pair_id,comment,Komentar_2,code,"upit
","pretvaranje int u string
","red sa prioritetom
","pretvaranje string u datum
","sortiranje string liste
","čuvanje liste u datoteku
","postgresql konekcija
","konfuziona matrica
","postavljanje radnog direktorijuma
","grupisanje po izbrojanim podacima
","binomna raspodela
","aes šifrovanje
","linearna regresija
","vreme tolerisanja za prijem na soketu
","upisivanje u csv datoteku
","pretvaranje decimalnog u heksadecimalni broj
","izvoz podataka u excel
","dijagram rasejanja
","pretvaranje json u csv
","lepo ispiši json
","zamena delova datoteke
","klasterizacija metodom k-srednjih vrednosti
","povezivanje na sql server
","html šifrovan string
","određivanje proteklog vremena korišćenjem časovnika
","parsiranje binarne datoteke u prilagođenu klasu
","dohvatanje trenutne ip adrese
","pretvaranje int u bool
","isčitavanje tekstualne datoteke liniju po liniju
","dohvatanje putanje izvršavanja
","odprema json datoteke pomoću HttpClient POST zahteva
","dohvatanje unutrašnjeg svojstva html taga
","pretvaranje string u broj
","formatiranje datuma
","nepromenjivi (readonly) niz
","filtriranje niza
","mapa u json
","parsiranje json datoteke
","dohvati trenutnu vrednost posmatrača
","dohvati naziv za vrednost enumerisanog tipa podatka
","šifriraj url
","kreiraj kolačić
","kako isprazniti niz
","kako dohvatiti današnji datum
","kako štiklirati checkbox
","inicijalizacija niza
","kako obrnuti string
","pročitaj svojstva datoteke
","prekopiraj u klibord
","pretvaranje html stranice u pdf
","konverzija json u xml datoteku
","kako nasumično izabrati broj
","normalna raspodela
","Nelder-Mead optimizacija
","hashset za određivanje broja različitih elemenata
","kako dohvatiti naziv tabele iz baze
","deserializacija json-a
","pronađi int unutar stringa
","dohvatanje jedinstvenog identifikatora trenutnog procesa
","regex ne razlikuje velika i mala slova
","prilagođeni http odgovor greške
","kako odrediti da li je string valida reč
","zamena http entiteta
","sakrij atribute datoteke
","sortiraj više nizova na osnovu redosleda drugih sortiranih nizova
","levenshteinova slicnost stringova
","kako dohvatiti html kod sa veb sajta
","baferisano čitanje teksta čitačem fajlova
","aes šifrovanje u ctr načinu rada
","matrica množenja
","štampanje rezimea modela
","jedinstveni elementi
","izvlačenje podataka iz sadržaja html koda
","toplotna mapa iz 3d koordinata
","dohvatanje svih roditelja xml čvora
","kako rekurzivno raspakovati zip datoteku
","podvuci tekst u label vidžetu
","raspakivanje velikih datoteka
","kopiranje putanje fajla
","dohvati opis http statusnog koda
","nasumično izvuci x stavki iz liste
","konvertuj string datum u yyyymmdd format
","pretvoriti utc vreme u epohu
","sve permutacije liste
","izvuci geografsku širinu i dužinu iz datog unosa
","kako proveriti da je checkbox štikliran
","pretvoriti uint8 niz u sliku
","memoizacija na disk - persistentna memoizacija
","parsiranje argumenata komandne linije
","kako pročitati sadržaj iz .gz zapakovanog fajla
","slanje binarnih podataka preko seriske veze
","otpakovanje podataka iz tekstualne datoteke
","pozicije podstingova u stringu
","čitanje elemenata iz html-a - <td>
","oduzimanje medijana iz svake kolone
","uklanjanja zaglavlja prilikom spajanja nekoliko datoteka
","parsiranje query stringa u url-u
","rangiranje fazi članova na osnovu stepena podudaranja
","izlaz u html datoteku
",kako efikasno pročitati .csv datoteku
cakephp_cakephp_FallbackPasswordHasher_1209," Returns true if the password need to be rehashed, with the first hasher present\n in the list of hashers\n\n @param string $password The password to verify\n @return bool\n"," Returns true if the password need to be rehashed, with the first hasher present",    public function needsRehash(string $password): bool    {        return $this->_hashers[0]->needsRehash($password);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
cakephp_cakephp_FormAuthenticate_1211, Checks the fields to ensure they are supplied.\n\n @param \\Cake\\Http\\ServerRequest $request The request that contains login information.\n @param array $fields The fields to be checked.\n @return bool False if the fields have not been supplied. True if they exist.\n, Checks the fields to ensure they are supplied.,"    protected function _checkFields(ServerRequest $request, array $fields): bool    {        foreach ([$fields['username'], $fields['password']] as $field) {            $value = $request->getData($field);            if (empty($value) || !is_string($value)) {                return false;            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
cakephp_cakephp_basics_1171, Command to return the eval-able code to startup PsySH in interactive debugger\\n Works the same way as eval(\\\\Psy\\\\sh());\\n psy/psysh must be loaded in your project\\n\\n ```\\n eval(breakpoint());\\n ```\\n\\n @return string|null\\n @link http://psysh.org/\\n, Command to return the eval-able code to startup PsySH in interactive debugger,"    function breakpoint(): ?string    {        if ((PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') && class_exists(PsyShell::class)) {            return 'extract(\Psy\Shell::debug(get_defined_vars(), isset($this) ? $this : null));';        }        trigger_error(            'psy/psysh must be installed and you must be in a CLI environment to use the breakpoint function',            E_USER_WARNING        );        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Cache_2478, Copy a file out of the cache\n, Copy a file out of the cache,"    public function copyTo($file, $target)    {        if ($this->enabled) {            $file = preg_replace('{[^'.$this->allowlist.']}i', '-', $file);            if (file_exists($this->root . $file)) {                try {                    touch($this->root . $file, filemtime($this->root . $file), time());                } catch (\ErrorException $e) {                    // fallback in case the above failed due to incorrect ownership                    // see https://github.com/composer/composer/issues/4070                    Silencer::call('touch', $this->root . $file);                }                $this->io->writeError('Reading '.$this->root . $file.' from cache', true, IOInterface::DEBUG);                return copy($this->root . $file, $target);            }        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_ClassLoader_2573, Turns on searching the include path for class files.\n\n @param bool $useIncludePath\n, Turns on searching the include path for class files.,    public function setUseIncludePath($useIncludePath)    {        $this->useIncludePath = $useIncludePath;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_ClassLoader_2581," Finds the path to the file where the class is defined.\n\n @param string $class The name of the class\n\n @return string|false The path if found, false otherwise\n", Finds the path to the file where the class is defined.,"    public function findFile($class)    {        // class map lookup        if (isset($this->classMap[$class])) {            return $this->classMap[$class];        }        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {            return false;        }        if (null !== $this->apcuPrefix) {            $file = apcu_fetch($this->apcuPrefix.$class, $hit);            if ($hit) {                return $file;            }        }        $file = $this->findFileWithExtension($class, '.php');        // Search for Hack files if we are running on HHVM        if (false === $file && defined('HHVM_VERSION')) {            $file = $this->findFileWithExtension($class, '.hh');        }        if (null !== $this->apcuPrefix) {            apcu_add($this->apcuPrefix.$class, $file);        }        if (false === $file) {            // Remember that this class does not exist.            $this->missingClasses[$class] = true;        }        return $file;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Compiler_2479, The Compiler class compiles composer into a phar\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Jordi Boggiano <j.boggiano@seld.be>\n, The Compiler class compiles composer into a phar,"class Compiler{    private $version;    private $branchAliasVersion = '';    private $versionDate;    /**     * Compiles composer into a single phar file     *     * @param  string            $pharFile The full path to the file to create     * @throws \RuntimeException     */    public function compile($pharFile = 'composer.phar')    {        if (file_exists($pharFile)) {            unlink($pharFile);        }        $process = new Process('git log --pretty=""%H"" -n1 HEAD', __DIR__);        if ($process->run() != 0) {            throw new \RuntimeException('Can\'t run git log. You must ensure to run compile from composer git repository clone and that git binary is available.');        }        $this->version = trim($process->getOutput());        $process = new Process('git log -n1 --pretty=%ci HEAD', __DIR__);        if ($process->run() != 0) {            throw new \RuntimeException('Can\'t run git log. You must ensure to run compile from composer git repository clone and that git binary is available.');        }        $this->versionDate = new \DateTime(trim($process->getOutput()));        $this->versionDate->setTimezone(new \DateTimeZone('UTC'));        $process = new Process('git describe --tags --exact-match HEAD');        if ($process->run() == 0) {            $this->version = trim($process->getOutput());        } else {            // get branch-alias defined in composer.json for dev-master (if any)            $localConfig = __DIR__.'/../../composer.json';            $file = new JsonFile($localConfig);            $localConfig = $file->read();            if (isset($localConfig['extra']['branch-alias']['dev-master'])) {                $this->branchAliasVersion = $localConfig['extra']['branch-alias']['dev-master'];            }        }        $phar = new \Phar($pharFile, 0, 'composer.phar');        $phar->setSignatureAlgorithm(\Phar::SHA1);        $phar->startBuffering();        $finderSort = function ($a, $b) {            return strcmp(strtr($a->getRealPath(), '\\', '/'), strtr($b->getRealPath(), '\\', '/'));        };        // Add Composer sources        $finder = new Finder();        $finder->files()            ->ignoreVCS(true)            ->name('*.php')            ->notName('Compiler.php')            ->notName('ClassLoader.php')            ->notName('InstalledVersions.php')            ->in(__DIR__.'/..')            ->sort($finderSort)        ;        foreach ($finder as $file) {            $this->addFile($phar, $file);        }        // Add runtime utilities separately to make sure they retains the docblocks as these will get copied into projects        $this->addFile($phar, new \SplFileInfo(__DIR__ . '/Autoload/ClassLoader.php'), false);        $this->addFile($phar, new \SplFileInfo(__DIR__ . '/InstalledVersions.php'), false);        // Add Composer resources        $finder = new Finder();        $finder->files()            ->in(__DIR__.'/../../res')            ->sort($finderSort)        ;        foreach ($finder as $file) {            $this->addFile($phar, $file, false);        }        // Add vendor files        $finder = new Finder();        $finder->files()            ->ignoreVCS(true)            ->notPath('/\/(composer\.(json|lock)|[A-Z]+\.md|\.gitignore|appveyor.yml|phpunit\.xml\.dist|phpstan\.neon\.dist|phpstan-config\.neon)$/')            ->notPath('/bin\/(jsonlint|validate-json|simple-phpunit)(\.bat)?$/')            ->notPath('symfony/debug/Resources/ext/')            ->notPath('justinrainbow/json-schema/demo/')            ->notPath('justinrainbow/json-schema/dist/')            ->notPath('composer/installed.json')            ->notPath('composer/LICENSE')            ->exclude('Tests')            ->exclude('tests')            ->exclude('docs')            ->in(__DIR__.'/../../vendor/')            ->sort($finderSort)        ;        $extraFiles = array(            realpath(__DIR__ . '/../../vendor/composer/spdx-licenses/res/spdx-exceptions.json'),            realpath(__DIR__ . '/../../vendor/composer/spdx-licenses/res/spdx-licenses.json'),            realpath(CaBundle::getBundledCaBundlePath()),            realpath(__DIR__ . '/../../vendor/symfony/console/Resources/bin/hiddeninput.exe'),            realpath(__DIR__ . '/../../vendor/symfony/polyfill-mbstring/Resources/mb_convert_variables.php8'),        );        $unexpectedFiles = array();        foreach ($finder as $file) {            if (in_array(realpath($file), $extraFiles, true)) {                unset($extraFiles[array_search(realpath($file), $extraFiles, true)]);            } elseif (!preg_match('{([/\\\\]LICENSE|\.php)$}', $file)) {                $unexpectedFiles[] = (string) $file;            }            if (preg_match('{\.php[\d.]*$}', $file)) {                $this->addFile($phar, $file);            } else {                $this->addFile($phar, $file, false);            }        }        if ($extraFiles) {            throw new \RuntimeException('These files were expected but not added to the phar, they might be excluded or gone from the source package:'.PHP_EOL.implode(PHP_EOL, $extraFiles));        }        if ($unexpectedFiles) {            throw new \RuntimeException('These files were unexpectedly added to the phar, make sure they are excluded or listed in $extraFiles:'.PHP_EOL.implode(PHP_EOL, $unexpectedFiles));        }        // Add bin/composer        $this->addComposerBin($phar);        // Stubs        $phar->setStub($this->getStub());        $phar->stopBuffering();        // disabled for interoperability with systems without gzip ext        // $phar->compressFiles(\Phar::GZ);        $this->addFile($phar, new \SplFileInfo(__DIR__.'/../../LICENSE'), false);        unset($phar);        // re-sign the phar with reproducible timestamp / signature        $util = new Timestamps($pharFile);        $util->updateTimestamps($this->versionDate);        $util->save($pharFile, \Phar::SHA1);        Linter::lint($pharFile);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Config_2509, Replaces {$refs} inside a config string\n\n @param  string|int|null $value a config string that can contain {$refs-to-other-config}\n @param  int             $flags Options (see class constants)\n @return string|int|null\n, Replaces {$refs} inside a config string,"    private function process($value, $flags)    {        $config = $this;        if (!is_string($value)) {            return $value;        }        return preg_replace_callback('#\{\$(.+)\}#', function ($match) use ($config, $flags) {            return $config->get($match[1], $flags);        }, $value);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Config_2511, Reads the value of a Composer environment variable\n\n This should be used to read COMPOSER_ environment variables\n that overload config values.\n\n @param  string      $var\n @return string|bool\n, Reads the value of a Composer environment variable,    private function getComposerEnv($var)    {        if ($this->useEnvironment) {            return getenv($var);        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Config_2512," Used by long-running custom scripts in composer.json\n\n ""scripts"": {\n   ""watch"": [\n     ""Composer\\\\Config::disableProcessTimeout"",\n     ""vendor/bin/long-running-script --watch""\n   ]\n }\n", Used by long-running custom scripts in composer.json,    public static function disableProcessTimeout()    {        // Override global timeout set earlier by environment or config        ProcessExecutor::setTimeout(0);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Installer_2543, Replace local repositories with InstalledArrayRepository instances\n\n This is to prevent any accidental modification of the existing repos on disk\n\n @param RepositoryManager $rm\n, Replace local repositories with InstalledArrayRepository instances,"    private function mockLocalRepositories(RepositoryManager $rm)    {        $packages = array();        foreach ($rm->getLocalRepository()->getPackages() as $package) {            $packages[(string) $package] = clone $package;        }        foreach ($packages as $key => $package) {            if ($package instanceof AliasPackage) {                $alias = (string) $package->getAliasOf();                $className = get_class($package);                $packages[$key] = new $className($packages[$alias], $package->getVersion(), $package->getPrettyVersion());            }        }        $rm->setLocalRepository(            new InstalledArrayRepository($packages)        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_StaticStringy_10256," Creates an instance of Stringy and invokes the given method with the\n rest of the passed arguments. The optional encoding is expected to be\n the last argument. For example, the following:\n StaticStringy::slice('fòôbàř', 0, 3, 'UTF-8'); translates to\n Stringy::create('fòôbàř', 'UTF-8')->slice(0, 3);\n The result is not cast, so the return value may be of type Stringy,\n integer, boolean, etc.\n\n @param string  $name\n @param mixed[] $arguments\n\n @return Stringy\n\n @throws \\BadMethodCallException\n", Creates an instance of Stringy and invokes the given method with the,"    public static function __callStatic($name, $arguments)    {        if (!static::$methodArgs) {            $stringyClass = new ReflectionClass('Stringy\Stringy');            $methods = $stringyClass->getMethods(ReflectionMethod::IS_PUBLIC);            foreach ($methods as $method) {                $params = $method->getNumberOfParameters() + 2;                static::$methodArgs[$method->name] = $params;            }        }        if (!isset(static::$methodArgs[$name])) {            throw new BadMethodCallException($name . ' is not a valid method');        }        $numArgs = count($arguments);        $str = ($numArgs) ? $arguments[0] : '';        if ($numArgs === static::$methodArgs[$name]) {            $args = array_slice($arguments, 1, -1);            $encoding = $arguments[$numArgs - 1];        } else {            $args = array_slice($arguments, 1);            $encoding = null;        }        $stringy = Stringy::create($str, $encoding);        $result = call_user_func_array([$stringy, $name], $args);        $cast = function($val) {            if (is_object($val) && $val instanceof Stringy) {                return (string) $val;            } else {                return $val;            }        };        return is_array($result) ? array_map($cast, $result) : $cast($result);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10281," Returns true if the string is serialized, false otherwise.\n\n @return bool Whether or not $str is serialized\n"," Returns true if the string is serialized, false otherwise.",    public function isSerialized()    {        return $this->str === 'b:0;' || @unserialize($this->str) !== false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10289," Returns the longest common substring between the string and $otherStr.\n In the case of ties, it returns that which occurs first.\n\n @param  string $otherStr Second string for comparison\n @return static Object with its $str being the longest common substring\n", Returns the longest common substring between the string and $otherStr.,"    public function longestCommonSubstring($otherStr)    {        // Uses dynamic programming to solve        // http://en.wikipedia.org/wiki/Longest_common_substring_problem        $encoding = $this->encoding;        $stringy = static::create($this->str, $encoding);        $strLength = $stringy->length();        $otherLength = \mb_strlen($otherStr, $encoding);        // Return if either string is empty        if ($strLength == 0 || $otherLength == 0) {            $stringy->str = '';            return $stringy;        }        $len = 0;        $end = 0;        $table = array_fill(0, $strLength + 1,            array_fill(0, $otherLength + 1, 0));        for ($i = 1; $i <= $strLength; $i++) {            for ($j = 1; $j <= $otherLength; $j++) {                $strChar = \mb_substr($stringy->str, $i - 1, 1, $encoding);                $otherChar = \mb_substr($otherStr, $j - 1, 1, $encoding);                if ($strChar == $otherChar) {                    $table[$i][$j] = $table[$i - 1][$j - 1] + 1;                    if ($table[$i][$j] > $len) {                        $len = $table[$i][$j];                        $end = $i;                    }                } else {                    $table[$i][$j] = 0;                }            }        }        $stringy->str = \mb_substr($stringy->str, $end - $len, $len, $encoding);        return $stringy;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10297," Returns a new string with the suffix $substring removed, if present.\n\n @param  string $substring The suffix to remove\n @return static Object having a $str without the suffix $substring\n"," Returns a new string with the suffix $substring removed, if present.","    public function removeRight($substring)    {        $stringy = static::create($this->str, $this->encoding);        if ($stringy->endsWith($substring)) {            $substringLength = \mb_strlen($substring, $stringy->encoding);            return $stringy->substr(0, $stringy->length() - $substringLength);        }        return $stringy;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10298, Returns a repeated string given a multiplier. An alias for str_repeat.\n\n @param  int    $multiplier The number of times to repeat the string\n @return static Object with a repeated str\n, Returns a repeated string given a multiplier. An alias for str_repeat.,"    public function repeat($multiplier)    {        $repeated = str_repeat($this->str, $multiplier);        return static::create($repeated, $this->encoding);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10299, Replaces all occurrences of $search in $str by $replacement.\n\n @param  string $search      The needle to search for\n @param  string $replacement The string to replace with\n @return static Object with the resulting $str after the replacements\n, Replaces all occurrences of $search in $str by $replacement.,"    public function replace($search, $replacement)    {        return $this->regexReplace(preg_quote($search), $replacement);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10303, Surrounds $str with the given substring.\n\n @param  string $substring The substring to add to both sides\n @return static Object whose $str had the substring both prepended and\n                 appended\n, Surrounds $str with the given substring.,"    public function surround($substring)    {        $str = implode('', [$substring, $this->str, $substring]);        return static::create($str, $this->encoding);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10304, Returns a case swapped version of the string.\n\n @return static Object whose $str has each character's case swapped\n, Returns a case swapped version of the string.,"    public function swapCase()    {        $stringy = static::create($this->str, $this->encoding);        $encoding = $stringy->encoding;        $stringy->str = preg_replace_callback(            '/[\S]/u',            function ($match) use ($encoding) {                if ($match[0] == \mb_strtoupper($match[0], $encoding)) {                    return \mb_strtolower($match[0], $encoding);                }                return \mb_strtoupper($match[0], $encoding);            },            $stringy->str        );        return $stringy;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10305," Returns a string with smart quotes, ellipsis characters, and dashes from\n Windows-1252 (commonly used in Word documents) replaced by their ASCII\n equivalents.\n\n @return static Object whose $str has those characters removed\n"," Returns a string with smart quotes, ellipsis characters, and dashes from","    public function tidy()    {        $str = preg_replace([            '/\x{2026}/u',            '/[\x{201C}\x{201D}]/u',            '/[\x{2018}\x{2019}]/u',            '/[\x{2013}\x{2014}]/u',        ], [            '...',            '""',            ""'"",            '-',        ], $this->str);        return static::create($str, $this->encoding);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10311," Returns an UpperCamelCase version of the supplied string. It trims\n surrounding spaces, capitalizes letters following digits, spaces, dashes\n and underscores, and removes spaces, dashes, underscores.\n\n @return static Object with $str in UpperCamelCase\n", Returns an UpperCamelCase version of the supplied string. It trims,    public function upperCamelize()    {        return $this->camelize()->upperCaseFirst();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10313, Returns the replacements for the toAscii() method.\n\n @return array An array of replacements.\n, Returns the replacements for the toAscii() method.,"    protected function charsArray()    {        static $charsArray;        if (isset($charsArray)) return $charsArray;        return $charsArray = [            '0'     => ['°', '₀', '۰', '０'],            '1'     => ['¹', '₁', '۱', '１'],            '2'     => ['²', '₂', '۲', '２'],            '3'     => ['³', '₃', '۳', '３'],            '4'     => ['⁴', '₄', '۴', '٤', '４'],            '5'     => ['⁵', '₅', '۵', '٥', '５'],            '6'     => ['⁶', '₆', '۶', '٦', '６'],            '7'     => ['⁷', '₇', '۷', '７'],            '8'     => ['⁸', '₈', '۸', '８'],            '9'     => ['⁹', '₉', '۹', '９'],            'a'     => ['à', 'á', 'ả', 'ã', 'ạ', 'ă', 'ắ', 'ằ', 'ẳ', 'ẵ',                        'ặ', 'â', 'ấ', 'ầ', 'ẩ', 'ẫ', 'ậ', 'ā', 'ą', 'å',                        'α', 'ά', 'ἀ', 'ἁ', 'ἂ', 'ἃ', 'ἄ', 'ἅ', 'ἆ', 'ἇ',                        'ᾀ', 'ᾁ', 'ᾂ', 'ᾃ', 'ᾄ', 'ᾅ', 'ᾆ', 'ᾇ', 'ὰ', 'ά',                        'ᾰ', 'ᾱ', 'ᾲ', 'ᾳ', 'ᾴ', 'ᾶ', 'ᾷ', 'а', 'أ', 'အ',                        'ာ', 'ါ', 'ǻ', 'ǎ', 'ª', 'ა', 'अ', 'ا', 'ａ', 'ä'],            'b'     => ['б', 'β', 'ب', 'ဗ', 'ბ', 'ｂ'],            'c'     => ['ç', 'ć', 'č', 'ĉ', 'ċ', 'ｃ'],            'd'     => ['ď', 'ð', 'đ', 'ƌ', 'ȡ', 'ɖ', 'ɗ', 'ᵭ', 'ᶁ', 'ᶑ',                        'д', 'δ', 'د', 'ض', 'ဍ', 'ဒ', 'დ', 'ｄ'],            'e'     => ['é', 'è', 'ẻ', 'ẽ', 'ẹ', 'ê', 'ế', 'ề', 'ể', 'ễ',                        'ệ', 'ë', 'ē', 'ę', 'ě', 'ĕ', 'ė', 'ε', 'έ', 'ἐ',                        'ἑ', 'ἒ', 'ἓ', 'ἔ', 'ἕ', 'ὲ', 'έ', 'е', 'ё', 'э',                        'є', 'ə', 'ဧ', 'ေ', 'ဲ', 'ე', 'ए', 'إ', 'ئ', 'ｅ'],            'f'     => ['ф', 'φ', 'ف', 'ƒ', 'ფ', 'ｆ'],            'g'     => ['ĝ', 'ğ', 'ġ', 'ģ', 'г', 'ґ', 'γ', 'ဂ', 'გ', 'گ',                        'ｇ'],            'h'     => ['ĥ', 'ħ', 'η', 'ή', 'ح', 'ه', 'ဟ', 'ှ', 'ჰ', 'ｈ'],            'i'     => ['í', 'ì', 'ỉ', 'ĩ', 'ị', 'î', 'ï', 'ī', 'ĭ', 'į',                        'ı', 'ι', 'ί', 'ϊ', 'ΐ', 'ἰ', 'ἱ', 'ἲ', 'ἳ', 'ἴ',                        'ἵ', 'ἶ', 'ἷ', 'ὶ', 'ί', 'ῐ', 'ῑ', 'ῒ', 'ΐ', 'ῖ',                        'ῗ', 'і', 'ї', 'и', 'ဣ', 'ိ', 'ီ', 'ည်', 'ǐ', 'ი',                        'इ', 'ی', 'ｉ'],            'j'     => ['ĵ', 'ј', 'Ј', 'ჯ', 'ج', 'ｊ'],            'k'     => ['ķ', 'ĸ', 'к', 'κ', 'Ķ', 'ق', 'ك', 'က', 'კ', 'ქ',                        'ک', 'ｋ'],            'l'     => ['ł', 'ľ', 'ĺ', 'ļ', 'ŀ', 'л', 'λ', 'ل', 'လ', 'ლ',                        'ｌ'],            'm'     => ['м', 'μ', 'م', 'မ', 'მ', 'ｍ'],            'n'     => ['ñ', 'ń', 'ň', 'ņ', 'ŉ', 'ŋ', 'ν', 'н', 'ن', 'န',                        'ნ', 'ｎ'],            'o'     => ['ó', 'ò', 'ỏ', 'õ', 'ọ', 'ô', 'ố', 'ồ', 'ổ', 'ỗ',                        'ộ', 'ơ', 'ớ', 'ờ', 'ở', 'ỡ', 'ợ', 'ø', 'ō', 'ő',                        'ŏ', 'ο', 'ὀ', 'ὁ', 'ὂ', 'ὃ', 'ὄ', 'ὅ', 'ὸ', 'ό',                        'о', 'و', 'θ', 'ို', 'ǒ', 'ǿ', 'º', 'ო', 'ओ', 'ｏ',                        'ö'],            'p'     => ['п', 'π', 'ပ', 'პ', 'پ', 'ｐ'],            'q'     => ['ყ', 'ｑ'],            'r'     => ['ŕ', 'ř', 'ŗ', 'р', 'ρ', 'ر', 'რ', 'ｒ'],            's'     => ['ś', 'š', 'ş', 'с', 'σ', 'ș', 'ς', 'س', 'ص', 'စ',                        'ſ', 'ს', 'ｓ'],            't'     => ['ť', 'ţ', 'т', 'τ', 'ț', 'ت', 'ط', 'ဋ', 'တ', 'ŧ',                        'თ', 'ტ', 'ｔ'],            'u'     => ['ú', 'ù', 'ủ', 'ũ', 'ụ', 'ư', 'ứ', 'ừ', 'ử', 'ữ',                        'ự', 'û', 'ū', 'ů', 'ű', 'ŭ', 'ų', 'µ', 'у', 'ဉ',                        'ု', 'ူ', 'ǔ', 'ǖ', 'ǘ', 'ǚ', 'ǜ', 'უ', 'उ', 'ｕ',                        'ў', 'ü'],            'v'     => ['в', 'ვ', 'ϐ', 'ｖ'],            'w'     => ['ŵ', 'ω', 'ώ', 'ဝ', 'ွ', 'ｗ'],            'x'     => ['χ', 'ξ', 'ｘ'],            'y'     => ['ý', 'ỳ', 'ỷ', 'ỹ', 'ỵ', 'ÿ', 'ŷ', 'й', 'ы', 'υ',                        'ϋ', 'ύ', 'ΰ', 'ي', 'ယ', 'ｙ'],            'z'     => ['ź', 'ž', 'ż', 'з', 'ζ', 'ز', 'ဇ', 'ზ', 'ｚ'],            'aa'    => ['ع', 'आ', 'آ'],            'ae'    => ['æ', 'ǽ'],            'ai'    => ['ऐ'],            'ch'    => ['ч', 'ჩ', 'ჭ', 'چ'],            'dj'    => ['ђ', 'đ'],            'dz'    => ['џ', 'ძ'],            'ei'    => ['ऍ'],            'gh'    => ['غ', 'ღ'],            'ii'    => ['ई'],            'ij'    => ['ĳ'],            'kh'    => ['х', 'خ', 'ხ'],            'lj'    => ['љ'],            'nj'    => ['њ'],            'oe'    => ['œ', 'ؤ'],            'oi'    => ['ऑ'],            'oii'   => ['ऒ'],            'ps'    => ['ψ'],            'sh'    => ['ш', 'შ', 'ش'],            'shch'  => ['щ'],            'ss'    => ['ß'],            'sx'    => ['ŝ'],            'th'    => ['þ', 'ϑ', 'ث', 'ذ', 'ظ'],            'ts'    => ['ц', 'ც', 'წ'],            'uu'    => ['ऊ'],            'ya'    => ['я'],            'yu'    => ['ю'],            'zh'    => ['ж', 'ჟ', 'ژ'],            '(c)'   => ['©'],            'A'     => ['Á', 'À', 'Ả', 'Ã', 'Ạ', 'Ă', 'Ắ', 'Ằ', 'Ẳ', 'Ẵ',                        'Ặ', 'Â', 'Ấ', 'Ầ', 'Ẩ', 'Ẫ', 'Ậ', 'Å', 'Ā', 'Ą',                        'Α', 'Ά', 'Ἀ', 'Ἁ', 'Ἂ', 'Ἃ', 'Ἄ', 'Ἅ', 'Ἆ', 'Ἇ',                        'ᾈ', 'ᾉ', 'ᾊ', 'ᾋ', 'ᾌ', 'ᾍ', 'ᾎ', 'ᾏ', 'Ᾰ', 'Ᾱ',                        'Ὰ', 'Ά', 'ᾼ', 'А', 'Ǻ', 'Ǎ', 'Ａ', 'Ä'],            'B'     => ['Б', 'Β', 'ब', 'Ｂ'],            'C'     => ['Ç','Ć', 'Č', 'Ĉ', 'Ċ', 'Ｃ'],            'D'     => ['Ď', 'Ð', 'Đ', 'Ɖ', 'Ɗ', 'Ƌ', 'ᴅ', 'ᴆ', 'Д', 'Δ',                        'Ｄ'],            'E'     => ['É', 'È', 'Ẻ', 'Ẽ', 'Ẹ', 'Ê', 'Ế', 'Ề', 'Ể', 'Ễ',                        'Ệ', 'Ë', 'Ē', 'Ę', 'Ě', 'Ĕ', 'Ė', 'Ε', 'Έ', 'Ἐ',                        'Ἑ', 'Ἒ', 'Ἓ', 'Ἔ', 'Ἕ', 'Έ', 'Ὲ', 'Е', 'Ё', 'Э',                        'Є', 'Ə', 'Ｅ'],            'F'     => ['Ф', 'Φ', 'Ｆ'],            'G'     => ['Ğ', 'Ġ', 'Ģ', 'Г', 'Ґ', 'Γ', 'Ｇ'],            'H'     => ['Η', 'Ή', 'Ħ', 'Ｈ'],            'I'     => ['Í', 'Ì', 'Ỉ', 'Ĩ', 'Ị', 'Î', 'Ï', 'Ī', 'Ĭ', 'Į',                        'İ', 'Ι', 'Ί', 'Ϊ', 'Ἰ', 'Ἱ', 'Ἳ', 'Ἴ', 'Ἵ', 'Ἶ',                        'Ἷ', 'Ῐ', 'Ῑ', 'Ὶ', 'Ί', 'И', 'І', 'Ї', 'Ǐ', 'ϒ',                        'Ｉ'],            'J'     => ['Ｊ'],            'K'     => ['К', 'Κ', 'Ｋ'],            'L'     => ['Ĺ', 'Ł', 'Л', 'Λ', 'Ļ', 'Ľ', 'Ŀ', 'ल', 'Ｌ'],            'M'     => ['М', 'Μ', 'Ｍ'],            'N'     => ['Ń', 'Ñ', 'Ň', 'Ņ', 'Ŋ', 'Н', 'Ν', 'Ｎ'],            'O'     => ['Ó', 'Ò', 'Ỏ', 'Õ', 'Ọ', 'Ô', 'Ố', 'Ồ', 'Ổ', 'Ỗ',                        'Ộ', 'Ơ', 'Ớ', 'Ờ', 'Ở', 'Ỡ', 'Ợ', 'Ø', 'Ō', 'Ő',                        'Ŏ', 'Ο', 'Ό', 'Ὀ', 'Ὁ', 'Ὂ', 'Ὃ', 'Ὄ', 'Ὅ', 'Ὸ',                        'Ό', 'О', 'Θ', 'Ө', 'Ǒ', 'Ǿ', 'Ｏ', 'Ö'],            'P'     => ['П', 'Π', 'Ｐ'],            'Q'     => ['Ｑ'],            'R'     => ['Ř', 'Ŕ', 'Р', 'Ρ', 'Ŗ', 'Ｒ'],            'S'     => ['Ş', 'Ŝ', 'Ș', 'Š', 'Ś', 'С', 'Σ', 'Ｓ'],            'T'     => ['Ť', 'Ţ', 'Ŧ', 'Ț', 'Т', 'Τ', 'Ｔ'],            'U'     => ['Ú', 'Ù', 'Ủ', 'Ũ', 'Ụ', 'Ư', 'Ứ', 'Ừ', 'Ử', 'Ữ',                        'Ự', 'Û', 'Ū', 'Ů', 'Ű', 'Ŭ', 'Ų', 'У', 'Ǔ', 'Ǖ',                        'Ǘ', 'Ǚ', 'Ǜ', 'Ｕ', 'Ў', 'Ü'],            'V'     => ['В', 'Ｖ'],            'W'     => ['Ω', 'Ώ', 'Ŵ', 'Ｗ'],            'X'     => ['Χ', 'Ξ', 'Ｘ'],            'Y'     => ['Ý', 'Ỳ', 'Ỷ', 'Ỹ', 'Ỵ', 'Ÿ', 'Ῠ', 'Ῡ', 'Ὺ', 'Ύ',                        'Ы', 'Й', 'Υ', 'Ϋ', 'Ŷ', 'Ｙ'],            'Z'     => ['Ź', 'Ž', 'Ż', 'З', 'Ζ', 'Ｚ'],            'AE'    => ['Æ', 'Ǽ'],            'Ch'    => ['Ч'],            'Dj'    => ['Ђ'],            'Dz'    => ['Џ'],            'Gx'    => ['Ĝ'],            'Hx'    => ['Ĥ'],            'Ij'    => ['Ĳ'],            'Jx'    => ['Ĵ'],            'Kh'    => ['Х'],            'Lj'    => ['Љ'],            'Nj'    => ['Њ'],            'Oe'    => ['Œ'],            'Ps'    => ['Ψ'],            'Sh'    => ['Ш'],            'Shch'  => ['Щ'],            'Ss'    => ['ẞ'],            'Th'    => ['Þ'],            'Ts'    => ['Ц'],            'Ya'    => ['Я'],            'Yu'    => ['Ю'],            'Zh'    => ['Ж'],            ' '     => [""\xC2\xA0"", ""\xE2\x80\x80"", ""\xE2\x80\x81"",                        ""\xE2\x80\x82"", ""\xE2\x80\x83"", ""\xE2\x80\x84"",                        ""\xE2\x80\x85"", ""\xE2\x80\x86"", ""\xE2\x80\x87"",                        ""\xE2\x80\x88"", ""\xE2\x80\x89"", ""\xE2\x80\x8A"",                        ""\xE2\x80\xAF"", ""\xE2\x81\x9F"", ""\xE3\x80\x80"",                        ""\xEF\xBE\xA0""],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
deployphp_deployer_Deployer_305, Init console application\\n, Init console application,    public function init()    {        $this->addTaskCommands();        $this->getConsole()->add(new AutocompleteCommand());        $this->getConsole()->add(new BlackjackCommand());        $this->getConsole()->add(new ConfigCommand($this));        $this->getConsole()->add(new WorkerCommand($this));        $this->getConsole()->add(new InitCommand());        $this->getConsole()->add(new TreeCommand($this));        $this->getConsole()->add(new SshCommand($this));        $this->getConsole()->add(new RunCommand($this));        if (self::isPharArchive()) {            $selfUpdate = new PharUpdateCommand('self-update');            $selfUpdate->setDescription('Updates deployer.phar to the latest version');            $selfUpdate->setManifestUri('https://deployer.org/manifest.json');            $this->getConsole()->add($selfUpdate);            $this->getConsole()->getHelperSet()->set(new PharUpdateHelper());        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
deployphp_deployer_Deployer_309, Run Deployer\\n, Run Deployer,"    public static function run(string $version, ?string $deployFile)    {        if (!defined('DEPLOYER_VERSION')) {            die(<<<TXT  Warning! Incompatible global and local versions.  Please, update your globally installed Deployer,  or run locally installed Deployer via:        \x1b[36mphp \x1b[38;1mvendor/bin/dep\x1b[0m   TXT);        }        $input = new ArgvInput();        $output = new ConsoleOutput();        try {            // Init Deployer            $console = new Application('Deployer', $version);            $deployer = new self($console);            // Import recipe file            if (is_readable($deployFile ?? '')) {                $deployer->importer->import($deployFile);            }            // Run Deployer            $deployer->init();            $console->run($input, $output);        } catch (Throwable $exception) {            if (str_contains(""$input"", ""-vvv"")) {                $output->setVerbosity(OutputInterface::VERBOSITY_DEBUG);            }            self::printException($output, $exception);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
deployphp_deployer_functions_1050," Returns hosts based on provided selector.\n\n ```php\n on(select('stage=prod, role=db'), function ($host) {\n     ...\n });\n ```\n\n @return Host[]\n", Returns hosts based on provided selector.,function select(string $selector): array{    return Deployer::get()->selector->select($selector);},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
deployphp_deployer_functions_1056, Execute a callback within a specific directory and revert back to the initial working directory.\n\n @return mixed|null Return value of the $callback function or null if callback doesn't return anything\n, Execute a callback within a specific directory and revert back to the initial working directory.,"function within(string $path, callable $callback){    $lastWorkingPath = get('working_path', '');    try {        set('working_path', parse($path));        return $callback();    } finally {        set('working_path', $lastWorkingPath);    }    return null;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
deployphp_deployer_functions_1059," Iterate other hosts, allowing to call run a func in callback.\n\n ```php\n on(select('stage=prod, role=db'), function ($host) {\n     ...\n });\n ```\n\n ```php\n on(getHost('prod'), function ($host) {\n     ...\n });\n ```\n\n ```php\n on(Deployer::get()->hosts, function ($host) {\n     ...\n });\n ```\n\n @param Host|Host[] $hosts\n"," Iterate other hosts, allowing to call run a func in callback.","function on($hosts, callable $callback): void{    if (!is_array($hosts) && !($hosts instanceof \Traversable)) {        $hosts = [$hosts];    }    foreach ($hosts as $host) {        if ($host instanceof Host) {            $host->config()->load();            Context::push(new Context($host, input(), output()));            try {                $callback($host);                $host->config()->save();            } catch (GracefulShutdownException $e) {                Deployer::get()->messenger->renderException($e, $host);            } finally {                Context::pop();            }        } else {            throw new \InvalidArgumentException(""Function on can iterate only on Host instances."");        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
deployphp_deployer_functions_1064, Setup configuration option.\n\n @param mixed $value\n, Setup configuration option.,"function set(string $name, $value): void{    if (!Context::has()) {        Deployer::get()->config->set($name, $value);    } else {        Context::get()->getConfig()->set($name, $value);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
deployphp_deployer_functions_319," Setup which task run on failure of $task.\\n When called multiple times for a task, previous fail() definitions will be overridden.\\n\\n @param string $task The task which need to fail so $that should be run.\\n @param string|callable $do The task to be run.\\n\\n @return Task|null\\n", Setup which task run on failure of $task.,"function fail(string $task, $do){    if (is_callable($do)) {        $newTask = task(""fail:$task"", $do);        fail($task, ""fail:$task"");        return $newTask;    }    $deployer = Deployer::get();    $deployer->fail->set($task, $do);    return null;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
deployphp_deployer_functions_326, Writes an info message.\\n, Writes an info message.,"function info(string $message): void{    writeln(""<fg=green;options=bold>info</> "" . parse($message));}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
deployphp_deployer_functions_331, Check if there is such configuration option.\\n, Check if there is such configuration option.,function has(string $name): bool{    if (!Context::has()) {        return Deployer::get()->config->has($name);    } else {        return Context::get()->getConfig()->has($name);    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dnoegel_php-xdg-base-dir_XdgTest_742, In fallback mode a directory should be created\n, In fallback mode a directory should be created,"    public function testGetRuntimeDirShouldCreateDirectory()    {        putenv('XDG_RUNTIME_DIR=');        $dir = $this->getXdg()->getRuntimeDir(false);        $permission = decoct(fileperms($dir) & 0777);        $this->assertEquals(700, $permission);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dnoegel_php-xdg-base-dir_XdgTest_743," Ensure, that the fallback directories are created with correct permission\\\\\\\\n"," Ensure, that the fallback directories are created with correct permission","    public function testGetRuntimeShouldDeleteDirsWithWrongPermission()    {        $runtimeDir = sys_get_temp_dir() . DIRECTORY_SEPARATOR . XdgBaseDir\Xdg::RUNTIME_DIR_FALLBACK . getenv('USER');        rmdir($runtimeDir);        mkdir($runtimeDir, 0764, true);        // Permission should be wrong now        $permission = decoct(fileperms($runtimeDir) & 0777);        $this->assertEquals(764, $permission);        putenv('XDG_RUNTIME_DIR=');        $dir = $this->getXdg()->getRuntimeDir(false);        // Permission should be fixed        $permission = decoct(fileperms($dir) & 0777);        $this->assertEquals(700, $permission);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dnoegel_php-xdg-base-dir_Xdg_732, Simple implementation of the XDG standard https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\\\\n\\\\n Based on the python implementation https://github.com/takluyver/pyxdg/blob/master/xdg/BaseDirectory.py\\\\n, Simple implementation of the XDG standard https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html,"class Xdg{    const S_IFDIR = 040000; // directory    const S_IRWXO = 00007;  // rwx other    const S_IRWXG = 00056;  // rwx group    const RUNTIME_DIR_FALLBACK = 'php-xdg-runtime-dir-fallback-';    /**     * @return string     */    public function getHomeDir()    {        return getenv('HOME') ?: (getenv('HOMEDRIVE') . DIRECTORY_SEPARATOR . getenv('HOMEPATH'));    }    /**     * @return string     */    public function getHomeConfigDir()    {        if ($path = getenv('XDG_CONFIG_HOME')) {            return $path;        }        $homeDir = $this->getHomeDir();        $path = DIRECTORY_SEPARATOR === $homeDir ? $homeDir.'.config' : $homeDir . DIRECTORY_SEPARATOR . '.config';        return $path;    }    /**     * @return string     */    public function getHomeDataDir()    {        $path = getenv('XDG_DATA_HOME') ?: $this->getHomeDir() . DIRECTORY_SEPARATOR . '.local' . DIRECTORY_SEPARATOR . 'share';        return $path;    }    /**     * @return array     */    public function getConfigDirs()    {        $configDirs = getenv('XDG_CONFIG_DIRS') ? explode(':', getenv('XDG_CONFIG_DIRS')) : array('/etc/xdg');        $paths = array_merge(array($this->getHomeConfigDir()), $configDirs);        return $paths;    }    /**     * @return array     */    public function getDataDirs()    {        $dataDirs = getenv('XDG_DATA_DIRS') ? explode(':', getenv('XDG_DATA_DIRS')) : array('/usr/local/share', '/usr/share');        $paths = array_merge(array($this->getHomeDataDir()), $dataDirs);        return $paths;    }    /**     * @return string     */    public function getHomeCacheDir()    {        $path = getenv('XDG_CACHE_HOME') ?: $this->getHomeDir() . DIRECTORY_SEPARATOR . '.cache';        return $path;    }    public function getRuntimeDir($strict=true)    {        if ($runtimeDir = getenv('XDG_RUNTIME_DIR')) {            return $runtimeDir;        }        if ($strict) {            throw new \RuntimeException('XDG_RUNTIME_DIR was not set');        }        $fallback = sys_get_temp_dir() . DIRECTORY_SEPARATOR . self::RUNTIME_DIR_FALLBACK . getenv('USER');        $create = false;        if (!is_dir($fallback)) {            mkdir($fallback, 0700, true);        }        $st = lstat($fallback);        # The fallback must be a directory        if (!$st['mode'] & self::S_IFDIR) {            rmdir($fallback);            $create = true;        } elseif ($st['uid'] != $this->getUid() ||            $st['mode'] & (self::S_IRWXG | self::S_IRWXO)        ) {            rmdir($fallback);            $create = true;        }        if ($create) {            mkdir($fallback, 0700, true);        }        return $fallback;    }    private function getUid()    {        if (function_exists('posix_getuid')) {            return posix_getuid();        }        return getmyuid();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cellmap_482, Remove a row group from the cellmap.\n\n @param Frame $group The group to remove\n, Remove a row group from the cellmap.,    public function remove_row_group(Frame $group)    {        $key = $group->get_id();        if (!isset($this->_frames[$key])) {            return; // Presumably this row has alredy been removed        }        $iter = $group->get_first_child();        while ($iter) {            $this->remove_row($iter);            $iter = $iter->get_next_sibling();        }        $this->_frames[$key] = null;        unset($this->_frames[$key]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_322," A toUnicode section, needed for unicode fonts\n\n @param $id\n @param $action\n @return null|string\n"," A toUnicode section, needed for unicode fonts","    protected function o_toUnicode($id, $action)    {        switch ($action) {            case 'new':                $this->objects[$id] = [                    't'    => 'toUnicode'                ];                break;            case 'add':                break;            case 'out':                $ordering = 'UCS';                $registry = 'Adobe';                if ($this->encrypted) {                    $this->encryptInit($id);                    $ordering = $this->ARC4($ordering);                    $registry = $this->filterText($this->ARC4($registry), false, false);                }                $stream = <<<EOT/CIDInit /ProcSet findresource begin12 dict beginbegincmap/CIDSystemInfo<</Registry ($registry)/Ordering ($ordering)/Supplement 0>> def/CMapName /Adobe-Identity-UCS def/CMapType 2 def1 begincodespacerange<0000> <FFFF>endcodespacerange1 beginbfrange<0000> <FFFF> <0000>endbfrangeendcmapCMapName currentdict /CMap defineresource popendendEOT;                $res = ""\n$id 0 obj\n"";                $res .= ""<</Length "" . mb_strlen($stream, '8bit') . "" >>\n"";                $res .= ""stream\n"" . $stream . ""\nendstream"" . ""\nendobj"";;                return $res;        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_326, initialize the encryption for processing a particular object\n\n @param $id\n, initialize the encryption for processing a particular object,"    function encryptInit($id)    {        $tmp = $this->encryptionKey;        $hex = dechex($id);        if (mb_strlen($hex, '8bit') < 6) {            $hex = substr('000000', 0, 6 - mb_strlen($hex, '8bit')) . $hex;        }        $tmp .= chr(hexdec(substr($hex, 4, 2)))            . chr(hexdec(substr($hex, 2, 2)))            . chr(hexdec(substr($hex, 0, 2)))            . chr(0)            . chr(0)        ;        $key = $this->md5_16($tmp);        $this->ARC4_init(substr($key, 0, 10));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_342, draw a bezier curve based on 4 control points\n\n @param $x1\n @param $y1\n @param $x2\n @param $y2\n @param $x3\n @param $y3\n, draw a bezier curve based on 4 control points,"    function curveTo($x1, $y1, $x2, $y2, $x3, $y3)    {        $this->addContent(sprintf(""\n%.3F %.3F %.3F %.3F %.3F %.3F c"", $x1, $y1, $x2, $y2, $x3, $y3));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_356," draw a clipping rounded rectangle, all the elements added after this will be clipped\n\n @param $x1\n @param $y1\n @param $w\n @param $h\n @param $rTL\n @param $rTR\n @param $rBR\n @param $rBL\n"," draw a clipping rounded rectangle, all the elements added after this will be clipped","    function clippingRectangleRounded($x1, $y1, $w, $h, $rTL, $rTR, $rBR, $rBL)    {        $this->save();        // start: top edge, left end        $this->addContent(sprintf(""\n%.3F %.3F m "", $x1, $y1 - $rTL + $h));        // line: bottom edge, left end        $this->addContent(sprintf(""\n%.3F %.3F l "", $x1, $y1 + $rBL));        // curve: bottom-left corner        $this->ellipse($x1 + $rBL, $y1 + $rBL, $rBL, 0, 0, 8, 180, 270, false, false, false, true);        // line: right edge, bottom end        $this->addContent(sprintf(""\n%.3F %.3F l "", $x1 + $w - $rBR, $y1));        // curve: bottom-right corner        $this->ellipse($x1 + $w - $rBR, $y1 + $rBR, $rBR, 0, 0, 8, 270, 360, false, false, false, true);        // line: right edge, top end        $this->addContent(sprintf(""\n%.3F %.3F l "", $x1 + $w, $y1 + $h - $rTR));        // curve: bottom-right corner        $this->ellipse($x1 + $w - $rTR, $y1 + $h - $rTR, $rTR, 0, 0, 8, 0, 90, false, false, false, true);        // line: bottom edge, right end        $this->addContent(sprintf(""\n%.3F %.3F l "", $x1 + $rTL, $y1 + $h));        // curve: top-right corner        $this->ellipse($x1 + $rTL, $y1 + $h - $rTL, $rTL, 0, 0, 8, 90, 180, false, false, false, true);        // line: top edge, left end        $this->addContent(sprintf(""\n%.3F %.3F l "", $x1 + $rBL, $y1));        // Close & clip        $this->addContent("" W n"");    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_359, translate\n\n @param float $t_x movement to the right\n @param float $t_y movement to the bottom\n,prevodi,"    function translate($t_x, $t_y)    {        $tm = [            1,            0,            0,            1,            $t_x,            -$t_y        ];        $this->transform($tm);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_363, return the height in units of the current font in the given size\n\n @param $size\n @return float|int\n, return the height in units of the current font in the given size,"    function getFontHeight($size)    {        if (!$this->numFonts) {            $this->selectFont($this->defaultFont);        }        $font = $this->fonts[$this->currentFont];        // for the current font, and the given size, what is the height of the font in user units        if (isset($font['Ascender']) && isset($font['Descender'])) {            $h = $font['Ascender'] - $font['Descender'];        } else {            $h = $font['FontBBox'][3] - $font['FontBBox'][1];        }        // have to adjust by a font offset for Windows fonts.  unfortunately it looks like        // the bounding box calculations are wrong and I don't know why.        if (isset($font['FontHeightOffset'])) {            // For CourierNew from Windows this needs to be -646 to match the            // Adobe native Courier font.            //            // For FreeMono from GNU this needs to be -337 to match the            // Courier font.            //            // Both have been added manually to the .afm and .ufm files.            $h += (int)$font['FontHeightOffset'];        }        return $size * $h / 1000;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_366," return array containing codepoints (UTF-8 character values) for the\n string passed in.\n\n based on the excellent TCPDF code by Nicola Asuni and the\n RFC for UTF-8 at http://www.faqs.org/rfcs/rfc3629.html\n\n @access private\n @author Orion Richardson\n @since  January 5, 2008\n\n @param string $text UTF-8 string to process\n\n @return array UTF-8 codepoints array for the string\n", return array containing codepoints (UTF-8 character values) for the,"    function utf8toCodePointsArray(&$text)    {        $length = mb_strlen($text, '8bit'); // http://www.php.net/manual/en/function.mb-strlen.php#77040        $unicode = []; // array containing unicode values        $bytes = []; // array containing single character byte sequences        $numbytes = 1; // number of octets needed to represent the UTF-8 character        for ($i = 0; $i < $length; $i++) {            $c = ord($text[$i]); // get one string character at time            if (count($bytes) === 0) { // get starting octect                if ($c <= 0x7F) {                    $unicode[] = $c; // use the character ""as is"" because is ASCII                    $numbytes = 1;                } elseif (($c >> 0x05) === 0x06) { // 2 bytes character (0x06 = 110 BIN)                    $bytes[] = ($c - 0xC0) << 0x06;                    $numbytes = 2;                } elseif (($c >> 0x04) === 0x0E) { // 3 bytes character (0x0E = 1110 BIN)                    $bytes[] = ($c - 0xE0) << 0x0C;                    $numbytes = 3;                } elseif (($c >> 0x03) === 0x1E) { // 4 bytes character (0x1E = 11110 BIN)                    $bytes[] = ($c - 0xF0) << 0x12;                    $numbytes = 4;                } else {                    // use replacement character for other invalid sequences                    $unicode[] = 0xFFFD;                    $bytes = [];                    $numbytes = 1;                }            } elseif (($c >> 0x06) === 0x02) { // bytes 2, 3 and 4 must start with 0x02 = 10 BIN                $bytes[] = $c - 0x80;                if (count($bytes) === $numbytes) {                    // compose UTF-8 bytes to a single unicode value                    $c = $bytes[0];                    for ($j = 1; $j < $numbytes; $j++) {                        $c += ($bytes[$j] << (($numbytes - $j - 1) * 0x06));                    }                    if ((($c >= 0xD800) and ($c <= 0xDFFF)) or ($c >= 0x10FFFF)) {                        // The definition of UTF-8 prohibits encoding character numbers between                        // U+D800 and U+DFFF, which are reserved for use with the UTF-16                        // encoding form (as surrogate pairs) and do not directly represent                        // characters.                        $unicode[] = 0xFFFD; // use replacement character                    } else {                        $unicode[] = $c; // add char to array                    }                    // reset data for next char                    $bytes = [];                    $numbytes = 1;                }            } else {                // use replacement character for other invalid sequences                $unicode[] = 0xFFFD;                $bytes = [];                $numbytes = 1;            }        }        return $unicode;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_367," given a start position and information about how text is to be laid out, calculate where\n on the page the text will end\n\n @param $x\n @param $y\n @param $angle\n @param $size\n @param $wa\n @param $text\n @return array\n"," given a start position and information about how text is to be laid out, calculate where","    private function getTextPosition($x, $y, $angle, $size, $wa, $text)    {        // given this information return an array containing x and y for the end position as elements 0 and 1        $w = $this->getTextWidth($size, $text);        // need to adjust for the number of spaces in this text        $words = explode(' ', $text);        $nspaces = count($words) - 1;        $w += $wa * $nspaces;        $a = deg2rad((float)$angle);        return [cos($a) * $w + $x, -sin($a) * $w + $y];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_372, close an object\n,zatvori objekat,"    function closeObject()    {        // close the object, as long as there was one open in the first place, which will be indicated by        // an objectId on the stack.        if ($this->nStack > 0) {            $this->currentContents = $this->stack[$this->nStack]['c'];            $this->currentPage = $this->stack[$this->nStack]['p'];            $this->nStack--;            // easier to probably not worry about removing the old entries, they will be overwritten            // if there are new ones.        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_374, return a storable representation of a specific object\n\n @param $id\n @return string|null\n, return a storable representation of a specific object,"    function serializeObject($id)    {        if (array_key_exists($id, $this->objects)) {            return serialize($this->objects[$id]);        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Dompdf_490, Restore the system's locale configuration\n, Restore the system's locale configuration,"    private function restorePhpConfig()    {        if (!empty($this->systemLocale)) {            setlocale(LC_NUMERIC, $this->systemLocale);            $this->systemLocale = null;        }        if (!empty($this->pcreJit)) {            @ini_set('pcre.jit', $this->pcreJit);            $this->pcreJit = null;        }        if (!empty($this->mbstringEncoding)) {            mb_internal_encoding($this->mbstringEncoding);            $this->mbstringEncoding = null;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Dompdf_494," Builds the {@link FrameTree}, loads any CSS and applies the styles to\n the {@link FrameTree}\n"," Builds the {@link FrameTree}, loads any CSS and applies the styles to","    private function processHtml()    {        $this->tree->build_tree();        $this->css->load_css_file($this->css->getDefaultStylesheet(), Stylesheet::ORIG_UA);        $acceptedmedia = Stylesheet::$ACCEPTED_GENERIC_MEDIA_TYPES;        $acceptedmedia[] = $this->options->getDefaultMediaType();        // <base href="""" />        $base_nodes = $this->dom->getElementsByTagName(""base"");        if ($base_nodes->length && ($href = $base_nodes->item(0)->getAttribute(""href""))) {            [$this->protocol, $this->baseHost, $this->basePath] = Helpers::explode_url($href);        }        // Set the base path of the Stylesheet to that of the file being processed        $this->css->set_protocol($this->protocol);        $this->css->set_host($this->baseHost);        $this->css->set_base_path($this->basePath);        // Get all the stylesheets so that they are processed in document order        $xpath = new DOMXPath($this->dom);        $stylesheets = $xpath->query(""//*[name() = 'link' or name() = 'style']"");        /** @var \DOMElement $tag */        foreach ($stylesheets as $tag) {            switch (strtolower($tag->nodeName)) {                // load <link rel=""STYLESHEET"" ... /> tags                case ""link"":                    if (mb_strtolower(stripos($tag->getAttribute(""rel""), ""stylesheet"") !== false) || // may be ""appendix stylesheet""                        mb_strtolower($tag->getAttribute(""type"")) === ""text/css""                    ) {                        //Check if the css file is for an accepted media type                        //media not given then always valid                        $formedialist = preg_split(""/[\s\n,]/"", $tag->getAttribute(""media""), -1, PREG_SPLIT_NO_EMPTY);                        if (count($formedialist) > 0) {                            $accept = false;                            foreach ($formedialist as $type) {                                if (in_array(mb_strtolower(trim($type)), $acceptedmedia)) {                                    $accept = true;                                    break;                                }                            }                            if (!$accept) {                                //found at least one mediatype, but none of the accepted ones                                //Skip this css file.                                break;                            }                        }                        $url = $tag->getAttribute(""href"");                        $url = Helpers::build_url($this->protocol, $this->baseHost, $this->basePath, $url);                        $this->css->load_css_file($url, Stylesheet::ORIG_AUTHOR);                    }                    break;                // load <style> tags                case ""style"":                    // Accept all <style> tags by default (note this is contrary to W3C                    // HTML 4.0 spec:                    // http://www.w3.org/TR/REC-html40/present/styles.html#adef-media                    // which states that the default media type is 'screen'                    if ($tag->hasAttributes() &&                        ($media = $tag->getAttribute(""media"")) &&                        !in_array($media, $acceptedmedia)                    ) {                        break;                    }                    $css = """";                    if ($tag->hasChildNodes()) {                        $child = $tag->firstChild;                        while ($child) {                            $css .= $child->nodeValue; // Handle <style><!-- blah --></style>                            $child = $child->nextSibling;                        }                    } else {                        $css = $tag->nodeValue;                    }                    // Set the base path of the Stylesheet to that of the file being processed                    $this->css->set_protocol($this->protocol);                    $this->css->set_host($this->baseHost);                    $this->css->set_base_path($this->basePath);                    $this->css->load_css($css, Stylesheet::ORIG_AUTHOR);                    break;            }            // Set the base path of the Stylesheet to that of the file being processed            $this->css->set_protocol($this->protocol);            $this->css->set_host($this->baseHost);            $this->css->set_base_path($this->basePath);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_FontMetrics_557, Calculates font height\n\n @param string $font\n @param float $size\n\n @return float\n, Calculates font height,"    public function getFontHeight($font, $size)    {        return $this->getCanvas()->get_font_height($font, $size);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Frame_576, Re-initialize the frame\n, Re-initialize the frame,"    public function reset()    {        $this->_position[""x""] = null;        $this->_position[""y""] = null;        $this->_containing_block[""x""] = null;        $this->_containing_block[""y""] = null;        $this->_containing_block[""w""] = null;        $this->_containing_block[""h""] = null;        $this->_style = null;        unset($this->_style);        $this->_style = clone $this->_original_style;        // If this represents a generated node then child nodes represent generated content.        // Remove the children since the content will be generated next time this frame is reflowed.         if ($this->_node->nodeName === ""dompdf_generated"" && $this->_style->content != ""normal"") {            foreach ($this->get_children() as $child) {                $this->remove_child($child);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Frame_588," Return the height of the margin box of the frame, in pt.  Meaningless\n unless the height has been calculated properly.\n\n @return float\n"," Return the height of the margin box of the frame, in pt.  Meaningless","    public function get_margin_height()    {        $style = $this->_style;        return (            (float)$style->length_in_pt(                [                    $style->height,                    (float)$style->length_in_pt(                        [                            $style->border_top_width,                            $style->border_bottom_width,                            $style->margin_top,                            $style->margin_bottom,                            $style->padding_top,                            $style->padding_bottom                        ], $this->_containing_block[""w""]                    )                ],                $this->_containing_block[""h""]            )        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Frame_592," Return the padding box (x,y,w,h) of the frame\n\n @return array\n"," Return the padding box (x,y,w,h) of the frame","    public function get_padding_box()    {        $style = $this->_style;        $cb = $this->_containing_block;        $x = $this->_position[""x""] +            (float)$style->length_in_pt(                [                    $style->margin_left,                    $style->border_left_width                ],                $cb[""w""]);        $y = $this->_position[""y""] +            (float)$style->length_in_pt(                [                    $style->margin_top,                    $style->border_top_width                ],                $cb[""h""]            );        $w = $style->length_in_pt(                [                    $style->padding_left,                    $style->width,                    $style->padding_right                ],                $cb[""w""]            );        $h = $style->length_in_pt(                [                    $style->padding_top,                    $style->padding_bottom,                    $style->length_in_pt($style->height, $cb[""h""])                ],                $cb[""w""]            );        return [0 => $x, ""x"" => $x,            1 => $y, ""y"" => $y,            2 => $w, ""w"" => $w,            3 => $h, ""h"" => $h];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Helpers_617, Decoder for RLE8 compression in windows bitmaps\n http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/bitmaps_6x0u.asp\n\n @param string $str Data to decode\n @param integer $width Image width\n\n @return string\n, Decoder for RLE8 compression in windows bitmaps,"    public static function rle8_decode($str, $width)    {        $lineWidth = $width + (3 - ($width - 1) % 4);        $out = '';        $cnt = strlen($str);        for ($i = 0; $i < $cnt; $i++) {            $o = ord($str[$i]);            switch ($o) {                case 0: # ESCAPE                    $i++;                    switch (ord($str[$i])) {                        case 0: # NEW LINE                            $padCnt = $lineWidth - strlen($out) % $lineWidth;                            if ($padCnt < $lineWidth) {                                $out .= str_repeat(chr(0), $padCnt); # pad line                            }                            break;                        case 1: # END OF FILE                            $padCnt = $lineWidth - strlen($out) % $lineWidth;                            if ($padCnt < $lineWidth) {                                $out .= str_repeat(chr(0), $padCnt); # pad line                            }                            break 3;                        case 2: # DELTA                            $i += 2;                            break;                        default: # ABSOLUTE MODE                            $num = ord($str[$i]);                            for ($j = 0; $j < $num; $j++) {                                $out .= $str[++$i];                            }                            if ($num % 2) {                                $i++;                            }                    }                    break;                default:                    $out .= str_repeat($str[++$i], $o);            }        }        return $out;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Helpers_619," parse a full url or pathname and return an array(protocol, host, path,\n file + query + fragment)\n\n @param string $url\n @return array\n"," parse a full url or pathname and return an array(protocol, host, path,","    public static function explode_url($url)    {        $protocol = """";        $host = """";        $path = """";        $file = """";        $arr = parse_url($url);        if ( isset($arr[""scheme""]) ) {            $arr[""scheme""] = mb_strtolower($arr[""scheme""]);        }        // Exclude windows drive letters...        if (isset($arr[""scheme""]) && $arr[""scheme""] !== ""file"" && strlen($arr[""scheme""]) > 1) {            $protocol = $arr[""scheme""] . ""://"";            if (isset($arr[""user""])) {                $host .= $arr[""user""];                if (isset($arr[""pass""])) {                    $host .= "":"" . $arr[""pass""];                }                $host .= ""@"";            }            if (isset($arr[""host""])) {                $host .= $arr[""host""];            }            if (isset($arr[""port""])) {                $host .= "":"" . $arr[""port""];            }            if (isset($arr[""path""]) && $arr[""path""] !== """") {                // Do we have a trailing slash?                if ($arr[""path""][mb_strlen($arr[""path""]) - 1] === ""/"") {                    $path = $arr[""path""];                    $file = """";                } else {                    $path = rtrim(dirname($arr[""path""]), '/\\') . ""/"";                    $file = basename($arr[""path""]);                }            }            if (isset($arr[""query""])) {                $file .= ""?"" . $arr[""query""];            }            if (isset($arr[""fragment""])) {                $file .= ""#"" . $arr[""fragment""];            }        } else {            $i = mb_stripos($url, ""file://"");            if ($i !== false) {                $url = mb_substr($url, $i + 7);            }            $protocol = """"; // ""file://""; ? why doesn't this work... It's because of            // network filenames like //COMPU/SHARENAME            $host = """"; // localhost, really            $file = basename($url);            $path = dirname($url);            // Check that the path exists            if ($path !== false) {                $path .= '/';            } else {                // generate a url to access the file if no real path found.                $protocol = isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on' ? 'https://' : 'http://';                $host = isset($_SERVER[""HTTP_HOST""]) ? $_SERVER[""HTTP_HOST""] : php_uname(""n"");                if (substr($arr[""path""], 0, 1) === '/') {                    $path = dirname($arr[""path""]);                } else {                    $path = '/' . rtrim(dirname($_SERVER[""SCRIPT_NAME""]), '/') . '/' . $arr[""path""];                }            }        }        $ret = [$protocol, $host, $path, $file,            ""protocol"" => $protocol,            ""host"" => $host,            ""path"" => $path,            ""file"" => $file];        return $ret;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Parser_394, Outwards facing interface for HTML5.\n, Outwards facing interface for HTML5.,"class HTML5_Parser{    /**     * Parses a full HTML document.     * @param $text | HTML text to parse     * @param $builder | Custom builder implementation     * @return DOMDocument|DOMNodeList Parsed HTML as DOMDocument     */    public static function parse($text, $builder = null) {        $tokenizer = new HTML5_Tokenizer($text, $builder);        $tokenizer->parse();        return $tokenizer->save();    }    /**     * Parses an HTML fragment.     * @param $text | HTML text to parse     * @param $context String name of context element to pretend parsing is in.     * @param $builder | Custom builder implementation     * @return DOMDocument|DOMNodeList Parsed HTML as DOMDocument     */    public static function parseFragment($text, $context = null, $builder = null) {        $tokenizer = new HTML5_Tokenizer($text, $builder);        $tokenizer->parseFragment($context);        return $tokenizer->save();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
egulias_EmailValidator_EmailLexer_700, Lexical non-catchable patterns.\\n\\n @return string[]\\n, Lexical non-catchable patterns.,"    protected function getNonCatchablePatterns()    {        return [            '[\xA0-\xff]+',        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
egulias_EmailValidator_EmailLexer_701, Retrieve token type. Also processes the token value if necessary.\n\n @param string $value\n @throws \\InvalidArgumentException\n @return integer\n, Retrieve token type. Also processes the token value if necessary.,"    protected function getType(&$value)    {        $encoded = $value;        if (mb_detect_encoding($value, 'auto', true) !== 'UTF-8') {            $encoded = utf8_encode($value);        }        if ($this->isValid($encoded)) {            return $this->charValue[$encoded];        }        if ($this->isNullType($encoded)) {            return self::C_NUL;        }        if ($this->isInvalidChar($encoded)) {            $this->hasInvalidTokens = true;            return self::INVALID;        }        return  self::GENERIC;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Frame_8400," Returns the full contents of the file for this frame,\n if it's known.\n @return string|null\n"," Returns the full contents of the file for this frame,","    public function getFileContents()    {        if ($this->fileContentsCache === null && $filePath = $this->getFile()) {            // Leave the stage early when 'Unknown' or '[internal]' is passed            // this would otherwise raise an exception when            // open_basedir is enabled.            if ($filePath === ""Unknown"" || $filePath === '[internal]') {                return null;            }            try {                $this->fileContentsCache = file_get_contents($filePath);            } catch (ErrorException $exception) {                // Internal file paths of PHP extensions cannot be opened            }        }        return $this->fileContentsCache;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Frame_8404, Compares Frame against one another\n @param  Frame $frame\n @return bool\n, Compares Frame against one another,    public function equals(Frame $frame)    {        if (!$this->getFile() || $this->getFile() === 'Unknown' || !$this->getLine()) {            return false;        }        return $frame->getFile() === $this->getFile() && $frame->getLine() === $this->getLine();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Inspector_6758, Returns an iterator for the inspected exception's\n frames.\n @return \\Whoops\\Exception\\FrameCollection\n, Returns an iterator for the inspected exception's,"    public function getFrames()    {        if ($this->frames === null) {            $frames = $this->getTrace($this->exception);            // Fill empty line/file info for call_user_func_array usages (PHP Bug #44428)            foreach ($frames as $k => $frame) {                if (empty($frame['file'])) {                    // Default values when file and line are missing                    $file = '[internal]';                    $line = 0;                    $next_frame = !empty($frames[$k + 1]) ? $frames[$k + 1] : [];                    if ($this->isValidNextFrame($next_frame)) {                        $file = $next_frame['file'];                        $line = $next_frame['line'];                    }                    $frames[$k]['file'] = $file;                    $frames[$k]['line'] = $line;                }            }            // Find latest non-error handling frame index ($i) used to remove error handling frames            $i = 0;            foreach ($frames as $k => $frame) {                if ($frame['file'] == $this->exception->getFile() && $frame['line'] == $this->exception->getLine()) {                    $i = $k;                }            }            // Remove error handling frames            if ($i > 0) {                array_splice($frames, 0, $i);            }            $firstFrame = $this->getFrameFromException($this->exception);            array_unshift($frames, $firstFrame);            $this->frames = new FrameCollection($frames);            if ($previousInspector = $this->getPreviousExceptionInspector()) {                // Keep outer frame on top of the inner one                $outerFrames = $this->frames;                $newFrames = clone $previousInspector->getFrames();                // I assume it will always be set, but let's be safe                if (isset($newFrames[0])) {                    $newFrames[0]->addComment(                        $previousInspector->getExceptionMessage(),                        'Exception message:'                    );                }                $newFrames->prependFrames($outerFrames->topDiff($newFrames));                $this->frames = $newFrames;            }        }        return $this->frames;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Inspector_7127, Returns a url to the php-manual related to the underlying error - when available.\n\n @return string|null\n, Returns a url to the php-manual related to the underlying error - when available.,    public function getExceptionDocrefUrl()    {        return $this->extractDocrefUrl($this->exception->getMessage())['url'];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Inspector_7514, Returns an array of all previous exceptions for this inspector's exception\n @return \\Throwable[]\n, Returns an array of all previous exceptions for this inspector's exception,    public function getPreviousExceptions()    {        if ($this->previousExceptions === null) {            $this->previousExceptions = [];            $prev = $this->exception->getPrevious();            while ($prev !== null) {                $this->previousExceptions[] = $prev;                $prev = $prev->getPrevious();            }        }        return $this->previousExceptions;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_RunTest_7546, Test error suppression using @ operator.\n, Test error suppression using @ operator.,"    public function testErrorSuppression()    {        $run = $this->getRunInstance();        $run->register();        $handler = $this->getHandler();        $run->pushHandler($handler);        $test = $this;        $handler            ->shouldReceive('handle')            ->andReturnUsing(function () use ($test) {                $test->fail('$handler should not be called, error not suppressed');            });        @trigger_error(""Test error suppression"");        // Reached the end without errors        $this->assertTrue(true);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_RunTest_7547, Test to make sure that error_reporting is respected.\n, Test to make sure that error_reporting is respected.,"    public function testErrorReporting()    {        $run = $this->getRunInstance();        $run->register();        $handler = $this->getHandler();        $run->pushHandler($handler);        $test = $this;        $handler            ->shouldReceive('handle')            ->andReturnUsing(function () use ($test) {                $test->fail('$handler should not be called, error_reporting not respected');            });        $oldLevel = error_reporting(E_ALL ^ E_USER_NOTICE);        trigger_error(""Test error reporting"", E_USER_NOTICE);        error_reporting($oldLevel);        // Reached the end without errors        $this->assertTrue(true);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Run_6421, Explicitly request your handler runs as the last of all currently registered handlers.\n\n @param HandlerInterface $handler\n\n @return Run\n, Explicitly request your handler runs as the last of all currently registered handlers.,"    public function appendHandler($handler)    {        array_unshift($this->handlerStack, $this->resolveHandler($handler));        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Run_6423, Register your handler as the last of all currently registered handlers (to be executed first).\n Prefer using appendHandler and prependHandler for clarity.\n\n @param Callable|HandlerInterface $handler\n\n @return Run\n\n @throws InvalidArgumentException If argument is not callable or instance of HandlerInterface.\n, Register your handler as the last of all currently registered handlers (to be executed first).,    public function pushHandler($handler)    {        $this->handlerStack[] = $this->resolveHandler($handler);        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Run_6432," Handles an exception, ultimately generating a Whoops error page.\n\n @param Throwable $exception\n\n @return string Output generated by handlers.\n"," Handles an exception, ultimately generating a Whoops error page.","    public function handleException($exception)    {        // Walk the registered handlers in the reverse order        // they were registered, and pass off the exception        $inspector = $this->getInspector($exception);        // Capture output produced while handling the exception,        // we might want to send it straight away to the client,        // or return it silently.        $this->system->startOutputBuffering();        // Just in case there are no handlers:        $handlerResponse = null;        $handlerContentType = null;        try {            foreach (array_reverse($this->handlerStack) as $handler) {                $handler->setRun($this);                $handler->setInspector($inspector);                $handler->setException($exception);                // The HandlerInterface does not require an Exception passed to handle()                // and neither of our bundled handlers use it.                // However, 3rd party handlers may have already relied on this parameter,                // and removing it would be possibly breaking for users.                $handlerResponse = $handler->handle($exception);                // Collect the content type for possible sending in the headers.                $handlerContentType = method_exists($handler, 'contentType') ? $handler->contentType() : null;                if (in_array($handlerResponse, [Handler::LAST_HANDLER, Handler::QUIT])) {                    // The Handler has handled the exception in some way, and                    // wishes to quit execution (Handler::QUIT), or skip any                    // other handlers (Handler::LAST_HANDLER). If $this->allowQuit                    // is false, Handler::QUIT behaves like Handler::LAST_HANDLER                    break;                }            }            $willQuit = $handlerResponse == Handler::QUIT && $this->allowQuit();        } finally {            $output = $this->system->cleanOutputBuffer();        }        // If we're allowed to, send output generated by handlers directly        // to the output, otherwise, and if the script doesn't quit, return        // it so that it may be used by the caller        if ($this->writeToOutput()) {            // @todo Might be able to clean this up a bit better            if ($willQuit) {                // Cleanup all other output buffers before sending our output:                while ($this->system->getOutputBufferLevel() > 0) {                    $this->system->endOutputBuffering();                }                // Send any headers if needed:                if (Misc::canSendHeaders() && $handlerContentType) {                    header(""Content-Type: {$handlerContentType}"");                }            }            $this->writeToOutputNow($output);        }        if ($willQuit) {            // HHVM fix for https://github.com/facebook/hhvm/issues/4055            $this->system->flushOutputBuffer();            $this->system->stopExecution(                $this->sendExitCode()            );        }        return $output;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Run_6703, Unregisters all handlers registered by this Whoops\\Run instance.\n\n @return Run\n, Unregisters all handlers registered by this Whoops,    public function unregister()    {        if ($this->isRegistered) {            $this->system->restoreExceptionHandler();            $this->system->restoreErrorHandler();            $this->isRegistered = false;        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Run_6708, Resolves the giving handler.\n\n @param HandlerInterface $handler\n\n @return HandlerInterface\n\n @throws InvalidArgumentException\n, Resolves the giving handler.,"    private function resolveHandler($handler)    {        if (is_callable($handler)) {            $handler = new CallbackHandler($handler);        }        if (!$handler instanceof HandlerInterface) {            throw new InvalidArgumentException(                ""Handler must be a callable, or instance of ""                . ""Whoops\\Handler\\HandlerInterface""            );        }        return $handler;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Run_6709, Echo something to the browser.\n\n @param string $output\n\n @return Run\n, Echo something to the browser.,    private function writeToOutputNow($output)    {        if ($this->sendHttpCode() && Misc::canSendHeaders()) {            $this->system->setHttpResponseCode(                $this->sendHttpCode()            );        }        echo $output;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Run_7459, Registers this instance as an error handler.\n\n @return Run\n, Registers this instance as an error handler.,"    public function register()    {        if (!$this->isRegistered) {            // Workaround PHP bug 42098            // https://bugs.php.net/bug.php?id=42098            class_exists(""\\Whoops\\Exception\\ErrorException"");            class_exists(""\\Whoops\\Exception\\FrameCollection"");            class_exists(""\\Whoops\\Exception\\Frame"");            class_exists(""\\Whoops\\Exception\\Inspector"");            $this->system->setErrorHandler([$this, self::ERROR_HANDLER]);            $this->system->setExceptionHandler([$this, self::EXCEPTION_HANDLER]);            $this->system->registerShutdownFunction([$this, self::SHUTDOWN_HANDLER]);            $this->isRegistered = true;        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Run_7463, Special case to deal with Fatal errors and the like.\n\n @return void\n, Special case to deal with Fatal errors and the like.,"    public function handleShutdown()    {        // If we reached this step, we are in shutdown handler.        // An exception thrown in a shutdown handler will not be propagated        // to the exception handler. Pass that information along.        $this->canThrowExceptions = false;        $error = $this->system->getLastError();        if ($error && Misc::isLevelFatal($error['type'])) {            // If there was a fatal error,            // it was not handled in handleError yet.            $this->allowQuit = false;            $this->handleError(                $error['type'],                $error['message'],                $error['file'],                $error['line']            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
firefly-iii_firefly-iii_Controller_769, Method to grab all parameters from the URI.\\n\\n @return ParameterBag\\n, Method to grab all parameters from the URI.,"    private function getParameters(): ParameterBag    {        $bag  = new ParameterBag;        $page = (int)request()->get('page');        if (0 === $page) {            $page = 1;        }        $bag->set('page', $page);        // some date fields:        $dates = ['start', 'end', 'date'];        foreach ($dates as $field) {            $date = request()->query->get($field);            $obj  = null;            if (null !== $date) {                try {                    $obj = Carbon::parse($date);                } catch (InvalidDateException $e) {                    // don't care                    Log::error(sprintf('Invalid date exception in API controller: %s', $e->getMessage()));                }            }            $bag->set($field, $obj);        }        // integer fields:        $integers = ['limit'];        foreach ($integers as $integer) {            $value = request()->query->get($integer);            if (null !== $value) {                $bag->set($integer, (int)$value);            }        }        return $bag;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
firefly-iii_firefly-iii_UpdateControllerTest_846, Only create optional sets.\\n\\n @return array\\n, Only create optional sets.,"    public function newUpdateDataProvider(): array    {        $configuration = new TestConfiguration;        // optional field sets (for all test configs)        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('name', 'uuid'));        $configuration->addOptionalFieldSet('name', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('active', 'boolean'));        $configuration->addOptionalFieldSet('active', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('iban', 'iban'));        $configuration->addOptionalFieldSet('iban', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('bic', 'bic'));        $configuration->addOptionalFieldSet('bic', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('account_number', 'iban'));        $configuration->addOptionalFieldSet('account_number', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('order', 'order'));        $configuration->addOptionalFieldSet('order', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('include_net_worth', 'boolean'));        $configuration->addOptionalFieldSet('include_net_worth', $fieldSet);        $fieldSet               = new FieldSet;        $fieldSet->parameters   = [1];        $field                  = Field::createBasic('virtual_balance', 'random-amount');        $field->ignorableFields = ['current_balance'];        $fieldSet->addField($field);        $configuration->addOptionalFieldSet('virtual_balance', $fieldSet);        $fieldSet               = new FieldSet;        $fieldSet->parameters   = [1];        $field                  = new Field;        $field->fieldTitle      = 'currency_id';        $field->fieldType       = 'random-currency-id';        $field->ignorableFields = ['currency_code', 'currency_symbol', 'current_balance'];        $field->title           = 'currency_id';        $fieldSet->addField($field);        $configuration->addOptionalFieldSet('currency_id', $fieldSet);        $fieldSet               = new FieldSet;        $fieldSet->parameters   = [1];        $field                  = new Field;        $field->fieldTitle      = 'currency_code';        $field->fieldType       = 'random-currency-code';        $field->ignorableFields = ['currency_id', 'currency_symbol', 'current_balance'];        $field->title           = 'currency_code';        $fieldSet->addField($field);        $configuration->addOptionalFieldSet('currency_code', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('account_role', 'random-asset-accountRole'));        $configuration->addOptionalFieldSet('account_role', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('notes', 'uuid'));        $configuration->addOptionalFieldSet('notes', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [1];        $fieldSet->addField(Field::createBasic('latitude', 'latitude'));        $fieldSet->addField(Field::createBasic('longitude', 'longitude'));        $fieldSet->addField(Field::createBasic('zoom_level', 'random-zoom_level'));        $configuration->addOptionalFieldSet('notes', $fieldSet);        $fieldSet               = new FieldSet;        $fieldSet->parameters   = [1];        $field                  = Field::createBasic('opening_balance', 'random-amount');        $field->ignorableFields = ['current_balance'];        $fieldSet->addField($field);        $fieldSet->addField(Field::createBasic('opening_balance_date', 'random-past-date'));        $configuration->addOptionalFieldSet('ob', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [7];        $fieldSet->addField(Field::createBasic('account_role', 'static-ccAsset'));        $fieldSet->addField(Field::createBasic('credit_card_type', 'static-monthlyFull'));        $fieldSet->addField(Field::createBasic('monthly_payment_date', 'random-past-date'));        $configuration->addOptionalFieldSet('cc1', $fieldSet);        $fieldSet               = new FieldSet;        $fieldSet->parameters   = [13];        $field                  = new Field;        $field->fieldTitle      = 'liability_type';        $field->fieldType       = 'random-liability-type';        $field->ignorableFields = ['account_role'];        $field->title           = 'liability_type';        $fieldSet->addField($field);        $fieldSet->addField(Field::createBasic('account_role', 'null'));        $fieldSet->addField(Field::createBasic('credit_card_type', 'null'));        $fieldSet->addField(Field::createBasic('monthly_payment_date', 'null'));        $configuration->addOptionalFieldSet('liability-1', $fieldSet);        $fieldSet             = new FieldSet;        $fieldSet->parameters = [13];        $fieldSet->addField(Field::createBasic('interest', 'random-percentage'));        $field                  = new Field;        $field->fieldTitle      = 'interest_period';        $field->fieldType       = 'random-interest-period';        $field->ignorableFields = ['account_role'];        $field->title           = 'interest_period';        $fieldSet->addField($field);        $fieldSet->addField(Field::createBasic('account_role', 'null'));        $fieldSet->addField(Field::createBasic('credit_card_type', 'null'));        $fieldSet->addField(Field::createBasic('monthly_payment_date', 'null'));        $configuration->addOptionalFieldSet('liability-2', $fieldSet);        return $configuration->generateAll();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
firefly-iii_firefly-iii_breadcrumbs_832, Cuts away the middle of a string when it's very long.\n\n @param string $string\n\n @return string\n, Cuts away the middle of a string when it's very long.,"    function limitStringLength(string $string): string    {        $maxChars = 75;        $length   = \strlen($string);        $result   = $string;        if ($length > $maxChars) {            $result = substr_replace($string, ' ... ', (int)($maxChars / 2), $length - $maxChars);        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_DefaultGenerator_906, This generator returns a default value for all called properties\\n and methods. It works with Faker\\\\Generator\\\\Base->optional().\\n, This generator returns a default value for all called properties,"class DefaultGenerator{    protected $default;    public function __construct($default = null)    {        $this->default = $default;    }    /**     * @param string $attribute     *     * @return mixed     */    public function __get($attribute)    {        return $this->default;    }    /**     * @param string $method     * @param array $attributes     *     * @return mixed     */    public function __call($method, $attributes)    {        return $this->default;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_Ean_923, Computes the checksum of an EAN number.\\n\\n @see https://en.wikipedia.org/wiki/International_Article_Number\\n\\n @param string $digits\\n @return int\\n, Computes the checksum of an EAN number.,    public static function checksum($digits)    {        $length = strlen($digits);        $even = 0;        for ($i = $length - 1; $i >= 0; $i -= 2) {            $even += $digits[$i];        }        $odd = 0;        for ($i = $length - 2; $i >= 0; $i -= 2) {            $odd += $digits[$i];        }        return (10 - ((3 * $even + $odd) % 10)) % 10;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_Ean_924, Checks whether the provided number is an EAN compliant number and that\n the checksum is correct.\n\n @param string $ean An EAN number\n @return boolean\n, Checks whether the provided number is an EAN compliant number and that,"    public static function isValid($ean)    {        if (!preg_match(self::PATTERN, $ean)) {            return false;        }        return self::checksum(substr($ean, 0, -1)) === intval(substr($ean, -1));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_Generator_913, Replaces tokens ('{{ tokenName }}') with the result from the token method call\n\n @param  string $string String that needs to bet parsed\n @return string\n, Replaces tokens ('{{ tokenName }}') with the result from the token method call,"    public function parse($string)    {        return preg_replace_callback('/\{\{\s?(\w+)\s?\}\}/u', array($this, 'callFormatWithMatches'), $string);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_UniqueGenerator_916," Proxy for other generators, to return only unique values. Works with\n Faker\\Generator\\Base->unique()\n"," Proxy for other generators, to return only unique values. Works with","class UniqueGenerator{    protected $generator;    protected $maxRetries;    protected $uniques = array();    /**     * @param Generator $generator     * @param integer $maxRetries     */    public function __construct(Generator $generator, $maxRetries = 10000)    {        $this->generator = $generator;        $this->maxRetries = $maxRetries;    }    /**     * Catch and proxy all generator calls but return only unique values     * @param string $attribute     * @return mixed     */    public function __get($attribute)    {        return $this->__call($attribute, array());    }    /**     * Catch and proxy all generator calls with arguments but return only unique values     * @param string $name     * @param array $arguments     * @return mixed     */    public function __call($name, $arguments)    {        if (!isset($this->uniques[$name])) {            $this->uniques[$name] = array();        }        $i = 0;        do {            $res = call_user_func_array(array($this->generator, $name), $arguments);            $i++;            if ($i > $this->maxRetries) {                throw new \OverflowException(sprintf('Maximum retries of %d reached without finding a unique value', $this->maxRetries));            }        } while (array_key_exists(serialize($res), $this->uniques[$name]));        $this->uniques[$name][serialize($res)]= null;        return $res;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_UniqueGenerator_918, Catch and proxy all generator calls with arguments but return only unique values\n @param string $name\n @param array $arguments\n @return mixed\n, Catch and proxy all generator calls with arguments but return only unique values,"    public function __call($name, $arguments)    {        if (!isset($this->uniques[$name])) {            $this->uniques[$name] = array();        }        $i = 0;        do {            $res = call_user_func_array(array($this->generator, $name), $arguments);            $i++;            if ($i > $this->maxRetries) {                throw new \OverflowException(sprintf('Maximum retries of %d reached without finding a unique value', $this->maxRetries));            }        } while (array_key_exists(serialize($res), $this->uniques[$name]));        $this->uniques[$name][serialize($res)]= null;        return $res;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_ValidGenerator_919," Proxy for other generators, to return only valid values. Works with\\\\n Faker\\\\\\\\Generator\\\\\\\\Base->valid()\\\\n"," Proxy for other generators, to return only valid values. Works with","class ValidGenerator{    protected $generator;    protected $validator;    protected $maxRetries;    /**     * @param Generator $generator     * @param callable|null $validator     * @param integer $maxRetries     */    public function __construct(Generator $generator, $validator = null, $maxRetries = 10000)    {        if (is_null($validator)) {            $validator = function () {                return true;            };        } elseif (!is_callable($validator)) {            throw new \InvalidArgumentException('valid() only accepts callables as first argument');        }        $this->generator = $generator;        $this->validator = $validator;        $this->maxRetries = $maxRetries;    }    /**     * Catch and proxy all generator calls but return only valid values     * @param string $attribute     *     * @return mixed     */    public function __get($attribute)    {        return $this->__call($attribute, array());    }    /**     * Catch and proxy all generator calls with arguments but return only valid values     * @param string $name     * @param array $arguments     *     * @return mixed     */    public function __call($name, $arguments)    {        $i = 0;        do {            $res = call_user_func_array(array($this->generator, $name), $arguments);            $i++;            if ($i > $this->maxRetries) {                throw new \OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this->maxRetries));            }        } while (!call_user_func($this->validator, $res));        return $res;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_ValidGenerator_921, Catch and proxy all generator calls with arguments but return only valid values\\\\n @param string $name\\\\n @param array $arguments\\\\n\\\\n @return mixed\\\\n, Catch and proxy all generator calls with arguments but return only valid values,"    public function __call($name, $arguments)    {        $i = 0;        do {            $res = call_user_func_array(array($this->generator, $name), $arguments);            $i++;            if ($i > $this->maxRetries) {                throw new \OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this->maxRetries));            }        } while (!call_user_func($this->validator, $res));        return $res;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Assets_1114," Set up configuration options.\n\n All the class properties except 'js' and 'css' are accepted here.\n Also, an extra option 'autoload' may be passed containing an array of\n assets and/or collections that will be automatically added on startup.\n\n @param  array $config Configurable options.\n @return $this\n", Set up configuration options.,"    public function config(array $config)    {        foreach ($config as $key => $value) {            if ($this->hasProperty($key)) {                $this->setProperty($key, $value);            } elseif (Utils::startsWith($key, 'css_') || Utils::startsWith($key, 'js_')) {                $this->pipeline_options[$key] = $value;            }        }        // Add timestamp if it's enabled        if ($this->enable_asset_timestamp) {            $this->timestamp = Grav::instance()['cache']->getKey();        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Assets_1118, Add an Inline CSS asset or a collection of assets.\n\n @return $this\n, Add an Inline CSS asset or a collection of assets.,"    public function addInlineCss($asset)    {        return $this->addType($this::CSS_COLLECTION, $this::INLINE_CSS_TYPE, $asset, $this->unifyLegacyArguments(func_get_args(), $this::INLINE_CSS_TYPE));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Assets_1442," Add an asset or a collection of assets.\\n\\n It automatically detects the asset type (JavaScript, CSS or collection).\\n You may add more than one asset passing an array as argument.\\n\\n @param string|string[] $asset\\n @return $this\\n", Add an asset or a collection of assets.,"    public function add($asset)    {        $args = func_get_args();        // More than one asset        if (is_array($asset)) {            foreach ($asset as $index => $location) {                $params = array_slice($args, 1);                if (is_array($location)) {                    $params = array_shift($params);                    if (is_numeric($params)) {                        $params = [ 'priority' => $params ];                    }                    $params = [array_replace_recursive([], $location, $params)];                    $location = $index;                }                $params = array_merge([$location], $params);                call_user_func_array([$this, 'add'], $params);            }        } elseif (isset($this->collections[$asset])) {            array_shift($args);            $args = array_merge([$this->collections[$asset]], $args);            call_user_func_array([$this, 'add'], $args);        } else {            // Get extension            $extension = pathinfo(parse_url($asset, PHP_URL_PATH), PATHINFO_EXTENSION);            // JavaScript or CSS            if ($extension !== '') {                $extension = strtolower($extension);                if ($extension === 'css') {                    call_user_func_array([$this, 'addCss'], $args);                } elseif ($extension === 'js') {                    call_user_func_array([$this, 'addJs'], $args);                }            }        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Assets_1950, Initialization called in the Grav lifecycle to initialize the Assets with appropriate configuration\\n\\n @return void\\n, Initialization called in the Grav lifecycle to initialize the Assets with appropriate configuration,"    public function init()    {        $grav = Grav::instance();        /** @var Config $config */        $config = $grav['config'];        $asset_config = (array)$config->get('system.assets');        /** @var UniformResourceLocator $locator */        $locator = $grav['locator'];        $this->assets_dir = $locator->findResource('asset://');        $this->assets_url = $locator->findResource('asset://', false);        $this->config($asset_config);        // Register any preconfigured collections        foreach ((array) $this->collections as $name => $collection) {            $this->registerCollection($name, (array)$collection);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Browser_1127, Get the current major version identifier\\n\\n @return int the browser major version identifier\\n, Get the current major version identifier,"    public function getVersion()    {        $version = explode('.', $this->getLongVersion());        return (int)$version[0];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Browser_1449, Internally uses the PhpUserAgent package https://github.com/donatj/PhpUserAgent\\n, Internally uses the PhpUserAgent package https://github.com/donatj/PhpUserAgent,"class Browser{    /** @var string[] */    protected $useragent = [];    /**     * Browser constructor.     */    public function __construct()    {        try {            $this->useragent = parse_user_agent();        } catch (InvalidArgumentException $e) {            $this->useragent = parse_user_agent(""Mozilla/5.0 (compatible; Unknown;)"");        }    }    /**     * Get the current browser identifier     *     * Currently detected browsers:     *     * Android Browser     * BlackBerry Browser     * Camino     * Kindle / Silk     * Firefox / Iceweasel     * Safari     * Internet Explorer     * IEMobile     * Chrome     * Opera     * Midori     * Vivaldi     * TizenBrowser     * Lynx     * Wget     * Curl     *     * @return string the lowercase browser name     */    public function getBrowser()    {        return strtolower($this->useragent['browser']);    }    /**     * Get the current platform identifier     *     * Currently detected platforms:     *     * Desktop     *   -> Windows     *   -> Linux     *   -> Macintosh     *   -> Chrome OS     * Mobile     *   -> Android     *   -> iPhone     *   -> iPad / iPod Touch     *   -> Windows Phone OS     *   -> Kindle     *   -> Kindle Fire     *   -> BlackBerry     *   -> Playbook     *   -> Tizen     * Console     *   -> Nintendo 3DS     *   -> New Nintendo 3DS     *   -> Nintendo Wii     *   -> Nintendo WiiU     *   -> PlayStation 3     *   -> PlayStation 4     *   -> PlayStation Vita     *   -> Xbox 360     *   -> Xbox One     *     * @return string the lowercase platform name     */    public function getPlatform()    {        return strtolower($this->useragent['platform']);    }    /**     * Get the current full version identifier     *     * @return string the browser full version identifier     */    public function getLongVersion()    {        return $this->useragent['version'];    }    /**     * Get the current major version identifier     *     * @return int the browser major version identifier     */    public function getVersion()    {        $version = explode('.', $this->getLongVersion());        return (int)$version[0];    }    /**     * Determine if the request comes from a human, or from a bot/crawler     *     * @return bool     */    public function isHuman()    {        $browser = $this->getBrowser();        if (empty($browser)) {            return false;        }        if (preg_match('~(bot|crawl)~i', $browser)) {            return false;        }        return true;    }    /**     * Determine if “Do Not Track” is set by browser     * @see https://www.w3.org/TR/tracking-dnt/     *     * @return bool     */    public function isTrackable(): bool    {        return !(isset($_SERVER['HTTP_DNT']) && $_SERVER['HTTP_DNT'] === '1');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Browser_1455," Determine if the request comes from a human, or from a bot/crawler\n\n @return bool\n"," Determine if the request comes from a human, or from a bot/crawler","    public function isHuman()    {        $browser = $this->getBrowser();        if (empty($browser)) {            return false;        }        if (preg_match('~(bot|crawl)~i', $browser)) {            return false;        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1130, The GravCache object is used throughout Grav to store and retrieve cached data.\n It uses DoctrineCache library and supports a variety of caching mechanisms. Those include:\n\n APCu\n RedisCache\n MemCache\n MemCacheD\n FileSystem\n, The GravCache object is used throughout Grav to store and retrieve cached data.,"class Cache extends Getters{    /** @var string Cache key. */    protected $key;    /** @var int */    protected $lifetime;    /** @var int */    protected $now;    /** @var Config $config */    protected $config;    /** @var DoctrineCache\CacheProvider */    protected $driver;    /** @var CacheInterface */    protected $simpleCache;    /** @var string */    protected $driver_name;    /** @var string */    protected $driver_setting;    /** @var bool */    protected $enabled;    /** @var string */    protected $cache_dir;    protected static $standard_remove = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'cache://images',        'asset://',    ];    protected static $standard_remove_no_images = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'asset://',    ];    protected static $all_remove = [        'cache://',        'cache://images',        'asset://',        'tmp://'    ];    protected static $assets_remove = [        'asset://'    ];    protected static $images_remove = [        'cache://images'    ];    protected static $cache_remove = [        'cache://'    ];    protected static $tmp_remove = [        'tmp://'    ];    /**     * Constructor     *     * @param Grav $grav     */    public function __construct(Grav $grav)    {        $this->init($grav);    }    /**     * Initialization that sets a base key and the driver based on configuration settings     *     * @param  Grav $grav     * @return void     */    public function init(Grav $grav)    {        $this->config = $grav['config'];        $this->now = time();        if (null === $this->enabled) {            $this->enabled = (bool)$this->config->get('system.cache.enabled');        }        /** @var Uri $uri */        $uri = $grav['uri'];        $prefix = $this->config->get('system.cache.prefix');        $uniqueness = substr(md5($uri->rootUrl(true) . $this->config->key() . GRAV_VERSION), 2, 8);        // Cache key allows us to invalidate all cache on configuration changes.        $this->key = ($prefix ? $prefix : 'g') . '-' . $uniqueness;        $this->cache_dir = $grav['locator']->findResource('cache://doctrine/' . $uniqueness, true, true);        $this->driver_setting = $this->config->get('system.cache.driver');        $this->driver = $this->getCacheDriver();        $this->driver->setNamespace($this->key);        /** @var EventDispatcher $dispatcher */        $dispatcher = Grav::instance()['events'];        $dispatcher->addListener('onSchedulerInitialized', [$this, 'onSchedulerInitialized']);    }    /**     * @return CacheInterface     */    public function getSimpleCache()    {        if (null === $this->simpleCache) {            $cache = new \Grav\Framework\Cache\Adapter\DoctrineCache($this->driver, '', $this->getLifetime());            // Disable cache key validation.            $cache->setValidation(false);            $this->simpleCache = $cache;        }        return $this->simpleCache;    }    /**     * Deletes the old out of date file-based caches     *     * @return int     */    public function purgeOldCache()    {        $cache_dir = dirname($this->cache_dir);        $current = basename($this->cache_dir);        $count = 0;        foreach (new DirectoryIterator($cache_dir) as $file) {            $dir = $file->getBasename();            if ($dir === $current || $file->isDot() || $file->isFile()) {                continue;            }            Folder::delete($file->getPathname());            $count++;        }        return $count;    }    /**     * Public accessor to set the enabled state of the cache     *     * @param bool|int $enabled     * @return void     */    public function setEnabled($enabled)    {        $this->enabled = (bool)$enabled;    }    /**     * Returns the current enabled state     *     * @return bool     */    public function getEnabled()    {        return $this->enabled;    }    /**     * Get cache state     *     * @return string     */    public function getCacheStatus()    {        return 'Cache: [' . ($this->enabled ? 'true' : 'false') . '] Setting: [' . $this->driver_setting . '] Driver: [' . $this->driver_name . ']';    }    /**     * Automatically picks the cache mechanism to use.  If you pick one manually it will use that     * If there is no config option for $driver in the config, or it's set to 'auto', it will     * pick the best option based on which cache extensions are installed.     *     * @return DoctrineCache\CacheProvider  The cache driver to use     */    public function getCacheDriver()    {        $setting = $this->driver_setting;        $driver_name = 'file';        // CLI compatibility requires a non-volatile cache driver        if ($this->config->get('system.cache.cli_compatibility') && (            $setting === 'auto' || $this->isVolatileDriver($setting))) {            $setting = $driver_name;        }        if (!$setting || $setting === 'auto') {            if (extension_loaded('apcu')) {                $driver_name = 'apcu';            } elseif (extension_loaded('wincache')) {                $driver_name = 'wincache';            }        } else {            $driver_name = $setting;        }        $this->driver_name = $driver_name;        switch ($driver_name) {            case 'apc':            case 'apcu':                $driver = new DoctrineCache\ApcuCache();                break;            case 'wincache':                $driver = new DoctrineCache\WinCacheCache();                break;            case 'memcache':                if (extension_loaded('memcache')) {                    $memcache = new \Memcache();                    $memcache->connect(                        $this->config->get('system.cache.memcache.server', 'localhost'),                        $this->config->get('system.cache.memcache.port', 11211)                    );                    $driver = new DoctrineCache\MemcacheCache();                    $driver->setMemcache($memcache);                } else {                    throw new LogicException('Memcache PHP extension has not been installed');                }                break;            case 'memcached':                if (extension_loaded('memcached')) {                    $memcached = new \Memcached();                    $memcached->addServer(                        $this->config->get('system.cache.memcached.server', 'localhost'),                        $this->config->get('system.cache.memcached.port', 11211)                    );                    $driver = new DoctrineCache\MemcachedCache();                    $driver->setMemcached($memcached);                } else {                    throw new LogicException('Memcached PHP extension has not been installed');                }                break;            case 'redis':                if (extension_loaded('redis')) {                    $redis = new \Redis();                    $socket = $this->config->get('system.cache.redis.socket', false);                    $password = $this->config->get('system.cache.redis.password', false);                    $databaseId = $this->config->get('system.cache.redis.database', 0);                    if ($socket) {                        $redis->connect($socket);                    } else {                        $redis->connect(                            $this->config->get('system.cache.redis.server', 'localhost'),                            $this->config->get('system.cache.redis.port', 6379)                        );                    }                    // Authenticate with password if set                    if ($password && !$redis->auth($password)) {                        throw new \RedisException('Redis authentication failed');                    }                    // Select alternate ( !=0 ) database ID if set                    if ($databaseId && !$redis->select($databaseId)) {                        throw new \RedisException('Could not select alternate Redis database ID');                    }                    $driver = new DoctrineCache\RedisCache();                    $driver->setRedis($redis);                } else {                    throw new LogicException('Redis PHP extension has not been installed');                }                break;            default:                $driver = new DoctrineCache\FilesystemCache($this->cache_dir);                break;        }        return $driver;    }    /**     * Gets a cached entry if it exists based on an id. If it does not exist, it returns false     *     * @param  string $id the id of the cached entry     * @return mixed|bool     returns the cached entry, can be any type, or false if doesn't exist     */    public function fetch($id)    {        if ($this->enabled) {            return $this->driver->fetch($id);        }        return false;    }    /**     * Stores a new cached entry.     *     * @param  string       $id       the id of the cached entry     * @param  array|object|int $data     the data for the cached entry to store     * @param  int|null     $lifetime the lifetime to store the entry in seconds     */    public function save($id, $data, $lifetime = null)    {        if ($this->enabled) {            if ($lifetime === null) {                $lifetime = $this->getLifetime();            }            $this->driver->save($id, $data, $lifetime);        }    }    /**     * Deletes an item in the cache based on the id     *     * @param string $id    the id of the cached data entry     * @return bool         true if the item was deleted successfully     */    public function delete($id)    {        if ($this->enabled) {            return $this->driver->delete($id);        }        return false;    }    /**     * Deletes all cache     *     * @return bool     */    public function deleteAll()    {        if ($this->enabled) {            return $this->driver->deleteAll();        }        return false;    }    /**     * Returns a boolean state of whether or not the item exists in the cache based on id key     *     * @param string $id    the id of the cached data entry     * @return bool         true if the cached items exists     */    public function contains($id)    {        if ($this->enabled) {            return $this->driver->contains(($id));        }        return false;    }    /**     * Getter method to get the cache key     *     * @return string     */    public function getKey()    {        return $this->key;    }    /**     * Setter method to set key (Advanced)     *     * @param string $key     * @return void     */    public function setKey($key)    {        $this->key = $key;        $this->driver->setNamespace($this->key);    }    /**     * Helper method to clear all Grav caches     *     * @param string $remove standard|all|assets-only|images-only|cache-only     * @return array     */    public static function clearCache($remove = 'standard')    {        $locator = Grav::instance()['locator'];        $output = [];        $user_config = USER_DIR . 'config/system.yaml';        switch ($remove) {            case 'all':                $remove_paths = self::$all_remove;                break;            case 'assets-only':                $remove_paths = self::$assets_remove;                break;            case 'images-only':                $remove_paths = self::$images_remove;                break;            case 'cache-only':                $remove_paths = self::$cache_remove;                break;            case 'tmp-only':                $remove_paths = self::$tmp_remove;                break;            case 'invalidate':                $remove_paths = [];                break;            default:                if (Grav::instance()['config']->get('system.cache.clear_images_by_default')) {                    $remove_paths = self::$standard_remove;                } else {                    $remove_paths = self::$standard_remove_no_images;                }        }        // Delete entries in the doctrine cache if required        if (in_array($remove, ['all', 'standard'])) {            $cache = Grav::instance()['cache'];            $cache->driver->deleteAll();        }        // Clearing cache event to add paths to clear        Grav::instance()->fireEvent('onBeforeCacheClear', new Event(['remove' => $remove, 'paths' => &$remove_paths]));        foreach ($remove_paths as $stream) {            // Convert stream to a real path            try {                $path = $locator->findResource($stream, true, true);                if ($path === false) {                    continue;                }                $anything = false;                $files = glob($path . '/*');                if (is_array($files)) {                    foreach ($files as $file) {                        if (is_link($file)) {                            $output[] = '<yellow>Skipping symlink:  </yellow>' . $file;                        } elseif (is_file($file)) {                            if (@unlink($file)) {                                $anything = true;                            }                        } elseif (is_dir($file)) {                            if (Folder::delete($file, false)) {                                $anything = true;                            }                        }                    }                }                if ($anything) {                    $output[] = '<red>Cleared:  </red>' . $path . '/*';                }            } catch (Exception $e) {                // stream not found or another error while deleting files.                $output[] = '<red>ERROR: </red>' . $e->getMessage();            }        }        $output[] = '';        if (($remove === 'all' || $remove === 'standard') && file_exists($user_config)) {            touch($user_config);            $output[] = '<red>Touched: </red>' . $user_config;            $output[] = '';        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }        Grav::instance()->fireEvent('onAfterCacheClear', new Event(['remove' => $remove, 'output' => &$output]));        return $output;    }    /**     * @return void     */    public static function invalidateCache()    {        $user_config = USER_DIR . 'config/system.yaml';        if (file_exists($user_config)) {            touch($user_config);        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }    }    /**     * Set the cache lifetime programmatically     *     * @param int $future timestamp     * @return void     */    public function setLifetime($future)    {        if (!$future) {            return;        }        $interval = (int)($future - $this->now);        if ($interval > 0 && $interval < $this->getLifetime()) {            $this->lifetime = $interval;        }    }    /**     * Retrieve the cache lifetime (in seconds)     *     * @return int     */    public function getLifetime()    {        if ($this->lifetime === null) {            $this->lifetime = (int)($this->config->get('system.cache.lifetime') ?: 604800); // 1 week default        }        return $this->lifetime;    }    /**     * Returns the current driver name     *     * @return string     */    public function getDriverName()    {        return $this->driver_name;    }    /**     * Returns the current driver setting     *     * @return string     */    public function getDriverSetting()    {        return $this->driver_setting;    }    /**     * is this driver a volatile driver in that it resides in PHP process memory     *     * @param string $setting     * @return bool     */    public function isVolatileDriver($setting)    {        if (in_array($setting, ['apc', 'apcu', 'xcache', 'wincache'])) {            return true;        }        return false;    }    /**     * Static function to call as a scheduled Job to purge old Doctrine files     *     * @param bool $echo     *     * @return string|void     */    public static function purgeJob($echo = false)    {        /** @var Cache $cache */        $cache = Grav::instance()['cache'];        $deleted_folders = $cache->purgeOldCache();        $msg = 'Purged ' . $deleted_folders . ' old cache folders...';        if ($echo) {            echo $msg;        } else {            return $msg;        }    }    /**     * Static function to call as a scheduled Job to clear Grav cache     *     * @param string $type     * @return void     */    public static function clearJob($type)    {        $result = static::clearCache($type);        static::invalidateCache();        echo strip_tags(implode(""\n"", $result));    }    /**     * @param Event $event     * @return void     */    public function onSchedulerInitialized(Event $event)    {        /** @var Scheduler $scheduler */        $scheduler = $event['scheduler'];        $config = Grav::instance()['config'];        // File Cache Purge        $at = $config->get('system.cache.purge_at');        $name = 'cache-purge';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::purgeJob', [true], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');        // Cache Clear        $at = $config->get('system.cache.clear_at');        $clear_type = $config->get('system.cache.clear_job_type');        $name = 'cache-clear';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::clearJob', [$clear_type], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1137, Get cache state\\n\\n @return string\\n, Get cache state,    public function getCacheStatus()    {        return 'Cache: [' . ($this->enabled ? 'true' : 'false') . '] Setting: [' . $this->driver_setting . '] Driver: [' . $this->driver_name . ']';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1138," Automatically picks the cache mechanism to use.  If you pick one manually it will use that\n If there is no config option for $driver in the config, or it's set to 'auto', it will\n pick the best option based on which cache extensions are installed.\n\n @return DoctrineCache\\CacheProvider  The cache driver to use\n", Automatically picks the cache mechanism to use.  If you pick one manually it will use that,"    public function getCacheDriver()    {        $setting = $this->driver_setting;        $driver_name = 'file';        // CLI compatibility requires a non-volatile cache driver        if ($this->config->get('system.cache.cli_compatibility') && (            $setting === 'auto' || $this->isVolatileDriver($setting))) {            $setting = $driver_name;        }        if (!$setting || $setting === 'auto') {            if (extension_loaded('apcu')) {                $driver_name = 'apcu';            } elseif (extension_loaded('wincache')) {                $driver_name = 'wincache';            }        } else {            $driver_name = $setting;        }        $this->driver_name = $driver_name;        switch ($driver_name) {            case 'apc':            case 'apcu':                $driver = new DoctrineCache\ApcuCache();                break;            case 'wincache':                $driver = new DoctrineCache\WinCacheCache();                break;            case 'memcache':                if (extension_loaded('memcache')) {                    $memcache = new \Memcache();                    $memcache->connect(                        $this->config->get('system.cache.memcache.server', 'localhost'),                        $this->config->get('system.cache.memcache.port', 11211)                    );                    $driver = new DoctrineCache\MemcacheCache();                    $driver->setMemcache($memcache);                } else {                    throw new LogicException('Memcache PHP extension has not been installed');                }                break;            case 'memcached':                if (extension_loaded('memcached')) {                    $memcached = new \Memcached();                    $memcached->addServer(                        $this->config->get('system.cache.memcached.server', 'localhost'),                        $this->config->get('system.cache.memcached.port', 11211)                    );                    $driver = new DoctrineCache\MemcachedCache();                    $driver->setMemcached($memcached);                } else {                    throw new LogicException('Memcached PHP extension has not been installed');                }                break;            case 'redis':                if (extension_loaded('redis')) {                    $redis = new \Redis();                    $socket = $this->config->get('system.cache.redis.socket', false);                    $password = $this->config->get('system.cache.redis.password', false);                    $databaseId = $this->config->get('system.cache.redis.database', 0);                    if ($socket) {                        $redis->connect($socket);                    } else {                        $redis->connect(                            $this->config->get('system.cache.redis.server', 'localhost'),                            $this->config->get('system.cache.redis.port', 6379)                        );                    }                    // Authenticate with password if set                    if ($password && !$redis->auth($password)) {                        throw new \RedisException('Redis authentication failed');                    }                    // Select alternate ( !=0 ) database ID if set                    if ($databaseId && !$redis->select($databaseId)) {                        throw new \RedisException('Could not select alternate Redis database ID');                    }                    $driver = new DoctrineCache\RedisCache();                    $driver->setRedis($redis);                } else {                    throw new LogicException('Redis PHP extension has not been installed');                }                break;            default:                $driver = new DoctrineCache\FilesystemCache($this->cache_dir);                break;        }        return $driver;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1146, Set the cache lifetime programmatically\\n\\n @param int $future timestamp\\n @return void\\n, Set the cache lifetime programmatically,    public function setLifetime($future)    {        if (!$future) {            return;        }        $interval = (int)($future - $this->now);        if ($interval > 0 && $interval < $this->getLifetime()) {            $this->lifetime = $interval;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1147, Retrieve the cache lifetime (in seconds)\\n\\n @return int\\n, Retrieve the cache lifetime (in seconds),    public function getLifetime()    {        if ($this->lifetime === null) {            $this->lifetime = (int)($this->config->get('system.cache.lifetime') ?: 604800); // 1 week default        }        return $this->lifetime;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1151, Static function to call as a scheduled Job to clear Grav cache\\n\\n @param string $type\\n @return void\\n, Static function to call as a scheduled Job to clear Grav cache,"    public static function clearJob($type)    {        $result = static::clearCache($type);        static::invalidateCache();        echo strip_tags(implode(""\n"", $result));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1969, Initialization that sets a base key and the driver based on configuration settings\\n\\n @param  Grav $grav\\n @return void\\n, Initialization that sets a base key and the driver based on configuration settings,"    public function init(Grav $grav)    {        $this->config = $grav['config'];        $this->now = time();        if (null === $this->enabled) {            $this->enabled = (bool)$this->config->get('system.cache.enabled');        }        /** @var Uri $uri */        $uri = $grav['uri'];        $prefix = $this->config->get('system.cache.prefix');        $uniqueness = substr(md5($uri->rootUrl(true) . $this->config->key() . GRAV_VERSION), 2, 8);        // Cache key allows us to invalidate all cache on configuration changes.        $this->key = ($prefix ? $prefix : 'g') . '-' . $uniqueness;        $this->cache_dir = $grav['locator']->findResource('cache://doctrine/' . $uniqueness, true, true);        $this->driver_setting = $this->config->get('system.cache.driver');        $this->driver = $this->getCacheDriver();        $this->driver->setNamespace($this->key);        /** @var EventDispatcher $dispatcher */        $dispatcher = Grav::instance()['events'];        $dispatcher->addListener('onSchedulerInitialized', [$this, 'onSchedulerInitialized']);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1971, Deletes the old out of date file-based caches\\n\\n @return int\\n, Deletes the old out of date file-based caches,    public function purgeOldCache()    {        $cache_dir = dirname($this->cache_dir);        $current = basename($this->cache_dir);        $count = 0;        foreach (new DirectoryIterator($cache_dir) as $file) {            $dir = $file->getBasename();            if ($dir === $current || $file->isDot() || $file->isFile()) {                continue;            }            Folder::delete($file->getPathname());            $count++;        }        return $count;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1979, Returns a boolean state of whether or not the item exists in the cache based on id key\n\n @param string $id    the id of the cached data entry\n @return bool         true if the cached items exists\n, Returns a boolean state of whether or not the item exists in the cache based on id key,    public function contains($id)    {        if ($this->enabled) {            return $this->driver->contains(($id));        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_79, Deletes an item in the cache based on the id\n\n @param string $id    the id of the cached data entry\n @return bool         true if the item was deleted successfully\n, Deletes an item in the cache based on the id,    public function delete($id)    {        if ($this->enabled) {            return $this->driver->delete($id);        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_80, Deletes all cache\\n\\n @return bool\\n, Deletes all cache,    public function deleteAll()    {        if ($this->enabled) {            return $this->driver->deleteAll();        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_87, Returns the current driver name\\n\\n @return string\\n, Returns the current driver name,    public function getDriverName()    {        return $this->driver_name;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Composer_1155, Return the composer executable file path\\n\\n @return string\\n, Return the composer executable file path,"    public static function getComposerExecutor()    {        $executor = PHP_BINARY . ' ';        $composer = static::getComposerLocation();        if ($composer !== static::DEFAULT_PATH && is_executable($composer)) {            $file = fopen($composer, 'rb');            $firstLine = fgets($file);            fclose($file);            if (!preg_match('/^#!.+php/i', $firstLine)) {                $executor = '';            }        }        return $executor . $composer;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Composer_1481, Returns the location of composer.\\n\\n @return string\\n, Returns the location of composer.,"    public static function getComposerLocation()    {        if (!function_exists('shell_exec') || stripos(PHP_OS, 'win') === 0) {            return self::DEFAULT_PATH;        }        // check for global composer install        $path = trim((string)shell_exec('command -v composer'));        // fall back to grav bundled composer        if (!$path || !preg_match('/(composer|composer\.phar)$/', $path)) {            $path = self::DEFAULT_PATH;        }        return $path;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_100, Add the debugger assets to the Grav Assets\n\n @return $this\n, Add the debugger assets to the Grav Assets,"    public function addAssets()    {        if ($this->enabled) {            // Only add assets if Page is HTML            $page = $this->grav['page'];            if ($page->templateFormat() !== 'html') {                return $this;            }            /** @var Assets $assets */            $assets = $this->grav['assets'];            // Clockwork specific assets            if ($this->clockwork) {                $assets->addCss('/system/assets/debugger/clockwork.css', ['loading' => 'inline']);                $assets->addJs('/system/assets/debugger/clockwork.js', ['loading' => 'inline']);            }            // Debugbar specific assets            if ($this->debugbar) {                // Add jquery library                $assets->add('jquery', 101);                $this->renderer = $this->debugbar->getJavascriptRenderer();                $this->renderer->setIncludeVendors(false);                [$css_files, $js_files] = $this->renderer->getAssets(null, JavascriptRenderer::RELATIVE_URL);                foreach ((array)$css_files as $css) {                    $assets->addCss($css);                }                $assets->addCss('/system/assets/debugger/phpdebugbar.css', ['loading' => 'inline']);                foreach ((array)$js_files as $js) {                    $assets->addJs($js);                }            }        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_102, Returns a data collector\\n\\n @param string $name\\n @return DataCollectorInterface|null\\n @throws DebugBarException\\n, Returns a data collector,    public function getCollector($name)    {        if ($this->debugbar && $this->debugbar->hasCollector($name)) {            return $this->debugbar->getCollector($name);        }        return null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_104, Sends the data through the HTTP headers\n\n @return $this\n, Sends the data through the HTTP headers,    public function sendDataInHeaders()    {        if ($this->enabled && $this->debugbar) {            $this->addMeasures();            $this->addDeprecations();            $this->debugbar->sendDataInHeaders();        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_106, Start profiling code.\n\n @return void\n, Start profiling code.,    public function startProfiling(): void    {        if ($this->enabled && extension_loaded('tideways_xhprof')) {            $this->profiling++;            if ($this->profiling === 1) {                // @phpstan-ignore-next-line                \tideways_xhprof_enable(TIDEWAYS_XHPROF_FLAGS_NO_BUILTINS);            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_110, Dump exception into the Messages tab of the Debug Bar\\n\\n @param Throwable $e\\n @return Debugger\\n, Dump exception into the Messages tab of the Debug Bar,"    public function addException(Throwable $e)    {        if ($this->initialized && $this->enabled) {            if ($this->debugbar) {                $this->debugbar['exceptions']->addThrowable($e);            }            if ($this->clockwork) {                /** @var UserData $exceptions */                $exceptions = $this->clockwork->userData('Exceptions');                $exceptions->data(['message' => $e->getMessage()]);                $this->clockwork->alert($e->getMessage(), ['exception' => $e]);            }        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_1156, Class Debugger\n @package Grav\\Common\n, Class Debugger,"class Debugger{    /** @var static */    protected static $instance;    /** @var Grav|null */    protected $grav;    /** @var Config|null */    protected $config;    /** @var JavascriptRenderer|null */    protected $renderer;    /** @var DebugBar|null */    protected $debugbar;    /** @var Clockwork|null */    protected $clockwork;    /** @var bool */    protected $enabled = false;    /** @var bool */    protected $initialized = false;    /** @var array */    protected $timers = [];    /** @var array */    protected $deprecations = [];    /** @var callable|null */    protected $errorHandler;    /** @var float */    protected $requestTime;    /** @var float */    protected $currentTime;    /** @var int */    protected $profiling = 0;    /** @var bool */    protected $censored = false;    /**     * Debugger constructor.     */    public function __construct()    {        static::$instance = $this;        $this->currentTime = microtime(true);        if (!defined('GRAV_REQUEST_TIME')) {            define('GRAV_REQUEST_TIME', $this->currentTime);        }        $this->requestTime = $_SERVER['REQUEST_TIME_FLOAT'] ?? GRAV_REQUEST_TIME;        // Set deprecation collector.        $this->setErrorHandler();    }    /**     * @return Clockwork|null     */    public function getClockwork(): ?Clockwork    {        return $this->enabled ? $this->clockwork : null;    }    /**     * Initialize the debugger     *     * @return $this     * @throws DebugBarException     */    public function init()    {        if ($this->initialized) {            return $this;        }        $this->grav = Grav::instance();        $this->config = $this->grav['config'];        // Enable/disable debugger based on configuration.        $this->enabled = (bool)$this->config->get('system.debugger.enabled');        $this->censored = (bool)$this->config->get('system.debugger.censored', false);        if ($this->enabled) {            $this->initialized = true;            $clockwork = $debugbar = null;            switch ($this->config->get('system.debugger.provider', 'debugbar')) {                case 'clockwork':                    $this->clockwork = $clockwork = new Clockwork();                    break;                default:                    $this->debugbar = $debugbar = new DebugBar();            }            $plugins_config = (array)$this->config->get('plugins');            ksort($plugins_config);            if ($clockwork) {                $log = $this->grav['log'];                $clockwork->setStorage(new FileStorage('cache://clockwork'));                if (extension_loaded('xdebug')) {                    $clockwork->addDataSource(new XdebugDataSource());                }                if ($log instanceof Logger) {                    $clockwork->addDataSource(new MonologDataSource($log));                }                $timeline = $clockwork->timeline();                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Server');                    $event->finalize($this->requestTime, GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Loading');                    $event->finalize(GRAV_REQUEST_TIME, $this->currentTime);                }                $event = $timeline->event('Site Setup');                $event->finalize($this->currentTime, microtime(true));            }            if ($this->censored) {                $censored = ['CENSORED' => true];            }            if ($debugbar) {                $debugbar->addCollector(new PhpInfoCollector());                $debugbar->addCollector(new MessagesCollector());                if (!$this->censored) {                    $debugbar->addCollector(new RequestDataCollector());                }                $debugbar->addCollector(new TimeDataCollector($this->requestTime));                $debugbar->addCollector(new MemoryCollector());                $debugbar->addCollector(new ExceptionsCollector());                $debugbar->addCollector(new ConfigCollector($censored ?? (array)$this->config->get('system'), 'Config'));                $debugbar->addCollector(new ConfigCollector($censored ?? $plugins_config, 'Plugins'));                $debugbar->addCollector(new ConfigCollector($this->config->get('streams.schemes'), 'Streams'));                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Server', $debugbar['time']->getRequestStartTime(), GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Loading', GRAV_REQUEST_TIME, $this->currentTime);                }                $debugbar['time']->addMeasure('Site Setup', $this->currentTime, microtime(true));            }            $this->addMessage('Grav v' . GRAV_VERSION . ' - PHP ' . PHP_VERSION);            $this->config->debug();            if ($clockwork) {                $clockwork->info('System Configuration', $censored ?? $this->config->get('system'));                $clockwork->info('Plugins Configuration', $censored ?? $plugins_config);                $clockwork->info('Streams', $this->config->get('streams.schemes'));            }        }        return $this;    }    public function finalize(): void    {        if ($this->clockwork && $this->enabled) {            $this->stopProfiling('Profiler Analysis');            $this->addMeasures();            $deprecations = $this->getDeprecations();            $count = count($deprecations);            if (!$count) {                return;            }            /** @var UserData $userData */            $userData = $this->clockwork->userData('Deprecated');            $userData->counters([                'Deprecated' => count($deprecations)            ]);            /*            foreach ($deprecations as &$deprecation) {                $d = $deprecation;                unset($d['message']);                $this->clockwork->log('deprecated', $deprecation['message'], $d);            }            unset($deprecation);             */            $userData->table('Your site is using following deprecated features', $deprecations);        }    }    public function logRequest(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface    {        if (!$this->enabled || !$this->clockwork) {            return $response;        }        $clockwork = $this->clockwork;        $this->finalize();        $clockwork->timeline()->finalize($request->getAttribute('request_time'));        if ($this->censored) {            $censored = 'CENSORED';            $request = $request                ->withCookieParams([$censored => ''])                ->withUploadedFiles([])                ->withHeader('cookie', $censored);            $request = $request->withParsedBody([$censored => '']);        }        $clockwork->addDataSource(new PsrMessageDataSource($request, $response));        $clockwork->resolveRequest();        $clockwork->storeRequest();        $clockworkRequest = $clockwork->getRequest();        $response = $response            ->withHeader('X-Clockwork-Id', $clockworkRequest->id)            ->withHeader('X-Clockwork-Version', $clockwork::VERSION);        $grav = Grav::instance();        $basePath = $this->grav['base_url_relative'] . $grav['pages']->base();        if ($basePath) {            $response = $response->withHeader('X-Clockwork-Path', $basePath . '/__clockwork/');        }        return $response->withHeader('Server-Timing', ServerTiming::fromRequest($clockworkRequest)->value());    }    public function debuggerRequest(RequestInterface $request): Response    {        $clockwork = $this->clockwork;        $headers = [            'Content-Type' => 'application/json',            'Grav-Internal-SkipShutdown' => 1        ];        $path = $request->getUri()->getPath();        $clockworkDataUri = '#/__clockwork(?:/(?<id>[0-9-]+))?(?:/(?<direction>(?:previous|next)))?(?:/(?<count>\d+))?#';        if (preg_match($clockworkDataUri, $path, $matches) === false) {            $response = ['message' => 'Bad Input'];            return new Response(400, $headers, json_encode($response));        }        $id = $matches['id'] ?? null;        $direction = $matches['direction'] ?? null;        $count = $matches['count'] ?? null;        $storage = $clockwork->getStorage();        if ($direction === 'previous') {            $data = $storage->previous($id, $count);        } elseif ($direction === 'next') {            $data = $storage->next($id, $count);        } elseif ($id === 'latest') {            $data = $storage->latest();        } else {            $data = $storage->find($id);        }        if (preg_match('#(?<id>[0-9-]+|latest)/extended#', $path)) {            $clockwork->extendRequest($data);        }        if (!$data) {            $response = ['message' => 'Not Found'];            return new Response(404, $headers, json_encode($response));        }        $data = is_array($data) ? array_map(function ($item) {            return $item->toArray();        }, $data) : $data->toArray();        return new Response(200, $headers, json_encode($data));    }    /**     * @return void     */    protected function addMeasures(): void    {        if (!$this->enabled) {            return;        }        $nowTime = microtime(true);        $clkTimeLine = $this->clockwork ? $this->clockwork->timeline() : null;        $debTimeLine = $this->debugbar ? $this->debugbar['time'] : null;        foreach ($this->timers as $name => $data) {            $description = $data[0];            $startTime = $data[1] ?? null;            $endTime = $data[2] ?? $nowTime;            if ($clkTimeLine) {                $event = $clkTimeLine->event($description);                $event->finalize($startTime, $endTime);            } elseif ($debTimeLine) {                if ($endTime - $startTime < 0.001) {                    continue;                }                $debTimeLine->addMeasure($description ?? $name, $startTime, $endTime);            }        }        $this->timers = [];    }    /**     * Set/get the enabled state of the debugger     *     * @param bool|null $state If null, the method returns the enabled value. If set, the method sets the enabled state     * @return bool     */    public function enabled($state = null)    {        if ($state !== null) {            $this->enabled = (bool)$state;        }        return $this->enabled;    }    /**     * Add the debugger assets to the Grav Assets     *     * @return $this     */    public function addAssets()    {        if ($this->enabled) {            // Only add assets if Page is HTML            $page = $this->grav['page'];            if ($page->templateFormat() !== 'html') {                return $this;            }            /** @var Assets $assets */            $assets = $this->grav['assets'];            // Clockwork specific assets            if ($this->clockwork) {                $assets->addCss('/system/assets/debugger/clockwork.css', ['loading' => 'inline']);                $assets->addJs('/system/assets/debugger/clockwork.js', ['loading' => 'inline']);            }            // Debugbar specific assets            if ($this->debugbar) {                // Add jquery library                $assets->add('jquery', 101);                $this->renderer = $this->debugbar->getJavascriptRenderer();                $this->renderer->setIncludeVendors(false);                [$css_files, $js_files] = $this->renderer->getAssets(null, JavascriptRenderer::RELATIVE_URL);                foreach ((array)$css_files as $css) {                    $assets->addCss($css);                }                $assets->addCss('/system/assets/debugger/phpdebugbar.css', ['loading' => 'inline']);                foreach ((array)$js_files as $js) {                    $assets->addJs($js);                }            }        }        return $this;    }    /**     * @param int $limit     * @return array     */    public function getCaller($limit = 2)    {        $trace = debug_backtrace(false, $limit);        return array_pop($trace);    }    /**     * Adds a data collector     *     * @param DataCollectorInterface $collector     * @return $this     * @throws DebugBarException     */    public function addCollector($collector)    {        if ($this->debugbar && !$this->debugbar->hasCollector($collector->getName())) {            $this->debugbar->addCollector($collector);        }        return $this;    }    /**     * Returns a data collector     *     * @param string $name     * @return DataCollectorInterface|null     * @throws DebugBarException     */    public function getCollector($name)    {        if ($this->debugbar && $this->debugbar->hasCollector($name)) {            return $this->debugbar->getCollector($name);        }        return null;    }    /**     * Displays the debug bar     *     * @return $this     */    public function render()    {        if ($this->enabled && $this->debugbar) {            // Only add assets if Page is HTML            $page = $this->grav['page'];            if (!$this->renderer || $page->templateFormat() !== 'html') {                return $this;            }            $this->addMeasures();            $this->addDeprecations();            echo $this->renderer->render();        }        return $this;    }    /**     * Sends the data through the HTTP headers     *     * @return $this     */    public function sendDataInHeaders()    {        if ($this->enabled && $this->debugbar) {            $this->addMeasures();            $this->addDeprecations();            $this->debugbar->sendDataInHeaders();        }        return $this;    }    /**     * Returns collected debugger data.     *     * @return array|null     */    public function getData()    {        if (!$this->enabled || !$this->debugbar) {            return null;        }        $this->addMeasures();        $this->addDeprecations();        $this->timers = [];        return $this->debugbar->getData();    }    /**     * Hierarchical Profiler support.     *     * @param callable $callable     * @param string|null $message     * @return mixed     */    public function profile(callable $callable, string $message = null)    {        $this->startProfiling();        $response = $callable();        $this->stopProfiling($message);        return $response;    }    public function addTwigProfiler(Environment $twig): void    {        $clockwork = $this->getClockwork();        if ($clockwork) {            $source = new TwigClockworkDataSource($twig);            $source->listenToEvents();            $clockwork->addDataSource($source);        }    }    /**     * Start profiling code.     *     * @return void     */    public function startProfiling(): void    {        if ($this->enabled && extension_loaded('tideways_xhprof')) {            $this->profiling++;            if ($this->profiling === 1) {                // @phpstan-ignore-next-line                \tideways_xhprof_enable(TIDEWAYS_XHPROF_FLAGS_NO_BUILTINS);            }        }    }    /**     * Stop profiling code. Returns profiling array or null if profiling couldn't be done.     *     * @param string|null $message     * @return array|null     */    public function stopProfiling(string $message = null): ?array    {        $timings = null;        if ($this->enabled && extension_loaded('tideways_xhprof')) {            $profiling = $this->profiling - 1;            if ($profiling === 0) {                // @phpstan-ignore-next-line                $timings = \tideways_xhprof_disable();                $timings = $this->buildProfilerTimings($timings);                if ($this->clockwork) {                    /** @var UserData $userData */                    $userData = $this->clockwork->userData('Profiler');                    $userData->counters([                        'Calls' => count($timings)                    ]);                    $userData->table('Profiler', $timings);                } else {                    $this->addMessage($message ?? 'Profiler Analysis', 'debug', $timings);                }            }            $this->profiling = max(0, $profiling);        }        return $timings;    }    /**     * @param array $timings     * @return array     */    protected function buildProfilerTimings(array $timings): array    {        // Filter method calls which take almost no time.        $timings = array_filter($timings, function ($value) {            return $value['wt'] > 50;        });        uasort($timings, function (array $a, array $b) {            return $b['wt'] <=> $a['wt'];        });        $table = [];        foreach ($timings as $key => $timing) {            $parts = explode('==>', $key);            $method = $this->parseProfilerCall(array_pop($parts));            $context = $this->parseProfilerCall(array_pop($parts));            // Skip redundant method calls.            if ($context === 'Grav\Framework\RequestHandler\RequestHandler::handle()') {                continue;            }            // Do not profile library calls.            if (strpos($context, 'Grav\\') !== 0) {                continue;            }            $table[] = [                'Context' => $context,                'Method' => $method,                'Calls' => $timing['ct'],                'Time (ms)' => $timing['wt'] / 1000,            ];        }        return $table;    }    /**     * @param string|null $call     * @return mixed|string|null     */    protected function parseProfilerCall(?string $call)    {        if (null === $call) {            return '';        }        if (strpos($call, '@')) {            [$call,] = explode('@', $call);        }        if (strpos($call, '::')) {            [$class, $call] = explode('::', $call);        }        if (!isset($class)) {            return $call;        }        // It is also possible to display twig files, but they are being logged in views.        /*        if (strpos($class, '__TwigTemplate_') === 0 && class_exists($class)) {            $env = new Environment();            / ** @var Template $template * /            $template = new $class($env);            return $template->getTemplateName();        }        */        return ""{$class}::{$call}()"";    }    /**     * Start a timer with an associated name and description     *     * @param string      $name     * @param string|null $description     * @return $this     */    public function startTimer($name, $description = null)    {        $this->timers[$name] = [$description, microtime(true)];        return $this;    }    /**     * Stop the named timer     *     * @param string $name     * @return $this     */    public function stopTimer($name)    {        if (isset($this->timers[$name])) {            $endTime = microtime(true);            $this->timers[$name][] = $endTime;        }        return $this;    }    /**     * Dump variables into the Messages tab of the Debug Bar     *     * @param mixed  $message     * @param string $label     * @param mixed|bool $isString     * @return $this     */    public function addMessage($message, $label = 'info', $isString = true)    {        if ($this->enabled) {            if ($this->censored) {                if (!is_scalar($message)) {                    $message = 'CENSORED';                }                if (!is_scalar($isString)) {                    $isString = ['CENSORED'];                }            }            if ($this->debugbar) {                if (is_array($isString)) {                    $message = $isString;                    $isString = false;                } elseif (is_string($isString)) {                    $message = $isString;                    $isString = true;                }                $this->debugbar['messages']->addMessage($message, $label, $isString);            }            if ($this->clockwork) {                $context = $isString;                if (!is_scalar($message)) {                    $context = $message;                    $message = gettype($context);                }                if (is_bool($context)) {                    $context = [];                } elseif (!is_array($context)) {                    $type = gettype($context);                    $context = [$type => $context];                }                $this->clockwork->log($label, $message, $context);            }        }        return $this;    }    /**     * @param string $name     * @param object $event     * @param EventDispatcherInterface $dispatcher     * @param float|null $time     * @return $this     */    public function addEvent(string $name, $event, EventDispatcherInterface $dispatcher, float $time = null)    {        if ($this->enabled && $this->clockwork) {            $time = $time ?? microtime(true);            $duration = (microtime(true) - $time) * 1000;            $data = null;            if ($event && method_exists($event, '__debugInfo')) {                $data = $event;            }            $listeners = [];            foreach ($dispatcher->getListeners($name) as $listener) {                $listeners[] = $this->resolveCallable($listener);            }            $this->clockwork->addEvent($name, $data, $time, ['listeners' => $listeners, 'duration' => $duration]);        }        return $this;    }    /**     * Dump exception into the Messages tab of the Debug Bar     *     * @param Throwable $e     * @return Debugger     */    public function addException(Throwable $e)    {        if ($this->initialized && $this->enabled) {            if ($this->debugbar) {                $this->debugbar['exceptions']->addThrowable($e);            }            if ($this->clockwork) {                /** @var UserData $exceptions */                $exceptions = $this->clockwork->userData('Exceptions');                $exceptions->data(['message' => $e->getMessage()]);                $this->clockwork->alert($e->getMessage(), ['exception' => $e]);            }        }        return $this;    }    /**     * @return void     */    public function setErrorHandler()    {        $this->errorHandler = set_error_handler(            [$this, 'deprecatedErrorHandler']        );    }    /**     * @param int $errno     * @param string $errstr     * @param string $errfile     * @param int $errline     * @return bool     */    public function deprecatedErrorHandler($errno, $errstr, $errfile, $errline)    {        if ($errno !== E_USER_DEPRECATED && $errno !== E_DEPRECATED) {            if ($this->errorHandler) {                return call_user_func($this->errorHandler, $errno, $errstr, $errfile, $errline);            }            return true;        }        if (!$this->enabled) {            return true;        }        // Figure out error scope from the error.        $scope = 'unknown';        if (stripos($errstr, 'grav') !== false) {            $scope = 'grav';        } elseif (strpos($errfile, '/twig/') !== false) {            $scope = 'twig';        } elseif (stripos($errfile, '/yaml/') !== false) {            $scope = 'yaml';        } elseif (strpos($errfile, '/vendor/') !== false) {            $scope = 'vendor';        }        // Clean up backtrace to make it more useful.        $backtrace = debug_backtrace(DEBUG_BACKTRACE_PROVIDE_OBJECT);        // Skip current call.        array_shift($backtrace);        // Find yaml file where the error happened.        if ($scope === 'yaml') {            foreach ($backtrace as $current) {                if (isset($current['args'])) {                    foreach ($current['args'] as $arg) {                        if ($arg instanceof SplFileInfo) {                            $arg = $arg->getPathname();                        }                        if (is_string($arg) && preg_match('/.+\.(yaml|md)$/i', $arg)) {                            $errfile = $arg;                            $errline = 0;                            break 2;                        }                    }                }            }        }        // Filter arguments.        $cut = 0;        $previous = null;        foreach ($backtrace as $i => &$current) {            if (isset($current['args'])) {                $args = [];                foreach ($current['args'] as $arg) {                    if (is_string($arg)) {                        $arg = ""'"" . $arg . ""'"";                        if (mb_strlen($arg) > 100) {                            $arg = 'string';                        }                    } elseif (is_bool($arg)) {                        $arg = $arg ? 'true' : 'false';                    } elseif (is_scalar($arg)) {                        $arg = $arg;                    } elseif (is_object($arg)) {                        $arg = get_class($arg) . ' $object';                    } elseif (is_array($arg)) {                        $arg = '$array';                    } else {                        $arg = '$object';                    }                    $args[] = $arg;                }                $current['args'] = $args;            }            $object = $current['object'] ?? null;            unset($current['object']);            $reflection = null;            if ($object instanceof TemplateWrapper) {                $reflection = new ReflectionObject($object);                $property = $reflection->getProperty('template');                $property->setAccessible(true);                $object = $property->getValue($object);            }            if ($object instanceof Template) {                $file = $current['file'] ?? null;                if (preg_match('`(Template.php|TemplateWrapper.php)$`', $file)) {                    $current = null;                    continue;                }                $debugInfo = $object->getDebugInfo();                $line = 1;                if (!$reflection) {                    foreach ($debugInfo as $codeLine => $templateLine) {                        if ($codeLine <= $current['line']) {                            $line = $templateLine;                            break;                        }                    }                }                $src = $object->getSourceContext();                //$code = preg_split('/\r\n|\r|\n/', $src->getCode());                //$current['twig']['twig'] = trim($code[$line - 1]);                $current['twig']['file'] = $src->getPath();                $current['twig']['line'] = $line;                $prevFile = $previous['file'] ?? null;                if ($prevFile && $file === $prevFile) {                    $prevLine = $previous['line'];                    $line = 1;                    foreach ($debugInfo as $codeLine => $templateLine) {                        if ($codeLine <= $prevLine) {                            $line = $templateLine;                            break;                        }                    }                    //$previous['twig']['twig'] = trim($code[$line - 1]);                    $previous['twig']['file'] = $src->getPath();                    $previous['twig']['line'] = $line;                }                $cut = $i;            } elseif ($object instanceof ProcessorInterface) {                $cut = $cut ?: $i;                break;            }            $previous = &$backtrace[$i];        }        unset($current);        if ($cut) {            $backtrace = array_slice($backtrace, 0, $cut + 1);        }        $backtrace = array_values(array_filter($backtrace));        // Skip vendor libraries and the method where error was triggered.        foreach ($backtrace as $i => $current) {            if (!isset($current['file'])) {                continue;            }            if (strpos($current['file'], '/vendor/') !== false) {                $cut = $i + 1;                continue;            }            if (isset($current['function']) && ($current['function'] === 'user_error' || $current['function'] === 'trigger_error')) {                $cut = $i + 1;                continue;            }            break;        }        if ($cut) {            $backtrace = array_slice($backtrace, $cut);        }        $backtrace = array_values(array_filter($backtrace));        $current = reset($backtrace);        // If the issue happened inside twig file, change the file and line to match that file.        $file = $current['twig']['file'] ?? '';        if ($file) {            $errfile = $file;            $errline = $current['twig']['line'] ?? 0;        }        $deprecation = [            'scope' => $scope,            'message' => $errstr,            'file' => $errfile,            'line' => $errline,            'trace' => $backtrace,            'count' => 1        ];        $this->deprecations[] = $deprecation;        // Do not pass forward.        return true;    }    /**     * @return array     */    protected function getDeprecations(): array    {        if (!$this->deprecations) {            return [];        }        $list = [];        /** @var array $deprecated */        foreach ($this->deprecations as $deprecated) {            $list[] = $this->getDepracatedMessage($deprecated)[0];        }        return $list;    }    /**     * @return void     * @throws DebugBarException     */    protected function addDeprecations()    {        if (!$this->deprecations) {            return;        }        $collector = new MessagesCollector('deprecated');        $this->addCollector($collector);        $collector->addMessage('Your site is using following deprecated features:');        /** @var array $deprecated */        foreach ($this->deprecations as $deprecated) {            list($message, $scope) = $this->getDepracatedMessage($deprecated);            $collector->addMessage($message, $scope);        }    }    /**     * @param array $deprecated     * @return array     */    protected function getDepracatedMessage($deprecated)    {        $scope = $deprecated['scope'];        $trace = [];        if (isset($deprecated['trace'])) {            foreach ($deprecated['trace'] as $current) {                $class = $current['class'] ?? '';                $type = $current['type'] ?? '';                $function = $this->getFunction($current);                if (isset($current['file'])) {                    $current['file'] = str_replace(GRAV_ROOT . '/', '', $current['file']);                }                unset($current['class'], $current['type'], $current['function'], $current['args']);                if (isset($current['twig'])) {                    $trace[] = $current['twig'];                } else {                    $trace[] = ['call' => $class . $type . $function] + $current;                }            }        }        $array = [            'message' => $deprecated['message'],            'file' => $deprecated['file'],            'line' => $deprecated['line'],            'trace' => $trace        ];        return [            array_filter($array),            $scope        ];    }    /**     * @param array $trace     * @return string     */    protected function getFunction($trace)    {        if (!isset($trace['function'])) {            return '';        }        return $trace['function'] . '(' . implode(', ', $trace['args'] ?? []) . ')';    }    /**     * @param callable $callable     * @return string     */    protected function resolveCallable(callable $callable)    {        if (is_array($callable)) {            return get_class($callable[0]) . '->' . $callable[1] . '()';        }        return 'unknown';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_1166, Returns collected debugger data.\\n\\n @return array|null\\n, Returns collected debugger data.,    public function getData()    {        if (!$this->enabled || !$this->debugbar) {            return null;        }        $this->addMeasures();        $this->addDeprecations();        $this->timers = [];        return $this->debugbar->getData();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_1497, Stop the named timer\\n\\n @param string $name\\n @return $this\\n, Stop the named timer,    public function stopTimer($name)    {        if (isset($this->timers[$name])) {            $endTime = microtime(true);            $this->timers[$name][] = $endTime;        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_1999, Adds a data collector\\n\\n @param DataCollectorInterface $collector\\n @return $this\\n @throws DebugBarException\\n, Adds a data collector,    public function addCollector($collector)    {        if ($this->debugbar && !$this->debugbar->hasCollector($collector->getName())) {            $this->debugbar->addCollector($collector);        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Getters_1182, Magic method to determine if the attribute is set\\n\\n @param  int|string $offset Medium name value\\n @return boolean         True if the value is set\\n, Magic method to determine if the attribute is set,    public function __isset($offset)    {        return $this->offsetExists($offset);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Getters_1189, Returns an associative array of object properties.\n\n @return array\n, Returns an associative array of object properties.,"    public function toArray()    {        if ($this->gettersVariable) {            $var = $this->gettersVariable;            return $this->{$var};        }        $properties = (array)$this;        $list = [];        foreach ($properties as $property => $value) {            if ($property[0] !== ""\0"") {                $list[$property] = $value;            }        }        return $list;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1195, Process a request\\n\\n @return void\\n, Process a request,"    public function process()    {        if (isset($this->initialized['process'])) {            return;        }        // Initialize Grav if needed.        $this->setup();        $this->initialized['process'] = true;        $container = new Container(            [                'initializeProcessor' => function () {                    return new InitializeProcessor($this);                },                'backupsProcessor' => function () {                    return new BackupsProcessor($this);                },                'pluginsProcessor' => function () {                    return new PluginsProcessor($this);                },                'themesProcessor' => function () {                    return new ThemesProcessor($this);                },                'schedulerProcessor' => function () {                    return new SchedulerProcessor($this);                },                'requestProcessor' => function () {                    return new RequestProcessor($this);                },                'tasksProcessor' => function () {                    return new TasksProcessor($this);                },                'assetsProcessor' => function () {                    return new AssetsProcessor($this);                },                'twigProcessor' => function () {                    return new TwigProcessor($this);                },                'pagesProcessor' => function () {                    return new PagesProcessor($this);                },                'debuggerAssetsProcessor' => function () {                    return new DebuggerAssetsProcessor($this);                },                'renderProcessor' => function () {                    return new RenderProcessor($this);                },            ]        );        $default = static function () {            return new Response(404, ['Expires' => 0, 'Cache-Control' => 'no-store, max-age=0'], 'Not Found');        };        $collection = new RequestHandler($this->middleware, $default, $container);        $response = $collection->handle($this['request']);        $body = $response->getBody();        /** @var Messages $messages */        $messages = $this['messages'];        // Prevent caching if session messages were displayed in the page.        $noCache = $messages->isCleared();        if ($noCache) {            $response = $response->withHeader('Cache-Control', 'no-store, max-age=0');        }        // Handle ETag and If-None-Match headers.        if ($response->getHeaderLine('ETag') === '1') {            $etag = md5($body);            $response = $response->withHeader('ETag', '""' . $etag . '""');            $search = trim($this['request']->getHeaderLine('If-None-Match'), '""');            if ($noCache === false && $search === $etag) {                $response = $response->withStatus(304);                $body = '';            }        }        // Echo page content.        $this->header($response);        echo $body;        $this['debugger']->render();        // Response object can turn off all shutdown processing. This can be used for example to speed up AJAX responses.        // Note that using this feature will also turn off response compression.        if ($response->getHeaderLine('Grav-Internal-SkipShutdown') !== '1') {            register_shutdown_function([$this, 'shutdown']);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1198, Set the system locale based on the language and configuration\n\n @return void\n, Set the system locale based on the language and configuration,"    public function setLocale()    {        // Initialize Locale if set and configured.        if ($this['language']->enabled() && $this['config']->get('system.languages.override_locale')) {            $language = $this['language']->getLanguage();            setlocale(LC_ALL, strlen($language) < 3 ? ($language . '_' . strtoupper($language)) : $language);        } elseif ($this['config']->get('system.default_locale')) {            setlocale(LC_ALL, $this['config']->get('system.default_locale'));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1201, Magic Catch All Function\\n\\n Used to call closures.\\n\\n Source: http://stackoverflow.com/questions/419804/closures-as-class-members\\n\\n @param string $method\\n @param array $args\\n @return mixed|null\\n, Magic Catch All Function,"    public function __call($method, $args)    {        $closure = $this->{$method} ?? null;        return is_callable($closure) ? $closure(...$args) : null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1203, Initialize and return a Grav instance\n\n @param  array $values\n @return static\n, Initialize and return a Grav instance,"    protected static function load(array $values)    {        $container = new static($values);        $container['debugger'] = new Debugger();        $container['grav'] = function (Container $container) {            user_error('Calling $grav[\'grav\'] or {{ grav.grav }} is deprecated since Grav 1.6, just use $grav or {{ grav }}', E_USER_DEPRECATED);            return $container;        };        $container->registerServices();        return $container;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1204, Register all services\\n Services are defined in the diMap. They can either only the class\\n of a Service Provider or a pair of serviceKey => serviceClass that\\n gets directly mapped into the container.\\n\\n @return void\\n, Register all services,    protected function registerServices()    {        foreach (self::$diMap as $serviceKey => $serviceClass) {            if (is_int($serviceKey)) {                $this->register(new $serviceClass);            } else {                $this[$serviceKey] = function ($c) use ($serviceClass) {                    return new $serviceClass($c);                };            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_141, Measure how long it takes to do an action.\n\n @param string $timerId\n @param string $timerTitle\n @param callable $callback\n @return mixed   Returns value returned by the callable.\n, Measure how long it takes to do an action.,"    public function measureTime(string $timerId, string $timerTitle, callable $callback)    {        $debugger = $this['debugger'];        $debugger->startTimer($timerId, $timerTitle);        $result = $callback();        $debugger->stopTimer($timerId);        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1523, Terminates Grav request with a response.\n\n Please use this method instead of calling `die();` or `exit();`. Note that you need to create a response object.\n\n @param ResponseInterface $response\n @return void\n, Terminates Grav request with a response.,"    public function close(ResponseInterface $response): void    {        // Make sure nothing extra gets written to the response.        while (ob_get_level()) {            ob_end_clean();        }        // Close the session.        if (isset($this['session'])) {            $this['session']->close();        }        /** @var ServerRequestInterface $request */        $request = $this['request'];        /** @var Debugger $debugger */        $debugger = $this['debugger'];        $response = $debugger->logRequest($request, $response);        $body = $response->getBody();        /** @var Messages $messages */        $messages = $this['messages'];        // Prevent caching if session messages were displayed in the page.        $noCache = $messages->isCleared();        if ($noCache) {            $response = $response->withHeader('Cache-Control', 'no-store, max-age=0');        }        // Handle ETag and If-None-Match headers.        if ($response->getHeaderLine('ETag') === '1') {            $etag = md5($body);            $response = $response->withHeader('ETag', '""' . $etag . '""');            $search = trim($this['request']->getHeaderLine('If-None-Match'), '""');            if ($noCache === false && $search === $etag) {                $response = $response->withStatus(304);                $body = '';            }        }        // Echo page content.        $this->header($response);        echo $body;        exit();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1532," This attempts to find media, other files, and download them\n\n @param string $path\n @return PageInterface|false\n"," This attempts to find media, other files, and download them","    public function fallbackUrl($path)    {        $this->fireEvent('onPageFallBackUrl');        /** @var Uri $uri */        $uri = $this['uri'];        /** @var Config $config */        $config = $this['config'];        $uri_extension = strtolower($uri->extension());        $fallback_types = $config->get('system.media.allowed_fallback_types', null);        $supported_types = $config->get('media.types');        // Check whitelist first, then ensure extension is a valid media type        if (!empty($fallback_types) && !in_array($uri_extension, $fallback_types, true)) {            return false;        }        if (!array_key_exists($uri_extension, $supported_types)) {            return false;        }        $path_parts = pathinfo($path);        /** @var Pages $pages */        $pages = $this['pages'];        $page = $pages->find($path_parts['dirname'], true);        if ($page) {            $media = $page->media()->all();            $parsed_url = parse_url(rawurldecode($uri->basename()));            $media_file = $parsed_url['path'];            // if this is a media object, try actions first            if (isset($media[$media_file])) {                /** @var Medium $medium */                $medium = $media[$media_file];                foreach ($uri->query(null, true) as $action => $params) {                    if (in_array($action, ImageMedium::$magic_actions, true)) {                        call_user_func_array([&$medium, $action], explode(',', $params));                    }                }                Utils::download($medium->path(), false);            }            // unsupported media type, try to download it...            if ($uri_extension) {                $extension = $uri_extension;            } else {                if (isset($path_parts['extension'])) {                    $extension = $path_parts['extension'];                } else {                    $extension = null;                }            }            if ($extension) {                $download = true;                if (in_array(ltrim($extension, '.'), $config->get('system.media.unsupported_inline_types', []), true)) {                    $download = false;                }                Utils::download($page->path() . DIRECTORY_SEPARATOR . $uri->basename(), $download);            }            // Nothing found            return false;        }        return $page;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_2027, Grav container is the heart of Grav.\\n\\n @package Grav\\\\Common\\n, Grav container is the heart of Grav.,"class Grav extends Container{    /** @var string Processed output for the page. */    public $output;    /** @var static The singleton instance */    protected static $instance;    /**     * @var array Contains all Services and ServicesProviders that are mapped     *            to the dependency injection container.     */    protected static $diMap = [        AccountsServiceProvider::class,        AssetsServiceProvider::class,        BackupsServiceProvider::class,        ConfigServiceProvider::class,        ErrorServiceProvider::class,        FilesystemServiceProvider::class,        FlexServiceProvider::class,        InflectorServiceProvider::class,        LoggerServiceProvider::class,        OutputServiceProvider::class,        PagesServiceProvider::class,        RequestServiceProvider::class,        SessionServiceProvider::class,        StreamsServiceProvider::class,        TaskServiceProvider::class,        'browser'    => Browser::class,        'cache'      => Cache::class,        'events'     => EventDispatcher::class,        'exif'       => Exif::class,        'plugins'    => Plugins::class,        'scheduler'  => Scheduler::class,        'taxonomy'   => Taxonomy::class,        'themes'     => Themes::class,        'twig'       => Twig::class,        'uri'        => Uri::class,    ];    /**     * @var array All middleware processors that are processed in $this->process()     */    protected $middleware = [        'initializeProcessor',        'pluginsProcessor',        'themesProcessor',        'requestProcessor',        'tasksProcessor',        'backupsProcessor',        'schedulerProcessor',        'assetsProcessor',        'twigProcessor',        'pagesProcessor',        'debuggerAssetsProcessor',        'renderProcessor',    ];    /** @var array */    protected $initialized = [];    /**     * Reset the Grav instance.     *     * @return void     */    public static function resetInstance()    {        if (self::$instance) {            // @phpstan-ignore-next-line            self::$instance = null;        }    }    /**     * Return the Grav instance. Create it if it's not already instanced     *     * @param array $values     * @return Grav     */    public static function instance(array $values = [])    {        if (null === self::$instance) {            self::$instance = static::load($values);        } elseif ($values) {            $instance = self::$instance;            foreach ($values as $key => $value) {                $instance->offsetSet($key, $value);            }        }        return self::$instance;    }    /**     * Get Grav version.     *     * @return string     */    public function getVersion(): string    {        return GRAV_VERSION;    }    /**     * @return bool     */    public function isSetup(): bool    {        return isset($this->initialized['setup']);    }    /**     * Setup Grav instance using specific environment.     *     * @param string|null $environment     * @return $this     */    public function setup(string $environment = null)    {        if (isset($this->initialized['setup'])) {            return $this;        }        $this->initialized['setup'] = true;        // Force environment if passed to the method.        if ($environment) {            Setup::$environment = $environment;        }        // Initialize setup and streams.        $this['setup'];        $this['streams'];        return $this;    }    /**     * Initialize CLI environment.     *     * Call after `$grav->setup($environment)`     *     * - Load configuration     * - Initialize logger     * - Disable debugger     * - Set timezone, locale     * - Load plugins (call PluginsLoadedEvent)     * - Set Pages and Users type to be used in the site     *     * This method WILL NOT initialize assets, twig or pages.     *     * @return $this     */    public function initializeCli()    {        InitializeProcessor::initializeCli($this);        return $this;    }    /**     * Process a request     *     * @return void     */    public function process()    {        if (isset($this->initialized['process'])) {            return;        }        // Initialize Grav if needed.        $this->setup();        $this->initialized['process'] = true;        $container = new Container(            [                'initializeProcessor' => function () {                    return new InitializeProcessor($this);                },                'backupsProcessor' => function () {                    return new BackupsProcessor($this);                },                'pluginsProcessor' => function () {                    return new PluginsProcessor($this);                },                'themesProcessor' => function () {                    return new ThemesProcessor($this);                },                'schedulerProcessor' => function () {                    return new SchedulerProcessor($this);                },                'requestProcessor' => function () {                    return new RequestProcessor($this);                },                'tasksProcessor' => function () {                    return new TasksProcessor($this);                },                'assetsProcessor' => function () {                    return new AssetsProcessor($this);                },                'twigProcessor' => function () {                    return new TwigProcessor($this);                },                'pagesProcessor' => function () {                    return new PagesProcessor($this);                },                'debuggerAssetsProcessor' => function () {                    return new DebuggerAssetsProcessor($this);                },                'renderProcessor' => function () {                    return new RenderProcessor($this);                },            ]        );        $default = static function () {            return new Response(404, ['Expires' => 0, 'Cache-Control' => 'no-store, max-age=0'], 'Not Found');        };        $collection = new RequestHandler($this->middleware, $default, $container);        $response = $collection->handle($this['request']);        $body = $response->getBody();        /** @var Messages $messages */        $messages = $this['messages'];        // Prevent caching if session messages were displayed in the page.        $noCache = $messages->isCleared();        if ($noCache) {            $response = $response->withHeader('Cache-Control', 'no-store, max-age=0');        }        // Handle ETag and If-None-Match headers.        if ($response->getHeaderLine('ETag') === '1') {            $etag = md5($body);            $response = $response->withHeader('ETag', '""' . $etag . '""');            $search = trim($this['request']->getHeaderLine('If-None-Match'), '""');            if ($noCache === false && $search === $etag) {                $response = $response->withStatus(304);                $body = '';            }        }        // Echo page content.        $this->header($response);        echo $body;        $this['debugger']->render();        // Response object can turn off all shutdown processing. This can be used for example to speed up AJAX responses.        // Note that using this feature will also turn off response compression.        if ($response->getHeaderLine('Grav-Internal-SkipShutdown') !== '1') {            register_shutdown_function([$this, 'shutdown']);        }    }    /**     * Terminates Grav request with a response.     *     * Please use this method instead of calling `die();` or `exit();`. Note that you need to create a response object.     *     * @param ResponseInterface $response     * @return void     */    public function close(ResponseInterface $response): void    {        // Make sure nothing extra gets written to the response.        while (ob_get_level()) {            ob_end_clean();        }        // Close the session.        if (isset($this['session'])) {            $this['session']->close();        }        /** @var ServerRequestInterface $request */        $request = $this['request'];        /** @var Debugger $debugger */        $debugger = $this['debugger'];        $response = $debugger->logRequest($request, $response);        $body = $response->getBody();        /** @var Messages $messages */        $messages = $this['messages'];        // Prevent caching if session messages were displayed in the page.        $noCache = $messages->isCleared();        if ($noCache) {            $response = $response->withHeader('Cache-Control', 'no-store, max-age=0');        }        // Handle ETag and If-None-Match headers.        if ($response->getHeaderLine('ETag') === '1') {            $etag = md5($body);            $response = $response->withHeader('ETag', '""' . $etag . '""');            $search = trim($this['request']->getHeaderLine('If-None-Match'), '""');            if ($noCache === false && $search === $etag) {                $response = $response->withStatus(304);                $body = '';            }        }        // Echo page content.        $this->header($response);        echo $body;        exit();    }    /**     * @param ResponseInterface $response     * @return void     * @deprecated 1.7 Do not use     */    public function exit(ResponseInterface $response): void    {        $this->close($response);    }    /**     * Terminates Grav request and redirects browser to another location.     *     * Please use this method instead of calling `header(""Location: {$url}"", true, 302); exit();`.     *     * @param string $route Internal route.     * @param int|null $code  Redirection code (30x)     * @return void     */    public function redirect($route, $code = null): void    {        $response = $this->getRedirectResponse($route, $code);        $this->close($response);    }    /**     * Returns redirect response object from Grav.     *     * @param string $route Internal route.     * @param int|null $code  Redirection code (30x)     * @return ResponseInterface     */    public function getRedirectResponse($route, $code = null): ResponseInterface    {        /** @var Uri $uri */        $uri = $this['uri'];        // Clean route for redirect        $route = preg_replace(""#^\/[\\\/]+\/#"", '/', $route);        if ($code < 300 || $code > 399) {            $code = null;        }        if (null === $code) {            // Check for redirect code in the route: e.g. /new/[301], /new[301]/route or /new[301].html            $regex = '/.*(\[(30[1-7])\])(.\w+|\/.*?)?$/';            preg_match($regex, $route, $matches);            if ($matches) {                $route = str_replace($matches[1], '', $matches[0]);                $code = $matches[2];            }        }        if ($code === null) {            $code = $this['config']->get('system.pages.redirect_default_code', 302);        }        if ($uri::isExternal($route)) {            $url = $route;        } else {            $url = rtrim($uri->rootUrl(), '/') . '/';            if ($this['config']->get('system.pages.redirect_trailing_slash', true)) {                $url .= trim($route, '/'); // Remove trailing slash            } else {                $url .= ltrim($route, '/'); // Support trailing slash default routes            }        }        return new Response($code, ['Location' => $url]);    }    /**     * Redirect browser to another location taking language into account (preferred)     *     * @param string $route Internal route.     * @param int    $code  Redirection code (30x)     * @return void     */    public function redirectLangSafe($route, $code = null)    {        if (!$this['uri']->isExternal($route)) {            $this->redirect($this['pages']->route($route), $code);        } else {            $this->redirect($route, $code);        }    }    /**     * Set response header.     *     * @param ResponseInterface|null $response     * @return void     */    public function header(ResponseInterface $response = null)    {        if (null === $response) {            /** @var PageInterface $page */            $page = $this['page'];            $response = new Response($page->httpResponseCode(), $page->httpHeaders(), '');        }        header(""HTTP/{$response->getProtocolVersion()} {$response->getStatusCode()} {$response->getReasonPhrase()}"");        foreach ($response->getHeaders() as $key => $values) {            // Skip internal Grav headers.            if (strpos($key, 'Grav-Internal-') === 0) {                continue;            }            foreach ($values as $i => $value) {                header($key . ': ' . $value, $i === 0);            }        }    }    /**     * Set the system locale based on the language and configuration     *     * @return void     */    public function setLocale()    {        // Initialize Locale if set and configured.        if ($this['language']->enabled() && $this['config']->get('system.languages.override_locale')) {            $language = $this['language']->getLanguage();            setlocale(LC_ALL, strlen($language) < 3 ? ($language . '_' . strtoupper($language)) : $language);        } elseif ($this['config']->get('system.default_locale')) {            setlocale(LC_ALL, $this['config']->get('system.default_locale'));        }    }    /**     * @param object $event     * @return object     */    public function dispatchEvent($event)    {        /** @var EventDispatcherInterface $events */        $events = $this['events'];        $eventName = get_class($event);        $timestamp = microtime(true);        $event = $events->dispatch($event);        /** @var Debugger $debugger */        $debugger = $this['debugger'];        $debugger->addEvent($eventName, $event, $events, $timestamp);        return $event;    }    /**     * Fires an event with optional parameters.     *     * @param  string $eventName     * @param  Event|null $event     * @return Event     */    public function fireEvent($eventName, Event $event = null)    {        /** @var EventDispatcherInterface $events */        $events = $this['events'];        if (null === $event) {            $event = new Event();        }        $timestamp = microtime(true);        $events->dispatch($event, $eventName);        /** @var Debugger $debugger */        $debugger = $this['debugger'];        $debugger->addEvent($eventName, $event, $events, $timestamp);        return $event;    }    /**     * Set the final content length for the page and flush the buffer     *     * @return void     */    public function shutdown()    {        // Prevent user abort allowing onShutdown event to run without interruptions.        if (function_exists('ignore_user_abort')) {            @ignore_user_abort(true);        }        // Close the session allowing new requests to be handled.        if (isset($this['session'])) {            $this['session']->close();        }        /** @var Config $config */        $config = $this['config'];        if ($config->get('system.debugger.shutdown.close_connection', true)) {            // Flush the response and close the connection to allow time consuming tasks to be performed without leaving            // the connection to the client open. This will make page loads to feel much faster.            // FastCGI allows us to flush all response data to the client and finish the request.            $success = function_exists('fastcgi_finish_request') ? @fastcgi_finish_request() : false;            if (!$success) {                // Unfortunately without FastCGI there is no way to force close the connection.                // We need to ask browser to close the connection for us.                if ($config->get('system.cache.gzip')) {                    // Flush gzhandler buffer if gzip setting was enabled to get the size of the compressed output.                    ob_end_flush();                } elseif ($config->get('system.cache.allow_webserver_gzip')) {                    // Let web server to do the hard work.                    header('Content-Encoding: identity');                } elseif (function_exists('apache_setenv')) {                    // Without gzip we have no other choice than to prevent server from compressing the output.                    // This action turns off mod_deflate which would prevent us from closing the connection.                    @apache_setenv('no-gzip', '1');                } else {                    // Fall back to unknown content encoding, it prevents most servers from deflating the content.                    header('Content-Encoding: none');                }                // Get length and close the connection.                header('Content-Length: ' . ob_get_length());                header('Connection: close');                ob_end_flush();                @ob_flush();                flush();            }        }        // Run any time consuming tasks.        $this->fireEvent('onShutdown');    }    /**     * Magic Catch All Function     *     * Used to call closures.     *     * Source: http://stackoverflow.com/questions/419804/closures-as-class-members     *     * @param string $method     * @param array $args     * @return mixed|null     */    public function __call($method, $args)    {        $closure = $this->{$method} ?? null;        return is_callable($closure) ? $closure(...$args) : null;    }    /**     * Measure how long it takes to do an action.     *     * @param string $timerId     * @param string $timerTitle     * @param callable $callback     * @return mixed   Returns value returned by the callable.     */    public function measureTime(string $timerId, string $timerTitle, callable $callback)    {        $debugger = $this['debugger'];        $debugger->startTimer($timerId, $timerTitle);        $result = $callback();        $debugger->stopTimer($timerId);        return $result;    }    /**     * Initialize and return a Grav instance     *     * @param  array $values     * @return static     */    protected static function load(array $values)    {        $container = new static($values);        $container['debugger'] = new Debugger();        $container['grav'] = function (Container $container) {            user_error('Calling $grav[\'grav\'] or {{ grav.grav }} is deprecated since Grav 1.6, just use $grav or {{ grav }}', E_USER_DEPRECATED);            return $container;        };        $container->registerServices();        return $container;    }    /**     * Register all services     * Services are defined in the diMap. They can either only the class     * of a Service Provider or a pair of serviceKey => serviceClass that     * gets directly mapped into the container.     *     * @return void     */    protected function registerServices()    {        foreach (self::$diMap as $serviceKey => $serviceClass) {            if (is_int($serviceKey)) {                $this->register(new $serviceClass);            } else {                $this[$serviceKey] = function ($c) use ($serviceClass) {                    return new $serviceClass($c);                };            }        }    }    /**     * This attempts to find media, other files, and download them     *     * @param string $path     * @return PageInterface|false     */    public function fallbackUrl($path)    {        $this->fireEvent('onPageFallBackUrl');        /** @var Uri $uri */        $uri = $this['uri'];        /** @var Config $config */        $config = $this['config'];        $uri_extension = strtolower($uri->extension());        $fallback_types = $config->get('system.media.allowed_fallback_types', null);        $supported_types = $config->get('media.types');        // Check whitelist first, then ensure extension is a valid media type        if (!empty($fallback_types) && !in_array($uri_extension, $fallback_types, true)) {            return false;        }        if (!array_key_exists($uri_extension, $supported_types)) {            return false;        }        $path_parts = pathinfo($path);        /** @var Pages $pages */        $pages = $this['pages'];        $page = $pages->find($path_parts['dirname'], true);        if ($page) {            $media = $page->media()->all();            $parsed_url = parse_url(rawurldecode($uri->basename()));            $media_file = $parsed_url['path'];            // if this is a media object, try actions first            if (isset($media[$media_file])) {                /** @var Medium $medium */                $medium = $media[$media_file];                foreach ($uri->query(null, true) as $action => $params) {                    if (in_array($action, ImageMedium::$magic_actions, true)) {                        call_user_func_array([&$medium, $action], explode(',', $params));                    }                }                Utils::download($medium->path(), false);            }            // unsupported media type, try to download it...            if ($uri_extension) {                $extension = $uri_extension;            } else {                if (isset($path_parts['extension'])) {                    $extension = $path_parts['extension'];                } else {                    $extension = null;                }            }            if ($extension) {                $download = true;                if (in_array(ltrim($extension, '.'), $config->get('system.media.unsupported_inline_types', []), true)) {                    $download = false;                }                Utils::download($page->path() . DIRECTORY_SEPARATOR . $uri->basename(), $download);            }            // Nothing found            return false;        }        return $page;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_ClientTest_682," Test fetching an access token with assertion credentials\n populates the ""created"" field\n", Test fetching an access token with assertion credentials,"  public function testFetchAccessTokenWithAssertionAddsCreated()  {    $this->checkServiceAccountCredentials();    $client = $this->getClient();    $client->useApplicationDefaultCredentials();    $token = $client->fetchAccessTokenWithAssertion();    $this->assertNotNull($token);    $this->assertArrayHasKey('created', $token);  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_607, Attempt to exchange a code for an valid authentication token.\\\\\\\\n Helper wrapped around the OAuth 2.0 implementation.\\\\\\\\n\\\\\\\\n @param $code string code from accounts.google.com\\\\\\\\n @return array access token\\\\\\\\n, Attempt to exchange a code for an valid authentication token.,"  public function fetchAccessTokenWithAuthCode($code)  {    if (strlen($code) == 0) {      throw new InvalidArgumentException(""Invalid code"");    }    $auth = $this->getOAuth2Service();    $auth->setCode($code);    $auth->setRedirectUri($this->getRedirectUri());    $httpHandler = HttpHandlerFactory::build($this->getHttpClient());    $creds = $auth->fetchAuthToken($httpHandler);    if ($creds && isset($creds['access_token'])) {      $creds['created'] = time();      $this->setAccessToken($creds);    }    return $creds;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_608, For backwards compatibility\\\\\\\\n alias for fetchAccessTokenWithAssertion\\\\\\\\n\\\\\\\\n @return array access token\\\\\\\\n @deprecated\\\\\\\\n, For backwards compatibility,  public function refreshTokenWithAssertion()  {    return $this->fetchAccessTokenWithAssertion();  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_610, To prevent useApplicationDefaultCredentials from inappropriately being\n called in a conditional\n\n @see https://developers.google.com/identity/protocols/application-default-credentials\n, To prevent useApplicationDefaultCredentials from inappropriately being,  public function isUsingApplicationDefaultCredentials()  {    return $this->config['use_application_default_credentials'];  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_611," Set the access token used for requests.\\\\\\\\n\\\\\\\\n Note that at the time requests are sent, tokens are cached. A token will be\\\\\\\\n cached for each combination of service and authentication scopes. If a\\\\\\\\n cache pool is not provided, creating a new instance of the client will\\\\\\\\n allow modification of access tokens. If a persistent cache pool is\\\\\\\\n provided, in order to change the access token, you must clear the cached\\\\\\\\n token by calling `$client->getCache()->clear()`. (Use caution in this case,\\\\\\\\n as calling `clear()` will remove all cache items, including any items not\\\\\\\\n related to Google API PHP Client.)\\\\\\\\n\\\\\\\\n @param string|array $token\\\\\\\\n @throws InvalidArgumentException\\\\\\\\n", Set the access token used for requests.,"  public function setAccessToken($token)  {    if (is_string($token)) {      if ($json = json_decode($token, true)) {        $token = $json;      } else {        // assume $token is just the token string        $token = array(          'access_token' => $token,        );      }    }    if ($token == null) {      throw new InvalidArgumentException('invalid json token');    }    if (!isset($token['access_token'])) {      throw new InvalidArgumentException(""Invalid token format"");    }    $this->token = $token;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_623," Set the application name, this is included in the User-Agent HTTP header.\n @param string $applicationName\n"," Set the application name, this is included in the User-Agent HTTP header.",  public function setApplicationName($applicationName)  {    $this->config['application_name'] = $applicationName;  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_624," If 'plus.login' is included in the list of requested scopes, you can use\n this method to define types of app activities that your app will write.\n You can find a list of available types here:\n @link https://developers.google.com/+/api/moment-types\n\n @param array $requestVisibleActions Array of app activity types\n"," If 'plus.login' is included in the list of requested scopes, you can use","  public function setRequestVisibleActions($requestVisibleActions)  {    if (is_array($requestVisibleActions)) {      $requestVisibleActions = implode("" "", $requestVisibleActions);    }    $this->config['request_visible_actions'] = $requestVisibleActions;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_625," Set the developer key to use, these are obtained through the API Console.\\\\\\\\n @see http://code.google.com/apis/console-help/#generatingdevkeys\\\\\\\\n @param string $developerKey\\\\\\\\n"," Set the developer key to use, these are obtained through the API Console.",  public function setDeveloperKey($developerKey)  {    $this->config['developer_key'] = $developerKey;  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_629," If this is provided with the value true, and the authorization request is\\\\\\\\n granted, the authorization will include any previous authorizations\\\\\\\\n granted to this user/application combination for other scopes.\\\\\\\\n @param $include boolean - the URL-space to use.\\\\\\\\n"," If this is provided with the value true, and the authorization request is",  public function setIncludeGrantedScopes($include)  {    $this->config['include_granted_scopes'] = $include;  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_630," sets function to be called when an access token is fetched\\\\n @param callable $tokenCallback - function ($cacheKey, $accessToken)\\\\n", sets function to be called when an access token is fetched,  public function setTokenCallback(callable $tokenCallback)  {    $this->config['token_callback'] = $tokenCallback;  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_631," Set the scopes to be requested. Must be called before createAuthUrl().\\\\\\\\n Will remove any previously configured scopes.\\\\\\\\n @param string|array $scope_or_scopes, ie:\\\\\\\\n    array(\\\\\\\\n        'https://www.googleapis.com/auth/plus.login',\\\\\\\\n        'https://www.googleapis.com/auth/moderator'\\\\\\\\n    );\\\\\\\\n", Set the scopes to be requested. Must be called before createAuthUrl().,  public function setScopes($scope_or_scopes)  {    $this->requestedScopes = array();    $this->addScope($scope_or_scopes);  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_632," This functions adds a scope to be requested as part of the OAuth2.0 flow.\n Will append any scopes not previously requested to the scope parameter.\n A single string will be treated as a scope to request. An array of strings\n will each be appended.\n @param $scope_or_scopes string|array e.g. ""profile""\n", This functions adds a scope to be requested as part of the OAuth2.0 flow.,"  public function addScope($scope_or_scopes)  {    if (is_string($scope_or_scopes) && !in_array($scope_or_scopes, $this->requestedScopes)) {      $this->requestedScopes[] = $scope_or_scopes;    } else if (is_array($scope_or_scopes)) {      foreach ($scope_or_scopes as $scope) {        $this->addScope($scope);      }    }  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_636, Are we running in Google AppEngine?\\\\\\\\n return bool\\\\\\\\n, Are we running in Google AppEngine?,"  public function isAppEngine()  {    return (isset($_SERVER['SERVER_SOFTWARE']) &&        strpos($_SERVER['SERVER_SOFTWARE'], 'Google App Engine') !== false);  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_638," Set the auth config from new or deprecated JSON config.\\\\n This structure should match the file downloaded from\\\\n the ""Download JSON"" button on in the Google Developer\\\\n Console.\\\\n @param string|array $config the configuration json\\\\n @throws \\\\\\\\Google\\\\\\\\Exception\\\\n", Set the auth config from new or deprecated JSON config.,"  public function setAuthConfig($config)  {    if (is_string($config)) {      if (!file_exists($config)) {        throw new InvalidArgumentException(sprintf('file ""%s"" does not exist', $config));      }      $json = file_get_contents($config);      if (!$config = json_decode($json, true)) {        throw new LogicException('invalid json for auth config');      }    }    $key = isset($config['installed']) ? 'installed' : 'web';    if (isset($config['type']) && $config['type'] == 'service_account') {      // application default credentials      $this->useApplicationDefaultCredentials();      // set the information from the config      $this->setClientId($config['client_id']);      $this->config['client_email'] = $config['client_email'];      $this->config['signing_key'] = $config['private_key'];      $this->config['signing_algorithm'] = 'HS256';    } elseif (isset($config[$key])) {      // old-style      $this->setClientId($config[$key]['client_id']);      $this->setClientSecret($config[$key]['client_secret']);      if (isset($config[$key]['redirect_uris'])) {        $this->setRedirectUri($config[$key]['redirect_uris'][0]);      }    } else {      // new-style      $this->setClientId($config['client_id']);      $this->setClientSecret($config['client_secret']);      if (isset($config['redirect_uris'])) {        $this->setRedirectUri($config['redirect_uris'][0]);      }    }  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_643, create a default google auth object\\n, create a default google auth object,"  protected function createOAuth2Service()  {    $auth = new OAuth2(        [          'clientId'          => $this->getClientId(),          'clientSecret'      => $this->getClientSecret(),          'authorizationUri'   => self::OAUTH2_AUTH_URL,          'tokenCredentialUri' => self::OAUTH2_TOKEN_URI,          'redirectUri'       => $this->getRedirectUri(),          'issuer'            => $this->config['client_id'],          'signingKey'        => $this->config['signing_key'],          'signingAlgorithm'  => $this->config['signing_algorithm'],        ]    );    return $auth;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Collection_653," Extension to the regular Google\\Model that automatically\n exposes the items array for iteration, so you can just\n iterate over the object rather than a reference inside.\n", Extension to the regular Google,"class Collection extends Model implements \Iterator, \Countable{  protected $collection_key = 'items';  public function rewind()  {    if (isset($this->{$this->collection_key})        && is_array($this->{$this->collection_key})) {      reset($this->{$this->collection_key});    }  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_656," Getter that handles passthrough access to the data array, and lazy object creation.\\\\\\\\n @param string $key Property name.\\\\\\\\n @return mixed The value if any, or null.\\\\\\\\n"," Getter that handles passthrough access to the data array, and lazy object creation.",  public function __get($key)  {    $keyType = $this->keyType($key);    $keyDataType = $this->dataType($key);    if ($keyType && !isset($this->processed[$key])) {      if (isset($this->modelData[$key])) {        $val = $this->modelData[$key];      } elseif ($keyDataType == 'array' || $keyDataType == 'map') {        $val = array();      } else {        $val = null;      }      if ($this->isAssociativeArray($val)) {        if ($keyDataType && 'map' == $keyDataType) {          foreach ($val as $arrayKey => $arrayItem) {              $this->modelData[$key][$arrayKey] =                new $keyType($arrayItem);          }        } else {          $this->modelData[$key] = new $keyType($val);        }      } else if (is_array($val)) {        $arrayObject = array();        foreach ($val as $arrayIndex => $arrayItem) {          $arrayObject[$arrayIndex] = new $keyType($arrayItem);        }        $this->modelData[$key] = $arrayObject;      }      $this->processed[$key] = true;    }    return isset($this->modelData[$key]) ? $this->modelData[$key] : null;  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_657, Initialize this object's properties from an array.\\n\\n @param array $array Used to seed this object's properties.\\n @return void\\n, Initialize this object's properties from an array.,"  protected function mapTypes($array)  {    // Hard initialise simple types, lazy load more complex ones.    foreach ($array as $key => $val) {      if ($keyType = $this->keyType($key)) {        $dataType = $this->dataType($key);        if ($dataType == 'array' || $dataType == 'map') {          $this->$key = array();          foreach ($val as $itemKey => $itemVal) {            if ($itemVal instanceof $keyType) {              $this->{$key}[$itemKey] = $itemVal;            } else {              $this->{$key}[$itemKey] = new $keyType($itemVal);            }          }        } elseif ($val instanceof $keyType) {          $this->$key = $val;        } else {          $this->$key = new $keyType($val);        }        unset($array[$key]);      } elseif (property_exists($this, $key)) {          $this->$key = $val;          unset($array[$key]);      } elseif (property_exists($this, $camelKey = $this->camelCase($key))) {          // This checks if property exists as camelCase, leaving it in array as snake_case          // in case of backwards compatibility issues.          $this->$camelKey = $val;      }    }    $this->modelData = $array;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_660," Handle different types of values, primarily\\\\n other objects and map and array data types.\\\\n"," Handle different types of values, primarily",  private function getSimpleValue($value)  {    if ($value instanceof Model) {      return $value->toSimpleObject();    } else if (is_array($value)) {      $return = array();      foreach ($value as $key => $a_value) {        $a_value = $this->getSimpleValue($a_value);        if ($a_value !== null) {          $key = $this->getMappedName($key);          $return[$key] = $this->nullPlaceholderCheck($a_value);        }      }      return $return;    }    return $value;  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_661, Check whether the value is the null placeholder and return true null.\\\\n, Check whether the value is the null placeholder and return true null.,  private function nullPlaceholderCheck($value)  {    if ($value === self::NULL_VALUE) {      return null;    }    return $value;  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_662," If there is an internal name mapping, use that.\\n"," If there is an internal name mapping, use that.","  private function getMappedName($key)  {    if (isset($this->internal_gapi_mappings, $this->internal_gapi_mappings[$key])) {      $key = $this->internal_gapi_mappings[$key];    }    return $key;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_663, Returns true only if the array is associative.\\n @param array $array\\n @return bool True if the array is associative.\\n, Returns true only if the array is associative.,  protected function isAssociativeArray($array)  {    if (!is_array($array)) {      return false;    }    $keys = array_keys($array);    foreach ($keys as $key) {      if (is_string($key)) {        return true;      }    }    return false;  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Revoke_669, Wrapper around Google Access Tokens which provides convenience functions\\\\\\\\n\\\\\\\\n, Wrapper around Google Access Tokens which provides convenience functions,"class Revoke{  /**   * @var ClientInterface The http client   */  private $http;  /**   * Instantiates the class, but does not initiate the login flow, leaving it   * to the discretion of the caller.   */  public function __construct(ClientInterface $http = null)  {    $this->http = $http;  }  /**   * Revoke an OAuth2 access token or refresh token. This method will revoke the current access   * token, if a token isn't provided.   *   * @param string|array $token The token (access token or a refresh token) that should be revoked.   * @return boolean Returns True if the revocation was successful, otherwise False.   */  public function revokeToken($token)  {    if (is_array($token)) {      if (isset($token['refresh_token'])) {        $token = $token['refresh_token'];      } else {        $token = $token['access_token'];      }    }    $body = Psr7\stream_for(http_build_query(array('token' => $token)));    $request = new Request(        'POST',        Client::OAUTH2_REVOKE_URI,        [          'Cache-Control' => 'no-store',          'Content-Type'  => 'application/x-www-form-urlencoded',        ],        $body    );    $httpHandler = HttpHandlerFactory::build($this->http);    $response = $httpHandler($request);    return $response->getStatusCode() == 200;  }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Revoke_670," Revoke an OAuth2 access token or refresh token. This method will revoke the current access\\\\\\\\n token, if a token isn't provided.\\\\\\\\n\\\\\\\\n @param string|array $token The token (access token or a refresh token) that should be revoked.\\\\\\\\n @return boolean Returns True if the revocation was successful, otherwise False.\\\\\\\\n", Revoke an OAuth2 access token or refresh token. This method will revoke the current access,"  public function revokeToken($token)  {    if (is_array($token)) {      if (isset($token['refresh_token'])) {        $token = $token['refresh_token'];      } else {        $token = $token['access_token'];      }    }    $body = Psr7\stream_for(http_build_query(array('token' => $token)));    $request = new Request(        'POST',        Client::OAUTH2_REVOKE_URI,        [          'Cache-Control' => 'no-store',          'Content-Type'  => 'application/x-www-form-urlencoded',        ],        $body    );    $httpHandler = HttpHandlerFactory::build($this->http);    $response = $httpHandler($request);    return $response->getStatusCode() == 200;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Service_667, Create a new HTTP Batch handler for this service\\\\\\\\n\\\\\\\\n @return Batch\\\\\\\\n, Create a new HTTP Batch handler for this service,"  public function createBatch()  {    return new Batch(        $this->client,        false,        $this->rootUrl,        $this->batchPath    );  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_VerifyTest_693, Most of the logic for ID token validation is in AuthTest -\\\\n this is just a general check to ensure we verify a valid\\\\n id token if one exists.\\\\n, Most of the logic for ID token validation is in AuthTest -,"  public function testValidateIdToken()  {    $this->checkToken();    $jwt = $this->getJwtService();    $client = $this->getClient();    $http = $client->getHttpClient();    $token = $client->getAccessToken();    if ($client->isAccessTokenExpired()) {      $token = $client->fetchAccessTokenWithRefreshToken();    }    $segments = explode('.', $token['id_token']);    $this->assertCount(3, $segments);    // Extract the client ID in this case as it wont be set on the test client.    $data = json_decode($jwt->urlSafeB64Decode($segments[1]));    $verify = new Google_AccessToken_Verify($http);    $payload = $verify->verifyIdToken($token['id_token'], $data->aud);    $this->assertArrayHasKey('sub', $payload);    $this->assertGreaterThan(0, strlen($payload['sub']));    // TODO: Need to be smart about testing/disabling the    // caching for this test to make sense. Not sure how to do that    // at the moment.    $client = $this->getClient();    $http = $client->getHttpClient();    $data = json_decode($jwt->urlSafeB64Decode($segments[1]));    $verify = new Google_AccessToken_Verify($http);    $payload = $verify->verifyIdToken($token['id_token'], $data->aud);    $this->assertArrayHasKey('sub', $payload);    $this->assertGreaterThan(0, strlen($payload['sub']));  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Verify_673, Retrieve and cache a certificates file.\\n\\n @param $url string location\\n @throws \\\\Google\\\\Exception\\n @return array certificates\\n, Retrieve and cache a certificates file.,"  private function retrieveCertsFromLocation($url)  {    // If we're retrieving a local file, just grab it.    if (0 !== strpos($url, 'http')) {      if (!$file = file_get_contents($url)) {        throw new GoogleException(            ""Failed to retrieve verification certificates: '"" .            $url . ""'.""        );      }      return json_decode($file, true);    }    $response = $this->http->get($url);    if ($response->getStatusCode() == 200) {      return json_decode((string) $response->getBody(), true);    }    throw new GoogleException(        sprintf(            'Failed to retrieve verification certificates: ""%s"".',            $response->getBody()->getContents()        ),        $response->getStatusCode()    );  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Verify_674," Gets federated sign-on certificates to use for verifying identity tokens.\\\\n Returns certs as array structure, where keys are key ids, and values\\\\n are PEM encoded certificates.\\\\n", Gets federated sign-on certificates to use for verifying identity tokens.,"  private function getFederatedSignOnCerts()  {    $certs = null;    if ($cache = $this->getCache()) {      $cacheItem = $cache->getItem('federated_signon_certs_v3');      $certs = $cacheItem->get();    }    if (!$certs) {      $certs = $this->retrieveCertsFromLocation(          self::FEDERATED_SIGNON_CERT_URL      );      if ($cache) {        $cacheItem->expiresAt(new DateTime('+1 hour'));        $cacheItem->set($certs);        $cache->save($cacheItem);      }    }    if (!isset($certs['keys'])) {      throw new InvalidArgumentException(          'federated sign-on certs expects ""keys"" to be set'      );    }    return $certs['keys'];  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Verify_675," phpseclib calls ""phpinfo"" by default, which requires special\\n whitelisting in the AppEngine VM environment. This function\\n sets constants to bypass the need for phpseclib to check phpinfo\\n\\n @see phpseclib/Math/BigInteger\\n @see https://github.com/GoogleCloudPlatform/getting-started-php/issues/85\\n"," phpseclib calls ""phpinfo"" by default, which requires special","  private function setPhpsecConstants()  {    if (filter_var(getenv('GAE_VM'), FILTER_VALIDATE_BOOLEAN)) {      if (!defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {        define('MATH_BIGINTEGER_OPENSSL_ENABLED', true);      }      if (!defined('CRYPT_RSA_MODE')) {        define('CRYPT_RSA_MODE', constant($this->getOpenSslConstant()));      }    }  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_BodySummarizer_1899, Returns a summarized message body.\\n, Returns a summarized message body.,"    public function summarize(MessageInterface $message): ?string    {        return $this->truncateAt === null            ? \GuzzleHttp\Psr7\Message::bodySummary($message)            : \GuzzleHttp\Psr7\Message::bodySummary($message, $this->truncateAt);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Client_10, Return an InvalidArgumentException with pre-set message.\n, Return an InvalidArgumentException with pre-set message.,"    private function invalidBody(): InvalidArgumentException    {        return new InvalidArgumentException('Passing in the ""body"" request '            . 'option as an array to send a request is not supported. '            . 'Please use the ""form_params"" request option to send a '            . 'application/x-www-form-urlencoded request, or the ""multipart"" '            . 'request option to send a multipart/form-data request.');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Client_1066, The HttpClient PSR (PSR-18) specify this method.\\n\\n @inheritDoc\\n, The HttpClient PSR (PSR-18) specify this method.,"    public function sendRequest(RequestInterface $request): ResponseInterface    {        $options[RequestOptions::SYNCHRONOUS] = true;        $options[RequestOptions::ALLOW_REDIRECTS] = false;        $options[RequestOptions::HTTP_ERRORS] = false;        return $this->sendAsync($request, $options)->wait();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Client_1395, Merges default options into the array.\n\n @param array $options Options to modify by reference\n, Merges default options into the array.,"    private function prepareDefaults(array $options): array    {        $defaults = $this->config;        if (!empty($defaults['headers'])) {            // Default headers are only added if they are not present.            $defaults['_conditional'] = $defaults['headers'];            unset($defaults['headers']);        }        // Special handling for headers is required as they are added as        // conditional headers and as headers passed to a request ctor.        if (\array_key_exists('headers', $options)) {            // Allows default headers to be unset.            if ($options['headers'] === null) {                $defaults['_conditional'] = [];                unset($options['headers']);            } elseif (!\is_array($options['headers'])) {                throw new InvalidArgumentException('headers must be an array');            }        }        // Shallow merge defaults underneath options.        $result = $options + $defaults;        // Remove null values.        foreach ($result as $k => $v) {            if ($v === null) {                unset($result[$k]);            }        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Client_1396, Transfers the given request and applies request options.\n\n The URI of the request is not modified and the request options are used\n as-is without merging in default options.\n\n @param array $options See \\GuzzleHttp\\RequestOptions.\n, Transfers the given request and applies request options.,"    private function transfer(RequestInterface $request, array $options): PromiseInterface    {        $request = $this->applyOptions($request, $options);        /** @var HandlerStack $handler */        $handler = $options['handler'];        try {            return P\Create::promiseFor($handler($request, $options));        } catch (\Exception $e) {            return P\Create::rejectionFor($e);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Client_1397, Applies the array of request options to a request.\n, Applies the array of request options to a request.,"    private function applyOptions(RequestInterface $request, array &$options): RequestInterface    {        $modify = [            'set_headers' => [],        ];        if (isset($options['headers'])) {            $modify['set_headers'] = $options['headers'];            unset($options['headers']);        }        if (isset($options['form_params'])) {            if (isset($options['multipart'])) {                throw new InvalidArgumentException('You cannot use '                    . 'form_params and multipart at the same time. Use the '                    . 'form_params option if you want to send application/'                    . 'x-www-form-urlencoded requests, and the multipart '                    . 'option to send multipart/form-data requests.');            }            $options['body'] = \http_build_query($options['form_params'], '', '&');            unset($options['form_params']);            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'application/x-www-form-urlencoded';        }        if (isset($options['multipart'])) {            $options['body'] = new Psr7\MultipartStream($options['multipart']);            unset($options['multipart']);        }        if (isset($options['json'])) {            $options['body'] = Utils::jsonEncode($options['json']);            unset($options['json']);            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'application/json';        }        if (!empty($options['decode_content'])            && $options['decode_content'] !== true        ) {            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Accept-Encoding'], $options['_conditional']);            $modify['set_headers']['Accept-Encoding'] = $options['decode_content'];        }        if (isset($options['body'])) {            if (\is_array($options['body'])) {                throw $this->invalidBody();            }            $modify['body'] = Psr7\Utils::streamFor($options['body']);            unset($options['body']);        }        if (!empty($options['auth']) && \is_array($options['auth'])) {            $value = $options['auth'];            $type = isset($value[2]) ? \strtolower($value[2]) : 'basic';            switch ($type) {                case 'basic':                    // Ensure that we don't have the header in different case and set the new value.                    $modify['set_headers'] = Psr7\Utils::caselessRemove(['Authorization'], $modify['set_headers']);                    $modify['set_headers']['Authorization'] = 'Basic '                        . \base64_encode(""$value[0]:$value[1]"");                    break;                case 'digest':                    // @todo: Do not rely on curl                    $options['curl'][\CURLOPT_HTTPAUTH] = \CURLAUTH_DIGEST;                    $options['curl'][\CURLOPT_USERPWD] = ""$value[0]:$value[1]"";                    break;                case 'ntlm':                    $options['curl'][\CURLOPT_HTTPAUTH] = \CURLAUTH_NTLM;                    $options['curl'][\CURLOPT_USERPWD] = ""$value[0]:$value[1]"";                    break;            }        }        if (isset($options['query'])) {            $value = $options['query'];            if (\is_array($value)) {                $value = \http_build_query($value, '', '&', \PHP_QUERY_RFC3986);            }            if (!\is_string($value)) {                throw new InvalidArgumentException('query must be a string or array');            }            $modify['query'] = $value;            unset($options['query']);        }        // Ensure that sink is not an invalid value.        if (isset($options['sink'])) {            // TODO: Add more sink validation?            if (\is_bool($options['sink'])) {                throw new InvalidArgumentException('sink must not be a boolean');            }        }        $request = Psr7\Utils::modifyRequest($request, $modify);        if ($request->getBody() instanceof Psr7\MultipartStream) {            // Use a multipart/form-data POST if a Content-Type is not set.            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'multipart/form-data; boundary='                . $request->getBody()->getBoundary();        }        // Merge in conditional headers if they are not present.        if (isset($options['_conditional'])) {            // Build up the changes so it's in a single clone of the message.            $modify = [];            foreach ($options['_conditional'] as $k => $v) {                if (!$request->hasHeader($k)) {                    $modify['set_headers'][$k] = $v;                }            }            $request = Psr7\Utils::modifyRequest($request, $modify);            // Don't pass this internal value along to middleware/handlers.            unset($options['_conditional']);        }        return $request;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Client_6, Configures the default options for a client.\\n, Configures the default options for a client.,"    private function configureDefaults(array $config): void    {        $defaults = [            'allow_redirects' => RedirectMiddleware::$defaultSettings,            'http_errors'     => true,            'decode_content'  => true,            'verify'          => true,            'cookies'         => false,            'idn_conversion'  => false,        ];        // Use the standard Linux HTTP_PROXY and HTTPS_PROXY if set.        // We can only trust the HTTP_PROXY environment variable in a CLI        // process due to the fact that PHP has no reliable mechanism to        // get environment variables that start with ""HTTP_"".        if (\PHP_SAPI === 'cli' && ($proxy = Utils::getenv('HTTP_PROXY'))) {            $defaults['proxy']['http'] = $proxy;        }        if ($proxy = Utils::getenv('HTTPS_PROXY')) {            $defaults['proxy']['https'] = $proxy;        }        if ($noProxy = Utils::getenv('NO_PROXY')) {            $cleanedNoProxy = \str_replace(' ', '', $noProxy);            $defaults['proxy']['no'] = \explode(',', $cleanedNoProxy);        }        $this->config = $config + $defaults;        if (!empty($config['cookies']) && $config['cookies'] === true) {            $this->config['cookies'] = new CookieJar();        }        // Add the default user-agent header.        if (!isset($this->config['headers'])) {            $this->config['headers'] = ['User-Agent' => Utils::defaultUserAgent()];        } else {            // Add the User-Agent header if one was not already set.            foreach (\array_keys($this->config['headers']) as $name) {                if (\strtolower($name) === 'user-agent') {                    return;                }            }            $this->config['headers']['User-Agent'] = Utils::defaultUserAgent();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_HandlerStack_1074, Dumps a string representation of the stack.\n\n @return string\n, Dumps a string representation of the stack.,"    public function __toString()    {        $depth = 0;        $stack = [];        if ($this->handler !== null) {            $stack[] = ""0) Handler: "" . $this->debugCallable($this->handler);        }        $result = '';        foreach (\array_reverse($this->stack) as $tuple) {            $depth++;            $str = ""{$depth}) Name: '{$tuple[1]}', "";            $str .= ""Function: "" . $this->debugCallable($tuple[0]);            $result = ""> {$str}\n{$result}"";            $stack[] = $str;        }        foreach (\array_keys($stack) as $k) {            $result .= ""< {$stack[$k]}\n"";        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_HandlerStack_1075," Set the HTTP handler that actually returns a promise.\\n\\n @param callable(RequestInterface, array): PromiseInterface $handler Accepts a request and array of options and\\n                                                                     returns a Promise.\\n", Set the HTTP handler that actually returns a promise.,    public function setHandler(callable $handler): void    {        $this->handler = $handler;        $this->cached = null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_HandlerStack_1080, Provides a debug string for a given callable.\\n\\n @param callable $fn Function to write as a string.\\n, Provides a debug string for a given callable.,"    private function debugCallable($fn): string    {        if (\is_string($fn)) {            return ""callable({$fn})"";        }        if (\is_array($fn)) {            return \is_string($fn[0])                ? ""callable({$fn[0]}::{$fn[1]})""                : ""callable(['"" . \get_class($fn[0]) . ""', '{$fn[1]}'])"";        }        /** @var object $fn */        return 'callable(' . \spl_object_hash($fn) . ')';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_HandlerStack_1404, Remove a middleware by instance or name from the stack.\\n\\n @param callable|string $remove Middleware to remove by instance or name.\\n, Remove a middleware by instance or name from the stack.,"    public function remove($remove): void    {        $this->cached = null;        $idx = \is_callable($remove) ? 0 : 1;        $this->stack = \array_values(\array_filter(            $this->stack,            static function ($tuple) use ($idx, $remove) {                return $tuple[$idx] !== $remove;            }        ));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_HandlerStack_15, Returns true if the builder has a handler.\n, Returns true if the builder has a handler.,    public function hasHandler(): bool    {        return $this->handler !== null ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_HandlerStack_17," Compose the middleware and handler into a single callable function.\n\n @return callable(RequestInterface, array): PromiseInterface\n", Compose the middleware and handler into a single callable function.,"    public function resolve(): callable    {        if ($this->cached === null) {            if (($prev = $this->handler) === null) {                throw new \LogicException('No handler has been specified');            }            foreach (\array_reverse($this->stack) as $fn) {                /** @var callable(RequestInterface, array): PromiseInterface $prev */                $prev = $fn[0]($prev);            }            $this->cached = $prev;        }        return $this->cached;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_HandlerStack_1909, Creates a composed Guzzle handler function by stacking middlewares on top of\\n an HTTP handler function.\\n\\n @final\\n, Creates a composed Guzzle handler function by stacking middlewares on top of,"class HandlerStack{    /**     * @var null|callable(RequestInterface, array): PromiseInterface     */    private $handler;    /**     * @var array{(callable(callable(RequestInterface, array): PromiseInterface): callable), (string|null)}[]     */    private $stack = [];    /**     * @var null|callable(RequestInterface, array): PromiseInterface     */    private $cached;    /**     * Creates a default handler stack that can be used by clients.     *     * The returned handler will wrap the provided handler or use the most     * appropriate default handler for your system. The returned HandlerStack has     * support for cookies, redirects, HTTP error exceptions, and preparing a body     * before sending.     *     * The returned handler stack can be passed to a client in the ""handler""     * option.     *     * @param null|callable(RequestInterface, array): PromiseInterface $handler HTTP handler function to use with the stack. If no     *                                                                          handler is provided, the best handler for your     *                                                                          system will be utilized.     */    public static function create(?callable $handler = null): self    {        $stack = new self($handler ?: Utils::chooseHandler());        $stack->push(Middleware::httpErrors(), 'http_errors');        $stack->push(Middleware::redirect(), 'allow_redirects');        $stack->push(Middleware::cookies(), 'cookies');        $stack->push(Middleware::prepareBody(), 'prepare_body');        return $stack;    }    /**     * @param null|callable(RequestInterface, array): PromiseInterface $handler Underlying HTTP handler.     */    public function __construct(callable $handler = null)    {        $this->handler = $handler;    }    /**     * Invokes the handler stack as a composed handler     *     * @return ResponseInterface|PromiseInterface     */    public function __invoke(RequestInterface $request, array $options)    {        $handler = $this->resolve();        return $handler($request, $options);    }    /**     * Dumps a string representation of the stack.     *     * @return string     */    public function __toString()    {        $depth = 0;        $stack = [];        if ($this->handler !== null) {            $stack[] = ""0) Handler: "" . $this->debugCallable($this->handler);        }        $result = '';        foreach (\array_reverse($this->stack) as $tuple) {            $depth++;            $str = ""{$depth}) Name: '{$tuple[1]}', "";            $str .= ""Function: "" . $this->debugCallable($tuple[0]);            $result = ""> {$str}\n{$result}"";            $stack[] = $str;        }        foreach (\array_keys($stack) as $k) {            $result .= ""< {$stack[$k]}\n"";        }        return $result;    }    /**     * Set the HTTP handler that actually returns a promise.     *     * @param callable(RequestInterface, array): PromiseInterface $handler Accepts a request and array of options and     *                                                                     returns a Promise.     */    public function setHandler(callable $handler): void    {        $this->handler = $handler;        $this->cached = null;    }    /**     * Returns true if the builder has a handler.     */    public function hasHandler(): bool    {        return $this->handler !== null ;    }    /**     * Unshift a middleware to the bottom of the stack.     *     * @param callable(callable): callable $middleware Middleware function     * @param string                       $name       Name to register for this middleware.     */    public function unshift(callable $middleware, ?string $name = null): void    {        \array_unshift($this->stack, [$middleware, $name]);        $this->cached = null;    }    /**     * Push a middleware to the top of the stack.     *     * @param callable(callable): callable $middleware Middleware function     * @param string                       $name       Name to register for this middleware.     */    public function push(callable $middleware, string $name = ''): void    {        $this->stack[] = [$middleware, $name];        $this->cached = null;    }    /**     * Add a middleware before another middleware by name.     *     * @param string                       $findName   Middleware to find     * @param callable(callable): callable $middleware Middleware function     * @param string                       $withName   Name to register for this middleware.     */    public function before(string $findName, callable $middleware, string $withName = ''): void    {        $this->splice($findName, $withName, $middleware, true);    }    /**     * Add a middleware after another middleware by name.     *     * @param string                       $findName   Middleware to find     * @param callable(callable): callable $middleware Middleware function     * @param string                       $withName   Name to register for this middleware.     */    public function after(string $findName, callable $middleware, string $withName = ''): void    {        $this->splice($findName, $withName, $middleware, false);    }    /**     * Remove a middleware by instance or name from the stack.     *     * @param callable|string $remove Middleware to remove by instance or name.     */    public function remove($remove): void    {        $this->cached = null;        $idx = \is_callable($remove) ? 0 : 1;        $this->stack = \array_values(\array_filter(            $this->stack,            static function ($tuple) use ($idx, $remove) {                return $tuple[$idx] !== $remove;            }        ));    }    /**     * Compose the middleware and handler into a single callable function.     *     * @return callable(RequestInterface, array): PromiseInterface     */    public function resolve(): callable    {        if ($this->cached === null) {            if (($prev = $this->handler) === null) {                throw new \LogicException('No handler has been specified');            }            foreach (\array_reverse($this->stack) as $fn) {                /** @var callable(RequestInterface, array): PromiseInterface $prev */                $prev = $fn[0]($prev);            }            $this->cached = $prev;        }        return $this->cached;    }    private function findByName(string $name): int    {        foreach ($this->stack as $k => $v) {            if ($v[1] === $name) {                return $k;            }        }        throw new \InvalidArgumentException(""Middleware not found: $name"");    }    /**     * Splices a function into the middleware list at a specific position.     */    private function splice(string $findName, string $withName, callable $middleware, bool $before): void    {        $this->cached = null;        $idx = $this->findByName($findName);        $tuple = [$middleware, $withName];        if ($before) {            if ($idx === 0) {                \array_unshift($this->stack, $tuple);            } else {                $replacement = [$tuple, $this->stack[$idx]];                \array_splice($this->stack, $idx, 1, $replacement);            }        } elseif ($idx === \count($this->stack) - 1) {            $this->stack[] = $tuple;        } else {            $replacement = [$this->stack[$idx], $tuple];            \array_splice($this->stack, $idx, 1, $replacement);        }    }    /**     * Provides a debug string for a given callable.     *     * @param callable $fn Function to write as a string.     */    private function debugCallable($fn): string    {        if (\is_string($fn)) {            return ""callable({$fn})"";        }        if (\is_array($fn)) {            return \is_string($fn[0])                ? ""callable({$fn[0]}::{$fn[1]})""                : ""callable(['"" . \get_class($fn[0]) . ""', '{$fn[1]}'])"";        }        /** @var object $fn */        return 'callable(' . \spl_object_hash($fn) . ')';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_HandlerStack_1910, Invokes the handler stack as a composed handler\\n\\n @return ResponseInterface|PromiseInterface\\n, Invokes the handler stack as a composed handler,"    public function __invoke(RequestInterface $request, array $options)    {        $handler = $this->resolve();        return $handler($request, $options);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_MessageFormatter_20," Formats log messages using variable substitutions for requests, responses,\n and other transactional data.\n\n The following variable substitutions are supported:\n\n - {request}:        Full HTTP request message\n - {response}:       Full HTTP response message\n - {ts}:             ISO 8601 date in GMT\n - {date_iso_8601}   ISO 8601 date in GMT\n - {date_common_log} Apache common log date using the configured timezone.\n - {host}:           Host of the request\n - {method}:         Method of the request\n - {uri}:            URI of the request\n - {version}:        Protocol version\n - {target}:         Request target of the request (path + query + fragment)\n - {hostname}:       Hostname of the machine that sent the request\n - {code}:           Status code of the response (if available)\n - {phrase}:         Reason phrase of the response  (if available)\n - {error}:          Any error messages (if available)\n - {req_header_ - {res_header_ - {req_headers}:    Request headers\n - {res_headers}:    Response headers\n - {req_body}:       Request body\n - {res_body}:       Response body\n\n @final\n"," Formats log messages using variable substitutions for requests, responses,","class MessageFormatter implements MessageFormatterInterface{    /**     * Apache Common Log Format.     *     * @link https://httpd.apache.org/docs/2.4/logs.html#common     *     * @var string     */    public const CLF = ""{hostname} {req_header_User-Agent} - [{date_common_log}] \""{method} {target} HTTP/{version}\"" {code} {res_header_Content-Length}"";    public const DEBUG = "">>>>>>>>\n{request}\n<<<<<<<<\n{response}\n--------\n{error}"";    public const SHORT = '[{ts}] ""{method} {target} HTTP/{version}"" {code}';    /**     * @var string Template used to format log messages     */    private $template;    /**     * @param string $template Log message template     */    public function __construct(?string $template = self::CLF)    {        $this->template = $template ?: self::CLF;    }    /**     * Returns a formatted message string.     *     * @param RequestInterface       $request  Request that was sent     * @param ResponseInterface|null $response Response that was received     * @param \Throwable|null        $error    Exception that was received     */    public function format(RequestInterface $request, ?ResponseInterface $response = null, ?\Throwable $error = null): string    {        $cache = [];        /** @var string */        return \preg_replace_callback(            '/{\s*([A-Za-z_\-\.0-9]+)\s*}/',            function (array $matches) use ($request, $response, $error, &$cache) {                if (isset($cache[$matches[1]])) {                    return $cache[$matches[1]];                }                $result = '';                switch ($matches[1]) {                    case 'request':                        $result = Psr7\Message::toString($request);                        break;                    case 'response':                        $result = $response ? Psr7\Message::toString($response) : '';                        break;                    case 'req_headers':                        $result = \trim($request->getMethod()                                . ' ' . $request->getRequestTarget())                            . ' HTTP/' . $request->getProtocolVersion() . ""\r\n""                            . $this->headers($request);                        break;                    case 'res_headers':                        $result = $response ?                            \sprintf(                                'HTTP/%s %d %s',                                $response->getProtocolVersion(),                                $response->getStatusCode(),                                $response->getReasonPhrase()                            ) . ""\r\n"" . $this->headers($response)                            : 'NULL';                        break;                    case 'req_body':                        $result = $request->getBody()->__toString();                        break;                    case 'res_body':                        if (!$response instanceof ResponseInterface) {                            $result = 'NULL';                            break;                        }                        $body = $response->getBody();                        if (!$body->isSeekable()) {                            $result = 'RESPONSE_NOT_LOGGEABLE';                            break;                        }                        $result = $response->getBody()->__toString();                        break;                    case 'ts':                    case 'date_iso_8601':                        $result = \gmdate('c');                        break;                    case 'date_common_log':                        $result = \date('d/M/Y:H:i:s O');                        break;                    case 'method':                        $result = $request->getMethod();                        break;                    case 'version':                        $result = $request->getProtocolVersion();                        break;                    case 'uri':                    case 'url':                        $result = $request->getUri();                        break;                    case 'target':                        $result = $request->getRequestTarget();                        break;                    case 'req_version':                        $result = $request->getProtocolVersion();                        break;                    case 'res_version':                        $result = $response                            ? $response->getProtocolVersion()                            : 'NULL';                        break;                    case 'host':                        $result = $request->getHeaderLine('Host');                        break;                    case 'hostname':                        $result = \gethostname();                        break;                    case 'code':                        $result = $response ? $response->getStatusCode() : 'NULL';                        break;                    case 'phrase':                        $result = $response ? $response->getReasonPhrase() : 'NULL';                        break;                    case 'error':                        $result = $error ? $error->getMessage() : 'NULL';                        break;                    default:                        // handle prefixed dynamic headers                        if (\strpos($matches[1], 'req_header_') === 0) {                            $result = $request->getHeaderLine(\substr($matches[1], 11));                        } elseif (\strpos($matches[1], 'res_header_') === 0) {                            $result = $response                                ? $response->getHeaderLine(\substr($matches[1], 11))                                : 'NULL';                        }                }                $cache[$matches[1]] = $result;                return $result;            },            $this->template        );    }    /**     * Get headers from message as string     */    private function headers(MessageInterface $message): string    {        $result = '';        foreach ($message->getHeaders() as $name => $values) {            $result .= $name . ': ' . \implode(', ', $values) . ""\r\n"";        }        return \trim($result);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Middleware_1083, Functions used to create and wrap handlers with handler middleware.\n, Functions used to create and wrap handlers with handler middleware.,"final class Middleware{    /**     * Middleware that adds cookies to requests.     *     * The options array must be set to a CookieJarInterface in order to use     * cookies. This is typically handled for you by a client.     *     * @return callable Returns a function that accepts the next handler.     */    public static function cookies(): callable    {        return static function (callable $handler): callable {            return static function ($request, array $options) use ($handler) {                if (empty($options['cookies'])) {                    return $handler($request, $options);                } elseif (!($options['cookies'] instanceof CookieJarInterface)) {                    throw new \InvalidArgumentException('cookies must be an instance of GuzzleHttp\Cookie\CookieJarInterface');                }                $cookieJar = $options['cookies'];                $request = $cookieJar->withCookieHeader($request);                return $handler($request, $options)                    ->then(                        static function (ResponseInterface $response) use ($cookieJar, $request): ResponseInterface {                            $cookieJar->extractCookies($request, $response);                            return $response;                        }                    );            };        };    }    /**     * Middleware that throws exceptions for 4xx or 5xx responses when the     * ""http_errors"" request option is set to true.     *     * @param BodySummarizerInterface|null $bodySummarizer The body summarizer to use in exception messages.     *     * @return callable(callable): callable Returns a function that accepts the next handler.     */    public static function httpErrors(BodySummarizerInterface $bodySummarizer = null): callable    {        return static function (callable $handler) use ($bodySummarizer): callable {            return static function ($request, array $options) use ($handler, $bodySummarizer) {                if (empty($options['http_errors'])) {                    return $handler($request, $options);                }                return $handler($request, $options)->then(                    static function (ResponseInterface $response) use ($request, $bodySummarizer) {                        $code = $response->getStatusCode();                        if ($code < 400) {                            return $response;                        }                        throw RequestException::create($request, $response, null, [], $bodySummarizer);                    }                );            };        };    }    /**     * Middleware that pushes history data to an ArrayAccess container.     *     * @param array|\ArrayAccess<int, array> $container Container to hold the history (by reference).     *     * @return callable(callable): callable Returns a function that accepts the next handler.     *     * @throws \InvalidArgumentException if container is not an array or ArrayAccess.     */    public static function history(&$container): callable    {        if (!\is_array($container) && !$container instanceof \ArrayAccess) {            throw new \InvalidArgumentException('history container must be an array or object implementing ArrayAccess');        }        return static function (callable $handler) use (&$container): callable {            return static function (RequestInterface $request, array $options) use ($handler, &$container) {                return $handler($request, $options)->then(                    static function ($value) use ($request, &$container, $options) {                        $container[] = [                            'request'  => $request,                            'response' => $value,                            'error'    => null,                            'options'  => $options                        ];                        return $value;                    },                    static function ($reason) use ($request, &$container, $options) {                        $container[] = [                            'request'  => $request,                            'response' => null,                            'error'    => $reason,                            'options'  => $options                        ];                        return P\Create::rejectionFor($reason);                    }                );            };        };    }    /**     * Middleware that invokes a callback before and after sending a request.     *     * The provided listener cannot modify or alter the response. It simply     * ""taps"" into the chain to be notified before returning the promise. The     * before listener accepts a request and options array, and the after     * listener accepts a request, options array, and response promise.     *     * @param callable $before Function to invoke before forwarding the request.     * @param callable $after  Function invoked after forwarding.     *     * @return callable Returns a function that accepts the next handler.     */    public static function tap(callable $before = null, callable $after = null): callable    {        return static function (callable $handler) use ($before, $after): callable {            return static function (RequestInterface $request, array $options) use ($handler, $before, $after) {                if ($before) {                    $before($request, $options);                }                $response = $handler($request, $options);                if ($after) {                    $after($request, $options, $response);                }                return $response;            };        };    }    /**     * Middleware that handles request redirects.     *     * @return callable Returns a function that accepts the next handler.     */    public static function redirect(): callable    {        return static function (callable $handler): RedirectMiddleware {            return new RedirectMiddleware($handler);        };    }    /**     * Middleware that retries requests based on the boolean result of     * invoking the provided ""decider"" function.     *     * If no delay function is provided, a simple implementation of exponential     * backoff will be utilized.     *     * @param callable $decider Function that accepts the number of retries,     *                          a request, [response], and [exception] and     *                          returns true if the request is to be retried.     * @param callable $delay   Function that accepts the number of retries and     *                          returns the number of milliseconds to delay.     *     * @return callable Returns a function that accepts the next handler.     */    public static function retry(callable $decider, callable $delay = null): callable    {        return static function (callable $handler) use ($decider, $delay): RetryMiddleware {            return new RetryMiddleware($decider, $handler, $delay);        };    }    /**     * Middleware that logs requests, responses, and errors using a message     * formatter.     *     * @phpstan-param \Psr\Log\LogLevel::* $logLevel  Level at which to log requests.     *     * @param LoggerInterface                            $logger    Logs messages.     * @param MessageFormatterInterface|MessageFormatter $formatter Formatter used to create message strings.     * @param string                                     $logLevel  Level at which to log requests.     *     * @return callable Returns a function that accepts the next handler.     */    public static function log(LoggerInterface $logger, $formatter, string $logLevel = 'info'): callable    {        // To be compatible with Guzzle 7.1.x we need to allow users to pass a MessageFormatter        if (!$formatter instanceof MessageFormatter && !$formatter instanceof MessageFormatterInterface) {            throw new \LogicException(sprintf('Argument 2 to %s::log() must be of type %s', self::class, MessageFormatterInterface::class));        }        return static function (callable $handler) use ($logger, $formatter, $logLevel): callable {            return static function (RequestInterface $request, array $options = []) use ($handler, $logger, $formatter, $logLevel) {                return $handler($request, $options)->then(                    static function ($response) use ($logger, $request, $formatter, $logLevel): ResponseInterface {                        $message = $formatter->format($request, $response);                        $logger->log($logLevel, $message);                        return $response;                    },                    static function ($reason) use ($logger, $request, $formatter): PromiseInterface {                        $response = $reason instanceof RequestException ? $reason->getResponse() : null;                        $message = $formatter->format($request, $response, P\Create::exceptionFor($reason));                        $logger->error($message);                        return P\Create::rejectionFor($reason);                    }                );            };        };    }    /**     * This middleware adds a default content-type if possible, a default     * content-length or transfer-encoding header, and the expect header.     */    public static function prepareBody(): callable    {        return static function (callable $handler): PrepareBodyMiddleware {            return new PrepareBodyMiddleware($handler);        };    }    /**     * Middleware that applies a map function to the request before passing to     * the next handler.     *     * @param callable $fn Function that accepts a RequestInterface and returns     *                     a RequestInterface.     */    public static function mapRequest(callable $fn): callable    {        return static function (callable $handler) use ($fn): callable {            return static function (RequestInterface $request, array $options) use ($handler, $fn) {                return $handler($fn($request), $options);            };        };    }    /**     * Middleware that applies a map function to the resolved promise's     * response.     *     * @param callable $fn Function that accepts a ResponseInterface and     *                     returns a ResponseInterface.     */    public static function mapResponse(callable $fn): callable    {        return static function (callable $handler) use ($fn): callable {            return static function (RequestInterface $request, array $options) use ($handler, $fn) {                return $handler($request, $options)->then($fn);            };        };    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Middleware_1085," Middleware that pushes history data to an ArrayAccess container.\\n\\n @param array|\\\\ArrayAccess<int, array> $container Container to hold the history (by reference).\\n\\n @return callable(callable): callable Returns a function that accepts the next handler.\\n\\n @throws \\\\InvalidArgumentException if container is not an array or ArrayAccess.\\n", Middleware that pushes history data to an ArrayAccess container.,"    public static function history(&$container): callable    {        if (!\is_array($container) && !$container instanceof \ArrayAccess) {            throw new \InvalidArgumentException('history container must be an array or object implementing ArrayAccess');        }        return static function (callable $handler) use (&$container): callable {            return static function (RequestInterface $request, array $options) use ($handler, &$container) {                return $handler($request, $options)->then(                    static function ($value) use ($request, &$container, $options) {                        $container[] = [                            'request'  => $request,                            'response' => $value,                            'error'    => null,                            'options'  => $options                        ];                        return $value;                    },                    static function ($reason) use ($request, &$container, $options) {                        $container[] = [                            'request'  => $request,                            'response' => null,                            'error'    => $reason,                            'options'  => $options                        ];                        return P\Create::rejectionFor($reason);                    }                );            };        };    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Middleware_1088, Middleware that applies a map function to the request before passing to\n the next handler.\n\n @param callable $fn Function that accepts a RequestInterface and returns\n                     a RequestInterface.\n, Middleware that applies a map function to the request before passing to,"    public static function mapRequest(callable $fn): callable    {        return static function (callable $handler) use ($fn): callable {            return static function (RequestInterface $request, array $options) use ($handler, $fn) {                return $handler($fn($request), $options);            };        };    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Middleware_1089, Middleware that applies a map function to the resolved promise's\n response.\n\n @param callable $fn Function that accepts a ResponseInterface and\n                     returns a ResponseInterface.\n, Middleware that applies a map function to the resolved promise's,"    public static function mapResponse(callable $fn): callable    {        return static function (callable $handler) use ($fn): callable {            return static function (RequestInterface $request, array $options) use ($handler, $fn) {                return $handler($request, $options)->then($fn);            };        };    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Middleware_1411, Middleware that adds cookies to requests.\n\n The options array must be set to a CookieJarInterface in order to use\n cookies. This is typically handled for you by a client.\n\n @return callable Returns a function that accepts the next handler.\n, Middleware that adds cookies to requests.,"    public static function cookies(): callable    {        return static function (callable $handler): callable {            return static function ($request, array $options) use ($handler) {                if (empty($options['cookies'])) {                    return $handler($request, $options);                } elseif (!($options['cookies'] instanceof CookieJarInterface)) {                    throw new \InvalidArgumentException('cookies must be an instance of GuzzleHttp\Cookie\CookieJarInterface');                }                $cookieJar = $options['cookies'];                $request = $cookieJar->withCookieHeader($request);                return $handler($request, $options)                    ->then(                        static function (ResponseInterface $response) use ($cookieJar, $request): ResponseInterface {                            $cookieJar->extractCookies($request, $response);                            return $response;                        }                    );            };        };    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Middleware_1414," This middleware adds a default content-type if possible, a default\n content-length or transfer-encoding header, and the expect header.\n"," This middleware adds a default content-type if possible, a default",    public static function prepareBody(): callable    {        return static function (callable $handler): PrepareBodyMiddleware {            return new PrepareBodyMiddleware($handler);        };    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Middleware_25, Middleware that handles request redirects.\\n\\n @return callable Returns a function that accepts the next handler.\\n, Middleware that handles request redirects.,    public static function redirect(): callable    {        return static function (callable $handler): RedirectMiddleware {            return new RedirectMiddleware($handler);        };    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Pool_1090," Sends an iterator of requests concurrently using a capped pool size.\\n\\n The pool will read from an iterator until it is cancelled or until the\\n iterator is consumed. When a request is yielded, the request is sent after\\n applying the ""request_options"" request options (if provided in the ctor).\\n\\n When a function is yielded by the iterator, the function is provided the\\n ""request_options"" array that should be merged on top of any existing\\n options, and the function MUST then return a wait-able promise.\\n\\n @final\\n", Sends an iterator of requests concurrently using a capped pool size.,"class Pool implements PromisorInterface{    /**     * @var EachPromise     */    private $each;    /**     * @param ClientInterface $client   Client used to send the requests.     * @param array|\Iterator $requests Requests or functions that return     *                                  requests to send concurrently.     * @param array           $config   Associative array of options     *                                  - concurrency: (int) Maximum number of requests to send concurrently     *                                  - options: Array of request options to apply to each request.     *                                  - fulfilled: (callable) Function to invoke when a request completes.     *                                  - rejected: (callable) Function to invoke when a request is rejected.     */    public function __construct(ClientInterface $client, $requests, array $config = [])    {        if (!isset($config['concurrency'])) {            $config['concurrency'] = 25;        }        if (isset($config['options'])) {            $opts = $config['options'];            unset($config['options']);        } else {            $opts = [];        }        $iterable = P\Create::iterFor($requests);        $requests = static function () use ($iterable, $client, $opts) {            foreach ($iterable as $key => $rfn) {                if ($rfn instanceof RequestInterface) {                    yield $key => $client->sendAsync($rfn, $opts);                } elseif (\is_callable($rfn)) {                    yield $key => $rfn($opts);                } else {                    throw new \InvalidArgumentException('Each value yielded by the iterator must be a Psr7\Http\Message\RequestInterface or a callable that returns a promise that fulfills with a Psr7\Message\Http\ResponseInterface object.');                }            }        };        $this->each = new EachPromise($requests(), $config);    }    /**     * Get promise     */    public function promise(): PromiseInterface    {        return $this->each->promise();    }    /**     * Sends multiple requests concurrently and returns an array of responses     * and exceptions that uses the same ordering as the provided requests.     *     * IMPORTANT: This method keeps every request and response in memory, and     * as such, is NOT recommended when sending a large number or an     * indeterminate number of requests concurrently.     *     * @param ClientInterface $client   Client used to send the requests     * @param array|\Iterator $requests Requests to send concurrently.     * @param array           $options  Passes through the options available in     *                                  {@see \GuzzleHttp\Pool::__construct}     *     * @return array Returns an array containing the response or an exception     *               in the same order that the requests were sent.     *     * @throws \InvalidArgumentException if the event format is incorrect.     */    public static function batch(ClientInterface $client, $requests, array $options = []): array    {        $res = [];        self::cmpCallback($options, 'fulfilled', $res);        self::cmpCallback($options, 'rejected', $res);        $pool = new static($client, $requests, $options);        $pool->promise()->wait();        \ksort($res);        return $res;    }    /**     * Execute callback(s)     */    private static function cmpCallback(array &$options, string $name, array &$results): void    {        if (!isset($options[$name])) {            $options[$name] = static function ($v, $k) use (&$results) {                $results[$k] = $v;            };        } else {            $currentFn = $options[$name];            $options[$name] = static function ($v, $k) use (&$results, $currentFn) {                $currentFn($v, $k);                $results[$k] = $v;            };        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Pool_1092, Execute callback(s)\\n, Execute callback(s),"    private static function cmpCallback(array &$options, string $name, array &$results): void    {        if (!isset($options[$name])) {            $options[$name] = static function ($v, $k) use (&$results) {                $results[$k] = $v;            };        } else {            $currentFn = $options[$name];            $options[$name] = static function ($v, $k) use (&$results, $currentFn) {                $currentFn($v, $k);                $results[$k] = $v;            };        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_AggregateException_695, Exception thrown when too many errors occur in the some() or any() methods.\n, Exception thrown when too many errors occur in the some() or any() methods.,"class AggregateException extends RejectionException{    public function __construct($msg, array $reasons)    {        parent::__construct(            $reasons,            sprintf('%s; %d rejected promises', $msg, count($reasons))        );    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Coroutine_697," Creates a promise that is resolved using a generator that yields values or\n promises (somewhat similar to C#\'s async keyword).\n\n When called, the Coroutine::of method will start an instance of the generator\n and returns a promise that is fulfilled with its final yielded value.\n\n Control is returned back to the generator when the yielded promise settles.\n This can lead to less verbose code when doing lots of sequential async calls\n with minimal processing in between.\n\n     use GuzzleHttp\\Promise;\n\n     function createPromise($value) {\n         return new Promise\\FulfilledPromise($value);\n     }\n\n     $promise = Promise\\Coroutine::of(function () {\n         $value = (yield createPromise(\'a\'));\n         try {\n             $value = (yield createPromise($value . \'b\'));\n         } catch (\\Exception $e) {\n             // The promise was rejected.\n         }\n         yield $value . \'c\';\n     });\n\n     // Outputs ""abc""\n     $promise->then(function ($v) { echo $v; });\n\n @param callable $generatorFn Generator function to wrap into a promise.\n\n @return Promise\n\n @link https://github.com/petkaantonov/bluebird/blob/master/API.md#generators inspiration\n", Creates a promise that is resolved using a generator that yields values or,"final class Coroutine implements PromiseInterface{    /**     * @var PromiseInterface|null     */    private $currentPromise;    /**     * @var Generator     */    private $generator;    /**     * @var Promise     */    private $result;    public function __construct(callable $generatorFn)    {        $this->generator = $generatorFn();        $this->result = new Promise(function () {            while (isset($this->currentPromise)) {                $this->currentPromise->wait();            }        });        try {            $this->nextCoroutine($this->generator->current());        } catch (\Exception $exception) {            $this->result->reject($exception);        } catch (Throwable $throwable) {            $this->result->reject($throwable);        }    }    /**     * Create a new coroutine.     *     * @return self     */    public static function of(callable $generatorFn)    {        return new self($generatorFn);    }    public function then(        callable $onFulfilled = null,        callable $onRejected = null    ) {        return $this->result->then($onFulfilled, $onRejected);    }    public function otherwise(callable $onRejected)    {        return $this->result->otherwise($onRejected);    }    public function wait($unwrap = true)    {        return $this->result->wait($unwrap);    }    public function getState()    {        return $this->result->getState();    }    public function resolve($value)    {        $this->result->resolve($value);    }    public function reject($reason)    {        $this->result->reject($reason);    }    public function cancel()    {        $this->currentPromise->cancel();        $this->result->cancel();    }    private function nextCoroutine($yielded)    {        $this->currentPromise = Create::promiseFor($yielded)            ->then([$this, '_handleSuccess'], [$this, '_handleFailure']);    }    /**     * @internal     */    public function _handleSuccess($value)    {        unset($this->currentPromise);        try {            $next = $this->generator->send($value);            if ($this->generator->valid()) {                $this->nextCoroutine($next);            } else {                $this->result->resolve($value);            }        } catch (Exception $exception) {            $this->result->reject($exception);        } catch (Throwable $throwable) {            $this->result->reject($throwable);        }    }    /**     * @internal     */    public function _handleFailure($reason)    {        unset($this->currentPromise);        try {            $nextYield = $this->generator->throw(Create::exceptionFor($reason));            // The throw was caught, so keep iterating on the coroutine            $this->nextCoroutine($nextYield);        } catch (Exception $exception) {            $this->result->reject($exception);        } catch (Throwable $throwable) {            $this->result->reject($throwable);        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Create_701, Creates a promise for a value if the value is not a promise.\\\\n\\\\n @param mixed $value Promise or value.\\\\n\\\\n @return PromiseInterface\\\\n, Creates a promise for a value if the value is not a promise.,"    public static function promiseFor($value)    {        if ($value instanceof PromiseInterface) {            return $value;        }        // Return a Guzzle promise that shadows the given promise.        if (is_object($value) && method_exists($value, 'then')) {            $wfn = method_exists($value, 'wait') ? [$value, 'wait'] : null;            $cfn = method_exists($value, 'cancel') ? [$value, 'cancel'] : null;            $promise = new Promise($wfn, $cfn);            $value->then([$promise, 'resolve'], [$promise, 'reject']);            return $promise;        }        return new FulfilledPromise($value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Create_702," Creates a rejected promise for a reason if the reason is not a promise.\\\\\\\\n If the provided reason is a promise, then it is returned as-is.\\\\\\\\n\\\\\\\\n @param mixed $reason Promise or reason.\\\\\\\\n\\\\\\\\n @return PromiseInterface\\\\\\\\n", Creates a rejected promise for a reason if the reason is not a promise.,    public static function rejectionFor($reason)    {        if ($reason instanceof PromiseInterface) {            return $reason;        }        return new RejectedPromise($reason);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Create_703, Create an exception for a rejected promise value.\n\n @param mixed $reason\n\n @return \\Exception|\\Throwable\n, Create an exception for a rejected promise value.,    public static function exceptionFor($reason)    {        if ($reason instanceof \Exception || $reason instanceof \Throwable) {            return $reason;        }        return new RejectionException($reason);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Create_704, Returns an iterator for the given value.\\\\n\\\\n @param mixed $value\\\\n\\\\n @return \\\\\\\\Iterator\\\\n, Returns an iterator for the given value.,    public static function iterFor($value)    {        if ($value instanceof \Iterator) {            return $value;        }        if (is_array($value)) {            return new \ArrayIterator($value);        }        return new \ArrayIterator([$value]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_EachPromise_708, Represents a promise that iterates over many promises and invokes\\\\n side-effect functions in the process.\\\\n, Represents a promise that iterates over many promises and invokes,"class EachPromise implements PromisorInterface{    private $pending = [];    private $nextPendingIndex = 0;    /** @var \Iterator|null */    private $iterable;    /** @var callable|int|null */    private $concurrency;    /** @var callable|null */    private $onFulfilled;    /** @var callable|null */    private $onRejected;    /** @var Promise|null */    private $aggregate;    /** @var bool|null */    private $mutex;    /**     * Configuration hash can include the following key value pairs:     *     * - fulfilled: (callable) Invoked when a promise fulfills. The function     *   is invoked with three arguments: the fulfillment value, the index     *   position from the iterable list of the promise, and the aggregate     *   promise that manages all of the promises. The aggregate promise may     *   be resolved from within the callback to short-circuit the promise.     * - rejected: (callable) Invoked when a promise is rejected. The     *   function is invoked with three arguments: the rejection reason, the     *   index position from the iterable list of the promise, and the     *   aggregate promise that manages all of the promises. The aggregate     *   promise may be resolved from within the callback to short-circuit     *   the promise.     * - concurrency: (integer) Pass this configuration option to limit the     *   allowed number of outstanding concurrently executing promises,     *   creating a capped pool of promises. There is no limit by default.     *     * @param mixed $iterable Promises or values to iterate.     * @param array $config   Configuration options     */    public function __construct($iterable, array $config = [])    {        $this->iterable = Create::iterFor($iterable);        if (isset($config['concurrency'])) {            $this->concurrency = $config['concurrency'];        }        if (isset($config['fulfilled'])) {            $this->onFulfilled = $config['fulfilled'];        }        if (isset($config['rejected'])) {            $this->onRejected = $config['rejected'];        }    }    /** @psalm-suppress InvalidNullableReturnType */    public function promise()    {        if ($this->aggregate) {            return $this->aggregate;        }        try {            $this->createPromise();            /** @psalm-assert Promise $this->aggregate */            $this->iterable->rewind();            if (!$this->checkIfFinished()) {                $this->refillPending();            }        } catch (\Throwable $e) {            /**             * @psalm-suppress NullReference             * @phpstan-ignore-next-line             */            $this->aggregate->reject($e);        } catch (\Exception $e) {            /**             * @psalm-suppress NullReference             * @phpstan-ignore-next-line             */            $this->aggregate->reject($e);        }        /**         * @psalm-suppress NullableReturnStatement         * @phpstan-ignore-next-line         */        return $this->aggregate;    }    private function createPromise()    {        $this->mutex = false;        $this->aggregate = new Promise(function () {            reset($this->pending);            // Consume a potentially fluctuating list of promises while            // ensuring that indexes are maintained (precluding array_shift).            while ($promise = current($this->pending)) {                next($this->pending);                $promise->wait();                if (Is::settled($this->aggregate)) {                    return;                }            }        });        // Clear the references when the promise is resolved.        $clearFn = function () {            $this->iterable = $this->concurrency = $this->pending = null;            $this->onFulfilled = $this->onRejected = null;            $this->nextPendingIndex = 0;        };        $this->aggregate->then($clearFn, $clearFn);    }    private function refillPending()    {        if (!$this->concurrency) {            // Add all pending promises.            while ($this->addPending() && $this->advanceIterator());            return;        }        // Add only up to N pending promises.        $concurrency = is_callable($this->concurrency)            ? call_user_func($this->concurrency, count($this->pending))            : $this->concurrency;        $concurrency = max($concurrency - count($this->pending), 0);        // Concurrency may be set to 0 to disallow new promises.        if (!$concurrency) {            return;        }        // Add the first pending promise.        $this->addPending();        // Note this is special handling for concurrency=1 so that we do        // not advance the iterator after adding the first promise. This        // helps work around issues with generators that might not have the        // next value to yield until promise callbacks are called.        while (--$concurrency            && $this->advanceIterator()            && $this->addPending());    }    private function addPending()    {        if (!$this->iterable || !$this->iterable->valid()) {            return false;        }        $promise = Create::promiseFor($this->iterable->current());        $key = $this->iterable->key();        // Iterable keys may not be unique, so we use a counter to        // guarantee uniqueness        $idx = $this->nextPendingIndex++;        $this->pending[$idx] = $promise->then(            function ($value) use ($idx, $key) {                if ($this->onFulfilled) {                    call_user_func(                        $this->onFulfilled,                        $value,                        $key,                        $this->aggregate                    );                }                $this->step($idx);            },            function ($reason) use ($idx, $key) {                if ($this->onRejected) {                    call_user_func(                        $this->onRejected,                        $reason,                        $key,                        $this->aggregate                    );                }                $this->step($idx);            }        );        return true;    }    private function advanceIterator()    {        // Place a lock on the iterator so that we ensure to not recurse,        // preventing fatal generator errors.        if ($this->mutex) {            return false;        }        $this->mutex = true;        try {            $this->iterable->next();            $this->mutex = false;            return true;        } catch (\Throwable $e) {            $this->aggregate->reject($e);            $this->mutex = false;            return false;        } catch (\Exception $e) {            $this->aggregate->reject($e);            $this->mutex = false;            return false;        }    }    private function step($idx)    {        // If the promise was already resolved, then ignore this step.        if (Is::settled($this->aggregate)) {            return;        }        unset($this->pending[$idx]);        // Only refill pending promises if we are not locked, preventing the        // EachPromise to recursively invoke the provided iterator, which        // cause a fatal error: ""Cannot resume an already running generator""        if ($this->advanceIterator() && !$this->checkIfFinished()) {            // Add more pending promises if possible.            $this->refillPending();        }    }    private function checkIfFinished()    {        if (!$this->pending && !$this->iterable->valid()) {            // Resolve the promise if there's nothing left to do.            $this->aggregate->resolve(null);            return true;        }        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_FulfilledPromise_710, A promise that has been fulfilled.\\n\\n Thenning off of this promise will invoke the onFulfilled callback\\n immediately and ignore other callbacks.\\n, A promise that has been fulfilled.,"class FulfilledPromise implements PromiseInterface{    private $value;    public function __construct($value)    {        if (is_object($value) && method_exists($value, 'then')) {            throw new \InvalidArgumentException(                'You cannot create a FulfilledPromise with a promise.'            );        }        $this->value = $value;    }    public function then(        callable $onFulfilled = null,        callable $onRejected = null    ) {        // Return itself if there is no onFulfilled function.        if (!$onFulfilled) {            return $this;        }        $queue = Utils::queue();        $p = new Promise([$queue, 'run']);        $value = $this->value;        $queue->add(static function () use ($p, $value, $onFulfilled) {            if (Is::pending($p)) {                try {                    $p->resolve($onFulfilled($value));                } catch (\Throwable $e) {                    $p->reject($e);                } catch (\Exception $e) {                    $p->reject($e);                }            }        });        return $p;    }    public function otherwise(callable $onRejected)    {        return $this->then(null, $onRejected);    }    public function wait($unwrap = true, $defaultDelivery = null)    {        return $unwrap ? $this->value : null;    }    public function getState()    {        return self::FULFILLED;    }    public function resolve($value)    {        if ($value !== $this->value) {            throw new \LogicException(""Cannot resolve a fulfilled promise"");        }    }    public function reject($reason)    {        throw new \LogicException(""Cannot reject a fulfilled promise"");    }    public function cancel()    {        // pass    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Is_711, Returns true if a promise is pending.\\n\\n @return bool\\n, Returns true if a promise is pending.,    public static function pending(PromiseInterface $promise)    {        return $promise->getState() === PromiseInterface::PENDING;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Is_712, Returns true if a promise is fulfilled or rejected.\\\\\\\\n\\\\\\\\n @return bool\\\\\\\\n, Returns true if a promise is fulfilled or rejected.,    public static function settled(PromiseInterface $promise)    {        return $promise->getState() !== PromiseInterface::PENDING;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Is_713, Returns true if a promise is fulfilled.\\\\\\\\n\\\\\\\\n @return bool\\\\\\\\n, Returns true if a promise is fulfilled.,    public static function fulfilled(PromiseInterface $promise)    {        return $promise->getState() === PromiseInterface::FULFILLED;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Is_714, Returns true if a promise is rejected.\n\n @return bool\n, Returns true if a promise is rejected.,    public static function rejected(PromiseInterface $promise)    {        return $promise->getState() === PromiseInterface::REJECTED;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Promise_715, Promises/A+ implementation that avoids recursion when possible.\\\\\\\\n\\\\\\\\n @link https://promisesaplus.com/\\\\\\\\n, Promises/A+ implementation that avoids recursion when possible.,"class Promise implements PromiseInterface{    private $state = self::PENDING;    private $result;    private $cancelFn;    private $waitFn;    private $waitList;    private $handlers = [];    /**     * @param callable $waitFn   Fn that when invoked resolves the promise.     * @param callable $cancelFn Fn that when invoked cancels the promise.     */    public function __construct(        callable $waitFn = null,        callable $cancelFn = null    ) {        $this->waitFn = $waitFn;        $this->cancelFn = $cancelFn;    }    public function then(        callable $onFulfilled = null,        callable $onRejected = null    ) {        if ($this->state === self::PENDING) {            $p = new Promise(null, [$this, 'cancel']);            $this->handlers[] = [$p, $onFulfilled, $onRejected];            $p->waitList = $this->waitList;            $p->waitList[] = $this;            return $p;        }        // Return a fulfilled promise and immediately invoke any callbacks.        if ($this->state === self::FULFILLED) {            $promise = Create::promiseFor($this->result);            return $onFulfilled ? $promise->then($onFulfilled) : $promise;        }        // It's either cancelled or rejected, so return a rejected promise        // and immediately invoke any callbacks.        $rejection = Create::rejectionFor($this->result);        return $onRejected ? $rejection->then(null, $onRejected) : $rejection;    }    public function otherwise(callable $onRejected)    {        return $this->then(null, $onRejected);    }    public function wait($unwrap = true)    {        $this->waitIfPending();        if ($this->result instanceof PromiseInterface) {            return $this->result->wait($unwrap);        }        if ($unwrap) {            if ($this->state === self::FULFILLED) {                return $this->result;            }            // It's rejected so ""unwrap"" and throw an exception.            throw Create::exceptionFor($this->result);        }    }    public function getState()    {        return $this->state;    }    public function cancel()    {        if ($this->state !== self::PENDING) {            return;        }        $this->waitFn = $this->waitList = null;        if ($this->cancelFn) {            $fn = $this->cancelFn;            $this->cancelFn = null;            try {                $fn();            } catch (\Throwable $e) {                $this->reject($e);            } catch (\Exception $e) {                $this->reject($e);            }        }        // Reject the promise only if it wasn't rejected in a then callback.        /** @psalm-suppress RedundantCondition */        if ($this->state === self::PENDING) {            $this->reject(new CancellationException('Promise has been cancelled'));        }    }    public function resolve($value)    {        $this->settle(self::FULFILLED, $value);    }    public function reject($reason)    {        $this->settle(self::REJECTED, $reason);    }    private function settle($state, $value)    {        if ($this->state !== self::PENDING) {            // Ignore calls with the same resolution.            if ($state === $this->state && $value === $this->result) {                return;            }            throw $this->state === $state                ? new \LogicException(""The promise is already {$state}."")                : new \LogicException(""Cannot change a {$this->state} promise to {$state}"");        }        if ($value === $this) {            throw new \LogicException('Cannot fulfill or reject a promise with itself');        }        // Clear out the state of the promise but stash the handlers.        $this->state = $state;        $this->result = $value;        $handlers = $this->handlers;        $this->handlers = null;        $this->waitList = $this->waitFn = null;        $this->cancelFn = null;        if (!$handlers) {            return;        }        // If the value was not a settled promise or a thenable, then resolve        // it in the task queue using the correct ID.        if (!is_object($value) || !method_exists($value, 'then')) {            $id = $state === self::FULFILLED ? 1 : 2;            // It's a success, so resolve the handlers in the queue.            Utils::queue()->add(static function () use ($id, $value, $handlers) {                foreach ($handlers as $handler) {                    self::callHandler($id, $value, $handler);                }            });        } elseif ($value instanceof Promise && Is::pending($value)) {            // We can just merge our handlers onto the next promise.            $value->handlers = array_merge($value->handlers, $handlers);        } else {            // Resolve the handlers when the forwarded promise is resolved.            $value->then(                static function ($value) use ($handlers) {                    foreach ($handlers as $handler) {                        self::callHandler(1, $value, $handler);                    }                },                static function ($reason) use ($handlers) {                    foreach ($handlers as $handler) {                        self::callHandler(2, $reason, $handler);                    }                }            );        }    }    /**     * Call a stack of handlers using a specific callback index and value.     *     * @param int   $index   1 (resolve) or 2 (reject).     * @param mixed $value   Value to pass to the callback.     * @param array $handler Array of handler data (promise and callbacks).     */    private static function callHandler($index, $value, array $handler)    {        /** @var PromiseInterface $promise */        $promise = $handler[0];        // The promise may have been cancelled or resolved before placing        // this thunk in the queue.        if (Is::settled($promise)) {            return;        }        try {            if (isset($handler[$index])) {                /*                 * If $f throws an exception, then $handler will be in the exception                 * stack trace. Since $handler contains a reference to the callable                 * itself we get a circular reference. We clear the $handler                 * here to avoid that memory leak.                 */                $f = $handler[$index];                unset($handler);                $promise->resolve($f($value));            } elseif ($index === 1) {                // Forward resolution values as-is.                $promise->resolve($value);            } else {                // Forward rejections down the chain.                $promise->reject($value);            }        } catch (\Throwable $reason) {            $promise->reject($reason);        } catch (\Exception $reason) {            $promise->reject($reason);        }    }    private function waitIfPending()    {        if ($this->state !== self::PENDING) {            return;        } elseif ($this->waitFn) {            $this->invokeWaitFn();        } elseif ($this->waitList) {            $this->invokeWaitList();        } else {            // If there's no wait function, then reject the promise.            $this->reject('Cannot wait on a promise that has '                . 'no internal wait function. You must provide a wait '                . 'function when constructing the promise to be able to '                . 'wait on a promise.');        }        Utils::queue()->run();        /** @psalm-suppress RedundantCondition */        if ($this->state === self::PENDING) {            $this->reject('Invoking the wait callback did not resolve the promise');        }    }    private function invokeWaitFn()    {        try {            $wfn = $this->waitFn;            $this->waitFn = null;            $wfn(true);        } catch (\Exception $reason) {            if ($this->state === self::PENDING) {                // The promise has not been resolved yet, so reject the promise                // with the exception.                $this->reject($reason);            } else {                // The promise was already resolved, so there's a problem in                // the application.                throw $reason;            }        }    }    private function invokeWaitList()    {        $waitList = $this->waitList;        $this->waitList = null;        foreach ($waitList as $result) {            do {                $result->waitIfPending();                $result = $result->result;            } while ($result instanceof Promise);            if ($result instanceof PromiseInterface) {                $result->wait(false);            }        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_PropertyHelper_730, A class to help get properties of an object.\\n\\n @internal\\n\\n @author Tobias Nyholm <tobias.nyholm@gmail.com>\\n, A class to help get properties of an object.,"class PropertyHelper{    /**     * @param object $object     * @param string $property     *     * @throws \ReflectionException     */    public static function get($object, $property)    {        $property = (new \ReflectionObject($object))->getProperty($property);        $property->setAccessible(true);        return $property->getValue($object);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_FactoryParameter_2311, Compute qualified name for the given type.\n\n This function knows how to prefix class names with a leading slash and\n also how to handle PHP 8's union types.\n\n @param ReflectionType $type\n\n @return string\n, Compute qualified name for the given type.,"    private static function getQualifiedName(ReflectionType $type)    {        // PHP 8 union types can be recursively processed        if ($type instanceof ReflectionUnionType) {            return implode('|', array_map(function (ReflectionType $type) {                // The ""self::"" call within a Closure is fine here because this                // code will only ever be executed on PHP 7.0+                return self::getQualifiedName($type);            }, $type->getTypes()));        }        // PHP 7.0 doesn't have named types, but 7.1+ does        $name = $type instanceof ReflectionNamedType ? $type->getName() : (string) $type;        return $type->isBuiltin() ? $name : sprintf('\\%s', $name);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1804," Make an assertion and throw {@link Hamcrest_AssertionError} if it fails.\\n\\n Example:\\n <pre>\\n //With an identifier\\n assertThat(""assertion identifier"", $apple->flavour(), equalTo(""tasty""));\\n //Without an identifier\\n assertThat($apple->flavour(), equalTo(""tasty""));\\n //Evaluating a boolean expression\\n assertThat(""some error"", $a > $b);\\n </pre>\\n", Make an assertion and throw {@link Hamcrest_AssertionError} if it fails.,"    function assertThat()    {        $args = func_get_args();        call_user_func_array(            array('Hamcrest\MatcherAssert', 'assertThat'),            $args        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1811, An array with elements that match the given matchers in the same order.\n, An array with elements that match the given matchers in the same order.,"    function contains(/* args... */)    {        $args = func_get_args();        return call_user_func_array(array('\Hamcrest\Arrays\IsArrayContainingInOrder', 'arrayContaining'), $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1863, Matches if value contains $substrings in a constrained order.\n, Matches if value contains $substrings in a constrained order.,"    function stringContainsInOrder(/* args... */)    {        $args = func_get_args();        return call_user_func_array(array('\Hamcrest\Text\StringContainsInOrder', 'stringContainsInOrder'), $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_2315, Evaluates to true only if each $matcher[$i] is satisfied by $array[$i].\n, Evaluates to true only if each $matcher[$i] is satisfied by $array[$i].,"    function anArray(/* args... */)    {        $args = func_get_args();        return call_user_func_array(array('\Hamcrest\Arrays\IsArray', 'anArray'), $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_2318, An array with elements that match the given matchers.\n, An array with elements that match the given matchers.,"    function arrayContainingInAnyOrder(/* args... */)    {        $args = func_get_args();        return call_user_func_array(array('\Hamcrest\Arrays\IsArrayContainingInAnyOrder', 'arrayContainingInAnyOrder'), $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_2341," Test if the value is an array containing this matcher.\\n\\n Example:\\n <pre>\\n assertThat(array('a', 'b'), hasItem(equalTo('b')));\\n //Convenience defaults to equalTo()\\n assertThat(array('a', 'b'), hasItem('b'));\\n </pre>\\n", Test if the value is an array containing this matcher.,"    function hasItem(/* args... */)    {        $args = func_get_args();        return call_user_func_array(array('\Hamcrest\Core\IsCollectionContaining', 'hasItem'), $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_MatcherAssert_1898," Performs the actual assertion logic.\\n\\n If <code>$matcher</code> doesn't match <code>$actual</code>,\\n throws a {@link Hamcrest\\\\AssertionError} with a description\\n of the failure along with the optional <code>$identifier</code>.\\n\\n @param string $identifier added to the message upon failure\\n @param mixed $actual value to compare against <code>$matcher</code>\\n @param \\\\Hamcrest\\\\Matcher $matcher applied to <code>$actual</code>\\n @throws AssertionError\\n", Performs the actual assertion logic.,"    private static function doAssert($identifier, $actual, Matcher $matcher)    {        if (!$matcher->matches($actual)) {            $description = new StringDescription();            if (!empty($identifier)) {                $description->appendText($identifier . PHP_EOL);            }            $description->appendText('Expected: ')                                    ->appendDescriptionOf($matcher)                                    ->appendText(PHP_EOL . '     but: ');            $matcher->describeMismatch($actual, $description);            throw new AssertionError((string) $description);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
humhub_humhub_AppAsset_2462, AppAsset includes HumHub core assets to the main layout.\n This Assetbundle includes some core dependencies and the humhub core api.\n\n Note: All CSS/JS files will be compressed and bundled. If you need dynamic\n css/js loading e.g. based on users locale: see AppDynamicAsset\n, AppAsset includes HumHub core assets to the main layout.,"class AppAsset extends WebStaticAssetBundle{    /**     * @inheritdoc     */    public $defer = false;    /**     * @inheritdoc     */    public $defaultDepends = false;    /**     * @inheritdoc     */    public $jsPosition = View::POS_HEAD;    const BUNDLE_NAME = 'app';    const STATIC_DEPENDS = [        JqueryAsset::class,        JuiBootstrapBridgeAsset::class,        JuiAsset::class,        YiiAsset::class,        ActiveFormAsset::class,        ValidationAsset::class,        BootstrapAsset::class,        BootstrapPluginAsset::class,        BluebirdAsset::class,        FontAwesomeAsset::class,        AnimateCssAsset::class, // preload        OpenSansAsset::class,        PjaxAsset::class,        JqueryTimeAgoAsset::class,        /**         * Style only assets         */        HighlightJsStyleAsset::class,        NProgressStyleAsset::class,        Select2StyleAsset::class,        BlueimpGalleryStyleAsset::class,        FlatelementsStyleAsset::class,        /**         * Polyfills         */        IntersectionObserverPolyfillAsset::class,        /**         * Core HumHub API + commonly required modules         */        CoreApiAsset::class,        ContentAsset::class,        FileAsset::class,    ];    /**     * @inheritdoc     */    public $depends = self::STATIC_DEPENDS;    /**     * @inheritdoc     */    public $js = [        'js/desktop-notify-min.js',        'js/desktop-notify-config.js',    ];    /**     * @inheritdoc     */    public static function register($view)    {        $instance = parent::register($view);        AppDynamicAsset::register($view);        CoreBundleAsset::register($view);        return $instance;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
invoiceninja_invoiceninja_AcceptanceTester_1739, Define custom actions here\n, Define custom actions here,"    function checkIfLogin(\AcceptanceTester $I)    {        $I->amOnPage('/login?lang=en');        $I->see('Login');        $I->fillField(['name' => 'email'], Fixtures::get('username'));        $I->fillField(['name' => 'password'], Fixtures::get('password'));        $I->click('Login');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
invoiceninja_invoiceninja_TestCase_1737, Creates the application.\\\\n\\\\n @return \\\\\\\\Illuminate\\\\\\\\Foundation\\\\\\\\Application\\\\n, Creates the application.,    public function createApplication()    {        $app = require __DIR__.'/../bootstrap/app.php';        $app->make(Illuminate\Contracts\Console\Kernel::class)->bootstrap();        return $app;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Apriori_802, Get all association rules which are generated for every k-length frequent item set.\n\n @return mixed[][]\n, Get all association rules which are generated for every k-length frequent item set.,    public function getRules(): array    {        if (count($this->large) === 0) {            $this->large = $this->apriori();        }        if (count($this->rules) > 0) {            return $this->rules;        }        $this->rules = [];        $this->generateAllRules();        return $this->rules;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Apriori_808, Generates all proper subsets for given set $sample without the empty set.\n\n @param mixed[] $sample\n\n @return mixed[][]\n, Generates all proper subsets for given set $sample without the empty set.,"    private function antecedents(array $sample): array    {        $cardinality = count($sample);        $antecedents = $this->powerSet($sample);        return array_filter($antecedents, static function ($antecedent) use ($cardinality): bool {            return (count($antecedent) != $cardinality) && ($antecedent != []);        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Apriori_812, Calculates confidence for $set. Confidence is the relative amount of sets containing $subset which also contain\n $set.\n\n @param mixed[] $set\n @param mixed[] $subset\n, Calculates confidence for $set. Confidence is the relative amount of sets containing $subset which also contain,"    private function confidence(array $set, array $subset): float    {        return $this->support($set) / $this->support($subset);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Apriori_813, Calculates support for item set $sample. Support is the relative amount of sets containing $sample in the data\n pool.\n\n @see \\Phpml\\Association\\Apriori::samples\n\n @param mixed[] $sample\n, Calculates support for item set $sample. Support is the relative amount of sets containing $sample in the data,    private function support(array $sample): float    {        return $this->frequency($sample) / count($this->samples);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_ConjugateGradient_932, Returns the value of f(x) for given solution\n, Returns the value of f(x) for given solution,    protected function cost(array $theta): float    {        [$cost] = parent::gradient($theta);        return array_sum($cost) / (int) $this->sampleCount;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_ConjugateGradient_938, Element-wise <b>multiplication</b> of two vectors of the same size\n, Element-wise <b>multiplication</b> of two vectors of the same size,"    public static function mul(array $m1, array $m2): array    {        $res = [];        foreach ($m1 as $i => $val) {            $res[] = $val * $m2[$i];        }        return $res;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_ConjugateGradient_942, Element-wise <b>division</b> of a vector with a scalar\n, Element-wise <b>division</b> of a vector with a scalar,"    public static function divs(array $m1, float $m2): array    {        $res = [];        foreach ($m1 as $val) {            $res[] = $val / ($m2 + 1e-32);        }        return $res;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_DecisionTree_819," This method is used to set number of columns to be used\n when deciding a split at an internal node of the tree.  <br>\n If the value is given 0, then all features are used (default behaviour),\n otherwise the given value will be used as a maximum for number of columns\n randomly selected for each split operation.\n\n @return $this\n\n @throws InvalidArgumentException\n", This method is used to set number of columns to be used,    public function setNumFeatures(int $numFeatures)    {        if ($numFeatures < 0) {            throw new InvalidArgumentException('Selected column count should be greater or equal to zero');        }        $this->numUsableFeatures = $numFeatures;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_EigenvalueDecomposition_1001," Nonsymmetric reduction to Hessenberg form.\n\n This is derived from the Algol procedures orthes and ortran,\n by Martin and Wilkinson, Handbook for Auto. Comp.,\n Vol.ii-Linear Algebra, and the corresponding\n Fortran subroutines in EISPACK.\n", Nonsymmetric reduction to Hessenberg form.,    private function orthes(): void    {        $low = 0;        $high = $this->n - 1;        for ($m = $low + 1; $m <= $high - 1; ++$m) {            // Scale column.            $scale = 0.0;            for ($i = $m; $i <= $high; ++$i) {                $scale += abs($this->H[$i][$m - 1]);            }            if ($scale != 0.0) {                // Compute Householder transformation.                $h = 0.0;                for ($i = $high; $i >= $m; --$i) {                    $this->ort[$i] = $this->H[$i][$m - 1] / $scale;                    $h += $this->ort[$i] * $this->ort[$i];                }                $g = $h ** .5;                if ($this->ort[$m] > 0) {                    $g *= -1;                }                $h -= $this->ort[$m] * $g;                $this->ort[$m] -= $g;                // Apply Householder similarity transformation                // H = (I -u * u' / h) * H * (I -u * u') / h)                for ($j = $m; $j < $this->n; ++$j) {                    $f = 0.0;                    for ($i = $high; $i >= $m; --$i) {                        $f += $this->ort[$i] * $this->H[$i][$j];                    }                    $f /= $h;                    for ($i = $m; $i <= $high; ++$i) {                        $this->H[$i][$j] -= $f * $this->ort[$i];                    }                }                for ($i = 0; $i <= $high; ++$i) {                    $f = 0.0;                    for ($j = $high; $j >= $m; --$j) {                        $f += $this->ort[$j] * $this->H[$i][$j];                    }                    $f /= $h;                    for ($j = $m; $j <= $high; ++$j) {                        $this->H[$i][$j] -= $f * $this->ort[$j];                    }                }                $this->ort[$m] = $scale * $this->ort[$m];                $this->H[$m][$m - 1] = $scale * $g;            }        }        // Accumulate transformations (Algol's ortran).        for ($i = 0; $i < $this->n; ++$i) {            for ($j = 0; $j < $this->n; ++$j) {                $this->V[$i][$j] = ($i == $j ? 1.0 : 0.0);            }        }        for ($m = $high - 1; $m >= $low + 1; --$m) {            if ($this->H[$m][$m - 1] != 0.0) {                for ($i = $m + 1; $i <= $high; ++$i) {                    $this->ort[$i] = $this->H[$i][$m - 1];                }                for ($j = $m; $j <= $high; ++$j) {                    $g = 0.0;                    for ($i = $m; $i <= $high; ++$i) {                        $g += $this->ort[$i] * $this->V[$i][$j];                    }                    // Double division avoids possible underflow                    $g /= $this->ort[$m];                    $g /= $this->H[$m][$m - 1];                    for ($i = $m; $i <= $high; ++$i) {                        $this->V[$i][$j] += $g * $this->ort[$i];                    }                }            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Euclidean_990, Square of Euclidean distance\n\n @throws \\Phpml\\Exception\\InvalidArgumentException\n, Square of Euclidean distance,"    public function sqDistance(array $a, array $b): float    {        return $this->distance($a, $b) ** 2;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_GD_945," Calculates gradient, cost function and penalty term for each sample\n then returns them as an array of values\n"," Calculates gradient, cost function and penalty term for each sample","    protected function gradient(array $theta): array    {        $costs = [];        $gradient = [];        $totalPenalty = 0;        if ($this->gradientCb === null) {            throw new InvalidOperationException('Gradient callback is not defined');        }        foreach ($this->samples as $index => $sample) {            $target = $this->targets[$index];            $result = ($this->gradientCb)($theta, $sample, $target);            [$cost, $grad, $penalty] = array_pad($result, 3, 0);            $costs[] = $cost;            $gradient[] = $grad;            $totalPenalty += $penalty;        }        $totalPenalty /= $this->sampleCount;        return [$costs, $gradient, $totalPenalty];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Gaussian_1014, Returns probability density of the given <i>$value</i>\n\n @return float|int\n, Returns probability density of the given <i>$value</i>,    public function pdf(float $value)    {        // Calculate the probability density by use of normal/Gaussian distribution        // Ref: https://en.wikipedia.org/wiki/Normal_distribution        $std2 = $this->std ** 2;        $mean = $this->mean;        return exp(-(($value - $mean) ** 2) / (2 * $std2)) / ((2 * $std2 * M_PI) ** .5);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Gaussian_1015, Returns probability density value of the given <i>$value</i> based on\n given standard deviation and the mean\n, Returns probability density value of the given <i>$value</i> based on,"    public static function distributionPdf(float $mean, float $std, float $value): float    {        $normal = new self($mean, $std);        return $normal->pdf($value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_IrisDataset_895, Classes: 3\n Samples per class: 50\n Samples total: 150\n Features per sample: 4.\n, Classes: 3,"class IrisDataset extends CsvDataset{    public function __construct()    {        $filepath = __DIR__.'/../../../data/iris.csv';        parent::__construct($filepath, 4, true);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_LDA_908, Transforms the given sample to a lower dimensional vector by using\n the eigenVectors obtained in the last run of <code>fit</code>.\n\n @throws InvalidOperationException\n, Transforms the given sample to a lower dimensional vector by using,"    public function transform(array $sample): array    {        if (!$this->fit) {            throw new InvalidOperationException('LDA has not been fitted with respect to original dataset, please run LDA::fit() first');        }        if (!is_array($sample[0])) {            $sample = [$sample];        }        return $this->reduce($sample);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_LUDecomposition_1005, Get lower triangular factor.\n\n @return Matrix Lower triangular factor\n, Get lower triangular factor.,    public function getL(): Matrix    {        $L = [];        for ($i = 0; $i < $this->m; ++$i) {            for ($j = 0; $j < $this->n; ++$j) {                if ($i > $j) {                    $L[$i][$j] = $this->LU[$i][$j];                } elseif ($i == $j) {                    $L[$i][$j] = 1.0;                } else {                    $L[$i][$j] = 0.0;                }            }        }        return new Matrix($L);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_LogisticRegression_861," Lambda (λ) parameter of regularization term. If 0 is given,\n then the regularization term is cancelled\n"," Lambda (λ) parameter of regularization term. If 0 is given,",    public function setLambda(float $lambda): void    {        $this->lambda = $lambda;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_LogisticRegression_864, Returns the appropriate callback function for the selected cost function\n\n @throws \\Exception\n, Returns the appropriate callback function for the selected cost function,"    protected function getCostFunction(): Closure    {        $penalty = 0;        if ($this->penalty === 'L2') {            $penalty = $this->lambda;        }        switch ($this->costFunction) {            case 'log':                /*                 * Negative of Log-likelihood cost function to be minimized:                 *J(x) = ∑( - y . log(h(x)) - (1 - y) . log(1 - h(x)))                 *                 * If regularization term is given, then it will be added to the cost:                 *for L2 : J(x) = J(x) +  λ/m . w                 *                 * The gradient of the cost function to be used with gradient descent:                 *∇J(x) = -(y - h(x)) = (h(x) - y)                 */                return function ($weights, $sample, $y) use ($penalty): array {                    $this->weights = $weights;                    $hX = $this->output($sample);                    // In cases where $hX = 1 or $hX = 0, the log-likelihood                    // value will give a NaN, so we fix these values                    if ($hX == 1) {                        $hX = 1 - 1e-10;                    }                    if ($hX == 0) {                        $hX = 1e-10;                    }                    $y = $y < 0 ? 0 : 1;                    $error = -$y * log($hX) - (1 - $y) * log(1 - $hX);                    $gradient = $hX - $y;                    return [$error, $gradient, $penalty];                };            case 'sse':                /*                 * Sum of squared errors or least squared errors cost function:                 *J(x) = ∑ (y - h(x))^2                 *                 * If regularization term is given, then it will be added to the cost:                 *for L2 : J(x) = J(x) +  λ/m . w                 *                 * The gradient of the cost function:                 *∇J(x) = -(h(x) - y) . h(x) . (1 - h(x))                 */                return function ($weights, $sample, $y) use ($penalty): array {                    $this->weights = $weights;                    $hX = $this->output($sample);                    $y = $y < 0 ? 0 : 1;                    $error = (($y - $hX) ** 2);                    $gradient = -($y - $hX) * $hX * (1 - $hX);                    return [$error, $gradient, $penalty];                };            default:                // Not reached                throw new Exception(sprintf('Logistic regression has invalid cost function: %s.', $this->costFunction));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_LogisticRegression_867," Returns the output of the network, a float value between 0.0 and 1.0\n"," Returns the output of the network, a float value between 0.0 and 1.0",    protected function output(array $sample): float    {        $sum = parent::output($sample);        return 1.0 / (1.0 + exp(-$sum));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_MnistDataset_892, MNIST dataset: http://yann.lecun.com/exdb/mnist/\n original mnist dataset reader: https://github.com/AndrewCarterUK/mnist-neural-network-plain-php\n, MNIST dataset: http://yann.lecun.com/exdb/mnist/,"final class MnistDataset extends ArrayDataset{    private const MAGIC_IMAGE = 0x00000803;    private const MAGIC_LABEL = 0x00000801;    private const IMAGE_ROWS = 28;    private const IMAGE_COLS = 28;    public function __construct(string $imagePath, string $labelPath)    {        $this->samples = $this->readImages($imagePath);        $this->targets = $this->readLabels($labelPath);        if (count($this->samples) !== count($this->targets)) {            throw new InvalidArgumentException('Must have the same number of images and labels');        }    }    private function readImages(string $imagePath): array    {        $stream = fopen($imagePath, 'rb');        if ($stream === false) {            throw new InvalidArgumentException('Could not open file: '.$imagePath);        }        $images = [];        try {            $header = fread($stream, 16);            $fields = unpack('Nmagic/Nsize/Nrows/Ncols', (string) $header);            if ($fields['magic'] !== self::MAGIC_IMAGE) {                throw new InvalidArgumentException('Invalid magic number: '.$imagePath);            }            if ($fields['rows'] != self::IMAGE_ROWS) {                throw new InvalidArgumentException('Invalid number of image rows: '.$imagePath);            }            if ($fields['cols'] != self::IMAGE_COLS) {                throw new InvalidArgumentException('Invalid number of image cols: '.$imagePath);            }            for ($i = 0; $i < $fields['size']; $i++) {                $imageBytes = fread($stream, $fields['rows'] * $fields['cols']);                // Convert to float between 0 and 1                $images[] = array_map(function ($b) {                    return $b / 255;                }, array_values(unpack('C*', (string) $imageBytes)));            }        } finally {            fclose($stream);        }        return $images;    }    private function readLabels(string $labelPath): array    {        $stream = fopen($labelPath, 'rb');        if ($stream === false) {            throw new InvalidArgumentException('Could not open file: '.$labelPath);        }        $labels = [];        try {            $header = fread($stream, 8);            $fields = unpack('Nmagic/Nsize', (string) $header);            if ($fields['magic'] !== self::MAGIC_LABEL) {                throw new InvalidArgumentException('Invalid magic number: '.$labelPath);            }            $labels = fread($stream, $fields['size']);        } finally {            fclose($stream);        }        return array_values(unpack('C*', (string) $labels));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_NaiveBayes_833, Calculates the probability P(label|sample_n)\n, Calculates the probability P(label|sample_n),"    private function sampleProbability(array $sample, int $feature, string $label): float    {        if (!isset($sample[$feature])) {            throw new InvalidArgumentException('Missing feature. All samples must have equal number of features');        }        $value = $sample[$feature];        if ($this->dataType[$label][$feature] == self::NOMINAL) {            if (!isset($this->discreteProb[$label][$feature][$value]) ||                $this->discreteProb[$label][$feature][$value] == 0) {                return self::EPSILON;            }            return $this->discreteProb[$label][$feature][$value];        }        $std = $this->std[$label][$feature];        $mean = $this->mean[$label][$feature];        // Calculate the probability density by use of normal/Gaussian distribution        // Ref: https://en.wikipedia.org/wiki/Normal_distribution        //        // In order to avoid numerical errors because of small or zero values,        // some libraries adopt taking log of calculations such as        // scikit-learn did.        // (See : https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/naive_bayes.py)        $pdf = -0.5 * log(2.0 * M_PI * $std * $std);        $pdf -= 0.5 * (($value - $mean) ** 2) / ($std * $std);        return $pdf;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_NaiveBayes_834, Return samples belonging to specific label\n, Return samples belonging to specific label,    private function getSamplesByLabel(string $label): array    {        $samples = [];        for ($i = 0; $i < $this->sampleCount; ++$i) {            if ($this->targets[$i] == $label) {                $samples[] = $this->samples[$i];            }        }        return $samples;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_OneVsRest_920, Resets the classifier and the vars internally used by OneVsRest to create multiple classifiers.\n, Resets the classifier and the vars internally used by OneVsRest to create multiple classifiers.,    public function reset(): void    {        $this->classifiers = [];        $this->allLabels = [];        $this->costValues = [];        $this->resetBinary();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Perceptron_874, Returns the class value (either -1 or 1) for the given input\n, Returns the class value (either -1 or 1) for the given input,    protected function outputClass(array $sample): int    {        return $this->output($sample) > 0 ? 1 : -1;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_RandomForest_848, This will return an array including an importance value for\n each column in the given dataset. Importance values for a column\n is the average importance of that column in all trees in the forest\n, This will return an array including an importance value for,"    public function getFeatureImportances(): array    {        // Traverse each tree and sum importance of the columns        $sum = [];        foreach ($this->classifiers as $tree) {            /** @var DecisionTree $tree */            $importances = $tree->getFeatureImportances();            foreach ($importances as $column => $importance) {                if (array_key_exists($column, $sum)) {                    $sum[$column] += $importance;                } else {                    $sum[$column] = $importance;                }            }        }        // Normalize & sort the importance values        $total = array_sum($sum);        array_walk($sum, function (&$importance) use ($total): void {            $importance /= $total;        });        arsort($sum);        return $sum;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Set_972, Creates the difference of A and B.\n, Creates the difference of A and B.,"    public static function difference(self $a, self $b): self    {        return new self(array_diff($a->toArray(), $b->toArray()));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_UnivariateLinearRegression_918," Quick linear model for testing the effect of a single regressor,\n sequentially for many regressors.\n\n This is done in 2 steps:\n\n 1. The cross correlation between each regressor and the target is computed,\n that is, ((X[:, i] - mean(X[:, i]))  2. It is converted to an F score.\n\n Ported from scikit-learn f_regression function (http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.f_regression.html#sklearn.feature_selection.f_regression)\n"," Quick linear model for testing the effect of a single regressor,","final class UnivariateLinearRegression implements ScoringFunction{    /**     * @var bool     */    private $center;    /**     * @param bool $center - if true samples and targets will be centered     */    public function __construct(bool $center = true)    {        $this->center = $center;    }    public function score(array $samples, array $targets): array    {        if ($this->center) {            $this->centerTargets($targets);            $this->centerSamples($samples);        }        $correlations = [];        foreach (array_keys($samples[0]) as $index) {            $featureColumn = array_column($samples, $index);            $correlations[$index] =                Matrix::dot($targets, $featureColumn)[0] / (new Matrix($featureColumn, false))->transpose()->frobeniusNorm()                / (new Matrix($targets, false))->frobeniusNorm();        }        $degreesOfFreedom = count($targets) - ($this->center ? 2 : 1);        return array_map(function (float $correlation) use ($degreesOfFreedom): float {            return $correlation ** 2 / (1 - $correlation ** 2) * $degreesOfFreedom;        }, $correlations);    }    private function centerTargets(array &$targets): void    {        $mean = Mean::arithmetic($targets);        array_walk($targets, function (&$target) use ($mean): void {            $target -= $mean;        });    }    private function centerSamples(array &$samples): void    {        $means = [];        foreach ($samples[0] as $index => $feature) {            $means[$index] = Mean::arithmetic(array_column($samples, $index));        }        foreach ($samples as &$sample) {            foreach ($sample as $index => &$feature) {                $feature -= $means[$index];            }        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_framework_AuthManager_4, Create a session based authentication guard.\n\n @param  string  $name\n @param  array  $config\n @return \\Illuminate\\Auth\\SessionGuard\n, Create a session based authentication guard.,"    public function createSessionDriver($name, $config)    {        $provider = $this->createUserProvider($config['provider'] ?? null);        $guard = new SessionGuard($name, $provider, $this->app['session.store']);        // When using the remember me functionality of the authentication services we        // will need to be set the encryption instance of the guard, which allows        // secure, encrypted cookie values to get generated for those cookies.        if (method_exists($guard, 'setCookieJar')) {            $guard->setCookieJar($this->app['cookie']);        }        if (method_exists($guard, 'setDispatcher')) {            $guard->setDispatcher($this->app['events']);        }        if (method_exists($guard, 'setRequest')) {            $guard->setRequest($this->app->refresh('request', $guard, 'setRequest'));        }        return $guard;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_framework_AuthManager_5, Create a token based authentication guard.\n\n @param  string  $name\n @param  array  $config\n @return \\Illuminate\\Auth\\TokenGuard\n, Create a token based authentication guard.,"    public function createTokenDriver($name, $config)    {        // The token guard implements a basic API token based guard implementation        // that takes an API token field from the request and matches it to the        // user in the database or another persistence layer where users are.        $guard = new TokenGuard(            $this->createUserProvider($config['provider'] ?? null),            $this->app['request'],            $config['input_key'] ?? 'api_token',            $config['storage_key'] ?? 'api_token',            $config['hash'] ?? false        );        $this->app->refresh('request', $guard, 'setRequest');        return $guard;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_framework_AuthServiceProvider_22, Register the access gate service.\n\n @return void\n, Register the access gate service.,"    protected function registerAccessGate()    {        $this->app->singleton(GateContract::class, function ($app) {            return new Gate($app, function () use ($app) {                return call_user_func($app['auth']->userResolver());            });        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_framework_AuthServiceProvider_23, Register a resolver for the authenticated user.\n\n @return void\n, Register a resolver for the authenticated user.,"    protected function registerRequirePassword()    {        $this->app->bind(RequirePassword::class, function ($app) {            return new RequirePassword(                $app[ResponseFactory::class],                $app[UrlGenerator::class],                $app['config']->get('auth.password_timeout')            );        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_framework_CreatesUserProviders_35, Get the user provider configuration.\n\n @param  string|null  $provider\n @return array|null\n, Get the user provider configuration.,    protected function getProviderConfiguration($provider)    {        if ($provider = $provider ?: $this->getDefaultUserProvider()) {            return $this->app['config']['auth.providers.'.$provider];        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_framework_DatabaseUserProvider_41," Retrieve a user by their unique identifier and ""remember me"" token.\n\n @param  mixed  $identifier\n @param  string  $token\n @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n"," Retrieve a user by their unique identifier and ""remember me"" token.","    public function retrieveByToken($identifier, $token)    {        $user = $this->getGenericUser(            $this->conn->table($this->table)->find($identifier)        );        return $user && $user->getRememberToken() && hash_equals($user->getRememberToken(), $token)                    ? $user : null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_framework_EloquentUserProvider_50, Retrieve a user by the given credentials.\n\n @param  array  $credentials\n @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n, Retrieve a user by the given credentials.,"    public function retrieveByCredentials(array $credentials)    {        if (empty($credentials) ||           (count($credentials) === 1 &&            Str::contains($this->firstCredentialKey($credentials), 'password'))) {            return;        }        // First we will add each credential element to the query as a where clause.        // Then we can execute the query and, if we found a user, return it in a        // Eloquent User ""model"" that will be utilized by the Guard instances.        $query = $this->newModelQuery();        foreach ($credentials as $key => $value) {            if (Str::contains($key, 'password')) {                continue;            }            if (is_array($value) || $value instanceof Arrayable) {                $query->whereIn($key, $value);            } else {                $query->where($key, $value);            }        }        return $query->first();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_framework_EloquentUserProvider_52, Validate a user against the given credentials.\n\n @param  \\Illuminate\\Contracts\\Auth\\Authenticatable  $user\n @param  array  $credentials\n @return bool\n, Validate a user against the given credentials.,"    public function validateCredentials(UserContract $user, array $credentials)    {        $plain = $credentials['password'];        return $this->hasher->check($plain, $user->getAuthPassword());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_framework_EloquentUserProvider_53, Create a new instance of the model.\n\n @return \\Illuminate\\Database\\Eloquent\\Model\n, Create a new instance of the model.,"    public function createModel()    {        $class = '\\'.ltrim($this->model, '\\');        return new $class;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_laravel_ExampleTest_17, A basic test example.\\n\\n @return void\\n, A basic test example.,    public function test_example()    {        $response = $this->get('/');        $response->assertStatus(200);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_laravel_Kernel_2, Register the commands for the application.\\n\\n @return void\\n, Register the commands for the application.,    protected function commands()    {        $this->load(__DIR__.'/Commands');        require base_path('routes/console.php');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_laravel_RedirectIfAuthenticated_740, Handle an incoming request.\n\n @param  \\Illuminate\\Http\\Request  $request\n @param  \\Closure  $next\n @param  string|null  ...$guards\n @return mixed\n, Handle an incoming request.,"    public function handle(Request $request, Closure $next, ...$guards)    {        $guards = empty($guards) ? [null] : $guards;        foreach ($guards as $guard) {            if (Auth::guard($guard)->check()) {                return redirect(RouteServiceProvider::HOME);            }        }        return $next($request);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_laravel_TrustHosts_6, Get the host patterns that should be trusted.\\n\\n @return array\\n, Get the host patterns that should be trusted.,"    public function hosts()    {        return [            $this->allSubdomainsOfApplicationUrl(),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_laravel_UserFactory_742, Define the model's default state.\n\n @return array\n, Define the model's default state.,"    public function definition()    {        return [            'name' => $this->faker->name(),            'email' => $this->faker->unique()->safeEmail(),            'email_verified_at' => now(),            'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password            'remember_token' => Str::random(10),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Application_2906, Gets list of application listeners.\n\n @param ServiceManager $serviceManager\n @param array $configuration\n @return array\n, Gets list of application listeners.,"    private function getListeners(ServiceManager $serviceManager, array $configuration)    {        $appConfigListeners = isset($configuration['listeners']) ? $configuration['listeners'] : [];        $config = $serviceManager->get('config');        $serviceConfigListeners = isset($config['listeners']) ? $config['listeners'] : [];        return array_unique(array_merge($serviceConfigListeners, $appConfigListeners));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Archive_2847, Split current format to list of archivers.\n\n @param string $source\n @return string[]|string\n, Split current format to list of archivers.,"    protected function _getArchivers($source)    {        $ext = pathinfo($source, PATHINFO_EXTENSION);        if (!empty($this->_formats[$ext])) {            return explode('.', $this->_formats[$ext]);        }        return [];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_CookieTester_2811, Retrieve cookie metadata factory\n, Retrieve cookie metadata factory,    protected function getCookieMetadataFactory()    {        return $this->cookieMetadataFactory;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_CookieTester_2813, Dispatch request\n\n @param RequestInterface $request\n @return \\Magento\\Framework\\App\\ResponseInterface\n, Dispatch request,    public function dispatch(RequestInterface $request)    {        $this->request = $request;        $result = $this->execute();        return $result ? $result : $this->_response;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_DataObject_2863, Get object data by particular key\n\n @param string $key\n @return mixed\n, Get object data by particular key,    public function getDataByKey($key)    {        return $this->_getData($key);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_DataObject_2864, Get value from _data array without parse key\n\n @param   string $key\n @return  mixed\n, Get value from _data array without parse key,    protected function _getData($key)    {        if (isset($this->_data[$key])) {            return $this->_data[$key];        }        return null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_DataObject_2872, Implementation of \\ArrayAccess::offsetGet()\n\n @param string $offset\n @return mixed\n @link http://www.php.net/manual/en/arrayaccess.offsetget.php\n, Implementation of ,    public function offsetGet($offset)    {        if (isset($this->_data[$offset])) {            return $this->_data[$offset];        }        return null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_DisableAdminUsage_2778, Controller to record Admin analytics usage log\n, Controller to record Admin analytics usage log,"class DisableAdminUsage extends Action implements HttpPostActionInterface{    /**     * @var Factory     */    private $configFactory;    /**     * @var ProductMetadataInterface     */    private $productMetadata;    /**     * @var NotificationLogger     */    private $notificationLogger;    /**     * DisableAdminUsage constructor.     *     * @param Action\Context $context     * @param ProductMetadataInterface $productMetadata     * @param NotificationLogger $notificationLogger     * @param Factory $configFactory     */    public function __construct(        Action\Context $context,        ProductMetadataInterface $productMetadata,        NotificationLogger $notificationLogger,        Factory $configFactory    ) {        parent::__construct($context);        $this->configFactory = $configFactory;        $this->productMetadata = $productMetadata;        $this->notificationLogger = $notificationLogger;    }    /**     * Change the value of config/admin/usage/enabled     */    private function disableAdminUsage()    {        $configModel = $this->configFactory->create();        $configModel->setDataByPath('admin/usage/enabled', 0);        $configModel->save();    }    /**     * Log information about the last admin usage selection     *     * @return ResultInterface     */    private function markUserNotified(): ResultInterface    {        $responseContent = [            'success' => $this->notificationLogger->log(                $this->productMetadata->getVersion()            ),            'error_message' => ''        ];        $resultJson = $this->resultFactory->create(ResultFactory::TYPE_JSON);        return $resultJson->setData($responseContent);    }    /**     * Log information about the last shown advertisement     *     * @return ResultInterface     */    public function execute()    {        $this->disableAdminUsage();        $this->markUserNotified();    }    /**     * @inheritDoc     */    protected function _isAllowed()    {        return $this->_authorization->isAllowed(static::ADMIN_RESOURCE);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_DisableAdminUsage_2782, Log information about the last shown advertisement\n\n @return ResultInterface\n, Log information about the last shown advertisement,    public function execute()    {        $this->disableAdminUsage();        $this->markUserNotified();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Item_2837, Template method used to configure the attribute codes for the custom attributes\n\n @return string[]\n, Template method used to configure the attribute codes for the custom attributes,"    protected function getCustomAttributesCodes()    {        return array_merge(            parent::getCustomAttributesCodes(),            [self::CUSTOM_ATTRIBUTE_1, self::CUSTOM_ATTRIBUTE_2, self::CUSTOM_ATTRIBUTE_3]        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Log_2800, Admin Analytics log resource\n, Admin Analytics log resource,class Log extends DataObject{    /**     * Get log id     *     * @return int     */    public function getId() : ?int    {        return $this->getData('id');    }    /**     * Get last viewed product version     *     * @return string     */    public function getLastViewVersion() : ?string    {        return $this->getData('last_viewed_in_version');    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Logger_2794, Admin Analytics log data logger.\n\n Saves and retrieves release notification viewer log data.\n, Admin Analytics log data logger.,"class Logger{    /**     * Admin Analytics usage version log table name     */    const LOG_TABLE_NAME = 'admin_analytics_usage_version_log';    /**     * @var Resource     */    private $resource;    /**     * @var LogFactory     */    private $logFactory;    /**     * @param ResourceConnection $resource     * @param LogFactory $logFactory     */    public function __construct(        ResourceConnection $resource,        LogFactory $logFactory    ) {        $this->resource = $resource;        $this->logFactory = $logFactory;    }    /**     * Save (insert new or update existing) log.     *     * @param string $lastViewVersion     * @return bool     */    public function log(string $lastViewVersion): bool    {        /** @var \Magento\Framework\DB\Adapter\AdapterInterface $connection */        $connection = $this->resource->getConnection(ResourceConnection::DEFAULT_CONNECTION);        $connection->insertOnDuplicate(            $this->resource->getTableName(self::LOG_TABLE_NAME),            [                'last_viewed_in_version' => $lastViewVersion,            ],            [                'last_viewed_in_version',            ]        );        return true;    }    /**     * Get log by the last view version.     *     * @return Log     */    public function get(): Log    {        return $this->logFactory->create(['data' => $this->loadLatestLogData()]);    }    /**     * Checks is log already exists.     *     * @return boolean     */    public function checkLogExists(): bool    {        $data = $this->logFactory->create(['data' => $this->loadLatestLogData()]);        $lastViewedVersion = $data->getLastViewVersion();        return isset($lastViewedVersion);    }    /**     * Load release notification viewer log data by last view version     *     * @return array     */    private function loadLatestLogData(): array    {        $connection = $this->resource->getConnection();        $select = $connection->select()            ->from(['log_table' => $this->resource->getTableName(self::LOG_TABLE_NAME)])            ->order('log_table.id desc')            ->limit(['count' => 1]);        $data = $connection->fetchRow($select);        if (!$data) {            $data = [];        }        return $data;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Logger_2796, Save (insert new or update existing) log.\n\n @param string $lastViewVersion\n @return bool\n, Save (insert new or update existing) log.,"    public function log(string $lastViewVersion): bool    {        /** @var \Magento\Framework\DB\Adapter\AdapterInterface $connection */        $connection = $this->resource->getConnection(ResourceConnection::DEFAULT_CONNECTION);        $connection->insertOnDuplicate(            $this->resource->getTableName(self::LOG_TABLE_NAME),            [                'last_viewed_in_version' => $lastViewVersion,            ],            [                'last_viewed_in_version',            ]        );        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Logger_2797, Get log by the last view version.\n\n @return Log\n, Get log by the last view version.,    public function get(): Log    {        return $this->logFactory->create(['data' => $this->loadLatestLogData()]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Logger_2799, Load release notification viewer log data by last view version\n\n @return array\n, Load release notification viewer log data by last view version,    private function loadLatestLogData(): array    {        $connection = $this->resource->getConnection();        $select = $connection->select()            ->from(['log_table' => $this->resource->getTableName(self::LOG_TABLE_NAME)])            ->order('log_table.id desc')            ->limit(['count' => 1]);        $data = $connection->fetchRow($select);        if (!$data) {            $data = [];        }        return $data;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_error_handler_2808, Set custom error handler.\n, Set custom error handler.,"function setCustomErrorHandler(){    set_error_handler(        function ($errNo, $errStr, $errFile, $errLine) {            if (error_reporting()) {                $errorNames = [                    E_ERROR => 'Error',                    E_WARNING => 'Warning',                    E_PARSE => 'Parse',                    E_NOTICE => 'Notice',                    E_CORE_ERROR => 'Core Error',                    E_CORE_WARNING => 'Core Warning',                    E_COMPILE_ERROR => 'Compile Error',                    E_COMPILE_WARNING => 'Compile Warning',                    E_USER_ERROR => 'User Error',                    E_USER_WARNING => 'User Warning',                    E_USER_NOTICE => 'User Notice',                    E_STRICT => 'Strict',                    E_RECOVERABLE_ERROR => 'Recoverable Error',                    E_DEPRECATED => 'Deprecated',                    E_USER_DEPRECATED => 'User Deprecated',                ];                $errName = isset($errorNames[$errNo]) ? $errorNames[$errNo] : """";                throw new \PHPUnit\Framework\Exception(                    sprintf(""%s: %s in %s:%s."", $errName, $errStr, $errFile, $errLine),                    $errNo                );            }        }    );}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_health_check_2873, Handle any fatal errors\n\n @return void\n, Handle any fatal errors,function fatalErrorHandler(){    $error = error_get_last();    if ($error !== null && $error['type'] === E_ERROR) {        http_response_code(500);    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processorFactory_2901, Error processor factory\n, Error processor factory,"class ProcessorFactory{    /**     * Create Processor     *     * @return Processor     */    public function createProcessor()    {        $objectManagerFactory = \Magento\Framework\App\Bootstrap::createObjectManagerFactory(BP, $_SERVER);        $objectManager = $objectManagerFactory->create($_SERVER);        $response = $objectManager->create(\Magento\Framework\App\Response\Http::class);        return new Processor($response);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processorFactory_2902, Create Processor\n\n @return Processor\n, Create Processor,"    public function createProcessor()    {        $objectManagerFactory = \Magento\Framework\App\Bootstrap::createObjectManagerFactory(BP, $_SERVER);        $objectManager = $objectManagerFactory->create($_SERVER);        $response = $objectManager->create(\Magento\Framework\App\Response\Http::class);        return new Processor($response);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2877, Process 404 error\n\n @return \\Magento\\Framework\\App\\Response\\Http\n, Process 404 error,    public function process404()    {        $this->pageTitle = 'Error 404: Not Found';        $this->_response->setHttpResponseCode(404);        $this->_response->setBody($this->_renderPage('404.phtml'));        return $this->_response;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2878, Process 503 error\n\n @return \\Magento\\Framework\\App\\Response\\Http\n, Process 503 error,    public function process503()    {        $this->pageTitle = 'Error 503: Service Unavailable';        $this->_response->setHttpResponseCode(503);        $this->_response->setBody($this->_renderPage('503.phtml'));        return $this->_response;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2889, Set report data\n\n @param array $reportData\n @return void\n, Set report data,    protected function _setReportData($reportData)    {        $this->reportData = $reportData;        if (!isset($reportData['url'])) {            $this->reportData['url'] = '';        } else {            $this->reportData['url'] = $this->getHostUrl() . $reportData['url'];        }        if (isset($this->reportData['script_name'])) {            $this->_scriptName = $this->reportData['script_name'];        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2890, Create report\n\n @param array $reportData\n @return string\n, Create report,"    public function saveReport(array $reportData): string    {        $this->reportId = $reportData['report_id'];        $this->_reportFile = $this->getReportPath(            $this->getReportDirNestingLevel($this->reportId),            $this->reportId        );        $reportDirName = dirname($this->_reportFile);        if (!file_exists($reportDirName)) {            @mkdir($reportDirName, 0777, true);        }        $this->_setReportData($reportData);        @file_put_contents($this->_reportFile, $this->serializer->serialize($reportData). PHP_EOL);        if (isset($reportData['skin']) && self::DEFAULT_SKIN != $reportData['skin']) {            $this->_setSkin($reportData['skin']);        }        $this->_setReportUrl();        return $this->reportUrl;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2891, Get report\n\n @param string $reportId\n @return void\n, Get report,"    public function loadReport($reportId)    {        try {            if (!$this->isReportIdValid($reportId)) {                throw new \RuntimeException(""Report Id is invalid"");            }            $reportFile = $this->findReportFile($reportId);            if (!is_readable($reportFile)) {                throw new \RuntimeException(""Report file cannot be read"");            }            $this->reportId = $reportId;            $this->_reportFile = $reportFile;            $this->_setReportData($this->serializer->unserialize(file_get_contents($this->_reportFile)));        } catch (\RuntimeException $e) {            $this->redirectToBaseUrl();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2892, Searches for the report file and returns the path to it\n\n @param string $reportId\n @return string\n @throws \\RuntimeException\n, Searches for the report file and returns the path to it,"    private function findReportFile(string $reportId): string    {        $reportFile = $this->getReportPath(            $this->getReportDirNestingLevel($reportId),            $reportId        );        if (file_exists($reportFile)) {            return $reportFile;        }        $maxReportDirNestingLevel = $this->getMaxReportDirNestingLevel($reportId);        for ($i = 0; $i <= $maxReportDirNestingLevel; $i++) {            $reportFile = $this->getReportPath($i, $reportId);            if (file_exists($reportFile)) {                return $reportFile;            }        }        throw new \RuntimeException(""Report file not found"");    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2894, Checks report id\n\n @param string $reportId\n @return bool\n, Checks report id,"    private function isReportIdValid(string $reportId): bool    {        return (bool)preg_match('/[a-fA-F0-9]{64}/', $reportId);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2898, Send report\n\n @return void\n @SuppressWarnings(PHPMD.CyclomaticComplexity)\n @SuppressWarnings(PHPMD.NPathComplexity)\n, Send report,"    public function sendReport()    {        $this->pageTitle = 'Error Submission Form';        $this->postData['firstName'] = (isset($_POST['firstname']))            ? trim($this->escaper->escapeHtml($_POST['firstname'])) : '';        $this->postData['lastName'] = (isset($_POST['lastname']))            ? trim($this->escaper->escapeHtml($_POST['lastname'])) : '';        $this->postData['email'] = (isset($_POST['email']))            ? trim($this->escaper->escapeHtml($_POST['email'])) : '';        $this->postData['telephone'] = (isset($_POST['telephone']))            ? trim($this->escaper->escapeHtml($_POST['telephone'])) : '';        $this->postData['comment'] = (isset($_POST['comment']))            ? trim($this->escaper->escapeHtml($_POST['comment'])) : '';        if (isset($_POST['submit'])) {            if ($this->_validate()) {                $msg  = ""URL: {$this->reportData['url']}\n""                    . ""IP Address: {$this->_getClientIp()}\n""                    . ""First Name: {$this->postData['firstName']}\n""                    . ""Last Name: {$this->postData['lastName']}\n""                    . ""Email Address: {$this->postData['email']}\n"";                if ($this->postData['telephone']) {                    $msg .= ""Telephone: {$this->postData['telephone']}\n"";                }                if ($this->postData['comment']) {                    $msg .= ""Comment: {$this->postData['comment']}\n"";                }                $subject = sprintf('%s [%s]', (string)$this->_config->subject, $this->reportId);                @mail((string)$this->_config->email_address, $subject, $msg);                $this->showSendForm = false;                $this->showSentMsg  = true;            } else {                $this->showErrorMsg = true;            }        } else {            $time = gmdate('Y-m-d H:i:s \G\M\T');            $msg = ""URL: {$this->reportData['url']}\n""                . ""IP Address: {$this->_getClientIp()}\n""                . ""Time: {$time}\n""                . ""Error:\n{$this->reportData[0]}\n\n""                . ""Trace:\n{$this->reportData[1]}"";            $subject = sprintf('%s [%s]', (string)$this->_config->subject, $this->reportId);            @mail((string)$this->_config->email_address, $subject, $msg);            if ($this->_config->trash == 'delete') {                @unlink($this->_reportFile);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ANOVA_3433, ANOVA (Analysis of Variance)\\n, ANOVA (Analysis of Variance),"class ANOVA{    /**     * One-way ANOVA     * Technique used to compare means of three or more samples     * (using the F distribution).     * https://en.wikipedia.org/wiki/One-way_analysis_of_variance     *     * Produces the following analysis of the data:     *     * ANOVA hypothesis test summary data     *     *           | SS | df | MS | F | P |     * Treatment |    |    |    |   |   |     * Error     |    |    |    |     * Total     |    |    |     *     *  where:     *   Treament is between groups     *   Error is within groups     *   SS = Sum of squares     *   df = Degrees of freedom     *   MS = Mean squares     *   F  = F statistic     *   P  = P value     *     * Data summary table     *     *       | N | Sum | Mean | SS | Variance | SD | SEM |     * 0     |   |     |      |    |          |    |     |     * 1     |   |     |      |    |          |    |     |     * ...   |   |     |      |    |          |    |     |     * Total |   |     |      |    |          |    |     |     *     *  where:     *   Each row is the summary for a sample, numbered from 0 to m - 1     *   m   = Number of samples     *   N   = Sample size     *   SS  = Sum of squares     *   SD  = Standard deviation     *   SEM = Standard error of the mean     *     * Calculations     *     * Sum of Squares     * SST (sum of squares total)     * ∑⟮xᵢ − μ⟯²     *  where:     *   xᵢ = each element of all samples     *   μ  = mean total of all elements of all samples     *     * SSB (sum of squares between - treatment)     * ∑n(x - μ)²     *  where:     *   n = sample size     *   x = sample mean     *   μ  = mean total of all elements of all samples     *     * SSW (sum of squares within - error)     * ∑∑⟮xᵢ − μ⟯²  Sum of sum of squared deviations of each sample     *  where:     *   xᵢ = each element of the sample     *   μ  = mean of the sample     *     * Degrees of Freedom     * dfT (degrees of freedom for the total)     * mn - 1     *     * dfB (degrees of freedom between - treatment)     * m - 1     *     * dfW (degrees of freedom within - error)     * m(n - 1)     *     *  where:     *   m = number of samples     *   n = number of elements in each sample     *     * Mean Squares     * MSB (Mean squares between - treatment)     * SSB / dfB     *     * MSW (Mean squares within - error)     * SSW / dfW     *     * Test Statistics     * F = MSB / MSW     * P = F distribution CDF above F with degrees of freedom dfB and dfW     *     * @param  array[] ...$samples Samples to analyze (at least 3 or more samples)     *     * @return array [     *                 ANOVA => [     *                   treatment => [SS, df, MS, F, P],     *                   error     => [SS, df, MS],     *                   total     => [SS, df],     *                 ],     *                 total_summary => [n, sum, mean, SS, variance, sd, sem],     *                 data_summary  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ]     *               ]     *     * @throws Exception\BadDataException if less than three samples, or if all samples don't have the same number of values     * @throws Exception\OutOfBoundsException     */    public static function oneWay(array ...$samples): array    {        // Must have at least three samples        $m = \count($samples);        if ($m < 3) {            throw new Exception\BadDataException('Must have at least three samples');        }        // All samples must have the same number of items        $n = \count($samples[0]);        for ($i = 1; $i < $m; $i++) {            if (\count($samples[$i]) !== $n) {                throw new Exception\BadDataException('All samples must have the same number of values');            }        }        // Summary data for each sample        $summary_data = [];        foreach ($samples as $i => $sample) {            $summary_data[$i]             = [];            $summary_data[$i]['n']        = $n;            $summary_data[$i]['sum']      = \array_sum($sample);            $summary_data[$i]['mean']     = Average::mean($sample);            $summary_data[$i]['SS']       = RandomVariable::sumOfSquares($sample);            $summary_data[$i]['variance'] = Descriptive::sampleVariance($sample);            $summary_data[$i]['sd']       = Descriptive::sd($sample);            $summary_data[$i]['sem']      = RandomVariable::standardErrorOfTheMean($sample);        }        // Totals summary        $all_elements = \array_reduce(            $samples,            function ($merged, $sample) {                return \array_merge($merged, $sample);            },            array()        );        $μ     = Average::mean($all_elements);        $total = [            'n'        => \count($all_elements),            'sum'      => \array_sum($all_elements),            'mean'     => $μ,            'SS'       => RandomVariable::sumOfSquares($all_elements),            'variance' => Descriptive::sampleVariance($all_elements),            'sd'       => Descriptive::sd($all_elements),            'sem'      => RandomVariable::standardErrorOfTheMean($all_elements),        ];        // ANOVA sum of squares        $SST = RandomVariable::sumOfSquaresDeviations($all_elements);        $SSB = \array_sum(\array_map(            function ($sample) use ($n, $μ) {                return $n * (Average::mean($sample) - $μ) ** 2;            },            $samples        ));        $SSW = \array_sum(\array_map(            'MathPHP\Statistics\RandomVariable::sumOfSquaresDeviations',            $samples        ));        // ANOVA degrees of freedom        $dfT = $m * $n - 1;        $dfB = $m - 1;        $dfW = $m * ($n - 1);        // ANOVA mean squares        $MSB = $SSB / $dfB;        $MSW = $SSW / $dfW;        // Test statistics        $F = $MSB / $MSW;        $fDist = new F($dfB, $dfW);        $P = $fDist->above($F);        // Return ANOVA report        return [            'ANOVA' => [                'treatment' => [                    'SS' => $SSB,                    'df' => $dfB,                    'MS' => $MSB,                    'F'  => $F,                    'P'  => $P,                ],                'error' => [                    'SS' => $SSW,                    'df' => $dfW,                    'MS' => $MSW,                ],                'total' => [                    'SS' => $SST,                    'df' => $dfT,                ],            ],            'total_summary' => $total,            'data_summary'  => $summary_data,        ];    }    /**     * Two-way ANOVA     * Examines the influence of two different categorical independent variables on     * one continuous dependent variable. The two-way ANOVA not only aims at assessing     * the main effect of each independent variable but also if there is any interaction     * between them (using the F distribution).     * https://en.wikipedia.org/wiki/Two-way_analysis_of_variance     *     * Produces the following analysis of the data:     *     * ANOVA hypothesis test summary data     *     *             | SS | df | MS | F | P |     * Factor A    |    |    |    |   |   |     * Factor B    |    |    |    |   |   |     * Interaction |    |    |    |   |   |     * Error       |    |    |    |     * Total       |    |    |     *     *  where:     *   Interaction = Factor A X Factor B working together     *   Error is within groups     *   SS = Sum of squares     *   df = Degrees of freedom     *   MS = Mean squares     *   F  = F statistic     *   P  = P value     *     * Data summary tables for:     *   Factor A     *   Factor B     *   Factor AB (Interaction)     *   Total     *     *       | N | Sum | Mean | SS | Variance | SD | SEM |     * 0     |   |     |      |    |          |    |     |     * 1     |   |     |      |    |          |    |     |     * ...   |   |     |      |    |          |    |     |     * Total |   |     |      |    |          |    |     |     *     *  where:     *   Each row is the summary for a sample, numbered from 0 to m - 1     *   m   = Number of samples     *   N   = Sample size     *   SS  = Sum of squares     *   SD  = Standard deviation     *   SEM = Standard error of the mean     *     * Calculations     *     * Sum of Squares     * SST (sum of squares total)     * ∑⟮xᵢ − μ⟯²     *  where:     *   xᵢ = each element of all samples     *   μ  = mean total of all elements of all samples     *     * SSA, SSB (sum of squares for each factor A and B)     * ∑n(x - μ)²     *  where:     *   n = sample size     *   x = sample mean     *   μ  = mean total of all elements of all samples     *     * SSW (sum of squares within - error)     * ∑∑⟮x − μ⟯²  Sum of sum of squared deviations of each sample     *  where:     *   x = mean of each AB     *   μ = mean of the sample     *     * SSAB (sum of squares AB - interaction)     * SSAB = SST - SSA - SSB - SSW;     *     * Degrees of Freedom     * dfT (degrees of freedom for the total)     * n - 1     *     * dfA (degrees of freedom factor A)     * r - 1     *     * dfB (degrees of freedom factor B)     * c - 1     *     * dfAB (degrees of freedom factor AB - interaction)     * (r - 1)(c - 1)     *     * dfW (degrees of freedom within - error)     * n - rc     *     *  where:     *   n = number of samples     *   r = number of rows (number of factor As)     *   c = number of columns (number of factor Bs)     *     * Mean Squares     * MSA (Mean squares factor A)     * SSA / dfA     *     * MSB (Mean squares factor B)     * SSB / dfB     *     * MSAB (Mean squares factor AB - interaction)     * SSAB / dfAB     *     * MSW (Mean squares within - error)     * SSW / dfW     *     * F Test Statistics     * FA  = MSA / MSW     * FB  = MSB / MSW     * FAB = MSAB / MSW     *     * P values     * PA  = F distribution CDF above FA with degrees of freedom dfA and dfW     * PB  = F distribution CDF above FB with degrees of freedom dfA and dfW     * PAB = F distribution CDF above FAB with degrees of freedom dfAB and dfW     *     * Example input data for ...$data parameter:     *             | Factor B₁ | Factor B₂ | ⋯     *   Factor A₁ |  4, 6, 8  |  6, 6, 9  | ⋯     *   Factor A₂ |  4, 8, 9  | 7, 10, 13 | ⋯     *      ⋮           ⋮           ⋮         ⋮     * @param  array[] ...$data Samples to analyze [     *               // Factor A₁     *               [     *                   [4, 6, 8] // Factor B₁     *                   [6, 6, 9] // Factor B₂     *                       ⋮     *               ],     *               // Factor A₂     *               [     *                   [4, 8, 9]   // Factor B₁     *                   [7, 10, 13] // Factor B₂     *                       ⋮     *               ],     *               ...     *         ]     *     * @return array [     *                 ANOVA => [     *                   factorA  => [SS, df, MS, F, P],     *                   factorB  => [SS, df, MS, F, P],     *                   factorAB => [SS, df, MS, F, P],     *                   error    => [SS, df, MS],     *                   total    => [SS, df],     *                 ],     *                 total_summary => [n, sum, mean, SS, variance, sd, sem],     *                 summary_factorA  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ],     *                 summary_factorB  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ],     *                 summary_factorAB  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ]     *               ]     * @throws Exception\BadDataException if less than two A factors, or if B factors or values have different number elements     * @throws Exception\OutOfBoundsException     */    public static function twoWay(array ...$data): array    {        // Must have at least two rows (two types of factor A)        $r = \count($data);        if ($r < 2) {            throw new Exception\BadDataException('Must have at least two rows (two types of factor A)');        }        // All samples must have the same number the second factor B        $c = \count($data[0]);        for ($i = 1; $i < $r; $i++) {            if (\count($data[$i]) !== $c) {                throw new Exception\BadDataException('All samples must have the same number of the second factor B');            }        }        // Each AB factor interaction must have the same number of values        $v = \count($data[0][0]);        for ($i = 0; $i < $r; $i++) {            for ($j = 0; $j < $c; $j++) {                if (\count($data[$i][$j]) !== $v) {                    throw new Exception\BadDataException('Each AB factor interaction must have the same number of values');                }            }        }        // Aggregates for all elements, rows (factor A), and columns (factor B)        $all_elements = [];        $A_elements   = [];        $B_elements   = [];        // Summaries for factor A, factor B, and AB        $summary_A     = [];        $summary_B     = [];        $summary_AB    = [];        // Summary data for each AB        // And aggregate all elements and elements for factor A        foreach ($data as $A => $Bs) {            $A_elements[$A] = [];            foreach ($Bs as $B => $values) {                // Aggregates                $all_elements   = \array_merge($all_elements, $values);                $A_elements[$A] = \array_merge($A_elements[$A], $values);                // AB summary                $summary_AB[$A][$B]             = [];                $summary_AB[$A][$B]['n']        = $c;                $summary_AB[$A][$B]['sum']      = \array_sum($values);                $summary_AB[$A][$B]['mean']     = Average::mean($values);                $summary_AB[$A][$B]['SS']       = RandomVariable::sumOfSquares($values);                $summary_AB[$A][$B]['variance'] = Descriptive::sampleVariance($values);                $summary_AB[$A][$B]['sd']       = Descriptive::sd($values);                $summary_AB[$A][$B]['sem']      = RandomVariable::standardErrorOfTheMean($values);            }        }        // Aggregate elements for factor B        for ($B = 0; $B < $c; $B++) {            $B_elements[$B] = [];            foreach ($data as $factor1s) {                $B_elements[$B] = \array_merge($B_elements[$B], $factor1s[$B]);            }        }        // Factor A summary        foreach ($A_elements as $A => $elements) {            $summary_A[$A]             = [];            $summary_A[$A]['n']        = \count($elements);            $summary_A[$A]['sum']      = \array_sum($elements);            $summary_A[$A]['mean']     = Average::mean($elements);            $summary_A[$A]['SS']       = RandomVariable::sumOfSquares($elements);            $summary_A[$A]['variance'] = Descriptive::sampleVariance($elements);            $summary_A[$A]['sd']       = Descriptive::sd($elements);            $summary_A[$A]['sem']      = RandomVariable::standardErrorOfTheMean($elements);        }        // Factor B summary        foreach ($B_elements as $B => $elements) {            $summary_B[$B]             = [];            $summary_B[$B]['n']        = \count($elements);            $summary_B[$B]['sum']      = \array_sum($elements);            $summary_B[$B]['mean']     = Average::mean($elements);            $summary_B[$B]['SS']       = RandomVariable::sumOfSquares($elements);            $summary_B[$B]['variance'] = Descriptive::sampleVariance($elements);            $summary_B[$B]['sd']       = Descriptive::sd($elements);            $summary_B[$B]['sem']      = RandomVariable::standardErrorOfTheMean($elements);        }        // Totals summary        $μ             = Average::mean($all_elements);        $summary_total = [            'n'        => \count($all_elements),            'sum'      => \array_sum($all_elements),            'mean'     => $μ,            'SS'       => RandomVariable::sumOfSquares($all_elements),            'variance' => Descriptive::sampleVariance($all_elements),            'sd'       => Descriptive::sd($all_elements),            'sem'      => RandomVariable::standardErrorOfTheMean($all_elements),        ];        // Sum of squares factor A        $SSA = \array_sum(\array_map(            function ($f1) use ($μ) {                return $f1['n'] * ($f1['mean'] - $μ) ** 2;            },            $summary_A        ));        // Sum of squares factor B        $SSB = \array_sum(\array_map(            function ($B) use ($μ) {                return $B['n'] * ($B['mean'] - $μ) ** 2;            },            $summary_B        ));        // Sum of squares within (error)        $SSW = 0;        foreach ($data as $A => $Bs) {            foreach ($Bs as $B => $values) {                foreach ($values as $value) {                    $SSW += ($value - $summary_AB[$A][$B]['mean']) ** 2;                }            }        }        // Sum of squares total        $SST = 0;        foreach ($data as $A => $Bs) {            foreach ($Bs as $B => $values) {                foreach ($values as $value) {                    $SST += ($value - $μ) ** 2;                }            }        }        // Sum of squares AB interaction        $SSAB = $SST - $SSA - $SSB - $SSW;        // Degrees of freedom        $dfA  = $r - 1;        $dfB  = $c - 1;        $dfAB = ($r - 1) * ($c - 1);        $dfW  = $summary_total['n'] - ($r * $c);        $dfT  = $summary_total['n'] - 1;        // Mean squares        $MSA  = $SSA / $dfA;        $MSB  = $SSB / $dfB;        $MSAB = $SSAB / $dfAB;        $MSW  = $SSW / $dfW;        // F test statistics        $FA  = $MSA / $MSW;        $FB  = $MSB / $MSW;        $FAB = $MSAB / $MSW;        // P values        $fDist1 = new F($dfA, $dfW);        $fDist2 = new F($dfB, $dfW);        $fDist3 = new F($dfAB, $dfW);        $PA  = $fDist1->above($FA);        $PB  = $fDist2->above($FB);        $PAB = $fDist3->above($FAB);        // Return ANOVA report        return [            'ANOVA' => [                'factorA' => [                    'SS' => $SSA,                    'df' => $dfA,                    'MS' => $MSA,                    'F'  => $FA,                    'P'  => $PA,                ],                'factorB' => [                    'SS' => $SSB,                    'df' => $dfB,                    'MS' => $MSB,                    'F'  => $FB,                    'P'  => $PB,                ],                'interaction' => [                    'SS' => $SSAB,                    'df' => $dfAB,                    'MS' => $MSAB,                    'F'  => $FAB,                    'P'  => $PAB,                ],                'error' => [                    'SS' => $SSW,                    'df' => $dfW,                    'MS' => $MSW,                ],                'total' => [                    'SS' => $SST,                    'df' => $dfT,                ],            ],            'total_summary'       => $summary_total,            'summary_factorA'     => $summary_A,            'summary_factorB'     => $summary_B,            'summary_interaction' => $summary_AB,        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Advanced_3369," Fibonacci numbers\n Every number is the sum of the two preceding ones.\n https://en.wikipedia.org/wiki/Fibonacci_number\n\n F₀ = 0\n F₁ = 1\n Fᵢ = Fᵢ₋₁ + Fᵢ₋₂\n\n Example:\n  n = 6\n  Sequence:    0, 1, 1, 2, 3, 5\n  Array index: 0, 1, 2, 3, 4, 5\n\n @param  int $n How many numbers in the sequence\n\n @return array Indexed from 0\n", Fibonacci numbers,"    public static function fibonacci(int $n): array    {        $fibonacci = [];        // Bad input; return empty list        if ($n <= 0) {            return $fibonacci;        }        // Base case (n = 1): F₀ = 0        $fibonacci[] = 0;        if ($n === 1) {            return $fibonacci;        }        // Base case (n = 2): F₀ = 0, F₁ = 1        $fibonacci[] = 1;        if ($n === 2) {            return $fibonacci;        }        // Standard iterative case (n > 1): Fᵢ = Fᵢ₋₁ + Fᵢ₋₂        for ($i = 2; $i < $n; $i++) {            $fibonacci[] = $fibonacci[$i - 1] + $fibonacci[$i - 2];        }        return $fibonacci;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Advanced_3370," Lucas numbers\n Every number is the sum of its two immediate previous terms.\n Similar to Fibonacci numbers except the base cases differ.\n https://en.wikipedia.org/wiki/Lucas_number\n\n L₀ = 2\n L₁ = 1\n Lᵢ = Lᵢ₋₁ + Lᵢ₋₂\n\n Example:\n  n = 6\n  Sequence:    2, 1, 3, 4, 7, 11\n  Array index: 0, 1, 2, 3, 4, 5\n\n @param  int $n How many numbers in the sequence\n\n @return array Indexed from 0\n", Lucas numbers,"    public static function lucasNumber(int $n): array    {        $lucas = [];        // Bad input; return empty list        if ($n <= 0) {            return $lucas;        }        // Base case (n = 1): L₀ = 2        $lucas[] = 2;        if ($n === 1) {            return $lucas;        }        // Base case (n = 2): , L₀ = 2L₁ = 1        $lucas[] = 1;        if ($n === 2) {            return $lucas;        }        // Standard iterative case: Lᵢ = Lᵢ₋₁ + Lᵢ₋₂        for ($i = 2; $i < $n; $i++) {            $lucas[$i] = $lucas[$i - 1] + $lucas[$i - 2];        }        return $lucas;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Advanced_3371," Pell numbers\n The denominators of the closest rational approximations to the square root of 2.\n https://en.wikipedia.org/wiki/Pell_number\n\n P₀ = 0\n P₁ = 1\n Pᵢ = 2Pᵢ₋₁ + Pᵢ₋₂\n\n Example:\n  n = 6\n  Sequence:    0, 1, 2, 5, 12, 29\n  Array index: 0, 1, 2, 3, 4,  5\n\n @param  int $n How many numbers in the sequence\n\n @return array Indexed from 0\n", Pell numbers,"    public static function pellNumber(int $n): array    {        $pell = [];        // Bad input; return empty list        if ($n <= 0) {            return $pell;        }        // Base case (n = 1): P₀ = 0        $pell[] = 0;        if ($n === 1) {            return $pell;        }        // Base case (n = 2): P₀ = 0, P₁ = 1        $pell[] = 1;        if ($n === 2) {            return $pell;        }        // Standard iterative case: Pᵢ = 2Pᵢ₋₁ + Pᵢ₋₂        for ($i = 2; $i < $n; $i++) {            $pell[$i] = 2 * $pell[$i - 1] + $pell[$i - 2];        }        return $pell;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Advanced_3374," Hexagonal numbers\\n Figurate numbers that represent hexagons.\\n https://en.wikipedia.org/wiki/Hexagonal_number\\n\\n      2n × (2n - 1)\\n hn = -------------\\n           2\\n\\n Example:\\n  n = 6\\n  Sequence:    1, 6, 15, 28, 45, 66\\n  Array index: 1, 2, 3,  4,  5,  6\\n\\n @param  int $n How many numbers in the sequence\\n\\n @return array Indexed from 1\\n", Hexagonal numbers,    public static function hexagonalNumber(int $n): array    {        $hexagonal = [];        // Bad input; return empty list        if ($n <= 0) {            return $hexagonal;        }        // Standard case for hn: (2n × (2n - 1)) / 2        for ($i = 1; $i <= $n; $i++) {            $hexagonal[$i] = ((2 * $i) * (2 * $i - 1)) / 2;        }        return $hexagonal;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Advanced_3376," Look-and-say sequence (describe the previous term!)\\n (Sequence A005150 in the OEIS)\\n\\n 1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, ...\\n\\n To generate a member of the sequence from the previous member,\\n read off the digits of the previous member, counting the number of\\n digits in groups of the same digit.\\n\\n 1 is read off as ""one 1"" or 11.\\n 11 is read off as ""two 1s"" or 21.\\n 21 is read off as ""one 2, then one 1"" or 1211.\\n 1211 is read off as ""one 1, one 2, then two 1s"" or 111221.\\n 111221 is read off as ""three 1s, two 2s, then one 1"" or 312211.\\n\\n https://en.wikipedia.org/wiki/Look-and-say_sequence\\n https://oeis.org/A005150\\n\\n Example:\\n  n = 6\\n  Sequence:    1, 11, 21, 1211, 111221, 312211\\n  Array index: 1, 2,  3,  4,    5,      6\\n\\n @param  int $n How many numbers in the sequence\\n\\n @return array of strings indexed from 1\\n", Look-and-say sequence (describe the previous term!),"    public static function lookAndSay(int $n): array    {        if ($n <= 0) {            return [];        }        // Initialize        $list     = [1 => '1'];        $previous = '1';        // Base case        if ($n === 1) {            return $list;        }        for ($i = 2; $i <= $n; $i++) {            $sequence = """";            $count    = 1;            $len      = \strlen($previous);            for ($j = 1; $j < $len; $j++) {                if (\substr($previous, $j, 1) === \substr($previous, $j - 1, 1)) {                    $count++;                } else {                    $sequence .= $count . \substr($previous, $j - 1, 1);                    $count = 1;                }            }            $sequence .= $count . \substr($previous, $j - 1, 1);            $previous = $sequence;            $list[$i] = $sequence;        }        return $list;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Advanced_3377," Lazy caterer's sequence (central polygonal numbers)\\n Describes the maximum number of pieces of a circle that can be made with\\n a given number of straight cuts.\\n\\n https://en.wikipedia.org/wiki/Lazy_caterer%27s_sequence\\n https://oeis.org/A000124\\n\\n     n² + n + 2\\n p = ----------\\n          2\\n\\n Using binomial coefficients:\\n\\n         (n + 1)   (n)   (n)   (n)\\n p = 1 + (     ) = ( ) + ( ) + ( )\\n         (  2 )    (0)   (1)   (2)\\n\\n Example:\\n  n = 6\\n  Sequence:    1, 2, 4, 7, 11, 16, 22\\n  Array index: 0, 1, 2, 3, 4,  5,  6\\n\\n @param int $n How many numbers in the sequence\\n\\n @return array\\n", Lazy caterer's sequence (central polygonal numbers),    public static function lazyCaterers(int $n): array    {        if ($n < 0) {            return [];        }        $p = [];        for ($i = 0; $i < $n; $i++) {            $p[] = ($i ** 2 + $i + 2) / 2;        }        return $p;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Advanced_3379," Perfect numbers\n @see https://oeis.org/A000396\n\n Example\n  n = 5\n  Sequence:    6, 28, 496, 8128, 33550336\n  Array index: 0, 1,  2,   3,    4\n\n @param  int $n\n\n @return array\n\n @throws OutOfBoundsException\n", Perfect numbers,"    public static function perfectNumbers(int $n): array    {        if ($n <= 0) {            return [];        }        if ($n <= 10) {            return \array_slice(self::PERFECT_NUMBERS, 0, $n);        }        throw new OutOfBoundsException(""Perfect numbers beyond the tenth are too large to compute"");    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_AlgebraTest_3651," Test data created with Python numpy.roots([a, b])\n @return array (a, b, root)\n"," Test data created with Python numpy.roots([a, b])","    public function dataProviderForLinear(): array    {        return [            [-1, 0, 0],            [1, 0, 0],            [5, 0, 0],            [1, 1, -1],            [-1, 1, 1],            [1, -1, 1],            [-1, -1, -1],            [1, 2, -2],            [-1, 2, 2],            [1, -2, 2],            [-1, -2, -2],            [2, 4, -2],            [-2, 4, 2],            [2, -4, 2],            [-2, -4, -2],            [0.5, 1, -2],            [-0.5, 1, 2],            [0.5, -1, 2],            [-0.5, -1, -2],            [1, 0.5, -0.5],            [-1, 0.5, 0.5],            [1, -0.5, 0.5],            [-1, -0.5, -0.5],            [1, -3, 3],            [35, 8, -0.22857143],            [8, 35, -4.375],            [82376, 984398, -11.95005827],            [3.2, 2, -0.625],            [6.2, 8.7, -1.40322581],            [8.7, 6.2, -0.71264368],            [0.001, 3, -3000],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_AlgebraTest_3655, Many data examples from: http://www.themathpage.com/alg/quadratic-equations.htm\n, Many data examples from: http://www.themathpage.com/alg/quadratic-equations.htm,"    public function dataProviderForQuadratic(): array    {        return [            [2, 4, -4, [-1 - \sqrt(3), -1 + \sqrt(3)]],            [1, -3, -4, [-1, 4]],            [1, 1, -4, [-2.56155281280883, 1.56155281280883]],            [1, 0, -4, [-2, 2]],            [6, 11, -35, [-7 / 2, 5 / 3]],            [1, 0, -48, [-4 * \sqrt(3), 4 * \sqrt(3)]],            [1, -7, 0, [0, 7]],            [5, 6, 1, [-1, -0.2]],            [1, 2, -8, [-4, 2]],            [1, 2, -3, [-3, 1]],            [1, -12, 36, [6, 6]],            [2, 9, -5, [-5, 1 / 2]],            [1, -3, 2, [1, 2]],            [1, 7, 12, [-4, -3]],            [1, 3, -10, [-5, 2]],            [1, -1, -30, [-5, 6]],            [2, 7, 3, [-3, -1 / 2]],            [3, 1, -2, [-1, 2 / 3]],            [1, 12, 36, [-6, -6]],            [1, -2, 1, [1, 1]],            [1, -5, 0, [0, 5]],            [1, 1, 0, [-1, 0]],            [3, 4, 0, [-4 / 3, 0]],            [2, -1, 0, [0, 1 / 2]],            [1, 0, -3, [-sqrt(3), \sqrt(3)]],            [1, 0, -25, [-5, 5]],            [1, 0, -10, [-sqrt(10), \sqrt(10)]],            [1, -5, 6, [2, 3]],            [1, -8, 12, [2, 6]],            [3, 1, -10, [-2, 5 / 3]],            [2, -1, 0, [0, 1 / 2]],            [3, 5 / 2, -3, [-3 / 2, 2 / 3]],            [5, 11 / 2, -3, [-3 / 2, 2 / 5]],            [5, -11 / 3, -4, [-3 / 5, 4 / 3]],            [1, 1, -20, [-5, 4]],            [1, -3, -18, [-3, 6]],            [2, -5, -3, [-1 / 2, 3]],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_AlgebraTest_3665, Calculator used to generate and validate examples: http://www.1728.org/cubic.htm\\n Some examples from: http://www.mash.dept.shef.ac.uk/Resources/web-cubicequations-john.pdf\\n Some examples from: https://trans4mind.com/personal_development/mathematics/polynomials/cardanoMethodExamples.htm\\n @return array\\n, Calculator used to generate and validate examples: http://www.1728.org/cubic.htm,"    public function dataProviderForCubic(): array    {        return [            // D < 0: Three real roots. Nice even numbers.            [1, 0, 0, 0, [0, 0, 0]],            [1, -6, 11, -6, [3, 1, 2]],            [1, -5, -2, 24, [4, -2, 3]],            [1, 0, -7, -6, [3, -2, -1]],            [1, -4, -9, 36, [4, -3, 3]],            [1, 3, -6, -8, [2, -4, -1]],            [1, 2, -21, 18, [3, -6, 1]],            [1, -7, 4, 12, [6, -1, 2]],            [1, 9, 26, 24, [-2, -4, -3]],            [1, 0, -19, -30, [5, -3, -2]],            [1, 2, -25, -50, [5, -5, -2]],            [1, 6, 11, 6, [-1, -3, -2]],            [1, 4, 1, -6, [1, -3, -2]],            [2, 9, 3, -4, [0.5, -4, -1]],            [2, -4, -22, 24, [4, -3, 1]],            [2, 3, -11, -6, [2, -3, -1 / 2]],            [2, -9, 1, 12, [4, -1, 1.5]],            [2, -3, -5, 6, [2, -1.5, 1]],            [3, -1, -10, 8, [4 / 3, -2, 1]],            [6, -5, -17, 6, [2, -1.5, 1 / 3]],            [45, 24, -7, -2, [1 / 3, -2 / 3, -0.2]],            [-1, -1, 22, 40, [5, -4, -2]],            [-1, 0, 19, -30, [3, -5, 2]],            [-1, 6, -5, -12, [4, -1, 3]],            // D < 0: Three real roots. Floats.            [1, 6, 3, -5, [0.66966384064222, -5.24655136455856, -1.42311247608366]],            [1, 4, 1, -5, [0.9122291784844, -3.198691243516, -1.7135379349684]],            [1, -4, -6, 5, [5, -1.61803398874989, 0.61803398874989]],            [1, -3, -1, 1, [3.21431974337754, -0.67513087056665, 0.46081112718911]],            [1, -2, -6, 4, [3.41421356237309, -2, 0.58578643762691]],            [1, 1, -16, 0, [3.53112887414927, -4.53112887414927, 0]],            [2, -3, -22, 24, [3.62221312679243, -3.16796177749228,  1.04574865069985]],            [2, -2, -22, 24, [3.2488979294409, -3.35109344639606,  1.10219551695516]],            [1000, -1254, -496, 191, [1.49979930548345, -0.50033136443491, 0.25453205895145]],            // D = 0: All real roots--at least two are equal. Nice even numbers.            [1, -5, 8, -4, [2, 1, 2]],            [1, -3, 3, -1, [1, 1, 1]],            [1, 3, 3, 1, [-1, -1, -1]],            [1, 2, -20, 24, [2, -6, 2]],            [64, -48, 12, -1, [0.25, 0.25, 0.25]],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Algebra_2488," Greatest common divisor - recursive Euclid's algorithm\\n The largest positive integer that divides the numbers without a remainder.\\n For example, the GCD of 8 and 12 is 4.\\n https://en.wikipedia.org/wiki/Greatest_common_divisor\\n\\n gcd(a, 0) = a\\n gcd(a, b) = gcd(b, a mod b)\\n\\n @param  int $a\\n @param  int $b\\n\\n @return int\\n", Greatest common divisor - recursive Euclid's algorithm,"    public static function gcd(int $a, int $b): int    {        // Base cases        if ($a == 0) {            return $b;        }        if ($b == 0) {            return $a;        }        // Recursive case        return Algebra::gcd($b, $a % $b);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Algebra_2491," Get factors of an integer\\n The decomposition of a composite number into a product of smaller integers.\\n https://en.wikipedia.org/wiki/Integer_factorization\\n\\n Algorithm:\\n - special case: if x is 0, return [\\\\INF]\\n - let x be |x|\\n - push on 1 as a factor\\n - prime factorize x\\n - build sets of prime powers from primes\\n - push on the product of each set\\n\\n @param  int $x\\n @return array of factors\\n\\n @throws Exception\\\\OutOfBoundsException if n is < 1\\n", Get factors of an integer,"    public static function factors(int $x): array    {        // 0 has infinite factors        if ($x === 0) {            return [\INF];        }        $x       = \abs($x);        $factors = [1];        // Prime factorize x        $primes = Integer::primeFactorization($x);        // Prime powers from primes        $sets       = [];        $current    = [];        $map        = [];        $exponents  = \array_count_values($primes);        $limit      = 1;        $count      = 0;        foreach ($exponents as $prime => $exponent) {            $map[]        = $prime;            $sets[$prime] = [1, $prime];            $primePower   = $prime;            for ($n = 2; $n <= $exponent; ++$n) {                $primePower *= $prime;                $sets[$prime][$n] = $primePower;            }            $limit *= \count($sets[$prime]);            if ($count === 0) { // Skip 1 on the first prime                $current[] = \next($sets[$prime]);            } else {                $current[] = 1;            }            ++$count;        }        // Multiply distinct prime powers together        for ($i = 1; $i < $limit; ++$i) {            $factors[] = \array_product($current);            for ($i2 = 0; $i2 < $count; ++$i2) {                $current[$i2] = \next($sets[$map[$i2]]);                if ($current[$i2] !== false) {                    break;                }                $current[$i2] = \reset($sets[$map[$i2]]);            }        }        \sort($factors);        return $factors;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Algebra_2492," Linear equation of one variable\n An equation having the form: ax + b = 0\n where x represents an unknown, or the root of the equation, and a and b represent known numbers.\n https://en.wikipedia.org/wiki/Linear_equation#One_variable\n\n ax + b = 0\n\n     -b\n x = --\n      a\n\n No root exists for a = 0, as a(0) + b = b\n\n @param float $a a of ax + b = 0\n @param float $b b of ax + b = 0\n\n @return float|null Root of the linear equation: x = -b / a\n", Linear equation of one variable,"    public static function linear(float $a, float $b): ?float    {        if ($a == 0) {            return null;        }        return -$b / $a;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2546, Create a random ArbitraryInteger\n\n @param int $bytes\n\n @return Number\\ArbitraryInteger\n\n @throws Exception\\BadParameterException\n @throws Exception\\IncorrectTypeException\n, Create a random ArbitraryInteger,"    public static function rand(int $bytes): Number\ArbitraryInteger    {        if ($bytes <= 0) {            throw new Exception\BadParameterException('Cannot produce a random number with zero or negative bytes.');        }        return Number\ArbitraryInteger::fromBinary(\random_bytes($bytes), \mt_rand(0, 1) === 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2894, Construct from binary factory method\n\n @param  string $value\n @param  bool   $positive\n\n @return ArbitraryInteger\n\n @throws Exception\\BadParameterException\n @throws Exception\\IncorrectTypeException\n, Construct from binary factory method,"    public static function fromBinary(string $value, bool $positive): ArbitraryInteger    {        $result = new ArbitraryInteger(0);        $result->setVariables($value, $positive);        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2895, Zero value: 0\\n\\n @return ArbitraryInteger\\n, Zero value: 0,    public static function createZeroValue(): ObjectArithmetic    {        return new ArbitraryInteger(0);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2896, Directly set the class properties\\n\\n @param string $value\\n @param bool   $positive\\n, Directly set the class properties,"    protected function setVariables(string $value, bool $positive)    {        $value = \ltrim($value, \chr(0));        if ($value == '') {            $value = \chr(0);        }        $this->base256  = $value;        $this->isPositive = $positive;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2898, Convert ArbitraryInteger to a float\n\n @return float\n, Convert ArbitraryInteger to a float,    public function toFloat(): float    {        $number      = \str_split(\strrev($this->base256));        $place_value = 1;        $float       = \ord($number[0]);        unset($number[0]);        foreach ($number as $digit) {            $place_value *= 256;            $float       += \ord($digit) * $place_value;        }        return \floatval($float) * ($this->isPositive ? 1 : -1);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2899, Return the number as a binary string\n\n @return string\n, Return the number as a binary string,    public function toBinary(): string    {        return $this->base256;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2901, is the number positive?\n @return bool\n, is the number positive?,    public function isPositive(): bool    {        return $this->isPositive;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2903, Integer Square Root\\n\\n Calculate the largest integer less than the square root of an integer.\\n https://en.wikipedia.org/wiki/Integer_square_root\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\OutOfBoundsException\\n, Integer Square Root,"    public function isqrt(): ArbitraryInteger    {        if ($this->lessThan(0)) {            throw new Exception\OutOfBoundsException('isqrt only works on numbers ≥ 0');        }        // √0 = 0 edge case        if ($this->equals(0)) {            return new static(0);        }        $length = \strlen($this->base256);        // Start close to the value, at a number around half the digits.        $X        = self::fromBinary(\substr($this->base256, 0, \intdiv($length, 2) + 1), true);        $lastX    = $X;        $converge = false;        while (!$converge) {            $NX = $this->intdiv($X);            $X  = $X->add($NX)->intdiv(2);            if ($X->equals($lastX) || $X->equals($lastX->add(1))) {                $converge = true;            } else {                $lastX = $X;            }        }        return $lastX;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2904, Absolute Value\n\n @return ArbitraryInteger\n\n @throws Exception\\BadParameterException\n @throws Exception\\IncorrectTypeException\n, Absolute Value,"    public function abs(): ArbitraryInteger    {        return self::fromBinary($this->base256, true);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2909, Integer division - Returns the integer quotient from integer division\\n\\n @param int|string|ArbitraryInteger $divisor\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n, Integer division - Returns the integer quotient from integer division,"    public function intdiv($divisor): ArbitraryInteger    {        [$int, $mod] = $this->fullIntdiv($divisor);        return $int;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2914, Test for equality\\n\\n Two ArbitraryIntegers are equal IFF their $base256 strings\\n are identical and their signs are identical.\\n\\n @param int|string|ArbitraryInteger $int\\n\\n @return bool\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n, Test for equality,    public function equals($int): bool    {        $int = self::create($int);        return $this->base256 == $int->toBinary() && $this->isPositive == $int->isPositive();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2915, Greater Than\n\n Test if one ArbitraryInteger is greater than another\n\n @param int|string|ArbitraryInteger $int\n\n @return bool\n\n @throws Exception\\BadParameterException\n @throws Exception\\IncorrectTypeException\n, Greater Than,    public function greaterThan($int): bool    {        $int = self::create($int);        return $int->lessThan($this);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2916, Less Than\n\n Test if one ArbitraryInteger is less than another\n\n @param int|string|ArbitraryInteger $int\n\n @return bool\n\n @throws Exception\\BadParameterException\n @throws Exception\\IncorrectTypeException\n, Less Than,"    public function lessThan($int): bool    {        $int          = self::create($int);        $base_256     = $this->base256;        $int_256      = $int->toBinary();        $my_len       = \strlen($base_256);        $int_len      = \strlen($int_256);        $my_positive  = $this->isPositive;        $int_positive = $int->isPositive();        // Check if signs differ        if ($my_positive && !$int_positive) {            return false;        }        if ($int_positive && !$my_positive) {            return true;        }        // If one number has more digits, its absolute value is larger.        if ($my_len > $int_len) {            return !$my_positive;        } elseif ($int_len > $my_len) {            return $my_positive;        } else {            // Test each digit from most significant to least.            for ($i = 0; $i < $my_len; $i++) {                if ($base_256[$i] !== $int_256[$i]) {                    $test = \ord($base_256[$i]) < \ord($int_256[$i]);                    return $my_positive ? $test : !$test;                }            }            // Must be equal            return false;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArithmeticTest_3711," Test data generated with R: a %% n\\n @return array (dividend, divisor, expected)\\n", Test data generated with R: a %% n,"    public function dataProviderForModuloNegativeDividend(): array    {        return [            [-0, 1, 0],            [-0, 2, 0],            [-1, 1, 0],            [-1, 2, 1],            [-2, 1, 0],            [-2, 2, 0],            [-2, 3, 1],            [-3, 2, 1],            [-5, 3, 1],            [-10, 1, 0],            [-10, 2, 0],            [-10, 3, 2],            [-10, 4, 2],            [-10, 5, 0],            [-10, 6, 2],            [-10, 7, 4],            [-10, 8, 6],            [-10, 9, 8],            [-10, 10, 0],            [-12, 5, 3],            [-18, 3, 0],            [-100, 3, 2],            [-100, 7, 5],            [-340, 60, 20],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Arithmetic_2494," Calculate any nᵗʰ root of a value: ⁿ√x\n Equivalent to x¹/ⁿ\n\n nᵗʰ root of a number x is a number r which, when raised to the power n yields x:\n\n Use the the PHP pow function if it is an even root or if $x is positive.\n If $x is negative and it is an odd root, we can extend the native function.\n\n @param  float $x value to find the root of\n @param  int   $nᵗʰ root (magnitude of the root - 2 for square root, 3 for cube root, etc.)\n\n @return float\n", Calculate any nᵗʰ root of a value: ⁿ√x,"    public static function root(float $x, int $nᵗʰ): float    {        if ($x >= 0 || $nᵗʰ % 2 === 0) {            return \pow($x, 1 / $nᵗʰ);        }        return - \pow(\abs($x), 1 / $nᵗʰ);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Arithmetic_2547, Arithmetic of functions. These functions return functions themselves.\\n, Arithmetic of functions. These functions return functions themselves.,"class Arithmetic{    /**     * Adds any number of single variable (callback) functions {f(x)}. Returns     * the sum as a callback function.     *     * @param callable ...$args Two or more single-variable callback functions     *     * @return callable         Sum of the input functions     */    public static function add(callable ...$args): callable    {        $sum = function ($x, ...$args) {            $function = 0;            foreach ($args as $arg) {                $function += $arg($x);            }            return $function;        };        return function ($x) use ($args, $sum) {            return $sum(...\array_merge([$x], $args));        };    }    /**     * Multiplies any number of single variable (callback) functions {f(x)}.     * Returns the product as a callback function.     *     * @param callable ...$args Two or more single-variable callback functions     *     * @return callable         Product of the input functions     */    public static function multiply(callable ...$args): callable    {        $product = function ($x, ...$args) {            $function = 1;            foreach ($args as $arg) {                $function *= $arg($x);            }            return $function;        };        return function ($x) use ($args, $product) {            return $product(...\array_merge([$x], $args));        };    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3438, Calculate the weighted mean average of a list of numbers\n https://en.wikipedia.org/wiki/Weighted_arithmetic_mean\n\n     ∑⟮xᵢwᵢ⟯\n x̄ = -----\n      ∑⟮wᵢ⟯\n\n @param float[] $numbers\n @param float[] $weights\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n @throws Exception\\BadDataException if the number of numbers and weights are not equal\n, Calculate the weighted mean average of a list of numbers,"    public static function weightedMean(array $numbers, array $weights): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the weightedMean of an empty list of numbers');        }        if (empty($weights)) {            return Average::mean($numbers);        }        if (\count($numbers) !== \count($weights)) {            throw new Exception\BadDataException('Numbers and weights must have the same number of elements.');        }        $∑⟮xᵢwᵢ⟯ = \array_sum(\array_map(            function ($xᵢ, $wᵢ) {                return $xᵢ * $wᵢ;            },            $numbers,            $weights        ));        $∑⟮wᵢ⟯ = \array_sum($weights);        return $∑⟮xᵢwᵢ⟯ / $∑⟮wᵢ⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3439, Calculate the median average of a list of numbers\n\n @param float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n @throws Exception\\OutOfBoundsException if kth-smallest k is out of bounds\n, Calculate the median average of a list of numbers,"    public static function median(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median of an empty list of numbers');        }        if (\count($numbers) === 1) {            return \array_pop($numbers);        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // For odd number of numbers, take the middle indexed number        if (\count($numbers) % 2 == 1) {            $middle_index = \intdiv(\count($numbers), 2);            return self::kthSmallest($numbers, $middle_index);        }        // For even number of items, take the mean of the middle two indexed numbers        $left_middle_index  = \intdiv(\count($numbers), 2) - 1;        $left_median        = self::kthSmallest($numbers, $left_middle_index);        $right_middle_index = $left_middle_index + 1;        $right_median       = self::kthSmallest($numbers, $right_middle_index);        return self::mean([ $left_median, $right_median ]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3445," Contraharmonic mean\n A function complementary to the harmonic mean.\n A special case of the Lehmer mean, L₂(x), where p = 2.\n https://en.wikipedia.org/wiki/Contraharmonic_mean\n\n @param  float[] $numbers\n\n @return float\n", Contraharmonic mean,"    public static function contraharmonicMean(array $numbers): float    {        $p = 2;        return self::lehmerMean($numbers, $p);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3446, Root mean square (quadratic mean)\n The square root of the arithmetic mean of the squares of a set of numbers.\n https://en.wikipedia.org/wiki/Root_mean_square\n           ___________\n          /x₁+²x₂²+ ⋯\n x rms = / -----------\n        √       n\n\n @param  float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n, Root mean square (quadratic mean),"    public static function rootMeanSquare(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the root mean square of an empty list of numbers');        }        $n = \count($numbers);        $x₁²＋x₂²＋⋯ = \array_sum(\array_map(            function ($x) {                return $x ** 2;            },            $numbers        ));        return \sqrt($x₁²＋x₂²＋⋯ / $n);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3447, Quadradic mean (root mean square)\n Convenience function for rootMeanSquare\n\n @param  float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n, Quadradic mean (root mean square),    public static function quadraticMean(array $numbers): float    {        return self::rootMeanSquare($numbers);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3449," Interquartile mean (IQM)\n A measure of central tendency based on the truncated mean of the interquartile range.\n Only the data in the second and third quartiles is used (as in the interquartile range),\n and the lowest 25% and the highest 25% of the scores are discarded.\n https://en.wikipedia.org/wiki/Interquartile_mean\n\n @param  float[] $numbers\n\n @return float\n\n @throws Exception\\OutOfBoundsException\n", Interquartile mean (IQM),"    public static function interquartileMean(array $numbers): float    {        return self::truncatedMean($numbers, 25);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3452," Truncated mean (trimmed mean)\\n The mean after discarding given parts of a probability distribution or sample\\n at the high and low end, and typically discarding an equal amount of both.\\n This number of points to be discarded is given as a percentage of the total number of points.\\n https://en.wikipedia.org/wiki/Truncated_mean\\n\\n Trim count = floor( (trim percent / 100) \\n For example: [8, 3, 7, 1, 3, 9] with a trim of 20%\\n First sort the list: [1, 3, 3, 7, 8, 9]\\n Sample size = 6\\n Then determine trim count: floot(20/100  Trim the list by removing 1 from each end: [3, 3, 7, 8]\\n Finally, find the mean: 5.2\\n\\n @param float[] $numbers\\n @param int     $trim_percent Percent between 0-99\\n\\n @return float\\n\\n @throws Exception\\\\OutOfBoundsException if trim percent is not between 0 and 99\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n", Truncated mean (trimmed mean),"    public static function truncatedMean(array $numbers, int $trim_percent): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the truncated mean of an empty list of numbers');        }        if ($trim_percent < 0 || $trim_percent > 99) {            throw new Exception\OutOfBoundsException('Trim percent must be between 0 and 99.');        }        $n          = \count($numbers);        $trim_count = \floor($n * ($trim_percent / 100));        \sort($numbers);        for ($i = 1; $i <= $trim_count; $i++) {            \array_shift($numbers);            \array_pop($numbers);        }        return self::mean($numbers);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3454," Generalized mean (power mean, Hölder mean)\\n https://en.wikipedia.org/wiki/Generalized_mean\\n\\n          / 1  n    \\\\ 1/p\\n Mp(x) = |  -  ∑ xᵢᵖ|\\n          \\\\ n ⁱ⁼¹   /\\n\\n Special cases:\\n  M-∞(x) is \\\\min(x)\\n  M₋₁(x) is the harmonic mean\\n  M₀(x) is the geometric mean\\n  M₁(x) is the arithmetic mean\\n  M₂(x) is the quadratic mean\\n  M₃(x) is the cubic mean\\n  M∞(x) is max(X)\\n\\n @param  float[] $numbers\\n @param  float   $p\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n"," Generalized mean (power mean, Hölder mean)","    public static function generalizedMean(array $numbers, float $p): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the generalized mean of an empty list of numbers');        }        // Special cases for infinite p        if ($p == -\INF) {            return \min($numbers);        }        if ($p == \INF) {            return \max($numbers);        }        // Special case for p = 0 (geometric mean)        if ($p == 0) {            return self::geometricMean($numbers);        }        // Standard case for non-infinite p        $n    = \count($numbers);        $∑xᵢᵖ = \array_sum(Map\Single::pow($numbers, $p));        return \pow($∑xᵢᵖ / $n, 1 / $p);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3455, Power mean (generalized mean)\n Convenience method for generalizedMean\n\n @param  float[] $numbers\n @param  float $p\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n, Power mean (generalized mean),"    public static function powerMean(array $numbers, float $p): float    {        return self::generalizedMean($numbers, $p);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_BaseEncoderDecoder_2550, Utility functions to manipulate numerical strings with non-standard bases and alphabets\n, Utility functions to manipulate numerical strings with non-standard bases and alphabets,"class BaseEncoderDecoder{    /** string alphabet of base 64 numbers */    private const RFC3548_BASE64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';    /** string alphabet of file safe base 64 numbers */    private const RFC3548_BASE64_FILE_SAFE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';    /** string alphabet of base 32 numbers */    private const RFC3548_BASE32 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';    /**     * Get the default alphabet for a given number base     *     * @param int $base     *     * @return string offset     */    protected static function getDefaultAlphabet(int $base): string    {        switch ($base) {            case 2:            case 8:            case 10:                return '0';            case 16:                return '0123456789abcdef';            default:                return \chr(0);        }    }    /**     * Convert to an arbitrary base and alphabet     *     * @param ArbitraryInteger $number     * @param int $base     * @param string $alphabet     *     * @return string     *     * @throws Exception\BadParameterException if the base is greater than 256     */    public static function toBase(ArbitraryInteger $number, int $base, $alphabet = null): string    {        if ($base > 256) {            throw new Exception\BadParameterException(""Number base cannot be greater than 256."");        }        if ($alphabet === null) {            $alphabet = self::getDefaultAlphabet($base);        }        $base_256 = $number->toBinary();        $result   = '';        while ($base_256 !== '') {            $carry    = 0;            $next_int = $base_256;            $len      = \strlen($base_256);            $base_256 = '';            for ($i = 0; $i < $len; $i++) {                $chr   = \ord($next_int[$i]);                $int   = \intdiv($chr + 256 * $carry, $base);                $carry = ($chr + 256 * $carry) % $base;                // or just trim off all leading chr(0)s                if ($base_256 !== '' || $int > 0) {                    $base_256 .= \chr($int);                }            }            if (\strlen($alphabet) == 1) {                $result = \chr(\ord($alphabet) + $carry) . $result;            } else {                $result = $alphabet[$carry] . $result;            }        }        return $result;    }    /**     * Create an ArbitraryInteger from a number string in novel number bases and alphabets     *     * @param string $number     * @param int    $base     * @param string $offset     *     * @return ArbitraryInteger     *     * @throws Exception\BadParameterException if the string is empty or base is greater than 256     */    public static function createArbitraryInteger(string $number, int $base, string $offset = null): ArbitraryInteger    {        if ($number == '') {            throw new Exception\BadParameterException(""String cannot be empty."");        }        if ($base > 256) {            throw new Exception\BadParameterException(""Number base cannot be greater than 256"");        }        // Set to default offset and ascii alphabet        if ($offset === null) {            $offset = self::getDefaultAlphabet($base);        }        $length = \strlen($number);        // Remove the offset.        if ($offset !== \chr(0)) {            // I'm duplicating the for loop instead of placing the if within the for            // to prevent calling the if/else on every pass.            if (\strlen($offset) ==  1) {                // Subtract a constant offset from each character.                $offset_num = \ord($offset);                for ($i = 0; $i < $length; $i++) {                    $chr   = $number[$i];                    $digit = \ord($chr) - $offset_num;                    // Check that all elements are greater than the offset, and are members of the alphabet.                    if ($digit < 0 || $digit >= $base) {                        throw new Exception\BadParameterException(""Invalid character in string."");                    }                    $number[$i] = \chr(\ord($chr) - $offset_num);                }            } else {                // Lookup the offset from the string position                for ($i = 0; $i < $length; $i++) {                    $chr = $number[$i];                    $pos = \strpos($offset, $chr);                    if ($pos === false) {                        throw new Exception\BadParameterException(""Invalid character in string."");                    }                    $number[$i] = \chr($pos);                }            }        }        // Convert to base 256        $base256 = new ArbitraryInteger(0);        $length  = \strlen($number);        for ($i = 0; $i < $length; $i++) {            $chr = \ord($number[$i]);            $base256 = $base256->multiply($base)->add($chr);        }        return $base256;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Basic_3384," Arithmetic progression\\n A sequence of numbers such that the difference between the consecutive terms is constant.\\n https://en.wikipedia.org/wiki/Arithmetic_progression\\n\\n Example:\\n  n  = 10\\n  d  = 2\\n  a₁ = 1\\n  Sequence:    1, 3, 5, 7, 9, 11, 13, 15, 17, 19\\n  Array index: 1, 2, 3, 4, 5, 6,  7,  8,  9,  10\\n\\n @param int $n  How many numbers in the sequence\\n @param int $d  Difference between the elements of the sequence\\n @param int $a₁ Starting number for the sequence\\n\\n @return array Indexed from 1\\n", Arithmetic progression,"    public static function arithmeticProgression(int $n, int $d, int $a₁): array    {        if ($n <= 0) {            return [];        }        $progression[1] = $a₁;        for ($i = 1; $i < $n; $i++) {            $progression[$i + 1] = $progression[$i] + $d;        }        return $progression;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Basic_3385," Geometric progression\\n A sequence of numbers where each term after the first is found by multiplying\\n the previous one by a fixed, non-zero number called the common ratio.\\n https://en.wikipedia.org/wiki/Geometric_progression\\n\\n an = arⁿ⁻¹\\n\\n Example:\\n  n = 4\\n  a = 2\\n  r = 3\\n  Sequence:    2(3)⁰, 2(3)¹, 2(3)², 2(3)³\\n  Sequence:    2,     6,     18,    54\\n  Array index: 0      1      2      3\\n\\n @param  int    $n How many numbers in the sequence\\n @param  number $a Scalar value\\n @param  number $r Common ratio\\n\\n @return array Indexed from 0 (indexes are powers of common ratio)\\n\\n @throws Exception\\\\BadParameterException\\n", Geometric progression,"    public static function geometricProgression(int $n, $a, $r): array    {        if ($r === 0) {            throw new Exception\BadParameterException('Common ratio r cannot be 0');        }        $progression = [];        if ($n < 0) {            return $progression;        }        for ($i = 0; $i < $n; $i++) {            $progression[] = $a * $r ** $i;        }        return $progression;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Basic_3386," Square numbers\n https://en.wikipedia.org/wiki/Square_number\n\n n²\n\n Example:\n  n = 5\n  Sequence:    0², 1², 2², 3², 4²\n  Sequence:    0,  1,  4,  9,  16\n  Array index: 0,  1,  2,  3,  4\n\n @param  int $n How many numbers in the sequence\n\n @return array Indexed from 0 (indexes are the base number which is raised to the power of 2)\n", Square numbers,    public static function squareNumber(int $n): array    {        $squares = [];        if ($n <= 0) {            return $squares;        }        for ($i = 0; $i < $n; $i++) {            $squares[] = $i ** 2;        }        return $squares;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Basic_3387," Cubic numbers\\n https://en.wikipedia.org/wiki/Cube_(algebra)\\n\\n n³\\n\\n Example:\\n  n = 5\\n  Sequence:    0³, 1³, 2³, 3³, 4³\\n  Sequence:    0,  1,  8,  27, 64\\n  Array index: 0,  1,  2,  3,  4\\n\\n @param  int $n How many numbers in the sequence\\n\\n @return array Indexed from 0 (indexes are the base number which is raised to the power of 3)\\n", Cubic numbers,    public static function cubicNumber(int $n): array    {        $cubes = [];        if ($n <= 0) {            return $cubes;        }        for ($i = 0; $i < $n; $i++) {            $cubes[] = $i ** 3;        }        return $cubes;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Basic_3389," Powers of ten\\n https://en.wikipedia.org/wiki/Power_of_10\\n\\n Example:\\n  n = 5\\n  Sequence:    10⁰, 10¹, 10², 10³,  10⁴\\n  Sequence:    1,   10,  100, 1000, 10000\\n  Array index: 0,   1,   2,   3,    4\\n\\n @param  int $n How many numbers in the sequence\\n\\n @return array Indexed from 0 (indexes are the power 10 is raised to)\\n", Powers of ten,    public static function powersOfTen(int $n): array    {        $powers_of_10 = [];        if ($n <= 0) {            return $powers_of_10;        }        for ($i = 0; $i < $n; $i++) {            $powers_of_10[] = 10 ** $i;        }        return $powers_of_10;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Basic_3390," Factorial\\n https://en.wikipedia.org/wiki/Factorial\\n\\n Example:\\n  n = 5\\n  Sequence:    0!, 1!, 2!, 3!, 4!\\n  Sequence:    1,  1,  2,  6,  24\\n  Array index: 0,  1,  2,  3,  4\\n\\n @param  int $n How many numbers in the sequence\\n\\n @return array Indexed from 0 (indexes are the n!)\\n", Factorial,    public static function factorial(int $n): array    {        if ($n <= 0) {            return [];        }        $factorial = [1];        if ($n === 1) {            return $factorial;        }        for ($i = 1; $i < $n; $i++) {            $factorial[] = $i * $factorial[$i - 1];        }        return $factorial;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Basic_3391," Digit sum (sum of digits)\\n https://en.wikipedia.org/wiki/Digit_sum\\n https://oeis.org/A007953\\n\\n Example\\n  n = 11\\n  Sequence:    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1\\n  Array index: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1\\n\\n @param  int $n How many numbers in the sequence\\n\\n @return array Indexed from 0 (indexes are the n in the digitSum(n))\\n", Digit sum (sum of digits),    public static function digitSum(int $n): array    {        if ($n <= 0) {            return [];        }        $digit_sums = [];        for ($i = 0; $i < $n; $i++) {            $digit_sums[] = Arithmetic::digitSum($i);        }        return $digit_sums;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Bernoulli_3210," Probability mass function\n\n q = (1 - p)  for k = 0\n p            for k = 1\n\n @param  int $k number of successes  k ∈ {0, 1}\n\n @return float\n", Probability mass function,"    public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        if ($k === 0) {            return $this->q;        } else {            return $this->p;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_BetaTest_5110," Data generated with calculator: https://captaincalculator.com/math/statistics/beta-distribution-calculator/\\n @return array [α, β, μ]\\n", Data generated with calculator: https://captaincalculator.com/math/statistics/beta-distribution-calculator/,"    public function dataProviderForMedian(): array    {        return [            // α == β            [1, 1, 0.5],            [2, 2, 0.5],            [3, 3, 0.5],            // α == 1, β > 0            [1, 0.1, 0.99902344],            [1, 0.5, 0.75],            [1, 2, 0.29289322],            [1, 3, 0.20629947],            [1, 4, 0.15910358],            [1, 5, 0.12944944],            // β == 1, α > 0            [0.1, 1, 0.00097656],            [0.5, 1, 0.25],            [2, 1, 0.70710678],            [3, 1, 0.79370053],            [4, 1, 0.84089642],            [5, 1, 0.87055056],            // α == 3, β == 2            [3, 2, 0.61427243],            // α == 2, β == 3            [2, 3, 0.38572757],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Beta_3057, Beta distribution\n https://en.wikipedia.org/wiki/Beta_distribution\n, Beta distribution,"class Beta extends Continuous{    /**     * Distribution parameter bounds limits     * α ∈ (0,∞)     * β ∈ (0,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'α' => '(0,∞)',        'β' => '(0,∞)',    ];    /**     * Distribution support bounds limits     * x ∈ [0,1]     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '[0,1]',    ];    /** @var number Shape Parameter */    protected $α;    /** @var number Shape Parameter */    protected $β;    /**     * Constructor     *     * @param float $α shape parameter α > 0     * @param float $β shape parameter β > 0     */    public function __construct(float $α, float $β)    {        parent::__construct($α, $β);    }    /**     * Probability density function     *     *       xᵃ⁻¹(1 - x)ᵝ⁻¹     * pdf = --------------     *           B(α,β)     *     * @param float $x x ∈ (0,1)     *     * @return float     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $α = $this->α;        $β = $this->β;        $xᵃ⁻¹ = \pow($x, $α - 1);        $⟮1 − x⟯ᵝ⁻¹ = \pow(1 - $x, $β - 1);        $B⟮α、β⟯ = Special::beta($α, $β);        return ($xᵃ⁻¹ * $⟮1 − x⟯ᵝ⁻¹) / $B⟮α、β⟯;    }    /**     * Cumulative distribution function     *     * cdf = Iₓ(α,β)     *     * @param float $x x ∈ (0,1)     *     * @return float     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $α = $this->α;        $β = $this->β;        return Special::regularizedIncompleteBeta($x, $α, $β);    }    /**     * Inverse cumulative distribution function (quantile function)     * Iterative method     *     * @param float $x     * @param float $tolerance (optional)     * @param int   $max_iterations (optional)     *     * @return float     *     * @throws MathException if it fails to converge on a guess within the tolerance     */    public function inverse(float $x, float $tolerance = 1.0e-15, int $max_iterations = 200): float    {        [$a, $b] = [0, 2];        for ($i = 0; $i < $max_iterations; $i++) {            $guess = ($a + $b) / 2;            $cdf   = $this->cdf($guess);            if ($cdf == $x || $cdf == 0) {                $b = $a;            } elseif ($cdf > $x) {                $b = $guess;            } else {                $a = $guess;            }            if (($b - $a) <= $tolerance) {                return $guess;            }        }        throw new MathException(""Failed to converge on a Beta inverse within a tolerance of $tolerance after {$max_iterations} iterations"");    }    /**     * Mean of the distribution     *     *       α     * μ = -----     *     α + β     *     * @return float     */    public function mean(): float    {        $α = $this->α;        $β = $this->β;        return $α / ($α + $β);    }    /**     * Median of the distribution     *     * Closed forms     *  - For symmetric cases α = β, median = 1/2     *  - For α = 1 and β > 0, median = 1 - 2^(-1/β)     *  - For α > 0 and β = 1, median = 2^(-1/α)     *  - For α = 3 and β = 2, median = 0.6142724318676105     *  - For α = 2 and β = 3, median = 0.38572756813238945     *     * Approximation     *             α  - ⅓     *  median =  ---------     *            α + β - ⅔     *     * @see https://en.wikipedia.org/wiki/Beta_distribution#Median     *     * @return float     */    public function median(): float    {        $α = $this->α;        $β = $this->β;        if ($α == $β) {            return 0.5;        }        if ($α == 1 && $β > 0) {            return 1 - 2 ** (-1 / $β);        }        if ($β == 1 && $α > 0) {            return 2 ** (-1 / $α);        }        if ($α == 3 && $β == 2) {            return 0.6142724318676105;        }        if ($α == 2 && $β == 3) {            return 0.38572756813238945;        }        return ($α - 1 / 3) / ($α + $β - 2 / 3);    }    /**     * Mode of the distribution     *     *          α - 1     * mode = ---------    α, β > 1     *        α + β - 2     *     * mode = 0            α = 1, β > 1     * mode = 1            α > 1, β = 1     *     * @return float     */    public function mode(): float    {        $α = $this->α;        $β = $this->β;        if ($α == 1 && $β > 1) {            return 0;        }        if ($α > 1 && $β == 1) {            return 1;        }        return ($α - 1) / ($α + $β - 2);    }    /**     * Variance of the distribution     *     *                  αβ     * var[X] = -------------------     *          ⟮α ＋ β⟯²⟮α ＋ β ＋ 1⟯     *     * @return float     */    public function variance(): float    {        $α = $this->α;        $β = $this->β;        $αβ          = $α * $β;        $⟮α ＋ β⟯²     = ($α + $β) ** 2;        $⟮α ＋ β ＋ 1⟯ = $α + $β + 1;        return $αβ / ($⟮α ＋ β⟯² * $⟮α ＋ β ＋ 1⟯);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Beta_3059," Probability density function\\n\\n       xᵃ⁻¹(1 - x)ᵝ⁻¹\\n pdf = --------------\\n           B(α,β)\\n\\n @param float $x x ∈ (0,1)\\n\\n @return float\\n", Probability density function,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $α = $this->α;        $β = $this->β;        $xᵃ⁻¹ = \pow($x, $α - 1);        $⟮1 − x⟯ᵝ⁻¹ = \pow(1 - $x, $β - 1);        $B⟮α、β⟯ = Special::beta($α, $β);        return ($xᵃ⁻¹ * $⟮1 − x⟯ᵝ⁻¹) / $B⟮α、β⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Beta_3060," Cumulative distribution function\n\n cdf = Iₓ(α,β)\n\n @param float $x x ∈ (0,1)\n\n @return float\n", Cumulative distribution function,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $α = $this->α;        $β = $this->β;        return Special::regularizedIncompleteBeta($x, $α, $β);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Beta_3063," Mode of the distribution\n\n          α - 1\n mode = ---------    α, β > 1\n        α + β - 2\n\n mode = 0            α = 1, β > 1\n mode = 1            α > 1, β = 1\n\n @return float\n", Mode of the distribution,    public function mode(): float    {        $α = $this->α;        $β = $this->β;        if ($α == 1 && $β > 1) {            return 0;        }        if ($α > 1 && $β == 1) {            return 1;        }        return ($α - 1) / ($α + $β - 2);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3218," Probability mass function\n\n P(X = r) = nCr pʳ (1 - p)ⁿ⁻ʳ\n\n If n is large, combinatorial factorial blows up,\n so use the multiplication method instead.\n\n @param  int $r number of successful events\n\n @return float\n", Probability mass function,"    public function pmf(int $r): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['r' => $r]);        return $this->n < 150            ? $this->combinatorialMethod($r)            : $this->multiplicationMethod($r, $this->n, $this->p);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3219, PMF combinatorial method\n\n P(X = r) = nCr pʳ (1 - p)ⁿ⁻ʳ\n\n @param int $r number of successful events\n\n @return float\n\n @throws \\MathPHP\\Exception\\OutOfBoundsException\n, PMF combinatorial method,"    private function combinatorialMethod(int $r): float    {        $n = $this->n;        $p = $this->p;        $nCr       = Combinatorics::combinations($n, $r);        $pʳ        = \pow($p, $r);        $⟮1 − p⟯ⁿ⁻ʳ = \pow(1 - $p, $n - $r);        return $nCr * $pʳ * $⟮1 − p⟯ⁿ⁻ʳ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3223, Variance of the distribution\n\n σ² = np(1 - p)\n\n @return float\n, Variance of the distribution,    public function variance(): float    {        $n = $this->n;        $p = $this->p;        return $n * $p * (1 - $p);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_BisectionMethod_3036," Bisection's Method (also known as the Binary-search method)\\n\\n In numerical analysis, the Bisection method is a method for finding successively\\n better approximations to the roots (or zeroes) of a continuous, real-valued\\n function f(x). It starts with two points $a and $b, such that f($a) and f($b)\\n have different signs (one is positive, one is negative). This lets us use\\n the intermediate value theorem to prove that there is a root $p such that\\n p is between $a and $b. We initially set $p to be the average of $a and $b\\n and analyze the result of f($p). Based on the sign, we construct a new $p that\\n is either the average of $a and the original $p, or the average of the\\n original $p and $b. We continue doing this until our function evaluation f($p)\\n is within the tolerance set on our input.\\n\\n https://en.wikipedia.org/wiki/Bisection_method\\n", Bisection's Method (also known as the Binary-search method),"class BisectionMethod{    /**     * Use the Bisection Method to find the x which produces $function(x) = 0.     *     * @param callable $function f(x) callback function     * @param number   $a        The start of the interval which contains a root     * @param number   $b        The end of the interval which contains a root     * @param number   $tol      Tolerance; How close to the actual solution we would like.     * @return number     *     * @throws Exception\OutOfBoundsException     * @throws Exception\BadDataException     */    public static function solve(callable $function, $a, $b, $tol)    {        // Validate input arguments        self::validate($function, $a, $b, $tol);        do {            $f⟮a⟯ = $function($a);            $p   = ($a + $b) / 2;     // construct the midpoint            $f⟮p⟯ = $function($p);            $dif = \abs($f⟮p⟯);       // the magnitude of our function at the midpoint            if (Special::sgn($f⟮p⟯) !== Special::sgn($f⟮a⟯)) {                $b = $p;            // the new endpoint is our original midpoint            } else {                $a = $p;            // the new start point is our original endpoint            }        } while ($dif > $tol);        return $p;    }    /**     * Verify the input arguments are valid for correct use of the bisection     * method. If the tolerance is less than zero, an Exception will be thrown.     * If f($a) and f($b) have the same sign, we cannot use the intermediate     * value theorem to guarantee a root is between $a and $b. This exposes the     * risk of an endless loop, so we throw an Exception. If $a = $b, then clearly     * we cannot run our loop as $a and $b will themselves be the midpoint, so we     * throw an Exception.     *     * @param Callable $function f(x) callback function     * @param number   $a        The start of the interval which contains a root     * @param number   $b        The end of the interval which contains a root     * @param number   $tol      Tolerance; How close to the actual solution we would like.     *     * @throws Exception\OutOfBoundsException if $tol (the tolerance) is negative     * @throws Exception\BadDataException if $a = $b     * @throws Exception\BadDataException if f($a) and f($b) share the same sign     */    private static function validate(callable $function, $a, $b, $tol)    {        Validation::tolerance($tol);        Validation::interval($a, $b);        $f⟮a⟯ = $function($a);        $f⟮b⟯ = $function($b);        if (Special::sgn($f⟮a⟯) === Special::sgn($f⟮b⟯)) {            throw new Exception\BadDataException(                'Input function has the same sign at the start and end of the interval. Choose start and end points such that the function evaluated at those points has a different sign (one positive, one negative).'            );        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Bitwise_2552," Add two ints ignoring the signing bit.\n\n 8 bit examples:\n 0d15 + 0d1 = 0d16\n 0b00001111 + 0b00000001 = 0b00010000\n\n 0d127 + 0d1 = 0d-128\n 0b01111111 + 0b00000001 = 0b10000000\n\n 0d-1 + 0d1 = 0d0\n 0b11111111 + 0b00000001 = 0b00000000 :overflow = true\n\n 0d-1 + 0d-1 = 0d-2\n 0b11111111 + 0b11111111 = 0b11111110: overflow = true\n\n Scenarios\n  1) Result is an integer\n       $a and $b are negative, the most significant bit will overflow.\n       If only one is negative, the most significant bit will overflow if the sum is positive.\n  2) Result is not an integer\n    a) a and b are positive\n         If $a + $b overflows as a signed int, it is now a negative int, but the most significant\n         bit will not overflow.\n    b) a and b are not both positive\n         The sum of two ""large"" negative numbers will both overflow the most significant bit\n         and the signed int.\n         The values of $a and $b have to be shifted towards zero to prevent the\n         signed int from overflowing. We are removing the most significant\n         bit from the ints by subtracting PHP_INT_MIN to prevent overflow.\n         $a = 1001, $b = 1010, return [true, \'0011] because PHP_INT_MIN = 1000,\n         Giving $a - 1000 = 0001, $b - 1000 = 0010.\n\n @param int $a\n @param int $b\n\n @return array\n         \'overflow\' is true if the result is larger than the bits in an int\n         \'value\' is the result of the addition ignoring any overflow.\n", Add two ints ignoring the signing bit.,"    public static function add(int $a, int $b): array    {        /** @var int|float due to potential overflow */        $sum = $a + $b;        if (\is_int($sum)) {            $overflow = (($a < 0 || $b < 0) && $sum >= 0) || ($a < 0 && $b < 0);        } elseif ($a > 0 && $b > 0) {            $sum      = $a - \PHP_INT_MAX + $b - 1 + \PHP_INT_MIN;            $overflow = false;        } else {            $a       -= \PHP_INT_MIN;            $b       -= \PHP_INT_MIN;            $sum      = $a + $b;            $overflow = true;        }        return [            'overflow' => $overflow,            'value'    => $sum,        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_BoolesRule_3018," Boole's Rule\n\n In numerical analysis, Boole's rule is a technique for approximating\n the definite integral of a function.\n\n Boole's rule belongs to the closed Newton-Cotes formulas, a group of methods\n for numerical integration which approximate the integral of a function. We\n can either directly supply a set of inputs and their corresponding outputs for\n said function, or if we explicitly know the function, we can define it as a\n callback function and then generate a set of points by evaluating that function\n at n points between a start and end point. We then use these values to\n interpolate a Lagrange polynomial. Finally, we integrate the Lagrange\n polynomial to approximate the integral of our original function.\n\n Boole's rule is produced by integrating the fourth Lagrange polynomial.\n\n https://en.wikipedia.org/wiki/Boole%27s_rule\n http://mathworld.wolfram.com/BoolesRule.html\n http://www.efunda.com/math/num_integration/num_int_newton.cfm\n", Boole's Rule,"class BoolesRule extends NumericalIntegration{    /**     * Use Boole's Rule to aproximate the definite integral of a     * function f(x). Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose definite integral we     * are approximating.     *     * Note: Boole's rule requires that our number of subintervals is a factor     * of four (we must supply an n points such that n-1 is a multiple of four)     * and also that the size of each subinterval is equal (spacing between each     * point is equal).     *     * The bounds of the definite integral to which we are approximating is     * determined by the our inputs.     *     * Example: approximate([0, 10], [2, 5], [4, 7], [6,3]) will approximate the     * definite integral of the function that produces these coordinates with a     * lower bound of 0, and an upper bound of 6.     *     * Example: approximate(function($x) {return $x**2;}, [0, 3 ,5]) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 3. Then, this array will be used in our approximation.     *     * Boole's Rule:     *     * xn        ⁿ⁻¹ xᵢ₊₁     * ∫ f(x)dx = ∑   ∫ f(x)dx     * x₁        ⁱ⁼¹  xᵢ     *     *         ⁽ⁿ⁻¹⁾/⁴ 2h     *          = ∑    -- [7f⟮x₄ᵢ₋₃⟯ + 32f⟮x₄ᵢ₋₂⟯ + 12f⟮x₄ᵢ₋₁⟯ + 32f⟮x₄ᵢ⟯ + 7f⟮x₄ᵢ₊₁⟯] + O(h⁷f⁽⁶⁾(x))     *           ⁱ⁼¹   45     * where h = (xn - x₁) / (n - 1)     *     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4], [4,5], [5,6]].     *                                Example callback: function($x) {return $x**2;}     * @param number         ...$args The arguments of our callback function: start,     *                                end, and n. Example: approximate($source, 0, 8, 4).     *                                If $source is a set of points, do not input any     *                                $args. Example: approximate($source).     *     * @return float                  The approximation to the integral of f(x)     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     */    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 5);        Validation::isSubintervalsMultiple($points, $m = 4);        $sorted = self::sort($points);        Validation::isSpacingConstant($sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $subIntervals  = $n - 1;        $a             = $sorted[0][$x];        $b             = $sorted[$n - 1][$x];        $h             = ($b - $a) / $subIntervals;        $approximation = 0;        /*         * ⁽ⁿ⁻¹⁾/⁴ 2h         *  = ∑    -- [7f⟮x₄ᵢ₋₃⟯ + 32f⟮x₄ᵢ₋₂⟯ + 12f⟮x₄ᵢ₋₁⟯ + 32f⟮x₄ᵢ⟯ + 7f⟮x₄ᵢ₊₁⟯] + O(h⁷f⁽⁶⁾(x))         *   ⁱ⁼¹   45         *  where h = (xn - x₁) / (n - 1)         */        for ($i = 1; $i < ($subIntervals / 4) + 1; $i++) {            $x₄ᵢ₋₃          = $sorted[(4 * $i) - 4][$x];            $x₄ᵢ₋₂          = $sorted[(4 * $i) - 3][$x];            $x₄ᵢ₋₁          = $sorted[(4 * $i) - 2][$x];            $x₄ᵢ            = $sorted[(4 * $i) - 1][$x];            $x₄ᵢ₊₁          = $sorted[(4 * $i)][$x];            $f⟮x₄ᵢ₋₃⟯        = $sorted[(4 * $i) - 4][$y]; // y₄ᵢ₋₃            $f⟮x₄ᵢ₋₂⟯        = $sorted[(4 * $i) - 3][$y]; // y₄ᵢ₋₂            $f⟮x₄ᵢ₋₁⟯        = $sorted[(4 * $i) - 2][$y]; // y₄ᵢ₋₁            $f⟮x₄ᵢ⟯          = $sorted[(4 * $i) - 1][$y]; // y₄ᵢ            $f⟮x₄ᵢ₊₁⟯        = $sorted[(4 * $i)][$y];   // y₄ᵢ₊₁            $lagrange       = LagrangePolynomial::interpolate([[$x₄ᵢ₋₃, $f⟮x₄ᵢ₋₃⟯], [$x₄ᵢ₋₂, $f⟮x₄ᵢ₋₂⟯], [$x₄ᵢ₋₁, $f⟮x₄ᵢ₋₁⟯], [$x₄ᵢ, $f⟮x₄ᵢ⟯], [$x₄ᵢ₊₁, $f⟮x₄ᵢ₊₁⟯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($x₄ᵢ₊₁) - $integral($x₄ᵢ₋₃); // definite integral of lagrange polynomial        }        return $approximation;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_BoolesRule_3019," Use Boole's Rule to aproximate the definite integral of a\n function f(x). Our input can support either a set of arrays, or a callback\n function with arguments (to produce a set of arrays). Each array in our\n input contains two numbers which correspond to coordinates (x, y) or\n equivalently, (x, f(x)), of the function f(x) whose definite integral we\n are approximating.\n\n Note: Boole's rule requires that our number of subintervals is a factor\n of four (we must supply an n points such that n-1 is a multiple of four)\n and also that the size of each subinterval is equal (spacing between each\n point is equal).\n\n The bounds of the definite integral to which we are approximating is\n determined by the our inputs.\n\n Example: approximate([0, 10], [2, 5], [4, 7], [6,3]) will approximate the\n definite integral of the function that produces these coordinates with a\n lower bound of 0, and an upper bound of 6.\n\n Example: approximate(function($x) {return $x a set of arrays by evaluating the callback at 5 evenly spaced points\n between 0 and 3. Then, this array will be used in our approximation.\n\n Boole's Rule:\n\n xn        ⁿ⁻¹ xᵢ₊₁\n ∫ f(x)dx = ∑   ∫ f(x)dx\n x₁        ⁱ⁼¹  xᵢ\n\n         ⁽ⁿ⁻¹⁾/⁴ 2h\n          = ∑    -- [7f⟮x₄ᵢ₋₃⟯ + 32f⟮x₄ᵢ₋₂⟯ + 12f⟮x₄ᵢ₋₁⟯ + 32f⟮x₄ᵢ⟯ + 7f⟮x₄ᵢ₊₁⟯] + O(h⁷f⁽⁶⁾(x))\n           ⁱ⁼¹   45\n where h = (xn - x₁) / (n - 1)\n\n @param callable|array $source  The source of our approximation. Should be either\n                                a callback function or a set of arrays. Each array\n                                (point) contains precisely two numbers, an x and y.\n                                Example array: [[1,2], [2,3], [3,4], [4,5], [5,6]].\n                                Example callback: function($x) {return $x @param number         ...$args The arguments of our callback function: start,\n                                end, and n. Example: approximate($source, 0, 8, 4).\n                                If $source is a set of points, do not input any\n                                $args. Example: approximate($source).\n\n @return float                  The approximation to the integral of f(x)\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n", Use Boole's Rule to aproximate the definite integral of a,"    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 5);        Validation::isSubintervalsMultiple($points, $m = 4);        $sorted = self::sort($points);        Validation::isSpacingConstant($sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $subIntervals  = $n - 1;        $a             = $sorted[0][$x];        $b             = $sorted[$n - 1][$x];        $h             = ($b - $a) / $subIntervals;        $approximation = 0;        /*         * ⁽ⁿ⁻¹⁾/⁴ 2h         *  = ∑    -- [7f⟮x₄ᵢ₋₃⟯ + 32f⟮x₄ᵢ₋₂⟯ + 12f⟮x₄ᵢ₋₁⟯ + 32f⟮x₄ᵢ⟯ + 7f⟮x₄ᵢ₊₁⟯] + O(h⁷f⁽⁶⁾(x))         *   ⁱ⁼¹   45         *  where h = (xn - x₁) / (n - 1)         */        for ($i = 1; $i < ($subIntervals / 4) + 1; $i++) {            $x₄ᵢ₋₃          = $sorted[(4 * $i) - 4][$x];            $x₄ᵢ₋₂          = $sorted[(4 * $i) - 3][$x];            $x₄ᵢ₋₁          = $sorted[(4 * $i) - 2][$x];            $x₄ᵢ            = $sorted[(4 * $i) - 1][$x];            $x₄ᵢ₊₁          = $sorted[(4 * $i)][$x];            $f⟮x₄ᵢ₋₃⟯        = $sorted[(4 * $i) - 4][$y]; // y₄ᵢ₋₃            $f⟮x₄ᵢ₋₂⟯        = $sorted[(4 * $i) - 3][$y]; // y₄ᵢ₋₂            $f⟮x₄ᵢ₋₁⟯        = $sorted[(4 * $i) - 2][$y]; // y₄ᵢ₋₁            $f⟮x₄ᵢ⟯          = $sorted[(4 * $i) - 1][$y]; // y₄ᵢ            $f⟮x₄ᵢ₊₁⟯        = $sorted[(4 * $i)][$y];   // y₄ᵢ₊₁            $lagrange       = LagrangePolynomial::interpolate([[$x₄ᵢ₋₃, $f⟮x₄ᵢ₋₃⟯], [$x₄ᵢ₋₂, $f⟮x₄ᵢ₋₂⟯], [$x₄ᵢ₋₁, $f⟮x₄ᵢ₋₁⟯], [$x₄ᵢ, $f⟮x₄ᵢ⟯], [$x₄ᵢ₊₁, $f⟮x₄ᵢ₊₁⟯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($x₄ᵢ₊₁) - $integral($x₄ᵢ₋₃); // definite integral of lagrange polynomial        }        return $approximation;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Categorical_3224, Categorical distribution\\n\\n https://en.wikipedia.org/wiki/Categorical_distribution\\n\\n @property-read int   $k             number of categories\\n @property-read array $probabilities probabilities of each category\\n, Categorical distribution,"class Categorical extends Discrete{    public const PARAMETER_LIMITS = [];    /** @var int number of categories */    private $k;    /**     * @var array     * Probability of each category     * If associative array, category names are keys.     * Otherwise, category names are array indexes.     */    private $probabilities;    /**     * Distribution constructor     *     * @param  int   $k             number of categories     * @param  array $probabilities of each category - If associative array, category names are keys.     *                                                 Otherwise, category names are array indexes.     *     * @throws Exception\BadParameterException if k does not indicate at least one category     * @throws Exception\BadDataException      if there are not k probabilities     * @throws Exception\BadDataException      if the probabilities do not add up to 1     */    public function __construct(int $k, array $probabilities)    {        // Must have at least one category        if ($k <= 0) {            throw new Exception\BadParameterException(""k (number of categories) must be > 0. Given $k"");        }        // Must have k number of probabilities        if (\count($probabilities) != $k) {            throw new Exception\BadDataException(""Must have $k probabilities. Given "" . \count($probabilities));        }        // Probabilities must add up to 1        if (\round(\array_sum($probabilities), 1) != 1) {            throw new Exception\BadDataException('Probabilities do not add up to 1.');        }        $this->k             = $k;        $this->probabilities = $probabilities;        parent::__construct();    }    /**     * Probability mass function     *     * pmf = p(x = i) = pᵢ     *     * @param  mixed $x category name/number     *     * @return float     *     * @throws Exception\BadDataException if x is not a valid category     */    public function pmf($x): float    {        if (!isset($this->probabilities[$x])) {            throw new Exception\BadDataException(""$x is not a valid category"");        }        return $this->probabilities[$x];    }    /**     * Mode of the distribution     *     * i such that pᵢ = \max(p₁, ... pk)     *     * @return mixed Category name/number. Only returns one category in case on multimodal scenario.     */    public function mode()    {        $category = null;        $pmax     = 0;        foreach ($this->probabilities as $i => $pᵢ) {            if ($pᵢ > $pmax) {                $pmax     = $pᵢ;                $category = $i;            }        }        return $category;    }    /**     * Magic getter for k and probabilities     *     * @param  string $name     *     * @return int|array     *     * @throws Exception\BadDataException if $name is not a valid parameter     */    public function __get(string $name)    {        switch ($name) {            case 'k':            case 'probabilities':                return $this->{$name};            default:                throw new Exception\BadDataException(""$name is not a valid gettable parameter"");        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Categorical_3226, Probability mass function\\n\\n pmf = p(x = i) = pᵢ\\n\\n @param  mixed $x category name/number\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if x is not a valid category\\n, Probability mass function,"    public function pmf($x): float    {        if (!isset($this->probabilities[$x])) {            throw new Exception\BadDataException(""$x is not a valid category"");        }        return $this->probabilities[$x];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Categorical_3227," Mode of the distribution\\n\\n i such that pᵢ = \\\\max(p₁, ... pk)\\n\\n @return mixed Category name/number. Only returns one category in case on multimodal scenario.\\n", Mode of the distribution,    public function mode()    {        $category = null;        $pmax     = 0;        foreach ($this->probabilities as $i => $pᵢ) {            if ($pᵢ > $pmax) {                $pmax     = $pᵢ;                $category = $i;            }        }        return $category;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Categorical_3228, Magic getter for k and probabilities\\n\\n @param  string $name\\n\\n @return int|array\\n\\n @throws Exception\\\\BadDataException if $name is not a valid parameter\\n, Magic getter for k and probabilities,"    public function __get(string $name)    {        switch ($name) {            case 'k':            case 'probabilities':                return $this->{$name};            default:                throw new Exception\BadDataException(""$name is not a valid gettable parameter"");        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cauchy_3067, Probability density function\n\n                1\n    --------------------------\n       ┌        / x - x₀ \\ ² ┐\n    πγ | 1  +  | ---------|  |\n       └        \\    γ   /   ┘\n\n @param float $x\n\n @return float\n, Probability density function,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π  = \M_PI;        return 1 / ($π * $γ * (1 + (($x - $x₀) / $γ) ** 2));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cauchy_3069," Inverse CDF (Quantile function)\n\n Q(p;x₀,γ) = x₀ + γ tan[π(p - ½)]\n\n @param float $p\n\n @return float\n", Inverse CDF (Quantile function),"    public function inverse(float $p): float    {        Support::checkLimits(['p' => '[0,1]'], ['p' => $p]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π = \M_PI;        return $x₀ + $γ * \tan($π * ($p - .5));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cauchy_3070, Mean of the distribution (undefined)\\n\\n μ is undefined\\n\\n @return float \\\\NAN\\n, Mean of the distribution (undefined),    public function mean(): float    {        return \NAN;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cereal_3298, Cereal names\\n\\n @return string[]\\n, Cereal names,    public function getCereals(): array    {        return self::CEREALS;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cereal_3300," Raw data with each observation labeled\n ['B1' => ['X1126.0' => 0.002682755, 'X1134.0' => 0.003370673, 'X1142.0' => 0.004085942, ... ]]\n\n @return number[]\n", Raw data with each observation labeled,"    public function getLabeledXData(): array    {        return \array_map(            function (array $data) {                return \array_combine(self::X_LABELS, $data);            },            self::X_DATA        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cereal_3303," Raw data without labels\\n [[-0.1005049, 0.6265746, -1.1716630, ... ], [0.9233889, 0.1882929, -1.3185289, ... ], ... ]\\n\\n @return number[][]\\n", Raw data without labels,    public function getYscData(): array    {        return \array_values(self::YSC_DATA);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ChiSquared_3076, Probability density function\n\n                 1\n           -------------- x⁽ᵏ/²⁾⁻¹ ℯ⁻⁽ˣ/²⁾\n  χ²(k) =          / k \\\n           2ᵏ/² Γ |  -  |\n                   \\ 2 /\n\n @param float $x point at which to evaluate > 0\n\n @return float probability\n, Probability density function,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $k = $this->k;        // Numerator        $x⁽ᵏ／²⁾⁻¹ = $x ** (($k / 2) - 1);        $ℯ⁻⁽ˣ／²⁾  = \exp(-($x / 2));        // Denominator        $２ᵏ／²  = 2 ** ($k / 2);        $Γ⟮k／2⟯ = Special::Γ($k / 2);        return ($x⁽ᵏ／²⁾⁻¹ * $ℯ⁻⁽ˣ／²⁾) / ($２ᵏ／² * $Γ⟮k／2⟯);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ChiSquared_3077," Cumulative distribution function\\n\\n Cumulative t value up to a point, left tail.\\n\\n          / k   x  \\\\\\n       γ |  - , -  |\\n          \\\\ 2   2 /\\n CDF = -------------\\n            / k \\\\\\n         Γ |  -  |\\n            \\\\ 2 /\\n\\n @param float $x Chi-square critical value (CV) > 0\\n\\n @return float cumulative probability\\n", Cumulative distribution function,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $k = $this->k;        // Numerator        $γ⟮k／2、x／2⟯ = Special::γ($k / 2, $x / 2);        // Denominator        $Γ⟮k／2⟯ = Special::Γ($k / 2);        return $γ⟮k／2、x／2⟯ / $Γ⟮k／2⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ChiSquared_3081, Variance of the distribution\\n\\n var[X] = 2k\\n\\n @return float\\n, Variance of the distribution,    public function variance(): float    {        return 2 * $this->k;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cholesky_2861," Cholesky decomposition\\n A decomposition of a square, positive definitive matrix\\n into the product of a lower triangular matrix and its transpose.\\n\\n https://en.wikipedia.org/wiki/Cholesky_decomposition\\n\\n A = LLᵀ\\n\\n     [a₁₁ a₁₂ a₁₃]\\n A = [a₂₁ a₂₂ a₂₃]\\n     [a₃₁ a₃₂ a₃₃]\\n\\n     [l₁₁  0   0 ] [l₁₁ l₁₂ l₁₃]\\n A = [l₂₁ l₂₂  0 ] [ 0  l₂₂ l₂₃] ≡ LLᵀ\\n     [l₃₁ l₃₂ l₃₃] [ 0   0  l₃₃]\\n\\n Diagonal elements\\n          ____________\\n         /     ᵢ₋₁\\n lᵢᵢ =  / aᵢᵢ - ∑l²ᵢₓ\\n       √       ˣ⁼¹\\n\\n Elements below diagonal\\n\\n        1   /      ᵢ₋₁     \\\\\\n lⱼᵢ = --- |  aⱼᵢ - ∑lⱼₓlᵢₓ |\\n       lᵢᵢ  \\\\      ˣ⁼¹     /\\n\\n @property-read NumericMatrix $L  Lower triangular matrix\\n @property-read NumericMatrix $LT Transpose of lower triangular matrix\\n @property-read NumericMatrix $Lᵀ Transpose of lower triangular matrix\\n", Cholesky decomposition,"class Cholesky extends Decomposition{    /** @var NumericMatrix Lower triangular matrix L of A = LLᵀ */    private $L;    /** @var NumericMatrix Transpose of lower triangular matrix of A = LLᵀ */    private $Lᵀ;    /**     * Cholesky constructor     *     * @param NumericMatrix $L  Lower triangular matrix     * @param NumericMatrix $Lᵀ Transpose of lower triangular matrix     */    private function __construct(NumericMatrix $L, NumericMatrix $Lᵀ)    {        $this->L  = $L;        $this->Lᵀ = $Lᵀ;    }    /**     * Decompose a matrix into Cholesky decomposition     * Factory method to create Cholesky decomposition.     *     * @param NumericMatrix $A     *     * @return Cholesky Lower triangular matrix L and transpose Lᵀ of A = LLᵀ     *     * @throws Exception\BadDataException     * @throws Exception\BadParameterException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     */    public static function decompose(NumericMatrix $A): Cholesky    {        if (!$A->isPositiveDefinite()) {            throw new Exception\MatrixException('Matrix must be positive definite for Cholesky decomposition');        }        $m = $A->getM();        $L = MatrixFactory::zero($m, $m)->getMatrix();        for ($j = 0; $j < $m; $j++) {            for ($i = 0; $i < ($j + 1); $i++) {                $∑lⱼₓlᵢₓ = 0;                for ($x = 0; $x < $i; $x++) {                    $∑lⱼₓlᵢₓ += $L[$j][$x] * $L[$i][$x];                }                $L[$j][$i] = ($j === $i)                    ? \sqrt($A[$j][$j] - $∑lⱼₓlᵢₓ)                    : (1 / $L[$i][$i] * ($A[$j][$i] - $∑lⱼₓlᵢₓ));            }        }        $L  = MatrixFactory::create($L);        $Lᵀ = $L->transpose();        return new Cholesky($L, $Lᵀ);    }    /**     * Get L, or Lᵀ matrix     *     * @param string $name     *     * @return NumericMatrix     *     * @throws Exception\MatrixException     */    public function __get(string $name): NumericMatrix    {        switch ($name) {            case 'L':                return $this->L;            case 'LT':            case 'Lᵀ':                return $this->Lᵀ;            default:                throw new Exception\MatrixException(""Cholesky class does not have a gettable property: $name"");        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cholesky_2862, Cholesky constructor\n\n @param NumericMatrix $L  Lower triangular matrix\n @param NumericMatrix $Lᵀ Transpose of lower triangular matrix\n, Cholesky constructor,"    private function __construct(NumericMatrix $L, NumericMatrix $Lᵀ)    {        $this->L  = $L;        $this->Lᵀ = $Lᵀ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cholesky_2863, Decompose a matrix into Cholesky decomposition\n Factory method to create Cholesky decomposition.\n\n @param NumericMatrix $A\n\n @return Cholesky Lower triangular matrix L and transpose Lᵀ of A = LLᵀ\n\n @throws Exception\\BadDataException\n @throws Exception\\BadParameterException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MathException\n @throws Exception\\MatrixException\n @throws Exception\\OutOfBoundsException\n, Decompose a matrix into Cholesky decomposition,"    public static function decompose(NumericMatrix $A): Cholesky    {        if (!$A->isPositiveDefinite()) {            throw new Exception\MatrixException('Matrix must be positive definite for Cholesky decomposition');        }        $m = $A->getM();        $L = MatrixFactory::zero($m, $m)->getMatrix();        for ($j = 0; $j < $m; $j++) {            for ($i = 0; $i < ($j + 1); $i++) {                $∑lⱼₓlᵢₓ = 0;                for ($x = 0; $x < $i; $x++) {                    $∑lⱼₓlᵢₓ += $L[$j][$x] * $L[$i][$x];                }                $L[$j][$i] = ($j === $i)                    ? \sqrt($A[$j][$j] - $∑lⱼₓlᵢₓ)                    : (1 / $L[$i][$i] * ($A[$j][$i] - $∑lⱼₓlᵢₓ));            }        }        $L  = MatrixFactory::create($L);        $Lᵀ = $L->transpose();        return new Cholesky($L, $Lᵀ);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cholesky_2864," Get L, or Lᵀ matrix\n\n @param string $name\n\n @return NumericMatrix\n\n @throws Exception\\MatrixException\n"," Get L, or Lᵀ matrix","    public function __get(string $name): NumericMatrix    {        switch ($name) {            case 'L':                return $this->L;            case 'LT':            case 'Lᵀ':                return $this->Lᵀ;            default:                throw new Exception\MatrixException(""Cholesky class does not have a gettable property: $name"");        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_CircularTest_5878," Test data made with custom R function:\n resultantLength <- function(x) {\n     sinSum = sum(sin(x))\n     cosSum = sum(cos(x))\n     R      = sqrt(sinSum^2 + cosSum^2)\n     return(R)\n }\n @return array [angles, length]\n", Test data made with custom R function:,"    public function dataProviderForResultantLength(): array    {        $π = \M_PI;        return [            [[0, $π], 1.224647e-16],            [[0, 0.5, $π], 1],            [[0, 2 * $π], 2],            [[0, 0.5 * $π], 1.414214],            [[0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], 10.4581],            [[0 * $π, 0.1 * $π, 0.2 * $π, 0.3 * $π, 0.4 * $π, 0.5 * $π, 0.6 * $π, 0.7 * $π, 0.8 * $π, 0.9 * $π, 1 * $π], 6.313752],            [[0, 0, 90], 1.791007],            [[1.4 * $π, 1.7 * $π, 1.75 * $π, 2.54 * $π, 4.32 * $π], 1.532213],            [[5, 60, 340], 0.6201251],            [[5, 50, 150, 250], 3.63869],            [[10, 20, 30], 0.6781431],            [[355, 5, 15], 1.507955],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Circular_3466, Circular statistics (directional statistics)\n https://en.wikipedia.org/wiki/Directional_statistics\n https://ncss-wpengine.netdna-ssl.com/wp-content/themes/ncss/pdf/Procedures/NCSS/Circular_Data_Analysis.pdf\n, Circular statistics (directional statistics),"class Circular{    /**     * Mean of circular quantities (circular mean)     * Mean direction of circular data.     * A mean which is sometimes better-suited for quantities like angles, daytimes, and fractional parts of real numbers.     * https://en.wikipedia.org/wiki/Mean_of_circular_quantities     * _     * α = atan2(∑sin αⱼ, ∑cos αⱼ)     *     * @param  array $angles     *     * @return float mean direction of circular data     */    public static function mean(array $angles): float    {        $∑sinαⱼ = \array_sum(\array_map(            function ($αⱼ) {                return \sin($αⱼ);            },            $angles        ));        $∑cosαⱼ = \array_sum(\array_map(            function ($αⱼ) {                return \cos($αⱼ);            },            $angles        ));        return \atan2($∑sinαⱼ, $∑cosαⱼ);    }    /**     * Resultant length (R)     * https://en.wikipedia.org/wiki/Directional_statistics#Moments     * https://ncss-wpengine.netdna-ssl.com/wp-content/themes/ncss/pdf/Procedures/NCSS/Circular_Data_Analysis.pdf     *     * S  = ∑sin θᵢ     * C  = ∑cos θᵢ     * R² = S² + C²     * R  = √(S² + C²)     *     * @param  array $angles     *     * @return float     */    public static function resultantLength(array $angles): float    {        $S = \array_sum(\array_map(            function ($θᵢ) {                return \sin($θᵢ);            },            $angles        ));        $C = \array_sum(\array_map(            function ($θᵢ) {                return \cos($θᵢ);            },            $angles        ));        $S² = $S ** 2;        $C² = $C ** 2;        $R² = $S² + $C²;        $R  = \sqrt($R²);        return $R;    }    /**     * Mean resultant length - MRL (ρ)     * https://en.wikipedia.org/wiki/Directional_statistics#Moments     * https://ncss-wpengine.netdna-ssl.com/wp-content/themes/ncss/pdf/Procedures/NCSS/Circular_Data_Analysis.pdf     *     * S  = ∑sin θᵢ     * C  = ∑cos θᵢ     * R² = S² + C²     * R  = √(S² + C²)     *     * _    R     * R  = -     *      n     *     *      _     * ρ  = R     *     * @param  array $angles     *     * @return float     */    public static function meanResultantLength(array $angles): float    {        $n = \count($angles);        $R = self::resultantLength($angles);        $ρ = $R / $n;        return $ρ;    }    /**     * Circular variance     * https://en.wikipedia.org/wiki/Directional_statistics#Measures_of_location_and_spread     * https://www.ebi.ac.uk/thornton-srv/software/PROCHECK/nmr_manual/man_cv.html     * https://ncss-wpengine.netdna-ssl.com/wp-content/themes/ncss/pdf/Procedures/NCSS/Circular_Data_Analysis.pdf     *              _     * Var(θ) = 1 - R     * Var(θ) = 1 - ρ     *     * @param  array $angles     *     * @return float     */    public static function variance(array $angles): float    {        $ρ = self::meanResultantLength($angles);        return 1 - $ρ;    }    /**     * Circular standard deviation     * https://en.wikipedia.org/wiki/Directional_statistics#Measures_of_location_and_spread     * https://ncss-wpengine.netdna-ssl.com/wp-content/themes/ncss/pdf/Procedures/NCSS/Circular_Data_Analysis.pdf     *     *       _______     *      /     _     * ν = √ -2ln(R)     *     *       _     * Where R = ρ = mean resultant length     *     * @param  array $angles     *     * @return float     */    public static function standardDeviation(array $angles): float    {        $ρ       = self::meanResultantLength($angles);        $√⟮−2ln⟮R⟯⟯ = \sqrt(-2 * \log($ρ));        return $√⟮−2ln⟮R⟯⟯;    }    /**     * Get a report of all the descriptive circular statistics over a list of angles     * Includes mean, resultant length, mean resultant length, variance, standard deviation.     *     * @param array $angles     *     * @return array [ n, mean, resultant_length, mean_resultant_length, variance, sd]     */    public static function describe(array $angles): array    {        return [            'n'                     => \count($angles),            'mean'                  => self::mean($angles),            'resultant_length'      => self::resultantLength($angles),            'mean_resultant_length' => self::meanResultantLength($angles),            'variance'              => self::variance($angles),            'sd'                    => self::standardDeviation($angles),        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Circular_3467," Mean of circular quantities (circular mean)\\n Mean direction of circular data.\\n A mean which is sometimes better-suited for quantities like angles, daytimes, and fractional parts of real numbers.\\n https://en.wikipedia.org/wiki/Mean_of_circular_quantities\\n _\\n α = atan2(∑sin αⱼ, ∑cos αⱼ)\\n\\n @param  array $angles\\n\\n @return float mean direction of circular data\\n", Mean of circular quantities (circular mean),"    public static function mean(array $angles): float    {        $∑sinαⱼ = \array_sum(\array_map(            function ($αⱼ) {                return \sin($αⱼ);            },            $angles        ));        $∑cosαⱼ = \array_sum(\array_map(            function ($αⱼ) {                return \cos($αⱼ);            },            $angles        ));        return \atan2($∑sinαⱼ, $∑cosαⱼ);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Circular_3470, Circular variance\n https://en.wikipedia.org/wiki/Directional_statistics#Measures_of_location_and_spread\n https://www.ebi.ac.uk/thornton-srv/software/PROCHECK/nmr_manual/man_cv.html\n https://ncss-wpengine.netdna-ssl.com/wp-content/themes/ncss/pdf/Procedures/NCSS/Circular_Data_Analysis.pdf\n              _\n Var(θ) = 1 - R\n Var(θ) = 1 - ρ\n\n @param  array $angles\n\n @return float\n, Circular variance,    public static function variance(array $angles): float    {        $ρ = self::meanResultantLength($angles);        return 1 - $ρ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Circular_3471, Circular standard deviation\n https://en.wikipedia.org/wiki/Directional_statistics#Measures_of_location_and_spread\n https://ncss-wpengine.netdna-ssl.com/wp-content/themes/ncss/pdf/Procedures/NCSS/Circular_Data_Analysis.pdf\n\n       _______\n      /     _\n ν = √ -2ln(R)\n\n       _\n Where R = ρ = mean resultant length\n\n @param  array $angles\n\n @return float\n, Circular standard deviation,    public static function standardDeviation(array $angles): float    {        $ρ       = self::meanResultantLength($angles);        $√⟮−2ln⟮R⟯⟯ = \sqrt(-2 * \log($ρ));        return $√⟮−2ln⟮R⟯⟯;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ClampedCubicSpline_2985," Interpolate\n\n @param callable|array $source The source of our approximation. Should be either\n                           a callback function or a set of arrays. Each array\n                           (point) contains precisely three numbers: x, y, and y'\n                           Example array: [[1,2,1], [2,3,0], [3,4,2]].\n                           Example callback: function($x) {return $x @param number ...$args   (Optional) An additional callback: our first derivative,\n                           and arguments of our callback functions: start,\n                           end, and n.\n                           Example: approximate($source, $derivative, 0, 8, 5).\n                           If $source is a set of points, do not input any\n                           $args. Example: approximate($source).\n\n @return Piecewise         The interpolating (piecewise) polynomial, as an\n                           instance of Piecewise.\n\n @throws Exception\\BadDataException\n", Interpolate,"    public static function interpolate($source, ...$args): Piecewise    {        // Get an array of points from our $source argument        $points = self::getSplinePoints($source, $args);        // Validate input and sort points        self::validateSpline($points, $degree = 1);        $sorted = self::sort($points);        // Descriptive constants        $x  = self::X;        $y  = self::Y;        $y’ = self::Y’;        // Initialize        $n     = \count($sorted);        $k     = $n - 1;        $x₀    = $sorted[0][$x];        $x₁    = $sorted[1][$x];        $f⟮x₀⟯  = $sorted[0][$y];  // y₀        $f⟮x₁⟯  = $sorted[1][$y];  // y₁        $y’₀   = $sorted[0][$y’]; // y₀-prime        $h     = [$x₁ - $x₀];        $a     = [(3 / $h[0]) * ($f⟮x₁⟯ - $f⟮x₀⟯) - 3 * $y’₀];        $μ     = [0.5];        $z     = [$a[0] / (2 * $h[0])];        $c[$k] = 0;        $poly  = [];        $int   = [];        for ($i = 0; $i < $k; $i++) {            $xᵢ    = $sorted[$i][$x];            $xᵢ₊₁  = $sorted[$i + 1][$x];            $a[$i] = $sorted[$i][$y];            $h[$i] = $xᵢ₊₁ - $xᵢ;            if ($i == 0) {                continue;            }            $xᵢ₋₁   = $sorted[$i - 1][$x];            $f⟮xᵢ⟯   = $sorted[$i][$y];   // yᵢ            $f⟮xᵢ₊₁⟯ = $sorted[$i + 1][$y]; // yᵢ₊₁            $f⟮xᵢ₋₁⟯ = $sorted[$i - 1][$y]; // yᵢ₋₁            $α      = (3 / $h[$i]) * ($f⟮xᵢ₊₁⟯ - $f⟮xᵢ⟯) - (3 / $h[$i - 1]) * ($f⟮xᵢ⟯ - $f⟮xᵢ₋₁⟯);            $l      = 2 * ($xᵢ₊₁ - $xᵢ₋₁) - $h[$i - 1] * $μ[$i - 1];            $μ[$i]  = $h[$i] / $l;            $z[$i]  = ($α - $h[$i - 1] * $z[$i - 1]) / $l;        }        $f⟮xₙ⟯   = $sorted[$k][$y];   // yₙ        $f⟮xₙ₋₁⟯ = $sorted[$k - 1][$y]; // yₙ₋₁        $y’ₙ    = $sorted[$k][$y’];  // yₙ-prime        $a[$k]  = 3 * $y’ₙ - 3 * ($f⟮xₙ⟯ - $f⟮xₙ₋₁⟯) / $h[$k - 1];        $l      = $h[$k - 1] * (2 - $μ[$k - 1]);        $z[$k]  = ($a[$k] - $h[$k - 1] * $z[$k - 1]) / $l;        $c[$n]  = $z[$k];        for ($i = $k - 1; $i >= 0; $i--) {            $xᵢ     = $sorted[$i][$x];            $xᵢ₊₁   = $sorted[$i + 1][$x];            $f⟮xᵢ⟯   = $sorted[$i][$y];    // yᵢ            $f⟮xᵢ₊₁⟯ = $sorted[$i + 1][$y];  // yᵢ₊₁            $c[$i]  = $z[$i] - $μ[$i] * $c[$i + 1];            $b[$i]  = ($f⟮xᵢ₊₁⟯ - $f⟮xᵢ⟯) / $h[$i] - $h[$i] * ($c[$i + 1] + 2 * $c[$i]) / 3;            $d[$i]  = ($c[$i + 1] - $c[$i]) / (3 * $h[$i]);            $poly[$i] = new Polynomial([                $d[$i],                $c[$i] - 3 * $d[$i] * $xᵢ,                $b[$i] - 2 * $c[$i] * $xᵢ + 3 * $d[$i] * ($xᵢ ** 2),                $a[$i] - $b[$i] * $xᵢ + $c[$i] * ($xᵢ ** 2) - $d[$i] * ($xᵢ ** 3)            ]);            if ($i == 0) {                $int[$i] = [$xᵢ, $xᵢ₊₁];            } else {                $int[$i] = [$xᵢ, $xᵢ₊₁, true, false];            }        }        $piecewise = new Piecewise($int, $poly);        return $piecewise;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_CombinatoricsTest_5076," Test data produced with Python scipy.special.comb(n, k, exact=True, repetition=False)\\n @return array [n, r, combinations]\\n"," Test data produced with Python scipy.special.comb(n, k, exact=True, repetition=False)","    public function dataProviderForCombinations(): array    {        return [            [10,  0,          1],            [10,  1,         10],            [10,  2,         45],            [10,  3,        120],            [10,  4,        210],            [10,  5,        252],            [10,  6,        210],            [10,  7,        120],            [10,  8,         45],            [10,  9,         10],            [10, 10,          1],            [ 5,  3,         10],            [ 6,  4,         15],            [16,  3,        560],            [20,  3,       1140],            [35, 20, 3247943160],            [35, 25,  183579396],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_CombinatoricsTest_5078," Test data produced with Python scipy.special.comb(n, k, exact=False, repetition=False)\n @return array [n, r, combinations, ε]\n"," Test data produced with Python scipy.special.comb(n, k, exact=False, repetition=False)","    public function dataProviderForCombinationsWithLargeFloatingPointOverflowResult(): array    {        return [            [70, 30, 5.534774005814348e+19, 0],            [100, 50, 1.0089134454556415e+29, 1e14],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_CombinatoricsTest_5083," Test data produced with Python scipy.special.comb(n, k, exact=True, repetition=True)\\n @return array [n, r, combinations]\\n"," Test data produced with Python scipy.special.comb(n, k, exact=True, repetition=True)","    public function dataProviderForCombinationsWithRepetition(): array    {        return [            [10,  0,                  1],            [10,  1,                 10],            [10,  2,                 55],            [10,  3,                220],            [10,  4,                715],            [10,  5,               2002],            [10,  6,               5005],            [10,  7,              11440],            [10,  8,              24310],            [10,  9,              48620],            [10, 10,              92378],            [5,   3,                 35],            [5,   7,                330],            [6,   4,                126],            [16,  3,                816],            [20,  3,               1540],            [21, 20,       137846528820],            [35, 25,  30284005485024837],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_CombinatoricsTest_5085," Test data produced with Python scipy.special.comb(n, k, exact=False, repetition=True)\n @return array [n, r, combinations, ε]\n"," Test data produced with Python scipy.special.comb(n, k, exact=False, repetition=True)","    public function dataProviderForCombinationsWithRepetitionWithLargeFloatingPointOverflowResult(): array    {        return [            [70, 30, 2.0560637875127662e+25, 1e10],            [100, 50, 1.341910727315462e+40, 1e25],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Combinatorics_3046, Combinatorics\\n  - Factorials\\n    - Factorial\\n    - Double factorial\\n    - Rising factorial\\n    - Falling factorial\\n    - Subfactorial\\n  - Permutations and Combinations\\n    - Permutations nPn\\n    - Permutations nPk\\n    - Combinations without repetition nCk\\n    - Combinations with repetition nC′k\\n    - Central binomial coefficient\\n  - Other Combinatorics\\n    - Catalan number\\n    - Lah number\\n    - Multinomial coefficient\\n, Combinatorics,"class Combinatorics{    /** @var bool Combinations with repetition */    public const REPETITION = true;    /**************************************************************************     * Factorials     *************************************************************************/    /**     * Factorial (iterative)     * Represents the number of ways to arrange n things (permutations)     * n! = n(n - 1)(n - 2) ・・・ (n - (n - 1))     *     * @param  int $n     *     * @return float number of permutations of n     *     * @throws Exception\OutOfBoundsException if n < 0     */    public static function factorial(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute factorial of a negative number.');        }        $factorial = 1;        while ($n > 1) {            $factorial *= $n;            --$n;        }        return $factorial;    }    /**     * Double factorial (iterative)     * Also known as semifactorial     *     * The product of all the integers from 1 up to some non-negative integer n     * that have the same parity as n. Denoted by n!!     *     * n‼︎ = n(n - 2)(n - 4) ・・・     *     * For even n:     *       n/2     * n‼︎ =  ∏ (2k) = n(n - 2) ・・・ 2     *       k=1     *     * For odd n:     *     (n+1)/2     * n‼︎ =  ∏ (2k - 1) = n(n - 2) ・・・ 1     *       k=1     *     * 0‼︎ = 1     *     * @param  int $n     *     * @return float     *     * @throws Exception\OutOfBoundsException if n < 0     */    public static function doubleFactorial(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute double factorial of a negative number.');        }        // Zero base case        if ($n === 0) {            return 1;        }        // Even and odd initialization base cases: odd = 1, even = 2        if ($n % 2 == 0) {            $n‼︎ = 2;        } else {            $n‼︎ = 1;        }        while ($n > 2) {            $n‼︎ *= $n;            $n  -= 2;        }        return $n‼︎;    }    /**     * Rising Factorial     * Also known as Pochhammer function, Pochhammer polynomial, ascending factorial,     * rising sequential product, upper factorial.     * https://en.wikipedia.org/wiki/Falling_and_rising_factorials     *     * x⁽ⁿ⁾ = x * (x + 1) * (x + 2) ... (x + n - 1)     *     * @param  float $x     * @param  int   $n     *     * @return float     *     * @throws Exception\OutOfBoundsException if n < 0     */    public static function risingFactorial(float $x, int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute rising factorial of a negative number.');        }        $fact = 1;        while ($n > 0) {            $fact *= $x + $n - 1;            $n--;        }        return $fact;    }    /**     * Falling Factorial     * Also known as descending factorial, falling sequential product, lower factorial.     * https://en.wikipedia.org/wiki/Falling_and_rising_factorials     *     * x₍ᵢ₎ = x * (x - 1) * (x - 2) ... (x - i + 1)     *     * @param  float $x     * @param  int   $n     *     * @return float     *     * @throws Exception\OutOfBoundsException if n < 0     */    public static function fallingFactorial(float $x, int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute falling factorial of a negative number.');        }        if ($n > $x) {            return 0;        }        $fact = 1;        while ($n > 0) {            $fact *= $x - $n + 1;            $n--;        }        return $fact;    }    /**     * Subfactorial - Derangement number (iterative)     * The number of permutations of n objects in which no object appears in its natural place.     *     *         n  (-1)ⁱ      * !n = n! ∑  -----     *        ᵢ₌₀  i!     *     * https://en.wikipedia.org/wiki/Derangement     * http://mathworld.wolfram.com/Subfactorial.html     *     * @param  int $n     *     * @return float number of permutations of n     *     * @throws Exception\OutOfBoundsException if n < 0     */    public static function subfactorial(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute subfactorial of a negative number.');        }        $n！ = self::factorial($n);        $∑  = 0;        for ($i = 0; $i <= $n; $i++) {            $i！ = self::factorial($i);            $∑  += ((-1) ** $i) / $i！;        }        return $n！ * $∑;    }    /**************************************************************************     * Permutations and combinations     *************************************************************************/    /**     * Permutations (ordered arrangements)     *     * nPn - number of permutations of n things, taken n at a time.     * P(n) = nPn = (N)n = n(n - 1)(n - 2) ・・・ (n - (n - 1)) = n!     *     *     * nPk: number of permutations of n things, taking only k of them.     *                    n!     * P(n,k) = nPk =  --------     *                 (n - k)!     *     * @param int $n     * @param int $k (Optional) for nPk permutations     *     * @return float number of permutations of n     *     * @throws Exception\OutOfBoundsException if n is negative or k is larger than n     */    public static function permutations(int $n, int $k = null): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute negative permutations.');        }        if (!\is_null($k) && $k > $n) {            throw new Exception\OutOfBoundsException('k cannot be larger than n.');        }        // nPn: permutations of n things, taken n at a time        if (\is_null($k)) {            return self::factorial($n);        }        // nPk: Permutations of n things taking only k of them        $falling_factorial = 1;        for ($i = $n - $k + 1; $i <= $n; $i++) {            $falling_factorial *= $i;        }        return $falling_factorial;    }    /**     * Combinations - Binomial Coefficient     * Number of ways of picking k unordered outcomes from n possibilities     * n choose k: number of possible combinations of n objects taken k at a time.     *     * Without repetition:     *        (n)       n!     *  nCk = ( ) = ----------     *        (k)   (n - k)!k!     *     * With repetition:     *         (n)   (n + k - 1)!     *  nC'k = ( ) = ------------     *         (k)    (n - 1)!k!     *     * http://mathworld.wolfram.com/BinomialCoefficient.html     * The above formulas are inefficient and can quickly result in floating point overflow.     * Instead, we use the multiplicative formula.     *     *        (n)   nᵏ    n(n - 1)(n - 2)⋯(n - (k - 1)     _ᵏ_  n + 1 - i     *  nCk = ( ) = -- =  ----------------------------   = | |  ---------     *        (k)   k!        k(k - 1)(k - 2)⋯1            ⁱ⁼¹      i     *     * Where the numerator nᵏ is expressed as a falling factorial.     * The numerator gives the number of ways to select a sequence of k distinct objects, retaining the order of selection, from a set of n objects.     * The denominator counts the number of distinct sequences that define the same k-combination when order is disregarded.     * Due to the symmetry of the binomial coefficient with regard to k and n − k,     * calculation may be optimised by setting the upper limit of the product above to the smaller of k and n − k.     * https://en.wikipedia.org/wiki/Binomial_coefficient#Multiplicative_formula     *     * @param  int  $n     * @param  int  $k     * @param  bool $repetition Whether to do n choose k with or without repetitions     *     * @return float number of possible combinations of n objects taken k at a time     *     * @throws Exception\OutOfBoundsException if n is negative; if k is larger than n     */    public static function combinations(int $n, int $k, bool $repetition = false): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute negative combinations.');        }        if (!$repetition && $k > $n) {            throw new Exception\OutOfBoundsException('k cannot be larger than n.');        }        if ($repetition) { // nC'k with repetition            $denominator = $n - 1;            $numerator   = $n + $k - 1;        } else { // nCk without repetition            $denominator = $n - $k;            $numerator   = $n;        }        // The internal self::fallingFactorial() implementation always returns a float.        // Here we maintain int precision as much as possible.        $max = \max($denominator, $k);        $min = \min($denominator, $k);        $falling_factorial = 1;        for ($i = $max + 1; $i <= $numerator; $i++) {            $falling_factorial *= $i;        }        return $falling_factorial / self::factorial($min);    }    /**     * Central Binomial Coefficient     *     * (2n)   (2n)!     * (  ) = ----- for n ≥ 0     * (n )   (n!)²     *     * https://en.wikipedia.org/wiki/Central_binomial_coefficient     *     * @param  int $n     *     * @return float number     *     * @throws Exception\OutOfBoundsException if n < 0     */    public static function centralBinomialCoefficient(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute negative central binomial coefficient.');        }        $⟮2n⟯！ = self::factorial(2 * $n);        $⟮n！⟯² = (self::factorial($n)) ** 2;        return $⟮2n⟯！ / $⟮n！⟯²;    }    /**************************************************************************     * Other Combinatorics     *************************************************************************/    /**     * Catalan number     *     *        1   (2n)     * Cn = ----- (  ) for n ≥ 0     *      n + 1 (n )     *     * https://en.wikipedia.org/wiki/Catalan_number     *     * @param  int $n     *     * @return float number     *     * @throws Exception\OutOfBoundsException if n < 0     */    public static function catalanNumber(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute negative catalan number.');        }        return (1 / ($n + 1)) * self::centralBinomialCoefficient($n);    }    /**     * Lah number     * Coefficients expressing rising factorials in terms of falling factorials.     * https://en.wikipedia.org/wiki/Lah_number     *     *           / n - 1 \  n!     * L(n,k) = |         | --     *           \ k - 1 /  k!     *     * @param int $n     * @param int $k     *     * @return float     *     * @throws Exception\OutOfBoundsException if n or k < 1 or n < k     */    public static function lahNumber(int $n, int $k): float    {        if ($n < 1 || $k < 1) {            throw new Exception\OutOfBoundsException(""n and k must be < 1 for Lah Numbers"");        }        if ($n < $k) {            throw new Exception\OutOfBoundsException(""n must be >= k for Lah Numbers"");        }        $nCk = self::combinations($n - 1, $k - 1);        $n！ = self::factorial($n);        $k！ = self::factorial($k);        return $nCk * ($n！ / $k！);    }    /**     * Multinomial coefficient (Multinomial Theorem)     * Finds the number of divisions of n items into r distinct nonoverlapping subgroups of sizes k₁, k₂, etc.     *     *       n!       (n₁ + n₂ + ⋯ + nk)!     *   ---------- = -------------------     *   k₁!k₂!⋯km!       k₁!k₂!⋯km!     *     * http://mathworld.wolfram.com/MultinomialCoefficient.html     * https://en.wikipedia.org/wiki/Multinomial_theorem     *     * @param  int[] $groups Sizes of each subgroup     *     * @return float Number of divisions of n items into r distinct nonoverlapping subgroups     *     * @throws Exception\OutOfBoundsException     */    public static function multinomial(array $groups): float    {        /** @var int $n */        $n            = \array_sum($groups);        $n！          = self::factorial($n);        $k₁！k₂！⋯km！ = \array_product(\array_map([Combinatorics::class, 'factorial'], $groups));        return $n！ / $k₁！k₂！⋯km！;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Combinatorics_3049," Rising Factorial\\n Also known as Pochhammer function, Pochhammer polynomial, ascending factorial,\\n rising sequential product, upper factorial.\\n https://en.wikipedia.org/wiki/Falling_and_rising_factorials\\n\\n x⁽ⁿ⁾ = x \\n @param  float $x\\n @param  int   $n\\n\\n @return float\\n\\n @throws Exception\\\\OutOfBoundsException if n < 0\\n", Rising Factorial,"    public static function risingFactorial(float $x, int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute rising factorial of a negative number.');        }        $fact = 1;        while ($n > 0) {            $fact *= $x + $n - 1;            $n--;        }        return $fact;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Combinatorics_3050," Falling Factorial\\n Also known as descending factorial, falling sequential product, lower factorial.\\n https://en.wikipedia.org/wiki/Falling_and_rising_factorials\\n\\n x₍ᵢ₎ = x \\n @param  float $x\\n @param  int   $n\\n\\n @return float\\n\\n @throws Exception\\\\OutOfBoundsException if n < 0\\n", Falling Factorial,"    public static function fallingFactorial(float $x, int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute falling factorial of a negative number.');        }        if ($n > $x) {            return 0;        }        $fact = 1;        while ($n > 0) {            $fact *= $x - $n + 1;            $n--;        }        return $fact;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Combinatorics_3052, Central Binomial Coefficient\n\n (2n)   (2n)!\n (  ) = ----- for n ≥ 0\n (n )   (n!)²\n\n https://en.wikipedia.org/wiki/Central_binomial_coefficient\n\n @param  int $n\n\n @return float number\n\n @throws Exception\\OutOfBoundsException if n < 0\n, Central Binomial Coefficient,    public static function centralBinomialCoefficient(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute negative central binomial coefficient.');        }        $⟮2n⟯！ = self::factorial(2 * $n);        $⟮n！⟯² = (self::factorial($n)) ** 2;        return $⟮2n⟯！ / $⟮n！⟯²;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ComplexAxiomsTest_4736," Tests of complex number axioms\\n These tests don't test specific functions,\\n but rather complex number axioms which in term make use of multiple functions.\\n If all the complex number math is implemented properly, these tests should\\n all work out according to the axioms.\\n\\n Axioms tested:\\n  - Commutativity\\n    - z + w = w + z\\n    - zw = wz\\n  - Associativity\\n    - z + (u + v) = (z + u) + v\\n    - z(uv) = (zu)v\\n  - Distributed Law\\n    - z(u + v) = zu + zv\\n  - Identity\\n    - z + 0 = z\\n    - z   - Inverse\\n    - (∀a)(∃b) a + b = 0\\n", Tests of complex number axioms,"class ComplexNumberAxiomsTest extends \PHPUnit\Framework\TestCase{    /**     * @test Axiom: z + w = w + z     * Commutativity of addition.     * @dataProvider dataProviderForTwoComplexNumbers     * @param        int $r₁     * @param        int $i₁     * @param        int $r₂     * @param        int $i₂     * @throws       \Exception     */    public function testCommutativityOfAddition(int $r₁, int $i₁, int $r₂, int $i₂)    {        // Given        $z = new Complex($r₁, $i₁);        $w = new Complex($r₂, $i₂);        // When        $z＋w = $z->add($w);        $w＋z = $w->add($z);        $this->assertTrue($z＋w->equals($w＋z));        $this->assertTrue($w＋z->equals($z＋w));        $this->assertEquals($z＋w->r, $w＋z->r);        $this->assertEquals($z＋w->i, $w＋z->i);    }    /**     * @test Axiom: zw = wz     * Commutativity of multiplication.     * @dataProvider dataProviderForTwoComplexNumbers     * @param        int $r₁     * @param        int $i₁     * @param        int $r₂     * @param        int $i₂     * @throws       \Exception     */    public function testCommutativityOfMultiplication(int $r₁, int $i₁, int $r₂, int $i₂)    {        // Given        $z = new Complex($r₁, $i₁);        $w = new Complex($r₂, $i₂);        // When        $zw = $z->multiply($w);        $wz = $w->multiply($z);        $this->assertTrue($zw->equals($wz));        $this->assertTrue($wz->equals($zw));        $this->assertEquals($zw->r, $wz->r);        $this->assertEquals($zw->i, $wz->i);    }    /**     * @test Axiom: z + (u + v) = (z + u) + v     * Associativity of Addition.     * @dataProvider dataProviderForThreeComplexNumbers     * @param        int $r₁     * @param        int $i₁     * @param        int $r₂     * @param        int $i₂     * @param        int $r₃     * @param        int $i₃     * @throws       \Exception     */    public function testAssociativityOfAddition(int $r₁, int $i₁, int $r₂, int $i₂, int $r₃, int $i₃)    {        // Given        $z = new Complex($r₁, $i₁);        $u = new Complex($r₂, $i₂);        $v = new Complex($r₃, $i₃);        // When        $z⟮u ＋ v⟯ = $z->add($u->add($v));        $⟮z ＋ u⟯v = $z->add($u)->add($v);        $this->assertTrue($z⟮u ＋ v⟯->equals($⟮z ＋ u⟯v));        $this->assertTrue($⟮z ＋ u⟯v->equals($z⟮u ＋ v⟯));        $this->assertEquals($z⟮u ＋ v⟯->r, $⟮z ＋ u⟯v->r);        $this->assertEquals($z⟮u ＋ v⟯->i, $⟮z ＋ u⟯v->i);    }    /**     * @test Axiom: z(uv) = (zu)v     * Associativity of Multiplication.     * @dataProvider dataProviderForThreeComplexNumbers     * @param        int $r₁     * @param        int $i₁     * @param        int $r₂     * @param        int $i₂     * @param        int $r₃     * @param        int $i₃     * @throws       \Exception     */    public function testAssociativityOfMultiplication(int $r₁, int $i₁, int $r₂, int $i₂, int $r₃, int $i₃)    {        // Given        $z = new Complex($r₁, $i₁);        $u = new Complex($r₂, $i₂);        $v = new Complex($r₃, $i₃);        // When        $z⟮uv⟯ = $z->multiply($u->multiply($v));        $⟮zu⟯v = $z->multiply($u)->multiply($v);        $this->assertTrue($z⟮uv⟯->equals($⟮zu⟯v));        $this->assertTrue($⟮zu⟯v->equals($z⟮uv⟯));        $this->assertEquals($z⟮uv⟯->r, $⟮zu⟯v->r);        $this->assertEquals($z⟮uv⟯->i, $⟮zu⟯v->i);    }    /**     * @test Axiom: z(u + v) = zu + zv     * Distributed Law.     * @dataProvider dataProviderForThreeComplexNumbers     * @param        int $r₁     * @param        int $i₁     * @param        int $r₂     * @param        int $i₂     * @param        int $r₃     * @param        int $i₃     * @throws       \Exception     */    public function testDistributedLaw(int $r₁, int $i₁, int $r₂, int $i₂, int $r₃, int $i₃)    {        // Given        $z = new Complex($r₁, $i₁);        $u = new Complex($r₂, $i₂);        $v = new Complex($r₃, $i₃);        // When        $z⟮u ＋ v⟯ = $z->multiply($u->add($v));        $zu ＋ zv = $z->multiply($u)->add($z->multiply($v));        $this->assertTrue($z⟮u ＋ v⟯->equals($zu ＋ zv));        $this->assertTrue($zu ＋ zv->equals($z⟮u ＋ v⟯));        $this->assertEquals($z⟮u ＋ v⟯->r, $zu ＋ zv->r);        $this->assertEquals($z⟮u ＋ v⟯->i, $zu ＋ zv->i);    }    /**     * @test Axiom: z + 0 = z     * Additive identity     * @dataProvider dataProviderForOneComplexNumber     * @param        int $r     * @param        int $i     * @throws       \Exception     */    public function testAdditiveIdentity(int $r, int $i)    {        // Given        $z = new Complex($r, $i);        // When        $z＋0 = $z->add(0);        $this->assertTrue($z＋0->equals($z));        $this->assertTrue($z->equals($z＋0));        $this->assertEquals($z->r, $z＋0->r);        $this->assertEquals($z->i, $z＋0->i);    }    /**     * @test Axiom: z * 1 = z     * Multiplicative identity     * @dataProvider dataProviderForOneComplexNumber     * @param        int $r     * @param        int $i     * @throws       \Exception     */    public function testMultiplicativeIdentity(int $r, int $i)    {        // Given        $z = new Complex($r, $i);        // When        $z1 = $z->multiply(1);        $this->assertTrue($z1->equals($z));        $this->assertTrue($z->equals($z1));        $this->assertEquals($z->r, $z1->r);        $this->assertEquals($z->i, $z1->i);    }    /**     * @test Axiom: (∀a)(∃b) a + b = 0     * Additive inverse.     * @dataProvider dataProviderForOneComplexNumber     * @param        int $r     * @param        int $i     * @throws       \Exception     */    public function testAdditiveInverse(int $r, int $i)    {        // Given        $a = new Complex($r, $i);        $b = new Complex(-$r, -$i);        // When        $a＋b = $a->add($b);        $this->assertEquals(0, $a＋b->r);        $this->assertEquals(0, $a＋b->i);    }    public function dataProviderForOneComplexNumber(): array    {        return [            [0, 0],            [0, 0],            [0, 0],            [0, 1],            [1, 0],            [1, 0],            [1, 0],            [1, 1],            [1, 1],            [1, 1],            [1, 1],            [2, 3],            [4, 5],            [7, 4],            [-5, 2],            [3, -6],            [-3, -5],            [4, 5],            [3, 6],            [12, 65],            [54, -4],            [-3, 34],        ];    }    public function dataProviderForTwoComplexNumbers(): array    {        return [            [0, 0, 0, 0],            [0, 0, 0, 1],            [0, 0, 1, 0],            [0, 1, 0, 0],            [1, 0, 0, 0],            [1, 0, 0, 1],            [1, 0, 1, 0],            [1, 1, 0, 0],            [1, 1, 0, 1],            [1, 1, 1, 0],            [1, 1, 1, 1],            [2, 3, 4, 5],            [4, 5, 3, 7],            [7, 4, 5, 1],            [-5, 2, 7, 2],            [3, -6, -5, 3],            [-3, -5, -2, -7],            [4, 5, -6, -3],            [3, 6, -4, 43],            [12, 65, 32, -32],            [54, -4, 43, -96],            [-3, 34, 12, -4],        ];    }    public function dataProviderForThreeComplexNumbers(): array    {        return [            [0, 0, 0, 0, 0, 0],            [0, 0, 0, 1, 0, 0],            [0, 0, 1, 0, 0, 0],            [0, 1, 0, 0, 0, 0],            [1, 0, 0, 0, 1, 0],            [1, 0, 0, 1, 0, 1],            [1, 0, 1, 0, 0, 0],            [1, 1, 0, 0, 0, 0],            [1, 1, 0, 1, 1, 1],            [1, 1, 1, 0, 0, 0],            [1, 1, 1, 1, 0, 0],            [2, 3, 4, 5, 0, 0],            [4, 5, 3, 7, 0, 1],            [7, 4, 5, 1, 1, 0],            [-5, 2, 7, 2, 5, 3],            [3, -6, -5, 3, 5, 3],            [-3, -5, -2, -7, 5, 3],            [4, 5, -6, -3, 5, 3],            [3, 6, -4, 43, 5, 3],            [12, 65, 32, -32, 5, 3],            [54, -4, 43, -96, 5, 3],            [-3, 34, 12, -4, 5, 3],            [1, 2, 3, 4, 5, 6],            [6, 5, 4, 3, 2, 1],            [1, -2, 3, -4, 5, -6],            [-6, 5, -4, 3, -2, 1],            [345, 765, 235, 123, 765, 456],        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ComplexMatrix_2611," Conjugate Transpose - Aᴴ, also denoted as A\\n Take the transpose and then take the complex conjugate of each complex-number entry.\\n\\n https://en.wikipedia.org/wiki/Conjugate_transpose\\n\\n @return ComplexMatrix\\n"," Conjugate Transpose - Aᴴ, also denoted as A",    public function conjugateTranspose(): Matrix    {        return $this->transpose()->map(            function (Complex $c) {                return $c->complexConjugate();            }        );    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2919, Creates 0 + 0i\n\n @return Complex\n, Creates 0 + 0i,"    public static function createZeroValue(): ObjectArithmetic    {        return new Complex(0, 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2923, The absolute value (magnitude) of a complex number (modulus)\n https://en.wikipedia.org/wiki/Complex_number#Absolute_value_and_argument\n\n If z = a + bi\n        _______\n |z| = √a² + b²\n\n @return number\n, The absolute value (magnitude) of a complex number (modulus),    public function abs()    {        return \sqrt($this->r ** 2 + $this->i ** 2);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2924," The argument (phase) of a complex number\\n The argument of z is the angle of the radius OP with the positive real axis, and is written as arg(z).\\n https://en.wikipedia.org/wiki/Complex_number#Absolute_value_and_argument\\n\\n If z = a + bi\\n arg(z) = atan(b, a)\\n\\n @return number\\n", The argument (phase) of a complex number,"    public function arg()    {        return \atan2($this->i, $this->r);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2925," The square root of a complex number\\n https://en.wikipedia.org/wiki/Complex_number#Square_root\\n\\n The roots of a + bi (with b ≠ 0) are ±(γ + δi), where\\n\\n         ____________\\n        /     _______\\n       / a + √a² + b²\\n γ =  /  ------------\\n     √         2\\n\\n               ____________\\n              /      _______\\n             / -a + √a² + b²\\n δ = sgn(b) /  -------------\\n           √         2\\n\\n The square root returns the positive root.\\n\\n @return Complex (positive root)\\n", The square root of a complex number,    public function sqrt(): Complex    {        return $this->roots()[0];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2926," The roots of a complex number\n https://en.wikipedia.org/wiki/Complex_number#Square_root\n\n The roots of a + bi (with b ≠ 0) are ±(γ + δi), where\n\n         ____________\n        /     _______\n       / a + √a² + b²\n γ =  /  ------------\n     √         2\n\n               ____________\n              /      _______\n             / -a + √a² + b²\n δ = sgn(b) /  -------------\n           √         2\n\n\n @return array Complex[] (two roots)\n", The roots of a complex number,"    public function roots(): array    {        $sgn = Special::sgn($this->i) >= 0 ? 1 : -1;        $γ   = \sqrt(($this->r + $this->abs()) / 2);        $δ   = $sgn * \sqrt((-$this->r + $this->abs()) / 2);        $z₁ = new Complex($γ, $δ);        $z₂ = new Complex(-$γ, -$δ);        return [$z₁, $z₂];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2927, The inverse of a complex number (reciprocal)\\n\\n https://en.wikipedia.org/wiki/Complex_number#Reciprocal\\n\\n @return Complex\\n\\n @throws Exception\\\\BadDataException if = to 0 + 0i\\n, The inverse of a complex number (reciprocal),    public function inverse(): Complex    {        if ($this->r == 0 && $this->i == 0) {            throw new Exception\BadDataException('Cannot take inverse of 0 + 0i');        }        return $this->complexConjugate()->divide($this->abs() ** 2);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2928, Negate the complex number\\n Switches the signs of both the real and imaginary parts.\\n\\n @return Complex\\n, Negate the complex number,"    public function negate(): Complex    {        return new Complex(-$this->r, -$this->i);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2929, Polar form\n https://en.wikipedia.org/wiki/Complex_number#Polar_form\n\n z = a + bi = r(cos(θ) + i  sin(θ))\n Where\n  r = |z|\n  θ = arg(z) (in radians)\n\n @return Complex\n, Polar form,"    public function polarForm(): Complex    {        $r = $this->abs();        $θ = $this->arg();        return new Complex($r * \cos($θ), $r * \sin($θ));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2930, Complex addition\\n https://en.wikipedia.org/wiki/Complex_number#Addition_and_subtraction\\n\\n (a + bi) + (c + di) = (a + c) + (b + d)i\\n\\n @param mixed $c\\n\\n @return Complex\\n\\n @throws Exception\\\\IncorrectTypeException if the argument is not numeric or Complex.\\n, Complex addition,"    public function add($c): Complex    {        if (\is_numeric($c)) {            $r = $this->r + $c;            $i = $this->i;        } elseif ($c instanceof Complex) {            $r = $this->r + $c->r;            $i = $this->i + $c->i;        } else {            throw new Exception\IncorrectTypeException('Argument must be real or complex number');        }        return new Complex($r, $i);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Continuous_3085," CDF above - Probability of being above x to ∞\\n Area under a continuous distribution, that lies above a specified point.\\n\\n P(above) = 1 - CDF(x)\\n\\n @param float $x\\n\\n @return float\\n", CDF above - Probability of being above x to ∞,    public function above(float $x): float    {        return 1 - $this->cdf($x);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_CorrelationTest_5900," Data generated with R: cor(x, y, method=""pearson)\\n @return array [x, y, ppc]\\n"," Data generated with R: cor(x, y, method=""pearson)","    public function dataProviderForPopulationCorrelationCoefficient(): array    {        return [            [                [1, 2, 4, 5, 8],                [5, 20, 40, 80, 100],                0.9684134            ],            [                [1, 2, 4, 5, 8],                [5, 20, 30, 50, 120],                0.963586            ],            [                [106, 100, 86, 101, 99, 103, 97, 113, 112, 110],                [7, 27, 2, 50, 28, 29, 20, 12, 6, 17],                -0.07021633            ],            [                [0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10],                [1.6, 2.7, 4.5, 7.4, 12.2, 20.1, 33.1, 54.6, 90, 148.4, 244.7, 403.4, 665.1, 1096.6, 1808.0, 2981.0, 4914.8, 8103.1, 13359.7, 22026.5],                0.6990668            ],            [                [679.10, 818.93, 302.38, 1149.60, 573.14, 1034.55, 633.25, 1095.42, 1122.58, 686.51, 1172.84, 593.70, 1247.95, 533.99, 605.51, 696.96, 1282.95, 531.16, 788.36, 956.06, 1149.38, 1069.82, 1124.17],                [.80, 1.93, .97, 11.80, 1.41, 2.41, 3.40, .98, 2.46, .26, 9.97, .37, 6.70, .09, 1.72, 6.76, 10.27, .13, 2.87, 3.10, .96, 3.77, 7.09],                0.6323985            ],            [                [1760, 2040, 2440, 2550, 2730, 2740, 3010, 3080, 3370, 3740, 4910, 5090, 5090, 5380, 5850, 6730, 6990, 7960],                [529, 566, 473, 461, 465, 532, 484, 527, 488, 485, 478, 434, 468, 449, 425, 389, 421, 416],                -0.8203196            ],            [                [99, 120, 98, 102, 123, 105, 85, 110, 117, 90],                [2, 0, 25, 45, 14, 20, 15, 19, 22, 4],                -0.03609958            ],            [                [35, 23, 47, 17, 10, 43, 9, 6, 28],                [30, 33, 45, 23, 8, 49, 12, 4, 31],                0.9498663            ],            [                [50, 175, 270, 375, 425, 580, 710, 790, 890, 980],                [1.80, 1.20, 2.00, 1.00, 1.00, 1.20, 0.80, 0.60, 1.00, 0.85],                -0.7271081            ],            [                [2.5, 2.5, 2.5, 3, 3, 2.5, 2.25, 2.75, 2, 2.75],                [2.25, 2.75, 2.75, 2.25, 2.25, 3.25, 2, 2, 2.75, 1.25],                -0.3676942            ],            [                [2.5, 2.5, 2.5, 3, 3, 2.5, 2.25, 2.75, 2, 2.75],                [6, 7, 8, 3, 6, 5, 4, 6, 6, 4],                -0.264683            ],            [                [2.5, 2.5, 2.5, 3, 3, 2.5, 2.25, 2.75, 2, 2.75],                [4, 6, 3, 2, 9, 7, 8, 9, 5, 4],                -0.003555568            ],            [                [2.25, 2.75, 2.75, 2.25, 2.25, 3.25, 2, 2, 2.75, 1.25],                [6, 7, 8, 3, 6, 5, 4, 6, 6, 4],                0.4640445            ],            [                [2.25, 2.75, 2.75, 2.25, 2.25, 3.25, 2, 2, 2.75, 1.25],                [4, 6, 3, 2, 9, 7, 8, 9, 5, 4],                0.004007348            ],            [                [6, 7, 8, 3, 6, 5, 4, 6, 6, 4],                [4, 6, 3, 2, 9, 7, 8, 9, 5, 4],                0.1032071            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_CorrelationTest_5913," Data generated with R: cor(X, Y, method=""spearman"")\\n @return array [X, Y, ρ]\\n"," Data generated with R: cor(X, Y, method=""spearman"")","    public function dataProviderForSpearmansRho(): array    {        return [            [                [56, 75, 45, 71, 62, 64, 58, 80, 76, 61],                [66, 70, 40, 60, 65, 56, 59, 77, 67, 63],                0.6727273            ],            [                [1, 2, 3, 4, 5],                [2, 3, 4, 4, 6],                0.9746794            ],            [                [4, 10, 3, 1, 9, 2, 6, 7, 8, 5],                [5, 8, 6, 2, 10, 3, 9, 4, 7, 1],                0.6848485            ],            [                [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],                [26, 25, 18, 33, 70, 55, 50, 49, 70, 80, 76, 74, 73],                0.8583227            ],            [                [1, 5, 2, 5, 2],                [2, 2, 3, 1, 3],                -0.4722222            ],            // Wikipedia test case (https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient)            [                [106, 100, 86, 101, 99, 103, 97, 113, 112, 110],                [7, 27, 2, 50, 28, 29, 20, 12, 6, 17],                -0.1757576            ],            // http://www.statstutor.ac.uk/resources/uploaded/spearmans.pdf            [                [0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10],                [1.6, 2.7, 4.5, 7.4, 12.2, 20.1, 33.1, 54.6, 90, 148.4, 244.7, 403.4, 665.1, 1096.6, 1808.0, 2981.0, 4914.8, 8103.1, 13359.7, 22026.5],                1            ],            [                [679.10, 818.93, 302.38, 1149.60, 573.14, 1034.55, 633.25, 1095.42, 1122.58, 686.51, 1172.84, 593.70, 1247.95, 533.99, 605.51, 696.96, 1282.95, 531.16, 788.36, 956.06, 1149.38, 1069.82, 1124.17],                [.80, 1.93, .97, 11.80, 1.41, 2.41, 3.40, .98, 2.46, .26, 9.97, .37, 6.70, .09, 1.72, 6.76, 10.27, .13, 2.87, 3.10, .96, 3.77, 7.09],                0.708498            ],            // http://www.biostathandbook.com/spearman.html            [                [1760, 2040, 2440, 2550, 2730, 2740, 3010, 3080, 3370, 3740, 4910, 5090, 5090, 5380, 5850, 6730, 6990, 7960],                [529, 566, 473, 461, 465, 532, 484, 527, 488, 485, 478, 434, 468, 449, 425, 389, 421, 416],                -0.7630357            ],            // http://www.real-statistics.com/correlation/spearmans-rank-correlation/            [                [99, 120, 98, 102, 123, 105, 85, 110, 117, 90],                [2, 0, 25, 45, 14, 20, 15, 19, 22, 4],                -0.1151515            ],            // https://www.worldsupporter.org/en/chapter/66927-example-how-calculate-spearman-correlation            [                [35, 23, 47, 17, 10, 43, 9, 6, 28],                [30, 33, 45, 23, 8, 49, 12, 4, 31],                0.9            ],            [                [50, 175, 270, 375, 425, 580, 710, 790, 890, 980],                [1.80, 1.20, 2.00, 1.00, 1.00, 1.20, 0.80, 0.60, 1.00, 0.85],                -0.7570127            ],            // Github issue 380 test cases            [                [2.5, 2.5, 2.5, 3, 3, 2.5, 2.25, 2.75, 2, 2.75],                [2.25, 2.75, 2.75, 2.25, 2.25, 3.25, 2, 2, 2.75, 1.25],                -0.3721858            ],            [                [2.5, 2.5, 2.5, 3, 3, 2.5, 2.25, 2.75, 2, 2.75],                [6, 7, 8, 3, 6, 5, 4, 6, 6, 4],                -0.254073            ],            [                [2.5, 2.5, 2.5, 3, 3, 2.5, 2.25, 2.75, 2, 2.75],                [4, 6, 3, 2, 9, 7, 8, 9, 5, 4],                -0.01266457            ],            [                [2.25, 2.75, 2.75, 2.25, 2.25, 3.25, 2, 2, 2.75, 1.25],                [6, 7, 8, 3, 6, 5, 4, 6, 6, 4],                0.4709775            ],            [                [2.25, 2.75, 2.75, 2.25, 2.25, 3.25, 2, 2, 2.75, 1.25],                [4, 6, 3, 2, 9, 7, 8, 9, 5, 4],                -0.1410998            ],            [                [6, 7, 8, 3, 6, 5, 4, 6, 6, 4],                [4, 6, 3, 2, 9, 7, 8, 9, 5, 4],                0.1009871            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Correlation_3474," Population Covariance\n A measure of how much two random variables change together.\n Average product of their deviations from their respective means.\n The population covariance is defined in terms of the population means μx, μy\n https://en.wikipedia.org/wiki/Covariance\n\n cov(X, Y) = σxy = E[⟮X - μx⟯⟮Y - μy⟯]\n\n                   ∑⟮xᵢ - μₓ⟯⟮yᵢ - μy⟯\n cov(X, Y) = σxy = -----------------\n                           N\n\n @param array $X values for random variable X\n @param array $Y values for random variable Y\n\n @return float\n\n @throws Exception\\BadDataException if X and Y do not have the same number of elements\n", Population Covariance,"    public static function populationCovariance(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('X and Y must have the same number of elements.');        }        $μₓ = Average::mean($X);        $μy = Average::mean($Y);        $∑⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ = \array_sum(\array_map(            function ($xᵢ, $yᵢ) use ($μₓ, $μy) {                return ( $xᵢ - $μₓ ) * ( $yᵢ - $μy );            },            $X,            $Y        ));        $N = \count($X);        return $∑⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ / $N;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Correlation_3475," Sample covariance\\n A measure of how much two random variables change together.\\n Average product of their deviations from their respective means.\\n The population covariance is defined in terms of the sample means x, y\\n https://en.wikipedia.org/wiki/Covariance\\n\\n cov(X, Y) = Sxy = E[⟮X - x⟯⟮Y - y⟯]\\n\\n                   ∑⟮xᵢ - x⟯⟮yᵢ - y⟯\\n cov(X, Y) = Sxy = ---------------\\n                         n - 1\\n\\n @param array $X values for random variable X\\n @param array $Y values for random variable Y\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if X and Y do not have the same number of elements\\n", Sample covariance,"    public static function sampleCovariance(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('X and Y must have the same number of elements.');        }        $x = Average::mean($X);        $y = Average::mean($Y);        $∑⟮xᵢ − x⟯⟮yᵢ − y⟯ = \array_sum(\array_map(            function ($xᵢ, $yᵢ) use ($x, $y) {                return ( $xᵢ - $x ) * ( $yᵢ - $y );            },            $X,            $Y        ));        $n = \count($X);        return $∑⟮xᵢ − x⟯⟮yᵢ − y⟯ / ($n - 1);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Correlation_3477," Population correlation coefficient\n Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r)\n\n A normalized measure of the linear correlation between two variables X and Y,\n giving a value between +1 and −1 inclusive, where 1 is total positive correlation,\n 0 is no correlation, and −1 is total negative correlation.\n It is widely used in the sciences as a measure of the degree of linear dependence\n between two variables.\n https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n\n The correlation coefficient of two variables in a data sample is their covariance\n divided by the product of their individual standard deviations.\n\n        cov(X,Y)\n ρxy = ----------\n         σx σy\n\n  conv(X,Y) is the population covariance\n  σx is the population standard deviation of X\n  σy is the population standard deviation of Y\n\n @param array $X values for random variable X\n @param array $Y values for random variable Y\n\n @return float\n\n @throws Exception\\BadDataException\n @throws Exception\\OutOfBoundsException\n", Population correlation coefficient,"    public static function populationCorrelationCoefficient(array $X, array $Y): float    {        $cov⟮X，Y⟯ = self::populationCovariance($X, $Y);        $σx      = Descriptive::standardDeviation($X, true);        $σy      = Descriptive::standardDeviation($Y, true);        return $cov⟮X，Y⟯ / ( $σx * $σy );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DescriptiveTest_5919," Data provider for range test\n @return array [ [ numbers ], range ]\n", Data provider for range test,"    public function dataProviderForRange(): array    {        return [            [ [ 1, 1, 1 ], 0 ],            [ [ 1, 1, 2 ], 1 ],            [ [ 1, 2, 1 ], 1 ],            [ [ 8, 4, 3 ], 5 ],            [ [ 9, 7, 8 ], 2 ],            [ [ 13, 18, 13, 14, 13, 16, 14, 21, 13 ], 8 ],            [ [ 1, 2, 4, 7 ], 6 ],            [ [ 8, 9, 10, 10, 10, 11, 11, 11, 12, 13 ], 5 ],            [ [ 6, 7, 8, 10, 12, 14, 14, 15, 16, 20 ], 14 ],            [ [ 9, 10, 11, 13, 15, 17, 17, 18, 19, 23 ], 14 ],            [ [ 12, 14, 16, 20, 24, 28, 28, 30, 32, 40 ], 28 ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DescriptiveTest_5922," Data provider for midrange test\\n @return array [ [ numbers ], range ]\\n", Data provider for midrange test,"    public function dataProviderForMidrange(): array    {        return [            [ [ 1, 1, 1 ], 1 ],            [ [ 1, 1, 2 ], 1.5 ],            [ [ 1, 2, 1 ], 1.5 ],            [ [ 8, 4, 3 ], 5.5 ],            [ [ 9, 7, 8 ], 8 ],            [ [ 13, 18, 13, 14, 13, 16, 14, 21, 13 ], 17 ],            [ [ 1, 2, 4, 7 ], 4 ],            [ [ 8, 9, 10, 10, 10, 11, 11, 11, 12, 13 ], 10.5 ],            [ [ 6, 7, 8, 10, 12, 14, 14, 15, 16, 20 ], 13 ],            [ [ 9, 10, 11, 13, 15, 17, 17, 18, 19, 23 ], 16 ],            [ [ 12, 14, 16, 20, 24, 28, 28, 30, 32, 40 ], 26 ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DescriptiveTest_5925," Data provider for population variance test\n @return array [ [ numbers ], variance ]\n", Data provider for population variance test,"    public function dataProviderForPopulationVariance(): array    {        return [            [ [ -10, 0, 10, 20, 30 ], 200 ],            [ [ 8, 9, 10, 11, 12 ], 2 ],            [ [ 600, 470, 170, 430, 300 ], 21704 ],            [ [ -5, 1, 8, 7, 2], 21.84 ],            [ [ 3, 7, 34, 25, 46, 7754, 3, 6 ], 6546331.937 ],            [ [ 4, 6, 2, 2, 2, 2, 3, 4, 1, 3 ], 1.89 ],            [ [ -3432, 5, 23, 9948, -74 ], 20475035.6 ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DescriptiveTest_5928," Data provider for sample variance test\\n @return array [ [ numbers ], variance ]\\n", Data provider for sample variance test,"    public function dataProviderForSampleVariance(): array    {        return [            [ [ -10, 0, 10, 20, 30 ], 250 ],            [ [ 8, 9, 10, 11, 12 ], 2.5 ],            [ [ 600, 470, 170, 430, 300 ], 27130 ],            [ [ -5, 1, 8, 7, 2 ], 27.3 ],            [ [ 3, 7, 34, 25, 46, 7754, 3, 6 ], 7481522.21429 ],            [ [ 4, 6, 2, 2, 2, 2, 3, 4, 1, 3 ], 2.1 ],            [ [ -3432, 5, 23, 9948, -74 ], 25593794.5 ],            [ [ 3, 21, 98, 203, 17, 9 ],  6219.9 ],            [ [ 170, 300, 430, 470, 600 ], 27130 ],            [ [ 1550, 1700, 900, 850, 1000, 950 ], 135416.66668 ],            [ [ 1245, 1255, 1654, 1547, 1787, 1989, 1878, 2011, 2145, 2545, 2656 ], 210804.29090909063 ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DescriptiveTest_5933," Data provider for weighted sample variance test\\n @return array [ [ numbers, weights ], variance ]\\n", Data provider for weighted sample variance test,"    public function dataProviderForWeightedSampleVarianceUnbiased(): array    {        return [            [ [ -10, 0, 10, 20, 30 ], [1, 1, 1, 1, 1], 250 ],            [ [ 8, 9, 10, 11, 12 ], [1, 1, 1, 1, 1], 2.5 ],            [ [ 600, 470, 170, 430, 300 ], [1, 1, 1, 1, 1], 27130 ],            [ [ -5, 1, 8, 7, 2 ], [1, 1, 1, 1, 1], 27.3 ],            [ [ 3, 7, 34, 25, 46, 7754, 3, 6 ], [1, 1, 1, 1, 1, 1, 1, 1], 7481522.21429 ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DescriptiveTest_5935," Data provider for weighted sample variance test\n Test data created with R package Weighted.Desc.Stat: w.var(x, w)\n @return array [ [ numbers, weights ], variance ]\n", Data provider for weighted sample variance test,"    public function dataProviderForWeightedSampleVarianceBiased(): array    {        return [            [ [ -10, 0, 10, 20, 30 ], [1, 1, 1, 1, 1], 200 ],            [ [ 8, 9, 10, 11, 12 ], [1, 1, 1, 1, 1], 2 ],            [ [ 8, 9, 10, 11, 12 ], [0.3, 0.3, 0.2, 0.2, 0.1], 1.702479 ],            [ [ 600, 470, 170, 430, 300 ], [1, 1, 1, 1, 1], 21704 ],            [ [ -5, 1, 8, 7, 2 ], [1, 1, 1, 1, 1], 21.84 ],            [ [ 3, 7, 34, 25, 46, 7754, 3, 6 ], [1, 1, 1, 1, 1, 1, 1, 1], 6546332 ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DescriptiveTest_5943," Data provider for standard deviation using sample variance test\n @return array [ [ numbers ], mean ]\n", Data provider for standard deviation using sample variance test,"    public function dataProviderForStandardDeviationUsingSampleVariance(): array    {        return [            [ [ 3, 21, 98, 203, 17, 9 ],  78.86634 ],            [ [ 170, 300, 430, 470, 600 ], 164.7118696390761 ],            [ [ 1550, 1700, 900, 850, 1000, 950 ], 367.99 ],            [ [ 1245, 1255, 1654, 1547, 1787, 1989, 1878, 2011, 2145, 2545, 2656 ], 459.13 ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3482, Descriptive statistics\\n Summary statistics that quantitatively describe or summarize features of a collection of information.\\n https://en.wikipedia.org/wiki/Descriptive_statistics\\n, Descriptive statistics,"class Descriptive{    public const POPULATION = true;    public const SAMPLE     = false;    /**     * Range - the difference between the largest and smallest values     * It is the size of the smallest interval which contains all the data.     * It provides an indication of statistical dispersion.     * (https://en.wikipedia.org/wiki/Range_(statistics))     *     * R = max x - min x     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function range(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the range of an empty list of numbers');        }        return \max($numbers) - \min($numbers);    }    /**     * Midrange - the mean of the largest and smallest values     * It is the midpoint of the range; as such, it is a measure of central tendency.     * (https://en.wikipedia.org/wiki/Mid-range)     *     *     max x + min x     * M = -------------     *           2     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function midrange(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the midrange of an empty list of numbers');        }        return Average::mean([\min($numbers), \max($numbers)]);    }    /**     * Variance     *     * Variance measures how far a set of numbers are spread out.     * A variance of zero indicates that all the values are identical.     * Variance is always non-negative: a small variance indicates that the data points     * tend to be very close to the mean (expected value) and hence to each other.     * A high variance indicates that the data points are very spread out around the mean     * and from each other.     * (https://en.wikipedia.org/wiki/Variance)     *     *      ∑⟮xᵢ - μ⟯²     * σ² = ----------     *          ν     *     * Generalized method that allows setting the degrees of freedom.     * For population variance, set d.f. (ν) to n     * For sample variance, set d.f (ν) to n - 1     * Or use populationVariance or sampleVariance convenience methods.     *     * μ is the population mean     * ν is the degrees of freedom, which usually is     *   the number of numbers in the population set or n - 1 for sample set.     *     * @param float[] $numbers     * @param int     $ν degrees of freedom     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function variance(array $numbers, int $ν): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the variance of an empty list of numbers');        }        if ($ν <= 0) {            throw new Exception\OutOfBoundsException('Degrees of freedom must be > 0');        }        $∑⟮xᵢ − μ⟯² = RandomVariable::sumOfSquaresDeviations($numbers);        return $∑⟮xᵢ − μ⟯² / $ν;    }    /**     * Population variance - Use when all possible observations of the system are present.     * If used with a subset of data (sample variance), it will be a biased variance.     *     *      ∑⟮xᵢ - μ⟯²     * σ² = ----------     *          N     *     * μ is the population mean     * N is the number of numbers in the population set     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function populationVariance(array $numbers): float    {        $N = \count($numbers);        return self::variance($numbers, $N);    }    /**     * Unbiased sample variance     * Use when only a subset of all possible observations of the system are present.     *     *      ∑⟮xᵢ - x̄⟯²     * S² = ----------     *        n - 1     *     * x̄ is the sample mean     * n is the number of numbers in the sample set     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function sampleVariance(array $numbers): float    {        if (\count($numbers) == 1) {            return 0;        }        $n = \count($numbers);        return self::variance($numbers, $n - 1);    }    /**     * Weighted sample variance     *     * Biased case     *     *       ∑wᵢ⟮xᵢ - μw⟯²     * σ²w = ----------     *           ∑wᵢ     *     * Unbiased estimator for frequency weights     *     *       ∑wᵢ⟮xᵢ - μw⟯²     * σ²w = ----------     *         ∑wᵢ - 1     *     * μw is the weighted mean     *     * https://en.wikipedia.org/wiki/Weighted_arithmetic_mean#Weighted_sample_variance     *     * @param float[] $numbers     * @param float[] $weights     * @param bool    $biased     *     * @return float     *     * @throws Exception\BadDataException if the number of numbers and weights are not equal     */    public static function weightedSampleVariance(array $numbers, array $weights, bool $biased = false): float    {        if (\count($numbers) === 1) {            return 0;        }        if (\count($numbers) !== \count($weights)) {            throw new Exception\BadDataException('Numbers and weights must have the same number of elements.');        }        $μw           = Average::weightedMean($numbers, $weights);        $∑wᵢ⟮xᵢ − μw⟯² = \array_sum(\array_map(            function ($xᵢ, $wᵢ) use ($μw) {                return $wᵢ * \pow(($xᵢ - $μw), 2);            },            $numbers,            $weights        ));        $∑wᵢ = $biased            ? \array_sum($weights)            : \array_sum($weights) - 1;        return $∑wᵢ⟮xᵢ − μw⟯² / $∑wᵢ;    }    /**     * Standard deviation     * A measure that is used to quantify the amount of variation or dispersion of a set of data values.     * A low standard deviation indicates that the data points tend to be close to the mean     * (also called the expected value) of the set.     * A high standard deviation indicates that the data points are spread out over a wider range of values.     * (https://en.wikipedia.org/wiki/Standard_deviation)     *     * σ   = √⟮σ²⟯ = √⟮variance⟯     * SD+ = √⟮σ²⟯ = √⟮sample variance⟯     *     * @param float[] $numbers     * @param bool    $SD＋ : true returns SD+ (uses population variance);     *                false returns SD (uses sample variance);     *                Default is false (SD (sample variance))     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function standardDeviation(array $numbers, bool $SD＋ = false): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the standard deviation of an empty list of numbers');        }        return $SD＋            ? \sqrt(self::populationVariance($numbers))            : \sqrt(self::sampleVariance($numbers));    }    /**     * sd - Standard deviation - convenience method     *     * @param float[] $numbers     * @param bool    $SD＋ : true returns SD+ (uses population variance);     *                false returns SD (uses sample variance);     *                Default is false (SD (sample variance))     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function sd(array $numbers, bool $SD＋ = false): float    {        return self::standardDeviation($numbers, $SD＋);    }    /**     * MAD - mean absolute deviation     *     * The average of the absolute deviations from a central point.     * It is a summary statistic of statistical dispersion or variability.     * (https://en.wikipedia.org/wiki/Average_absolute_deviation)     *     *       ∑|xᵢ - x̄|     * MAD = ---------     *           N     *     * x̄ is the mean     * N is the number of numbers in the population set     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function meanAbsoluteDeviation(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the mean absolute deviation of an empty list of numbers');        }        $x         = Average::mean($numbers);        $∑│xᵢ − x│ = \array_sum(\array_map(            function ($xᵢ) use ($x) {                return \abs($xᵢ - $x);            },            $numbers        ));        $N = \count($numbers);        return $∑│xᵢ − x│ / $N;    }    /**     * MAD - median absolute deviation     *     * The average of the absolute deviations from a central point.     * It is a summary statistic of statistical dispersion or variability.     * It is a robust measure of the variability of a univariate sample of quantitative data.     * (https://en.wikipedia.org/wiki/Median_absolute_deviation)     *     * MAD = median(|xᵢ - x̄|)     *     * x̄ is the median     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function medianAbsoluteDeviation(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median absolute deviation of an empty list of numbers');        }        $x = Average::median($numbers);        return Average::median(\array_map(            function ($xᵢ) use ($x) {                return \abs($xᵢ - $x);            },            $numbers        ));    }    /**     * Quartiles     * Three points that divide the data set into four equal groups, each group comprising a quarter of the data.     * https://en.wikipedia.org/wiki/Quartile     *     * There are multiple methods for computing quartiles:     *  - Inclusive     *  - Exclusive     *     * @param float[] $numbers     * @param string  $method What quartile method to use (optional - default: exclusive)     *     * @return float[] (0%, Q1, Q2, Q3, 100%, IQR)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quartiles(array $numbers, string $method = 'exclusive'): array    {        switch (strtolower($method)) {            case 'inclusive':                return self::quartilesInclusive($numbers);            case 'exclusive':                return self::quartilesExclusive($numbers);            default:                return self::quartilesExclusive($numbers);        }    }    /**     * Quartiles - Exclusive method     * Three points that divide the data set into four equal groups, each group comprising a quarter of the data.     * https://en.wikipedia.org/wiki/Quartile     *     * 0% is smallest number     * Q1 (25%) is first quartile (lower quartile, 25th percentile)     * Q2 (50%) is second quartile (median, 50th percentile)     * Q3 (75%) is third quartile (upper quartile, 75th percentile)     * 100% is largest number     * interquartile_range is the difference between the upper and lower quartiles. (IQR = Q₃ - Q₁)     *     * Method used     *  - Use the median to divide the ordered data set into two halves.     *   - If there are an odd number of data points in the original ordered data set, do not include the median     *     (the central value in the ordered list) in either half.     *   - If there are an even number of data points in the original ordered data set,     *     split this data set exactly in half.     *  - The lower quartile value is the median of the lower half of the data.     *    The upper quartile value is the median of the upper half of the data.     *     * This rule is employed by the TI-83 calculator boxplot and ""1-Var Stats"" functions.     * This is the most basic method that is commonly taught in math textbooks.     *     * @param float[] $numbers     *     * @return array (0%, Q1, Q2, Q3, 100%, IQR)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quartilesExclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        if (\count($numbers) === 1) {            $number = \array_pop($numbers);            return [                '0%'   => $number,                'Q1'   => $number,                'Q2'   => $number,                'Q3'   => $number,                '100%' => $number,                'IQR'  => 0,            ];        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }    /**     * Quartiles - Inclusive method (R method)     * Three points that divide the data set into four equal groups, each group comprising a quarter of the data.     * https://en.wikipedia.org/wiki/Quartile     *     * 0% is smallest number     * Q1 (25%) is first quartile (lower quartile, 25th percentile)     * Q2 (50%) is second quartile (median, 50th percentile)     * Q3 (75%) is third quartile (upper quartile, 75th percentile)     * 100% is largest number     * interquartile_range is the difference between the upper and lower quartiles. (IQR = Q₃ - Q₁)     *     * Method used     *  - Use the median to divide the ordered data set into two halves.     *   - If there are an odd number of data points in the original ordered data set,     *     include the median (the central value in the ordered list) in both halves.     *   - If there are an even number of data points in the original ordered data set,     *     split this data set exactly in half.     *  - The lower quartile value is the median of the lower half of the data.     *    The upper quartile value is the median of the upper half of the data.     *     * The values found by this method are also known as ""Tukey's hinges"".     * This is the method that the programming language R uses by default.     *     * @param float[] $numbers     *     * @return array (0%, Q1, Q2, Q3, 100%, IQR)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quartilesInclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);            // Add median to both halves            $median = Average::median($numbers);            \array_push($lower_half, $median);            \array_unshift($upper_half, $median);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }    /**     * IQR - Interquartile range (midspread, middle fifty)     * A measure of statistical dispersion.     * Difference between the upper and lower quartiles.     * https://en.wikipedia.org/wiki/Interquartile_range     *     * IQR = Q₃ - Q₁     *     * @param float[] $numbers     * @param string  $method What quartile method to use (optional - default: exclusive)     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function interquartileRange(array $numbers, string $method = 'exclusive'): float    {        return self::quartiles($numbers, $method)['IQR'];    }    /**     * IQR - Interquartile range (midspread, middle fifty)     * Convenience wrapper function for interquartileRange.     *     * @param float[] $numbers     * @param string  $method What quartile method to use (optional - default: exclusive)     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function iqr(array $numbers, string $method = 'exclusive'): float    {        return self::quartiles($numbers, $method)['IQR'];    }    /**     * Compute the P-th percentile of a list of numbers     *     * Linear interpolation between closest ranks method - Second variant, C = 1     * P-th percentile (0 <= P <= 100) of a list of N ordered values (sorted from least to greatest)     * Similar method used in NumPy and Excel     * https://en.wikipedia.org/wiki/Percentile#Second_variant.2C_.7F.27.22.60UNIQ--postMath-00000043-QINU.60.22.27.7F     *     *      P     * x - --- (N - 1) + 1     *     100     *     * P = percentile     * N = number of elements in list     *     * ν(x) = νₓ + x％1(νₓ₊₁ - νₓ)     *     * ⌊x⌋  = integer part of x     * x％1 = fraction part of x     * νₓ   = number in position x in sorted list of numbers     * νₓ₊₁ = number in position x + 1 in sorted list of number     *     * @param float[] $numbers     * @param float   $P percentile to calculate     *     * @return float in list corresponding to P percentile     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if $P percentile is not between 0 and 100     */    public static function percentile(array $numbers, float $P): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the P-th percentile of an empty list of numbers');        }        if ($P < 0 || $P > 100) {            throw new Exception\OutOfBoundsException('Percentile P must be between 0 and 100.');        }        $N = \count($numbers);        if ($N === 1) {            return \array_shift($numbers);        }        \sort($numbers);        if ($P == 100) {            return  $numbers[$N - 1];        }        $x    = ($P / 100) * ($N - 1) + 1;        $⌊x⌋  = \intval($x);        $x％1 = $x - $⌊x⌋;        $νₓ   = $numbers[$⌊x⌋ - 1];        $νₓ₊₁ = $numbers[$⌊x⌋];        return $νₓ + $x％1 * ($νₓ₊₁ - $νₓ);    }    /**     * Midhinge     * The average of the first and third quartiles and is thus a measure of location.     * Equivalently, it is the 25% trimmed mid-range or 25% midsummary; it is an L-estimator.     * https://en.wikipedia.org/wiki/Midhinge     *     * Midhinge = (first quartile, third quartile) / 2     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function midhinge(array $numbers): float    {        $quartiles = self::quartiles($numbers);        $Q1        = $quartiles['Q1'];        $Q2        = $quartiles['Q3'];        return Average::mean([$Q1, $Q2]);    }    /**     * Coefficient of variation (cᵥ)     * Also known as relative standard deviation (RSD)     *     * A standardized measure of dispersion of a probability distribution or     * frequency distribution. It is often expressed as a percentage.     * The ratio of the standard deviation to the mean.     * https://en.wikipedia.org/wiki/Coefficient_of_variation     *     *      σ     * cᵥ = -     *      μ     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function coefficientOfVariation(array $numbers): float    {        $σ = self::standardDeviation($numbers);        $μ = Average::mean($numbers);        return $σ / $μ;    }    /**     * Get a report of all the descriptive statistics over a list of numbers     * Includes mean, median, mode, range, midrange, variance, standard deviation, quartiles, etc.     *     * @param float[] $numbers     * @param bool    $population : true means all possible observations of the system are present;     *                           false means a sample is used.     *     * @return array [n, mean, median, mode, range, midrange, variance, sd, CV, mean_mad,     *                median_mad, quartiles, skewness, kurtosis, sem, ci_95, ci_99]     *     * @throws Exception\OutOfBoundsException     * @throws Exception\BadDataException     */    public static function describe(array $numbers, bool $population = false): array    {        $n = \count($numbers);        $μ = Average::mean($numbers);        $σ = self::standardDeviation($numbers, $population);        return [            'n'                  => $n,            'min'                => \min($numbers),            'max'                => \max($numbers),            'mean'               => $μ,            'median'             => Average::median($numbers),            'mode'               => Average::mode($numbers),            'range'              => self::range($numbers),            'midrange'           => self::midrange($numbers),            'variance'           => $population ? self::populationVariance($numbers) : self::sampleVariance($numbers),            'sd'                 => $σ,            'cv'                 => $μ ? $σ / $μ : \NAN,            'mean_mad'           => self::meanAbsoluteDeviation($numbers),            'median_mad'         => self::medianAbsoluteDeviation($numbers),            'quartiles'          => self::quartiles($numbers),            'midhinge'           => self::midhinge($numbers),            'skewness'           => $population                ? ($n > 0 ? RandomVariable::populationSkewness($numbers) : null)                : ($n >= 3 ? RandomVariable::skewness($numbers) : null),            'ses'                => $n > 2 ? RandomVariable::ses($n) : null,            'kurtosis'           => $population                ? ($n > 3 ? RandomVariable::populationKurtosis($numbers) : null)                : ($n > 0 ? RandomVariable::sampleKurtosis($numbers) : null),            'sek'                => $n > 3 ? RandomVariable::sek($n) : null,            'sem'                => RandomVariable::standardErrorOfTheMean($numbers),            'ci_95'              => RandomVariable::confidenceInterval($μ, $n, $σ, '95'),            'ci_99'              => RandomVariable::confidenceInterval($μ, $n, $σ, '99'),        ];    }    /**     * Five number summary     * A descriptive statistic that provides information about a set of observations.     * It consists of the five most important sample percentiles:     *  1) the sample minimum (smallest observation)     *  2) the lower quartile or first quartile     *  3) the median (middle value)     *  4) the upper quartile or third quartile     *  5) the sample maximum (largest observation)     *     * https://en.wikipedia.org/wiki/Five-number_summary     *     * @param  array  $numbers     *     * @return array [min, Q1, median, Q3, max]     *     * @throws Exception\BadDataException     */    public static function fiveNumberSummary(array $numbers): array    {        $quartiles = self::quartiles($numbers);        return [            'min'    => \min($numbers),            'Q1'     => $quartiles['Q1'],            'median' => Average::median($numbers),            'Q3'     => $quartiles['Q3'],            'max'    => \max($numbers),        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3483, Range - the difference between the largest and smallest values\n It is the size of the smallest interval which contains all the data.\n It provides an indication of statistical dispersion.\n (https://en.wikipedia.org/wiki/Range_(statistics))\n\n R = max x - min x\n\n @param float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n, Range - the difference between the largest and smallest values,    public static function range(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the range of an empty list of numbers');        }        return \max($numbers) - \min($numbers);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3488, MAD - mean absolute deviation\n\n The average of the absolute deviations from a central point.\n It is a summary statistic of statistical dispersion or variability.\n (https://en.wikipedia.org/wiki/Average_absolute_deviation)\n\n       ∑|xᵢ - x̄|\n MAD = ---------\n           N\n\n x̄ is the mean\n N is the number of numbers in the population set\n\n @param float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n, MAD - mean absolute deviation,"    public static function meanAbsoluteDeviation(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the mean absolute deviation of an empty list of numbers');        }        $x         = Average::mean($numbers);        $∑│xᵢ − x│ = \array_sum(\array_map(            function ($xᵢ) use ($x) {                return \abs($xᵢ - $x);            },            $numbers        ));        $N = \count($numbers);        return $∑│xᵢ − x│ / $N;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3489, MAD - median absolute deviation\\n\\n The average of the absolute deviations from a central point.\\n It is a summary statistic of statistical dispersion or variability.\\n It is a robust measure of the variability of a univariate sample of quantitative data.\\n (https://en.wikipedia.org/wiki/Median_absolute_deviation)\\n\\n MAD = median(|xᵢ - x̄|)\\n\\n x̄ is the median\\n\\n @param float[] $numbers\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n, MAD - median absolute deviation,"    public static function medianAbsoluteDeviation(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median absolute deviation of an empty list of numbers');        }        $x = Average::median($numbers);        return Average::median(\array_map(            function ($xᵢ) use ($x) {                return \abs($xᵢ - $x);            },            $numbers        ));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3490," Quartiles - Exclusive method\n Three points that divide the data set into four equal groups, each group comprising a quarter of the data.\n https://en.wikipedia.org/wiki/Quartile\n\n 0% is smallest number\n Q1 (25%) is first quartile (lower quartile, 25th percentile)\n Q2 (50%) is second quartile (median, 50th percentile)\n Q3 (75%) is third quartile (upper quartile, 75th percentile)\n 100% is largest number\n interquartile_range is the difference between the upper and lower quartiles. (IQR = Q₃ - Q₁)\n\n Method used\n  - Use the median to divide the ordered data set into two halves.\n   - If there are an odd number of data points in the original ordered data set, do not include the median\n     (the central value in the ordered list) in either half.\n   - If there are an even number of data points in the original ordered data set,\n     split this data set exactly in half.\n  - The lower quartile value is the median of the lower half of the data.\n    The upper quartile value is the median of the upper half of the data.\n\n This rule is employed by the TI-83 calculator boxplot and ""1-Var Stats"" functions.\n This is the most basic method that is commonly taught in math textbooks.\n\n @param float[] $numbers\n\n @return array (0%, Q1, Q2, Q3, 100%, IQR)\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n", Quartiles - Exclusive method,"    public static function quartilesExclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        if (\count($numbers) === 1) {            $number = \array_pop($numbers);            return [                '0%'   => $number,                'Q1'   => $number,                'Q2'   => $number,                'Q3'   => $number,                '100%' => $number,                'IQR'  => 0,            ];        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3492," Compute the P-th percentile of a list of numbers\n\n Linear interpolation between closest ranks method - Second variant, C = 1\n P-th percentile (0 <= P <= 100) of a list of N ordered values (sorted from least to greatest)\n Similar method used in NumPy and Excel\n https://en.wikipedia.org/wiki/Percentile#Second_variant.2C_.7F.27.22.60UNIQ--postMath-00000043-QINU.60.22.27.7F\n\n      P\n x - --- (N - 1) + 1\n     100\n\n P = percentile\n N = number of elements in list\n\n ν(x) = νₓ + x％1(νₓ₊₁ - νₓ)\n\n ⌊x⌋  = integer part of x\n x％1 = fraction part of x\n νₓ   = number in position x in sorted list of numbers\n νₓ₊₁ = number in position x + 1 in sorted list of number\n\n @param float[] $numbers\n @param float   $P percentile to calculate\n\n @return float in list corresponding to P percentile\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n @throws Exception\\OutOfBoundsException if $P percentile is not between 0 and 100\n", Compute the P-th percentile of a list of numbers,"    public static function percentile(array $numbers, float $P): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the P-th percentile of an empty list of numbers');        }        if ($P < 0 || $P > 100) {            throw new Exception\OutOfBoundsException('Percentile P must be between 0 and 100.');        }        $N = \count($numbers);        if ($N === 1) {            return \array_shift($numbers);        }        \sort($numbers);        if ($P == 100) {            return  $numbers[$N - 1];        }        $x    = ($P / 100) * ($N - 1) + 1;        $⌊x⌋  = \intval($x);        $x％1 = $x - $⌊x⌋;        $νₓ   = $numbers[$⌊x⌋ - 1];        $νₓ₊₁ = $numbers[$⌊x⌋];        return $νₓ + $x％1 * ($νₓ₊₁ - $νₓ);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3494, Coefficient of variation (cᵥ)\\n Also known as relative standard deviation (RSD)\\n\\n A standardized measure of dispersion of a probability distribution or\\n frequency distribution. It is often expressed as a percentage.\\n The ratio of the standard deviation to the mean.\\n https://en.wikipedia.org/wiki/Coefficient_of_variation\\n\\n      σ\\n cᵥ = -\\n      μ\\n\\n @param float[] $numbers\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if degrees of freedom is ≤ 0\\n, Coefficient of variation (cᵥ),    public static function coefficientOfVariation(array $numbers): float    {        $σ = self::standardDeviation($numbers);        $μ = Average::mean($numbers);        return $σ / $μ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DiracDelta_3090, Dirac Delta Function\\n https://en.wikipedia.org/wiki/Dirac_delta_function\\n, Dirac Delta Function,"class DiracDelta extends Continuous{    /**     * Distribution parameter bounds limits     *     * @var array     */    public const PARAMETER_LIMITS = [];    /**     * Distribution support bounds limits     * x  ∈ (-∞,∞)     *     * @var array     */    public const SUPPORT_LIMITS = [        'x'  => '(-∞,∞)',    ];    /**     * Constructor     */    public function __construct()    {        parent::__construct();    }    /**     * Probability density function     *     *     *          /‾     *         |  +∞,   x = 0     * δ(x) = <     *         |  0,    x ≠ 0     *          \_     *     *     * @param float $x     *     * @return float probability     */    public function pdf(float $x): float    {        if ($x == 0) {            return \INF;        } else {            return 0;        }    }    /**     * Cumulative distribution function     * https://en.wikipedia.org/wiki/Heaviside_step_function     *     *  |\+∞     *  |   δ(x) dx = 1     * \|-∞     *     * @param float $x     * @todo how to handle x = 0, depending on context, some say CDF=.5 @ x=0     *     * @return int     */    public function cdf(float $x): int    {        if ($x >= 0) {            return 1;        }        return 0;    }    /**     * The inverse of the CDF function     *     * @return int     */    public function inverse(float $p): int    {        return 0;    }    /**     * Mean of the distribution     *     * @return int     */    public function mean(): int    {        return 0;    }    /**     * Median of the distribution     *     * @return int     */    public function median(): int    {        return 0;    }    /**     * Mode of the distribution     *     * @return int     */    public function mode(): int    {        return 0;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DiracDelta_3092," Probability density function\n\n\n          /‾\n         |  +∞,   x = 0\n δ(x) = <\n         |  0,    x ≠ 0\n          \\_\n\n\n @param float $x\n\n @return float probability\n", Probability density function,    public function pdf(float $x): float    {        if ($x == 0) {            return \INF;        } else {            return 0;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DiracDelta_3093," Cumulative distribution function\\n https://en.wikipedia.org/wiki/Heaviside_step_function\\n\\n  |\\\\+∞\\n  |   δ(x) dx = 1\\n \\\\|-∞\\n\\n @param float $x\\n @todo how to handle x = 0, depending on context, some say CDF=.5 @ x=0\\n\\n @return int\\n", Cumulative distribution function,    public function cdf(float $x): int    {        if ($x >= 0) {            return 1;        }        return 0;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Dirichlet_3275, Dirichlet distribution\n https://en.wikipedia.org/wiki/Dirichlet_distribution\n, Dirichlet distribution,"class Dirichlet{    /**     * Distribution parameter bounds limits     * α ∈ (0,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'α' => '(0,∞)',    ];    /**     * Distribution parameter bounds limits     * x ∈ (0,1)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '(0,1)',    ];    /** @var float[] $αs */    protected $αs;    /**     * Constructor     *     * @param float[] $αs     */    public function __construct(array $αs)    {        $n = \count($αs);        for ($i = 0; $i < $n; $i++) {            Support::checkLimits(self::PARAMETER_LIMITS, ['α' => $αs[$i]]);        }        $this->αs = $αs;    }    /**     * Probability density function     *     *        1    K   αᵢ-1     * pdf = ----  ∏ xᵢ     *       B(α) ⁱ⁼ⁱ     *     * where B(α) is the multivariate Beta function     *     * @param float[] $xs     *     * @return float     *     * @throws Exception\BadDataException if xs and αs don't have the same number of elements     */    public function pdf(array $xs): float    {        if (\count($xs) !== \count($this->αs)) {            throw new Exception\BadDataException('xs and αs must have the same number of elements');        }        $n = \count($xs);        for ($i = 0; $i < $n; $i++) {            Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $xs[$i]]);        }        /*         *  K   αᵢ-1         *  ∏ xᵢ         * ⁱ⁼ⁱ         */        $∏xᵢ = \array_product(            \array_map(                function ($xᵢ, $αᵢ) {                    return $xᵢ ** ($αᵢ - 1);                },                $xs,                $this->αs            )        );        $B⟮α⟯ = Special::multivariateBeta($this->αs);        return $∏xᵢ / $B⟮α⟯;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Dirichlet_3277, Probability density function\n\n        1    K   αᵢ-1\n pdf = ----  ∏ xᵢ\n       B(α) ⁱ⁼ⁱ\n\n where B(α) is the multivariate Beta function\n\n @param float[] $xs\n\n @return float\n\n @throws Exception\\BadDataException if xs and αs don't have the same number of elements\n, Probability density function,"    public function pdf(array $xs): float    {        if (\count($xs) !== \count($this->αs)) {            throw new Exception\BadDataException('xs and αs must have the same number of elements');        }        $n = \count($xs);        for ($i = 0; $i < $n; $i++) {            Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $xs[$i]]);        }        /*         *  K   αᵢ-1         *  ∏ xᵢ         * ⁱ⁼ⁱ         */        $∏xᵢ = \array_product(            \array_map(                function ($xᵢ, $αᵢ) {                    return $xᵢ ** ($αᵢ - 1);                },                $xs,                $this->αs            )        );        $B⟮α⟯ = Special::multivariateBeta($this->αs);        return $∏xᵢ / $B⟮α⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DistanceTest_5990," Test data created with Python scipy.spatial.distance.jensenshannon\\n distance.jensenshannon(p, q)\\n @return array [p, q, distance]\\n", Test data created with Python scipy.spatial.distance.jensenshannon,"    public function dataProviderForJensenShannon(): array    {        return [            [                [0.4, 0.6],                [0.5, 0.5],                0.07112938864483229,            ],            [                [0.1, 0.2, 0.2, 0.2, 0.2, 0.1],                [0.0, 0.1, 0.4, 0.4, 0.1, 0.0],                0.346820456568833            ],            [                [0.25, 0.5, 0.25],                [0.5, 0.3, 0.2],                0.18778369857844396,            ],            [                [0.5, 0.3, 0.2],                [0.25, 0.5, 0.25],                0.18778369857844396,            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DistanceTest_6022," Test data created with Python scipy.spatial.distance.canberra\\n distance.canberra(p, q)\\n @return array [p, q, distance]\\n", Test data created with Python scipy.spatial.distance.canberra,"    public function dataProviderForCanberra(): array    {        return [            [                [1, 0, 0],                [0, 1, 0],                2,            ],            [                [1, 1, 0],                [0, 1, 0],                1,            ],            [                [1, 2, 3],                [1, 2, 3],                0,            ],            [                [1, 2, 3],                [3, 2, 1],                1,            ],            [                [0.4, 0.6],                [0.5, 0.5],                0.20202020202020196,            ],            [                [0.1, 0.2, 0.2, 0.2, 0.2, 0.1],                [0.0, 0.1, 0.4, 0.4, 0.1, 0.0],                3.333333333333333            ],            [                [0.25, 0.5, 0.25],                [0.5, 0.3, 0.2],                0.6944444444444443,            ],            [                [0.5, 0.3, 0.2],                [0.25, 0.5, 0.25],                0.6944444444444443,            ],            [                [1],                [0],                1,            ],            [                [0],                [1],                1,            ],            [                [1],                [1],                0,            ],            [                [-1],                [-1],                0,            ],            [                [-2],                [-3],                0.2,            ],            [                [1, 1, 1],                [1, 1, 0],                1,            ],            [                [1, 1, 0],                [1, 1, 1],                1,            ],            [                [1, 1, 1],                [10, 5, 0],                2.484848484848485,            ],            [                [10, 5, 0],                [1, 1, 1],                2.484848484848485,            ],            [                [10, 10, 10],                [11, 11, 11],                0.14285714285714285,            ],            [                [11, 11, 11],                [10, 10, 10],                0.14285714285714285,            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distance_3496," Functions dealing with statistical distance.\\n Related to probability and information theory and entropy.\\n\\n - Distances\\n   - Bhattacharyya\\n   - Hellinger\\n   - Mahalanobis\\n   - Jensen-Shannon\\n   - Minkowski\\n   - Euclidean\\n   - Manhattan\\n   - Cosine\\n   - Cosine similarity\\n   - Bray Curtis\\n   - Canberra\\n\\n In statistics, probability theory, and information theory, a statistical distance quantifies the distance between\\n two statistical objects, which can be two random variables, or two probability distributions or samples, or the\\n distance can be between an individual sample point and a population or a wider sample of points.\\n\\n https://en.wikipedia.org/wiki/Statistical_distance\\n", Functions dealing with statistical distance.,"class Distance{    private const ONE_TOLERANCE = 0.010001;    /**     * Bhattacharyya distance     * Measures the similarity of two discrete or continuous probability distributions.     * https://en.wikipedia.org/wiki/Bhattacharyya_distance     *     * For probability distributions p and q over the same domain X,     * the Bhattacharyya distance is defined as:     *     * DB(p,q) = -ln(BC(p,q))     *     * where BC is the Bhattacharyya coefficient:     *     * BC(p,q) = ∑ √(p(x) q(x))     *          x∈X     *     * @param array $p distribution p     * @param array $q distribution q     *     * @return float distance between distributions     *     * @throws Exception\BadDataException if p and q do not have the same number of elements     * @throws Exception\BadDataException if p and q are not probability distributions that add up to 1     */    public static function bhattacharyya(array $p, array $q): float    {        // Arrays must have the same number of elements        if (\count($p) !== \count($q)) {            throw new Exception\BadDataException('p and q must have the same number of elements');        }        // Probability distributions must add up to 1.0        if ((\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) || (\abs(\array_sum($q) - 1) > self::ONE_TOLERANCE)) {            throw new Exception\BadDataException('Distributions p and q must add up to 1');        }        // ∑ √(p(x) q(x))        $BC⟮p、q⟯ = \array_sum(Map\Single::sqrt(Map\Multi::multiply($p, $q)));        return -\log($BC⟮p、q⟯);    }    /**     * Hellinger distance     * Used to quantify the similarity between two probability distributions. It is a type of f-divergence.     * https://en.wikipedia.org/wiki/Hellinger_distance     *     *          1   _______________     * H(P,Q) = -- √ ∑ (√pᵢ - √qᵢ)²     *          √2     *     * @param array $p distribution p     * @param array $q distribution q     *     * @return float difference between distributions     *     * @throws Exception\BadDataException if p and q do not have the same number of elements     * @throws Exception\BadDataException if p and q are not probability distributions that add up to 1     */    public static function hellinger(array $p, array $q): float    {        // Arrays must have the same number of elements        if (\count($p) !== \count($q)) {            throw new Exception\BadDataException('p and q must have the same number of elements');        }        // Probability distributions must add up to 1.0        if ((\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) || (\abs(\array_sum($q) - 1) > self::ONE_TOLERANCE)) {            throw new Exception\BadDataException('Distributions p and q must add up to 1');        }        // Defensive measures against taking the log of 0 which would be -∞ or dividing by 0        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        $q = \array_map(            function ($qᵢ) {                return $qᵢ == 0 ? 1e-15 : $qᵢ;            },            $q        );        // √ ∑ (√pᵢ - √qᵢ)²        $√∑⟮√pᵢ − √qᵢ⟯² = \sqrt(\array_sum(\array_map(            function ($pᵢ, $qᵢ) {                return (\sqrt($pᵢ) - \sqrt($qᵢ)) ** 2;            },            $p,            $q        )));        return (1 / \sqrt(2)) * $√∑⟮√pᵢ − √qᵢ⟯²;    }    /**     * Jensen-Shannon distance     * Square root of the Jensen-Shannon divergence     * https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence     *     *        _____________________     *       / 1          1     *  \   /  - D(P‖M) + - D(Q‖M)     *   \/    2          2     *     *           1     * where M = - (P + Q)     *           2     *     * D(P‖Q) = Kullback-Leibler divergence     *     * @param array $p distribution p     * @param array $q distribution q     *     * @return float     *     * @throws Exception\BadDataException if p and q do not have the same number of elements     * @throws Exception\BadDataException if p and q are not probability distributions that add up to 1     */    public static function jensenShannon(array $p, array $q): float    {        return \sqrt(Divergence::jensenShannon($p, $q));    }    /**     * Mahalanobis distance     *     * https://en.wikipedia.org/wiki/Mahalanobis_distance     *     * The Mahalanobis distance measures the distance between two points in multidimensional     * space, scaled by the standard deviation of the data in each dimension.     *     * If x and y are vectors of points in space, and S is the covariance matrix of that space,     * the Mahalanobis distance, D, of the point within the space is:     *     *    D = √[(x-y)ᵀ S⁻¹ (x-y)]     *     * If y is not provided, the distances will be calculated from x to the centroid of the dataset.     *     * The Mahalanobis distance can also be used to measure the distance between two sets of data.     * If x has more than one column, the combined data covariance matrix is used, and the distance     * will be calculated between the centroids of each data set.     *     * @param NumericMatrix      $x    a vector in the vector space. ie [[1],[2],[4]] or a matrix of data     * @param NumericMatrix      $data an array of data. i.e. [[1,2,3,4],[6,2,8,1],[0,4,8,1]]     * @param NumericMatrix|null $y    a vector in the vector space     *     * @return float Mahalanobis Distance     *     * @throws Exception\BadParameterException     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\VectorException     */    public static function mahalanobis(NumericMatrix $x, NumericMatrix $data, NumericMatrix $y = null): float    {        $Centroid = $data->rowMeans()->asColumnMatrix();        $Nx       = $x->getN();        if ($Nx > 1) {            // Combined covariance Matrix            $S = $data->augment($x)->covarianceMatrix();            $diff = $x->rowMeans()->asColumnMatrix()->subtract($Centroid);        } else {            $S = $data->covarianceMatrix();            if ($y === null) {                $y = $Centroid;            }            $diff = $x->subtract($y);        }        $S⁻¹ = $S->inverse();        $D   = $diff->transpose()->multiply($S⁻¹)->multiply($diff);        return \sqrt($D[0][0]);    }    /**     * Minkowski distance     *     * https://en.wikipedia.org/wiki/Minkowski_distance     *     * (Σ|xᵢ - yᵢ|ᵖ)¹/ᵖ     *     * @param float[] $xs input array     * @param float[] $ys input array     * @param int     $p  order of the norm of the difference     *     * @return float     *     * @throws Exception\BadDataException if p and q do not have the same number of elements     */    public static function minkowski(array $xs, array $ys, int $p): float    {        // Arrays must have the same number of elements        $n = \count($xs);        if ($n !== \count($ys)) {            throw new Exception\BadDataException('x and y must have the same number of elements');        }        if ($p < 1) {            throw new Exception\BadDataException(""p must be ≥ 1. Given $p"");        }        $∑｜xᵢ − yᵢ⟯ᵖ = \array_sum(            \array_map(                function ($x, $y) use ($p) {                    return \abs($x - $y) ** $p;                },                $xs,                $ys            )        );        return $∑｜xᵢ − yᵢ⟯ᵖ ** (1 / $p);    }    /**     * Euclidean distance     *     * https://en.wikipedia.org/wiki/Euclidean_distance     *     * A generalized term for the Euclidean norm is the L² norm or L² distance.     *     * (Σ|xᵢ - yᵢ|²)¹/²     *     * @param float[] $xs input array     * @param float[] $ys input array     *     * @return float     *     * @throws Exception\BadDataException if p and q do not have the same number of elements     */    public static function euclidean(array $xs, array $ys): float    {        return self::minkowski($xs, $ys, 2);    }    /**     * Manhattan distance (Taxicab geometry)     *     * https://en.wikipedia.org/wiki/Taxicab_geometry     *     * The taxicab metric is also known as rectilinear distance, L₁ distance, L¹ distance , snake distance, city block     * distance, Manhattan distance or Manhattan length, with corresponding variations in the name of the geometry.     *     * Σ|xᵢ - yᵢ|     *     * @param float[] $xs input array     * @param float[] $ys input array     *     * @return float     *     * @throws Exception\BadDataException if p and q do not have the same number of elements     */    public static function manhattan(array $xs, array $ys): float    {        return self::minkowski($xs, $ys, 1);    }    /**     * Cosine distance     *     *        A⋅B     * 1 - ---------     *     ‖A‖₂⋅‖B‖₂     *     *  where     *    A⋅B is the dot product of A and B     *    ‖A‖₂ is the L² norm of A     *    ‖B‖₂ is the L² norm of B     *     * Similar to Python: scipy.spatial.distance.cosine(u, v, w=None)     *     * @param float[] $A     * @param float[] $B     *     * @return float     *     * @throws Exception\BadDataException if null vector passed in     * @throws Exception\VectorException     */    public static function cosine(array $A, array $B): float    {        if (\count(\array_unique($A)) === 1 && \end($A) == 0) {            throw new Exception\BadDataException('A is the null vector');        }        if (\count(\array_unique($B)) === 1 && \end($B) == 0) {            throw new Exception\BadDataException('B is the null vector');        }        $A = new Vector($A);        $B = new Vector($B);        $A⋅B       = $A->dotProduct($B);        $‖A‖₂⋅‖B‖₂ = $A->l2Norm() * $B->l2Norm();        return 1 - ($A⋅B / $‖A‖₂⋅‖B‖₂);    }    /**     * Cosine similarity     * A measure of similarity between two non-zero vectors of an inner product space.     * Defined to equal the cosine of the angle between them, which is also the same as the inner product of the same     * vectors normalized to both have length 1.     *     *            A⋅B     * cos α = ---------     *         ‖A‖₂⋅‖B‖₂     *     *  where     *    A⋅B is the dot product of A and B     *    ‖A‖₂ is the L² norm of A     *    ‖B‖₂ is the L² norm of B     *     * Similar to Python: 1 - scipy.spatial.distance.cosine(u, v, w=None)     *     * @param float[] $A     * @param float[] $B     *     * @return float     *     * @throws Exception\BadDataException if null vector passed in     * @throws Exception\VectorException     */    public static function cosineSimilarity(array $A, array $B): float    {        return 1 - self::cosine($A, $B);    }    /**     * Bray Curtis Distance     *     * https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.braycurtis.html#scipy.spatial.distance.braycurtis     *     *  ∑｜uᵢ − vᵢ｜     *  -----------     *  ∑｜uᵢ + vᵢ｜     *     * @param array $u     * @param array $v     *     * @return float     */    public static function brayCurtis(array $u, array $v): float    {        if (\count($u) !== \count($v)) {            throw new Exception\BadDataException('u and v must have the same number of elements');        }        $uZero = \count(\array_unique($u)) === 1 && \end($u) == 0;        $vZero = \count(\array_unique($u)) === 1 && \end($v) == 0;        if ($uZero && $vZero) {            return \NAN;        }        $∑｜uᵢ − vᵢ｜ = \array_sum(\array_map(            function (float $uᵢ, float $vᵢ) {                return \abs($uᵢ - $vᵢ);            },            $u,            $v        ));        $∑｜uᵢ ＋ vᵢ｜ = \array_sum(\array_map(            function (float $uᵢ, float $vᵢ) {                return \abs($uᵢ + $vᵢ);            },            $u,            $v        ));        if ($∑｜uᵢ ＋ vᵢ｜ == 0) {            return \NAN;        }        return $∑｜uᵢ − vᵢ｜ / $∑｜uᵢ ＋ vᵢ｜;    }    /**     * Canberra Distance     * A numerical measure of the distance between pairs of points in a vector space     * It is a weighted version of L₁ (Manhattan) distance.     *     * https://en.wikipedia.org/wiki/Canberra_distance     * http://www.code10.info/index.php?option=com_content&view=article&id=49:article_canberra-distance&catid=38:cat_coding_algorithms_data-similarity&Itemid=57     *     *              ｜pᵢ − qᵢ｜     * d(p,q) = ∑ --------------     *            ｜pᵢ｜ + ｜qᵢ｜     *     * @param array $p     * @param array $q     *     * @return float     */    public static function canberra(array $p, array $q): float    {        if (\count($p) !== \count($q)) {            throw new Exception\BadDataException('p and q must have the same number of elements');        }        $pZero = \count(\array_unique($p)) === 1 && \end($p) == 0;        $qZero = \count(\array_unique($p)) === 1 && \end($q) == 0;        if ($pZero && $qZero) {            return \NAN;        }        // Numerators ｜pᵢ − qᵢ｜        $｜p − q｜ = \array_map(            function (float $pᵢ, float $qᵢ) {                return \abs($pᵢ - $qᵢ);            },            $p,            $q        );        // Denominators ｜pᵢ｜ + ｜qᵢ｜        $｜p｜ ＋ ｜q｜ = \array_map(            function (float $p, float $q) {                return \abs($p) + \abs($q);            },            $p,            $q        );        // Sum of quotients with non-zero denominators        //    ｜pᵢ − qᵢ｜        // ∑ --------------        //   ｜pᵢ｜ + ｜qᵢ｜        return \array_sum(\array_map(            function (float $｜pᵢ − qᵢ｜, float $｜pᵢ｜ ＋ ｜qᵢ｜) {                return $｜pᵢ｜ ＋ ｜qᵢ｜ == 0                    ? 0                    : $｜pᵢ − qᵢ｜ / $｜pᵢ｜ ＋ ｜qᵢ｜;            },            $｜p − q｜,            $｜p｜ ＋ ｜q｜        ));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distance_3502," Manhattan distance (Taxicab geometry)\\n\\n https://en.wikipedia.org/wiki/Taxicab_geometry\\n\\n The taxicab metric is also known as rectilinear distance, L₁ distance, L¹ distance , snake distance, city block\\n distance, Manhattan distance or Manhattan length, with corresponding variations in the name of the geometry.\\n\\n Σ|xᵢ - yᵢ|\\n\\n @param float[] $xs input array\\n @param float[] $ys input array\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if p and q do not have the same number of elements\\n", Manhattan distance (Taxicab geometry),"    public static function manhattan(array $xs, array $ys): float    {        return self::minkowski($xs, $ys, 1);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DistributionTest_6036," Data generated with R: rank(c(1, 2, 3, 4, 5), ties.method='average')\\n @return array\\n"," Data generated with R: rank(c(1, 2, 3, 4, 5), ties.method='average')","    public function dataProviderForRankingWithoutTies(): array    {        return [            [                [0],                [1],            ],            [                [1],                [1],            ],            [                [-1],                [1],            ],            [                [5],                [1],            ],            [                [1, 5],                [1, 2],            ],            [                [2, 5],                [1, 2],            ],            [                [1, 2, 3, 4, 5],                [1, 2, 3, 4, 5],            ],            [                [5, 2],                [2, 1],            ],            [                [5, 4, 3, 2, 1],                [5, 4, 3, 2, 1],            ],            [                [5, 3, 1, 2, 4],                [5, 3, 1, 2, 4],            ],            [                [1, 3, 5, 7, 9],                [1, 2, 3, 4, 5],            ],            [                [9, 7, 5, 3, 1],                [5, 4, 3, 2, 1],            ],            [                [3, 1, 4, 15, 92],                [2, 1, 3, 4, 5],            ],            [                [8, 4, 10, 3, 5, 32, 1, 98, 43],                [5, 3, 6, 2, 4, 7, 1, 9, 8],            ],            [                [1, 2, 4, 5],                [1, 2, 3, 4],            ],            [                [-3, -2, -1, 0, 1, 2, 3],                [1, 2, 3, 4, 5, 6, 7],            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DistributionTest_6039," Data generated with R: rank(c(1, 2, 3, 4, 5), ties.method='min')\n @return array\n"," Data generated with R: rank(c(1, 2, 3, 4, 5), ties.method='min')","    public function dataProviderForStandardCompetitionRanking(): array    {        return [            [                [1, 2, 2, 3],                [1, 2, 2, 4],            ],            [                [3, 2, 2, 1],                [4, 2, 2, 1],            ],            [                [1, 2, 3, 3, 4, 5],                [1, 2, 3, 3, 5, 6],            ],            [                [1, 2, 3, 3, 3, 4, 5],                [1, 2, 3, 3, 3, 6, 7],            ],            [                [1, 1],                [1, 1],            ],            [                [0, 0],                [1, 1],            ],            [                [-1, -1],                [1, 1],            ],            [                [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5],                [4, 1, 6, 1, 7, 11, 3, 10, 7, 4, 7],            ],            [                [1.0, 1.0, 2.0, 3.0, 3.0, 4.0, 5.0, 5.0, 5.0],                [1, 1, 3, 4, 4, 6, 7, 7, 7],            ],            [                [-3, -2, -2, -1, -1, 0, 1, 2, 3],                [1, 2, 2, 4, 4, 6, 7, 8, 9],            ],            [                [-1, 5, 7, -1],                [1, 3, 4, 1],            ],            [                [2.5, 2.5, 2.5, 3, 3, 2.5, 2.25, 2.75, 2, 2.75],                [3, 3, 3, 9, 9, 3, 2, 7, 1, 7],            ],            [                [2.25, 2.75, 2.75, 2.25, 2.25, 3.25, 2, 2, 2.75, 1.25],                [4, 7, 7, 4, 4, 10, 2, 2, 7, 1],            ],            [                [2.534, 2.512, 2.4634, 2.512, 2.543, 2.5, 2.51, 2.49, 2.49, 2.53, 2.5],                [10, 7, 1, 7, 11, 4, 6, 2, 2, 9, 4],            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distribution_3507," Frequency distribution\n A table that displays the frequency of various outcomes in a sample.\n Each entry in the table contains the frequency or count of the occurrences of values\n within a particular group or interval.\n The table summarizes the distribution of values in the sample.\n https://en.wikipedia.org/wiki/Frequency_distribution\n\n The values of the input array will be the keys of the result array.\n The count of the values will be the value of the result array for that key.\n\n @param array $values Ex: ( A, A, A, B, B, C )\n\n @return array frequency distribution Ex: ( A => 3, B => 2, C => 1 )\n", Frequency distribution,    public static function frequency(array $values): array    {        $frequencies = array();        foreach ($values as $value) {            if (!isset($frequencies[$value])) {                $frequencies[$value] = 1;            } else {                $frequencies[$value]++;            }        }        return $frequencies;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distribution_3509," Cumulative frequency distribution\n\n The values of the input array will be the keys of the result array.\n The cumulative frequency of the values will be the value of the result array for that key.\n\n @param array $values Ex: ( A, A, A, A, A, A, B, B, B, C )\n\n @return array cumulative frequency distribution Ex: ( A => 6, B => 9, C => 10 )\n", Cumulative frequency distribution,    public static function cumulativeFrequency(array $values): array    {        $running_total          = 0;        $cumulative_frequencies = array();        foreach (self::frequency($values) as $value => $frequency) {            $running_total += $frequency;            $cumulative_frequencies[$value] = $running_total;        }        return $cumulative_frequencies;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distribution_3510," Cumulative relative frequency distribution\\n Cumulative frequency distribution relative to the sample size.\\n\\n Cumulative relative frequency = cumulative frequency / sample size\\n\\n The values of the input array will be the keys of the result array.\\n The cumulative frequency of the values will be the value of the result array for that key.\\n\\n @param array $values Ex: ( A, A, A, A, A, A, B, B, B, C )\\n\\n @return array cumulative relative frequency distribution Ex: ( A => 0.6, B => 0.9, C => 1 )\\n", Cumulative relative frequency distribution,"    public static function cumulativeRelativeFrequency(array $values): array    {        $sample_size            = \count($values);        $cumulative_frequencies = self::cumulativeFrequency($values);        return \array_map(            function ($frequency) use ($sample_size) {                return $frequency / $sample_size;            },            $cumulative_frequencies        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distribution_3511," Assign a fractional average ranking to data - (""1 2.5 2.5 4"" ranking)\\n https://en.wikipedia.org/wiki/Ranking\\n\\n Similar to R: rank(values, ties.method=\\\'average\\\')\\n\\n @param array $values to be ranked\\n\\n @return array Rankings of the data in the same order the values were input\\n"," Assign a fractional average ranking to data - (""1 2.5 2.5 4"" ranking)","    public static function fractionalRanking(array $values): array    {        $Xs = $values;        \sort($Xs);        // Determine ranks - some items might show up multiple times, so record each successive rank.        $ordinalRanking⟮X⟯ = [];        foreach ($Xs as $rank => $xᵢ) {            $ordinalRanking⟮X⟯[\strval($xᵢ)][] = $rank + 1;        }        // Determine average rank of each value. Necessary when values show up multiple times.        // Rank will not change if value only shows up once.        $rg⟮X⟯ = \array_map(            function (array $x) {                return \array_sum($x) / \count($x);            },            $ordinalRanking⟮X⟯        );        // Map ranks to values in order they were originally input        return \array_map(            function ($value) use ($rg⟮X⟯) {                return $rg⟮X⟯[\strval($value)];            },            $values        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distribution_3512," Assign a standard competitive ranking to data - (""1224"" ranking)\\n https://en.wikipedia.org/wiki/Ranking\\n\\n Similar to R: rank(values, ties.method=\\\'min\\\')\\n\\n @param array $values to be ranked\\n\\n @return array Rankings of the data in the same order the values were input\\n"," Assign a standard competitive ranking to data - (""1224"" ranking)","    public static function standardCompetitionRanking(array $values): array    {        $count = \count($values);        $Xs    = $values;        \sort($Xs);        $ranking⟮X⟯    = [];        $ranking⟮X⟯[0] = 1;        for ($i = 1; $i < $count; $i++) {            $ranking⟮X⟯[$i] = $Xs[$i] == $Xs[$i - 1]                ? $ranking⟮X⟯[$i - 1]                : $i + 1;        }        $ranking⟮X⟯ = \array_combine(\array_map('\strval', $Xs), $ranking⟮X⟯);        // Map ranks to values in order they were originally input        return \array_map(            function ($value) use ($ranking⟮X⟯) {                return $ranking⟮X⟯[\strval($value)];            },            $values        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distribution_3514," Assign an ordinal ranking to data - (""1234"" ranking)\n https://en.wikipedia.org/wiki/Ranking\n\n Similar to R: rank(values, ties.method=\'first\')\n\n @param array $values to be ranked\n\n @return array Rankings of the data in the same order the values were input\n"," Assign an ordinal ranking to data - (""1234"" ranking)",    public static function ordinalRanking(array $values): array    {        $Xs = $values;        \sort($Xs);        $ranking⟮X⟯ = [];        foreach ($Xs as $i => $x) {            $ranking⟮X⟯[\strval($x)][] = $i + 1;        }        // Map ranks to values in order they were originally input        $rankedValues = [];        foreach ($values as $value) {            $rankedValues[] = \array_shift($ranking⟮X⟯[\strval($value)]);        }        return $rankedValues;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_DivergenceTest_6048," Test data created using Python's scipi.stats.Distance\\n @return array [p, q, distance]\\n", Test data created using Python's scipi.stats.Distance,"    public function dataProviderForKullbackLeibler(): array    {        return [            [                [0.5, 0.5],                [0.75, 0.25],                0.14384103622589045,            ],            [                [0.75, 0.25],                [0.5, 0.5],                0.13081203594113694,            ],            [                [0.2, 0.5, 0.3],                [0.1, 0.4, 0.5],                0.096953524639296684,            ],            [                [0.4, 0.6],                [0.3, 0.7],                0.022582421084357374            ],            [                [0.9, 0.1],                [0.1, 0.9],                1.7577796618689758            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Divergence_3516," Kullback-Leibler divergence\n (also known as: discrimination information, information divergence, information gain, relative entropy, KLIC, KL divergence)\n A measure of the difference between two probability distributions P and Q.\n https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\n\n                       P(i)\n Dkl(P‖Q) = ∑ P(i) log ----\n            ⁱ\u2009         Q(i)\n\n\n\n @param  array  $p distribution p\n @param  array  $q distribution q\n\n @return float difference between distributions\n\n @throws Exception\\BadDataException if p and q do not have the same number of elements\n @throws Exception\\BadDataException if p and q are not probability distributions that add up to 1\n", Kullback-Leibler divergence,"    public static function kullbackLeibler(array $p, array $q): float    {        // Arrays must have the same number of elements        if (\count($p) !== \count($q)) {            throw new Exception\BadDataException('p and q must have the same number of elements');        }        // Probability distributions must add up to 1.0        if ((\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) || (\abs(\array_sum($q) - 1) > self::ONE_TOLERANCE)) {            throw new Exception\BadDataException('Distributions p and q must add up to 1');        }        // Defensive measures against taking the log of 0 which would be -∞ or dividing by 0        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        $q = \array_map(            function ($qᵢ) {                return $qᵢ == 0 ? 1e-15 : $qᵢ;            },            $q        );        // ∑ P(i) log(P(i)/Q(i))        $Dkl⟮P‖Q⟯ = \array_sum(\array_map(            function ($P, $Q) {                return $P * \log($P / $Q);            },            $p,            $q        ));        return $Dkl⟮P‖Q⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Divergence_3517," Jensen-Shannon divergence\\n Also known as: information radius (IRad) or total divergence to the average.\\n A method of measuring the similarity between two probability distributions.\\n It is based on the Kullback–Leibler divergence, with some notable (and useful) differences,\\n including that it is symmetric and it is always a finite value.\\n https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence\\n\\n            1          1\\n JSD(P‖Q) = - D(P‖M) + - D(Q‖M)\\n            2          2\\n\\n           1\\n where M = - (P + Q)\\n           2\\n\\n       D(P‖Q) = Kullback-Leibler divergence\\n\\n @param array $p distribution p\\n @param array $q distribution q\\n\\n @return float difference between distributions\\n\\n @throws Exception\\\\BadDataException if p and q do not have the same number of elements\\n @throws Exception\\\\BadDataException if p and q are not probability distributions that add up to 1\\n", Jensen-Shannon divergence,"    public static function jensenShannon(array $p, array $q): float    {        // Arrays must have the same number of elements        if (\count($p) !== \count($q)) {            throw new Exception\BadDataException('p and q must have the same number of elements');        }        // Probability distributions must add up to 1.0        if ((\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) || (\abs(\array_sum($q) - 1) > self::ONE_TOLERANCE)) {            throw new Exception\BadDataException('Distributions p and q must add up to 1');        }        $M = \array_map(            function ($pᵢ, $qᵢ) {                return ($pᵢ + $qᵢ) / 2;            },            $p,            $q        );        $½D⟮P‖M⟯ = self::kullbackLeibler($p, $M) / 2;        $½D⟮Q‖M⟯ = self::kullbackLeibler($q, $M) / 2;        return $½D⟮P‖M⟯ + $½D⟮Q‖M⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Eigenvalue_2615, Find eigenvalues by the Jacobi method\\n\\n https://en.wikipedia.org/wiki/Jacobi_eigenvalue_algorithm\\n\\n @param NumericMatrix $A\\n\\n @return float[] of eigenvalues\\n\\n @throws Exception\\\\BadDataException if the matrix is not symmetric\\n @throws Exception\\\\BadDataException if the matrix is 1x1\\n @throws Exception\\\\MathException\\n, Find eigenvalues by the Jacobi method,"    public static function jacobiMethod(NumericMatrix $A): array    {        if (!$A->isSymmetric()) {            throw new Exception\BadDataException('Matrix must be symmetric');        }        $m = $A->getM();        if ($m < 2) {            throw new Exception\BadDataException(""Matrix must be 2x2 or larger"");        }        $D = $A;        $S = MatrixFactory::identity($m);        $iterations = 0; // For infinitely oscillating edge cases between very small positive and negative numbers that don't converge        while (!$D->isDiagonal()) {            // Find the largest off-diagonal element in $D            $pivot = ['value' => 0, 'i' => 0, 'j' => 0];            for ($i = 0; $i < $m - 1; $i++) {                for ($j = $i + 1; $j < $m; $j++) {                    if (\abs($D[$i][$j]) > \abs($pivot['value'])) {                        $pivot['value'] = $D[$i][$j];                        $pivot['i']     = $i;                        $pivot['j']     = $j;                    }                }            }            $i     = $pivot['i'];            $j     = $pivot['j'];            $angle = ($D[$i][$i] == $D[$j][$j])                ? ($D[$i][$i] > 0 ? 1 : -1) * \M_PI / 4                : \atan(2 * $D[$i][$j] / ($D[$i][$i] - $D[$j][$j])) / 2;            $G = MatrixFactory::givens($i, $j, $angle, $m);            $D = $G->transpose()->multiply($D)->multiply($G);            $S = $S->multiply($G);            // To prevent infinite looping when zero-like oscillations don't converge            $iterations++;            if ($iterations > 200) {                break;            }        }        $eigenvalues = $D->getDiagonalElements();        \usort($eigenvalues, function ($a, $b) {            return \abs($b) <=> \abs($a);        });        return $eigenvalues;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Entropy_2601," Functions dealing with information entropy in the field of statistical field of information thoery.\n\n - Entropy:\n   - Shannon entropy (bits)\n   - Shannon entropy (nats)\n   - Shannon entropy (harts)\n   - Cross entropy\n\n In information theory, entropy is the expected value (average) of the information contained in each message.\n\n https://en.wikipedia.org/wiki/Entropy_(information_theory)\n", Functions dealing with information entropy in the field of statistical field of information thoery.,"class Entropy{    private const ONE_TOLERANCE = 0.010001;    /**     * Shannon entropy (bit entropy)     * The average minimum number of bits needed to encode a string of symbols, based on the probability of the symbols.     * https://en.wikipedia.org/wiki/Entropy_(information_theory)     *     * H = -∑ pᵢlog₂(pᵢ)     *     * H is in shannons, or bits.     *     * @param  array $p probability distribution     *     * @return float average minimum number of bits     *     * @throws Exception\BadDataException if probability distribution p does not add up to 1     */    public static function shannonEntropy(array $p)    {        // Probability distribution must add up to 1.0        if (\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) {            throw new Exception\BadDataException('Probability distribution p must add up to 1; p adds up to: ' . \array_sum($p));        }        // Defensive measure against taking the log of 0 which would be -∞        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        // ∑ pᵢlog₂(pᵢ)        $∑pᵢlog₂⟮pᵢ⟯ = \array_sum(\array_map(            function ($pᵢ) {                return $pᵢ * \log($pᵢ, 2);            },            $p        ));        return -$∑pᵢlog₂⟮pᵢ⟯;    }    /**     * Shannon nat entropy (nat entropy)     * The average minimum number of nats needed to encode a string of symbols, based on the probability of the symbols.     * https://en.wikipedia.org/wiki/Entropy_(information_theory)     *     * H = -∑ pᵢln(pᵢ)     *     * H is in units of nats.     * 1 nat = 1/ln(2) shannons or bits.     * https://en.wikipedia.org/wiki/Nat_(unit)     *     * @param  array $p probability distribution     *     * @return float average minimum number of nats     *     * @throws Exception\BadDataException if probability distribution p does not add up to 1     */    public static function shannonNatEntropy(array $p)    {        // Probability distribution must add up to 1.0        if (\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) {            throw new Exception\BadDataException('Probability distribution p must add up to 1; p adds up to: ' . \array_sum($p));        }        // Defensive measure against taking the log of 0 which would be -∞        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        // ∑ pᵢln(pᵢ)        $∑pᵢln⟮pᵢ⟯ = \array_sum(\array_map(            function ($pᵢ) {                return $pᵢ * \log($pᵢ);            },            $p        ));        return -$∑pᵢln⟮pᵢ⟯;    }    /**     * Shannon hartley entropy (hartley entropy)     * The average minimum number of hartleys needed to encode a string of symbols, based on the probability of the symbols.     * https://en.wikipedia.org/wiki/Entropy_(information_theory)     *     * H = -∑ pᵢlog₁₀(pᵢ)     *     * H is in units of hartleys, or harts.     * 1 hartley = log₂(10) bit = ln(10) nat, or approximately 3.322 Sh, or 2.303 nat.     * https://en.wikipedia.org/wiki/Hartley_(unit)     *     * @param  array $p probability distribution     *     * @return float average minimum number of hartleys     *     * @throws Exception\BadDataException if probability distribution p does not add up to 1     */    public static function shannonHartleyEntropy(array $p)    {        // Probability distribution must add up to 1.0        if (\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) {            throw new Exception\BadDataException('Probability distribution p must add up to 1; p adds up to: ' . \array_sum($p));        }        // Defensive measure against taking the log of 0 which would be -∞        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        // ∑ pᵢlog₁₀(pᵢ)        $∑pᵢlog₁₀⟮pᵢ⟯ = \array_sum(\array_map(            function ($pᵢ) {                return $pᵢ * \log10($pᵢ);            },            $p        ));        return -$∑pᵢlog₁₀⟮pᵢ⟯;    }    /**     * Cross entropy     * The cross entropy between two probability distributions p and q over the same underlying set of events     * measures the average number of bits needed to identify an event drawn from the set, if a coding scheme     * is used that is optimized for an ""unnatural"" probability distribution q, rather than the ""true"" distribution p.     * https://en.wikipedia.org/wiki/Cross_entropy     *     * H(p,q) = -∑ p(x) log₂ q(x)     *     * @param array $p distribution p     * @param array $q distribution q     *     * @return float entropy between distributions     *     * @throws Exception\BadDataException if p and q do not have the same number of elements     * @throws Exception\BadDataException if p and q are not probability distributions that add up to 1     */    public static function crossEntropy(array $p, array $q)    {        // Arrays must have the same number of elements        if (\count($p) !== \count($q)) {            throw new Exception\BadDataException('p and q must have the same number of elements');        }        // Probability distributions must add up to 1.0        if ((\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) || (\abs(\array_sum($q) - 1) > self::ONE_TOLERANCE)) {            throw new Exception\BadDataException('Distributions p and q must add up to 1');        }        // Defensive measure against taking the log of 0 which would be -∞        $q = \array_map(            function ($qᵢ) {                return $qᵢ == 0 ? 1e-15 : $qᵢ;            },            $q        );        // ∑ p(x) log₂ q(x)        $∑plog₂⟮q⟯ = \array_sum(\array_map(            function ($pᵢ, $qᵢ) {                return $pᵢ * \log($qᵢ, 2);            },            $p,            $q        ));        return -$∑plog₂⟮q⟯;    }    /**     * Joint entropy (bits)     * A measure of the uncertainty associated with a set of variables.     * https://en.wikipedia.org/wiki/Joint_entropy     *     * H(X,Y) = -∑ ∑ P(x,y)log₂[P(x,y)]     *           x y     *     * Where x and y are particular values of random variables X and Y, respectively,     * and P(x,y) is the joint probability of these values occurring together.     * H is in shannons, or bits.     *     * Joint entropy is basically just shannonEntropy but the probability distribution input     * represents the probability of two variables happening at the same time.     *     * @param  array $P⟮x、y⟯ probability distribution of x and y occuring together     *     * @return float uncertainty     *     * @throws Exception\BadDataException if probability distribution $P⟮x、y⟯ does not add up to 1     */    public static function jointEntropy(array $P⟮x、y⟯)    {        return self::shannonEntropy($P⟮x、y⟯);    }    /**     * Rényi entropy     * Rényi entropy generalizes the Hartley entropy, the Shannon entropy, the collision entropy and the min entropy     * https://en.wikipedia.org/wiki/R%C3%A9nyi_entropy     *           1     * Hₐ(X) = ----- log₂(∑ pᵢᵃ)     *         1 - α     *     * α ≥ 0; α ≠ 1     *     * H is in shannons, or bits.     *     * @param  array  $p probability distribution     * @param  number $α order α     *     * @return float     *     * @throws Exception\BadDataException if probability distribution p does not add up to 1     * @throws Exception\OutOfBoundsException if α < 0 or α = 1     */    public static function renyiEntropy(array $p, $α)    {        // Probability distribution must add up to 1.0        if (\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) {            throw new Exception\BadDataException('Probability distribution p must add up to 1; p adds up to: ' . \array_sum($p));        }        // α ≥ 0; α ≠ 1        if ($α < 0 || $α == 1) {            throw new Exception\OutOfBoundsException(""α must be ≥ 0 and ≠ 1 "");        }        // (1 / 1 - α) log (∑ pᵢᵃ)        $Hₐ⟮X⟯ = (1 / (1 - $α)) * \log(\array_sum(Map\Single::pow($p, $α)), 2);        return $Hₐ⟮X⟯;    }    /**     * Perplexity     * a measurement of how well a probability distribution or probability model predicts a sample.     * It may be used to compare probability models.     * A low perplexity indicates the probability distribution is good at predicting the sample.     * https://en.wikipedia.org/wiki/Perplexity     *     * perplexity = 2ᴴ⁽ᵖ⁾ = 2^(-∑ pᵢlog₂(pᵢ))     * where H(p) = entropy     *     * Perplexity is in shannons, or bits.     *     * @param  array $p probability distribution     *     * @return float perplexity     *     * @throws Exception\BadDataException if probability distribution p does not add up to 1     */    public static function perplexity(array $p)    {        // Probability distribution must add up to 1.0        if (\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) {            throw new Exception\BadDataException('Probability distribution p must add up to 1; p adds up to: ' . \array_sum($p));        }        // ∑ pᵢlog₂(pᵢ)        $H⟮p⟯ = self::shannonEntropy($p);        return 2 ** $H⟮p⟯;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Entropy_2602," Shannon entropy (bit entropy)\n The average minimum number of bits needed to encode a string of symbols, based on the probability of the symbols.\n https://en.wikipedia.org/wiki/Entropy_(information_theory)\n\n H = -∑ pᵢlog₂(pᵢ)\n\n H is in shannons, or bits.\n\n @param  array $p probability distribution\n\n @return float average minimum number of bits\n\n @throws Exception\\BadDataException if probability distribution p does not add up to 1\n", Shannon entropy (bit entropy),"    public static function shannonEntropy(array $p)    {        // Probability distribution must add up to 1.0        if (\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) {            throw new Exception\BadDataException('Probability distribution p must add up to 1; p adds up to: ' . \array_sum($p));        }        // Defensive measure against taking the log of 0 which would be -∞        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        // ∑ pᵢlog₂(pᵢ)        $∑pᵢlog₂⟮pᵢ⟯ = \array_sum(\array_map(            function ($pᵢ) {                return $pᵢ * \log($pᵢ, 2);            },            $p        ));        return -$∑pᵢlog₂⟮pᵢ⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Entropy_2603," Shannon nat entropy (nat entropy)\n The average minimum number of nats needed to encode a string of symbols, based on the probability of the symbols.\n https://en.wikipedia.org/wiki/Entropy_(information_theory)\n\n H = -∑ pᵢln(pᵢ)\n\n H is in units of nats.\n 1 nat = 1/ln(2) shannons or bits.\n https://en.wikipedia.org/wiki/Nat_(unit)\n\n @param  array $p probability distribution\n\n @return float average minimum number of nats\n\n @throws Exception\\BadDataException if probability distribution p does not add up to 1\n", Shannon nat entropy (nat entropy),"    public static function shannonNatEntropy(array $p)    {        // Probability distribution must add up to 1.0        if (\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) {            throw new Exception\BadDataException('Probability distribution p must add up to 1; p adds up to: ' . \array_sum($p));        }        // Defensive measure against taking the log of 0 which would be -∞        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        // ∑ pᵢln(pᵢ)        $∑pᵢln⟮pᵢ⟯ = \array_sum(\array_map(            function ($pᵢ) {                return $pᵢ * \log($pᵢ);            },            $p        ));        return -$∑pᵢln⟮pᵢ⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Entropy_2604," Shannon hartley entropy (hartley entropy)\\n The average minimum number of hartleys needed to encode a string of symbols, based on the probability of the symbols.\\n https://en.wikipedia.org/wiki/Entropy_(information_theory)\\n\\n H = -∑ pᵢlog₁₀(pᵢ)\\n\\n H is in units of hartleys, or harts.\\n 1 hartley = log₂(10) bit = ln(10) nat, or approximately 3.322 Sh, or 2.303 nat.\\n https://en.wikipedia.org/wiki/Hartley_(unit)\\n\\n @param  array $p probability distribution\\n\\n @return float average minimum number of hartleys\\n\\n @throws Exception\\\\BadDataException if probability distribution p does not add up to 1\\n", Shannon hartley entropy (hartley entropy),"    public static function shannonHartleyEntropy(array $p)    {        // Probability distribution must add up to 1.0        if (\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) {            throw new Exception\BadDataException('Probability distribution p must add up to 1; p adds up to: ' . \array_sum($p));        }        // Defensive measure against taking the log of 0 which would be -∞        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        // ∑ pᵢlog₁₀(pᵢ)        $∑pᵢlog₁₀⟮pᵢ⟯ = \array_sum(\array_map(            function ($pᵢ) {                return $pᵢ * \log10($pᵢ);            },            $p        ));        return -$∑pᵢlog₁₀⟮pᵢ⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Entropy_2606," Joint entropy (bits)\n A measure of the uncertainty associated with a set of variables.\n https://en.wikipedia.org/wiki/Joint_entropy\n\n H(X,Y) = -∑ ∑ P(x,y)log₂[P(x,y)]\n           x y\n\n Where x and y are particular values of random variables X and Y, respectively,\n and P(x,y) is the joint probability of these values occurring together.\n H is in shannons, or bits.\n\n Joint entropy is basically just shannonEntropy but the probability distribution input\n represents the probability of two variables happening at the same time.\n\n @param  array $P⟮x、y⟯ probability distribution of x and y occuring together\n\n @return float uncertainty\n\n @throws Exception\\BadDataException if probability distribution $P⟮x、y⟯ does not add up to 1\n", Joint entropy (bits),    public static function jointEntropy(array $P⟮x、y⟯)    {        return self::shannonEntropy($P⟮x、y⟯);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Experiment_3529," Odds ratio (OR)\\n Computes odds ratio and 95% confidence ratio.\\n\\n Ratio which quantitatively describes the association between the presence/absence\\n of ""A"" and the presence/absence of ""B"" for individuals in the population.\\n https://en.wikipedia.org/wiki/Odds_ratio\\n http://www.bmj.com/content/343/bmj.d2304\\n\\n      a / b\\n OR = -----\\n      c / d\\n\\n Standard error of the log odds ratio:\\n                ______________\\n               / 1   1   1   1\\n SS{ln(OR)} = /  - + - - - + -\\n             √   a   b   c   d\\n\\n CI Range(95%) = exp( ln(OR) - z × SS{ln(OR)} ) to exp( ln(OR) + z × SS{ln(OR)} )\\n\\n P = exp((-0.717 \\n @param  int   $a Exposed and event present\\n @param  int   $b Exposed and event absent\\n @param  int   $c Non-exposed and event present\\n @param  int   $d Non-exposed and event absent\\n\\n @return array [ OR, ci_lower_bound, ci_upper_bound, p ]\\n", Odds ratio (OR),"    public static function oddsRatio(int $a, int $b, int $c, int $d): array    {        // Odds ratio        $OR = ($a / $b) / ($c / $d);        // Standard error of the log odds ratio        $ln⟮OR⟯     = \log($OR);        $SS｛ln⟮OR⟯｝ = \sqrt((1 / $a) + (1 / $b) + (1 / $c) + (1 / $d));        // Confidence interval        $ci_lower_bound = \exp($ln⟮OR⟯ - (self::Z * $SS｛ln⟮OR⟯｝));        $ci_upper_bound = \exp($ln⟮OR⟯ + (self::Z * $SS｛ln⟮OR⟯｝));        // P-value (significance level)        $est = \log($OR);                   // estimate of effect        $l   = \log($ci_lower_bound);       // ln CI lower bound        $u   = \log($ci_upper_bound);       // ln CI upper bound        $SE  = ($u - $l) / (2 * self::Z);  // standard error        $z   = \abs($est / $SE);            // test statistic z        $p   = \exp((self::NORMAL_LOWER_TAIL_PROBABILITY * $z) - (self::NORMAL_UPPER_TAIL_PROBABILITY * $z ** 2));        return [            'OR'             => $OR,            'ci_lower_bound' => $ci_lower_bound,            'ci_upper_bound' => $ci_upper_bound,            'p'              => $p,        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Experiment_3530," Likelihood ratio\n Computes positive and negative likelihood ratios from a, b, c, d variables.\n\n Used to analyze the goodness of a diagnostic tests.\n https://en.wikipedia.org/wiki/Likelihood_ratios_in_diagnostic_testing\n\n       a / (a + c)\n LL+ = -----------\n       b / (b + d)\n\n       c / (a + c)\n LL- = -----------\n       d / (b + d)\n\n @param  int   $a Exposed and event present\n @param  int   $b Exposed and event absent\n @param  int   $c Non-exposed and event present\n @param  int   $d Non-exposed and event absent\n\n @return array [ LL+, LL- ]\n", Likelihood ratio,"    public static function likelihoodRatio(int $a, int $b, int $c, int $d): array    {        // LL+ Positive likelihood ratio        $LL＋ = ($a / ($a + $c)) / ($b / ($b + $d));        // LL- Negative likelihood ratio        $LL− = ($c / ($a + $c)) / ($d / ($b + $d));        return [            'LL+' => $LL＋,            'LL-' => $LL−,        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Exponential_3102, Inverse cumulative distribution function (quantile function)\\n\\n            −ln(1 − p)\\n F⁻¹(p;λ) = ----------    0 ≤ p < 1\\n                λ\\n\\n @param float $p\\n\\n @return float\\n\\n @throws OutOfBoundsException\\n, Inverse cumulative distribution function (quantile function),"    public function inverse(float $p): float    {        if ($p < 0 || $p > 1) {            throw new OutOfBoundsException(""p must be between 0 and 1; given a p of $p"");        }        if ($p == 1) {            return \INF;        }        return -\log(1 - $p) / $this->λ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Exponential_3103, Mean of the distribution\n\n μ = λ⁻¹\n\n @return float\n, Mean of the distribution,    public function mean(): float    {        return 1 / $this->λ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Exponential_3104, Median of the distribution\n\n          ln(2)\n median = -----\n            λ\n\n @return float\n, Median of the distribution,    public function median(): float    {        return \log(2) / $this->λ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_F_3109," Probability density function\n\n      __________________\n     / (d₁ x)ᵈ¹ d₂ᵈ²\n    /  ----------------\n   √   (d₁ x + d₂)ᵈ¹⁺ᵈ²\n   ---------------------\n           / d₁  d₂ \\\n      x B |  --, --  |\n           \\ 2   2  /\n\n @param float $x  percentile ≥ 0\n\n @todo how to handle x = 0\n\n @return float probability\n", Probability density function,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $d₁ = $this->d₁;        $d₂ = $this->d₂;        // Numerator        $⟮d₁x⟯ᵈ¹d₂ᵈ²                = ($d₁ * $x) ** $d₁ * $d₂ ** $d₂;        $⟮d₁x＋d₂⟯ᵈ¹⁺ᵈ²             = ($d₁ * $x + $d₂) ** ($d₁ + $d₂);        $√⟮d₁x⟯ᵈ¹d₂ᵈ²／⟮d₁x＋d₂⟯ᵈ¹⁺ᵈ² = \sqrt($⟮d₁x⟯ᵈ¹d₂ᵈ² / $⟮d₁x＋d₂⟯ᵈ¹⁺ᵈ²);        // Denominator        $xB⟮d₁／2、d₂／2⟯ = $x * Special::beta($d₁ / 2, $d₂ / 2);        return $√⟮d₁x⟯ᵈ¹d₂ᵈ²／⟮d₁x＋d₂⟯ᵈ¹⁺ᵈ² / $xB⟮d₁／2、d₂／2⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_F_3111, Mean of the distribution\\n\\n       d₂\\n μ = ------  for d₂ > 2\\n     d₂ - 2\\n\\n @return float\\n, Mean of the distribution,    public function mean(): float    {        $d₂ = $this->d₂;        if ($d₂ > 2) {            return $d₂ / ($d₂ - 2);        }        return \NAN;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_F_3113, Variance of the distribution\n\n          2d₂²(d₁ + d₂ - 2)\n var[X] = -------------------   d₂ > 4\n          d₁(d₂ - 2)²(d₂ - 4)\n\n @return float\n, Variance of the distribution,    public function variance(): float    {        $d₁ = $this->d₁;        $d₂ = $this->d₂;        if ($d₂ <= 4) {            return \NAN;        }        $２d₂²⟮d₁ ＋ d₂ − 2⟯ = (2 * $d₂ ** 2) * ($d₁ + $d₂ - 2);        $d₁⟮d₂ − 2⟯²⟮d₂ − 4⟯  = ($d₁ * ($d₂ - 2) ** 2) * ($d₂ - 4);        return $２d₂²⟮d₁ ＋ d₂ − 2⟯ / $d₁⟮d₂ − 2⟯²⟮d₂ − 4⟯;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Finance_2506," Profitability Index.\\n The Profitability Index, also referred to as Profit Investment\\n Ratio (PIR) and Value Investment Ratio (VIR), is a comparison of\\n discounted cash inflows to discounted cash outflows. It can be\\n used as a decision criteria of an investment, using larger than 1\\n to choose an investment, and less than 1 to pass.\\n\\n The formula derivation:\\n https://en.wikipedia.org/wiki/Profitability_index\\n\\n PV(cash inflows)\\n ----------------\\n PV(cash outflows)\\n\\n The formula is usually stated in terms of the initial investmest,\\n but it is generalized here to discount all future outflows.\\n\\n Examples:\\n The profitability index of an initial $100 investment with future\\n returns of $50, $50, $50 with a 10% discount rate:\\n  profitabilityIndex([-100, 50, 50, 50], 0.10)\\n\\n @param  array $values\\n @param  float $rate\\n\\n @return float\\n", Profitability Index.,"    public static function profitabilityIndex(array $values, float $rate): float    {        $inflows  = array();        $outflows = array();        for ($i = 0; $i < \count($values); $i++) {            if ($values[$i] >= 0) {                $inflows[]  = $values[$i];                $outflows[] = 0;            } else {                $inflows[]  = 0;                $outflows[] = -$values[$i];            }        }        $nonzero = function ($x) {            return $x != 0;        };        if (\count(\array_filter($outflows, $nonzero)) == 0) {            return \NAN;        }        $pv_inflows  = self::npv($rate, $inflows);        $pv_outflows = self::npv($rate, $outflows);        return $pv_inflows / $pv_outflows;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_FivePointFormula_3006," Five Point Formula\\n\\n In numerical analysis, the five point formula is used for approximating\\n the derivative of a function at a point in its domain.\\n\\n We can either directly supply a set of inputs and their corresponding outputs\\n for said function, or if we explicitly know the function, we can define it as a\\n callback function and then generate a set of points by evaluating that function\\n at 5 points between a start and end point.\\n", Five Point Formula,"class FivePointFormula extends NumericalDifferentiation{    /**     * Use the Five Point Formula to approximate the derivative of a function at     * our $target. Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose derivative we are     * approximating.     *     * The Five Point Formula requires we supply 5 points that are evenly spaced     * apart, and that our target equals the x-components of one of our 5 points.     *     * Example: differentiation(2, function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Five Point Formula:     *     *   - If the 3rd point is our $target, use the Midpoint Formula:     *     *              1                                         h⁴     *     f′(x₀) = - [f(x₀-2h)-8f(x₀-h)+8f(x₀+h)-f(x₀+2h)] - - f⁽⁵⁾(ζ₁)     *             12h                                        30     *     *         where ζ₁ lies between x₀ - 2h and x₀ + 2h     *     *   - If the 1st or 5th point is our $target, use the Endpoint Formula:     *   - Note that when the 3rd point is our $target, we use a negative h.     *     *              1                                                        h⁴     *     f′(x₀) = - [-25f(x₀)+48f(x₀+h)-36f(x₀+2h)+16f(x₀+3h)-3f(x₀+4h)] + - f⁽⁵⁾(ζ₀)     *             12h                                                       5     *     *         where ζ₀ lies between x₀ and x₀ + 4h     *     * @param float          $target  The value at which we are approximating the derivative     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4], [4,5], [5,6]].     *                                Example callback: function($x) {return $x**2;}     * @param number         ...$args The arguments of our callback function: start,     *                                end, and n. Example: approximate($number, $source, 0, 8, 5).     *                                If $source is a set of points, do not input any     *                               $args. Example: approximate($source).     *     * @return float                 The approximation of f'($target), i.e. the derivative     *                               of our input at our target point     *     * @throws Exception\BadDataException     */    public static function differentiate(float $target, $source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input, sort points, make sure spacing is constant, and make        // sure our target is contained in an interval supplied by our $source        self::validate($points, $degree = 5);        $sorted = self::sort($points);        self::isSpacingConstant($sorted);        self::isTargetInPoints($target, $sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $h = ($sorted[4][$x] - $sorted[0][$x]) / 4;        /*         * If the 3rd point is our $target, use the Midpoint Formula:         *         *              1                                         h⁴         *     f′(x₀) = - [f(x₀-2h)-8f(x₀-h)+8f(x₀+h)-f(x₀+2h)] - - f⁽⁵⁾(ζ₁)         *             12h                                        30         *         *         where ζ₁ lies between x₀ - 2h and x₀ + 2h         */        if ($sorted[2][$x] == $target) {            $f⟮x₀⧿2h⟯    = $sorted[0][$y];            $f⟮x₀⧿h⟯     = $sorted[1][$y];            $f⟮x₀⧾h⟯     = $sorted[3][$y];            $f⟮x₀⧾2h⟯    = $sorted[4][$y];            $derivative = ($f⟮x₀⧿2h⟯ - 8 * $f⟮x₀⧿h⟯ + 8 * $f⟮x₀⧾h⟯ - $f⟮x₀⧾2h⟯) / (12 * $h);            return $derivative;        }        /*         * If the 1st or 5th point is our $target, use the Endpoint Formula:         * Note that when the 3rd point is our $target, we use a negative h.         *         *              1                                                        h⁴         *     f′(x₀) = - [-25f(x₀)+48f(x₀+h)-36f(x₀+2h)+16f(x₀+3h)-3f(x₀+4h)] + - f⁽⁵⁾(ζ₀)         *             12h                                                       5         *         *         where ζ₀ lies between x₀ and x₀ + 4h         */        if ($sorted[0][$x] == $target) {  // The 1st point is our $target            $f⟮x₀⟯    = $sorted[0][$y];            $f⟮x₀⧾h⟯  = $sorted[1][$y];            $f⟮x₀⧾2h⟯ = $sorted[2][$y];            $f⟮x₀⧾3h⟯ = $sorted[3][$y];            $f⟮x₀⧾4h⟯ = $sorted[4][$y];        } else {                          // The 5th point is our $target, use negative h            $h = -$h;            $f⟮x₀⟯    = $sorted[4][$y];            $f⟮x₀⧾h⟯  = $sorted[3][$y];            $f⟮x₀⧾2h⟯ = $sorted[2][$y];            $f⟮x₀⧾3h⟯ = $sorted[1][$y];            $f⟮x₀⧾4h⟯ = $sorted[0][$y];        }        $derivative = (-25 * $f⟮x₀⟯ + 48 * $f⟮x₀⧾h⟯ - 36 * $f⟮x₀⧾2h⟯ + 16 * $f⟮x₀⧾3h⟯ - 3 * $f⟮x₀⧾4h⟯) / (12 * $h);        return $derivative;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_FivePointFormula_3007," Use the Five Point Formula to approximate the derivative of a function at\\n our $target. Our input can support either a set of arrays, or a callback\\n function with arguments (to produce a set of arrays). Each array in our\\n input contains two numbers which correspond to coordinates (x, y) or\\n equivalently, (x, f(x)), of the function f(x) whose derivative we are\\n approximating.\\n\\n The Five Point Formula requires we supply 5 points that are evenly spaced\\n apart, and that our target equals the x-components of one of our 5 points.\\n\\n Example: differentiation(2, function($x) {return $x a set of arrays by evaluating the callback at 5 evenly spaced points\\n between 0 and 4. Then, this array will be used in our approximation.\\n\\n Five Point Formula:\\n\\n   - If the 3rd point is our $target, use the Midpoint Formula:\\n\\n              1                                         h⁴\\n     f′(x₀) = - [f(x₀-2h)-8f(x₀-h)+8f(x₀+h)-f(x₀+2h)] - - f⁽⁵⁾(ζ₁)\\n             12h                                        30\\n\\n         where ζ₁ lies between x₀ - 2h and x₀ + 2h\\n\\n   - If the 1st or 5th point is our $target, use the Endpoint Formula:\\n   - Note that when the 3rd point is our $target, we use a negative h.\\n\\n              1                                                        h⁴\\n     f′(x₀) = - [-25f(x₀)+48f(x₀+h)-36f(x₀+2h)+16f(x₀+3h)-3f(x₀+4h)] + - f⁽⁵⁾(ζ₀)\\n             12h                                                       5\\n\\n         where ζ₀ lies between x₀ and x₀ + 4h\\n\\n @param float          $target  The value at which we are approximating the derivative\\n @param callable|array $source  The source of our approximation. Should be either\\n                                a callback function or a set of arrays. Each array\\n                                (point) contains precisely two numbers, an x and y.\\n                                Example array: [[1,2], [2,3], [3,4], [4,5], [5,6]].\\n                                Example callback: function($x) {return $x @param number         ...$args The arguments of our callback function: start,\\n                                end, and n. Example: approximate($number, $source, 0, 8, 5).\\n                                If $source is a set of points, do not input any\\n                               $args. Example: approximate($source).\\n\\n @return float                 The approximation of f'($target), i.e. the derivative\\n                               of our input at our target point\\n\\n @throws Exception\\\\BadDataException\\n", Use the Five Point Formula to approximate the derivative of a function at,"    public static function differentiate(float $target, $source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input, sort points, make sure spacing is constant, and make        // sure our target is contained in an interval supplied by our $source        self::validate($points, $degree = 5);        $sorted = self::sort($points);        self::isSpacingConstant($sorted);        self::isTargetInPoints($target, $sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $h = ($sorted[4][$x] - $sorted[0][$x]) / 4;        /*         * If the 3rd point is our $target, use the Midpoint Formula:         *         *              1                                         h⁴         *     f′(x₀) = - [f(x₀-2h)-8f(x₀-h)+8f(x₀+h)-f(x₀+2h)] - - f⁽⁵⁾(ζ₁)         *             12h                                        30         *         *         where ζ₁ lies between x₀ - 2h and x₀ + 2h         */        if ($sorted[2][$x] == $target) {            $f⟮x₀⧿2h⟯    = $sorted[0][$y];            $f⟮x₀⧿h⟯     = $sorted[1][$y];            $f⟮x₀⧾h⟯     = $sorted[3][$y];            $f⟮x₀⧾2h⟯    = $sorted[4][$y];            $derivative = ($f⟮x₀⧿2h⟯ - 8 * $f⟮x₀⧿h⟯ + 8 * $f⟮x₀⧾h⟯ - $f⟮x₀⧾2h⟯) / (12 * $h);            return $derivative;        }        /*         * If the 1st or 5th point is our $target, use the Endpoint Formula:         * Note that when the 3rd point is our $target, we use a negative h.         *         *              1                                                        h⁴         *     f′(x₀) = - [-25f(x₀)+48f(x₀+h)-36f(x₀+2h)+16f(x₀+3h)-3f(x₀+4h)] + - f⁽⁵⁾(ζ₀)         *             12h                                                       5         *         *         where ζ₀ lies between x₀ and x₀ + 4h         */        if ($sorted[0][$x] == $target) {  // The 1st point is our $target            $f⟮x₀⟯    = $sorted[0][$y];            $f⟮x₀⧾h⟯  = $sorted[1][$y];            $f⟮x₀⧾2h⟯ = $sorted[2][$y];            $f⟮x₀⧾3h⟯ = $sorted[3][$y];            $f⟮x₀⧾4h⟯ = $sorted[4][$y];        } else {                          // The 5th point is our $target, use negative h            $h = -$h;            $f⟮x₀⟯    = $sorted[4][$y];            $f⟮x₀⧾h⟯  = $sorted[3][$y];            $f⟮x₀⧾2h⟯ = $sorted[2][$y];            $f⟮x₀⧾3h⟯ = $sorted[1][$y];            $f⟮x₀⧾4h⟯ = $sorted[0][$y];        }        $derivative = (-25 * $f⟮x₀⟯ + 48 * $f⟮x₀⧾h⟯ - 36 * $f⟮x₀⧾2h⟯ + 16 * $f⟮x₀⧾3h⟯ - 3 * $f⟮x₀⧾4h⟯) / (12 * $h);        return $derivative;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_FunctionMatrix_2619, Validate the matrix is entirely m x n\\n\\n @throws Exception\\\\BadDataException\\n, Validate the matrix is entirely m x n,"    protected function validateMatrixDimensions()    {        foreach ($this->A as $i => $row) {            if (\count($row) !== $this->n) {                throw new Exception\BadDataException(""Row $i has a different column count: "" . \count($row) . ""; was expecting {$this->n}."");            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_GammaTest_5201," Data provider for variance\n @return array [k, θ, variance]\n", Data provider for variance,"    public function dataProviderForVariance(): array    {        return [            [1, 1, 1],            [1, 2, 4],            [2, 1, 2],            [2, 2, 8],            [2, 3, 18],            [3, 1, 3],            [3, 2, 12],            [3, 3, 27],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Gamma_3115, Gamma distribution\n https://en.wikipedia.org/wiki/Gamma_distribution\n, Gamma distribution,"class Gamma extends Continuous{    /**     * Distribution parameter bounds limits     * k ∈ (0,∞)     * θ ∈ (0,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'k' => '(0,∞)',        'θ' => '(0,∞)',    ];    /**     * Distribution suport bounds limits     * x ∈ (0,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '(0,∞)',    ];    /** @var float shape parameter k > 0 */    protected $k;    /** @var float shape parameter θ > 0 */    protected $θ;    /**     * Constructor     *     * @param float $k shape parameter k > 0     * @param float $θ scale parameter θ > 0     */    public function __construct(float $k, float $θ)    {        parent::__construct($k, $θ);    }    /**     * Probability density function     *     *                     ₓ     *          1         ⁻-     * pdf = ------ xᵏ⁻¹ e θ     *       Γ(k)θᵏ     *     * @param float $x percentile      x > 0     *     * @return float     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $k = $this->k;        $θ = $this->θ;        $Γ⟮k⟯   = Special::Γ($k);        $θᵏ    = $θ ** $k;        $Γ⟮k⟯θᵏ = $Γ⟮k⟯ * $θᵏ;        $xᵏ⁻¹ = $x ** ($k - 1);        $e    = \M_E ** (-$x / $θ);        return ($xᵏ⁻¹ * $e) / $Γ⟮k⟯θᵏ;    }    /**     * Cumulative distribution function     *     *         1      /   x \     * cdf = ----- γ | k, -  |     *       Γ(k)     \   θ /     *     * @param float $x percentile      x > 0     *     * @return float     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $k = $this->k;        $θ = $this->θ;        $Γ⟮k⟯ = Special::Γ($k);        $γ   = Special::γ($k, $x / $θ);        return $γ / $Γ⟮k⟯;    }    /**     * Mean of the distribution     *     * μ = k θ     *     * @return float     */    public function mean(): float    {        return $this->k * $this->θ;    }    /**     * Approximation of the median of the distribution     * https://en.wikipedia.org/wiki/Gamma_distribution#Median_calculation     *     *       3k - 0.8     * υ ≈ μ --------     *       3k + 0.2     *     * @return float     */    public function median(): float    {        $μ   = $this->mean();        $３k = 3 * $this->k;        return $μ * (($３k - 0.8) / ($３k + 0.2));    }    /**     * Mode of the distribution     *     * mode = (k - 1)θ   k ≥ 1     *     * @return float     */    public function mode(): float    {        if ($this->k < 1) {            return \NAN;        }        return ($this->k - 1) * $this->θ;    }    /**     * Variance of the distribution     *     * var[X] = kθ²     *     * @return float     */    public function variance(): float    {        return $this->k * $this->θ ** 2;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Gamma_3117, Probability density function\n\n                     ₓ\n          1         ⁻-\n pdf = ------ xᵏ⁻¹ e θ\n       Γ(k)θᵏ\n\n @param float $x percentile      x > 0\n\n @return float\n, Probability density function,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $k = $this->k;        $θ = $this->θ;        $Γ⟮k⟯   = Special::Γ($k);        $θᵏ    = $θ ** $k;        $Γ⟮k⟯θᵏ = $Γ⟮k⟯ * $θᵏ;        $xᵏ⁻¹ = $x ** ($k - 1);        $e    = \M_E ** (-$x / $θ);        return ($xᵏ⁻¹ * $e) / $Γ⟮k⟯θᵏ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Gamma_3118," Cumulative distribution function\n\n         1      /   x \\\n cdf = ----- γ | k, -  |\n       Γ(k)     \\   θ /\n\n @param float $x percentile      x > 0\n\n @return float\n", Cumulative distribution function,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $k = $this->k;        $θ = $this->θ;        $Γ⟮k⟯ = Special::Γ($k);        $γ   = Special::γ($k, $x / $θ);        return $γ / $Γ⟮k⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Gamma_3119, Mean of the distribution\\n\\n μ = k θ\\n\\n @return float\\n, Mean of the distribution,    public function mean(): float    {        return $this->k * $this->θ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Gamma_3121, Mode of the distribution\n\n mode = (k - 1)θ   k ≥ 1\n\n @return float\n, Mode of the distribution,    public function mode(): float    {        if ($this->k < 1) {            return \NAN;        }        return ($this->k - 1) * $this->θ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Geometric_3229, Geometric distribution\n\n https://en.wikipedia.org/wiki/Geometric_distribution\n, Geometric distribution,"class Geometric extends Discrete{    /**     * Distribution parameter bounds limits     * p ∈ (0,1]     * @var array     */    public const PARAMETER_LIMITS = [        'p' => '(0,1]',    ];    /**     * Distribution parameter bounds limits     * k ∈ [1,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'k' => '[1,∞)',    ];    /** @var float success probability  0 < p ≤ 1 */    protected $p;    /**     * Constructor     *     * @param float $p success probability  0 < p ≤ 1     */    public function __construct(float $p)    {        parent::__construct($p);    }    /**     * Probability mass function     *     * The probability distribution of the number Y = X − 1 of failures     * before the first success, supported on the set { 0, 1, 2, 3, ... }     *     * k failures where k ∈ {0, 1, 2, 3, ...}     *     * pmf = (1 - p)ᵏp     *     * @param  int   $k number of trials     k ≥ 1     *     * @return float     */    public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ = \pow(1 - $p, $k);        return $⟮1 − p⟯ᵏ * $p;    }    /**     * Cumulative distribution function (lower cumulative)     *     * The probability distribution of the number Y = X − 1 of failures     * before the first success, supported on the set { 0, 1, 2, 3, ... }     *     * k failures where k ∈ {0, 1, 2, 3, ...}     *     * pmf = 1 - (1 - p)ᵏ⁺¹     *     * @param  int   $k number of trials     k ≥ 0     *     * @return float     */    public function cdf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ⁺¹ = \pow(1 - $p, $k + 1);        return 1 - $⟮1 − p⟯ᵏ⁺¹;    }    /**     * Mean of the distribution     *     *     1 - p     * μ = -----     *       p     *     * @return float     */    public function mean(): float    {        return (1 - $this->p) / $this->p;    }    /**     * Median of the distribution     *     *           _           _     *          |     -1      |     * median = | ----------- | - 1     *          | log₂(1 - p) |     *     * @return float     */    public function median(): float    {        $log₂⟮1 − p⟯ = \log(1 - $this->p, 2);        return \ceil(-1 / $log₂⟮1 − p⟯) - 1;    }    /**     * Mode of the distribution     *     * mode = 0     *     * @return int     */    public function mode(): int    {        return 0;    }    /**     * Variance of the distribution     *     *      1 - p     * σ² = -----     *        p²     *     * @return float     */    public function variance(): float    {        return (1 - $this->p) / $this->p ** 2;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Geometric_3234, Median of the distribution\\n\\n           _           _\\n          |     -1      |\\n median = | ----------- | - 1\\n          | log₂(1 - p) |\\n\\n @return float\\n, Median of the distribution,"    public function median(): float    {        $log₂⟮1 − p⟯ = \log(1 - $this->p, 2);        return \ceil(-1 / $log₂⟮1 − p⟯) - 1;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_HanesWoolf_3571, Calculate the regression parameters by least squares on linearized data\n x / y = x / V + K / V\n\n @throws Exception\\BadDataException\n @throws Exception\\MatrixException\n @throws Exception\\MathException\n, Calculate the regression parameters by least squares on linearized data,"    public function calculate(): void    {        // Linearize the relationship by dividing x by y        $y’ = Multi::divide($this->xs, $this->ys);        // Perform Least Squares Fit        $linear_parameters = $this->leastSquares($y’, $this->xs)->getColumn(0);        $V = 1 / $linear_parameters[1];        $K = $linear_parameters[0] * $V;        $this->parameters = [$V, $K];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Householder_2622, Householder matrix transformation\n\n u = x ± αe   where α = ‖x‖ and sgn(α) = sgn(x)\n\n              uuᵀ\n Q = I - 2               uᵀu\n\n https://en.wikipedia.org/wiki/Householder_transformation\n\n @param NumericMatrix $A source Matrix\n\n @return NumericMatrix\n\n @throws Exception\\MathException\n, Householder matrix transformation,"    public static function transform(NumericMatrix $A): NumericMatrix    {        $m = $A->getM();        $I = MatrixFactory::identity($m);        // x is the leftmost column of A        $x = $A->submatrix(0, 0, $m - 1, 0);        // α is the square root of the sum of squares of x with the correct sign        $sign = $x[0][0] >= 0 ? 1 : -1;        $α = $sign * $x->frobeniusNorm();        // e is the first column of I        $e = $I->submatrix(0, 0, $m - 1, 0);        // u = x ± αe        $u   = $e->scalarMultiply($α)->add($x);        $uᵀ  = $u->transpose();        $uᵀu = $uᵀ->multiply($u)->get(0, 0);        $uuᵀ = $u->multiply($uᵀ);        if ($uᵀu == 0) {            return $I;        }        // We scale $uuᵀ and subtract it from the identity matrix        return $I->subtract($uuᵀ->scalarMultiply(2 / $uᵀu));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_HypergeometricTest_5439, Test data made with: http://stattrek.com/m/online-calculator/hypergeometric.aspx\n @return array\n, Test data made with: http://stattrek.com/m/online-calculator/hypergeometric.aspx,"    public function dataProviderForPmf(): array    {        return [            [50, 5, 10, 4, 0.00396458305801507],            [50, 5, 10, 5, 0.000118937491740452],            [100, 80, 50, 40, 0.196871217706549],            [100, 80, 50, 35, 0.00889760379503624],            [48, 6, 15, 2, 0.350128003786331],            [48, 6, 15, 0, 0.0902552187538097],            [48, 6, 15, 6, 0.000407855201543217],            [100, 30, 20, 5, 0.19182559242904654583],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_HypergeometricTest_5441, Test data made with: http://stattrek.com/m/online-calculator/hypergeometric.aspx\\n @return array\\n, Test data made with: http://stattrek.com/m/online-calculator/hypergeometric.aspx,"    public function dataProviderForCdf(): array    {        return [            [50, 5, 10, 4, 0.000118937],            [100, 80, 50, 40, 0.401564391],            [100, 80, 50, 35, 0.988582509],            [48, 6, 15, 2, 0.269510717],            [48, 6, 15, 0, 0.909744781],            [100, 30, 20, 5, 0.599011207],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Hypergeometric_3241," Distribution mean\\n\\n       K\\n μ = n -\\n       N\\n\\n N is the population size,\\n K is the number of success states in the population,\\n n is the number of draws,\\n\\n N ∈ {0, 1, 2, ...}\\n K ∈ {0, 1, 2, ..., N}\\n n ∈ {0, 1, 2, ..., N}\\n k ∈ {max(0, n + K - N), ..., min(n, K)}\\n\\n @return float\\n", Distribution mean,    public function mean(): float    {        return $this->n * ($this->K / $this->N);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Hypergeometric_3243, Variance of the distribution\n\n        K (N - K) N - n\n σ² = n - ------- -----\n        N    N    N - 1\n\n @return float\n, Variance of the distribution,    public function variance(): float    {        $N = $this->N;        $K = $this->K;        $n = $this->n;        return $n * ($K / $N) * (($N - $K) / $N) * (($N - $n) / ($N - 1));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ImmutableSet_3396," Immutable Set (Set Theory)\\n A set that cannot be changed once created.\\n\\n Add, remove, and clear do not work on an immutable set. No Exceptions will\\n be thrown; it will just do nothing.\\n\\n Other than that, it acts just like a Set.\\n", Immutable Set (Set Theory),class ImmutableSet extends Set{    /**************************************************************************     * SINGLE MEMBER OPERATIONS - OVERIDDEN FROM SET     *  - Add (cannot add members)     *  - Add multi (cannot add members)     *  - Remove (cannot remove members)     *  - Remove multi (cannot remove members)     *  - Clear (cannot clear set)     **************************************************************************/    /**     * Cannot add members to an immutable set     *     * @param mixed $x     *     * @return Set (this set unchanged)     */    public function add($x): Set    {        return $this;    }    /**     * Cannot add members to an immutable set     *     * @param array $x     *     * @return Set (this set unchanged)     */    public function addMulti(array $x): Set    {        return $this;    }    /**     * Cannot remove members of an immutable set     *     * @param  mixed $x     *     * @return Set (this set unchanged)     */    public function remove($x): Set    {        return $this;    }    /**     * Cannot remove members of an immutable set     *     * @param  array $x     *     * @return Set (this set unchanged)     */    public function removeMulti(array $x): Set    {        return $this;    }    /**     * Cannot clear an immutable set     *     * @return Set (this set unchanged)     */    public function clear(): Set    {        return $this;    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_IntegerAxiomsTest_4812," Axiom: If a and b are coprime ⇒ lcm(a, b) = ab\n If a and b are coprime, then the least common multiple of a and b is equal to their product ab.\n @dataProvider dataProviderForCoprime\n @param        int $a\n @param        int $b\n"," Axiom: If a and b are coprime ⇒ lcm(a, b) = ab","    public function testCoprimeProductEqualsLcm(int $a, int $b)    {        // Given        $ab = $a * $b;        // When        $lcm⟮a、b⟯ = Algebra::lcm($a, $b);        // Then        $this->assertEquals($lcm⟮a、b⟯, $ab);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Integer_2973, Squarefree\n A squarefree integer is an integer which is divisble by no square number other than 1.\n It is equal to its radical (squarefree kernel).\n\n @see    https://en.wikipedia.org/wiki/Square-free_integer\n @see    https://oeis.org/A005117\n\n @param  int $n\n\n @return bool true if n is a squarefree integer; false otherwise\n, Squarefree,    public static function isSquarefree(int $n): bool    {        if ($n < 1) {            return false;        }        return $n === self::radical($n);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Integer_2974, Refactorable (or tau) number\\n A refactorable number is divisible by the count of its divisors σ₀(n)\\n\\n @see    https://en.wikipedia.org/wiki/Refactorable_number\\n @see    https://oeis.org/A033950\\n\\n @param  int $n\\n\\n @return bool true if n is divisible by σ₀(n); false otherwise\\n, Refactorable (or tau) number,    public static function isRefactorableNumber(int $n): bool    {        if ($n < 1) {            return false;        }        return $n % self::numberOfDivisors($n) === 0;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Integer_2977," If n is a perfect power, compute an m and k such that mᵏ = n.\n A perfect power is a positive integer that can be expressed as an integer power of another positive integer.\n If n is a perfect power, then exists m > 1 and k > 1 such that mᵏ = n.\n https://en.wikipedia.org/wiki/Perfect_power\n\n Algorithm:\n  For each divisor of n (as m), consider all possible values of k from 2 to log₂n.\n   - If mᵏ = n, return m and k\n   - If exhaust all possible mᵏ combinations, return empty array.\n\n An integer n could have multiple perfect power scenarios.\n Only one is returned.\n\n @param  int $n\n\n @return array [m, k]\n"," If n is a perfect power, compute an m and k such that mᵏ = n.","    public static function perfectPower(int $n): array    {        $√n = \sqrt($n);        $ms = \array_filter(            Algebra::factors($n),            function ($m) use ($√n) {                return ($m > 1 && $m <= $√n);            }        );        $max_k = \ceil(\log($n, 2));        foreach ($ms as $m) {            foreach (\range(2, $max_k) as $k) {                $mᵏ = $m ** $k;                if ($mᵏ == $n) {                    return [$m, $k];                }            }        }        return [];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Integer_2983, Even number\n\n @param  int $x\n\n @return bool true if x is even; false otherwise\n, Even number,    public static function isEven(int $x): bool    {        return (\abs($x) % 2) === 0;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Iris_3310, Sepal length observations\\n\\n @return number[]\\n, Sepal length observations,"    public function getSepalLength(): array    {        return \array_column(self::DATA, 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Iris_3313, Petal width observations\n\n @return number[]\n, Petal width observations,"    public function getPetalWidth(): array    {        return \array_column(self::DATA, 3);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Iter_3642, Zip - Make an iterator that aggregates items from multiple iterators\n Similar to Python's zip function\n @internal\n\n @param iterable ...$iterables\n\n @return \\MultipleIterator\n, Zip - Make an iterator that aggregates items from multiple iterators,    public static function zip(iterable ...$iterables): \MultipleIterator    {        $zippedIterator = new \MultipleIterator();        foreach ($iterables as $iterable) {            $zippedIterator->attachIterator(self::makeIterator($iterable));        }        return $zippedIterator;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_KernelDensityEstimation_3535, Evaluate the kernel density estimation at $x\\n\\n                       ____\\n            1          \\\\         / (x - xᵢ) \\\\\\n KDE(x) = -----             n                        ‾‾‾‾\\n @param float $x the value to evaluate\\n\\n @return float the kernel density estimate at $x\\n, Evaluate the kernel density estimation at $x,"    public function evaluate(float $x): float    {        $h = $this->h;        $n = $this->n;        $scale = \array_map(            function ($xᵢ) use ($x, $h) {                return ($x - $xᵢ) / $h;            },            $this->data        );        $K       = \array_map($this->kernel, $scale);        $density = \array_sum($K) / ($n * $h);        return $density;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LUTest_3980," Test data from various sources:\\n   SciPy scipy.linalg.lu(A)\\n   Online calculator: https://www.easycalculation.com/matrix/lu-decomposition-matrix.php\\n   Various other sources.\\n @return array (A, L, U, P)\\n", Test data from various sources:,"    public function dataProviderForLuDecomposition(): array    {        return [            [                [                    [4, 3],                    [6, 3],                ],                [                    [1, 0],                    [0.667, 1],                ],                [                    [6, 3],                    [0, 1],                ],                [                    [0, 1],                    [1, 0],                ],            ],            // Matrix Computations 3.4 Pivoting example - pivoting prevents large entries in the triangular factors L and U            [                [                    [.0001, 1],                    [1, 1],                ],                [                    [1, 0],                    [0.0001, 1],                ],                [                    [1, 1],                    [0, 0.999],                ],                [                    [0, 1],                    [1, 0],                ],            ],            // Zero at first pivot element would cause a divide by zero error without pivoting (http://buzzard.ups.edu/courses/2014spring/420projects/math420-UPS-spring-2014-reid-LU-pivoting.pdf)            [                [                    [0, 1],                    [1, 2],                ],                [                    [1, 0],                    [0, 1],                ],                [                    [1, 2],                    [0, 1],                ],                [                    [0, 1],                    [1, 0],                ],            ],            // Small pivots            [                [                    [10e-20, 1],                    [1, 2],                ],                [                    [1, 0],                    [1e-19, 1],                ],                [                    [1, 2],                    [0, 1],                ],                [                    [0, 1],                    [1, 0],                ],            ],            [                [                    [1, 3, 5],                    [2, 4, 7],                    [1, 1, 0],                ],                [                    [1, 0, 0],                    [.5, 1, 0],                    [.5, -1, 1],                ],                [                    [2, 4, 7],                    [0, 1, 1.5],                    [0, 0, -2],                ],                [                    [0, 1, 0],                    [1, 0, 0],                    [0, 0, 1],                ]            ],            [                [                    [1, -2, 3],                    [2, -5, 12],                    [0, 2, -10],                ],                [                    [1, 0, 0],                    [0, 1, 0],                    [0.5, 0.25, 1],                ],                [                    [2, -5, 12],                    [0, 2, -10],                    [0, 0, -0.5],                ],                [                    [0, 1, 0],                    [0, 0, 1],                    [1, 0, 0],                ],            ],            [                [                    [4, 2, 3],                    [-3, 1, 4],                    [2, 4, 5],                ],                [                    [1, 0, 0],                    [0.5, 1, 0],                    [-0.75, 0.833, 1],                ],                [                    [4, 2, 3],                    [0, 3, 3.5],                    [0, 0, 3.333]                ],                [                    [1, 0, 0],                    [0, 0, 1],                    [0, 1, 0],                ],            ],            // Partial pivoting example - (http://buzzard.ups.edu/courses/2014spring/420projects/math420-UPS-spring-2014-reid-LU-pivoting.pdf)            [                [                    [1, 2, 4],                    [2, 1, 3],                    [3, 2, 4],                ],                [                    [1, 0, 0],                    [1 / 3, 1, 0],                    [2 / 3, -1 / 4, 1],                ],                [                    [3, 2, 4],                    [0, 4 / 3, 8 / 3],                    [0, 0, 1]                ],                [                    [0, 0, 1],                    [1, 0, 0],                    [0, 1, 0],                ],            ],            [                [                    [2, 3, 4],                    [4, 7, 5],                    [4, 9, 5],                ],                [                    [1, 0, 0],                    [1, 1, 0],                    [0.5, -0.25, 1],                ],                [                    [4, 7, 5],                    [0, 2, 0],                    [0, 0, 1.5]                ],                [                    [0, 1, 0],                    [0, 0, 1],                    [1, 0, 0],                ],            ],            [                [                    [5, 4, 8, 9],                    [9, 9, 9, 9],                    [4, 5, 5, 7],                    [1, 9, 8, 7],                ],                [                    [1, 0, 0, 0],                    [.556, 1, 0, 0],                    [.111, -8, 1, 0],                    [.444, -1, .129, 1],                ],                [                    [9, 9, 9, 9],                    [0, -1, 3, 4],                    [0, 0, 31, 38],                    [0, 0, 0, 2.097],                ],                [                    [0, 1, 0, 0],                    [1, 0, 0, 0],                    [0, 0, 0, 1],                    [0, 0, 1, 0],                ],            ],            [                [                    [2, 1, 1, 0],                    [4, 3, 3, 1],                    [8, 7, 9, 5],                    [6, 7, 9, 8],                ],                [                    [1, 0, 0, 0],                    [0.25, 1, 0, 0],                    [0.5, 0.667, 1, 0],                    [0.75, -2.333, 1, 1],                ],                [                    [8, 7, 9, 5],                    [0, -0.75, -1.25, -1.25],                    [0, 0, -0.667, -0.667],                    [0, 0, 0, 2],                ],                [                    [0, 0, 1, 0],                    [1, 0, 0, 0],                    [0, 1, 0, 0],                    [0, 0, 0, 1],                ],            ],            [                [                    [11, 9, 24, 2],                    [1, 5, 2, 6],                    [3, 17, 18, 1],                    [2, 5, 7, 1],                ],                [                    [1, 0, 0, 0],                    [.27273, 1, 0, 0],                    [.09091, .28750, 1, 0],                    [.18182, .23125, .00360, 1],                ],                [                    [11, 9, 24, 2],                    [0, 14.54545, 11.45455, 0.45455],                    [0, 0, -3.47500, 5.68750],                    [0, 0, 0, 0.51079],                ],                [                    [1, 0, 0, 0],                    [0, 0, 1, 0],                    [0, 1, 0, 0],                    [0, 0, 0, 1],                ],            ],            [                [                    [5, 3, 8],                    [6, 4, 5],                    [1, 8, 9],                ],                [                    [1, 0, 0],                    [0.167, 1, 0],                    [.833, -0.045, 1],                ],                [                    [6, 4, 5],                    [0, 7.333, 8.167],                    [0, 0, 4.205]                ],                [                    [0, 1, 0],                    [0, 0, 1],                    [1, 0, 0],                ],            ],            [                [                    [3, 2, 6, 7],                    [4, 3, -6, 2],                    [12, 14, 14, -6],                    [4, 6, 4, -42],                ],                [                    [1, 0, 0, 0],                    [0.25, 1, 0, 0],                    [0.333, 1.111, 1, 0],                    [0.333, -0.889, -0.116, 1],                ],                [                    [12, 14, 14, -6],                    [0, -1.5, 2.5, 8.5],                    [0, 0, -13.444, -5.444],                    [0, 0, 0, -33.074],                ],                [                    [0, 0, 1, 0],                    [1, 0, 0, 0],                    [0, 1, 0, 0],                    [0, 0, 0, 1],                ],            ],            [                [                    [5, 3, 4, 1],                    [5, 6, 4, 3],                    [7, 6, 5, 3],                    [2, 7, 4, 7],                ],                [                    [1, 0, 0, 0],                    [0.286, 1, 0, 0],                    [0.714, -0.243, 1, 0],                    [0.714, 0.324, -0.385, 1],                ],                [                    [7, 6, 5, 3],                    [0, 5.286, 2.571, 6.143],                    [0, 0, 1.054, 0.351],                    [0, 0, 0, -1],                ],                [                    [0, 0, 1, 0],                    [0, 0, 0, 1],                    [1, 0, 0, 0],                    [0, 1, 0, 0],                ],            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LU_2869," LU Decomposition (Doolittle decomposition) with partial pivoting via permutation matrix\\n\\n A matrix has an LU-factorization if it can be expressed as the product of a\\n lower-triangular matrix L and an upper-triangular matrix U. If A is a nonsingular\\n matrix, then we can find a permutation matrix P so that PA will have an LU decomposition:\\n   PA = LU\\n\\n https://en.wikipedia.org/wiki/LU_decomposition\\n https://en.wikipedia.org/wiki/LU_decomposition#Doolittle_algorithm\\n\\n L: Lower triangular matrix--all entries above the main diagonal are zero.\\n    The main diagonal will be all ones.\\n U: Upper triangular matrix--all entries below the main diagonal are zero.\\n P: Permutation matrix--Identity matrix with possible rows interchanged.\\n\\n Example:\\n      [1 3 5]\\n  A = [2 4 7]\\n      [1 1 0]\\n\\n Create permutation matrix P:\\n      [0 1 0]\\n  P = [1 0 0]\\n      [0 0 1]\\n\\n Pivot A to be PA:\\n       [0 1 0][1 3 5]   [2 4 7]\\n  PA = [1 0 0][2 4 7] = [1 3 5]\\n       [0 0 1][1 1 0]   [1 1 0]\\n\\n Calculate L and U\\n\\n     [1    0 0]      [2 4   7]\\n L = [0.5  1 0]  U = [0 1 1.5]\\n     [0.5 -1 1]      [0 0  -2]\\n\\n @property-read NumericMatrix $L Lower triangular matrix in LUP decomposition\\n @property-read NumericMatrix $U Upper triangular matrix in LUP decomposition\\n @property-read NumericMatrix $P Permutation matrix in LUP decomposition\\n", LU Decomposition (Doolittle decomposition) with partial pivoting via permutation matrix,"class LU extends Decomposition{    /** @var NumericMatrix Lower triangular matrix in LUP decomposition */    private $L;    /** @var NumericMatrix Upper triangular matrix in LUP decomposition */    private $U;    /** @var NumericMatrix Permutation matrix in LUP decomposition */    private $P;    /**     * LU constructor     *     * @param NumericMatrix $L Lower triangular matrix     * @param NumericMatrix $U Upper triangular matrix     * @param NumericMatrix $P Permutation matrix     */    private function __construct(NumericMatrix $L, NumericMatrix $U, NumericMatrix $P)    {        $this->L = $L;        $this->U = $U;        $this->P = $P;    }    /**     * Decompose a matrix into an LU Decomposition (using Doolittle decomposition) with pivoting via permutation matrix     * Factory method to create LU objects.     *     * @param NumericMatrix $A     *     * @return LU     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\VectorException     */    public static function decompose(NumericMatrix $A): LU    {        if (!$A->isSquare()) {            throw new Exception\MatrixException('LU decomposition only works on square matrices');        }        $n = $A->getN();        // Initialize L as diagonal ones matrix, and U as zero matrix        $L = MatrixFactory::diagonal(\array_fill(0, $n, 1))->getMatrix();        $U = MatrixFactory::zero($n, $n)->getMatrix();        // Create permutation matrix P and pivoted PA        $P  = self::pivotize($A);        $PA = $P->multiply($A);        // Fill out L and U        for ($i = 0; $i < $n; $i++) {            // Calculate Uⱼᵢ            for ($j = 0; $j <= $i; $j++) {                $sum = 0;                for ($k = 0; $k < $j; $k++) {                    $sum += $U[$k][$i] * $L[$j][$k];                }                $U[$j][$i] = $PA[$j][$i] - $sum;            }            // Calculate Lⱼᵢ            for ($j = $i; $j < $n; $j++) {                $sum = 0;                for ($k = 0; $k < $i; $k++) {                    $sum += $U[$k][$i] * $L[$j][$k];                }                $L[$j][$i] = ($U[$i][$i] == 0) ? \NAN : ($PA[$j][$i] - $sum) / $U[$i][$i];            }        }        // Create LU decomposition        return new LU(MatrixFactory::create($L), MatrixFactory::create($U), $P);    }    /**     * Pivotize creates the permutation matrix P for the LU decomposition using partial pivoting.     * The permutation matrix is an identity matrix with rows possibly interchanged.     *     * The product PA results in a new matrix whose rows consist of the rows of A     * but no rearranged in the order specified by the permutation matrix P.     *     * Example:     *     *     [α₁₁ α₁₂ α₁₃]     * A = [α₂₁ α₂₂ α₂₃]     *     [α₃₁ α₃₂ α₃₃]     *     *     [0 1 0]     * P = [1 0 0]     *     [0 0 1]     *     *      [α₂₁ α₂₂ α₂₃] \ rows     * PA = [α₁₁ α₁₂ α₁₃] / interchanged     *      [α₃₁ α₃₂ α₃₃]     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     */    protected static function pivotize(NumericMatrix $A): NumericMatrix    {        $n = $A->getN();        $P = MatrixFactory::identity($n);        // Set initial column max to diagonal element Aᵢᵢ        for ($i = 0; $i < $n; $i++) {            $max = $A[$i][$i];            $row = $i;            // Check for column element below Aᵢᵢ that is bigger            for ($j = $i; $j < $n; $j++) {                if ($A[$j][$i] > $max) {                    $max = $A[$j][$i];                    $row = $j;                }            }            // Swap rows if a larger column element below Aᵢᵢ was found            if ($i != $row) {                $P = $P->rowInterchange($i, $row);            }        }        return $P;    }    /**     * Solve linear system of equations     * Ax = b     *  where:     *   A: Matrix     *   x: unknown to solve for     *   b: solution to linear system of equations (input to function)     *     * Use LU Decomposition and solve Ax = b.     *     * LU Decomposition:     *  - Equation to solve: Ax = b     *  - LU Decomposition produces: PA = LU     *  - Substitute: LUx = Pb, or Pb = LUx     *  - Can rewrite as Pb = L(Ux)     *  - Can say y = Ux     *  - Then can rewrite as Pb = Ly     *  - Solve for y (we know Pb and L)     *  - Solve for x in y = Ux once we know y     *     * Solving triangular systems Ly = Pb and Ux = y     *  - Solve for Ly = Pb using forward substitution     *     *         1   /    ᵢ₋₁      \     *   yᵢ = --- | bᵢ - ∑ Lᵢⱼyⱼ |     *        Lᵢᵢ  \    ʲ⁼¹      /     *     *  - Solve for Ux = y using back substitution     *     *         1   /     m       \     *   xᵢ = --- | yᵢ - ∑ Uᵢⱼxⱼ |     *        Uᵢᵢ  \   ʲ⁼ⁱ⁺¹     /     *     * @param Vector|array $b solution to Ax = b     *     * @return Vector x     *     * @throws Exception\IncorrectTypeException if b is not a Vector or array     * @throws Exception\MatrixException     * @throws Exception\VectorException     * @throws Exception\OutOfBoundsException     * @throws Exception\BadParameterException     */    public function solve($b): Vector    {        // Input must be a Vector or array.        if (!($b instanceof Vector || \is_array($b))) {            throw new Exception\IncorrectTypeException('b in Ax = b must be a Vector or array');        }        if (\is_array($b)) {            $b = new Vector($b);        }        $L  = $this->L;        $U  = $this->U;        $P  = $this->P;        $m  = $this->L->getM();        // Pivot solution vector b with permutation matrix: Pb        $Pb = $P->multiply($b);        /* Solve for Ly = Pb using forward substitution         *         1   /    ᵢ₋₁      \         *   yᵢ = --- | bᵢ - ∑ Lᵢⱼyⱼ |         *        Lᵢᵢ  \    ʲ⁼¹      /         */        $y    = [];        $y[0] = $Pb[0][0] / $L[0][0];        for ($i = 1; $i < $m; $i++) {            $sum = 0;            for ($j = 0; $j <= $i - 1; $j++) {                $sum += $L[$i][$j] * $y[$j];            }            $y[$i] = ($Pb[$i][0] - $sum) / $L[$i][$i];        }        /* Solve for Ux = y using back substitution         *         1   /     m       \         *   xᵢ = --- | yᵢ - ∑ Uᵢⱼxⱼ |         *        Uᵢᵢ  \   ʲ⁼ⁱ⁺¹     /         */        $x         = [];        $x[$m - 1] = $y[$m - 1] / $U[$m - 1][$m - 1];        for ($i = $m - 2; $i >= 0; $i--) {            $sum = 0;            for ($j = $i + 1; $j < $m; $j++) {                $sum += $U[$i][$j] * $x[$j];            }            if ($U[$i][$i] == 0) {                throw new Exception\DivisionByZeroException(""Uᵢᵢ (U[$i][$i]) is 0 during solve for Ux = y using back substitution in LU solve for Ax = b"");            }            $x[$i] = ($y[$i] - $sum) / $U[$i][$i];        }        // Return unknown xs as Vector        return new Vector(\array_reverse($x));    }    /**     * Get L, U, or P matrix     *     * @param string $name     *     * @return NumericMatrix     *     * @throws Exception\MatrixException     */    public function __get(string $name): NumericMatrix    {        switch ($name) {            case 'L':            case 'U':            case 'P':                return $this->$name;            default:                throw new Exception\MatrixException(""LU class does not have a gettable property: $name"");        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LU_2870, LU constructor\n\n @param NumericMatrix $L Lower triangular matrix\n @param NumericMatrix $U Upper triangular matrix\n @param NumericMatrix $P Permutation matrix\n, LU constructor,"    private function __construct(NumericMatrix $L, NumericMatrix $U, NumericMatrix $P)    {        $this->L = $L;        $this->U = $U;        $this->P = $P;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LU_2871, Decompose a matrix into an LU Decomposition (using Doolittle decomposition) with pivoting via permutation matrix\n Factory method to create LU objects.\n\n @param NumericMatrix $A\n\n @return LU\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MathException\n @throws Exception\\MatrixException\n @throws Exception\\OutOfBoundsException\n @throws Exception\\VectorException\n, Decompose a matrix into an LU Decomposition (using Doolittle decomposition) with pivoting via permutation matrix,"    public static function decompose(NumericMatrix $A): LU    {        if (!$A->isSquare()) {            throw new Exception\MatrixException('LU decomposition only works on square matrices');        }        $n = $A->getN();        // Initialize L as diagonal ones matrix, and U as zero matrix        $L = MatrixFactory::diagonal(\array_fill(0, $n, 1))->getMatrix();        $U = MatrixFactory::zero($n, $n)->getMatrix();        // Create permutation matrix P and pivoted PA        $P  = self::pivotize($A);        $PA = $P->multiply($A);        // Fill out L and U        for ($i = 0; $i < $n; $i++) {            // Calculate Uⱼᵢ            for ($j = 0; $j <= $i; $j++) {                $sum = 0;                for ($k = 0; $k < $j; $k++) {                    $sum += $U[$k][$i] * $L[$j][$k];                }                $U[$j][$i] = $PA[$j][$i] - $sum;            }            // Calculate Lⱼᵢ            for ($j = $i; $j < $n; $j++) {                $sum = 0;                for ($k = 0; $k < $i; $k++) {                    $sum += $U[$k][$i] * $L[$j][$k];                }                $L[$j][$i] = ($U[$i][$i] == 0) ? \NAN : ($PA[$j][$i] - $sum) / $U[$i][$i];            }        }        // Create LU decomposition        return new LU(MatrixFactory::create($L), MatrixFactory::create($U), $P);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LU_2873," Solve linear system of equations\\n Ax = b\\n  where:\\n   A: Matrix\\n   x: unknown to solve for\\n   b: solution to linear system of equations (input to function)\\n\\n Use LU Decomposition and solve Ax = b.\\n\\n LU Decomposition:\\n  - Equation to solve: Ax = b\\n  - LU Decomposition produces: PA = LU\\n  - Substitute: LUx = Pb, or Pb = LUx\\n  - Can rewrite as Pb = L(Ux)\\n  - Can say y = Ux\\n  - Then can rewrite as Pb = Ly\\n  - Solve for y (we know Pb and L)\\n  - Solve for x in y = Ux once we know y\\n\\n Solving triangular systems Ly = Pb and Ux = y\\n  - Solve for Ly = Pb using forward substitution\\n\\n         1   /    ᵢ₋₁      \\\\\\n   yᵢ = --- | bᵢ - ∑ Lᵢⱼyⱼ |\\n        Lᵢᵢ  \\\\    ʲ⁼¹      /\\n\\n  - Solve for Ux = y using back substitution\\n\\n         1   /     m       \\\\\\n   xᵢ = --- | yᵢ - ∑ Uᵢⱼxⱼ |\\n        Uᵢᵢ  \\\\   ʲ⁼ⁱ⁺¹     /\\n\\n @param Vector|array $b solution to Ax = b\\n\\n @return Vector x\\n\\n @throws Exception\\\\IncorrectTypeException if b is not a Vector or array\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\VectorException\\n @throws Exception\\\\OutOfBoundsException\\n @throws Exception\\\\BadParameterException\\n", Solve linear system of equations,"    public function solve($b): Vector    {        // Input must be a Vector or array.        if (!($b instanceof Vector || \is_array($b))) {            throw new Exception\IncorrectTypeException('b in Ax = b must be a Vector or array');        }        if (\is_array($b)) {            $b = new Vector($b);        }        $L  = $this->L;        $U  = $this->U;        $P  = $this->P;        $m  = $this->L->getM();        // Pivot solution vector b with permutation matrix: Pb        $Pb = $P->multiply($b);        /* Solve for Ly = Pb using forward substitution         *         1   /    ᵢ₋₁      \         *   yᵢ = --- | bᵢ - ∑ Lᵢⱼyⱼ |         *        Lᵢᵢ  \    ʲ⁼¹      /         */        $y    = [];        $y[0] = $Pb[0][0] / $L[0][0];        for ($i = 1; $i < $m; $i++) {            $sum = 0;            for ($j = 0; $j <= $i - 1; $j++) {                $sum += $L[$i][$j] * $y[$j];            }            $y[$i] = ($Pb[$i][0] - $sum) / $L[$i][$i];        }        /* Solve for Ux = y using back substitution         *         1   /     m       \         *   xᵢ = --- | yᵢ - ∑ Uᵢⱼxⱼ |         *        Uᵢᵢ  \   ʲ⁼ⁱ⁺¹     /         */        $x         = [];        $x[$m - 1] = $y[$m - 1] / $U[$m - 1][$m - 1];        for ($i = $m - 2; $i >= 0; $i--) {            $sum = 0;            for ($j = $i + 1; $j < $m; $j++) {                $sum += $U[$i][$j] * $x[$j];            }            if ($U[$i][$i] == 0) {                throw new Exception\DivisionByZeroException(""Uᵢᵢ (U[$i][$i]) is 0 during solve for Ux = y using back substitution in LU solve for Ax = b"");            }            $x[$i] = ($y[$i] - $sum) / $U[$i][$i];        }        // Return unknown xs as Vector        return new Vector(\array_reverse($x));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LU_2874," Get L, U, or P matrix\n\n @param string $name\n\n @return NumericMatrix\n\n @throws Exception\\MatrixException\n"," Get L, U, or P matrix","    public function __get(string $name): NumericMatrix    {        switch ($name) {            case 'L':            case 'U':            case 'P':                return $this->$name;            default:                throw new Exception\MatrixException(""LU class does not have a gettable property: $name"");        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Laplace_3124," Laplace distribution - probability density function\n\n https://en.wikipedia.org/wiki/Laplace_distribution\n\n            1      /  |x - μ| \\\n f(x|μ,b) = -- exp| - -------  |\n            2b     \\     b    /\n\n @param  float $x\n\n @return float\n", Laplace distribution - probability density function,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ = $this->μ;        $b = $this->b;        return (1 / (2 * $b)) * \exp(-(\abs($x - $μ) / $b));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Laplace_3128, Median of the distribution\\n\\n median = μ\\n\\n @return float μ\\n, Median of the distribution,    public function median(): float    {        return $this->μ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3607, The Design Matrix contains all the independent variables needed for the least squares regression\n\n https://en.wikipedia.org/wiki/Design_matrix\n\n @param mixed $xs\n\n @return NumericMatrix (Vandermonde)\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MathException\n @throws Exception\\MatrixException\n, The Design Matrix contains all the independent variables needed for the least squares regression,"    public function createDesignMatrix($xs): NumericMatrix    {        if (\is_int($xs) || \is_float($xs)) {            $xs = [$xs];        }        $X = MatrixFactory::vandermonde($xs, $this->p + 1);        if ($this->fit_constant == 0) {            $X = $X->columnExclude(0);        }        return $X;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3608," Project matrix (influence matrix, hat matrix H)\n Maps the vector of response values (dependent variable values) to the vector of fitted values (or predicted values).\n The diagonal elements of the projection matrix are the leverages.\n https://en.wikipedia.org/wiki/Projection_matrix\n\n H = X⟮XᵀX⟯⁻¹Xᵀ\n   where X is the design matrix\n\n @return NumericMatrix\n"," Project matrix (influence matrix, hat matrix H)",    public function getProjectionMatrix(): NumericMatrix    {        return $this->reg_P;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3610," SSreg - The Sum Squares of the regression (Explained sum of squares)\\n\\n The sum of the squares of the deviations of the predicted values from\\n the mean value of a response variable, in a standard regression model.\\n https://en.wikipedia.org/wiki/Explained_sum_of_squares\\n\\n SSreg = ∑(ŷᵢ - ȳ)²\\n When a constant is fit to the regression, the average of y = average of ŷ.\\n\\n In the case where the constant is not fit, we use the sum of squares of the predicted value\\n SSreg = ∑ŷᵢ²\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException\\n", SSreg - The Sum Squares of the regression (Explained sum of squares),    public function sumOfSquaresRegression(): float    {        if ($this->fit_constant == 1) {            return RandomVariable::sumOfSquaresDeviations($this->yHat());        }        return \array_sum(Single::square($this->reg_Yhat));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3611, SSres - The Sum Squares of the residuals (RSS - Residual sum of squares)\n\n The sum of the squares of residuals (deviations predicted from actual\n empirical values of data). It is a measure of the discrepancy between\n the data and an estimation model.\n https://en.wikipedia.org/wiki/Residual_sum_of_squares\n\n SSres = ∑(yᵢ - f(xᵢ))²\n       = ∑(yᵢ - ŷᵢ)²\n\n  where yᵢ is an observed value\n        ŷᵢ is a value predicted by the regression model\n\n @return float\n, SSres - The Sum Squares of the residuals (RSS - Residual sum of squares),"    public function sumOfSquaresResidual(): float    {        $Ŷ = $this->reg_Yhat;        return \array_sum(\array_map(            function ($yᵢ, $ŷᵢ) {                return ($yᵢ - $ŷᵢ) ** 2;            },            $this->reg_ys,            $Ŷ        ));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3612," SStot - The total Sum Squares\\n\\n the sum, over all observations, of the squared differences of\\n each observation from the overall mean.\\n https://en.wikipedia.org/wiki/Total_sum_of_squares\\n\\n For Simple Linear Regression\\n SStot = ∑(yᵢ - ȳ)²\\n\\n For Regression through a point\\n SStot = ∑yᵢ²\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException\\n", SStot - The total Sum Squares,    public function sumOfSquaresTotal(): float    {        return $this->sumOfSquaresResidual() + $this->sumOfSquaresRegression();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3613, Mean square regression\\n MSR = SSᵣ / p\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException\\n, Mean square regression,    public function meanSquareRegression(): float    {        $p   = $this->p;        $SSᵣ = $this->sumOfSquaresRegression();        $MSR = $SSᵣ / $p;        return $MSR;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3614, Mean of squares for error\\n MSE = SSₑ / ν\\n\\n @return float\\n, Mean of squares for error,    public function meanSquareResidual(): float    {        $ν   = $this->ν;        $SSₑ = $this->sumOfSquaresResidual();        $MSE = $SSₑ / $ν;        return $MSE;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3615, Mean of squares total\n MSTO = SSOT / (n - 1)\n\n @return float\n\n @throws Exception\\BadDataException\n, Mean of squares total,    public function meanSquareTotal(): float    {        $MSTO = $this->sumOfSquaresTotal() / ($this->n - $this->fit_constant);        return $MSTO;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3616, Error Standard Deviation\n\n Also called the standard error of the residuals\n\n @return float\n, Error Standard Deviation,    public function errorSd(): float    {        return \sqrt($this->meanSquareResidual());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3617, The degrees of freedom of the regression\n\n @return float\n, The degrees of freedom of the regression,    public function degreesOfFreedom(): float    {        return $this->ν;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3619, Regression variance\\n\\n @param  float $x\\n\\n @return float\\n\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\IncorrectTypeException\\n, Regression variance,    public function regressionVariance(float $x): float    {        $X      = $this->createDesignMatrix($x);        $⟮XᵀX⟯⁻¹ = $this->⟮XᵀX⟯⁻¹;        $M      = $X->multiply($⟮XᵀX⟯⁻¹)->multiply($X->transpose());        return $M[0][0];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3620, Get the regression residuals\\n eᵢ = yᵢ - ŷᵢ\\n or in matrix form\\n e = (I - H)y\\n\\n @return array\\n, Get the regression residuals,"    public function residuals(): array    {        return Multi::subtract($this->reg_ys, $this->reg_Yhat);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3627," The t values associated with each of the regression parameters (coefficients)\\n\\n       β\\n t = -----\\n     se(β)\\n\\n  where:\\n    β     = regression parameter (coefficient)\\n    se(β) = standard error of the regression parameter (coefficient)\\n\\n @return  array [m => t, b => t]\\n", The t values associated with each of the regression parameters (coefficients),"    public function tValues(): array    {        $se = $this->standardErrors();        $m  = $this->parameters[1];        $b  = $this->parameters[0];        return [            'm' => $m / $se['m'],            'b' => $b / $se['b'],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3628," The probabilty associated with each parameter's t value\\n\\n t probability = Student's T CDF(t,ν)\\n\\n  where:\\n    t = t value\\n    ν = n - p - alpha  degrees of freedom\\n\\n  alpha = 1 if the regression includes a constant term\\n\\n @return array [m => p, b => p]\\n", The probabilty associated with each parameter's t value,"    public function tProbability(): array    {        $ν  = $this->ν;        $t  = $this->tValues();        $studentT = new StudentT($ν);        return [            'm' => $studentT->cdf($t['m']),            'b' => $studentT->cdf($t['b']),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3629," The F statistic of the regression (F test)\n\n      MSm      SSᵣ/p\n F₀ = --- = -----------\n      MSₑ   SSₑ/(n - p - α)\n\n  where:\n    MSm = mean square model (regression mean square) = SSᵣ / df(SSᵣ) = SSᵣ/p\n    MSₑ = mean square error (estimate of variance σ² of the random error)\n        = SSₑ/(n - p - α)\n    p   = the order of the fitted polynomial\n    α   = 1 if the model includes a constant term, 0 otherwise. (p+α = total number of model parameters)\n    SSᵣ = sum of squares of the regression\n    SSₑ = sum of squares of residuals\n\n @return float\n", The F statistic of the regression (F test),    public function fStatistic(): float    {        $F = $this->meanSquareRegression() / $this->meanSquareResidual();        return $F;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3630," The probabilty associated with the regression F Statistic\n\n F probability = F distribution CDF(F,d₁,d₂)\n\n  where:\n    F  = F statistic\n    d₁ = degrees of freedom 1\n    d₂ = degrees of freedom 2\n\n    ν  = degrees of freedom\n\n @return float\n", The probabilty associated with the regression F Statistic,"    public function fProbability(): float    {        $F = $this->fStatistic();        $n = $this->n;        // Degrees of freedom        // Need to make sure the 1 in $d₁ should not be $this->fit_parameters;        $ν  = $this->ν;        $d₁ = $n - $ν - 1;        $d₂ = $ν;        $fDist = new F($d₁, $d₂);        return ($fDist->cdf($F));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3631," The confidence interval of the regression for Simple Linear Regression\\n                      ______________\\n                     /1   (x - x̄)²\\n CI(x,p) = t                    √  n     SSx\\n\\n Where:\\n   t is the critical t for the p value\\n   sy is the estimated standard deviation of y\\n   n is the number of data points\\n   x̄ is the average of the x values\\n   SSx = ∑(x - x̄)²\\n\\n If $p = .05, then we can say we are 95% confidence the actual regression line\\n will be within an interval of evaluate($x) ± CI($x, .05).\\n\\n @param float $x\\n @param float $p:  0 < p < 1 The P value to use\\n\\n @return float\\n\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\IncorrectTypeException\\n", The confidence interval of the regression for Simple Linear Regression,"    public function ci(float $x, float $p): float    {        $V  = $this->regressionVariance($x);        $σ² = $this->meanSquareResidual();        // The t-value        $studentT = new StudentT($this->ν);        $t = $studentT->inverse2Tails($p);        return $t * \sqrt($σ² * $V);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LimitsTest_5214," Limits should look like:\n  (a,b)\n  [a,b)\n  (a,b]\n  [a,b]\n", Limits should look like:,"    private function limitTest($limits)    {        foreach ($limits as $parameter => $limit) {            $this->assertRegExp('/^ ([[(]) (.+) , (.+?) ([])]) $/x', $limit);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LinearModel_3634, Get regression equation (y = mx + b)\\n\\n @param array $params\\n\\n @return string\\n, Get regression equation (y = mx + b),"    public function getModelEquation(array $params): string    {        return \sprintf('y = %fx + %f', $params[self::$M], $params[self::$B]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LinearThroughPoint_3580, Calculates the regression parameters.\n\n @throws \\MathPHP\\Exception\\BadDataException\n @throws \\MathPHP\\Exception\\IncorrectTypeException\n @throws \\MathPHP\\Exception\\MatrixException\n @throws \\MathPHP\\Exception\\MathException\n, Calculates the regression parameters.,"    public function calculate(): void    {        $v = $this->v;        $w = $this->w;        $x’ = Single::subtract($this->xs, $v);        $y’ = Single::subtract($this->ys, $w);        $parameters = $this->leastSquares($y’, $x’, 1, 0)->getColumn(0);        $m = $parameters[0];        $b = $this->w - $m * $this->v;        $this->parameters = [$b, $m];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LinearThroughPoint_3581, Evaluate the regression equation at x\\n Uses the instance model's evaluateModel method.\\n\\n @param  float $x\\n\\n @return float\\n, Evaluate the regression equation at x,"    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LineweaverBurk_3582, Use the Lineweaver-Burk method to fit an equation of the form\n       V  y = ----------\n       K + x\n\n The equation is linearized and fit using Least Squares\n, Use the Lineweaver-Burk method to fit an equation of the form,"class LineweaverBurk extends ParametricRegression{    use Models\MichaelisMenten;    use Methods\LeastSquares;    /**     * Calculate the regression parameters by least squares on linearized data     * y⁻¹ = K * V⁻¹ * x⁻¹ + V⁻¹     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     * @throws Exception\MathException     */    public function calculate(): void    {        // Linearize the relationship by taking the inverse of both x and y        $x’ = Single::pow($this->xs, -1);        $y’ = Single::pow($this->ys, -1);        // Perform Least Squares Fit        $linearized_parameters = $this->leastSquares($y’, $x’)->getColumn(0);        // Translate the linearized parameters back.        $V = 1 / $linearized_parameters[0];        $K = $linearized_parameters[1] * $V;        $this->parameters = [$V, $K];    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Logistic_3148, Logistic distribution\\n https://en.wikipedia.org/wiki/Logistic_distribution\\n, Logistic distribution,"class Logistic extends Continuous{    /**     * Distribution parameter bounds limits     * μ ∈ (-∞,∞)     * s ∈ (0,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'μ' => '(-∞,∞)',        's' => '(0,∞)',    ];    /**     * Distribution support bounds limits     * x ∈ (-∞,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '(-∞,∞)',    ];    /** @var float Location Parameter */    protected $μ;    /** @var float Scale Parameter */    protected $s;    /**     * Constructor     *     * @param float $μ shape parameter     * @param float $s shape parameter s > 0     */    public function __construct(float $μ, float $s)    {        parent::__construct($μ, $s);    }    /**     * Probability density function     *     *                     /  x - μ \     *                 exp| - -----  |     *                     \    s   /     * f(x; μ, s) = -----------------------     *                /        /  x - μ \ \ ²     *              s| 1 + exp| - -----  | |     *                \        \    s   / /     *     * @param float $x     *     * @return float     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ = $this->μ;        $s = $this->s;        $ℯ＾⁻⁽x⁻μ⁾／s = \exp(-($x - $μ) / $s);        return $ℯ＾⁻⁽x⁻μ⁾／s / ($s * \pow(1 + $ℯ＾⁻⁽x⁻μ⁾／s, 2));    }    /**     * Cumulative distribution function     * From -∞ to x (lower CDF)     *     *                      1     * f(x; μ, s) = -------------------     *                      /  x - μ \     *              1 + exp| - -----  |     *                      \    s   /     *     * @param float $x     *     * @return float     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ = $this->μ;        $s = $this->s;        $ℯ＾⁻⁽x⁻μ⁾／s = \exp(-($x - $μ) / $s);        return 1 / (1 + $ℯ＾⁻⁽x⁻μ⁾／s);    }    /**     * Inverse CDF (quantile function)     *     *                     /   p   \     * Q(p;μ,s) = μ + s ln|  -----  |     *                     \ 1 - p /     *     * @param float $p     *     * @return float     */    public function inverse(float $p): float    {        Support::checkLimits(['p' => '[0,1]'], ['p' => $p]);        $μ = $this->μ;        $s = $this->s;        if ($p == 1) {            return \INF;        }        return $μ + $s * \log($p / (1 - $p));    }    /**     * Mean of the distribution     *     * μ = μ     *     * @return float μ     */    public function mean(): float    {        return $this->μ;    }    /**     * Median of the distribution     *     * median = μ     *     * @return float μ     */    public function median(): float    {        return $this->μ;    }    /**     * Mode of the distribution     *     * mode = μ     *     * @return float μ     */    public function mode(): float    {        return $this->μ;    }    /**     * Variance of the distribution     *     *          s²π²     * var[X] = ----     *           3     *     * @return float     */    public function variance(): float    {        $s² = $this->s ** 2;        $π² = \M_PI ** 2;        return ($s² * $π²) / 3;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Logistic_3151," Cumulative distribution function\\n From -∞ to x (lower CDF)\\n\\n                      1\\n f(x; μ, s) = -------------------\\n                      /  x - μ \\\\\\n              1 + exp| - -----  |\\n                      \\\\    s   /\\n\\n @param float $x\\n\\n @return float\\n", Cumulative distribution function,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ = $this->μ;        $s = $this->s;        $ℯ＾⁻⁽x⁻μ⁾／s = \exp(-($x - $μ) / $s);        return 1 / (1 + $ℯ＾⁻⁽x⁻μ⁾／s);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Logistic_3152," Inverse CDF (quantile function)\\n\\n                     /   p   \\\\\\n Q(p;μ,s) = μ + s ln|  -----  |\\n                     \\\\ 1 - p /\\n\\n @param float $p\\n\\n @return float\\n", Inverse CDF (quantile function),"    public function inverse(float $p): float    {        Support::checkLimits(['p' => '[0,1]'], ['p' => $p]);        $μ = $this->μ;        $s = $this->s;        if ($p == 1) {            return \INF;        }        return $μ + $s * \log($p / (1 - $p));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Logistic_3155, Mode of the distribution\n\n mode = μ\n\n @return float μ\n, Mode of the distribution,    public function mode(): float    {        return $this->μ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixDataProvider_4024, All ref matrices in this data provider are not in rref.\n, All ref matrices in this data provider are not in rref.,"    public function dataProviderForRefMatrix(): array    {        return [            [                [                    [2],                ],            ],            [                [                    [4, 2],                ],            ],            [                [                    [1, 2],                    [0, 1],                ],            ],            [                [                    [1, 2],                    [0, 1],                    [0, 0],                ],            ],            [                [                    [2, 3],                    [0, 2],                    [0, 0],                    [0, 0],                ],            ],            [                [                    [1, 0, -1],                    [0, 5, 2],                    [0, 0, 0]                ],            ],            [                [                    [1, 2, 3, 4],                    [0, 0, 1, 3],                    [0, 0, 0, 1],                ],            ],            [                [                    [1, 2, 3, 4],                    [0, 0, 1, 3],                    [0, 0, 0, 1],                    [0, 0, 0, 0],                ],            ],            [                [                    [1, 0, 3, 3],                    [0, 1, 0, 4],                    [0, 0, 0, 1],                ],            ],            [                [                    [1, -3, 4, -3, 2, 5],                    [0, 1, -2, 2, 1, -3],                    [0, 0, 0, 0, 1, 4],                ],            ],            [                [                    [1, 4, 5, -9, -7],                    [0, 2, 4, -6, -6],                    [0, 0, 0, -5, 0],                    [0, 0, 0, 0, 0],                ],            ],            [                [                    [3, -9, 12, -9, 6, 15],                    [0, 1, -2, 2, 1, -3],                    [0, 0, 0, 0, 1, 4],                ],            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2688, Matrix factory to create matrices of all types.\\n Use factory instead of instantiating individual Matrix classes.\\n, Matrix factory to create matrices of all types.,"class MatrixFactory{    /**     * Factory method     *     * @param  number[][] $A 2-dimensional array of Matrix data     * @param float|null $ε Optional error tolerance     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public static function create(array $A, ?float $ε = null): Matrix    {        self::checkParams($A);        $matrix_type = self::determineMatrixType($A);        switch ($matrix_type) {            case 'numeric':            case 'numeric_square':                return self::createNumeric($A, $ε);            case 'complex':                return new ComplexMatrix($A);            case 'object':                return new ObjectMatrix($A);            case 'object_square':                return new ObjectSquareMatrix($A);        }        throw new Exception\IncorrectTypeException('Unknown matrix type: ' . print_r($A, true));    }    /**     * @param number[][] $A     * @param float|null $ε Optional error tolerance     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     */    public static function createNumeric(array $A, ?float $ε = null): NumericMatrix    {        $m = \count($A);        $n = \count($A[0]);        if ($m === $n) {            $A = new NumericSquareMatrix($A);            $A->setError($ε);            return $A;        }        $A = new NumericMatrix($A);        $A->setError($ε);        return $A;    }    /**     * Factory method to create a matrix from an array of Vectors     *     * Example:     *        [1]       [4]        [7]       [8]     *   X₁ = [2]  X₂ = [2]   X₃ = [8]  X₄ = [4]     *        [1]       [13]       [1]       [5]     *     *       [1  4 7 8]     *   R = [2  2 8 4]     *       [1 13 1 5]     *     * @param  Vector[] $A array of Vectors     * @param float|null $ε Optional error tolerance     *     * @return Matrix     *     * @throws Exception\MatrixException if the Vectors are not all the same length     * @throws Exception\IncorrectTypeException     * @throws Exception\BadDataException     */    public static function createFromVectors(array $A, ?float $ε = null): NumericMatrix    {        // Check that all vectors are the same length        $m = $A[0]->getN();        $n = \count($A);        for ($j = 1; $j < $n; $j++) {            if ($A[$j]->getN() !== $m) {                throw new Exception\MatrixException('Vectors being combined into matrix have different lengths');            }        }        // Concatenate all the vectors        $R = [];        foreach ($A as $V) {            $R[] = $V->getVector();        }        // Transpose to create matrix from the vector columns        return (self::createNumeric($R, $ε))->transpose();    }    /**     * Column vector (column matrix)     * m × 1 matrix consisting of a single column of m elements.     *     *     [x₁]     * x = [x₂]     *     [⋮ ]     *     [xm]     *     * @param array $A m × 1 vector representing the matrix     *     * @return Matrix     */    public static function createFromColumnVector(array $A): Matrix    {        foreach ($A as $item) {            if (\is_array($item)) {                throw new Exception\BadDataException('Column vector data must be a one-dimensional array');            }        }        $R = [];        foreach ($A as $value) {            $R[] = [$value];        }        return self::create($R);    }    /**     * Row vector (row matrix)     * 1 × n matrix consisting of a single row of n elements.     *     * x = [x₁ x₂ ⋯ xn]     *     * @param array $A 1 × n vector representing the matrix     *     * @return Matrix     */    public static function createFromRowVector(array $A): Matrix    {        foreach ($A as $item) {            if (\is_array($item)) {                throw new Exception\BadDataException('Row vector data must be a one-dimensional array');            }        }        $R = [$A];        return self::create($R);    }    /**     * Factory method     *     * @param  array[] $A 2-dimensional array of Matrix data     *     * @return FunctionMatrix     */    public static function createFunctionMatrix(array $A): FunctionMatrix    {        self::checkParams($A);        if (!is_callable($A[0][0])) {            throw new Exception\BadDataException('FunctionMatrix must be made of functions - got ' . gettype($A[0][0]));        }        return new FunctionMatrix($A);    }    /**************************************************************************     * SPECIAL MATRICES - Not created from an array of arrays     *  - identity     *  - exchange     *  - downshiftPermutation     *  - upshiftPermutation     *  - zero     *  - one     *  - eye     *  - diagonal     *  - hilbert     *  - vandermonde     *  - givens     **************************************************************************/    /**     * Identity matrix - n x n matrix with ones in the diagonal     *     * Example:     *  n = 3;     *     *      [1 0 0]     *  A = [0 1 0]     *      [0 0 1]     *     * @param int   $n size of matrix     *     * @return NumericSquareMatrix     *     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function identity(int $n): NumericSquareMatrix    {        if ($n < 0) {            throw new Exception\OutOfBoundsException(""n must be ≥ 0. n = $n"");        }        $R = [];        for ($i = 0; $i < $n; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $i == $j ? 1 : 0;            }        }        return new NumericSquareMatrix($R);    }    /**     * Exchange matrix - n x n matrix with ones in the reverse diagonal     * Row-reversed, or column-reversed version of the identity matrix.     * https://en.wikipedia.org/wiki/Exchange_matrix     *     * Example:     *  n = 3;     *     *      [0 0 1]     *  A = [0 1 0]     *      [1 0 0]     *     * @param int $n size of matrix     *     * @return NumericSquareMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function exchange(int $n): NumericSquareMatrix    {        if ($n < 0) {            throw new Exception\OutOfBoundsException(""n must be ≥ 0. n = $n"");        }        $R = [];        $one = $n - 1;        for ($i = 0; $i < $n; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $j == $one ? 1 : 0;            }            $one--;        }        return new NumericSquareMatrix($R);    }    /**     * Downshift permutation matrix     * Pushes the components of a vector down one notch with wraparound     *     *       [0, 0, 0, 1] [x₁]   [x₄]     *       [1, 0, 0, 0] [x₂]   [x₁]     * D₄x = [0, 1, 0, 0] [x₃] = [x₂]     *       [0, 0, 1, 0] [x₄]   [x₃]     *     * @param  int $n     *     * @return NumericSquareMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function downshiftPermutation(int $n): NumericSquareMatrix    {        $I = self::identity($n)->getMatrix();        $bottom_row = \array_pop($I);        \array_unshift($I, $bottom_row);        return new NumericSquareMatrix($I);    }    /**     * Upshift permutation matrix - Dᵀ     * Pushes the components of a vector up one notch with wraparound     *     * @param  int $n     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     */    public static function upshiftPermutation(int $n): Matrix    {        return self::downshiftPermutation($n)->transpose();    }    /**     * Zero matrix - m x n matrix with all elements being zeros     *     * Example:     *  m = 3; n = 3     *     *      [0 0 0]     *  A = [0 0 0]     *      [0 0 0]     *     * @param int $m rows     * @param int $n columns     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m < 1 or n < 1     */    public static function zero(int $m, int $n): NumericMatrix    {        if ($m < 1 || $n < 1) {            throw new Exception\OutOfBoundsException(""m and n must be > 0. m = $m, n = $n"");        }        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 0;            }        }        return self::createNumeric($R);    }    /**     * Ones matrix - m x n matrix with all elements being ones     *     * Example:     *  m = 3; n = 3     *     *      [1 1 1]     *  A = [1 1 1]     *      [1 1 1]     *     * @param int $m rows     * @param int $n columns     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m or n < 1     */    public static function one(int $m, int $n): NumericMatrix    {        if ($m < 1 || $n < 1) {            throw new Exception\OutOfBoundsException(""m and n must be > 0. m = $m, n = $n"");        }        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 1;            }        }        return self::createNumeric($R);    }    /**     * Eye matrix - ones on the k diagonal and zeros everywhere else.     * Diagonal can start at any column.     * Option to set the diagonal to any number.     *     * Example:     *  m = 3; n = 3; k = 1; x = 1 (3x3 matrix with 1s on the kth (1) diagonal)     *     *      [0 1 0]     *  A = [0 0 1]     *      [0 0 0]     *     * @param int        $m number of rows     * @param int        $n number of columns     * @param int        $k Diagonal to fill with xs     * @param float|null $x (optional; default 1)     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m, n, or k are < 0; if k >= n     */    public static function eye(int $m, int $n, int $k, float $x = null): NumericMatrix    {        if ($n < 0 || $m < 0 || $k < 0) {            throw new Exception\OutOfBoundsException(""m, n and k must be ≥ 0. m = $m, n = $n, k = $k"");        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException(""k must be < n. k = $k, n = $n"");        }        $x = $x ?? 1;        $R = (self::zero($m, $n))->getMatrix();        for ($i = 0; $i < $m; $i++) {            if (($k + $i) < $n) {                $R[$i][$k + $i] = $x;            }        }        return self::createNumeric($R);    }    /**     * A Diagonal Matrix is constructed from a single-row array.     * The elements of this array are placed on the diagonal of a square matrix.     *     * Example:     *  D = [1, 2, 3]     *     *     [1 0 0]     * A = [0 2 0]     *     [0 0 3]     *     * @param array $D elements of the diagonal     *     * @return NumericDiagonalMatrix     *     * @throws Exception\MatrixException     */    public static function diagonal(array $D): NumericDiagonalMatrix    {        $m = \count($D);        $A = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $m; $j++) {                if ($i == $j) {                    $A[$i][$j] = $D[$i];                } else {                    $A[$i][$j] = 0;                }            }        }        return new NumericDiagonalMatrix($A);    }    /**     * Hilbert matrix - a square matrix with entries being the unit fractions     * https://en.wikipedia.org/wiki/Hilbert_matrix     *     *           1     * Hij = ---------     *       i + j - 1     *     * Example: n = 5     *     *     [1 ½ ⅓ ¼ ⅕]     *     [½ ⅓ ¼ ⅕ ⅙]     * H = [⅓ ¼ ⅕ ⅙ ⅐]     *     [¼ ⅕ ⅙ ⅐ ⅛]     *     [⅕ ⅙ ⅐ ⅛ ⅑]     *     * @param int $n     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException     */    public static function hilbert(int $n): NumericMatrix    {        if ($n < 1) {            throw new Exception\OutOfBoundsException(""n must be > 0. m = $n"");        }        $H = [];        for ($i = 1; $i <= $n; $i++) {            for ($j = 1; $j <= $n; $j++) {                $H[$i - 1][$j - 1] = 1 / ($i + $j - 1);            }        }        return new NumericSquareMatrix($H);    }    /**     * Create the Vandermonde Matrix from a simple array.     *     * @param array $M (α₁, α₂, α₃ ⋯ αm)     * @param int   $n     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public static function vandermonde(array $M, int $n): NumericMatrix    {        $A = [];        foreach ($M as $row => $α) {            for ($i = 0; $i < $n; $i++) {                $A[$row][$i] = $α ** $i;            }        }        return self::createNumeric($A);    }   /**    * Construct a Givens rotation matrix    *    *               [  1 ⋯ 0 ⋯ 0 ⋯ 0  ]    *               [  ⋮ ⋱ ⋮   ⋮   ⋮   ]    *               [  0 ⋯ c ⋯-s ⋯ 0  ]    * G (𝒾,𝒿,θ) =   [  ⋮   ⋮  ⋱ ⋮  ⋮  ]    *               [  0 ⋯ s ⋯ c ⋯ 0  ]    *               [  ⋮    ⋮   ⋮ ⋱ ⋮ ]    *               [  0 ⋯ 0 ⋯ 0 ⋯ 1 ]    *    * https://en.wikipedia.org/wiki/Givens_rotation    *    * @param int   $m The row in G in which the top of the rotation lies    * @param int   $n The column in G in which the left of the rotation lies    * @param float $angle The angle to use in the trigonometric functions    * @param int   $size The total number of rows in G    *    * @return NumericMatrix    *    * @throws Exception\BadDataException    * @throws Exception\MathException    * @throws Exception\OutOfBoundsException    */    public static function givens(int $m, int $n, float $angle, int $size): NumericMatrix    {        if ($m >= $size || $n >= $size || $m < 0 || $n < 0) {            throw new Exception\OutOfBoundsException(""m and n must be within the matrix"");        }        $G         = MatrixFactory::identity($size)->getMatrix();        $G[$m][$m] = \cos($angle);        $G[$n][$n] = \cos($angle);        $G[$m][$n] = -1 * \sin($angle);        $G[$n][$m] = \sin($angle);        return self::createNumeric($G);    }    /**     * Create a Matrix of random numbers     *     * @param int $m   number of rows     * @param int $n   number of columns     * @param int $min lower bound for the random number (optional - default: 0)     * @param int $max upper bound for the random number (optional - default: 20)     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     */    public static function random(int $m, int $n, int $min = 0, int $max = 20): NumericMatrix    {        $A = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $A[$i][$j] = \rand($min, $max);            }        }        return self::createNumeric($A);    }    /* ************************************************************************     * PRIVATE HELPER METHODS     * ***********************************************************************/    /**     * Check input parameters     *     * @param  array    $A     *     * @throws Exception\BadDataException if array data not provided for matrix creation     * @throws Exception\MatrixException if any row has a different column count     */    private static function checkParams(array $A): void    {        if (empty($A)) {            throw new Exception\BadDataException('Array data not provided for Matrix creation');        }        if (isset($A[0]) && \is_array($A[0])) {            $column_count = \count($A[0]);            foreach ($A as $i => $row) {                if (\count($row) !== $column_count) {                    throw new Exception\MatrixException(""Row $i has a different column count: "" . \count($row) . ""; was expecting $column_count."");                }            }        }    }    /**     * Determine what type of matrix to create     *     * @param  array[] $A 2-dimensional array of Matrix data     *     * @return string indicating what matrix type to create     */    private static function determineMatrixType(array $A): string    {        $m = \count($A);        $n = \count($A[0]);        // Object (closure) matrices        if (\is_object($A[0][0])) {            if ($A[0][0] instanceof Complex) {                return 'complex';            }            return $m === $n                ? 'object_square'                : 'object';        }        // Numeric matrix        if (\is_numeric($A[0][0])) {            return $m === $n                ? 'numeric_square'                : 'numeric';        }        // Unknown or bad data        return 'unknown';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2693," Exchange matrix - n x n matrix with ones in the reverse diagonal\\n Row-reversed, or column-reversed version of the identity matrix.\\n https://en.wikipedia.org/wiki/Exchange_matrix\\n\\n Example:\\n  n = 3;\\n\\n      [0 0 1]\\n  A = [0 1 0]\\n      [1 0 0]\\n\\n @param int $n size of matrix\\n\\n @return NumericSquareMatrix\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\MathException\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\OutOfBoundsException if n < 0\\n", Exchange matrix - n x n matrix with ones in the reverse diagonal,"    public static function exchange(int $n): NumericSquareMatrix    {        if ($n < 0) {            throw new Exception\OutOfBoundsException(""n must be ≥ 0. n = $n"");        }        $R = [];        $one = $n - 1;        for ($i = 0; $i < $n; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $j == $one ? 1 : 0;            }            $one--;        }        return new NumericSquareMatrix($R);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2694," Downshift permutation matrix\n Pushes the components of a vector down one notch with wraparound\n\n       [0, 0, 0, 1] [x₁]   [x₄]\n       [1, 0, 0, 0] [x₂]   [x₁]\n D₄x = [0, 1, 0, 0] [x₃] = [x₂]\n       [0, 0, 1, 0] [x₄]   [x₃]\n\n @param  int $n\n\n @return NumericSquareMatrix\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MathException\n @throws Exception\\MatrixException\n @throws Exception\\OutOfBoundsException if n < 0\n", Downshift permutation matrix,"    public static function downshiftPermutation(int $n): NumericSquareMatrix    {        $I = self::identity($n)->getMatrix();        $bottom_row = \array_pop($I);        \array_unshift($I, $bottom_row);        return new NumericSquareMatrix($I);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2696, Zero matrix - m x n matrix with all elements being zeros\\n\\n Example:\\n  m = 3; n = 3\\n\\n      [0 0 0]\\n  A = [0 0 0]\\n      [0 0 0]\\n\\n @param int $m rows\\n @param int $n columns\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\MathException\\n @throws Exception\\\\OutOfBoundsException if m < 1 or n < 1\\n, Zero matrix - m x n matrix with all elements being zeros,"    public static function zero(int $m, int $n): NumericMatrix    {        if ($m < 1 || $n < 1) {            throw new Exception\OutOfBoundsException(""m and n must be > 0. m = $m, n = $n"");        }        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 0;            }        }        return self::createNumeric($R);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2698," A Diagonal Matrix is constructed from a single-row array.\n The elements of this array are placed on the diagonal of a square matrix.\n\n Example:\n  D = [1, 2, 3]\n\n     [1 0 0]\n A = [0 2 0]\n     [0 0 3]\n\n @param array $D elements of the diagonal\n\n @return NumericDiagonalMatrix\n\n @throws Exception\\MatrixException\n", A Diagonal Matrix is constructed from a single-row array.,    public static function diagonal(array $D): NumericDiagonalMatrix    {        $m = \count($D);        $A = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $m; $j++) {                if ($i == $j) {                    $A[$i][$j] = $D[$i];                } else {                    $A[$i][$j] = 0;                }            }        }        return new NumericDiagonalMatrix($A);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2700," Create the Vandermonde Matrix from a simple array.\n\n @param array $M (α₁, α₂, α₃ ⋯ αm)\n @param int   $n\n\n @return NumericMatrix\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MathException\n @throws Exception\\MatrixException\n", Create the Vandermonde Matrix from a simple array.,"    public static function vandermonde(array $M, int $n): NumericMatrix    {        $A = [];        foreach ($M as $row => $α) {            for ($i = 0; $i < $n; $i++) {                $A[$row][$i] = $α ** $i;            }        }        return self::createNumeric($A);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2701," Construct a Givens rotation matrix\\n\\n               [  1 ⋯ 0 ⋯ 0 ⋯ 0  ]\\n               [  ⋮ ⋱ ⋮   ⋮   ⋮   ]\\n               [  0 ⋯ c ⋯-s ⋯ 0  ]\\n G (𝒾,𝒿,θ) =   [  ⋮   ⋮  ⋱ ⋮  ⋮  ]\\n               [  0 ⋯ s ⋯ c ⋯ 0  ]\\n               [  ⋮    ⋮   ⋮ ⋱ ⋮ ]\\n               [  0 ⋯ 0 ⋯ 0 ⋯ 1 ]\\n\\n https://en.wikipedia.org/wiki/Givens_rotation\\n\\n @param int   $m The row in G in which the top of the rotation lies\\n @param int   $n The column in G in which the left of the rotation lies\\n @param float $angle The angle to use in the trigonometric functions\\n @param int   $size The total number of rows in G\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\MathException\\n @throws Exception\\\\OutOfBoundsException\\n", Construct a Givens rotation matrix,"    public static function givens(int $m, int $n, float $angle, int $size): NumericMatrix    {        if ($m >= $size || $n >= $size || $m < 0 || $n < 0) {            throw new Exception\OutOfBoundsException(""m and n must be within the matrix"");        }        $G         = MatrixFactory::identity($size)->getMatrix();        $G[$m][$m] = \cos($angle);        $G[$n][$n] = \cos($angle);        $G[$m][$n] = -1 * \sin($angle);        $G[$n][$m] = \sin($angle);        return self::createNumeric($G);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2702, Check input parameters\n\n @param  array    $A\n\n @throws Exception\\BadDataException if array data not provided for matrix creation\n @throws Exception\\MatrixException if any row has a different column count\n, Check input parameters,"    private static function checkParams(array $A): void    {        if (empty($A)) {            throw new Exception\BadDataException('Array data not provided for Matrix creation');        }        if (isset($A[0]) && \is_array($A[0])) {            $column_count = \count($A[0]);            foreach ($A as $i => $row) {                if (\count($row) !== $column_count) {                    throw new Exception\MatrixException(""Row $i has a different column count: "" . \count($row) . ""; was expecting $column_count."");                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2703, Determine what type of matrix to create\n\n @param  array[] $A 2-dimensional array of Matrix data\n\n @return string indicating what matrix type to create\n, Determine what type of matrix to create,    private static function determineMatrixType(array $A): string    {        $m = \count($A);        $n = \count($A[0]);        // Object (closure) matrices        if (\is_object($A[0][0])) {            if ($A[0][0] instanceof Complex) {                return 'complex';            }            return $m === $n                ? 'object_square'                : 'object';        }        // Numeric matrix        if (\is_numeric($A[0][0])) {            return $m === $n                ? 'numeric_square'                : 'numeric';        }        // Unknown or bad data        return 'unknown';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixVectorOperationsTest_4522, Computed using R colSums(A)\n @return array\n, Computed using R colSums(A),"    public function dataProviderForColumnSums(): array    {        return [            [                [                    [4, -1, 3],                    [1, 3, 5],                ],                [5, 2, 8],            ],            [                [                    [1, 4, 7, 8],                    [2, 2, 8, 4],                    [1, 13, 1, 5],                ],                [4, 19, 16, 17],            ],            [                [                    [19, 22, 6, 3, 2, 20],                    [12, 6, 9, 15, 13, 5],                ],                [31, 28, 15, 18, 15, 25],            ],            [                [                    [1, 5, 2, 6, 7, 3],                    [3, 11, 6, 8, 15, 11],                ],                [4, 16, 8, 14, 22, 14],            ],            [                [                    [4, 4.2, 3.9, 4.3, 4.1],                    [2, 2.1, 2, 2.1, 2.2],                    [.6, .59, .58, .62, .63]                ],                [6.60, 6.89, 6.48, 7.02, 6.93],            ]        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixVectorOperationsTest_4524, Computed using R colMeans(A)\\n @return array\\n, Computed using R colMeans(A),"    public function dataProviderForColumnMeans(): array    {        return [            [                [                    [4, -1, 3],                    [1, 3, 5],                ],                [2.5, 1.0, 4.0],            ],            [                [                    [1, 4, 7, 8],                    [2, 2, 8, 4],                    [1, 13, 1, 5],                ],                [1.333333, 6.333333, 5.333333, 5.666667],            ],            [                [                    [19, 22, 6, 3, 2, 20],                    [12, 6, 9, 15, 13, 5],                ],                [15.5, 14.0,  7.5,  9.0,  7.5, 12.5],            ],            [                [                    [1, 5, 2, 6, 7, 3],                    [3, 11, 6, 8, 15, 11],                ],                [2, 8, 4, 7, 11, 7],            ],            [                [                    [4, 4.2, 3.9, 4.3, 4.1],                    [2, 2.1, 2, 2.1, 2.2],                    [.6, .59, .58, .62, .63]                ],                [2.200000, 2.296667, 2.160000, 2.340000, 2.310000],            ]        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2630," Get a specific value at row i, column j\n\n @param  int    $i row index\n @param  int    $j column index\n @return number\n\n @throws Exception\\MatrixException if row i or column j does not exist\n"," Get a specific value at row i, column j","    public function get(int $i, int $j)    {        if ($i >= $this->m) {            throw new Exception\MatrixException(""Row $i does not exist"");        }        if ($j >= $this->n) {            throw new Exception\MatrixException(""Column $j does not exist"");        }        return $this->A[$i][$j];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2632," Returns the elements on the superdiagonal of a square matrix as an array\\n     [1 2 3]\\n A = [4 5 6]\\n     [7 8 9]\\n\\n getSuperdiagonalElements($A) = [2, 6]\\n\\n http://mathworld.wolfram.com/Superdiagonal.html\\n\\n @return array\\n", Returns the elements on the superdiagonal of a square matrix as an array,    public function getSuperdiagonalElements(): array    {        $superdiagonal = [];        if ($this->isSquare()) {            for ($i = 0; $i < $this->m - 1; $i++) {                $superdiagonal[] = $this->A[$i][$i + 1];            }        }        return $superdiagonal;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2633," Returns the elements on the subdiagonal of a square matrix as an array\\n     [1 2 3]\\n A = [4 5 6]\\n     [7 8 9]\\n\\n getSubdiagonalElements($A) = [4, 8]\\n\\n http://mathworld.wolfram.com/Subdiagonal.html\\n\\n @return array\\n", Returns the elements on the subdiagonal of a square matrix as an array,    public function getSubdiagonalElements(): array    {        $subdiagonal = [];        if ($this->isSquare()) {            for ($i = 1; $i < $this->m; $i++) {                $subdiagonal[] = $this->A[$i][$i - 1];            }        }        return $subdiagonal;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2634, Returns an array of vectors from the columns of the matrix.\\n Each column of the matrix becomes a vector.\\n\\n     [1 2 3]\\n A = [4 5 6]\\n     [7 8 9]\\n\\n           [1] [2] [3]\\n Vectors = [4] [5] [6]\\n           [7] [8] [9]\\n\\n @return Vector[]\\n, Returns an array of vectors from the columns of the matrix.,"    public function asVectors(): array    {        $n       = $this->n;        $vectors = [];        for ($j = 0; $j < $n; $j++) {            $vectors[] = new Vector(\array_column($this->A, $j));        }        return $vectors;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2636, Is this matrix the same size and type as some other matrix?\\n\\n @param Matrix $B\\n\\n @return bool\\n, Is this matrix the same size and type as some other matrix?,    protected function isEqualSizeAndType(Matrix $B): bool    {        if ($this->getObjectType() !== $B->getObjectType()) {            return false;        }        $m = $this->m;        $n = $this->n;        // Same dimensions        if ($m != $B->m || $n != $B->n) {            return false;        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2638," Augment a matrix\n An augmented matrix is a matrix obtained by appending the columns of two given matrices\n\n     [1, 2, 3]\n A = [2, 3, 4]\n     [3, 4, 5]\n\n     [4]\n B = [5]\n     [6]\n\n         [1, 2, 3 | 4]\n (A|B) = [2, 3, 4 | 5]\n         [3, 4, 5 | 6]\n\n @param  Matrix $B Matrix columns to add to matrix A\n\n @return Matrix\n\n @throws Exception\\MatrixException if matrices do not have the same number of rows\n @throws Exception\\IncorrectTypeException\n", Augment a matrix,"    public function augment(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of rows');        }        $m    = $this->m;        $A    = $this->A;        $B    = $B->getMatrix();        $⟮A∣B⟯ = [];        for ($i = 0; $i < $m; $i++) {            $⟮A∣B⟯[$i] = \array_merge($A[$i], $B[$i]);        }        return MatrixFactory::create($⟮A∣B⟯, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2639," Augment a matrix on the left\n An augmented matrix is a matrix obtained by preprending the columns of two given matrices\n\n     [1, 2, 3]\n A = [2, 3, 4]\n     [3, 4, 5]\n\n     [4]\n B = [5]\n     [6]\n\n         [4 | 1, 2, 3]\n (A|B) = [5 | 2, 3, 4]\n         [6 | 3, 4, 5]\n\n @param  Matrix $B Matrix columns to add to matrix A\n\n @return Matrix\n\n @throws Exception\\MatrixException if matrices do not have the same number of rows\n @throws Exception\\IncorrectTypeException\n", Augment a matrix on the left,"    public function augmentLeft(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of rows');        }        $m    = $this->m;        $A    = $this->A;        $B    = $B->getMatrix();        $⟮B∣A⟯ = [];        for ($i = 0; $i < $m; $i++) {            $⟮B∣A⟯[$i] = \array_merge($B[$i], $A[$i]);        }        return MatrixFactory::create($⟮B∣A⟯, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2640," Augment a matrix from below\n An augmented matrix is a matrix obtained by appending the rows of two given matrices\n\n     [1, 2, 3]\n A = [2, 3, 4]\n     [3, 4, 5]\n\n B = [4, 5, 6]\n\n         [1, 2, 3]\n (A_B) = [2, 3, 4]\n         [3, 4, 5]\n         [4, 5, 6]\n\n @param  Matrix $B Matrix rows to add to matrix A\n\n @return Matrix\n\n @throws Exception\\MatrixException if matrices do not have the same number of columns\n @throws Exception\\IncorrectTypeException\n", Augment a matrix from below,"    public function augmentBelow(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of columns');        }        $⟮A∣B⟯ = \array_merge($this->A, $B->getMatrix());        return MatrixFactory::create($⟮A∣B⟯, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2641," Augment a matrix from above\\n An augmented matrix is a matrix obtained by prepending the rows of two given matrices\\n\\n     [1, 2, 3]\\n A = [2, 3, 4]\\n     [3, 4, 5]\\n\\n B = [4, 5, 6]\\n\\n         [4, 5, 6]\\n         [1, 2, 3]\\n (A_B) = [2, 3, 4]\\n         [3, 4, 5]\\n\\n @param  Matrix $B Matrix rows to add to matrix A\\n\\n @return Matrix\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\MathException\\n @throws Exception\\\\MatrixException\\n", Augment a matrix from above,"    public function augmentAbove(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of columns');        }        $⟮A∣B⟯ = \array_merge($B->getMatrix(), $this->A);        return MatrixFactory::create($⟮A∣B⟯, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2643, Submatrix\n\n Return an arbitrary subset of a Matrix as a new Matrix.\n\n @param int $m₁ Starting row\n @param int $n₁ Starting column\n @param int $m₂ Ending row\n @param int $n₂ Ending column\n\n @return Matrix\n\n @throws Exception\\MatrixException\n, Submatrix,"    public function submatrix(int $m₁, int $n₁, int $m₂, int $n₂): Matrix    {        if ($m₁ >= $this->m || $m₁ < 0 || $m₂ >= $this->m || $m₂ < 0) {            throw new Exception\MatrixException('Specified Matrix row does not exist');        }        if ($n₁ >= $this->n || $n₁ < 0 || $n₂ >= $this->n || $n₂ < 0) {            throw new Exception\MatrixException('Specified Matrix column does not exist');        }        if ($m₂ < $m₁) {            throw new Exception\MatrixException('Ending row must be greater than beginning row');        }        if ($n₂ < $n₁) {            throw new Exception\MatrixException('Ending column must be greater than the beginning column');        }        $A = [];        for ($i = 0; $i <= $m₂ - $m₁; $i++) {            for ($j = 0; $j <= $n₂ - $n₁; $j++) {                $A[$i][$j] = $this->A[$i + $m₁][$j + $n₁];            }        }        return MatrixFactory::create($A, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2644, Insert\\n Insert a smaller matrix within a larger matrix starting at a specified position\\n\\n @param Matrix $small the smaller matrix to embed\\n @param int    $m     Starting row\\n @param int    $n     Starting column\\n\\n @return Matrix\\n\\n @throws Exception\\\\MatrixException\\n, Insert,"    public function insert(Matrix $small, int $m, int $n): Matrix    {        if ($this->getObjectType() !== $small->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($small->getM() + $m > $this->m || $small->getN() + $n > $this->n) {            throw new Exception\MatrixException('Inner matrix exceeds the bounds of the outer matrix');        }        $new_array = $this->A;        for ($i = 0; $i < $small->getM(); $i++) {            for ($j = 0; $j < $small->getN(); $j++) {                $new_array[$i + $m][$j + $n] = $small[$i][$j];            }        }        return MatrixFactory::create($new_array, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2649, Exclude a row from the result matrix\n\n @param int $mᵢ Row to exclude\n\n @return Matrix with row mᵢ excluded\n\n @throws Exception\\MatrixException if row to exclude does not exist\n @throws Exception\\IncorrectTypeException\n, Exclude a row from the result matrix,"    public function rowExclude(int $mᵢ): Matrix    {        if ($mᵢ >= $this->m || $mᵢ < 0) {            throw new Exception\MatrixException('Row to exclude does not exist');        }        $m = $this->m;        $R = [];        for ($i = 0; $i < $m; $i++) {            if ($i === $mᵢ) {                continue;            }            $R[$i] = $this->A[$i];        }        return MatrixFactory::create(\array_values($R), $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MichaelisMenten_3635, Evaluate the equation using the regression parameters\n y = (V \n @param float $x\n @param array $params\n\n @return float y evaluated\n, Evaluate the equation using the regression parameters,"    public static function evaluateModel(float $x, array $params): float    {        $V = $params[self::$V];        $K = $params[self::$K];        return ($V * $x) / ($K + $x);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MichaelisMenten_3636," Get regression parameters (V and K)\\n\\n @param array $params\\n\\n @return array [ V => number, K => number ]\\n", Get regression parameters (V and K),"    public function getModelParameters(array $params): array    {        return [            'V' => $params[self::$V],            'K' => $params[self::$K],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MidpointRule_3020," Midpoint rule\n\n In numerical analysis, the Midpoint rule is a technique for approximating\n the definite integral of a function.\n\n The Midpoint rule belongs to the closed Newton-Cotes formulas, a group of\n methods for numerical integration which approximate the integral of a function.\n We can either directly supply a set of inputs and their corresponding outputs\n for said function, or if we explicitly know the function, we can define it as a\n callback function and then generate a set of points by evaluating that function\n at n points between a start and end point. We then use these values to\n interpolate a Lagrange polynomial. Finally, we integrate the Lagrange\n polynomial to approximate the integral of our original function.\n\n https://en.wikipedia.org/wiki/Rectangle_method\n http://www.efunda.com/math/num_integration/num_int_newton.cfm\n", Midpoint rule,"class MidpointRule extends NumericalIntegration{    /**     * Use the Midpoint rule to approximate the definite integral of a     * function f(x). Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose definite integral we     * are approximating.     *     * The bounds of the definite integral to which we are approximating is     * determined by the our inputs.     *     * Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite     * integral of the function that produces these coordinates with a lower     * bound of 0, and an upper bound of 10.     *     * Example: approximate(function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Midpoint Rule:     *     * xn        ⁿ⁻¹ xᵢ₊₁     * ∫ f(x)dx = ∑   ∫ f(x)dx     * x₁        ⁱ⁼¹  xᵢ     *     *            ⁿ   h     *          = ∑   - [f(xᵢ)+f(xᵢ₊₁)] + O(h³f″(x))     *           ⁱ⁼¹  2     *     *  where h = xᵢ₊₁ - xᵢ     *  note: this implementation does not compute the error term.     * @param callable|array $source The source of our approximation. Should be either     *                               a callback function or a set of arrays. Each array     *                               (point) contains precisely two numbers, an x and y.     *                               Example array: [[1,2], [2,3], [3,4]].     *                               Example callback: function($x) {return $x**2;}     * @param number        ...$args The arguments of our callback function: start,     *                               end, and n. Example: approximate($source, 0, 8, 5).     *                               If $source is a set of points, do not input any     *                               $args. Example: approximate($source).     *     * @return float                 The approximation to the integral of f(x)     *     * @throws Exception\BadDataException     */    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         *   ⁿ   h         * = ∑   - [f(xᵢ)+f(xᵢ₊₁)] + O(h³f″(x))         *  ⁱ⁼¹  2         * where h = xᵢ₊₁ - xᵢ         */        for ($i = 0; $i < $steps; $i++) {            $xᵢ             = $sorted[$i][$x];            $xᵢ₊₁           = $sorted[$i + 1][$x];            $f⟮xᵢ⟯           = $sorted[$i][$y];     // yᵢ            $f⟮xᵢ₊₁⟯         = $sorted[$i + 1][$y];   // yᵢ₊₁            $midpoint       = ($f⟮xᵢ⟯ + $f⟮xᵢ₊₁⟯) / 2;            $h              = $xᵢ₊₁ - $xᵢ;            $approximation += $h * $midpoint;        }        return $approximation;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MtCars_3315," mtcars dataset (Motor Trend Car Road Tests)\\n\\n The data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of\\n automobile design and performance for 32 automobiles (1973–74 models).\\n\\n 32 observations on 11 variables.\\n R mtcars\\n\\n Source: Henderson and Velleman (1981), Building multiple regression models interactively. Biometrics, 37, 391–411.\\n", mtcars dataset (Motor Trend Car Road Tests),"class MtCars{    private const LABELS = ['mpg', 'cyl', 'disp', 'hp', 'drat', 'wt', 'qsec', 'vs', 'am', 'gear', 'carb'];    private const DATA = [        'Mazda RX4'           => [21, 6, 160, 110, 3.9, 2.62, 16.46, 0, 1, 4, 4],        'Mazda RX4 Wag'       => [21, 6, 160, 110, 3.9, 2.875, 17.02, 0, 1, 4, 4],        'Datsun 710'          => [22.8, 4, 108, 93, 3.85, 2.32, 18.61, 1, 1, 4, 1],        'Hornet 4 Drive'      => [21.4, 6, 258, 110, 3.08, 3.215, 19.44, 1, 0, 3, 1],        'Hornet Sportabout'   => [18.7, 8, 360, 175, 3.15, 3.44, 17.02, 0, 0, 3, 2],        'Valiant'             => [18.1, 6, 225, 105, 2.76, 3.46, 20.22, 1, 0, 3, 1],        'Duster 360'          => [14.3, 8, 360, 245, 3.21, 3.57, 15.84, 0, 0, 3, 4],        'Merc 240D'           => [24.4, 4, 146.7, 62, 3.69, 3.19, 20, 1, 0, 4, 2],        'Merc 230'            => [22.8, 4, 140.8, 95, 3.92, 3.15, 22.9, 1, 0, 4, 2],        'Merc 280'            => [19.2, 6, 167.6, 123, 3.92, 3.44, 18.3, 1, 0, 4, 4],        'Merc 280C'           => [17.8, 6, 167.6, 123, 3.92, 3.44, 18.9, 1, 0, 4, 4],        'Merc 450SE'          => [16.4, 8, 275.8, 180, 3.07, 4.07, 17.4, 0, 0, 3, 3],        'Merc 450SL'          => [17.3, 8, 275.8, 180, 3.07, 3.73, 17.6, 0, 0, 3, 3],        'Merc 450SLC'         => [15.2, 8, 275.8, 180, 3.07, 3.78, 18, 0, 0, 3, 3],        'Cadillac Fleetwood'  => [10.4, 8, 472, 205, 2.93, 5.25, 17.98, 0, 0, 3, 4],        'Lincoln Continental' => [10.4, 8, 460, 215, 3, 5.424, 17.82, 0, 0, 3, 4],        'Chrysler Imperial'   => [14.7, 8, 440, 230, 3.23, 5.345, 17.42, 0, 0, 3, 4],        'Fiat 128'            => [32.4, 4, 78.7, 66, 4.08, 2.2, 19.47, 1, 1, 4, 1],        'Honda Civic'         => [30.4, 4, 75.7, 52, 4.93, 1.615, 18.52, 1, 1, 4, 2],        'Toyota Corolla'      => [33.9, 4, 71.1, 65, 4.22, 1.835, 19.9, 1, 1, 4, 1],        'Toyota Corona'       => [21.5, 4, 120.1, 97, 3.7, 2.465, 20.01, 1, 0, 3, 1],        'Dodge Challenger'    => [15.5, 8, 318, 150, 2.76, 3.52, 16.87, 0, 0, 3, 2],        'AMC Javelin'         => [15.2, 8, 304, 150, 3.15, 3.435, 17.3, 0, 0, 3, 2],        'Camaro Z28'          => [13.3, 8, 350, 245, 3.73, 3.84, 15.41, 0, 0, 3, 4],        'Pontiac Firebird'    => [19.2, 8, 400, 175, 3.08, 3.845, 17.05, 0, 0, 3, 2],        'Fiat X1-9'           => [27.3, 4, 79, 66, 4.08, 1.935, 18.9, 1, 1, 4, 1],        'Porsche 914-2'       => [26, 4, 120.3, 91, 4.43, 2.14, 16.7, 0, 1, 5, 2],        'Lotus Europa'        => [30.4, 4, 95.1, 113, 3.77, 1.513, 16.9, 1, 1, 5, 2],        'Ford Pantera L'      => [15.8, 8, 351, 264, 4.22, 3.17, 14.5, 0, 1, 5, 4],        'Ferrari Dino'        => [19.7, 6, 145, 175, 3.62, 2.77, 15.5, 0, 1, 5, 6],        'Maserati Bora'       => [15, 8, 301, 335, 3.54, 3.57, 14.6, 0, 1, 5, 8],        'Volvo 142E'          => [21.4, 4, 121, 109, 4.11, 2.78, 18.6, 1, 1, 4, 2],    ];    /**     * Raw data without labels     * [[21, 6, 160, ... ], [30.4, 4, 71.1, ... ], ... ]     *     * @return number[][]     */    public function getData(): array    {        return \array_values(self::DATA);    }    /**     * Raw data with each observation labeled     * ['Car Model' => ['mpg' => 21, 'cyl' => 6, 'disp' => 160, ... ]]     *     * @return number[]     */    public function getLabeledData(): array    {        return \array_map(            function (array $data) {                return \array_combine(self::LABELS, $data);            },            self::DATA        );    }    /**     * Car model names     *     * @return string[]     */    public function getModels(): array    {        return \array_keys(self::DATA);    }    /**     * Data for a car model, with labels     * ['mpg' => 21, 'cyl' => 6, 'disp' => 160, ... ]     *     * @param string $model     *     * @return number[]     */    public function getModelData(string $model): array    {        return \array_combine(self::LABELS, self::DATA[$model]);    }    /**     * Miles per gallon observations for all models     * ['Mazda RX4' => 21, 'Honda civic' => 30.4, ... ]     *     * @return number[]     */    public function getMpg(): array    {        return \array_combine($this->getModels(), \array_column(self::DATA, 0));    }    /**     * Number of cylinders observations for all models     * ['Mazda RX4' => 6, 'Honda civic' => 4, ... ]     *     * @return number[]     */    public function getCyl(): array    {        return \array_column(self::DATA, 1);    }    /**     * Displacement (cubic inches) observations for all models     * ['Mazda RX4' => 160, 'Honda civic' => 75.7, ... ]     *     * @return number[]     */    public function getDisp(): array    {        return \array_column(self::DATA, 2);    }    /**     * Gross horsepower observations for all models     * ['Mazda RX4' => 110, 'Honda civic' => 52, ... ]     *     * @return number[]     */    public function getHp(): array    {        return \array_column(self::DATA, 3);    }    /**     * Rear axle ratio observations for all models     * ['Mazda RX4' => 3.9, 'Honda civic' => 4.93, ... ]     *     * @return number[]     */    public function getDrat(): array    {        return \array_column(self::DATA, 4);    }    /**     * Weight (1,000 pounds) observations for all models     * ['Mazda RX4' => 2.62, 'Honda civic' => 1.615, ... ]     *     * @return number[]     */    public function getWt(): array    {        return \array_column(self::DATA, 5);    }    /**     * Quarter-mile time observations for all models     * ['Mazda RX4' => 16.46, 'Honda civic' => 18.52, ... ]     *     * @return number[]     */    public function getQsec(): array    {        return \array_column(self::DATA, 6);    }    /**     * V/S observations for all models     * ['Mazda RX4' => 0, 'Honda civic' => 1, ... ]     *     * @return number[]     */    public function getVs(): array    {        return \array_column(self::DATA, 7);    }    /**     * Transmission (automatic: 0, manual: 1) observations for all models     * ['Mazda RX4' => 1, 'Honda civic' => 1, ... ]     *     * @return number[]     */    public function getAm(): array    {        return \array_column(self::DATA, 8);    }    /**     * Number of forward gears observations for all models     * ['Mazda RX4' => 4, 'Honda civic' => 4, ... ]     *     * @return number[]     */    public function getGear(): array    {        return \array_column(self::DATA, 9);    }    /**     * Number of carburetors observations for all models     * ['Mazda RX4' => 4, 'Honda civic' => 2, ... ]     *     * @return number[]     */    public function getCarb(): array    {        return \array_column(self::DATA, 10);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MtCars_3318, Car model names\n\n @return string[]\n, Car model names,    public function getModels(): array    {        return \array_keys(self::DATA);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MtCars_3319," Data for a car model, with labels\\n ['mpg' => 21, 'cyl' => 6, 'disp' => 160, ... ]\\n\\n @param string $model\\n\\n @return number[]\\n"," Data for a car model, with labels","    public function getModelData(string $model): array    {        return \array_combine(self::LABELS, self::DATA[$model]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MtCars_3322," Displacement (cubic inches) observations for all models\n ['Mazda RX4' => 160, 'Honda civic' => 75.7, ... ]\n\n @return number[]\n", Displacement (cubic inches) observations for all models,"    public function getDisp(): array    {        return \array_column(self::DATA, 2);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MtCars_3328," Transmission (automatic: 0, manual: 1) observations for all models\n ['Mazda RX4' => 1, 'Honda civic' => 1, ... ]\n\n @return number[]\n"," Transmission (automatic: 0, manual: 1) observations for all models","    public function getAm(): array    {        return \array_column(self::DATA, 8);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Multi_2582," Map subtract against multiple arrays\n\n [x₁ - y₁, x₂ - y₂, ... ]\n\n @param array ...$arrays Two or more arrays of numbers\n\n @return array\n\n @throws Exception\\BadDataException\n", Map subtract against multiple arrays,"    public static function subtract(array ...$arrays): array    {        self::checkArrayLengths($arrays);        $number_of_arrays = \count($arrays);        $length_of_arrays = \count($arrays[0]);        $differences      = \array_map(            function ($x) {                return $x;            },            $arrays[0]        );        for ($i = 0; $i < $length_of_arrays; $i++) {            for ($j = 1; $j < $number_of_arrays; $j++) {                $differences[$i] -= $arrays[$j][$i];            }        }        return $differences;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Multi_2583, Map multiply against multiple arrays\n\n [x₁ \n @param array ...$arrays Two or more arrays of numbers\n\n @return array\n\n @throws Exception\\BadDataException\n, Map multiply against multiple arrays,"    public static function multiply(array ...$arrays): array    {        self::checkArrayLengths($arrays);        $number_of_arrays = \count($arrays);        $length_of_arrays = \count($arrays[0]);        $products         = \array_fill(0, $length_of_arrays, 1);        for ($i = 0; $i < $length_of_arrays; $i++) {            for ($j = 0; $j < $number_of_arrays; $j++) {                $products[$i] *= $arrays[$j][$i];            }        }        return $products;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Multi_2584," Map divide against multiple arrays\n\n [x₁ / y₁, x₂ / y₂, ... ]\n\n @param array ...$arrays Two or more arrays of numbers\n\n @return array\n\n @throws Exception\\BadDataException\n", Map divide against multiple arrays,"    public static function divide(array ...$arrays): array    {        self::checkArrayLengths($arrays);        $number_of_arrays = \count($arrays);        $length_of_arrays = \count($arrays[0]);        $quotients        = \array_map(            function ($x) {                return $x;            },            $arrays[0]        );        for ($i = 0; $i < $length_of_arrays; $i++) {            for ($j = 1; $j < $number_of_arrays; $j++) {                $quotients[$i] /= $arrays[$j][$i];            }        }        return $quotients;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Multi_2586," Map min against multiple arrays\\n\\n [max(x₁, y₁), max(x₂, y₂), ... ]\\n\\n @param array ...$arrays Two or more arrays of numbers\\n\\n @return array\\n\\n @throws Exception\\\\BadDataException\\n", Map min against multiple arrays,"    public static function min(array ...$arrays): array    {        self::checkArrayLengths($arrays);        $number_of_arrays = \count($arrays);        $length_of_arrays = \count($arrays[0]);        $mins             = \array_map(            function ($x) {                return $x;            },            $arrays[0]        );        for ($i = 0; $i < $length_of_arrays; $i++) {            for ($j = 1; $j < $number_of_arrays; $j++) {                $mins[$i] = \min($mins[$i], $arrays[$j][$i]);            }        }        return $mins;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Multinomial_3281, Multinomial distribution (multivariate)\n\n https://en.wikipedia.org/wiki/Multinomial_distribution\n, Multinomial distribution (multivariate),"class Multinomial{    /** @var array */    protected $probabilities;    /**     * Multinomial constructor     *     * @param   array $probabilities     *     * @throws Exception\BadDataException if the probabilities do not add up to 1     */    public function __construct(array $probabilities)    {        // Probabilities must add up to 1        if (\round(\array_sum($probabilities), 1) != 1) {            throw new Exception\BadDataException('Probabilities do not add up to 1.');        }        $this->probabilities = $probabilities;    }    /**     * Probability mass function     *     *          n!     * pmf = ------- p₁ˣ¹⋯pkˣᵏ     *       x₁!⋯xk!     *     * n = number of trials (sum of the frequencies) = x₁ + x₂ + ⋯ xk     *     * @param  array $frequencies     *     * @return float     *     * @throws Exception\BadDataException if the number of frequencies does not match the number of probabilities     */    public function pmf(array $frequencies): float    {        // Must have a probability for each frequency        if (\count($frequencies) !== \count($this->probabilities)) {            throw new Exception\BadDataException('Number of frequencies does not match number of probabilities.');        }        foreach ($frequencies as $frequency) {            if (!\is_int($frequency)) {                throw new Exception\BadDataException(""Frequencies must be integers. $frequency is not an int."");            }        }        /** @var int $n */        $n   = \array_sum($frequencies);        $n！ = Combinatorics::factorial($n);        $x₁！⋯xk！ = \array_product(\array_map(            'MathPHP\Probability\Combinatorics::factorial',            $frequencies        ));        $p₁ˣ¹⋯pkˣᵏ = \array_product(\array_map(            function ($x, $p) {                return $p ** $x;            },            $frequencies,            $this->probabilities        ));        return ($n！ / $x₁！⋯xk！) * $p₁ˣ¹⋯pkˣᵏ;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NaturalCubicSpline_2992," Natural Cubic Spline Interpolating Polynomial\n\n In numerical analysis, cubic splines are used for polynomial\n interpolation.\n\n A cubic spline is a spline constructed of piecewise third-order polynomials\n which pass through a set of m control points."" In the case of the natural\n cubic spline, the second derivative of each polynomial is set to zero at the\n endpoints of each interval of the piecewise function.\n\n Cubic spline interpolation belongs to a collection of techniques that\n interpolate a function or a set of values, producing a continuous polynomial.\n In the case of the cubic spline, a piecewise function (polynomial) is produced.\n We can either directly supply a set of inputs and their corresponding outputs\n for said function, or if we explicitly know the function, we can define it as\n a callback function and then generate a set of points by evaluating that\n function at n points between a start and end point. We then use these values\n to interpolate our piecewise polynomial.\n\n https://en.wikipedia.org/wiki/Spline_interpolation\n http://mathworld.wolfram.com/CubicSpline.html\n", Natural Cubic Spline Interpolating Polynomial,"class NaturalCubicSpline extends Interpolation{    /**     * Interpolate     *     * @param callable|array $source The source of our approximation. Should be either     *                           a callback function or a set of arrays. Each array     *                           (point) contains precisely two numbers, an x and y.     *                           Example array: [[1,2], [2,3], [3,4]].     *                           Example callback: function($x) {return $x**2;}     * @param number   ...$args  The arguments of our callback function: start,     *                           end, and n. Example: approximate($source, 0, 8, 5).     *                           If $source is a set of points, do not input any     *                           $args. Example: approximate($source).     *     * @return Piecewise         The interpolating (piecewise) polynomial, as an     *                           instance of Piecewise.     *     * @throws Exception\BadDataException     */    public static function interpolate($source, ...$args): Piecewise    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 1);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n     = \count($sorted);        $k     = $n - 1;        $h     = [];        $a     = [];        $μ     = [0];        $z     = [0];        $z[$k] = 0;        $c     = [];        $c[$k] = 0;        $poly  = [];        $int   = [];        for ($i = 0; $i < $k; $i++) {            $xᵢ     = $sorted[$i][$x];            $xᵢ₊₁   = $sorted[$i + 1][$x];            $a[$i]  = $sorted[$i][$y];            $h[$i]  = $xᵢ₊₁ - $xᵢ;            if ($i == 0) {                continue;            }            $xᵢ₋₁   = $sorted[$i - 1][$x];            $f⟮xᵢ⟯   = $sorted[$i][$y];    // yᵢ            $f⟮xᵢ₊₁⟯ = $sorted[$i + 1][$y];  // yᵢ₊₁            $f⟮xᵢ₋₁⟯ = $sorted[$i - 1][$y];  // yᵢ₋₁            $α      = (3 / $h[$i]) * ($f⟮xᵢ₊₁⟯ - $f⟮xᵢ⟯) - (3 / $h[$i - 1]) * ($f⟮xᵢ⟯ - $f⟮xᵢ₋₁⟯);            $l      = 2 * ($xᵢ₊₁ - $xᵢ₋₁) - $h[$i - 1] * $μ[$i - 1];            $μ[$i]  = $h[$i] / $l;            $z[$i]  = ($α - $h[$i - 1] * $z[$i - 1]) / $l;        }        for ($i = $k - 1; $i >= 0; $i--) {            $xᵢ       = $sorted[$i][$x];            $xᵢ₊₁     = $sorted[$i + 1][$x];            $f⟮xᵢ⟯     = $sorted[$i][$y];    // yᵢ            $f⟮xᵢ₊₁⟯   = $sorted[$i + 1][$y];  // yᵢ₊₁            $c[$i]    = $z[$i] - $μ[$i] * $c[$i + 1];            $b[$i]    = ($f⟮xᵢ₊₁⟯ - $f⟮xᵢ⟯) / $h[$i] - $h[$i] * ($c[$i + 1] + 2 * $c[$i]) / 3;            $d[$i]    = ($c[$i + 1] - $c[$i]) / (3 * $h[$i]);            $poly[$i] = new Polynomial([                $d[$i],                $c[$i] - 3 * $d[$i] * $xᵢ,                $b[$i] - 2 * $c[$i] * $xᵢ + 3 * $d[$i] * ($xᵢ ** 2),                $a[$i] - $b[$i] * $xᵢ + $c[$i] * ($xᵢ ** 2) - $d[$i] * ($xᵢ ** 3)            ]);            if ($i == 0) {                $int[$i] = [$xᵢ, $xᵢ₊₁];            } else {                $int[$i] = [$xᵢ, $xᵢ₊₁, true, false];            }        }        $piecewise = new Piecewise($int, $poly);        return $piecewise;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NegativeBinomial_3247," Cumulative distribution function (lower cumulative distribution)\n\n               ₓ\n P(x; r, p) =  Σ pmf(k, r, p)\n              ᵏ⁼⁰\n\n @param int $x number of successes\n\n @return float\n\n @throws MathException\n", Cumulative distribution function (lower cumulative distribution),"    public function cdf(int $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        return \array_sum(            \array_map(                [$this, 'pmf'],                \range(0, $x)            )        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NewtonsMethod_3040," Newton's Method (also known as the Newton–Raphson method)\n\n In numerical analysis, Newton's method is a method for finding successively better\n approximations to the roots (or zeroes) of a real-valued function.\n", Newton's Method (also known as the Newton–Raphson method),"class NewtonsMethod{    /**     * Use Newton's Method to find the x which produces $target = $function(x) value     * $args is an array of parameters to pass to $function, but having the element that     * will be changed and serve as the initial guess in position $position.     *     * @param callable $function     f(x) callback function     * @param array    $args         Parameters to pass to callback function. The initial value for the     *                               parameter of interest must be in this array.     * @param number   $target       Value of f(x) we a trying to solve for     * @param float    $tol          Tolerance; How close to the actual solution we would like.     * @param int      $position     Which element in the $args array will be changed; also serves as initial guess     * @param int      $iterations     *     * @return number     *     * @throws Exception\OutOfBoundsException if the tolerance is not valid     */    public static function solve(callable $function, array $args, $target, float $tol, int $position = 0, int $iterations = 100)    {        Validation::tolerance($tol);        // Initialize        $args1 = $args;        $guess = $args[$position];        $i     = 0;        do {            $args1[$position] = $guess + $tol; // load the initial guess into the arguments            $args[$position]  = $guess;        // load the initial guess into the arguments            $y                = $function(...$args);            $y_at_xplusdelx   = $function(...$args1);            $slope            = ($y_at_xplusdelx - $y) / $tol;            $del_y            = $target - $y;            if (\abs($slope) < $tol) {                return \NAN;            }            $guess            = $del_y / $slope + $guess;            $dif              = \abs($del_y);            $i++;        } while ($dif > $tol && $i < $iterations);        if ($dif > $tol) {            return \NAN;        }        return $guess;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NonInteger_3394, Harmonic Numbers\\n\\n      n  1\\n Hᵢ = ∑  -\\n     ⁱ⁼¹ i\\n\\n https://en.wikipedia.org/wiki/Harmonic_number\\n\\n @param int $n the length of the sequence to calculate\\n\\n @return array\\n, Harmonic Numbers,"    public static function Harmonic(int $n): array    {        return self::Hyperharmonic($n, 1);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NoncentralT_3157, Noncentral t-distribution\n https://en.wikipedia.org/wiki/Noncentral_t-distribution\n, Noncentral t-distribution,"class NoncentralT extends Continuous{    /**     * Distribution parameter bounds limits     * ν ∈ (0,∞)     * μ ∈ (-∞,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'ν' => '(0,∞)',        'μ' => '(-∞,∞)',    ];    /**     * Distribution support bounds limits     * x ∈ (-∞,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '(-∞,∞)',    ];    /** @var int degrees of freedom > 0 */    protected $ν;    /** @var float Noncentrality parameter */    protected $μ;    /**     * Constructor     *     * @param int   $ν degrees of freedom > 0     * @param float $μ Noncentrality parameter     */    public function __construct(int $ν, float $μ)    {        parent::__construct($ν, $μ);    }    /**     * Probability density function     *     *   /v\                /   μ²\     *  | - |              |-1*--- |                        / ν    3     μ²x²   \            / ν + 1    1     μ²x²   \   \     *   \2/                \   2 /           /         ₁F₁|  - ;  - ; --------- |       ₁F₁|  ----- ;  - ; --------- |   |     *  ν    * Γ(ν + 1) * e                  |              \ 2    2   2(ν + x²)/            \   2      2   2(ν + x²)/    |     * ---------------------------------  *  | √2*μ*x * ---------------------------  +  --------------------------------  |     *  ν           (ν / 2)                  |                        / ν + 1 \                         / ν    \          |     * 2  * (ν + x²)         * Γ(ν / 2)      |           (ν + x²) * Γ|  ------ |          √(ν + x²) * Γ|  - + 1 |         |     *                                        \                       \   2   /                         \ 2    /         /     *     * @param float $x percentile     *     * @return float     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $ν = $this->ν;        $μ = $this->μ;        $part1 =  $ν ** ($ν / 2) * Special::gamma($ν + 1) * \exp(-1 * $μ ** 2 / 2) / 2 ** $ν / ($ν + $x ** 2) ** ($ν / 2) / Special::gamma($ν / 2);        $F1 = $ν / 2 + 1;        $F2 = 3 / 2;        $F3 = $μ ** 2 * $x ** 2 / 2 / ($ν + $x ** 2);        $inner_part1 = \sqrt(2) * $μ * $x * Special::confluentHypergeometric($F1, $F2, $F3) / ($ν + $x ** 2) / Special::gamma(($ν + 1) / 2);        $F1 = ($ν + 1) / 2;        $F2 = 1 / 2;        $inner_part2 = Special::confluentHypergeometric($F1, $F2, $F3) / \sqrt($ν + $x ** 2) / Special::gamma($ν / 2 + 1);        return $part1 * ($inner_part1 + $inner_part2);    }    /**     * Cumulative distribution function     *     * Fᵥ,ᵤ(x) = Fᵥ,ᵤ(x),      if x ≥ 0     *         = 1 - Fᵥ,₋ᵤ(x)  if x < 0     *     * @param float $x     *     * @return float     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $ν = $this->ν;        $μ = $this->μ;        if ($μ == 0) {            $studentT = new StudentT($ν);            return $studentT->cdf($x);        }        if ($x >= 0) {            return $this->f($x, $ν, $μ);        }        return 1 - $this->f($x, $ν, -$μ);    }    /**     * F used within CDF     *                          _                                        _     *                   1  ∞  |        /    1  ν \          /       ν \  |     * Fᵥ,ᵤ(x) = Φ(-μ) + -  ∑  |  pⱼIy | j + -, -  | + qⱼIy | j + 1, -  | |     *                   2 ʲ⁼⁰ |_       \    2  2 /          \       2 / _|     *     *  where     *   Φ       = cumulative distribution function of the standard normal distribution     *   Iy(a,b) = regularized incomplete beta function     *     *          x²     *   y = ------     *       x² + ν     *     *        1      /  μ² \   / μ² \ʲ     *   pⱼ = -- exp| - -   | |  -   |     *        j!     \  2  /   \ 2  /     *     *              μ          /  μ² \   / μ² \ʲ     *   qⱼ = ------------ exp| - -   | |  -   |     *        √2Γ(j + 3/2)     \  2  /   \ 2  /     *     * @param float $x     * @param int   $ν     * @param float $μ     *     * @return float     */    private function f(float $x, int $ν, float $μ): float    {        $standardNormal = new StandardNormal();        $Φ = $standardNormal->cdf(-$μ);        $y = $x ** 2 / ($x ** 2 + $ν);        $sum = $Φ;        $tol = .00000001;        $j   = 0;        do {            $exp = \exp(-1 * $μ ** 2 / 2) * ($μ ** 2 / 2) ** $j;            $pⱼ  = 1 / Combinatorics::factorial($j) * $exp;            $qⱼ  = $μ / \sqrt(2) / Special::gamma($j + 3 / 2) * $exp;            $I1  = Special::regularizedIncompleteBeta($y, $j + 1 / 2, $ν / 2);            $I2  = Special::regularizedIncompleteBeta($y, $j + 1, $ν / 2);            $delta = $pⱼ * $I1 + $qⱼ * $I2;            $sum  += $delta / 2;            $j    += 1;        } while ($delta / $sum > $tol || $j < 10);        return $sum;    }    /**     * Mean of the distribution     *            _     *           /ν Γ((ν - 1)/2)     * E[T] = μ / - ------------    if ν > 1     *         √  2    Γ(ν/2)     *     *      = Does not exist        if ν ≤ 1     *     * @return float     */    public function mean(): float    {        $ν = $this->ν;        $μ = $this->μ;        if ($ν == 1) {            return \NAN;        }        return $μ * \sqrt($ν / 2) * Special::gamma(($ν - 1) / 2) / Special::gamma($ν / 2);    }    /**     * Median of the distribution     * @note: This is probably not correct and should be updated.     * @todo: Replace with actual median calculation.     *     * @return float     */    public function median(): float    {        return $this->mean();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NormalTest_5533, Test data created with scipy.stats.multivariate_normal.pdf\\n @return array\\n, Test data created with scipy.stats.multivariate_normal.pdf,"    public function dataProviderForPdf(): array    {        return [            [                [0, 0],                [0, 0],                [                    [1, 0],                    [0, 1],                ],                0.15915494309189535,            ],            [                [1, 1],                [0, 0],                [                    [1, 0],                    [0, 1],                ],                0.058549831524319168,            ],            [                [1, 1],                [1, 1],                [                    [1, 0],                    [0, 1],                ],                0.15915494309189535,            ],            [                [0.7, 1.4],                [1, 1.1],                [                    [1, 0],                    [0, 1],                ],                0.14545666578175082,            ],            [                [0.7, 1.4],                [1, 1.1],                [                    [1, 0],                    [0, 2],                ],                0.10519382725436884,            ],            [                [4.5, 7.6],                [3.2, 6.7],                [                    [1, 0],                    [0, 1],                ],                0.045598654639838636,            ],            [                [20.3, 12.6],                [20, 15],                [                    [25, 10],                    [10, 16],                ],                0.0070398507893074313,            ],            [                [7, 12],                [4.8, 8.4],                [                    [1.7, 2.6],                    [2.6, 6.3],                ],                0.019059723382617431,            ],            [                [4, 9],                [4.8, 8.4],                [                    [1.7, 2.6],                    [2.6, 6.3],                ],                0.032434509200433989,            ],            [                [4, 5],                [4.8, 8.4],                [                    [1.7, 2.6],                    [2.6, 6.3],                ],                0.023937002571148978,            ],            [                [5, 8],                [4.8, 8.4],                [                    [1.7, 2.6],                    [2.6, 6.3],                ],                0.07109614254107853,            ],            [                [4, 8],                [4.8, 8.4],                [                    [1.7, 2.6],                    [2.6, 6.3],                ],                0.057331098511004673,            ],            [                [30, 50],                [26.95, 24.8],                [                    [88.57632, 67.51579],                    [67.51579, 64.27368],                ],                6.0531136999164446e-12,            ],            [                [4.5, 7.6, 9.3],                [3.2, 6.7, 8.0],                [                    [1, 0, 0],                    [0, 1, 0],                    [0, 0, 1],                ],                0.0078141772449033566,            ],            [                [4.5, 7.6, 9.3],                [3.2, 6.7, 8.0],                [                    [1, 0, 0],                    [0, 1, 0],                    [0, 0, 2],                ],                0.0084305843631899829,            ],            [                [2, 11, 3],                [1, 12, 2],                [                    [1, 2, 0],                    [2, 5, 0.5],                    [0, 0.5, 3],                ],                8.2808512671378126e-05,            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3168, Inverse CDF (quantile)\n\n @param float $p\n\n @return float\n, Inverse CDF (quantile),    public function inverse(float $p): float    {        if ($p == 0) {            return -\INF;        }        if ($p == 1) {            return \INF;        }        return parent::inverse($p);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3169, Mean of the distribution\\n\\n μ = μ\\n\\n @return float\\n, Mean of the distribution,    public function mean(): float    {        return $this->μ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3172, Variance of the distribution\n\n var[X] = σ²\n\n @return float\n, Variance of the distribution,    public function variance(): float    {        return $this->σ ** 2;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3173, Random number - Box–Muller transform\n\n https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n, Random number - Box–Muller transform,"    public function rand()    {        $rand1 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        $rand2 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        return \sqrt(-2 * \log($rand1)) * \cos(2 * pi() * $rand2) * $this->σ + $this->μ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericDiagonalMatrix_2708, Diagonal matrix must be upper triangular\n @inheritDoc\n, Diagonal matrix must be upper triangular,    public function isUpperTriangular(): bool    {        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericDiagonalMatrix_2709, Diagonal matrix must be triangular\n @inheritDoc\n, Diagonal matrix must be triangular,    public function isTriangular(): bool    {        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2711, m x n Matrix\\n, m x n Matrix,"class NumericMatrix extends Matrix{    /** @var float Error/zero tolerance */    protected $ε;    // Default error/zero tolerance    protected const ε = 0.00000000001;    // Matrix data direction    public const ROWS    = 'rows';    public const COLUMNS = 'columns';    // Matrix solve methods    public const LU      = 'LU';    public const QR      = 'QR';    public const INVERSE = 'Inverse';    public const RREF    = 'RREF';    public const DEFAULT = 'Default';    /**     * Constructor     *     * @param array[] $A of arrays $A m x n matrix     *     * @throws Exception\BadDataException if any rows have a different column count     */    public function __construct(array $A)    {        $this->A       = $A;        $this->m       = \count($A);        $this->n       = $this->m > 0 ? \count($A[0]) : 0;        $this->ε       = self::ε;        $this->catalog = new MatrixCatalog();        $this->validateMatrixDimensions();    }    /**     * Validate the matrix is entirely m x n     *     * @throws Exception\BadDataException     */    protected function validateMatrixDimensions()    {        foreach ($this->A as $i => $row) {            if (\count($row) !== $this->n) {                throw new Exception\BadDataException(""Row $i has a different column count: "" . \count($row) . ""; was expecting {$this->n}."");            }        }    }    /**     * Get the type of objects that are stored in the matrix     *     * @return string The class of the objects     */    public function getObjectType(): string    {        return 'number';    }    /**************************************************************************     * BASIC MATRIX GETTERS     *  - getError     **************************************************************************/    /**     * Get error / zero tolerance     * @return float     */    public function getError(): float    {        return $this->ε;    }    /***************************************************************************     * SETTERS     *  - setError     **************************************************************************/    /**     * Set the error/zero tolerance for matrix values     *  - Used to determine tolerance for equality     *  - Used to determine if a value is zero     *     * @param float|null $ε     */    public function setError(?float $ε): void    {        if ($ε === null) {            return;        }        $this->ε = $ε;    }    /***************************************************************************     * MATRIX COMPARISONS     *  - isEqual     ***************************************************************************/    /**     * Is this matrix equal to some other matrix?     *     * @param NumericMatrix $B     *     * @return bool     */    public function isEqual(NumericMatrix $B): bool    {        if (!$this->isEqualSizeAndType($B)) {            return false;        }        $m = $this->m;        $n = $this->n;        $ε = $this->ε;        // All elements are the same        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if (Support::isNotEqual($this->A[$i][$j], $B[$i][$j], $ε)) {                    return false;                }            }        }        return true;    }    /**************************************************************************     * MATRIX PROPERTIES     *  - isSymmetric     *  - isSingular     *  - isNonsingular     *  - isInvertible     *  - isPositiveDefinite     *  - isPositiveSemidefinite     *  - isNegativeDefinite     *  - isNegativeSemidefinite     *  - isLowerTriangular     *  - isUpperTriangular     *  - isTriangular     *  - isDiagonal     *  - isRectangularDiagonal     *  - isRef     *  - isRref     *  - isIdempotent     *  - isNilpotent     *  - isInvolutory     *  - isSignature     *  - isUpperBidiagonal     *  - isLowerBidiagonal     *  - isBidiagonal     *  - isTridiagonal     *  - isUpperHessenberg     *  - isLowerHessenberg     *  - isOrthogonal     *  - isNormal     *  - isUnitary     *  - isHermitian     **************************************************************************/    /**     * Is the matrix symmetric?     * Does A = Aᵀ     * aᵢⱼ = aⱼᵢ     *     * Algorithm: Iterate on the upper triangular half and compare with corresponding     * values on the lower triangular half. Skips the diagonal as it is symmetric with itself.     *     * @return bool true if symmetric; false otherwise.     *     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     */    public function isSymmetric(): bool    {        if (!$this->isSquare()) {            return false;        }        for ($i = 0; $i < $this->m - 1; $i++) {            for ($j = $i + 1; $j < $this->n; $j++) {                if (Support::isNotEqual($this->A[$i][$j], $this->A[$j][$i], $this->ε)) {                    return false;                }            }        }        return true;    }    /**     * Is the matrix skew-symmetric? (Antisymmetric matrix)     * Does Aᵀ = −A     * aᵢⱼ = -aⱼᵢ and main diagonal are all zeros     *     * Algorithm: Iterate on the upper triangular half and compare with corresponding     * values on the lower triangular half. Skips the diagonal as it is symmetric with itself.     *     * @return bool true if skew-symmetric; false otherwise.     *     * @throws Exception\BadParameterException     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     */    public function isSkewSymmetric(): bool    {        if (!$this->isSquare()) {            return false;        }        for ($i = 0; $i < $this->m - 1; $i++) {            for ($j = $i + 1; $j < $this->n; $j++) {                if (Support::isNotEqual($this->A[$i][$j], -$this->A[$j][$i], $this->ε)) {                    return false;                }            }        }        foreach ($this->getDiagonalElements() as $diagonalElement) {            if (Support::isNotZero($diagonalElement, $this->ε)) {                return false;            }        }        return true;    }    /**     * Is the matrix singular?     * A square matrix that does not have an inverse.     * If the determinant is zero, then the matrix is singular.     * http://mathworld.wolfram.com/SingularMatrix.html     *     * @return bool true if singular; false otherwise.     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     * @throws Exception\BadParameterException     */    public function isSingular(): bool    {        $│A│ = $this->det();        if (Support::isZero($│A│, $this->ε)) {            return true;        }        return false;    }    /**     * Is the matrix nonsingular? (Regular matrix)     * A square matrix that is not singular. It has an inverse.     * If the determinant is nonzero, then the matrix is nonsingular.     * http://mathworld.wolfram.com/NonsingularMatrix.html     *     * @return bool true if nonsingular; false otherwise.     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     * @throws Exception\BadParameterException     */    public function isNonsingular(): bool    {        $│A│ = $this->det();        if (Support::isNotZero($│A│, $this->ε)) {            return true;        }        return false;    }    /**     * Is the matrix invertible? (Regular nonsingular matrix)     * Convenience method for isNonsingular.     * https://en.wikipedia.org/wiki/Invertible_matrix     * http://mathworld.wolfram.com/NonsingularMatrix.html     *     * @return bool true if invertible; false otherwise.     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     * @throws Exception\BadParameterException     */    public function isInvertible(): bool    {        return $this->isNonsingular();    }    /**     * Is the matrix positive definite?     *  - It is square and symmetric.     *  - All principal minors have strictly positive determinants (> 0)     *     * Other facts:     *  - All its eigenvalues are positive.     *  - All its pivots are positive.     *     * https://en.wikipedia.org/wiki/Positive-definite_matrix     * http://mathworld.wolfram.com/PositiveDefiniteMatrix.html     * http://mat.gsia.cmu.edu/classes/QUANT/NOTES/chap1/node8.html     * https://en.wikipedia.org/wiki/Sylvester%27s_criterion     *     * @return boolean true if positive definite; false otherwise     *     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\IncorrectTypeException     * @throws Exception\BadParameterException     */    public function isPositiveDefinite(): bool    {        if (!$this->isSymmetric()) {            return false;        }        for ($i = 1; $i <= $this->n; $i++) {            if ($this->leadingPrincipalMinor($i)->det() <= 0) {                return false;            }        }        return true;    }    /**     * Is the matrix positive semidefinite?     *  - It is square and symmetric.     *  - All principal minors have positive determinants (≥ 0)     *     * http://mathworld.wolfram.com/PositiveSemidefiniteMatrix.html     *     * @return boolean true if positive semidefinite; false otherwise     *     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\IncorrectTypeException     * @throws Exception\BadParameterException     */    public function isPositiveSemidefinite(): bool    {        if (!$this->isSymmetric()) {            return false;        }        for ($i = 1; $i <= $this->n; $i++) {            if ($this->leadingPrincipalMinor($i)->det() < 0) {                return false;            }        }        return true;    }    /**     * Is the matrix negative definite?     *  - It is square and symmetric.     *  - All principal minors have nonzero determinants and alternate in signs, starting with det(A₁) < 0     *     * http://mathworld.wolfram.com/NegativeDefiniteMatrix.html     *     * @return boolean true if negative definite; false otherwise     *     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\IncorrectTypeException     * @throws Exception\BadParameterException     */    public function isNegativeDefinite(): bool    {        if (!$this->isSymmetric()) {            return false;        }        for ($i = 1; $i <= $this->n; $i++) {            switch ($i % 2) {                case 1:                    if ($this->leadingPrincipalMinor($i)->det() >= 0) {                        return false;                    }                    break;                case 0:                    if ($this->leadingPrincipalMinor($i)->det() <= 0) {                        return false;                    }                    break;            }        }        return true;    }    /**     * Is the matrix negative semidefinite?     *  - It is square and symmetric.     *  - All principal minors have determinants that alternate signs, starting with det(A₁) ≤ 0     *     * http://mathworld.wolfram.com/NegativeSemidefiniteMatrix.html     *     * @return boolean true if negative semidefinite; false otherwise     *     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\IncorrectTypeException     * @throws Exception\BadParameterException     */    public function isNegativeSemidefinite(): bool    {        if (!$this->isSymmetric()) {            return false;        }        for ($i = 1; $i <= $this->n; $i++) {            switch ($i % 2) {                case 1:                    if ($this->leadingPrincipalMinor($i)->det() > 0) {                        return false;                    }                    break;                case 0:                    if ($this->leadingPrincipalMinor($i)->det() < 0) {                        return false;                    }                    break;            }        }        return true;    }    /**     * Is the matrix lower triangular?     *  - It is a square matrix     *  - All the entries above the main diagonal are zero     *     * https://en.wikipedia.org/wiki/Triangular_matrix     *     * @return boolean true if lower triangular; false otherwise     */    public function isLowerTriangular(): bool    {        if (!$this->isSquare()) {            return false;        }        $m = $this->m;        $n = $this->n;        for ($i = 0; $i < $m; $i++) {            for ($j = $i + 1; $j < $n; $j++) {                if (!Support::isZero($this->A[$i][$j])) {                    return false;                }            }        }        return true;    }    /**     * Is the matrix upper triangular?     *  - It is a square matrix     *  - All the entries below the main diagonal are zero     *     * https://en.wikipedia.org/wiki/Triangular_matrix     *     * @return boolean true if upper triangular; false otherwise     */    public function isUpperTriangular(): bool    {        if (!$this->isSquare()) {            return false;        }        $m = $this->m;        for ($i = 1; $i < $m; $i++) {            for ($j = 0; $j < $i; $j++) {                if (!Support::isZero($this->A[$i][$j])) {                    return false;                }            }        }        return true;    }    /**     * Is the matrix triangular?     * The matrix is either lower or upper triangular     *     * https://en.wikipedia.org/wiki/Triangular_matrix     *     * @return boolean true if triangular; false otherwise     */    public function isTriangular(): bool    {        return ($this->isLowerTriangular() || $this->isUpperTriangular());    }    /**     * Is the matrix diagonal?     *  - It is a square matrix     *  - All the entries above the main diagonal are zero     *  - All the entries below the main diagonal are zero     *     * http://mathworld.wolfram.com/DiagonalMatrix.html     *     * @return boolean true if diagonal; false otherwise     */    public function isDiagonal(): bool    {        return ($this->isLowerTriangular() && $this->isUpperTriangular());    }    /**     * Is the retangular matrix diagonal?     *  - All the entries below and above the main diagonal are zero     *     * https://en.wikipedia.org/wiki/Diagonal_matrix     *     * @return boolean true if rectangular diagonal     */    public function isRectangularDiagonal(): bool    {        $m = $this->m;        $n = $this->n;        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if ($i !== $j && !Support::isZero($this->A[$i][$j])) {                    return false;                }            }        }        return true;    }    /**     * Is the matrix in row echelon form?     *  - All nonzero rows are above any rows of all zeroes     *  - The leading coefficient of a nonzero row is always strictly to the right of the leading coefficient of the row above it.     *     * https://en.wikipedia.org/wiki/Row_echelon_form     *     * @return boolean true if matrix is in row echelon form; false otherwise     */    public function isRef(): bool    {        $m           = $this->m;        $n           = $this->n;        $zero_row_ok = true;        // All nonzero rows are above any rows of all zeroes        for ($i = $m - 1; $i >= 0; $i--) {            $zero_row = \count(\array_filter(                $this->A[$i],                function ($x) {                    return $x != 0;                }            )) === 0;            if (!$zero_row) {                $zero_row_ok = false;                continue;            }            if (!$zero_row_ok) {                return false;            }        }        // Leading coefficients to the right of rows above it        $lc = -1;        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if ($this->A[$i][$j] != 0) {                    if ($j <= $lc) {                        return false;                    }                    $lc = $j;                    continue 2;                }            }        }        return true;    }    /**     * Is the matrix in reduced row echelon form?     *  - It is in row echelon form     *  - Leading coefficients are 1     *  - Leading coefficients are the only nonzero entry in its column     *     * https://en.wikipedia.org/wiki/Row_echelon_form     *     * @return boolean true if matrix is in reduced row echelon form; false otherwise     *     * @throws Exception\MatrixException     */    public function isRref(): bool    {        // Row echelon form        if (!$this->isRef()) {            return false;        }        $m   = $this->m;        $n   = $this->n;        $lcs = [];        // Leading coefficients are 1        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if ($this->A[$i][$j] == 0) {                    continue;                }                if ($this->A[$i][$j] != 1) {                    return false;                }                $lcs[] = $j;                continue 2;            }        }        // Leading coefficients are the only nonzero entry in its column        foreach ($lcs as $j) {            $column  = $this->getColumn($j);            $entries = \array_filter($column);            if (\count($entries) !== 1) {                return false;            }            $entry = \array_shift($entries);            if ($entry != 1) {                return false;            }        }        return true;    }    /**     * Is the matrix idempotent?     * A matrix that equals itself when squared.     * https://en.wikipedia.org/wiki/Idempotent_matrix     *     * @return boolean true if matrix is idempotent; false otherwise     *     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     * @throws Exception\VectorException     */    public function isIdempotent(): bool    {        if (!$this->isSquare()) {            return false;        }        $A² = $this->multiply($this);        return $this->isEqual($A²);    }    /**     * Is the matrix nilpotent?     *     * A square MxM matrix is nilpotent if it becomes the     * zero matrix when raised to some power k ≤ M.     *     * Nilpotent matrices will have a zero trace for all k     * https://en.wikipedia.org/wiki/Nilpotent_matrix     *     * @return boolean true if matrix is nilpotent; false otherwise     *     * @throws Exception\MathException     */    public function isNilpotent(): bool    {        if (!$this->isSquare() || $this->trace() !== 0) {            return false;        }        $m    = $this->getM();        $zero = MatrixFactory::zero($m, $m);        if ($this->isEqual($zero)) {            return true;        }        $A         = $this;        $nilpotent = false;        for ($i = 1; $i < $m; $i++) {            $A = $A->multiply($this);            if ($A->isEqual($zero)) {                $nilpotent = true;                break;            }            if ($A->trace() !== 0) {                break;            }        }        return $nilpotent;    }    /**     * Is the matrix involutory?     * A matrix that is its own inverse. That is, multiplication by matrix A is an involution if and only if A² = I     * https://en.wikipedia.org/wiki/Involutory_matrix     *     * @return boolean true if matrix is involutory; false otherwise     *     * @throws Exception\OutOfBoundsException     * @throws Exception\MathException     */    public function isInvolutory(): bool    {        $I  = MatrixFactory::identity($this->m);        $A² = $this->multiply($this);        return $A²->isEqual($I);    }    /**     * Is the matrix a signature matrix?     * A diagonal matrix whose diagonal elements are plus or minus 1.     * https://en.wikipedia.org/wiki/Signature_matrix     *     *     | ±1  0  0 |     * A = |  0 ±1  0 |     *     |  0  0 ±1 |     *     * @return boolean true if matrix is a signature matrix; false otherwise     */    public function isSignature(): bool    {        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                if ($i == $j) {                    if (!\in_array($this->A[$i][$j], [-1, 1])) {                        return false;                    }                } else {                    if ($this->A[$i][$j] != 0) {                        return false;                    }                }            }        }        return true;    }    /**     * Is the matrix upper bidiagonal?     *  - It is a square matrix     *  - Non-zero entries allowed along the main diagonal     *  - Non-zero entries allowed along the diagonal above the main diagonal     *  - All the other entries are zero     *     * https://en.wikipedia.org/wiki/Bidiagonal_matrix     *     * @return boolean true if upper bidiagonal; false otherwise     */    public function isUpperBidiagonal(): bool    {        if (!$this->isSquare() || !$this->isUpperTriangular()) {            return false;        }        $m = $this->m;        $n = $this->n;        // Elements above upper diagonal are zero        for ($i = 0; $i < $m; $i++) {            for ($j = $i + 2; $j < $n; $j++) {                if ($this->A[$i][$j] != 0) {                    return false;                }            }        }        return true;    }    /**     * Is the matrix lower bidiagonal?     *  - It is a square matrix     *  - Non-zero entries allowed along the main diagonal     *  - Non-zero entries allowed along the diagonal below the main diagonal     *  - All the other entries are zero     *     * https://en.wikipedia.org/wiki/Bidiagonal_matrix     *     * @return boolean true if lower bidiagonal; false otherwise     */    public function isLowerBidiagonal(): bool    {        if (!$this->isSquare() || !$this->isLowerTriangular()) {            return false;        }        // Elements below lower diagonal are non-zero        for ($i = 2; $i < $this->m; $i++) {            for ($j = 0; $j < $i - 1; $j++) {                if ($this->A[$i][$j] != 0) {                    return false;                }            }        }        return true;    }    /**     * Is the matrix bidiagonal?     *  - It is a square matrix     *  - Non-zero entries along the main diagonal     *  - Non-zero entries along either the diagonal above or the diagonal below the main diagonal     *  - All the other entries are zero     *     * https://en.wikipedia.org/wiki/Bidiagonal_matrix     *     * @return boolean true if bidiagonal; false otherwise     */    public function isBidiagonal(): bool    {        return ($this->isUpperBidiagonal() || $this->isLowerBidiagonal());    }    /**     * Is the matrix tridiagonal?     *  - It is a square matrix     *  - Non-zero entries allowed along the main diagonal     *  - Non-zero entries allowed along the diagonal above the main diagonal     *  - Non-zero entries allowed along the diagonal below the main diagonal     *  - All the other entries are zero     *     *  - Is both upper and lower Hessenberg     *     * https://en.wikipedia.org/wiki/Tridiagonal_matrix     *     * @return boolean true if tridiagonal; false otherwise     */    public function isTridiagonal(): bool    {        if (!$this->isSquare()) {            return false;        }        if (!$this->isUpperHessenberg() || !$this->isLowerHessenberg()) {            return false;        }        return true;    }    /**     * Is the matrix upper Hessenberg?     *  - It is a square matrix     *  - Has zero entries below the first subdiagonal     *     * https://en.wikipedia.org/wiki/Hessenberg_matrix     *     * @return boolean true if upper Hessenberg; false otherwise     */    public function isUpperHessenberg(): bool    {        if (!$this->isSquare()) {            return false;        }        // Elements below lower diagonal are zero        for ($i = 2; $i < $this->m; $i++) {            for ($j = 0; $j < $i - 1; $j++) {                if ($this->A[$i][$j] != 0) {                    return false;                }            }        }        return true;    }    /**     * Is the matrix lower Hessenberg?     *  - It is a square matrix     *  - Has zero entries above the first subdiagonal     *     * https://en.wikipedia.org/wiki/Hessenberg_matrix     *     * @return boolean true if lower Hessenberg; false otherwise     */    public function isLowerHessenberg(): bool    {        if (!$this->isSquare()) {            return false;        }        // Elements above upper diagonal are zero        for ($i = 0; $i < $this->m; $i++) {            for ($j = $i + 2; $j < $this->n; $j++) {                if ($this->A[$i][$j] != 0) {                    return false;                }            }        }        return true;    }    /**     * Is the matrix orthogonal?     *  - It is a square matrix     *  - AAᵀ = AᵀA = I     *     * @return bool     *     * @throws Exception\MathException     */    public function isOrthogonal(): bool    {        if (!$this->isSquare()) {            return false;        }        // AAᵀ = I        $I   = MatrixFactory::identity($this->m);        $Aᵀ  = $this->transpose();        $AAᵀ = $this->multiply($Aᵀ);        return $AAᵀ->isEqual($I);    }    /**     * Is the matrix normal?     *  - It is a square matrix     *  - AAᴴ = AᴴA     *     * https://en.wikipedia.org/wiki/Normal_matrix     * @return bool     *     * @throws Exception\MathException     */    public function isNormal(): bool    {        if (!$this->isSquare()) {            return false;        }        // AAᴴ = AᴴA        $Aᴴ  = $this->conjugateTranspose();        $AAᴴ = $this->multiply($Aᴴ);        $AᴴA = $Aᴴ->multiply($this);        return $AAᴴ->isEqual($AᴴA);    }    /**     * Is the matrix unitary?     *  - It is a square matrix     *  - AAᴴ = AᴴA = I     *     * https://en.wikipedia.org/wiki/Unitary_matrix     * @return bool     *     * @throws Exception\MathException     */    public function isUnitary(): bool    {        if (!$this->isSquare()) {            return false;        }        // AAᴴ = AᴴA = I        $Aᴴ  = $this->conjugateTranspose();        $AAᴴ = $this->multiply($Aᴴ);        $AᴴA = $Aᴴ->multiply($this);        $I = MatrixFactory::identity($this->m);        return $AAᴴ->isEqual($AᴴA) && $AAᴴ->isEqual($I);    }    /**     * Is the matrix Hermitian?     *  - It is a square matrix     *  - A = Aᴴ     *     * https://en.wikipedia.org/wiki/Hermitian_matrix     * @return bool     *     * @throws Exception\MathException     */    public function isHermitian(): bool    {        if (!$this->isSquare()) {            return false;        }        // A = Aᴴ        $Aᴴ  = $this->conjugateTranspose();        return $this->isEqual($Aᴴ);    }    /**************************************************************************     * MATRIX AUGMENTATION - Return a Matrix     *  - augmentIdentity     **************************************************************************/    /**     * Augment a matrix with its identity matrix     *     *     [1, 2, 3]     * C = [2, 3, 4]     *     [3, 4, 5]     *     *         [1, 2, 3 | 1, 0, 0]     * (C|I) = [2, 3, 4 | 0, 1, 0]     *         [3, 4, 5 | 0, 0, 1]     *     * C must be a square matrix     *     * @return NumericMatrix     *     * @throws Exception\MatrixException if matrix is not square     * @throws Exception\IncorrectTypeException     * @throws Exception\OutOfBoundsException     */    public function augmentIdentity(): NumericMatrix    {        if (!$this->isSquare()) {            throw new Exception\MatrixException('Matrix is not square; cannot augment with the identity matrix');        }        return $this->augment(MatrixFactory::identity($this->getM()));    }    /**************************************************************************     * MATRIX ARITHMETIC OPERATIONS - Return a Matrix     *  - add     *  - directSum     *  - kroneckerSum     *  - subtract     *  - multiply     *  - scalarMultiply     *  - scalarDivide     *  - hadamardProduct     *  - kroneckerProduct     **************************************************************************/    /**     * Add two matrices - Entrywise sum     * Adds each element of one matrix to the same element in the other matrix.     * Returns a new matrix.     * https://en.wikipedia.org/wiki/Matrix_addition#Entrywise_sum     *     * @param NumericMatrix $B Matrix to add to this matrix     *     * @return NumericMatrix     *     * @throws Exception\MatrixException if matrices have a different number of rows or columns     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     */    public function add($B): NumericMatrix    {        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices have different number of rows');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices have different number of columns');        }        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] + $B[$i][$j];            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }    /**     * Direct sum of two matrices: A ⊕ B     * The direct sum of any pair of matrices A of size m × n and B of size p × q     * is a matrix of size (m + p) × (n + q)     * https://en.wikipedia.org/wiki/Matrix_addition#Direct_sum     *     * @param  NumericMatrix $B Matrix to add to this matrix     *     * @return NumericMatrix     *     * @throws Exception\IncorrectTypeException     */    public function directSum(NumericMatrix $B): NumericMatrix    {        $m = $this->m + $B->getM();        $n = $this->n + $B->getN();        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 0;            }        }        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j];            }        }        $m = $B->getM();        $n = $B->getN();        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i + $this->m][$j + $this->n] = $B[$i][$j];            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }    /**     * Kronecker Sum (A⊕B)     * A⊕B = A⊗Ib + I⊗aB     * Where A and B are square matrices, Ia and Ib are identity matrixes,     * and ⊗ is the Kronecker product.     *     * https://en.wikipedia.org/wiki/Matrix_addition#Kronecker_sum     * http://mathworld.wolfram.com/KroneckerSum.html     *     * @param NumericMatrix $B Square matrix     *     * @return NumericMatrix     *     * @throws Exception\MatrixException if either matrix is not a square matrix     * @throws Exception\OutOfBoundsException     * @throws Exception\IncorrectTypeException     * @throws Exception\BadDataException     */    public function kroneckerSum(NumericMatrix $B): NumericMatrix    {        if (!$this->isSquare() || !$B->isSquare()) {            throw new Exception\MatrixException('Matrices A and B must both be square for kroneckerSum');        }        $A  = $this;        $m  = $B->getM();        $n  = $this->n;        $In = MatrixFactory::identity($n);        $Im = MatrixFactory::identity($m);        $A⊗Im = $A->kroneckerProduct($Im);        $In⊗B = $In->kroneckerProduct($B);        $A⊕B  = $A⊗Im->add($In⊗B);        return $A⊕B;    }    /**     * Subtract two matrices - Entrywise subtraction     * Adds each element of one matrix to the same element in the other matrix.     * Returns a new matrix.     * https://en.wikipedia.org/wiki/Matrix_addition#Entrywise_sum     *     * @param NumericMatrix $B Matrix to subtract from this matrix     *     * @return NumericMatrix     *     * @throws Exception\MatrixException if matrices have a different number of rows or columns     * @throws Exception\IncorrectTypeException     */    public function subtract($B): NumericMatrix    {        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices have different number of rows');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices have different number of columns');        }        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] - $B[$i][$j];            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }    /**     * Matrix multiplication - ijk algorithm using cache-oblivious algorithm optimization     * https://en.wikipedia.org/wiki/Matrix_multiplication     * https://en.wikipedia.org/wiki/Cache-oblivious_algorithm     *     * Gene H. Golub and Charles F. Van Loan (2013). ""Matrix Computations 4th Edition",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
markrogoyski_math-php_NumericMatrix_2713, Validate the matrix is entirely m x n\\n\\n @throws Exception\\\\BadDataException\\n, Validate the matrix is entirely m x n,"    protected function validateMatrixDimensions()    {        foreach ($this->A as $i => $row) {            if (\count($row) !== $this->n) {                throw new Exception\BadDataException(""Row $i has a different column count: "" . \count($row) . ""; was expecting {$this->n}."");            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2714, Get the type of objects that are stored in the matrix\\n\\n @return string The class of the objects\\n, Get the type of objects that are stored in the matrix,    public function getObjectType(): string    {        return 'number';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2715, Get error / zero tolerance\\n @return float\\n, Get error / zero tolerance,    public function getError(): float    {        return $this->ε;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2718, Is the matrix symmetric?\n Does A = Aᵀ\n aᵢⱼ = aⱼᵢ\n\n Algorithm: Iterate on the upper triangular half and compare with corresponding\n values on the lower triangular half. Skips the diagonal as it is symmetric with itself.\n\n @return bool true if symmetric; false otherwise.\n\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MatrixException\n, Is the matrix symmetric?,"    public function isSymmetric(): bool    {        if (!$this->isSquare()) {            return false;        }        for ($i = 0; $i < $this->m - 1; $i++) {            for ($j = $i + 1; $j < $this->n; $j++) {                if (Support::isNotEqual($this->A[$i][$j], $this->A[$j][$i], $this->ε)) {                    return false;                }            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2721," Is the matrix nonsingular? (Regular matrix)\\n A square matrix that is not singular. It has an inverse.\\n If the determinant is nonzero, then the matrix is nonsingular.\\n http://mathworld.wolfram.com/NonsingularMatrix.html\\n\\n @return bool true if nonsingular; false otherwise.\\n\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\BadParameterException\\n", Is the matrix nonsingular? (Regular matrix),"    public function isNonsingular(): bool    {        $│A│ = $this->det();        if (Support::isNotZero($│A│, $this->ε)) {            return true;        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2724, Is the matrix positive semidefinite?\n  - It is square and symmetric.\n  - All principal minors have positive determinants (≥ 0)\n\n http://mathworld.wolfram.com/PositiveSemidefiniteMatrix.html\n\n @return boolean true if positive semidefinite; false otherwise\n\n @throws Exception\\MatrixException\n @throws Exception\\OutOfBoundsException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\BadParameterException\n, Is the matrix positive semidefinite?,    public function isPositiveSemidefinite(): bool    {        if (!$this->isSymmetric()) {            return false;        }        for ($i = 1; $i <= $this->n; $i++) {            if ($this->leadingPrincipalMinor($i)->det() < 0) {                return false;            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2727, Is the matrix lower triangular?\\n  - It is a square matrix\\n  - All the entries above the main diagonal are zero\\n\\n https://en.wikipedia.org/wiki/Triangular_matrix\\n\\n @return boolean true if lower triangular; false otherwise\\n, Is the matrix lower triangular?,    public function isLowerTriangular(): bool    {        if (!$this->isSquare()) {            return false;        }        $m = $this->m;        $n = $this->n;        for ($i = 0; $i < $m; $i++) {            for ($j = $i + 1; $j < $n; $j++) {                if (!Support::isZero($this->A[$i][$j])) {                    return false;                }            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2729, Is the matrix triangular?\n The matrix is either lower or upper triangular\n\n https://en.wikipedia.org/wiki/Triangular_matrix\n\n @return boolean true if triangular; false otherwise\n, Is the matrix triangular?,    public function isTriangular(): bool    {        return ($this->isLowerTriangular() || $this->isUpperTriangular());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2730, Is the matrix diagonal?\n  - It is a square matrix\n  - All the entries above the main diagonal are zero\n  - All the entries below the main diagonal are zero\n\n http://mathworld.wolfram.com/DiagonalMatrix.html\n\n @return boolean true if diagonal; false otherwise\n, Is the matrix diagonal?,    public function isDiagonal(): bool    {        return ($this->isLowerTriangular() && $this->isUpperTriangular());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2733, Is the matrix in reduced row echelon form?\\n  - It is in row echelon form\\n  - Leading coefficients are 1\\n  - Leading coefficients are the only nonzero entry in its column\\n\\n https://en.wikipedia.org/wiki/Row_echelon_form\\n\\n @return boolean true if matrix is in reduced row echelon form; false otherwise\\n\\n @throws Exception\\\\MatrixException\\n, Is the matrix in reduced row echelon form?,    public function isRref(): bool    {        // Row echelon form        if (!$this->isRef()) {            return false;        }        $m   = $this->m;        $n   = $this->n;        $lcs = [];        // Leading coefficients are 1        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if ($this->A[$i][$j] == 0) {                    continue;                }                if ($this->A[$i][$j] != 1) {                    return false;                }                $lcs[] = $j;                continue 2;            }        }        // Leading coefficients are the only nonzero entry in its column        foreach ($lcs as $j) {            $column  = $this->getColumn($j);            $entries = \array_filter($column);            if (\count($entries) !== 1) {                return false;            }            $entry = \array_shift($entries);            if ($entry != 1) {                return false;            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2735, Is the matrix nilpotent?\n\n A square MxM matrix is nilpotent if it becomes the\n zero matrix when raised to some power k ≤ M.\n\n Nilpotent matrices will have a zero trace for all k\n https://en.wikipedia.org/wiki/Nilpotent_matrix\n\n @return boolean true if matrix is nilpotent; false otherwise\n\n @throws Exception\\MathException\n, Is the matrix nilpotent?,"    public function isNilpotent(): bool    {        if (!$this->isSquare() || $this->trace() !== 0) {            return false;        }        $m    = $this->getM();        $zero = MatrixFactory::zero($m, $m);        if ($this->isEqual($zero)) {            return true;        }        $A         = $this;        $nilpotent = false;        for ($i = 1; $i < $m; $i++) {            $A = $A->multiply($this);            if ($A->isEqual($zero)) {                $nilpotent = true;                break;            }            if ($A->trace() !== 0) {                break;            }        }        return $nilpotent;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2739, Is the matrix lower bidiagonal?\\n  - It is a square matrix\\n  - Non-zero entries allowed along the main diagonal\\n  - Non-zero entries allowed along the diagonal below the main diagonal\\n  - All the other entries are zero\\n\\n https://en.wikipedia.org/wiki/Bidiagonal_matrix\\n\\n @return boolean true if lower bidiagonal; false otherwise\\n, Is the matrix lower bidiagonal?,    public function isLowerBidiagonal(): bool    {        if (!$this->isSquare() || !$this->isLowerTriangular()) {            return false;        }        // Elements below lower diagonal are non-zero        for ($i = 2; $i < $this->m; $i++) {            for ($j = 0; $j < $i - 1; $j++) {                if ($this->A[$i][$j] != 0) {                    return false;                }            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2740, Is the matrix bidiagonal?\n  - It is a square matrix\n  - Non-zero entries along the main diagonal\n  - Non-zero entries along either the diagonal above or the diagonal below the main diagonal\n  - All the other entries are zero\n\n https://en.wikipedia.org/wiki/Bidiagonal_matrix\n\n @return boolean true if bidiagonal; false otherwise\n, Is the matrix bidiagonal?,    public function isBidiagonal(): bool    {        return ($this->isUpperBidiagonal() || $this->isLowerBidiagonal());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2742, Is the matrix upper Hessenberg?\n  - It is a square matrix\n  - Has zero entries below the first subdiagonal\n\n https://en.wikipedia.org/wiki/Hessenberg_matrix\n\n @return boolean true if upper Hessenberg; false otherwise\n, Is the matrix upper Hessenberg?,    public function isUpperHessenberg(): bool    {        if (!$this->isSquare()) {            return false;        }        // Elements below lower diagonal are zero        for ($i = 2; $i < $this->m; $i++) {            for ($j = 0; $j < $i - 1; $j++) {                if ($this->A[$i][$j] != 0) {                    return false;                }            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2743, Is the matrix lower Hessenberg?\n  - It is a square matrix\n  - Has zero entries above the first subdiagonal\n\n https://en.wikipedia.org/wiki/Hessenberg_matrix\n\n @return boolean true if lower Hessenberg; false otherwise\n, Is the matrix lower Hessenberg?,    public function isLowerHessenberg(): bool    {        if (!$this->isSquare()) {            return false;        }        // Elements above upper diagonal are zero        for ($i = 0; $i < $this->m; $i++) {            for ($j = $i + 2; $j < $this->n; $j++) {                if ($this->A[$i][$j] != 0) {                    return false;                }            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2745, Is the matrix normal?\n  - It is a square matrix\n  - AAᴴ = AᴴA\n\n https://en.wikipedia.org/wiki/Normal_matrix\n @return bool\n\n @throws Exception\\MathException\n, Is the matrix normal?,    public function isNormal(): bool    {        if (!$this->isSquare()) {            return false;        }        // AAᴴ = AᴴA        $Aᴴ  = $this->conjugateTranspose();        $AAᴴ = $this->multiply($Aᴴ);        $AᴴA = $Aᴴ->multiply($this);        return $AAᴴ->isEqual($AᴴA);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2747, Is the matrix Hermitian?\\n  - It is a square matrix\\n  - A = Aᴴ\\n\\n https://en.wikipedia.org/wiki/Hermitian_matrix\\n @return bool\\n\\n @throws Exception\\\\MathException\\n, Is the matrix Hermitian?,    public function isHermitian(): bool    {        if (!$this->isSquare()) {            return false;        }        // A = Aᴴ        $Aᴴ  = $this->conjugateTranspose();        return $this->isEqual($Aᴴ);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2748," Augment a matrix with its identity matrix\\n\\n     [1, 2, 3]\\n C = [2, 3, 4]\\n     [3, 4, 5]\\n\\n         [1, 2, 3 | 1, 0, 0]\\n (C|I) = [2, 3, 4 | 0, 1, 0]\\n         [3, 4, 5 | 0, 0, 1]\\n\\n C must be a square matrix\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\MatrixException if matrix is not square\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\OutOfBoundsException\\n", Augment a matrix with its identity matrix,    public function augmentIdentity(): NumericMatrix    {        if (!$this->isSquare()) {            throw new Exception\MatrixException('Matrix is not square; cannot augment with the identity matrix');        }        return $this->augment(MatrixFactory::identity($this->getM()));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2749, Add two matrices - Entrywise sum\n Adds each element of one matrix to the same element in the other matrix.\n Returns a new matrix.\n https://en.wikipedia.org/wiki/Matrix_addition#Entrywise_sum\n\n @param NumericMatrix $B Matrix to add to this matrix\n\n @return NumericMatrix\n\n @throws Exception\\MatrixException if matrices have a different number of rows or columns\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MathException\n, Add two matrices - Entrywise sum,"    public function add($B): NumericMatrix    {        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices have different number of rows');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices have different number of columns');        }        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] + $B[$i][$j];            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2752, Subtract two matrices - Entrywise subtraction\\n Adds each element of one matrix to the same element in the other matrix.\\n Returns a new matrix.\\n https://en.wikipedia.org/wiki/Matrix_addition#Entrywise_sum\\n\\n @param NumericMatrix $B Matrix to subtract from this matrix\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\MatrixException if matrices have a different number of rows or columns\\n @throws Exception\\\\IncorrectTypeException\\n, Subtract two matrices - Entrywise subtraction,"    public function subtract($B): NumericMatrix    {        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices have different number of rows');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices have different number of columns');        }        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] - $B[$i][$j];            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2755, Negate a matrix\\n −A = −1A\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n, Negate a matrix,    public function negate(): NumericMatrix    {        return $this->scalarMultiply(-1);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2762," Mean deviation matrix\\n Matrix as an array of column vectors, where rows represent variables and columns represent samples.\\n Each column vector is subtracted by the sample mean.\\n\\n Example:\\n      [1  4 7 8]      [5]\\n  A = [2  2 8 4]  M = [4]\\n      [1 13 1 5]      [5]\\n\\n      |[1] - [5]   [4]  - [5]   [7] - [5]   [8] - [5]|\\n  B = |[2] - [4]   [2]  - [4]   [8] - [4]   [4] - [4]|\\n      |[1] - [5]   [13] - [5]   [1] - [5]   [5] - [5]|\\n\\n      [-4 -1  2 3]\\n  B = [-2 -2  4 0]\\n      [-2  8 -4 0]\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\IncorrectTypeException\\n", Mean deviation matrix,"    public function meanDeviationOfRowVariables(): NumericMatrix    {        $X = $this->asVectors();        $M = $this->rowMeans();        /** @var Vector[] $B */        $B = \array_map(            function (Vector $Xᵢ) use ($M) {                return $Xᵢ->subtract($M);            },            $X        );        return MatrixFactory::createFromVectors($B, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2763," Mean deviation matrix\n Matrix as an array of row vectors, where columns represent variables and rows represent samples.\n Each row vector is subtracted by the sample mean.\n\n Example:\n      [1  4 7 8]      [5]\n  A = [2  2 8 4]  M = [4]\n      [1 13 1 5]      [5]\n\n  M = [4/3, 19/3, 16/3, 17/3]\n\n      |[1] - [4/3]  [4] - [19/3]  7 - [16/3]  [8] - [17/3]|\n  B = |[2] - [4/3]  [2] - [19/3]  8 - [16/3]  [4] - [17/3]|\n      |[1] - [4/3] [13] - [19/3]  1 - [16/3]  [5] - [17/3]|\n\n      [-1/3  -2.33   1.66  2.33]\n  B = [2/3   -4.33   2.66 -1.66]\n      [-1/3   6.66  -4.33  -2/3]\n\n @return NumericMatrix\n\n @throws Exception\\IncorrectTypeException\n", Mean deviation matrix,"    public function meanDeviationOfColumnVariables(): NumericMatrix    {        $X = $this->asRowVectors();        $M = $this->columnMeans();        /** @var Vector[] $B */        $B = \array_map(            function (Vector $Xᵢ) use ($M) {                return $Xᵢ->subtract($M);            },            $X        );        return MatrixFactory::createFromVectors($B, $this->ε)->transpose();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2764," Covariance matrix (variance-covariance matrix, sample covariance matrix)\n where rows represent variables and columns represent samples\n https://en.wikipedia.org/wiki/Covariance_matrix\n https://en.wikipedia.org/wiki/Sample_mean_and_covariance\n\n       1\n S = ----- BBᵀ\n     N - 1\n\n  where B is the mean-deviation form\n\n Uses mathematical convention where matrix columns represent observation vectors.\n Follows formula and method found in Linear Algebra and Its Applications (Lay).\n\n @return NumericMatrix\n\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MatrixException\n @throws Exception\\BadParameterException\n @throws Exception\\VectorException\n"," Covariance matrix (variance-covariance matrix, sample covariance matrix)",    protected function covarianceMatrixOfRowVariables(): NumericMatrix    {        $n  = $this->n;        $B  = $this->meanDeviationOfRowVariables();        $Bᵀ = $B->transpose();        $S = $B->multiply($Bᵀ)->scalarMultiply((1 / ($n - 1)));        return $S;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2765," Covariance matrix (variance-covariance matrix, sample covariance matrix)\\n where columns represent variables and rows represent samples\\n https://en.wikipedia.org/wiki/Covariance_matrix\\n https://en.wikipedia.org/wiki/Sample_mean_and_covariance\\n\\n       1\\n S = ----- BᵀB\\n     N - 1\\n\\n  where B is the mean-deviation form\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\VectorException\\n"," Covariance matrix (variance-covariance matrix, sample covariance matrix)",    protected function covarianceMatrixOfColumnVariables(): NumericMatrix    {        $n  = $this->m;        $B  = $this->meanDeviationOfColumnVariables();        $Bᵀ = $B->transpose();        $S = $Bᵀ->multiply($B)->scalarMultiply((1 / ($n - 1)));        return $S;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2772," Means of each column, returned as a Vector\\n https://en.wikipedia.org/wiki/Sample_mean_and_covariance\\n\\n     1\\n M = - (X₁ + X₂ + ⋯ + Xn)\\n     m\\n\\n Example:\\n      [1  4 7 8]\\n  A = [2  2 8 4]\\n      [1 13 1 5]\\n\\n  Consider each row of observations as a row vector:\\n\\n   X₁ = [1  4 7 9]\\n   X₂ = [2  2 8 4]\\n   X₃ = [1 13 1 5]\\n\\n   1  /  1    4    7    9  \\\\      1\\n   - |  +2   +2   +8   +4   |  =  - [4  19  16  18]  =  [1⅓, 6⅓, 5⅓, 5.⅔]\\n   3  \\\\ +1  +13   +1   +5  /      3\\n\\n @return Vector\\n"," Means of each column, returned as a Vector","    public function columnMeans(): Vector    {        $m = $this->m;        $n = $this->n;        $means = [];        for ($i = 0; $i < $n; $i++) {            $means[] = \array_sum(\array_column($this->A, $i)) / $m;        }        return new Vector($means);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2775," Frobenius norm (Hilbert–Schmidt norm, Euclidean norm) (‖A‖F)\n Square root of the sum of the square of all elements.\n\n https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm\n\n          _____________\n         /ᵐ   ⁿ\n ‖A‖F = √ Σ   Σ  |aᵢⱼ|²\n         ᵢ₌₁ ᵢ₌₁\n\n @return number\n"," Frobenius norm (Hilbert–Schmidt norm, Euclidean norm) (‖A‖F)",    public function frobeniusNorm()    {        $m      = $this->m;        $n      = $this->n;        $ΣΣaᵢⱼ² = 0;        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $ΣΣaᵢⱼ² += ($this->A[$i][$j]) ** 2;            }        }        return \sqrt($ΣΣaᵢⱼ²);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2776, Infinity norm (‖A‖∞)\n Maximum absolute row sum of the matrix\n\n @return number\n, Infinity norm (‖A‖∞),"    public function infinityNorm()    {        $m = $this->m;        $‖A‖∞ = \array_sum(Map\Single::abs($this->A[0]));        for ($i = 1; $i < $m; $i++) {            $‖A‖∞ = \max($‖A‖∞, \array_sum(Map\Single::abs($this->A[$i])));        }        return $‖A‖∞;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2778, Determinant\\n\\n For a 1x1 matrix:\\n  A = [a]\\n\\n |A| = a\\n\\n For a 2x2 matrix:\\n      [a b]\\n  A = [c d]\\n\\n │A│ = ad - bc\\n\\n For a 3x3 matrix:\\n      [a b c]\\n  A = [d e f]\\n      [g h i]\\n\\n │A│ = a(ei - fh) - b(di - fg) + c(dh - eg)\\n\\n For 4x4 and larger matrices:\\n\\n │A│ = (-1)ⁿ │ref(A)│\\n\\n  where:\\n   │ref(A)│ = determinant of the row echelon form of A\\n   ⁿ        = number of row swaps when computing REF\\n\\n @return number\\n\\n @throws Exception\\\\MatrixException if matrix is not square\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\BadParameterException\\n, Determinant,"    public function det()    {        if ($this->catalog->hasDeterminant()) {            return $this->catalog->getDeterminant();        }        if (!$this->isSquare()) {            throw new Exception\MatrixException('Not a square matrix (required for determinant)');        }        $m = $this->m;        $R = MatrixFactory::create($this->A);        /*         * 1x1 matrix         *  A = [a]         *         * |A| = a         */        if ($m === 1) {            $det = $R[0][0];            $this->catalog->addDeterminant($det);            return $det;        }        /*         * 2x2 matrix         *      [a b]         *  A = [c d]         *         * |A| = ad - bc         */        if ($m === 2) {            $a = $R[0][0];            $b = $R[0][1];            $c = $R[1][0];            $d = $R[1][1];            $ad = $a * $d;            $bc = $b * $c;            $det = $ad - $bc;            $this->catalog->addDeterminant($det);            return $det;        }        /*         * 3x3 matrix         *      [a b c]         *  A = [d e f]         *      [g h i]         *         * |A| = a(ei - fh) - b(di - fg) + c(dh - eg)         */        if ($m === 3) {            $a = $R[0][0];            $b = $R[0][1];            $c = $R[0][2];            $d = $R[1][0];            $e = $R[1][1];            $f = $R[1][2];            $g = $R[2][0];            $h = $R[2][1];            $i = $R[2][2];            $ei = $e * $i;            $fh = $f * $h;            $di = $d * $i;            $fg = $f * $g;            $dh = $d * $h;            $eg = $e * $g;            $det = $a * ($ei - $fh) - $b * ($di - $fg) + $c * ($dh - $eg);            $this->catalog->addDeterminant($det);            return $det;        }        /*         * nxn matrix 4x4 or larger         * Get row echelon form, then compute determinant of ref.         * Then plug into formula with swaps.         * │A│ = (-1)ⁿ │ref(A)│         */        $ref⟮A⟯ = $this->ref();        $ⁿ     = $ref⟮A⟯->getRowSwaps();        // Det(ref(A))        $│ref⟮A⟯│ = 1;        for ($i = 0; $i < $m; $i++) {            $│ref⟮A⟯│ *= $ref⟮A⟯[$i][$i];        }        // │A│ = (-1)ⁿ │ref(A)│        $det = (-1) ** $ⁿ * $│ref⟮A⟯│;        $this->catalog->addDeterminant($det);        return $det;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2781, Multiply a row by a factor k\\n\\n Each element of Row mᵢ will be multiplied by k\\n\\n @param int   $mᵢ Row to multiply\\n @param float $k Multiplier\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\MatrixException if row to multiply does not exist\\n @throws Exception\\\\IncorrectTypeException\\n, Multiply a row by a factor k,"    public function rowMultiply(int $mᵢ, float $k): NumericMatrix    {        if ($mᵢ >= $this->m) {            throw new Exception\MatrixException('Row to multiply does not exist');        }        $n = $this->n;        $R = $this->A;        for ($j = 0; $j < $n; $j++) {            $R[$mᵢ][$j] *= $k;        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2782, Divide a row by a divisor k\n\n Each element of Row mᵢ will be divided by k\n\n @param int   $mᵢ Row to multiply\n @param float $k divisor\n\n @return NumericMatrix\n\n @throws Exception\\MatrixException if row to multiply does not exist\n @throws Exception\\BadParameterException if k is 0\n @throws Exception\\IncorrectTypeException\n, Divide a row by a divisor k,"    public function rowDivide(int $mᵢ, float $k): NumericMatrix    {        if ($mᵢ >= $this->m) {            throw new Exception\MatrixException('Row to multiply does not exist');        }        if ($k == 0) {            throw new Exception\BadParameterException('Divisor k must not be 0');        }        $n = $this->n;        $R = $this->A;        for ($j = 0; $j < $n; $j++) {            $R[$mᵢ][$j] /= $k;        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2785, Subtract k times row mᵢ to row mⱼ\n\n @param int   $mᵢ Row to multiply  @param int   $mⱼ Row that will have row mⱼ  @param float $k Multiplier\n\n @return NumericMatrix\n\n @throws Exception\\MatrixException if row to subtract does not exist\n @throws Exception\\IncorrectTypeException\n, Subtract k times row mᵢ to row mⱼ,"    public function rowSubtract(int $mᵢ, int $mⱼ, float $k): NumericMatrix    {        if ($mᵢ >= $this->m || $mⱼ >= $this->m) {            throw new Exception\MatrixException('Row to subtract does not exist');        }        $n = $this->n;        $R = $this->A;        for ($j = 0; $j < $n; $j++) {            $R[$mⱼ][$j] -= $R[$mᵢ][$j] * $k;        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2787, Multiply a column by a factor k\\n\\n Each element of column nᵢ will be multiplied by k\\n\\n @param int   $nᵢ Column to multiply\\n @param float $k Multiplier\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\MatrixException if column to multiply does not exist\\n @throws Exception\\\\IncorrectTypeException\\n, Multiply a column by a factor k,"    public function columnMultiply(int $nᵢ, float $k): NumericMatrix    {        if ($nᵢ >= $this->n) {            throw new Exception\MatrixException('Column to multiply does not exist');        }        $m = $this->m;        $R = $this->A;        for ($i = 0; $i < $m; $i++) {            $R[$i][$nᵢ] *= $k;        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2791, LU Decomposition (Doolittle decomposition) with pivoting via permutation matrix\\n\\n A = LU(P)\\n\\n L: Lower triangular matrix--all entries above the main diagonal are zero.\\n    The main diagonal will be all ones.\\n U: Upper tirangular matrix--all entries below the main diagonal are zero.\\n P: Permutation matrix--Identity matrix with possible rows interchanged.\\n\\n @return Decomposition\\\\LU\\n\\n @throws Exception\\\\MatrixException if matrix is not square\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\OutOfBoundsException\\n @throws Exception\\\\VectorException\\n, LU Decomposition (Doolittle decomposition) with pivoting via permutation matrix,    public function luDecomposition(): Decomposition\LU    {        if (!$this->catalog->hasLuDecomposition()) {            $this->catalog->addLuDecomposition(Decomposition\LU::decompose($this));        }        return $this->catalog->getLuDecomposition();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2794," Crout decomposition\\n\\n Decomposes a matrix into a lower triangular matrix (L), an upper triangular matrix (U).\\n\\n A = LU where L = LD\\n A = (LD)U\\n  - L = lower triangular matrix\\n  - D = diagonal matrix\\n  - U = normalised upper triangular matrix\\n\\n @return Decomposition\\\\Crout\\n\\n @throws Exception\\\\MatrixException if there is division by 0 because of a 0-value determinant\\n @throws Exception\\\\OutOfBoundsException\\n @throws Exception\\\\IncorrectTypeException\\n", Crout decomposition,    public function croutDecomposition(): Decomposition\Crout    {        if (!$this->catalog->hasCroutDecomposition()) {            $this->catalog->addCroutDecomposition(Decomposition\Crout::decompose($this));        }        return $this->catalog->getCroutDecomposition();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2795," Solve Ax = b using RREF\n\n As an augmented matrix Ab, the RREF has the x solution to Ax = b as the rightmost column.\n\n Edge case: If the matrix is singular, there may be one or more rows of zeros at the bottom. This leads to\n the ones not being on the diagonal. In this case, the rightmost column will not have the values in the correct\n order. To deal with this, we look at where the ones are and reorder the column vector.\n\n @param Vector $b\n @return Vector\n", Solve Ax = b using RREF,"    private function solveRref(Vector $b): Vector    {        $Ab   = $this->augment($b->asColumnMatrix());        $rref = $Ab->rref();        // Edge case if singular matrix        if ($this->isSingular()) {            $x = [];            $i = 0;            $j = 0;            while ($i < $this->m && $j < $this->n) {                if ($rref[$i][$j] == 1) {                    $x[] = $rref[$i][$this->n];                    $i++;                    $j++;                } else {                    $x[] = 0;                    $j++;                }            }            return new Vector($x);        }        // Standard case - rightmost column is the solution        return new Vector(\array_column($rref->getMatrix(), $rref->getN() - 1));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericalDifferentiation_3009, Evaluate our callback function at n evenly spaced points on the interval\n between start and end\n\n @param  callable $function f(x) callback function\n @param  number   $start    the start of the interval\n @param  number   $end      the end of the interval\n @param  number   $n        the number of function evaluations\n\n @return array[]\n, Evaluate our callback function at n evenly spaced points on the interval,"    protected static function functionToPoints(callable $function, $start, $end, $n): array    {        $points = [];        $h      = ($end - $start) / ($n - 1);        for ($i = 0; $i < $n; $i++) {            $xᵢ         = $start + $i * $h;            $f⟮xᵢ⟯       = $function($xᵢ);            $points[$i] = [$xᵢ, $f⟮xᵢ⟯];        }        return $points;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericalDifferentiation_3010," Validate that there are a set number of input arrays (points), that each point array\\n has precisely two numbers, and that no two points share the same first number\\n (x-component)\\n\\n @param  array $points Array of arrays (points)\\n @param  int   $degree The number of input arrays\\n\\n @throws Exception\\\\BadDataException if there are not enough input arrays\\n @throws Exception\\\\BadDataException if any point does not contain two numbers\\n @throws Exception\\\\BadDataException if two points share the same first number (x-component)\\n"," Validate that there are a set number of input arrays (points), that each point array","    public static function validate(array $points, int $degree)    {        if (\count($points) != $degree) {            throw new Exception\BadDataException(""You need to have $degree sets of coordinates (arrays) for this technique"");        }        $x_coordinates = [];        foreach ($points as $point) {            if (\count($point) !== 2) {                throw new Exception\BadDataException('Each array needs to have have precisely two numbers, an x- and y-component');            }            $x_component = $point[self::X];            if (\in_array($x_component, $x_coordinates)) {                throw new Exception\BadDataException('Not a function. Your input array contains more than one coordinate with the same x-component.');            }            $x_coordinates[] = $x_component;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericalDifferentiation_3011, Sorts our coordinates (arrays) by their x-component (first number) such\n that consecutive coordinates have an increasing x-component.\n\n @param array[] $points\n\n @return array[]\n, Sorts our coordinates (arrays) by their x-component (first number) such,"    protected static function sort(array $points): array    {        \usort($points, function ($a, $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericalDifferentiation_3012," Ensures that the length of each subinterval is equal, or equivalently,\n that the spacing between each point is equal\n\n @param  array[] $sorted Points sorted by (increasing) x-component\n\n @throws Exception\\BadDataException if the spacing between any two points is not equal\n         to the average spacing between every point\n"," Ensures that the length of each subinterval is equal, or equivalently,",    public static function isSpacingConstant(array $sorted)    {        $x       = self::X;        $length  = \count($sorted);        $spacing = ($sorted[$length - 1][$x] - $sorted[0][$x]) / ($length - 1);        for ($i = 1; $i < $length - 1; $i++) {            if ($sorted[$i + 1][$x] - $sorted[$i][$x] !== $spacing) {                throw new Exception\BadDataException('The size of each subinterval must be the same. Provide points with constant spacing.');            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericalDifferentiation_3013, Ensures that our target is the x-component of one of the points we supply\\n\\n @param  number $target The value at which we are approximating the derivative\\n @param  array  $sorted Points sorted by (increasing) x-component\\n\\n @throws Exception\\\\BadDataException if $target is not contained in the array of our x-components\\n, Ensures that our target is the x-component of one of the points we supply,"    public static function isTargetInPoints($target, array $sorted)    {        $xComponents = \array_map(            function (array $point) {                return $point[self::X];            },            $sorted        );        if (!\in_array($target, $xComponents)) {            throw new Exception\BadDataException('Your target point must be the x-component of one of the points you supplied.');        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericalIntegration_3023, Evaluate our callback function at n evenly spaced points on the interval between start and end\n\n @param  callable $function f(x) callback function\n @param  float    $start    the start of the interval\n @param  float    $end      the end of the interval\n @param  int      $n        the number of function evaluations\n\n @return array\n, Evaluate our callback function at n evenly spaced points on the interval between start and end,"    protected static function functionToPoints(callable $function, float $start, float $end, int $n): array    {        $points = [];        $h      = ($end - $start) / ($n - 1);        for ($i = 0; $i < $n; $i++) {            $xᵢ         = $start + $i * $h;            $f⟮xᵢ⟯       = $function($xᵢ);            $points[$i] = [$xᵢ, $f⟮xᵢ⟯];        }        return $points;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ObjectMatrix_2803, Get the type of objects that are stored in the matrix\\n\\n @return string The class of the objects\\n, Get the type of objects that are stored in the matrix,    public function getObjectType(): string    {        return $this->object_type;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ObjectMatrix_2805, Is this matrix equal to some other matrix?\\n\\n @param Matrix $B\\n\\n @return bool\\n, Is this matrix equal to some other matrix?,    public function isEqual(Matrix $B): bool    {        if (!$this->isEqualSizeAndType($B)) {            return false;        }        $m = $this->m;        $n = $this->n;        // All elements are the same        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if ($this->A[$i][$j] != $B[$i][$j]) {                    return false;                }            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ObjectMatrix_2810, Scalar matrix multiplication\\n https://en.wikipedia.org/wiki/Matrix_multiplication#Scalar_multiplication\\n\\n @param  float $λ\\n\\n @return Matrix\\n\\n @throws Exception\\\\BadParameterException if λ is not a number\\n @throws Exception\\\\IncorrectTypeException\\n, Scalar matrix multiplication,    public function scalarMultiply($λ): Matrix    {        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j]->multiply($λ);            }        }        return MatrixFactory::create($R);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ObjectMatrix_2812," Determinant\n\n This implementation is simpler than that of the parent. Instead of\n reducing the matrix, which requires division, we calculate the cofactors\n for the first row of the matrix, perform element-wise multiplication, and\n add the results of that row.\n\n This implementation also uses the same algorithm for 2x2 matrices. Adding\n a special case may quicken code execution.\n\n @return ObjectArithmetic\n", Determinant,"    public function det()    {        if ($this->catalog->hasDeterminant()) {            return $this->catalog->getDeterminant();        }        if (!$this->isSquare()) {            throw new Exception\MatrixException('Not a square matrix (required for determinant)');        }        $m = $this->m;        $R = MatrixFactory::create($this->A);        /*         * 1x1 matrix         *  A = [a]         *         * |A| = a         */        if ($m === 1) {            $det = $R[0][0];        } else {            // Calculate the cofactors of the top row of the matrix            $row_of_cofactors = [];            for ($i = 0; $i < $m; $i++) {                $row_of_cofactors[$i] = $R->cofactor(0, $i);            }            // Since we don't know what the data type is, we can't initialze $det            // to zero without a special initialize() or zero() method.            $initialize = true;            $det = $R[0][0]->multiply($row_of_cofactors[0]);            foreach ($row_of_cofactors as $key => $value) {                if ($initialize) {                    // We skip the first element since it was used to initialize.                    $initialize = false;                } else {                    // $det += element * cofactor                    $det = $det->add($R[0][$key]->multiply($value));                }            }        }        $this->catalog->addDeterminant($det);        return $det;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ObjectSquareMatrix_2814, ObjectSquareMatrix\\n\\n The objectSquareMatrix extends Matrix functions to a matrix of objects.\\n The object must implement the MatrixArithmetic interface to prove\\n compatibility. It extends the SquareMatrix in order to use Matrix::minor().\\n, ObjectSquareMatrix,"class ObjectSquareMatrix extends ObjectMatrix{    /**     * @param ObjectArithmetic[][] $A n x n matrix of objects     *     * @throws Exception\BadDataException if any rows have a different column count     * @throws Exception\IncorrectTypeException if all elements are not the same class     * @throws Exception\IncorrectTypeException if The class does not implement the ObjectArithmetic interface     * @throws Exception\MatrixException if not square     * @throws Exception\MathException     */    public function __construct(array $A)    {        parent::__construct($A);        if ($this->m !== $this->n) {            throw new Exception\MatrixException(""Not a square matrix; row count and column count differ: {$this->m}x{$this->n}"");        }    }    /**     * Square matrix must be square     *     * @return bool     */    public function isSquare(): bool    {        return true;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Outlier_3536, Tests for outliers in data\\n  - Grubbs' Test\\n, Tests for outliers in data,"class Outlier{    public const ONE_SIDED       = 'one';    public const TWO_SIDED       = 'two';    public const ONE_SIDED_LOWER = 'lower';    public const ONE_SIDED_UPPER = 'upper';    /**     * The Grubbs' Statistic (G) of a series of data     *     * G is the largest z-score for a set of data     * The statistic can be calculated, looking at only the maximum value (""upper"")     * the minimum value (""lower""), or the data point with the largest residual (""two"")     *     * https://en.wikipedia.org/wiki/Grubbs%27_test_for_outliers     * https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm     *     * Two-sided Grubbs' test statistic - largest difference from the mean is an outlier     *     *     max❘Yᵢ − μ❘     * G = ----------     *         σ     *     * One-sided Grubbs' test statistic - minimum value is an outlier     *     *     μ - Ymin     * G = --------     *        σ     *     * One-sided Grubbs' test statistic - maximum value is an outlier     *     *     Ymax - μ     * G = --------     *        σ     *     * @param float[] $data     * @param string  $typeOfTest (""upper"" ""lower"", or ""two"")     *     * @return float G (Grubb's test statistic)     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     * @throws Exception\BadParameterException if the type of test is not valid     */    public static function grubbsStatistic(array $data, string $typeOfTest = self::TWO_SIDED): float    {        $μ = Average::mean($data);        $σ = Descriptive::standardDeviation($data);        if ($typeOfTest === self::TWO_SIDED) {            $max❘Yᵢ − μ❘ = \max(Single::abs(Single::subtract($data, $μ)));            return $max❘Yᵢ − μ❘ / $σ;        }        if ($typeOfTest === self::ONE_SIDED_LOWER) {            $yMin = \min($data);            return ($μ - $yMin) / $σ;        }        if ($typeOfTest === self::ONE_SIDED_UPPER) {            $yMax = \max($data);            return ($yMax - $μ) / $σ;        }        throw new Exception\BadParameterException(""{$typeOfTest} is not a valid Grubbs; test"");    }    /**     * The critical Grubbs Value     *     * The critical Grubbs' value is used to determine if a value in a set of data is likely to be an outlier.     *     * https://en.wikipedia.org/wiki/Grubbs%27_test_for_outliers     * https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm     *     *                                ___________     *                   (n - 1)     /    T²     * Critical value =  ------- \  / ----------     *                     √n     \/  n - 2 + T²     *     * T = Critical value of the t distribution with (N-2) degrees of freedom and a significance level of α/(2N)     *     For the one-sided tests, replace α/(2N) with α/N.     *     * @param float  $𝛼 Significance level     * @param int    $n Size of the data set     * @param string $typeOfTest ('one' or 'two') one or two-tailed test     *     * @return float     *     * @throws Exception\BadParameterException     */    public static function grubbsCriticalValue(float $𝛼, int $n, string $typeOfTest): float    {        self::validateGrubbsCriticalValueTestType($typeOfTest);        $studentT = new StudentT($n - 2);        $T = $typeOfTest === self::ONE_SIDED            ? $studentT->inverse($𝛼 / $n)            : $studentT->inverse($𝛼 / (2 * $n));        return (($n - 1) / \sqrt($n)) * \sqrt($T ** 2 / ($n - 2 + $T ** 2));    }    /* ********************** *     * PRIVATE HELPER METHODS     * ********************** */    /**     * Validate the type of test is two sided, or one sided lower or upper     *     * @param string $typeOfTest     *     * @throws Exception\BadParameterException     */    private static function validateGrubbsCriticalValueTestType(string $typeOfTest)    {        if (!\in_array($typeOfTest, [self::ONE_SIDED, self::TWO_SIDED])) {            throw new Exception\BadParameterException(""{$typeOfTest} is not a valid Grubbs' test"");        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Outlier_3538," Validate the type of test is two sided, or one sided lower or upper\n\n @param string $typeOfTest\n\n @throws Exception\\BadParameterException\n"," Validate the type of test is two sided, or one sided lower or upper","    private static function validateGrubbsCriticalValueTestType(string $typeOfTest)    {        if (!\in_array($typeOfTest, [self::ONE_SIDED, self::TWO_SIDED])) {            throw new Exception\BadParameterException(""{$typeOfTest} is not a valid Grubbs' test"");        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PCARegressionTest_6237," Regression test for bug issue 414\\n\\n @link https://github.com/markrogoyski/math-php/issues/414\\n\\n The issue was construction the PCA with highly correlated data, calculating the eigenvalues would not converge,\\n resulting in an infinite loop.\\n", Regression test for bug issue 414,"class PCARegressionTest extends \PHPUnit\Framework\TestCase{    /**     * @test PCA center false and scale false     *     * R test data     * > library(mdatools)     * >     * > data = rbind(c(0.066073, 96.000000), c(5.407780, 1115.857143), c(19.440563, 3999.142857), c(35.582583, 7315.857143), c(71.602260, 14725.428571), c(165.725077, 34186.000000), c(235.426483, 48657.857143), c(256.868816, 53160.316186))     * > data     * [,1]      [,2]     * [1,]   0.066073    96.000     * [2,]   5.407780  1115.857     * [3,]  19.440563  3999.143     * [4,]  35.582583  7315.857     * [5,]  71.602260 14725.429     * [6,] 165.725077 34186.000     * [7,] 235.426483 48657.857     * [8,] 256.868816 53160.316     * >     * > model = pca(data, center=FALSE, scale=FALSE)     *     * > loadings = model$loadings     * > loadings     * Comp 1       Comp 2     * [1,] -0.004838294 -0.999988295     * [2,] -0.999988295  0.004838294     */    public function testBugCenterFalseScaleFalseLoadings()    {        // Given        $data = MatrixFactory::createNumeric([            [0.066073, 96.000000],            [5.407780, 1115.857143],            [19.440563, 3999.142857],            [35.582583, 7315.857143],            [71.602260, 14725.428571],            [165.725077, 34186.000000],            [235.426483, 48657.857143],            [256.868816, 53160.316186]        ]);        // And        $center = true;        $scale = false;        // When        $model = new PCA($data, $center, $scale);        // Then        $expected = [            [-0.004838294, -0.999988295],            [-0.999988295,  0.004838294],        ];        $loadings = $model->getLoadings();        // And since each column could be multiplied by -1, we will compare the two and adjust.        // Get an array that's roughly ones and negative ones.        $quotient = Multi::divide($expected[1], $loadings->getMatrix()[1]);        // Convert to exactly one or negative one. Cannot be zero.        $signum = \array_map(            function ($x) {                return $x <=> 0;            },            $quotient        );        $sign_change = MatrixFactory::diagonal($signum);        // Multiplying a sign change matrix on the right changes column signs.        $sign_adjusted = $loadings->multiply($sign_change);        // Then        $this->assertEqualsWithDelta($expected, $sign_adjusted->getMatrix(), .00001);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PCATest_6239," R code for expected values:\\n   library(mdatools)\\n   data = mtcars[,c(1:7,10,11)]\\n   model = pca(data, center=TRUE, scale=TRUE)\\n\\n @throws Exception\\\\MathException\\n", R code for expected values:,"    public static function setUpBeforeClass(): void    {        $mtCars = new SampleData\MtCars();        // Remove and categorical variables        self::$matrix = MatrixFactory::create($mtCars->getData())->columnExclude(8)->columnExclude(7);        self::$pca = new PCA(self::$matrix, true, true);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PCA_3569, Get the cumulative R²\\n\\n @return float[]\\n, Get the cumulative R²,    public function getCumR2(): array    {        $result = [];        $sum    = 0;        foreach ($this->getR2() as $R²value) {            $sum += $R²value;            $result[] = $sum;        }        return $result;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ParametricRegression_3587, Get the equation\\n Uses the model's getModelEquation method.\\n\\n @return string\\n, Get the equation,    public function getEquation(): string    {        return $this->getModelEquation($this->parameters);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Pareto_3174, Pareto distribution\\n https://en.wikipedia.org/wiki/Pareto_distribution\\n, Pareto distribution,"class Pareto extends Continuous{    /**     * Distribution parameter bounds limits     * a ∈ (0,∞)     * b ∈ (0,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'a' => '(0,∞)',        'b' => '(0,∞)',    ];    /**     * Distribution support bounds limits     * x ∈ (0,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '(0,∞)',        'a' => '(0,∞)',        'b' => '(0,∞)',    ];    /** @var float Shape Parameter */    protected $a;    /** @var float Scale Parameter */    protected $b;    /**     * Constructor     *     * @param float $a shape parameter     * @param float $b scale parameter     */    public function __construct(float $a, float $b)    {        parent::__construct($a, $b);    }    /**     * Probability density function     *     *          abᵃ     * P(x) =  ----  for x ≥ b     *         xᵃ⁺¹     *     * P(x) = 0      for x < b     *     * @param  float $x     *     * @return float     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $a = $this->a;        $b = $this->b;        if ($x < $b) {            return 0;        }        $abᵃ  = $a * $b ** $a;        $xᵃ⁺¹ = \pow($x, $a + 1);        return $abᵃ / $xᵃ⁺¹;    }    /**     * Cumulative distribution function     *     *             / b \ᵃ     * D(x) = 1 - |  -  | for x ≥ b     *             \ x /     *     * D(x) = 0           for x < b     *     * @param  float $x     *     * @return float     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $a = $this->a;        $b = $this->b;        if ($x < $b) {            return 0;        }        return 1 - \pow($b / $x, $a);    }    /**     * Inverse CDF (quantile)     *     *             b     * F⁻¹(P) = -------     *          (1 - P)¹/ᵃ     *     * @param float $p     *     * @return float     */    public function inverse(float $p): float    {        $a = $this->a;        $b = $this->b;        if ($p == 0) {            return -\INF;        }        if ($p == 1) {            return \INF;        }        return $b / ((1 - $p) ** (1 / $a));    }    /**     * Mean of the distribution     *     * μ = ∞ for a ≤ 1     *     *      ab     * μ = ----- for a > 1     *     a - 1     *     * @return float     */    public function mean(): float    {        $a = $this->a;        $b = $this->b;        if ($a <= 1) {            return \INF;        }        return $a * $b / ($a - 1);    }    /**     * Median of the distribution     *     * median = a ᵇ√2     *     * @return float     */    public function median(): float    {        $a = $this->a;        $b = $this->b;        return $a * (2 ** (1 / $b));    }    /**     * Mode of the distribution     *     * mode = a     *     * @return float     */    public function mode(): float    {        return $this->a;    }    /**     * Variance of the distribution     *     * σ² = ∞                 a ≤ 2     *     *            ab²     * σ² = ---------------   a > 2     *      (a - 1)²(a - 2)     *     * @return float     */    public function variance(): float    {        $a = $this->a;        $b = $this->b;        if ($a <= 2) {            return \INF;        }        return ($a * $b ** 2) / (($a - 1) ** 2 * ($a - 2));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Pareto_3177, Cumulative distribution function\n\n             / b \\ᵃ\n D(x) = 1 - |  -  | for x ≥ b\n             \\ x /\n\n D(x) = 0           for x < b\n\n @param  float $x\n\n @return float\n, Cumulative distribution function,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $a = $this->a;        $b = $this->b;        if ($x < $b) {            return 0;        }        return 1 - \pow($b / $x, $a);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Pareto_3179, Mean of the distribution\\n\\n μ = ∞ for a ≤ 1\\n\\n      ab\\n μ = ----- for a > 1\\n     a - 1\\n\\n @return float\\n, Mean of the distribution,    public function mean(): float    {        $a = $this->a;        $b = $this->b;        if ($a <= 1) {            return \INF;        }        return $a * $b / ($a - 1);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Pareto_3181, Mode of the distribution\n\n mode = a\n\n @return float\n, Mode of the distribution,    public function mode(): float    {        return $this->a;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Pareto_3182, Variance of the distribution\\n\\n σ² = ∞                 a ≤ 2\\n\\n            ab²\\n σ² = ---------------   a > 2\\n      (a - 1)²(a - 2)\\n\\n @return float\\n, Variance of the distribution,    public function variance(): float    {        $a = $this->a;        $b = $this->b;        if ($a <= 2) {            return \INF;        }        return ($a * $b ** 2) / (($a - 1) ** 2 * ($a - 2));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_People_3333," Raw data with each observation labeled\\n ['Lars' => ['height' => 198, 'weight' => 92, 'hairLength' => -1, ... ]]\\n\\n @return int[][]\\n", Raw data with each observation labeled,"    public function getLabeledData(): array    {        return \array_map(            function (array $data) {                return \array_combine(self::LABELS, $data);            },            self::DATA        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_People_3334, People names\n\n @return string[]\n, People names,    public function getNames(): array    {        return \array_keys(self::DATA);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Piecewise_2517, A convenience class for piecewise functions.\\n\\n https://en.wikipedia.org/wiki/Piecewise\\n, A convenience class for piecewise functions.,"class Piecewise{    /** @var array */    private $intervals;    /** @var array */    private $functions;    /**     * Validate that our inputs satisfy the conditions of a piecewise function,     * and then assign our inputs as the object parameters.     *     * In our $intervals array, each interval should contain two numbers [a, b].     * We can optionally add two booleans to an interval, signifying the openness     * of a and b, respectfully (true means open, false means closed). If boolean     * arguments are not supplied, the interval will be assumed to be closed.     *     * Examples:     *     1. [0, 2, true, false] means an interval from 0 to 2, where 0 is open     *        (exclusive) and 2 is closed (inclusive).     *     2. [-10, 10] means an closed (inclusive) interval from -10 to 10     *     * A number of conditions need to be met for a piecewise function:     *     o We must provide the same number of intervals as callback functions     *     o Each function in our $functions array needs to be callable     *     o Each interval must contain precisely 2 numbers, optionally 2 booleans     *     o An interval defined as a point (e.g. [2, 2]) must be closed at both ends     *     o The numbers in an interval must be increasing. Given [a, b] then b >= a.     *     o Two intervals cannot overlap. This means that if two intervals share     *       a start and end-point, the point must be closed on both sides. Also,     *       we cannot start or end an interval in the middle of another interval.     *     * @param  array $intervals Array of intervals     *                          Example: [[-10, 0, false, true], [0, 2], [3, 10]]     * @param  array $functions Array of callback functions     *     * @throws Exception\BadDataException if the number of intervals and functions are not the same     * @throws Exception\BadDataException if any function in $functions is not callable     * @throws Exception\BadDataException if any interval in $intervals does not contain 2 numbers     * @throws Exception\BadDataException if any interval [a, b] is decreasing, or b < a     * @throws Exception\BadDataException if an interval is a point that is not closed     * @throws Exception\BadDataException if two intervals share a point that is closed at both ends     * @throws Exception\BadDataException if one interval starts or ends inside another interval     */    public function __construct(array $intervals, array $functions)    {        $this->constructorPreconditions($intervals, $functions);        $unsortedIntervals = $intervals;        // Sort intervals such that start of intervals is increasing        \usort($intervals, function ($a, $b) {            return $a[0] <=> $b[0];        });        foreach ($intervals as $interval) {            // Store values from previous interval            $lastA     = $a ?? -\INF;            $lastB     = $b ?? -\INF;            $lastBOpen = $bOpen ?? false;            if (\count(\array_filter($interval, '\is_numeric')) !== 2) {                throw new Exception\BadDataException('Each interval must contain two numbers.');            }            // Fetch values from current interval            $a     = $interval[0];            $b     = $interval[1];            $aOpen = $interval[2] ?? false;            $bOpen = $interval[3] ?? false;            $this->checkAsAndBs($a, $b, $lastA, $lastB, $lastBOpen, $aOpen, $bOpen);        }        $this->intervals = $unsortedIntervals;        $this->functions = $functions;    }    /**    * When a callback function is being evaluated at a specific point, find the    * the corresponding function for that point in the domain, and then return    * the function evaluated at that point. If no function is found, throw an Exception.    *    * @param float $x₀ The value at which we are evaluating our piecewise function    *    * @return float The specific function evaluated at $x₀    *    * @throws Exception\BadDataException if an interval cannot be found which contains our $x₀    */    public function __invoke(float $x₀): float    {        $function = $this->getFunction($x₀);        return $function($x₀);    }    /**    * Find which subinterval our input value is contained within, and then return    * the function that corresponds to that subinterval. If no subinterval is found    * such that our input is contained within it, a false is returned.    *    * @param float $x The value at which we are searching for a subinterval that    *                  contains it, and thus has a corresponding function.    *    * @return callable Returns the function that contains $x in its domain    *    * @throws Exception\BadDataException if an interval cannot be found which contains our $x    */    private function getFunction(float $x): callable    {        foreach ($this->intervals as $i => $interval) {            $a     = $interval[0];            $b     = $interval[1];            $aOpen = $interval[2] ?? false;            $bOpen = $interval[3] ?? false;            // Four permutations: open-open, open-closed, closed-open, closed-closed            if ($this->openOpen($aOpen, $bOpen) && $x > $a && $x < $b) {                return $this->functions[$i];            }            if ($this->openClosed($aOpen, $bOpen) && $x > $a && $x <= $b) {                return $this->functions[$i];            }            if ($this->closedOpen($aOpen, $bOpen) && $x >= $a && $x < $b) {                return $this->functions[$i];            }            if ($this->closedClosed($aOpen, $bOpen) && $x >= $a && $x <= $b) {                return $this->functions[$i];            }        }        throw new Exception\BadDataException(""The input {$x} is not in the domain of this piecewise function, thus it is undefined at that point."");    }    /**     * Open-open interval     *     * @param  bool $aOpen     * @param  bool $bOpen     *     * @return bool     */    private function openOpen(bool $aOpen, bool $bOpen): bool    {        return $aOpen && $bOpen;    }    /**     * Open-closed interval     *     * @param  bool $aOpen     * @param  bool $bOpen     *     * @return bool     */    private function openClosed(bool $aOpen, bool $bOpen): bool    {        return $aOpen && !$bOpen;    }    /**     * Closed-open interval     *     * @param  bool $aOpen     * @param  bool $bOpen     *     * @return bool     */    private function closedOpen(bool $aOpen, bool $bOpen): bool    {        return !$aOpen && $bOpen;    }    /**     * Closed-closed interval     *     * @param  bool $aOpen     * @param  bool $bOpen     *     * @return bool     */    private function closedClosed(bool $aOpen, bool $bOpen): bool    {        return !$aOpen && !$bOpen;    }    /**     * Constructor preconditions - helper method     *  - Same number of intervals as functions     *  - All functions are callable     *     * @param  array  $intervals     * @param  array  $functions     *     * @return void     *     * @throws Exception\BadDataException if the number of intervals and functions are not the same     * @throws Exception\BadDataException if any function in $functions is not callable     */    private function constructorPreconditions(array $intervals, array $functions)    {        if (\count($intervals) !== \count($functions)) {            throw new Exception\BadDataException('For a piecewise function you must provide the same number of intervals as functions.');        }        if (\count(\array_filter($functions, '\is_callable')) !== \count($intervals)) {            throw new Exception\BadDataException('Not every function provided is valid. Ensure that each function is callable.');        }    }    /**     * Check the as and bs in the intervals     * Helper method of constructor.     *     * @param  number $a     * @param  number $b     * @param  number $lastA     * @param  number $lastB     * @param  bool   $lastBOpen     * @param  bool   $aOpen     * @param  bool   $bOpen     *     * @return void     *     * @throws Exception\BadDataException if any interval [a, b] is decreasing, or b < a     * @throws Exception\BadDataException if an interval is a point that is not closed     * @throws Exception\BadDataException if two intervals share a point that is closed at both ends     * @throws Exception\BadDataException if one interval starts or ends inside another interval     */    private function checkAsAndBs($a, $b, $lastA, $lastB, $lastBOpen, bool $aOpen, bool $bOpen)    {        if ($a === $b && ($aOpen || $bOpen)) {            throw new Exception\BadDataException(""Your interval [{$a}, {$b}] is a point and thus needs to be closed at both ends"");        }        if ($a > $b) {            throw new Exception\BadDataException(""Interval must be increasing. Try again using [{$b}, {$a}] instead of [{$a}, {$b}]"");        }        if ($a === $lastB && !$aOpen && !$lastBOpen) {            throw new Exception\BadDataException(""The intervals [{$lastA}, {$lastB}] and [{$a}, {$b}] share a point, but both intervals are also closed at that point. For intervals to share a point, one or both sides of that point must be open."");        }        if ($a < $lastB) {            throw new Exception\BadDataException(""The intervals [{$lastA}, {$lastB}] and [{$a}, {$b}] overlap. The subintervals of a piecewise functions cannot overlap."");        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Piecewise_2521," Find which subinterval our input value is contained within, and then return\n the function that corresponds to that subinterval. If no subinterval is found\n such that our input is contained within it, a false is returned.\n\n @param float $x The value at which we are searching for a subinterval that\n                  contains it, and thus has a corresponding function.\n\n @return callable Returns the function that contains $x in its domain\n\n @throws Exception\\BadDataException if an interval cannot be found which contains our $x\n"," Find which subinterval our input value is contained within, and then return","    private function getFunction(float $x): callable    {        foreach ($this->intervals as $i => $interval) {            $a     = $interval[0];            $b     = $interval[1];            $aOpen = $interval[2] ?? false;            $bOpen = $interval[3] ?? false;            // Four permutations: open-open, open-closed, closed-open, closed-closed            if ($this->openOpen($aOpen, $bOpen) && $x > $a && $x < $b) {                return $this->functions[$i];            }            if ($this->openClosed($aOpen, $bOpen) && $x > $a && $x <= $b) {                return $this->functions[$i];            }            if ($this->closedOpen($aOpen, $bOpen) && $x >= $a && $x < $b) {                return $this->functions[$i];            }            if ($this->closedClosed($aOpen, $bOpen) && $x >= $a && $x <= $b) {                return $this->functions[$i];            }        }        throw new Exception\BadDataException(""The input {$x} is not in the domain of this piecewise function, thus it is undefined at that point."");    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Piecewise_2522, Open-open interval\\n\\n @param  bool $aOpen\\n @param  bool $bOpen\\n\\n @return bool\\n, Open-open interval,"    private function openOpen(bool $aOpen, bool $bOpen): bool    {        return $aOpen && $bOpen;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Piecewise_2523, Open-closed interval\n\n @param  bool $aOpen\n @param  bool $bOpen\n\n @return bool\n, Open-closed interval,"    private function openClosed(bool $aOpen, bool $bOpen): bool    {        return $aOpen && !$bOpen;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Piecewise_2526, Constructor preconditions - helper method\n  - Same number of intervals as functions\n  - All functions are callable\n\n @param  array  $intervals\n @param  array  $functions\n\n @return void\n\n @throws Exception\\BadDataException if the number of intervals and functions are not the same\n @throws Exception\\BadDataException if any function in $functions is not callable\n, Constructor preconditions - helper method,"    private function constructorPreconditions(array $intervals, array $functions)    {        if (\count($intervals) !== \count($functions)) {            throw new Exception\BadDataException('For a piecewise function you must provide the same number of intervals as functions.');        }        if (\count(\array_filter($functions, '\is_callable')) !== \count($intervals)) {            throw new Exception\BadDataException('Not every function provided is valid. Ensure that each function is callable.');        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Piecewise_2527," Check the as and bs in the intervals\\n Helper method of constructor.\\n\\n @param  number $a\\n @param  number $b\\n @param  number $lastA\\n @param  number $lastB\\n @param  bool   $lastBOpen\\n @param  bool   $aOpen\\n @param  bool   $bOpen\\n\\n @return void\\n\\n @throws Exception\\\\BadDataException if any interval [a, b] is decreasing, or b < a\\n @throws Exception\\\\BadDataException if an interval is a point that is not closed\\n @throws Exception\\\\BadDataException if two intervals share a point that is closed at both ends\\n @throws Exception\\\\BadDataException if one interval starts or ends inside another interval\\n", Check the as and bs in the intervals,"    private function checkAsAndBs($a, $b, $lastA, $lastB, $lastBOpen, bool $aOpen, bool $bOpen)    {        if ($a === $b && ($aOpen || $bOpen)) {            throw new Exception\BadDataException(""Your interval [{$a}, {$b}] is a point and thus needs to be closed at both ends"");        }        if ($a > $b) {            throw new Exception\BadDataException(""Interval must be increasing. Try again using [{$b}, {$a}] instead of [{$a}, {$b}]"");        }        if ($a === $lastB && !$aOpen && !$lastBOpen) {            throw new Exception\BadDataException(""The intervals [{$lastA}, {$lastB}] and [{$a}, {$b}] share a point, but both intervals are also closed at that point. For intervals to share a point, one or both sides of that point must be open."");        }        if ($a < $lastB) {            throw new Exception\BadDataException(""The intervals [{$lastA}, {$lastB}] and [{$a}, {$b}] overlap. The subintervals of a piecewise functions cannot overlap."");        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PlantGrowth_3349," Raw data without labels\n [[4.17, 'ctrl'], [5.58, 'ctrl'], ... ]\n\n @return mixed[]\n", Raw data without labels,    public function getData(): array    {        return \array_values(self::DATA);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PlantGrowth_3352," Group (ctrl, trt1, trt2) observations\n\n @return string[]\n"," Group (ctrl, trt1, trt2) observations","    public function getGroup(): array    {        return \array_column(self::DATA, 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Poisson_3253, Constructor\n\n @param  float $λ average number of successful events per interval\n, Constructor,    public function __construct(float $λ)    {        parent::__construct($λ);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Poisson_3255," Cumulative Poisson Probability (lower culmulative distribution) - CDF\\n The probability that the Poisson random variable is greater than some specified lower limit,\\n and less than some specified upper limit.\\n\\n           k  λˣℯ^⁻λ\\n P(k,λ) =  ∑  ------\\n          ₓ₌₀  xᵢ!\\n\\n @param  int   $k events in the interval\\n\\n @return float The cumulative Poisson probability\\n", Cumulative Poisson Probability (lower culmulative distribution) - CDF,"    public function cdf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        return \array_sum(\array_map(            function ($k) {                return $this->pmf($k);            },            \range(0, $k)        ));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Poisson_3256, Mean of the distribution\n\n μ = λ\n\n @return float\n, Mean of the distribution,    public function mean(): float    {        return $this->λ;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PolynomialAxiomsTest_3742," Tests of polynomial axioms\\n These tests don't test specific functions,\\n but rather polynomial axioms which in term make use of multiple functions.\\n If all the polynomial math is implemented properly, these tests should\\n all work out according to the axioms.\\n\\n Axioms tested:\\n  - Commutativity\\n    - a + b = b + a\\n    - ab = bc\\n  - Associativity\\n    - a + (b + c) = (a + b) + c\\n    - a(bc) = (ab)c\\n  - Distributed Law\\n    - a ✕ (b + c) = a ✕ b + a ✕ c\\n    - a + (b ✕ c) = a ✕ c + b ✕ c\\n  - Identity\\n    - a + 0 = 0 + a = a\\n    - a ✕ 0 = 0 ✕ a = 0\\n  - Negate\\n    - -a = a   - Arithmetic\\n    - Sum of two polynomials is a polynomial\\n    - Product of two polynomials is a polynomial\\n    - Derivative of a polynomial is a polynomial\\n    - Integral of a polynomial is a polynomial\\n", Tests of polynomial axioms,"class PolynoialAxiomsTest extends \PHPUnit\Framework\TestCase{    /**     * @test Axiom: a + b = b + a     * Commutativity of addition.     * @dataProvider dataProviderForTwoPolynomials     * @param        array $a     * @param        array $b     * @throws       \Exception     */    public function testCommutativityOfAddition(array $a, array $b)    {        // Given        $a = new Polynomial($a);        $b = new Polynomial($b);        // When        $a＋b = $a->add($b);        $b＋a = $b->add($a);        // Then        $this->assertEquals($a＋b->getDegree(), $b＋a->getDegree());        $this->assertEquals($a＋b->getCoefficients(), $b＋a->getCoefficients());    }    /**     * @test Axiom: ab = bc     * Commutativity of multiplication.     * @dataProvider dataProviderForTwoPolynomials     * @param        array $a     * @param        array $b     * @throws       \Exception     */    public function testCommutativityOfMultiplication(array $a, array $b)    {        // Given        $a = new Polynomial($a);        $b = new Polynomial($b);        // When        $ab = $a->multiply($b);        $ba = $b->multiply($a);        // Then        $this->assertEquals($ab->getDegree(), $ba->getDegree());        $this->assertEquals($ab->getCoefficients(), $ba->getCoefficients());    }    /**     * @test Axiom: a + (b + c) = (a + b) + c     * Associativity of addition.     * @dataProvider dataProviderForThreePolynomials     * @param        array $a     * @param        array $b     * @param        array $c     * @throws       \Exception     */    public function testAssociativityOfAddition(array $a, array $b, array $c)    {        // Given        $a = new Polynomial($a);        $b = new Polynomial($b);        $c = new Polynomial($c);        // When        $a ＋ ⟮b ＋ c⟯ = $a->add($b->add($c));        $⟮a ＋ b⟯ ＋ c = ($a->add($b))->add($c);        // Then        $this->assertEquals($a ＋ ⟮b ＋ c⟯->getDegree(), $⟮a ＋ b⟯ ＋ c->getDegree());        $this->assertEquals($a ＋ ⟮b ＋ c⟯->getCoefficients(), $⟮a ＋ b⟯ ＋ c->getCoefficients());    }    /**     * @test Axiom: a(bc) = (ab)c     * Associativity of multiplication.     * @dataProvider dataProviderForThreePolynomials     * @param        array $a     * @param        array $b     * @param        array $c     * @throws       \Exception     */    public function testAssociativityOfMultiplication(array $a, array $b, array $c)    {        // Given        $a = new Polynomial($a);        $b = new Polynomial($b);        $c = new Polynomial($c);        // When        $a⟮bc⟯ = $a->multiply($b->multiply($c));        $⟮ab⟯c = ($a->multiply($b))->multiply($c);        // Then        $this->assertEquals($a⟮bc⟯->getDegree(), $⟮ab⟯c->getDegree());        $this->assertEquals($a⟮bc⟯->getCoefficients(), $⟮ab⟯c->getCoefficients());    }    /**     * @test Axiom: a ✕ (b + c) = a ✕ b + a ✕ c     * Distributive law.     * @dataProvider dataProviderForThreePolynomials     * @param        array $a     * @param        array $b     * @param        array $c     * @throws       \Exception     */    public function testDistributiveLaw1(array $a, array $b, array $c)    {        // Given        $a = new Polynomial($a);        $b = new Polynomial($b);        $c = new Polynomial($c);        // When        $a⟮b ＋ c⟯   = $a->multiply($b->add($c));        $⟮ab⟯ ＋ ⟮ac⟯ = ($a->multiply($b))->add($a->multiply($c));        // Then        $this->assertEquals($a⟮b ＋ c⟯->getDegree(), $⟮ab⟯ ＋ ⟮ac⟯->getDegree());        $this->assertEquals($a⟮b ＋ c⟯->getCoefficients(), $⟮ab⟯ ＋ ⟮ac⟯->getCoefficients());    }    /**     * @test Axiom: (a + b) ✕ c = a ✕ c + b ✕ c     * Distributive law.     * @dataProvider dataProviderForThreePolynomials     * @param        array $a     * @param        array $b     * @param        array $c     * @throws       \Exception     */    public function testDistributiveLaw2(array $a, array $b, array $c)    {        // Given        $a = new Polynomial($a);        $b = new Polynomial($b);        $c = new Polynomial($c);        // When        $⟮a ＋ b⟯c   = ($a->add($b))->multiply($c);        $⟮ac⟯ ＋ ⟮bc⟯ = ($a->multiply($c))->add($b->multiply($c));        // Then        $this->assertEquals($⟮a ＋ b⟯c->getDegree(), $⟮ac⟯ ＋ ⟮bc⟯->getDegree());        $this->assertEquals($⟮a ＋ b⟯c->getCoefficients(), $⟮ac⟯ ＋ ⟮bc⟯->getCoefficients());    }    /**     * @test Axiom: a + 0 = 0 + a = a     * Identity of addition.     * @dataProvider dataProviderForOnePolynomial     * @param        array $a     * @throws       \Exception     */    public function testIdentityOfAddition(array $a)    {        // Given        $a    = new Polynomial($a);        $zero = new Polynomial([0]);        // When        $a＋0    = $a->add($zero);        $zero＋a = $zero->add($a);        // Then        $this->assertEquals($a->getDegree(), $a＋0->getDegree());        $this->assertEquals($a->getDegree(), $zero＋a->getDegree());        // And        $this->assertEquals($a->getCoefficients(), $a＋0->getCoefficients());        $this->assertEquals($a->getCoefficients(), $zero＋a->getCoefficients());    }    /**     * @test Axiom: a ✕ 0 = 0 ✕ a = 0     * Identity of multiplication.     * @dataProvider dataProviderForOnePolynomial     * @param        array $a     * @throws       \Exception     */    public function testIdentityOfMultiplication(array $a)    {        // Given        $a    = new Polynomial($a);        $zero = new Polynomial([0]);        // When        $a✕0    = $a->multiply($zero);        $zero✕a = $zero->multiply($a);        // Then        $this->assertEquals($zero->getDegree(), $a✕0->getDegree());        $this->assertEquals($zero->getDegree(), $zero✕a->getDegree());        // And        $this->assertEquals($zero->getCoefficients(), $a✕0->getCoefficients());        $this->assertEquals($zero->getCoefficients(), $zero✕a->getCoefficients());    }    /**     * @test Axiom: -a = a * -1     * Negation is the same as multiplying by -1     * @dataProvider dataProviderForOnePolynomial     * @param        array $a     * @throws       \Exception     */    public function testNegateSameAsMultiplyingByNegativeOne(array $a)    {        // Given        $a = new Polynomial($a);        // When        $−a = $a->negate();        $a⟮−1⟯ = $a->multiply(-1);        // Then        $this->assertEquals($−a->getDegree(), $a⟮−1⟯->getDegree());        $this->assertEquals($−a->getCoefficients(), $a⟮−1⟯->getCoefficients());    }    /**     * @test Axiom: Sum of two polynomials is a polynomial     * @dataProvider dataProviderForTwoPolynomials     * @param        array $a     * @param        array $b     * @throws       \Exception     */    public function testArithmeticAdditionProperty(array $a, array $b)    {        // Given        $a = new Polynomial($a);        $b = new Polynomial($b);        // When        $a＋b = $a->add($b);        // Then        $this->assertInstanceOf(Polynomial::class, $a＋b);    }    /**     * @test Axiom: Product of two polynomials is a polynomial     * @dataProvider dataProviderForTwoPolynomials     * @param        array $a     * @param        array $b     * @throws       \Exception     */    public function testArithmeticMultiplicationProperty(array $a, array $b)    {        // Given        $a = new Polynomial($a);        $b = new Polynomial($b);        // When        $ab = $a->multiply($b);        // Then        $this->assertInstanceOf(Polynomial::class, $ab);    }    /**     * @test Axiom: Derivative of a polynomials is a polynomial     * @dataProvider dataProviderForOnePolynomial     * @param        array $a     * @throws       \Exception     */    public function testArithmeticDerivativeProperty(array $a)    {        // Given        $a = new Polynomial($a);        // When        $derivative = $a->differentiate();        // Then        $this->assertInstanceOf(Polynomial::class, $derivative);    }    /**     * @test Axiom: Integral of a polynomials is a polynomial     * @dataProvider dataProviderForOnePolynomial     * @param        array $a     * @throws       \Exception     */    public function testArithmeteicIntegrationProperty(array $a)    {        // Given        $a = new Polynomial($a);        // When        $derivative = $a->integrate();        // Then        $this->assertInstanceOf(Polynomial::class, $derivative);    }    public function dataProviderForOnePolynomial(): array    {        return [            [                [0],            ],            [                [1],            ],            [                [2],            ],            [                [8],            ],            [                [1, 5],            ],            [                [4, 0],            ],            [                [0, 3],            ],            [                [12, 4],            ],            [                [1, 2, 3],            ],            [                [2, 3, 4],            ],            [                [1, 1, 1],            ],            [                [5, 3, 6],            ],            [                [2, 7, 4],            ],            [                [6, 0, 3],            ],            [                [4, 5, 2, 6],            ],            [                [3, 5, 2, 10],            ],            [                [-4, 6, 7, -1],            ],            [                [-2, -1, -4, -3],            ],            [                [5, 3, 6],            ],            [                [7, 6, 6],            ],            [                [-6, -1],            ],            [                [-5, -5, -1, 2, 4, 6, 5],            ],            [                [10, 20, 30, 40],            ],            [                [-5, 10, -15, 20, -55],            ],            [                [0, 0, 0, 0, 5],            ],            [                [2, 0, 0, 0, 4],            ],            [                [-1, -2, -3, -4, -5, -6, -7, -8, -9],            ],            [                [1, 2, 3, 4, 5, 6, 7, 8, 9],            ],            [                [4, 54, 23, -34, 12, 73, -34, 2],            ],        ];    }    public function dataProviderForTwoPolynomials(): array    {        return [            [                [0],                [0],            ],            [                [1],                [1],            ],            [                [0],                [1],            ],            [                [1],                [0],            ],            [                [2],                [2],            ],            [                [1],                [2],            ],            [                [4],                [8],            ],            [                [1, 5],                [5, 4],            ],            [                [4, 0],                [5, 6],            ],            [                [0, 3],                [5, 5],            ],            [                [12, 4],                [5, 10],            ],            [                [1, 2, 3],                [1, 2, 3],            ],            [                [1, 2, 3],                [2, 3, 4],            ],            [                [1, 1, 1],                [2, 2, 2],            ],            [                [5, 3, 6],                [8, 7, 3],            ],            [                [2, 7, 4],                [5, 4, 7],            ],            [                [6, 0, 3],                [1, 1, 2],            ],            [                [4, 5, 2, 6],                [6, 5, 5, 4],            ],            [                [3, 5, 2, 10],                [2, -2, 5, 3],            ],            [                [-4, 6, 7, -1],                [5, 5, -5, -1],            ],            [                [-2, -1, -4, -3],                [-5, 5, -4, -3],            ],            [                [1],                [5, 3, 6],            ],            [                [7, 6, 6],                [3, 2],            ],            [                [-3, 4, 5, 6],                [-6, -1],            ],            [                [5, 6, 7, 6, 5, 6],                [-5, -5, -1, 2, 4, 6, 5],            ],            [                [10, 20, 30, 40],                [-4, 5, 6, -4, 3],            ],            [                [4, 8, 12, 16, 20],                [-5, 10, -15, 20, -55],            ],            [                [0, 0, 0, 0, 5],                [4, 3, 6, 7],            ],            [                [2, 0, 0, 0, 4],                [1, 1, 1, 1, 1],            ],            [                [1, 2, 3, 4, 5, 6, 7, 8, 9],                [-1, -2, -3, -4, -5, -6, -7, -8, -9],            ],            [                [1, 2, 3, 4, 5, 6, 7, 8, 9],                [2, 3, 4, 5, 6, 7, 8, 9, 10],            ],            [                [34, 65, 34, 23, 62, 87, 34, 65],                [4, 54, 23, -34, 12, 73, -34, 2],            ],        ];    }    public function dataProviderForThreePolynomials(): array    {        return [            [                [0],                [0],                [0],            ],            [                [1],                [1],                [1],            ],            [                [0],                [1],                [0],            ],            [                [1],                [0],                [1],            ],            [                [2],                [2],                [2],            ],            [                [1],                [2],                [3],            ],            [                [4],                [8],                [2],            ],            [                [1, 5],                [5, 4],                [4, 3],            ],            [                [4, 0],                [5, 6],                [6, 5],            ],            [                [0, 3],                [5, 5],                [0, 0],            ],            [                [12, 4],                [5, 10],                [2, 10],            ],            [                [1, 2, 3],                [1, 2, 3],                [1, 2, 3],            ],            [                [1, 2, 3],                [2, 3, 4],                [3, 4, 5],            ],            [                [1, 1, 1],                [2, 2, 2],                [3, 3, 3],            ],            [                [5, 3, 6],                [8, 7, 3],                [3, 2, 7],            ],            [                [2, 7, 4],                [5, 4, 7],                [6, 5, 4],            ],            [                [6, 0, 3],                [1, 1, 2],                [2, 3, 0],            ],            [                [4, 5, 2, 6],                [6, 5, 5, 4],                [2, 2, 3, 3],            ],            [                [3, 5, 2, 10],                [2, -2, 5, 3],                [-1, 3, 4, -1],            ],            [                [-4, 6, 7, -1],                [5, 5, -5, -1],                [6, 5, -4, -3],            ],            [                [-2, -1, -4, -3],                [-5, 5, -4, -3],                [1, -1, 1, -2],            ],            [                [1],                [5, 3, 6],                [3, -2],            ],            [                [7, 6, 6],                [3, 2],                [4],            ],            [                [-3, 4, 5, 6],                [-6, -1],                [5, 6, 4],            ],            [                [5, 6, 7, 6, 5, 6],                [-5, -5, -1, 2, 4, 6, 5],                [5, 5, 5, -6, -6, -4, 3],            ],            [                [10, 20, 30, 40],                [-4, 5, 6, -4, 3],                [-3, -3, -2, 1, 5],            ],            [                [4, 8, 12, 16, 20],                [-5, 10, -15, 20, -55],                [3, 6, 9, -12, -15],            ],            [                [0, 0, 0, 0, 5],                [4, 3, 6, 7],                [6, 0, 0, 0, 0],            ],            [                [2, 0, 0, 0, 4],                [1, 1, 1, 1, 1],                [2, 2, 2, -3, -2]            ],            [                [1, 2, 3, 4, 5, 6, 7, 8, 9],                [-1, -2, -3, -4, -5, -6, -7, -8, -9],                [4, 3, 5, 6],            ],            [                [1, 2, 3, 4, 5, 6, 7, 8, 9],                [2, 3, 4, 5, 6, 7, 8, 9, 10],                [3, 4, 5, 6, 7, 8, 9, 10, 11],            ],            [                [34, 65, 34, 23, 62, 87, 34, 65],                [4, 54, 23, -34, 12, 73, -34, 2],                [34, 23, 12, 63, 24, -42, 12, 4],            ],            [                [1, 2, 3, 4, 5, 6],                [-1, -2, -3, -4, -6],                [0, 0, 0, 0, 0, 0],            ],        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Polynomial_2532, Check that our input is either a number or a Polynomial\n Convert any numbers to Polynomial objects\n\n @param mixed $input The variable to check\n @return Polynomial\n @throws Exception\\IncorrectTypeException\n, Check that our input is either a number or a Polynomial,    private function checkNumericOrPolynomial($input): Polynomial    {        if ($input instanceof Polynomial) {            return $input;        } elseif (\is_numeric($input)) {            return new Polynomial([$input]);        } else {            throw new Exception\IncorrectTypeException('Input must be a Polynomial or a number');        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Polynomial_2538," Calculate the indefinite integral of a polynomial and return it as a new polynomial\\n Example: $polynomial = new Polynomial([3, -16, 12]); // 3x² - 16x + 12\\n          $integral = $polynomial->integrate();       // x³ - 8x² + 12x\\n\\n Note that this method assumes the constant of integration to be 0.\\n\\n @return Polynomial The integral of our polynomial object, also a polynomial object\\n", Calculate the indefinite integral of a polynomial and return it as a new polynomial,"    public function integrate(): Polynomial    {        $integralCoefficients = []; // Start with empty set of coefficients        // Iterate over each coefficient, integrating term-by-term        for ($i = 0; $i < $this->degree + 1; $i++) {            $integralCoefficients[] = $this->coefficients[$i] / ($this->degree - $i + 1);        }        $integralCoefficients[] = 0; // Make the constant of integration 0        return new Polynomial($integralCoefficients);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Polynomial_2541," Return a new polynomial that is the product of the current polynomial and an\n input polynomial\n Example: $polynomial = new Polynomial([2, -16]);          // 2x - 16\n          $integral   = $polynomial->integrate();          // x² - 16x\n          $product    = $polynomial->multiply($integral);  // 2x³ - 48x² + 256x\n\n @param mixed $polynomial The polynomial or scalar we are multiplying with our current polynomial\n\n @return Polynomial The product of our polynomial objects, also a polynomial object\n\n @throws Exception\\IncorrectTypeException\n", Return a new polynomial that is the product of the current polynomial and an,"    public function multiply($polynomial): Polynomial    {        $polynomial = $this->checkNumericOrPolynomial($polynomial);        // Calculate the degree of the product of the polynomials        $productDegree = $this->degree + $polynomial->degree;        // Reverse the coefficients arrays so you can multiply component-wise        $coefficientsA = \array_reverse($this->coefficients);        $coefficientsB = \array_reverse($polynomial->coefficients);        // Start with an array of coefficients that all equal 0        $productCoefficients = \array_fill(0, $productDegree + 1, 0);        // Iterate through the product of terms component-wise        for ($i = 0; $i < $this->degree + 1; $i++) {            for ($j = 0; $j < $polynomial->degree + 1; $j++) {                // Calculate the degree of the current product                $degree = $productDegree - ($i + $j);                // Calculate the product of the coefficients                $product = $coefficientsA[$i] * $coefficientsB[$j];                // Add the product to the existing coefficient of the current degree                $productCoefficients[$degree] = $productCoefficients[$degree] + $product;            }        }        return new Polynomial($productCoefficients);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Polynomial_2543, Calculate the roots of a polynomial\\n\\n Closed form solutions only exist if the degree is less than 5\\n\\n @return array of roots\\n\\n @throws Exception\\\\IncorrectTypeException\\n, Calculate the roots of a polynomial,    public function roots(): array    {        switch ($this->degree) {            case 0:                return [null];            case 1:                return [Algebra::linear(...$this->coefficients)];            case 2:                return Algebra::quadratic(...$this->coefficients);            case 3:                return Algebra::cubic(...$this->coefficients);            case 4:                return Algebra::quartic(...$this->coefficients);            default:                return [\NAN];        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PowerLaw_3589," Power law regression (power curve) - Least squares fitting\n http://mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html\n\n A functional relationship between two quantities,\n where a relative change in one quantity results in a proportional\n relative change in the other quantity,\n independent of the initial size of those quantities: one quantity\n varies as a power of another.\n https://en.wikipedia.org/wiki/Power_law\n\n y = Axᴮ\n\n Using least squares fitting: y = axᵇ\n\n     n∑⟮ln xᵢ ln yᵢ⟯ − ∑⟮ln xᵢ⟯ ∑⟮ln yᵢ⟯\n b = --------------------------------\n           n∑⟮ln xᵢ⟯² − ⟮∑⟮ln xᵢ⟯⟯²\n         _                    _\n        |  ∑⟮ln yᵢ⟯ − b∑⟮ln xᵢ⟯  |\n a = exp|  ------------------  |\n        |_          n         _|\n", Power law regression (power curve) - Least squares fitting,"class PowerLaw extends ParametricRegression{    use Models\PowerModel;    use Methods\LeastSquares;    /** @var float */    protected $a;    /** @var float */    protected $b;    /**     * Calculate the regression parameters by least squares on linearized data     * ln(y) = ln(A) + B*ln(x)     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     * @throws Exception\MathException     */    public function calculate(): void    {        // Linearize the relationship by taking the log of both sides.        $x’ = \array_map('\log', $this->xs);        $y’ = \array_map('\log', $this->ys);        // Perform Least Squares Fit        $linearized_parameters = $this->leastSquares($y’, $x’)->getColumn(0);        // Translate the linearized parameters back.        $this->a = \exp($linearized_parameters[0]);        $this->b = $linearized_parameters[1];        $this->parameters = [$this->a, $this->b];    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PowerLaw_3590, Calculate the regression parameters by least squares on linearized data\n ln(y) = ln(A) + B\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MatrixException\n @throws Exception\\MathException\n, Calculate the regression parameters by least squares on linearized data,"    public function calculate(): void    {        // Linearize the relationship by taking the log of both sides.        $x’ = \array_map('\log', $this->xs);        $y’ = \array_map('\log', $this->ys);        // Perform Least Squares Fit        $linearized_parameters = $this->leastSquares($y’, $x’)->getColumn(0);        // Translate the linearized parameters back.        $this->a = \exp($linearized_parameters[0]);        $this->b = $linearized_parameters[1];        $this->parameters = [$this->a, $this->b];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PowerModel_3640, Get regression equation (y = axᵇ) in format y = ax^b\n\n @param array $params\n\n @return string\n, Get regression equation (y = axᵇ) in format y = ax^b,"    public function getModelEquation(array $params): string    {        return \sprintf('y = %fx^%f', $params[self::$A], $params[self::$B]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_QR_2875, QR Decomposition using Householder reflections\\n\\n A = QR\\n\\n Q is an orthogonal matrix\\n R is an upper triangular matrix\\n\\n @property-read NumericMatrix $Q orthogonal matrix\\n @property-read NumericMatrix $R upper triangular matrix\\n, QR Decomposition using Householder reflections,"class QR extends Decomposition{    /** @var NumericMatrix orthogonal matrix  */    private $Q;    /** @var NumericMatrix upper triangular matrix */    private $R;    /**     * QR constructor     *     * @param NumericMatrix $Q Orthogonal matrix     * @param NumericMatrix $R Upper triangular matrix     */    private function __construct(NumericMatrix $Q, NumericMatrix $R)    {        $this->Q = $Q;        $this->R = $R;    }    /**     * Decompose a matrix into a QR Decomposition using Householder reflections     * Factory method to create QR objects.     *     * A = QR     *     * Q is an orthogonal matrix     * R is an upper triangular matrix     *     * Algorithm notes:     *  If the source matrix is square or wider than it is tall, the final     *  householder matrix will be the identity matrix with a -1 in the bottom     *  corner. The effect of this final transformation would only change signs     *  on existing matrices. Both R and Q will already be in appropriate forms     *  in the next to the last step. We can skip the last transformation without     *  affecting the validity of the results. Results indicate other software     *  behaves similarly.     *     *  This is because on a 1x1 matrix uuᵀ = uᵀu, so I - [[2]] = [[-1]]     *     * @param NumericMatrix $A source Matrix     *     * @return QR     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\VectorException     */    public static function decompose(NumericMatrix $A): QR    {        $n  = $A->getN();  // columns        $m  = $A->getM();  // rows        $HA = $A;        $numReflections = \min($m - 1, $n);        $FullI          = MatrixFactory::identity($m);        $Q              = $FullI;        for ($i = 0; $i < $numReflections; $i++) {            // Remove the leftmost $i columns and upper $i rows            $A = $HA->submatrix($i, $i, $m - 1, $n - 1);            // Create the householder matrix            $innerH = Householder::transform($A);            // Embed the smaller matrix within a full rank Identity matrix            $H  = $FullI->insert($innerH, $i, $i);            $Q  = $Q->multiply($H);            $HA = $H->multiply($HA);        }        $R = $HA;        return new QR(            $Q->submatrix(0, 0, $m - 1, \min($m, $n) - 1),            $R->submatrix(0, 0, \min($m, $n) - 1, $n - 1)        );    }    /**     * Solve linear system of equations     * Ax = b     *  where:     *   A: Matrix     *   x: unknown to solve for     *   b: solution to linear system of equations (input to function)     *     * Use QR Decomposition and solve Ax = b.     *     * QR Decomposition:     *  - Equation to solve: Ax = b     *  - QR Decomposition produces: A = QR     *  - Substitute to get QRx = b     *  - Multiply both sides by Qᵀ to get QᵀQRx = Qᵀb     *  - QᵀQ = I, so we get Rx = Qᵀb     *  - Multiply both sides by R⁻¹ to get R⁻¹Rx = R⁻¹Qᵀb     *  - R⁻¹R = I, so we get x = R⁻¹Qᵀb     * Solve x = R⁻¹Qᵀb     *     * @param Vector|array $b solution to Ax = b     *     * @return Vector x     *     * @throws Exception\IncorrectTypeException if b is not a Vector or array     */    public function solve($b): Vector    {        // Input must be a Vector or array.        if (!($b instanceof Vector || \is_array($b))) {            throw new Exception\IncorrectTypeException('b in Ax = b must be a Vector or array');        }        if (\is_array($b)) {            $b = new Vector($b);        }        $Qᵀ  = $this->Q->transpose();        $Qᵀb = $Qᵀ->multiply($b);        $R⁻¹ = $this->R->inverse();        $x   = $R⁻¹->multiply($Qᵀb);        return new Vector($x->getColumn(0));    }    /**     * Get Q or R matrix     *     * @param string $name     *     * @return NumericMatrix     *     * @throws Exception\MatrixException     */    public function __get(string $name): NumericMatrix    {        switch ($name) {            case 'Q':            case 'R':                return $this->$name;            default:                throw new Exception\MatrixException(""QR class does not have a gettable property: $name"");        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_QR_2877," Decompose a matrix into a QR Decomposition using Householder reflections\n Factory method to create QR objects.\n\n A = QR\n\n Q is an orthogonal matrix\n R is an upper triangular matrix\n\n Algorithm notes:\n  If the source matrix is square or wider than it is tall, the final\n  householder matrix will be the identity matrix with a -1 in the bottom\n  corner. The effect of this final transformation would only change signs\n  on existing matrices. Both R and Q will already be in appropriate forms\n  in the next to the last step. We can skip the last transformation without\n  affecting the validity of the results. Results indicate other software\n  behaves similarly.\n\n  This is because on a 1x1 matrix uuᵀ = uᵀu, so I - [[2]] = [[-1]]\n\n @param NumericMatrix $A source Matrix\n\n @return QR\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MathException\n @throws Exception\\MatrixException\n @throws Exception\\OutOfBoundsException\n @throws Exception\\VectorException\n", Decompose a matrix into a QR Decomposition using Householder reflections,"    public static function decompose(NumericMatrix $A): QR    {        $n  = $A->getN();  // columns        $m  = $A->getM();  // rows        $HA = $A;        $numReflections = \min($m - 1, $n);        $FullI          = MatrixFactory::identity($m);        $Q              = $FullI;        for ($i = 0; $i < $numReflections; $i++) {            // Remove the leftmost $i columns and upper $i rows            $A = $HA->submatrix($i, $i, $m - 1, $n - 1);            // Create the householder matrix            $innerH = Householder::transform($A);            // Embed the smaller matrix within a full rank Identity matrix            $H  = $FullI->insert($innerH, $i, $i);            $Q  = $Q->multiply($H);            $HA = $H->multiply($HA);        }        $R = $HA;        return new QR(            $Q->submatrix(0, 0, $m - 1, \min($m, $n) - 1),            $R->submatrix(0, 0, \min($m, $n) - 1, $n - 1)        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_QR_2878," Solve linear system of equations\\n Ax = b\\n  where:\\n   A: Matrix\\n   x: unknown to solve for\\n   b: solution to linear system of equations (input to function)\\n\\n Use QR Decomposition and solve Ax = b.\\n\\n QR Decomposition:\\n  - Equation to solve: Ax = b\\n  - QR Decomposition produces: A = QR\\n  - Substitute to get QRx = b\\n  - Multiply both sides by Qᵀ to get QᵀQRx = Qᵀb\\n  - QᵀQ = I, so we get Rx = Qᵀb\\n  - Multiply both sides by R⁻¹ to get R⁻¹Rx = R⁻¹Qᵀb\\n  - R⁻¹R = I, so we get x = R⁻¹Qᵀb\\n Solve x = R⁻¹Qᵀb\\n\\n @param Vector|array $b solution to Ax = b\\n\\n @return Vector x\\n\\n @throws Exception\\\\IncorrectTypeException if b is not a Vector or array\\n", Solve linear system of equations,    public function solve($b): Vector    {        // Input must be a Vector or array.        if (!($b instanceof Vector || \is_array($b))) {            throw new Exception\IncorrectTypeException('b in Ax = b must be a Vector or array');        }        if (\is_array($b)) {            $b = new Vector($b);        }        $Qᵀ  = $this->Q->transpose();        $Qᵀb = $Qᵀ->multiply($b);        $R⁻¹ = $this->R->inverse();        $x   = $R⁻¹->multiply($Qᵀb);        return new Vector($x->getColumn(0));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariableTest_6121," Generated with R (e1071) skewness(data, type=2)\\n @return array [X, skewness]\\n"," Generated with R (e1071) skewness(data, type=2)","    public function dataProviderForSkewnessNan(): array    {        return [            [[-1, -1, -1]],            [[10, 10, 10]],            [[0, 0, 0]],            [[10, 10, 10, 10]],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariableTest_6123," Generated with online calculator: http://www.endmemo.com/statistics/skewness.php\\n @return array [X, skewness]\\n", Generated with online calculator: http://www.endmemo.com/statistics/skewness.php,"    public function dataProviderForAlternativeSkewness(): array    {        return [            [ [61,61,61,61,61,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,67,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,73,73,73,73,73,73,73,73], -0.107612 ],            [ [1, 2, 3, 4, 5, 9, 23, 32, 69], 1.514015 ],            [ [5,20,40,80,100], 0.202721 ],            [ [3, 4, 5, 2, 3, 4, 5, 6, 4, 7], 0.287634 ],            [ [1, 1, 3, 4, 5, 6, 7, 8], -0.07413 ],            [ [1,2,3,4,5,6,7,8], 0 ],            [ [13, 18, 13, 14, 13, 16, 14, 21, 13], 1.160097],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariableTest_6135," Generated with R (e1071) kurtosis(data, type=1)\n @return array [X, kurtosis]\n"," Generated with R (e1071) kurtosis(data, type=1)","    public function dataProviderForSampleKurtosis(): array    {        return [            [ [ 1987, 1987, 1991, 1992, 1992, 1992, 1992, 1993, 1994, 1994, 1995 ], -0.2320107 ],            [ [ 0, 7, 7, 6, 6, 6, 5, 5, 4, 1 ], -0.273157 ],            [ [ 2, 2, 4, 6, 8, 10, 10 ], -1.574074 ],            [ [ 1242, 1353, 1142 ], -1.5 ],            [ [1, 2, 3, 4, 5, 9, 23, 32, 69], 1.389416 ],            [ [5,20,40,80,100], -1.525992 ],            [ [4, 5, 5, 5, 5, 6], 0 ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariableTest_6139," Generated with R (e1071) kurtosis(data, type=2)\\n @return array [X, kurtosis]\\n"," Generated with R (e1071) kurtosis(data, type=2)","    public function dataProviderForPopulationKurtosis(): array    {        return [            [ [ 1987, 1987, 1991, 1992, 1992, 1992, 1992, 1993, 1994, 1994, 1995 ],0.4466489 ],            [ [ 0, 7, 7, 6, 6, 6, 5, 5, 4, 1 ], 0.4813832 ],            [ [ 2, 2, 4, 6, 8, 10, 10 ], -1.977778 ],            [ [ 1242, 1353, 1142, 1222 ], 1.397048 ],            [ [1, 2, 3, 4, 5, 9, 23, 32, 69], 3.789364 ],            [ [5,20,40,80,100], -2.103968 ],            [ [4, 5, 5, 5, 5, 6], 2.5 ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariable_3541, Population skewness\n A measure of the asymmetry of the probability distribution of a real-valued random variable about its mean.\n https://en.wikipedia.org/wiki/Skewness\n http://brownmath.com/stat/shape.htm\n\n This method tends to match Excel's SKEW.P function.\n R (e1071) describes it as the typical definition used in many older textbooks (skewness type 1).\n\n         μ₃\n γ₁ = -------\n       μ₂³′²\n\n μ₂ is the second central moment\n μ₃ is the third central moment\n\n @param float[] $X list of numbers (random variable X)\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n, Population skewness,"    public static function populationSkewness(array $X): float    {        if (empty($X)) {            throw new Exception\BadDataException('Cannot find the population skewness of an empty list of numbers');        }        $μ₃ = self::centralMoment($X, 3);        $μ₂ = self::centralMoment($X, 2);        $μ₂³′² = \pow($μ₂, 3 / 2);        if ($μ₂³′² == 0) {            return \NAN;  // Prevents division by zero in μ₃ / μ₂³′² equation        }        return ($μ₃ /  $μ₂³′²);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariable_3542, Sample skewness\\n A measure of the asymmetry of the probability distribution of a real-valued random variable about its mean.\\n https://en.wikipedia.org/wiki/Skewness\\n http://brownmath.com/stat/shape.htm\\n\\n This method tends to match Excel's SKEW function.\\n It also matches what is used in SAS and SPSS. In R (e1071) it is skewness type 2.\\n\\n         μ₃     √(n(n - 1))\\n γ₁ = ------- × -----------\\n       μ₂³′²       n - 2\\n\\n μ₂ is the second central moment\\n μ₃ is the third central moment\\n n is the sample size\\n\\n @param float[] $X list of numbers (random variable X)\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers has less than 3 elements\\n, Sample skewness,"    public static function sampleSkewness(array $X): float    {        $n = \count($X);        if ($n < 3) {            throw new Exception\BadDataException('Cannot find the sample skewness of less than three numbers');        }        $μ₃    = self::centralMoment($X, 3);        $μ₂    = self::centralMoment($X, 2);        $μ₂³′² = \pow($μ₂, 3 / 2);        if ($μ₂³′² == 0) {            return \NAN;  // Prevents division by zero in μ₃ / μ₂³′² equation        }        $√⟮n⟮n − 1⟯⟯ = \sqrt($n * ($n - 1));        return ($μ₃ / $μ₂³′²) * ( $√⟮n⟮n − 1⟯⟯ / ($n - 2) );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariable_3544, Standard Error of Skewness (SES)\\n\\n         _____________________\\n        /      6n(n - 1)\\n SES = / --------------------\\n      √  (n - 2)(n + 1)(n + 3)\\n\\n @param int $n Sample size\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if n < 3\\n, Standard Error of Skewness (SES),"    public static function ses(int $n): float    {        if ($n < 3) {            throw new Exception\BadDataException(""SES requires a dataset of n > 2. N of $n given."");        }        $６n⟮n − 1⟯           = 6 * $n * ($n - 1);        $⟮n − 2⟯⟮n ＋ 1⟯⟮n ＋ 2⟯ = ($n - 2) * ($n + 1) * ($n + 3);        return \sqrt($６n⟮n − 1⟯ / $⟮n − 2⟯⟮n ＋ 1⟯⟮n ＋ 2⟯);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariable_3548, Standard error of the mean (SEM)\n The standard deviation of the sample-mean's estimate of a population mean.\n https://en.wikipedia.org/wiki/Standard_error\n\n       s\n SEₓ = --\n       √n\n\n s = sample standard deviation\n n = size (number of observations) of the sample\n\n @param float[] $X list of numbers (random variable X)\n\n @return float\n\n @throws Exception\\OutOfBoundsException\n @throws Exception\\BadDataException if the input array of numbers is empty\n, Standard error of the mean (SEM),"    public static function standardErrorOfTheMean(array $X): float    {        if (empty($X)) {            throw new Exception\BadDataException('Cannot find the SEM of an empty list of numbers');        }        $s  = Descriptive::standardDeviation($X, Descriptive::SAMPLE);        $√n = \sqrt(\count($X));        return $s / $√n;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariable_3550," Confidence interval\n Finds CI given a sample mean, sample size, and standard deviation.\n Uses Z score.\n https://en.wikipedia.org/wiki/Confidence_interval\n          σ\n ci = z         √n\n\n interval = (μ - ci, μ + ci)\n\n Available confidence levels: See Probability\\StandardNormalTable::Z_SCORES_FOR_CONFIDENCE_INTERVALS\n\n @param float  $μ sample mean\n @param int    $n sample size\n @param float  $σ standard deviation\n @param string $cl confidence level (Ex: 95, 99, 99.5, 99.9, etc.)\n\n @return array [ ci, lower_bound, upper_bound ]\n\n @throws Exception\\BadDataException\n", Confidence interval,"    public static function confidenceInterval(float $μ, int $n, float $σ, string $cl): array    {        if ($n === 0) {            return ['ci' => null, 'lower_bound' => null, 'upper_bound' => null];        }        $z = Table\StandardNormal::getZScoreForConfidenceInterval($cl);        $ci = $z * ($σ / \sqrt($n));        $lower_bound = $μ - $ci;        $upper_bound = $μ + $ci;        return [            'ci'          => $ci,            'lower_bound' => $lower_bound,            'upper_bound' => $upper_bound,        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariable_3551, Sum of squares\n\n ∑⟮xᵢ⟯²\n\n @param float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n, Sum of squares,    public static function sumOfSquares(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the sum of squares of an empty list of numbers');        }         $∑⟮xᵢ⟯² = \array_sum(Map\Single::square($numbers));         return $∑⟮xᵢ⟯²;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RandomVariable_3552, Sum of squares deviations\\n\\n ∑⟮xᵢ - μ⟯²\\n\\n @param  float[] $numbers\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n, Sum of squares deviations,"    public static function sumOfSquaresDeviations(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the sum of squares deviations of an empty list of numbers');        }        $μ         = Average::mean($numbers);        $∑⟮xᵢ − μ⟯² = \array_sum(\array_map(            function ($xᵢ) use ($μ) {                return \pow(($xᵢ - $μ), 2);            },            $numbers        ));        return $∑⟮xᵢ − μ⟯²;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2939," Rational Numbers\n\n https://en.wikipedia.org/wiki/Rational_number\n A rational number can be expressed as a fraction. Using the rational number object allows a user to\n express non-integer values with exact precision, and perform arithmetic without floating point\n errors.\n", Rational Numbers,"class Rational implements ObjectArithmetic{    /** @var int Whole part of the number */    protected $whole;    /** @var int Numerator part of the fractional part */    protected $numerator;    /** @var int Denominator part of the fractional part */    protected $denominator;    /**     * Constructor     *     * @todo  How to handle negative numbers in various positions.     * @param int $w whole part     * @param int $n numerator part     * @param int $d     */    public function __construct(int $w, int $n, int $d)    {        [$w, $n, $d]       = self::normalize($w, $n, $d);        $this->whole       = $w;        $this->numerator   = $n;        $this->denominator = $d;    }    /**     * Zero value: 0/1     *     * @return Rational     */    public static function createZeroValue(): ObjectArithmetic    {        return new Rational(0, 0, 1);    }    /**     * @return int     */    public function getWholePart(): int    {        return $this->whole;    }    /**     * @return int     */    public function getNumerator(): int    {        return $this->numerator;    }    /**     * @return int     */    public function getDenominator(): int    {        return $this->denominator;    }    /**     * String representation of a rational number     * 5 6/7, 456079/13745859, etc.     *     * @return string     */    public function __toString(): string    {        $sign     = '';        $whole    = '';        $fraction = '';        if (Special::sgn($this->whole) === -1 || Special::sgn($this->numerator) === -1) {            $sign = '-';        }        if ($this->whole !== 0) {            $whole = \abs($this->whole);        }        if ($this->numerator !== 0) {            if ($this->whole !== 0) {                $whole .= ' ';            }            $fraction = $this->numeratorToSuperscript() . '/' . $this->denominatorToSubscript();        }        $string = $sign . $whole . $fraction;        if ($string == '') {            $string = '0';        }        return $string;    }    /**     * Convert the numerator to superscript character     *     * @return string     */    private function numeratorToSuperscript(): string    {        return $this->toSuperOrSubscript(            \abs($this->numerator),            ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹']        );    }    /**     * Convert the denominator to subscript character     *     * @return string     */    private function denominatorToSubscript(): string    {        return $this->toSuperOrSubscript(            $this->denominator,            ['₀', '₁', '₂', '₃', '₄', '₅', '₆', '₇', '₈', '₉']        );    }    /**     * Convert a character to an alternate script (super or subscript)     *     * @param int   $i     number to convert     * @param array $chars conversion character map     *     * @return string     */    private function toSuperOrSubscript(int $i, array $chars): string    {        $return_string   = '';        $number_of_chars = \floor(\log10($i) + 1);        $working_value   = $i;        for ($j = $number_of_chars - 1; $j >= 0; $j--) {            $int = \intdiv($working_value, 10 ** $j);            $return_string .= $chars[$int];            $working_value -= $int * 10 ** $j;        }        return $return_string;    }    /**     * Rational number as a float     *     * @return float     */    public function toFloat(): float    {        $frac = $this->numerator / $this->denominator;        $sum  = $this->whole + $frac;        return $sum;    }    /**************************************************************************     * UNARY FUNCTIONS     **************************************************************************/    /**     * The absolute value of a rational number     *     * @return Rational     */    public function abs(): Rational    {        return new Rational(\abs($this->whole), \abs($this->numerator), \abs($this->denominator));    }    /**     * Inverse of a rational number     *     * @return Rational     *     * @throws Exception\DivisionByZeroException if R is zero     */    public function inverse(): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        if ($w == 0 && $n == 0) {            throw new Exception\DivisionByZeroException('Cannot take the inverse of zero.');        }        return new Rational(0, $d, $d * $w + $n);    }    /**************************************************************************     * BINARY FUNCTIONS     **************************************************************************/    /**     * Addition     *     * @param Rational|int $r     *     * @return Rational     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Rational.     */    public function add($r): Rational    {        if (\is_int($r)) {            return $this->addInt($r);        } elseif ($r instanceof Rational) {            return $this->addRational($r);        } else {            throw new Exception\IncorrectTypeException('Argument must be an integer or RationalNumber');        }    }    /**     * Add an integer     *     * @param int $int     *     * @return Rational     */    private function addInt(int $int): Rational    {        $w = $this->whole + $int;        return new Rational($w, $this->numerator, $this->denominator);    }    /**     * Add a rational number     *     * @param Rational $r     *     * @return Rational     */    private function addRational(Rational $r): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        $rn = $r->numerator;        $rd = $r->denominator;        $rw = $r->whole;        $w += $rw;        $lcm = Algebra::lcm($d, $rd);        $n = $n * \intdiv($lcm, $d) + $rn * \intdiv($lcm, $rd);        $d = $lcm;        return new Rational($w, $n, $d);    }    /**     * Subtraction     *     * @param Rational|int $r     *     * @return Rational     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Rational.     */    public function subtract($r): Rational    {        if (\is_int($r)) {            return $this->add(-1 * $r);        } elseif ($r instanceof Rational) {            return $this->add($r->multiply(-1));        } else {            throw new Exception\IncorrectTypeException('Argument must be an integer or RationalNumber');        }    }    /**     * Multiply     * Return the result of multiplying two rational numbers, or a rational number and an integer.     *     * @param Rational|int $r     *     * @return Rational     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Rational.     */    public function multiply($r): Rational    {        if (\is_int($r)) {            return $this->multiplyInt($r);        } elseif ($r instanceof Rational) {            return $this->multiplyRational($r);        } else {            throw new Exception\IncorrectTypeException('Argument must be an integer or RationalNumber');        }    }    /**     * Multiply an integer     *     * @param int $int     *     * @return Rational     */    private function multiplyInt(int $int): Rational    {        $w = $this->whole * $int;        $n = $this->numerator * $int;        return new Rational($w, $n, $this->denominator);    }    /**     * Multiply a rational number     *     * @param Rational $r     *     * @return Rational     */    private function multiplyRational(Rational $r): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        $w2 = $r->whole;        $n2 = $r->numerator;        $d2 = $r->denominator;        $new_w = $w * $w2;        $new_n = $w * $n2 * $d + $w2 * $n * $d2 + $n2 * $n;        $new_d = $d * $d2;        return new Rational($new_w, $new_n, $new_d);    }    /**     * Divide     * Return the result of dividing two rational numbers, or a rational number by an integer.     *     * @param Rational|int $r     *     * @return Rational     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Rational.     */    public function divide($r): Rational    {        if (\is_int($r)) {            return $this->divideInt($r);        } elseif ($r instanceof Rational) {            return $this->divideRational($r);        } else {            throw new Exception\IncorrectTypeException('Argument must be an integer or RationalNumber');        }    }    /**     * Divide by an integer     *     * @param int $int     *     * @return Rational     */    private function divideInt(int $int): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        return new Rational(0, $w * $d + $n, $int * $d);    }    /**     * Divide by a rational number     *     * @param Rational $r     *     * @return Rational     */    private function divideRational(Rational $r): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        $w2 = $r->whole;        $n2 = $r->numerator;        $d2 = $r->denominator;        $new_w = 0;        $new_n = $d2 * ($w * $d + $n);        $new_d = $d * ($w2 * $d2 + $n2);        return new Rational($new_w, $new_n, $new_d);    }    /**     * A rational number raised to an integer exponent     *     * @param int $p The exponent     *     * @return Rational Exponentiation     *     * @throws Exception\DivisionByZeroException if R is 0 and it is raised to a negative power     */    public function pow(int $p): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        if ($p < 0) {            if ($w == 0 && $n == 0) {                throw new Exception\DivisionByZeroException('Cannot raise zero to a negative exponent.');            }            $p = \abs($p);            return new Rational(0, $d ** $p, ($d * $w + $n) ** $p);        } else {            return new Rational(0, ($d * $w + $n) ** $p, $d ** $p);        }    }    /**************************************************************************     * COMPARISON FUNCTIONS     **************************************************************************/    /**     * Test for equality     *     * Two normalized RationalNumbers are equal IFF all three parts are equal.     *     * @param Rational $rn     *     * @return bool     */    public function equals(Rational $rn): bool    {        return $this->whole       == $rn->whole        &&               $this->numerator   == $rn->numerator    &&               $this->denominator == $rn->denominator;    }    /**     * Normalize the input     *     * We want to ensure that the format of the data in the object is correct.     * We will ensure that the numerator is smaller than the denominator, the sign     * of the denominator is always positive, and the signs of the numerator and     * whole number match.     *     * @param int $w whole number     * @param int $n numerator     * @param int $d denominator     *     * @return array     */    private function normalize(int $w, int $n, int $d): array    {        if ($d == 0) {            throw new Exception\BadDataException('Denominator cannot be zero');        }        // Make sure $d is positive        if ($d < 0) {            $n *= -1;            $d *= -1;        }        // Reduce the fraction        if (\abs($n) >= $d) {            $w += \intdiv($n, $d);            $n = $n % $d;        }        $gcd = 0;        while ($gcd != 1 && $n !== 0) {            $gcd = \abs(Algebra::gcd($n, $d));            $n /= $gcd;            $d /= $gcd;        }        // Make the signs of $n and $w match        if (Special::sgn($w) !== Special::sgn($n) && $w !== 0 && $n !== 0) {            $w = $w - Special::sgn($w);            $n = ($d - \abs($n)) * Special::sgn($w);        }        if ($n == 0) {            $d = 1;        }        return [$w, $n, $d];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2946, Convert the numerator to superscript character\n\n @return string\n, Convert the numerator to superscript character,"    private function numeratorToSuperscript(): string    {        return $this->toSuperOrSubscript(            \abs($this->numerator),            ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹']        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2948, Convert a character to an alternate script (super or subscript)\n\n @param int   $i     number to convert\n @param array $chars conversion character map\n\n @return string\n, Convert a character to an alternate script (super or subscript),"    private function toSuperOrSubscript(int $i, array $chars): string    {        $return_string   = '';        $number_of_chars = \floor(\log10($i) + 1);        $working_value   = $i;        for ($j = $number_of_chars - 1; $j >= 0; $j--) {            $int = \intdiv($working_value, 10 ** $j);            $return_string .= $chars[$int];            $working_value -= $int * 10 ** $j;        }        return $return_string;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2949, Rational number as a float\\n\\n @return float\\n, Rational number as a float,    public function toFloat(): float    {        $frac = $this->numerator / $this->denominator;        $sum  = $this->whole + $frac;        return $sum;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2951, Inverse of a rational number\\n\\n @return Rational\\n\\n @throws Exception\\\\DivisionByZeroException if R is zero\\n, Inverse of a rational number,"    public function inverse(): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        if ($w == 0 && $n == 0) {            throw new Exception\DivisionByZeroException('Cannot take the inverse of zero.');        }        return new Rational(0, $d, $d * $w + $n);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2952, Addition\\n\\n @param Rational|int $r\\n\\n @return Rational\\n\\n @throws Exception\\\\IncorrectTypeException if the argument is not numeric or Rational.\\n, Addition,    public function add($r): Rational    {        if (\is_int($r)) {            return $this->addInt($r);        } elseif ($r instanceof Rational) {            return $this->addRational($r);        } else {            throw new Exception\IncorrectTypeException('Argument must be an integer or RationalNumber');        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2954, Add a rational number\\n\\n @param Rational $r\\n\\n @return Rational\\n, Add a rational number,"    private function addRational(Rational $r): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        $rn = $r->numerator;        $rd = $r->denominator;        $rw = $r->whole;        $w += $rw;        $lcm = Algebra::lcm($d, $rd);        $n = $n * \intdiv($lcm, $d) + $rn * \intdiv($lcm, $rd);        $d = $lcm;        return new Rational($w, $n, $d);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2957, Multiply an integer\n\n @param int $int\n\n @return Rational\n, Multiply an integer,"    private function multiplyInt(int $int): Rational    {        $w = $this->whole * $int;        $n = $this->numerator * $int;        return new Rational($w, $n, $this->denominator);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2958, Multiply a rational number\n\n @param Rational $r\n\n @return Rational\n, Multiply a rational number,"    private function multiplyRational(Rational $r): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        $w2 = $r->whole;        $n2 = $r->numerator;        $d2 = $r->denominator;        $new_w = $w * $w2;        $new_n = $w * $n2 * $d + $w2 * $n * $d2 + $n2 * $n;        $new_d = $d * $d2;        return new Rational($new_w, $new_n, $new_d);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2959," Divide\\n Return the result of dividing two rational numbers, or a rational number by an integer.\\n\\n @param Rational|int $r\\n\\n @return Rational\\n\\n @throws Exception\\\\IncorrectTypeException if the argument is not numeric or Rational.\\n", Divide,    public function divide($r): Rational    {        if (\is_int($r)) {            return $this->divideInt($r);        } elseif ($r instanceof Rational) {            return $this->divideRational($r);        } else {            throw new Exception\IncorrectTypeException('Argument must be an integer or RationalNumber');        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2960, Divide by an integer\n\n @param int $int\n\n @return Rational\n, Divide by an integer,"    private function divideInt(int $int): Rational    {        $w = $this->whole;        $n = $this->numerator;        $d = $this->denominator;        return new Rational(0, $w * $d + $n, $int * $d);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Regression_3595, Get points\n\n @return array\n, Get points,    public function getPoints(): array    {        return $this->points;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Regression_3598, Get sample size (number of points)\n\n @return int\n, Get sample size (number of points),    public function getSampleSize(): int    {        return $this->n;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RegularGridInterpolator_2999, Count dimensions of a multi-dimensional array\n\n @param  array $array\n\n @return int\n, Count dimensions of a multi-dimensional array,    private function countDimensions(array $array): int    {        if (\is_array(\reset($array))) {            $return = $this->countDimensions(\reset($array)) + 1;        } else {            $return = 1;        }        return $return;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RegularGridInterpolator_3005," Find the cartesian product from the given iterator.\n Output is lexicographic ordered\n\n @param mixed ...$args ...$iterables[, $repeat]\n\n @return \\Generator\n", Find the cartesian product from the given iterator.,"    private function product(...$args): \Generator    {        $repeat = \array_pop($args);        $pools  = \array_merge(...\array_fill(0, $repeat, $args));        $result = [[]];        foreach ($pools as $pool) {            $result_inner = [];            foreach ($result as $x) {                foreach ($pool as $y) {                    $result_inner[] = \array_merge($x, [$y]);                }            }            $result = $result_inner;        }        foreach ($result as $prod) {            yield $prod;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RowEchelonForm_2886, Get number of row swaps when computing REF\\n\\n @return int\\n, Get number of row swaps when computing REF,    public function getRowSwaps(): int    {        return $this->swaps;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RowEchelonForm_2888," Reduce a matrix to row echelon form\\n Factory method to create a RowEchelonForm matrix\\n\\n First tries Guassian elimination.\\n If that fails (singular matrix), uses custom row reduction algorithm\\n\\n @param NumericMatrix $A\\n\\n @return RowEchelonForm\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\MatrixException\\n", Reduce a matrix to row echelon form,"    public static function reduce(NumericMatrix $A): RowEchelonForm    {        try {            [$R, $ref_swaps] = self::gaussianElimination($A);        } catch (Exception\SingularMatrixException $e) {            [$R, $ref_swaps] = self::rowReductionToEchelonForm($A);        }        $ref = new RowEchelonForm($R, $ref_swaps);        $ref->setError($A->getError());        return $ref;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SearchTest_5642, Test data created with Python NumPy nanargmax\\n @return array\\n, Test data created with Python NumPy nanargmax,"    public function dataProviderForNanArgMaxWithNans(): array    {        return [            [[0, 1, 2, 3, \NAN], 3],            [[0, 1, 2, \NAN, 3], 4],            [[0, 1, \NAN, 2, 3], 4],            [[0, \NAN, 1, 2, 3], 4],            [[\NAN, 0, 1, 2, 3], 4],            [[\NAN, 0, \NAN, 1, 2, 3], 5],            [[\NAN, \INF], 1],            [[\INF, \NAN], 0],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Search_2507, Search\n Various functions to find specific indices in an array.\n, Search,"class Search{    /**     * Search Sorted     * Find the array indices where items should be inserted to maintain sorted order.     *     * Inspired by and similar to Python NumPy's searchsorted     *     * @param float[]|int[] $haystack Sorted array with standard increasing numerical array keys     * @param float         $needle   Item wanting to insert     *     * @return int Index of where you would insert the needle and maintain sorted order     */    public static function sorted(array $haystack, float $needle): int    {        if (empty($haystack)) {            return 0;        }        $index = 0;        foreach ($haystack as $i => $val) {            if ($needle > $val) {                $index++;            } else {                return $index;            }        }        return $index;    }    /**     * ArgMax     * Find the array index of the maximum value.     *     * In case of the maximum value appearing multiple times, the index of the first occurrence is returned.     * In the case NAN is present, the index of the first NAN is returned.     *     * Inspired by and similar to Python NumPy's argmax     *     * @param float[]|int[] $values     *     * @return int Index of the first occurrence of the maximum value     *     * @throws Exception\BadDataException if the array of values is empty     */    public static function argMax(array $values): int    {        if (empty($values)) {            throw new Exception\BadDataException('Cannot find the argMax of an empty array');        }        // Special case: NAN wins if present        $nanPresent = \array_filter(            $values,            function ($value) {                return \is_float($value) && \is_nan($value);            }        );        if (\count($nanPresent) > 0) {            foreach ($values as $i => $v) {                if (\is_nan($v)) {                    return $i;                }            }        }        // Standard case: Find max and return index        return self::baseArgMax($values);    }    /**     * NanArgMax     * Find the array index of the maximum value, ignoring NANs     *     * In case of the maximum value appearing multiple times, the index of the first occurrence is returned.     *     * Inspired by and similar to Python NumPy's nanargmax     *     * @param float[]|int[] $values     *     * @return int Index of the first occurrence of the maximum value     *     * @throws Exception\BadDataException if the array of values is empty     * @throws Exception\BadDataException if the array only contains NANs     */    public static function nanArgMax(array $values): int    {        if (empty($values)) {            throw new Exception\BadDataException('Cannot find the argMax of an empty array');        }        $valuesWithoutNans = \array_filter(            $values,            function ($value) {                return !\is_nan($value);            }        );        if (\count($valuesWithoutNans) === 0) {            throw new Exception\BadDataException('Array of all NANs has no nanArgMax');        }        return self::baseArgMax($valuesWithoutNans);    }    /**     * Base argMax calculation     * Find the array index of the maximum value.     *     * In case of the maximum value appearing multiple times, the index of the first occurrence is returned.     *     * @param float[]|int[] $values     *     * @return int Index of the first occurrence of the maximum value     */    private static function baseArgMax(array $values): int    {        $max = \max($values);        foreach ($values as $i => $v) {            if ($v === $max) {                return $i;            }        }    }    /**     * ArgMin     * Find the array index of the minimum value.     *     * In case of the minimum value appearing multiple times, the index of the first occurrence is returned.     * In the case NAN is present, the index of the first NAN is returned.     *     * Inspired by and similar to Python NumPy's argmin     *     * @param float[]|int[] $values     *     * @return int Index of the first occurrence of the minimum value     *     * @throws Exception\BadDataException if the array of values is empty     */    public static function argMin(array $values): int    {        if (empty($values)) {            throw new Exception\BadDataException('Cannot find the argMin of an empty array');        }        // Special case: NAN wins if present        $nanPresent = \array_filter(            $values,            function ($value) {                return \is_float($value) && \is_nan($value);            }        );        if (\count($nanPresent) > 0) {            foreach ($values as $i => $v) {                if (\is_nan($v)) {                    return $i;                }            }        }        // Standard case: Find max and return index        return self::baseArgMin($values);    }    /**     * NanArgMin     * Find the array index of the minimum value, ignoring NANs     *     * In case of the minimum value appearing multiple times, the index of the first occurrence is returned.     *     * Inspired by and similar to Python NumPy's nanargin     *     * @param float[]|int[] $values     *     * @return int Index of the first occurrence of the minimum value     *     * @throws Exception\BadDataException if the array of values is empty     * @throws Exception\BadDataException if the array only contains NANs     */    public static function nanArgMin(array $values): int    {        if (empty($values)) {            throw new Exception\BadDataException('Cannot find the nanArgMin of an empty array');        }        $valuesWithoutNans = \array_filter(            $values,            function ($value) {                return !\is_nan($value);            }        );        if (\count($valuesWithoutNans) === 0) {            throw new Exception\BadDataException('Array of all NANs has no nanArgMax');        }        return self::baseArgMin($valuesWithoutNans);    }    /**     * Base argMin calculation     * Find the array index of the minimum value.     *     * In case of the maximum value appearing multiple times, the index of the first occurrence is returned.     *     * @param float[]|int[] $values     *     * @return int Index of the first occurrence of the minimum value     */    private static function baseArgMin(array $values): int    {        $max = \min($values);        foreach ($values as $i => $v) {            if ($v === $max) {                return $i;            }        }    }    /**     * NonZero     * Find the array indices of the scalar values that are non-zero.     *     * Considered 0:     *  int 0, -0     *  float 0.0, -0.0     *  string 0, -0, 0.0, -0.0     *  bool false     *     * Inspired by Python NumPy's nonzero     *     * @param float[]|int[] $values     *     * @return int[]     */    public static function nonZero(array $values): array    {        $indices = [];        foreach ($values as $i => $v) {            if (!\is_scalar($v)) {                continue;            }            if ($v != 0) {                $indices[] = $i;            }        }        return $indices;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Search_2511," Base argMax calculation\\n Find the array index of the maximum value.\\n\\n In case of the maximum value appearing multiple times, the index of the first occurrence is returned.\\n\\n @param float[]|int[] $values\\n\\n @return int Index of the first occurrence of the maximum value\\n", Base argMax calculation,    private static function baseArgMax(array $values): int    {        $max = \max($values);        foreach ($values as $i => $v) {            if ($v === $max) {                return $i;            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Search_2512," ArgMin\n Find the array index of the minimum value.\n\n In case of the minimum value appearing multiple times, the index of the first occurrence is returned.\n In the case NAN is present, the index of the first NAN is returned.\n\n Inspired by and similar to Python NumPy's argmin\n\n @param float[]|int[] $values\n\n @return int Index of the first occurrence of the minimum value\n\n @throws Exception\\BadDataException if the array of values is empty\n", ArgMin,"    public static function argMin(array $values): int    {        if (empty($values)) {            throw new Exception\BadDataException('Cannot find the argMin of an empty array');        }        // Special case: NAN wins if present        $nanPresent = \array_filter(            $values,            function ($value) {                return \is_float($value) && \is_nan($value);            }        );        if (\count($nanPresent) > 0) {            foreach ($values as $i => $v) {                if (\is_nan($v)) {                    return $i;                }            }        }        // Standard case: Find max and return index        return self::baseArgMin($values);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Search_2515," NonZero\\n Find the array indices of the scalar values that are non-zero.\\n\\n Considered 0:\\n  int 0, -0\\n  float 0.0, -0.0\\n  string 0, -0, 0.0, -0.0\\n  bool false\\n\\n Inspired by Python NumPy's nonzero\\n\\n @param float[]|int[] $values\\n\\n @return int[]\\n", NonZero,    public static function nonZero(array $values): array    {        $indices = [];        foreach ($values as $i => $v) {            if (!\is_scalar($v)) {                continue;            }            if ($v != 0) {                $indices[] = $i;            }        }        return $indices;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SecantMethod_3041," Secant Method (also known as the Newton–Raphson method)\\n\\n In numerical analysis, the Secant Method is a method for finding successively\\n better approximations to the roots (or zeroes) of a real-valued function. It is\\n a variation of Newton's Method that we can utilize when the derivative of our\\n function f'(x) is not explicity given or cannot be calculated.\\n\\n https://en.wikipedia.org/wiki/Secant_method\\n", Secant Method (also known as the Newton–Raphson method),"class SecantMethod{    /**     * Use the Secant Method to find the x which produces $f(x) = 0 by calculating     * the average change between our initial approximations and moving our     * approximations closer to the root.     *     * @param callable $function f(x) callback function     * @param number   $p₀       First initial approximation     * @param number   $p₁       Second initial approximation     * @param number   $tol      Tolerance; How close to the actual solution we would like.     *     * @return number     *     * @throws Exception\OutOfBoundsException if $tol (the tolerance) is negative     * @throws Exception\BadDataException if $p₀ = $p₁     */    public static function solve(callable $function, $p₀, $p₁, $tol)    {        Validation::tolerance($tol);        Validation::interval($p₀, $p₁);        do {            $q₀    = $function($p₀);            $q₁    = $function($p₁);            $slope = ($q₁ - $q₀) / ($p₁ - $p₀);            $p     = $p₁ - ($q₁ / $slope);            $dif   = \abs($p - $p₁);            $p₀    = $p₁;            $p₁    = $p;        } while ($dif > $tol);        return $p;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SetAxiomsTest_5705," Tests of Set axioms\n These tests don't test specific functions,\n but rather set axioms which in term make use of multiple functions.\n If all the set logic is implemented properly, these tests should\n all work out according to the axioms.\n\n Axioms tested:\n  - Subsets\n    - Ø ⊆ A\n    - A ⊆ A\n    - A = B iff A ⊆ B and B ⊆ A\n  - Union\n    - A ∪ B = B ∪ A\n    - A ∪ (B ∪ C) = (A ∪ B) ∪ C\n    - A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)\n    - A ∪ (A ∩ B) = A\n    - A ⊆ (A ∪ B)\n    - A ∪ A = A\n    - A ∪ Ø = A\n    - |A ∪ B| = |A| + |B| - |A ∩ B|\n  - Intersection\n    - A ∩ B = B ∩ A\n    - A ∩ (B ∩ C) = (A ∩ B) ∩ C\n    - A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)\n    - A ∩ (A ∪ B) = A\n    - (A ∩ B) ⊆ A\n    - A ∩ A = A\n    - A ∩ Ø = Ø\n  - Complement (difference)\n    - A ∖ B ≠ B ∖ A for A ≠ B\n    - A ∖ A = Ø\n  - Symmetric difference\n    - A Δ B = (A ∖ B) ∪ (B ∖ A)\n  - Cartesian product\n    - A × Ø = Ø\n    - A × (B ∪ C) = (A × B) ∪ (A × C)\n    - (A ∪ B) × C = (A × C) ∪ (B × C)\n    - |A × B| = |A|   - Power set\n    - |S| = n, then |P(S)| = 2ⁿ\n", Tests of Set axioms,"class SetAxiomsTest extends \PHPUnit\Framework\TestCase{    /**     * @test Axiom: Ø ⊆ A     * The empty set is a subset of every set     * @dataProvider dataProviderForSingleSet     */    public function testEmptySetSubsetOfEverySet(Set $A)    {        // Given        $Ø = new Set();        // When        $isSubset = $Ø->isSubset($A);        // Then        $this->assertTrue($isSubset);    }    /**     * @test Axiom: A ⊆ A     * Every set is a subset of itself     * @dataProvider dataProviderForSingleSet     */    public function testSetIsSubsetOfItself(Set $A)    {        // When        $isSubset = $A->isSubset($A);        // Then        $this->assertTrue($isSubset);    }    /**     * @test Axiom: A = B iff A ⊆ B and B ⊆ A     * Sets are equal if and only if they are both subsets of each other.     * @dataProvider dataProviderForSingleSet     */    public function testEqualSetsAreSubsetsInBothDirections(Set $A)    {        // Given        $B = $A;        $this->assertEquals($A, $A);        // Then        $this->assertTrue($A->isSubset($B));        $this->assertTrue($B->isSubset($A));    }    public function dataProviderForSingleSet(): array    {        return [            [new Set([])],            [new Set([0])],            [new Set([1])],            [new Set([5])],            [new Set([-5])],            [new Set([1, 2])],            [new Set([1, 2, 3])],            [new Set([1, -2, 3])],            [new Set([1, 2, 3, 4, 5, 6])],            [new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])],            [new Set([1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 2, 2.01, 2.001, 2.15])],            [new Set(['a'])],            [new Set(['a', 'b'])],            [new Set(['a', 'b', 'c', 'd', 'e'])],            [new Set([1, 2, 'a', 'b', 3.14, 'hello', 'goodbye'])],            [new Set([1, 2, 3, new Set([1, 2]), 'a', 'b'])],            [new Set(['a', 1, 'b', new Set([1, 'b']), new Set([3, 4, 5]), '4', 5])],            [new Set(['a', 1, 'b', new Set([1, 'b']), new Set([3, 4, 5]), '4', 5, new Set([3, 4, 5, new Set([1, 2])])])],        ];    }    /**     * @test Axiom: A ∪ B = B ∪ A     * Union is commutative     *     * @dataProvider dataProviderForTwoSets     * @param        Set $A     * @param        Set $B     */    public function testUnionCommutative(Set $A, Set $B)    {        // Given        $A∪B = $A->union($B);        $B∪A = $B->union($A);        // Then        $this->assertEquals($A∪B, $B∪A);        $this->assertEquals($A∪B->asArray(), $B∪A->asArray());    }    public function dataProviderForTwoSets(): array    {        return [            [                new Set([]),                new Set([]),            ],            [                new Set([1]),                new Set([]),            ],            [                new Set([]),                new Set([1]),            ],            [                new Set([1]),                new Set([1]),            ],            [                new Set([1]),                new Set([2]),            ],            [                new Set([2]),                new Set([1]),            ],            [                new Set([1]),                new Set([2]),            ],            [                new Set([2]),                new Set([1]),            ],            [                new Set([1, 2, 3, 'a', 'b']),                new Set([1, 'a', 'k']),            ],            [                new Set([1, 2, 3, 'a', 'b', new Set([1, 2])]),                new Set([1, 'a', 'k']),            ],            [                new Set([1, 2, 3, 'a', 'b']),                new Set([1, 'a', 'k', new Set([1, 2])]),            ],            [                new Set([1, 2, 3, 'a', 'b', new Set()]),                new Set([1, 'a', 'k', new Set([1, 2])]),            ],            [                new Set([1, 2, 3, 'a', 'b', new Set([1, 2])]),                new Set([1, 'a', 'k', -2, '2.4', 3.5, new Set([1, 2])]),            ],        ];    }    /**     * @test Axiom: A ∪ (B ∪ C) = (A ∪ B) ∪ C     * Unsion is associative     *     * @dataProvider dataProviderForThreeSets     * @param        Set $A     * @param        Set $B     * @param        Set $C     */    public function testUnsionAssociative(Set $A, Set $B, Set $C)    {        // Given        $A∪⟮B∪C⟯ = $A->union($B->union($C));        $⟮A∪B⟯∪C = $A->union($B)->union($C);        // Then        $this->assertEquals($A∪⟮B∪C⟯, $⟮A∪B⟯∪C);        $this->assertEquals($A∪⟮B∪C⟯->asArray(), $⟮A∪B⟯∪C->asArray());    }    /**     * @test Axiom: A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)     * Union is distributive     *     * @dataProvider dataProviderForThreeSets     * @param        Set $A     * @param        Set $B     * @param        Set $C     */    public function testUnionDistributive(Set $A, Set $B, Set $C)    {        // Given        $A∪⟮B∩C⟯    = $A->union($B->intersect($C));        $⟮A∪B⟯∩⟮A∪C⟯ = $A->union($B)->intersect($A->union($C));        // Then        $this->assertEquals($A∪⟮B∩C⟯, $⟮A∪B⟯∩⟮A∪C⟯);        $this->assertEquals($A∪⟮B∩C⟯->asArray(), $⟮A∪B⟯∩⟮A∪C⟯->asArray());    }    /**     * @test Axiom: A ∪ (A ∩ B) = A     * Union absorbtion law     *     * @dataProvider dataProviderForTwoSets     * @param        Set $A     * @param        Set $B     */    public function testUnionAbsorbtion(Set $A, Set $B)    {        // Given        $A∪⟮B∩C⟯ = $A->union($A->intersect($B));        // Then        $this->assertEquals($A, $A∪⟮B∩C⟯);        $this->assertEquals($A->asArray(), $A∪⟮B∩C⟯->asArray());    }    /**     * @test Axiom: A ⊆ (A ∪ B)     * A is a subset of A union B     *     * @dataProvider dataProviderForTwoSets     * @param        Set $A     * @param        Set $B     */    public function testAIsSubsetOfAUnionB(Set $A, Set $B)    {        // Given        $A∪B = $A->union($B);        // Then        $this->assertTrue($A->isSubset($A∪B));        $this->assertTrue($B->isSubset($A∪B));    }    /**     * @test Axiom: A ∪ A = A     * A union A equals A     *     * @dataProvider dataProviderForSingleSet     * @param       Set $A     */    public function testAUnionAEqualsA(Set $A)    {        // Given        $A∪A = $A->union($A);        // Then        $this->assertEquals($A, $A∪A);        $this->assertEquals($A->asArray(), $A∪A->asArray());    }    /**     * @test Axiom: A ∪ Ø = A     * A union empty set is A     *     * @dataProvider dataProviderForSingleSet     * @param        Set $A     */    public function testAUnionEmptySetEqualsA(Set $A)    {        // Given        $Ø   = new Set();        $A∪Ø = $A->union($Ø);        // Then        $this->assertEquals($A, $A∪Ø);        $this->assertEquals($A->asArray(), $A∪Ø->asArray());    }    /**     * @test Axiom: |A ∪ B| = |A| + |B| - |A ∩ B|     * The cardinality (count) of unsion of A and B is equal to the cardinality of A + B minus the cardinality of A intersection B     *     * @dataProvider dataProviderForTwoSets     * @param        Set $A     * @param        Set $B     */    public function testCardinalityOfUnion(Set $A, Set $B)    {        // Given        $A∪B = $A->union($B);        $A∩B = $A->intersect($B);        // Then        $this->assertEquals(count($A) + count($B) - count($A∩B), count($A∪B));        $this->assertEquals(count($A->asArray()) + count($B->asArray()) - count($A∩B->asArray()), count($A∪B->asArray()));    }    public function dataProviderForThreeSets(): array    {        return [            [                new Set([]),                new Set([]),                new Set([]),            ],            [                new Set([1]),                new Set([]),                new Set([]),            ],            [                new Set([]),                new Set([]),                new Set([1]),            ],            [                new Set([1]),                new Set([1]),                new Set([1]),            ],            [                new Set([1]),                new Set([2]),                new Set([2]),            ],            [                new Set([2]),                new Set([1]),                new Set([1]),            ],            [                new Set([1]),                new Set([2]),                new Set([3]),            ],            [                new Set([2]),                new Set([1]),                new Set([1, 4]),            ],            [                new Set([1, 2, 3, 'a', 'b']),                new Set([1, 'a', 'k']),                new Set([1, 9]),            ],            [                new Set([1, 2, 3, 'a', 'b', new Set([1, 2])]),                new Set([1, 'a', 'k']),                new Set([34, 40]),            ],            [                new Set([1, 2, 3, 'a', 'b']),                new Set([1, 'a', 'k', new Set([1, 2])]),                new Set([1, 9, 33]),            ],            [                new Set([1, 2, 3, 'a', 'b', new Set()]),                new Set([1, 'a', 'k', new Set([1, 2])]),                new Set([1, new Set([1, 2])]),            ],            [                new Set([1, 2, 3, 'a', 'b', new Set([1, 2])]),                new Set([1, 'a', 'k', -2, '2.4', 3.5, new Set([1, 2])]),                new Set([1, new Set([1, 2])], 99),            ],        ];    }    /**     * @test Axiom: A ∩ B = B ∩ A     * Intersection is commutative     *     * @dataProvider dataProviderForTwoSets     * @param        Set $A     * @param        Set $B     */    public function testIntersectionCommutative(Set $A, Set $B)    {        // Given        $A∩B = $A->intersect($B);        $B∩A = $B->intersect($A);        // Then        $this->assertEquals($A∩B, $B∩A);        $this->assertEquals($A∩B->asArray(), $B∩A->asArray());    }    /**     * @test Axiom: A ∩ (B ∩ C) = (A ∩ B) ∩ C     * Intersection is associative     *     * @dataProvider dataProviderForThreeSets     * @param        Set $A     * @param        Set $B     * @param        Set $C     */    public function testIntersectionAssociative(Set $A, Set $B, Set $C)    {        // Given        $A∩⟮B∩C⟯ = $A->intersect($B->intersect($C));        $⟮A∩B⟯∩C = $A->intersect($B)->intersect($C);        // Then        $this->assertEquals($A∩⟮B∩C⟯, $⟮A∩B⟯∩C);        $this->assertEquals($A∩⟮B∩C⟯->asArray(), $⟮A∩B⟯∩C->asArray());    }    /**     * @test Axiom: A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)     * Intersection is distributive     *     * @dataProvider dataProviderForThreeSets     * @param        Set $A     * @param        Set $B     * @param        Set $C     */    public function testIntersectionDistributive(Set $A, Set $B, Set $C)    {        // Given        $A∩⟮B∪C⟯    = $A->intersect($B->union($C));        $⟮A∩B⟯∪⟮A∩C⟯ = $A->intersect($B)->union($A->intersect($C));        // Then        $this->assertEquals($A∩⟮B∪C⟯, $⟮A∩B⟯∪⟮A∩C⟯);        $this->assertEquals($A∩⟮B∪C⟯->asArray(), $⟮A∩B⟯∪⟮A∩C⟯->asArray());    }    /**     * @test Axiom: A ∩ (A ∪ B) = A     * Intersection absorbtion law     *     * @dataProvider dataProviderForTwoSets     * @param        Set $A     * @param        Set $B     */    public function testIntersectionAbsorbtion(Set $A, Set $B)    {        // Given        $A∩⟮B∪C⟯ = $A->intersect($A->union($B));        // Then        $this->assertEquals($A, $A∩⟮B∪C⟯);        $this->assertEquals($A->asArray(), $A∩⟮B∪C⟯->asArray());    }    /**     * @test Axiom: (A ∩ B) ⊆ A     * A intersect B is a subset of A     *     * @dataProvider dataProviderForTwoSets     * @param        Set $A     * @param        Set $B     */    public function testAIntersectionBIsSubsetOfA(Set $A, Set $B)    {        // Given        $A∩B = $A->intersect($B);        // Then        $this->assertTrue($A∩B->isSubset($A));        $this->assertTrue($A∩B->isSubset($B));    }    /**     * @test Axiom: A ∩ A = A     * A intersection A equals A     *     * @dataProvider dataProviderForSingleSet     * @param        Set $A     */    public function testAIntersectionAEqualsA(Set $A)    {        // Given        $A∩A = $A->intersect($A);        // Then        $this->assertEquals($A, $A∩A);        $this->assertEquals($A->asArray(), $A∩A->asArray());    }    /**     * @test Axiom: A ∩ Ø = Ø     * A union empty set is A     *     * @dataProvider dataProviderForSingleSet     * @param        Set $A     */    public function testAIntersectionEmptySetIsEmptySet(Set $A)    {        // Given        $Ø   = new Set();        $A∩Ø = $A->intersect($Ø);        // Then        $this->assertEquals($Ø, $A∩Ø);        $this->assertEquals($Ø->asArray(), $A∩Ø->asArray());    }    /**     * @test Axiom: A ∖ B ≠ B ∖ A for A ≠ B     * A diff B does not equal B diff A if A and B are different sets     *     * @dataProvider dataProviderForTwoSetsDifferent     * @param        Set $A     * @param        Set $B     */    public function testADiffBDifferentFromBDiffAWhenNotEqual(Set $A, Set $B)    {        // Given        $A∖B = $A->difference($B);        $B∖A = $B->difference($A);        // Then        $this->assertNotEquals($A∖B, $B∖A);        $this->assertNotEquals($A∖B->asArray(), $B∖A->asArray());    }    public function dataProviderForTwoSetsDifferent(): array    {        return [            [                new Set([1]),                new Set([]),            ],            [                new Set([]),                new Set([1]),            ],            [                new Set([1]),                new Set([2]),            ],            [                new Set([2]),                new Set([1]),            ],            [                new Set([1]),                new Set([2]),            ],            [                new Set([2]),                new Set([1]),            ],            [                new Set([1, 2, 3, 'a', 'b']),                new Set([1, 'a', 'k']),            ],            [                new Set([1, 2, 3, 'a', 'b', new Set([1, 2])]),                new Set([1, 'a', 'k']),            ],            [                new Set([1, 2, 3, 'a', 'b']),                new Set([1, 'a', 'k', new Set([1, 2])]),            ],            [                new Set([1, 2, 3, 'a', 'b', new Set()]),                new Set([1, 'a', 'k', new Set([1, 2])]),            ],            [                new Set([1, 2, 3, 'a', 'b', new Set([1, 2])]),                new Set([1, 'a', 'k', -2, '2.4', 3.5, new Set([1, 2])]),            ],        ];    }    /**     * @test Axiom: A ∖ A = Ø     * A diff itself is the empty set     *     * @dataProvider dataProviderForSingleSet     * @param        Set $A     */    public function testADiffItselfIsEmptySet(Set $A)    {        // Given        $Ø   = new Set();        $A∖A = $A->difference($A);        // Then        $this->assertEquals($Ø, $A∖A);        $this->assertEquals($Ø->asArray(), $A∖A->asArray());    }    /**     * @test Axiom: A Δ B = (A ∖ B) ∪ (B ∖ A)     * A symmetric different B equals union of A diff B and B diff A     *     * @dataProvider dataProviderForTwoSets     * @param        Set $A     * @param        Set $B     */    public function testASymmetricDifferentBEqualsUnionADiffBAndBDiffA(Set $A, Set $B)    {        // Given        $AΔB       = $A->symmetricDifference($B);        $A∖B       = $A->difference($B);        $B∖A       = $B->difference($A);        $⟮A∖B⟯∪⟮B∖A⟯ = $A∖B->union($B∖A);        // Then        $this->assertEquals($AΔB, $⟮A∖B⟯∪⟮B∖A⟯);        $this->assertEquals($AΔB->asArray(), $⟮A∖B⟯∪⟮B∖A⟯->asArray());    }    /**     * @test Axiom: A × Ø = Ø     * A cartesian product with empty set is the empty set     *     * @dataProvider dataProviderForSingleSet     * @param        Set $A     */    public function testACartesianProductWithEmptySetIsEmptySet(Set $A)    {        // Given        $Ø   = new Set();        $A×Ø = $A->cartesianProduct($Ø);        // Then        $this->assertEquals($Ø, $A×Ø);    }    /**     * @test Axiom: A × (B ∪ C) = (A × B) ∪ (A × C)     * A cross union of B and C is the union of A cross B and A cross C     *     * @dataProvider dataProviderForThreeSets     * @param        Set $A     * @param        Set $B     * @param        Set $C     */    public function testACrossUnionBCEqualsACrossBUnionACrossC(Set $A, Set $B, Set $C)    {        // Given        $A×⟮B∪C⟯ = $A->cartesianProduct($B->union($C));        $⟮A×B⟯∪⟮A×C⟯ = $A->cartesianProduct($B)->union($A->cartesianProduct($C));        // Then        $this->assertEquals($A×⟮B∪C⟯, $⟮A×B⟯∪⟮A×C⟯);        $this->assertEquals($A×⟮B∪C⟯->asArray(), $⟮A×B⟯∪⟮A×C⟯->asArray());    }    /**     * @test Axiom: (A ∪ B) × C = (A × C) ∪ (B × C)     * A union B cross C is the union of A cross C and B cross C     *     * @dataProvider dataProviderForThreeSets     * @param        Set $A     * @param        Set $B     * @param        Set $C     */    public function testAUnionBCrossCEqualsUnsionOfACRossCAndBCrossC(Set $A, Set $B, Set $C)    {        // Given        $⟮A∪B⟯×C = $A->union($B)->cartesianProduct($C);        $⟮A×C⟯∪⟮B×C⟯ = $A->cartesianProduct($C)->union($B->cartesianProduct($C));        // Then        $this->assertEquals($⟮A∪B⟯×C, $⟮A×C⟯∪⟮B×C⟯);        $this->assertEquals($⟮A∪B⟯×C->asArray(), $⟮A×C⟯∪⟮B×C⟯->asArray());    }    /**     * @test Axiom: |A × B| - |A| * |B|     * The cardinality (count) of the cartesian product is the product of the cardinality of A and B     *     * @dataProvider dataProviderForTwoSets     * @param        Set $A     * @param        Set $B     */    public function testCardinalityOfCartesianProduct(Set $A, Set $B)    {        // Given        $A×B = $A->cartesianProduct($B);        // Then        $this->assertEquals(count($A) * count($B), count($A×B));        $this->assertEquals(count($A->asArray()) * count($B->asArray()), count($A×B->asArray()));    }    /**     * @test Axiom: |S| = n, then |P(S)| = 2ⁿ     * The cardinality (count) of a power set of S is 2ⁿ if the cardinality of S is n.     *     * @dataProvider dataProviderForSingleSet     * @param        Set $A     */    public function testCardinalityOfPowerSet(Set $A)    {        // Given        $P⟮S⟯ = $A->powerSet();        $n   = count($A);        // Then        $this->assertEquals(\pow(2, $n), count($P⟮S⟯));        $this->assertEquals(\pow(2, $n), count($P⟮S⟯->asArray()));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SetOperationsTest_5734," When adding objects to a set, the key becomes to the objects hash.\\n The object is stored as is as the value.\\n"," When adding objects to a set, the key becomes to the objects hash.","    public function testAddWithObjects()    {        // Given        $set    = new Set([1, 2, 3]);        $vector = new Vector([1, 2, 3]);        $matrix = new NumericMatrix([[1,2,3],[2,3,4]]);        // When        $set->add($vector);        $set->add($matrix);        // Then        $this->assertEquals(5, count($set));        $this->assertEquals(5, count($set->asArray()));        $objects = 0;        foreach ($set as $key => $value) {            if ($value instanceof \MathPHP\LinearAlgebra\Vector) {                $objects++;                $vector_key = \get_class($value) . '(' . spl_object_hash($vector) . ')';                $this->assertEquals($vector_key, $key);                $this->assertEquals($vector, $value);            }            if ($value instanceof \MathPHP\LinearAlgebra\NumericMatrix) {                $objects++;                $matrix_key = \get_class($value) . '(' . spl_object_hash($matrix) . ')';                $this->assertEquals($matrix_key, $key);                $this->assertEquals($matrix, $value);            }        }        // There should have been two objects (vector and matrix)        $this->assertEquals(2, $objects);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SetOperationsTest_5735," In this case, we add an array that contains arrays.\n So each array element will be added, but with the implementation\n detail that they will be converted into ArrayObjects.\n"," In this case, we add an array that contains arrays.","    public function testAddMultiWithArrayOfArrays()    {        // Given        $set   = new Set([1, 2, 3]);        $array = [4, 5, [1, 2, 3]];        // When        $set->addMulti($array);        // Then        $this->assertEquals(6, count($set));        $this->assertEquals(6, count($set->asArray()));        $arrays = 0;        foreach ($set as $key => $value) {            if (\is_array($value)) {                $arrays++;                $this->assertEquals([1, 2, 3], $value);                $this->assertEquals(3, count($value));                $this->assertEquals(1, $value[0]);                $this->assertEquals(1, $value[0]);                $this->assertEquals(1, $value[0]);            }        }        // There should have only been one array.        $this->assertEquals(1, $arrays);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SetOperationsTest_5737," When adding resources to a set, the key becomes to the resource ID.\\n The resource is stored as is as the value.\\n"," When adding resources to a set, the key becomes to the resource ID.","    public function testAddWithResources()    {        // Given        $set = new Set();        $fh  = fopen(__FILE__, 'r');        // When        $set->add($fh);        $set->add($fh); // Should only get added once        // Then        $this->assertEquals(1, count($set));        $this->assertEquals(1, count($set->asArray()));        $resources = 0;        foreach ($set as $key => $value) {            if (\is_resource($value)) {                $resources++;                $vector_key = 'Resource(' . \strval($value) . ')';                $this->assertEquals($vector_key, $key);                $this->assertEquals($fh, $value);            }        }        // There should have been one resource        $this->assertEquals(1, $resources);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3402," Set (Set Theory)\n A set is a collection of distinct objects, considered as an object in\n its own right.\n https://en.wikipedia.org/wiki/Set_(mathematics)\n\n Sets can contain numbers, strings, arrays, objects, and other sets.\n\n Implementation:\n For performance reasons, PHP arrays are used as a hash for quick access\n via hash keys.\n\n The hash keys are as follows:\n  - Numbers and strings: value itself\n  - Sets: Set as a string.\n  - Arrays: Array(array_serialization)\n  - Objects: Object\\Name(object_hash)\n  - Resource: Resource(Resource id: #)\n  - Null: ''\n\n The values of the associative array (hash) are the actual values or\n objects themselves. If the set is iterated in a foreach loop you will\n get back the original value, set, array, or object.\n\n An object cannot be in the set multiple times. For a regular value, like\n a number or string, this is straight forward. For arrays and objects, the\n behavior is based on whether they are the same thing. What that means depends\n on whether it is an array or object.\n\n Example (arrays):\n $array1 = [1, 2, 3];\n $array2 = [1, 2, 3];\n $set = new Set([$array1, $array2]);\n\n The set will have only one element, because the arrays are equal.\n $array2 === $array2 evaluates to true.\n\n Example (different objects):\n $object1 = new \\StdClass();\n $object2 = new \\StdClass();\n $set = new Set([$object1, $object2]);\n\n The set will have two elements, because they are different objects.\n $object1 === $object2 evaluates to false.\n\n Example (same objects):\n $object1 = new \\StdClass();\n $object2 = $object1;\n $set = new Set([$object1, $object2]);\n\n The set will have only one element, because the objects are the same.\n $object1 === $object2 evaluates to true.\n\n Example (Sets, a special case of object)\n $set1 = new Set([1, 2, 3]);\n $set2 = new Set([1, 2, 3]);\n $set3 = new Set([$set1, $set2]);\n\n Set3 will have only one element, because sets 1 and 2 are the same. Sets are\n not based on whether the object is the same, but whether the content of\n the set are the same. Sets and arrays act similarly.\n\n When storing a Set object as a member of a set, its key will be a string\n that uses mathematical set notation with the addtion of the word 'Set'.\n For example: Set{1, 2, 3}\n The one edge case of this, is that the Set object {1, 2, 3} and the string\n 'Set{1, 2, 3}' would appear identical in the case of adding one when the other\n already is a member of the set. When accessing the actual set member, you\n will always get back the original one added, whether it was a Set object or\n a string.\n", Set (Set Theory),"class Set implements \Countable, \Iterator{    /**     * Set as a hash.     * Keys are a representation of the members of the set.     * Values are the values/objects themselves.     * @var array     */    protected $A = [];    /**     * Constructor - Initialize set members     *     * @param array $members     */    public function __construct(array $members = [])    {        foreach ($members as $member) {            $this->A[$this->getKey($member)] = $member;        }    }    /**************************************************************************     * GET SET CONTENTS     *  - Array     *  - Length     **************************************************************************/    /**     * Get the set as an array     *     * @return array (values are the set members)     */    public function asArray(): array    {        return $this->A;    }    /**     * Get length of set (number of members in set)     *     * @return int     */    public function length(): int    {        return \count($this->A);    }    /**************************************************************************     * SET PROPERTIES     *  - Empty set     **************************************************************************/    public function isEmpty(): bool    {        return empty($this->A);    }    /**************************************************************************     * SINGLE MEMBER PROPERTIES     *  - Is member     *  - Is not member     **************************************************************************/    /**     * Set membership (x ∈ A)     * Is x a member of the set?     *     * @param  mixed $x     *     * @return boolean     */    public function isMember($x): bool    {        return \array_key_exists($this->getKey($x), $this->A);    }    /**     * Set non-membership (x ∉ A)     * Is x not a member of the set?     *     * @param  mixed $x     *     * @return boolean     */    public function isNotMember($x): bool    {        return !\array_key_exists($this->getKey($x), $this->A);    }    /**************************************************************************     * MEMBER OPERATIONS     *  - Add     *  - Add multi     *  - Remove     *  - Remove multi     **************************************************************************/    /**     * Add an element to the set     * Does nothing if element already exists in the set.     *     * @param mixed $x     *     * @return Set (this set)     */    public function add($x): Set    {        $this->A[$this->getKey($x)] = $x;        return $this;    }    /**     * Add an array of elements to the set     * Does nothing if element already exists in the set.     *     * @param array $members     *     * @return Set (this set)     */    public function addMulti(array $members): Set    {        foreach ($members as $member) {            $this->A[$this->getKey($member)] = $member;        }        return $this;    }    /**     * Remove an element from the set     * Does nothing if the element does not exist in the set.     *     * @param  mixed $x     *     * @return Set (this set)     */    public function remove($x): Set    {        unset($this->A[$this->getKey($x)]);        return $this;    }    /**     * Remove elements from the set     * Does nothing if the element does not exist in the set.     *     * @param  array $x     *     * @return Set (this set)     */    public function removeMulti(array $x): Set    {        foreach ($x as $member) {            unset($this->A[$this->getKey($member)]);        }        return $this;    }    /**     * Determine the key for the member to be added     *     * Based on the type of member to be added, the key differs:     *  - Number: value as is     *  - String: value as is     *  - Set: String representation of set. Example: {1, 2}     *  - Array: Array(array_serialization)     *  - Object: Class\Name(object_hash)     *  - Resource: Resource(Resource id #)     *  - Null: ''     *     * @param mixed $x     *     * @return string|null     */    protected function getKey($x): ?string    {        if (\is_int($x) || \is_float($x) || \is_string($x) || $x instanceof Set) {            return ""$x"";        } elseif (\is_object($x)) {            return \get_class($x) . '(' . \spl_object_hash($x) . ')';        } elseif (\is_array($x)) {            return 'Array(' . serialize($x) . ')';        } elseif (\is_resource($x)) {            return 'Resource(' . \strval($x) . ')';        }        return null;    }    /**************************************************************************     * SET PROPERTIES AGAINST OTHER SETS     *  - Disjoint     *  - Subset     *  - Proper subset     *  - Super set     *  - Proper superset     **************************************************************************/    /**     * Disjoint     * Does the set have no elements in common with the other set?     *     * Example of disjoint sets:     *  A = {1, 2, 3}     *  B = {4, 5, 6}     *     * @param  Set $other     *     * @return boolean     */    public function isDisjoint(Set $other): bool    {        return empty(\array_intersect_key($this->A, $other->asArray()));    }    /**     * Subset (A ⊆ B)     * Is the set a subset of the other set?     * In other words, does the other set contain all the elements of the set?     *     * @param  Set $B     *     * @return boolean     */    public function isSubset(Set $B): bool    {        $B_array  = $B->asArray();        $A∩B = \array_intersect_key($this->A, $B_array);        $A∖B = \array_diff_key($this->A, $B_array);        return (\count($A∩B) === \count($this->A)) && (empty($A∖B));    }    /**     * Proper subset (A ⊆ B & A ≠ B)     * Is the set a proper subset of the other set?     * In other words, does the other set contain all the elements of the set,     * and the set is not the same set as the other set?     *     * @param  Set $B     *     * @return boolean     */    public function isProperSubset(Set $B): bool    {        $B_array  = $B->asArray();        $A∩B = \array_intersect_key($this->A, $B_array);        $A∖B = \array_diff_key($this->A, $B_array);        return (\count($A∩B) === \count($this->A)) && (empty($A∖B)) && (\count($this->A) === \count($B));    }    /**     * Superset (A ⊇ B)     * Is the set a superset of the other set?     * In other words, does the the set contain all the elements of the other set?     *     * @param  Set $B     *     * @return boolean     */    public function isSuperset(Set $B): bool    {        $B_array  = $B->asArray();        $A∩B = \array_intersect_key($this->A, $B_array);        $A∖B = \array_diff_key($B_array, $this->A);        return (\count($A∩B) === $B->length()) && (empty($A∖B));    }    /**     * Superset (A ⊇ B & A ≠ B)     * Is the set a superset of the other set?     * In other words, does the the set contain all the elements of the other set,     * and the set is not the same set as the other set?     *     * @param  Set $B     *     * @return boolean     */    public function isProperSuperset(Set $B): bool    {        $B_array  = $B->asArray();        $A∩B = \array_intersect_key($this->A, $B_array);        $A∖B = \array_diff_key($B_array, $this->A);        return (\count($A∩B) === $B->length()) && (empty($A∖B)) && ($this != $B);    }    /**************************************************************************     * SET OPERATIONS ON OTHER SETS     *  - Union     *  - Intersection     *  - Difference     *  - Symmetric difference     **************************************************************************/    /**     * Union (A ∪ B)     * Produces a new set with all elements from all sets.     *     * Example:     *  {1, 2} ∪ {2, 3} = {1, 2, 3}     *     * @param  Set ...$Bs One or more sets     *     * @return Set     */    public function union(Set ...$Bs): Set    {        $union       = $this->A;        $new_members = [];        foreach ($Bs as $B) {            $new_members += \array_diff_key($B->asArray(), $union);        }        foreach ($new_members as $member => $value) {            $union[$member] = $value;        }        return new Set($union);    }    /**     * Intersect (A ∩ B)     * Produces a new set with all the elements common to all sets.     *     * Example:     *  {1, 2} ∩ {2, 3} = {2}     *     * @param  Set ...$Bs One or more sets     *     * @return Set     */    public function intersect(Set ...$Bs): Set    {        $B_members = [];        foreach ($Bs as $B) {            $B_members[] = $B->asArray();        }        $intersection = \array_intersect_key($this->A, ...$B_members);        return new Set($intersection);    }    /**     * Difference (relative complement) (A ∖ B) or (A - B)     * Produces a new set with elements that are not in the other sets.     *     * @param  Set ...$Bs One or more sets     *     * @return Set     */    public function difference(Set ...$Bs): Set    {        $B_members = [];        foreach ($Bs as $B) {            $B_members += $B->asArray();        }        $difference = \array_diff_key($this->A, $B_members);        return new Set($difference);    }    /**     * Symmetric Difference (A Δ B) = (A ∖ B) ∪ (B ∖ A)     * Produces a new set with elements that are in the set or the other,     * but not both.     *     * Example:     *  {7, 8, 9, 10} Δ {9, 10, 11, 12} = {7, 8, 11, 12}     *     * @param  Set $B     *     * @return Set     */    public function symmetricDifference(Set $B): Set    {        $B_array = $B->asArray();        $A∪B = \array_intersect_key($this->A, $B_array);        $A∖B = \array_diff_key($this->A, $A∪B);        $B∖A = \array_diff_key($B_array, $A∪B);        return new Set($A∖B + $B∖A);    }    /**     * Cartesian product (A×B)     * Produces a new set by associating every element of the set with every     * element of the other set(s).     *     * Example:     *  A   = (1, 2)     *  B   = (a, b)     *  A×B = ((1, a), (1, b), (2, a), (2, b))     *     * @param  Set ...$Bs One or more sets     *     * @return Set     */    public function cartesianProduct(Set ...$Bs): Set    {        $A×B     = [];        $product = $this->length();        $sets    = [$this->asArray()];        foreach ($Bs as $B) {            $product *= $B->length();            $sets[]   = $B->asArray();        }        $l = \count($sets);        for ($i = 0; $i < $product; ++$i) {            $elements = [];            for ($i2 = 0; $i2 < $l; ++$i2) {                $elements[] = \current($sets[$i2]);            }            $A×B[] = new Set($elements);            // Advance array pointers            for ($i2 = 0; $i2 < $l; ++$i2) {                \next($sets[$i2]);                $key = key($sets[$i2]);                if ($key !== null) {                    break;                }                \reset($sets[$i2]);            }        }        return new Set($A×B);    }    /**************************************************************************     * OTHER SET OPERATIONS     *  - Power set     *  - Copy     *  - Clear     *  - To string     **************************************************************************/    /**     * Power set P(S)     * The set of all subsets of S, including the empty set and S itself.     *     * Example:     *  S = {x, y, z}     *  P(S) = {Ø, {x}, {y}, {z}, {x,y}, {x,z}, {y,z}, {x,y,z}}     *     * Algorithm:     *  Setup:     *   - n:     size of the original set     *   - 2ⁿ:    size of the power set     *   - A:     original set as an array with numbered indices 0 to n - 1     *   - P(S):  power set to be created     *     *  Iterative loop algorithm:     *   - Loop i from 0 to < 2ⁿ     *    - Create empty temporary Set     *    - Loop j from 0 to < n     *      - If the jᵗʰ bit of the i counter is set, add A[j] to temporary Set     *    - Add temporary set to power set     *     * Time complexity: O(n2ⁿ)     * Reference: http://www.geeksforgeeks.org/power-set/     *     * @return Set     */    public function powerSet(): Set    {        // Setup        $n   = \count($this->A);         // Size of the original set        $２ⁿ = \pow(2, $n);              // Size of the power set        $A   = \array_values($this->A); //  Original set as an array with numbered indices        $P⟮S⟯ = new Set();              //  Power set to be created        // Populate power set        for ($i = 0; $i < $２ⁿ; $i++) {            $member_set = new Set();            for ($j = 0; $j < $n; $j++) {                if ($i & (1 << $j)) {                    $member_set->add($A[$j]);                }            }            $P⟮S⟯->add($member_set);        }        return $P⟮S⟯;    }    /**     * Copy     * Produces a new set with the same elements as the set.     *     * @return Set     */    public function copy(): Set    {        // ImmutableSet extends Set, so return the calling class' type.        return new static($this->A);    }    /**     * Clear the set. Removes all members.     * Results in an empty set.     *     * @return Set (this set)     */    public function clear(): Set    {        $this->A = [];        return $this;    }    /**     * Return the set as a string     * Set{a, b, c, ...}     *     * @return string     */    public function __toString(): string    {        if ($this->isEmpty()) {            return 'Ø';        }        return 'Set{' . \implode(', ', \array_keys($this->A)) . '}';    }    /**************************************************************************     * PHP INTERFACES     *  - Countable     *  - Iterator (Traversable)     **************************************************************************/    /**     * Countable interface     * Computes cardinality of a set S, |S|     *     * @return int     */    public function count(): int    {        return \count($this->A);    }    /**     * Iterator interface array to iterate over     * @var array     */    protected $iterator_keys;    /**     * Iterator interface position of iterator keys we are at (the key)     * @var mixed     */    protected $iterator_position;    /**     * Rewind (Iterator interface)     */    public function rewind()    {        $this->iterator_keys     = \array_keys($this->A);        $this->iterator_position = \array_shift($this->iterator_keys);    }    /**     * Valid (Iterator interface)     *     * @return boolean     */    public function valid(): bool    {        return isset($this->A[$this->iterator_position]);    }    /**     * Current (Iterator interface)     */    public function current()    {        return $this->A[$this->iterator_position];    }    /**     * Key (Iterator interface)     */    public function key()    {        return $this->iterator_position;    }    /**     * Next (Iterator interface)     */    public function next()    {        $this->iterator_position = \array_shift($this->iterator_keys);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3404, Get length of set (number of members in set)\\n\\n @return int\\n, Get length of set (number of members in set),    public function length(): int    {        return \count($this->A);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3416," Superset (A ⊇ B)\n Is the set a superset of the other set?\n In other words, does the the set contain all the elements of the other set?\n\n @param  Set $B\n\n @return boolean\n", Superset (A ⊇ B),"    public function isSuperset(Set $B): bool    {        $B_array  = $B->asArray();        $A∩B = \array_intersect_key($this->A, $B_array);        $A∖B = \array_diff_key($B_array, $this->A);        return (\count($A∩B) === $B->length()) && (empty($A∖B));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3418," Union (A ∪ B)\n Produces a new set with all elements from all sets.\n\n Example:\n  {1, 2} ∪ {2, 3} = {1, 2, 3}\n\n @param  Set ...$Bs One or more sets\n\n @return Set\n", Union (A ∪ B),"    public function union(Set ...$Bs): Set    {        $union       = $this->A;        $new_members = [];        foreach ($Bs as $B) {            $new_members += \array_diff_key($B->asArray(), $union);        }        foreach ($new_members as $member => $value) {            $union[$member] = $value;        }        return new Set($union);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3420, Difference (relative complement) (A ∖ B) or (A - B)\n Produces a new set with elements that are not in the other sets.\n\n @param  Set ...$Bs One or more sets\n\n @return Set\n, Difference (relative complement) (A ∖ B) or (A - B),"    public function difference(Set ...$Bs): Set    {        $B_members = [];        foreach ($Bs as $B) {            $B_members += $B->asArray();        }        $difference = \array_diff_key($this->A, $B_members);        return new Set($difference);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3422," Cartesian product (A×B)\n Produces a new set by associating every element of the set with every\n element of the other set(s).\n\n Example:\n  A   = (1, 2)\n  B   = (a, b)\n  A×B = ((1, a), (1, b), (2, a), (2, b))\n\n @param  Set ...$Bs One or more sets\n\n @return Set\n", Cartesian product (A×B),    public function cartesianProduct(Set ...$Bs): Set    {        $A×B     = [];        $product = $this->length();        $sets    = [$this->asArray()];        foreach ($Bs as $B) {            $product *= $B->length();            $sets[]   = $B->asArray();        }        $l = \count($sets);        for ($i = 0; $i < $product; ++$i) {            $elements = [];            for ($i2 = 0; $i2 < $l; ++$i2) {                $elements[] = \current($sets[$i2]);            }            $A×B[] = new Set($elements);            // Advance array pointers            for ($i2 = 0; $i2 < $l; ++$i2) {                \next($sets[$i2]);                $key = key($sets[$i2]);                if ($key !== null) {                    break;                }                \reset($sets[$i2]);            }        }        return new Set($A×B);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3425, Clear the set. Removes all members.\n Results in an empty set.\n\n @return Set (this set)\n, Clear the set. Removes all members.,    public function clear(): Set    {        $this->A = [];        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3426," Return the set as a string\\n Set{a, b, c, ...}\\n\\n @return string\\n", Return the set as a string,"    public function __toString(): string    {        if ($this->isEmpty()) {            return 'Ø';        }        return 'Set{' . \implode(', ', \array_keys($this->A)) . '}';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3430, Current (Iterator interface)\n, Current (Iterator interface),    public function current()    {        return $this->A[$this->iterator_position];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3432, Next (Iterator interface)\n, Next (Iterator interface),    public function next()    {        $this->iterator_position = \array_shift($this->iterator_keys);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ShiftedGeometric_3260," Shifted geometric distribution\\n\\n The probability distribution of the number X of Bernoulli trials needed\\n to get one success, supported on the set { 1, 2, 3, ...}\\n\\n https://en.wikipedia.org/wiki/Geometric_distribution\\n", Shifted geometric distribution,"class ShiftedGeometric extends Discrete{    /**     * Distribution parameter bounds limits     * p ∈ (0,1]     * @var array     */    public const PARAMETER_LIMITS = [        'p' => '(0,1]',    ];    /**     * Distribution support bounds limits     * k ∈ [1,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'k' => '[1,∞)',    ];    /** @var float success probability */    protected $p;    /**     * Constructor     *     * @param  float $p success probability  0 < p ≤ 1     */    public function __construct(float $p)    {        parent::__construct($p);    }    /**     * Probability mass function     *     * k trials where k ∈ {1, 2, 3, ...}     *     * pmf = (1 - p)ᵏ⁻¹p     *     * @param  int   $k number of trials     k ≥ 1     *     * @return float     */    public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ⁻¹ = \pow(1 - $p, $k - 1);        return $⟮1 − p⟯ᵏ⁻¹ * $p;    }    /**     * Cumulative distribution function     *     * k trials where k ∈ {0, 1, 2, 3, ...}     *     * pmf = 1 - (1 - p)ᵏ     *     * @param  int   $k number of trials     k ≥ 0     *     * @return float     */    public function cdf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ = \pow(1 - $p, $k);        return 1 - $⟮1 − p⟯ᵏ;    }    /**     * Mean of the distribution     *     *     1     * μ = -     *     p     *     * @return float     */    public function mean(): float    {        return 1 / $this->p;    }    /**     * Median of the distribution     *     *           _           _     *          |     -1      |     * median = | ----------- |     *          | log₂(1 - p) |     *     * @return float     */    public function median(): float    {        $log₂⟮1 − p⟯ = \log(1 - $this->p, 2);        return \ceil(-1 / $log₂⟮1 − p⟯);    }    /**     * Mode of the distribution     *     * mode = 1     *     * @return int     */    public function mode(): int    {        return 1;    }    /**     * Variance of the distribution     *     *      1 - p     * σ² = -----     *        p²     *     * @return float     */    public function variance(): float    {        return (1 - $this->p) / $this->p ** 2;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ShiftedGeometric_3262," Probability mass function\n\n k trials where k ∈ {1, 2, 3, ...}\n\n pmf = (1 - p)ᵏ⁻¹p\n\n @param  int   $k number of trials     k ≥ 1\n\n @return float\n", Probability mass function,"    public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ⁻¹ = \pow(1 - $p, $k - 1);        return $⟮1 − p⟯ᵏ⁻¹ * $p;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ShiftedGeometric_3267, Variance of the distribution\\n\\n      1 - p\\n σ² = -----\\n        p²\\n\\n @return float\\n, Variance of the distribution,    public function variance(): float    {        return (1 - $this->p) / $this->p ** 2;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Significance_3555, One-sample Z-test\n When the population mean and standard deviation are known.\n https://en.wikipedia.org/wiki/Z-test\n\n     Hₐ - H₀   M - μ   M - μ   M - μ\n z = ------- = ----- = ----- = -----\n        σ        σ      SEM     σ/√n\n\n p1 = CDF below if left tailed\n    = CDF above if right tailed\n p2 = CDF outside\n\n @param float $Hₐ Alternate hypothesis (M Sample mean)\n @param int   $n  Sample size\n @param float $H₀ Null hypothesis (μ Population mean)\n @param float $σ  SD of population (Standard error of the mean)\n\n @return array [\n   z  => z score\n   p1 => one-tailed p value (left or right tail depends on how Hₐ differs from H₀)\n   p2 => two-tailed p value\n ]\n, One-sample Z-test,"    public static function zTestOneSample(float $Hₐ, int $n, float $H₀, float $σ): array    {        // Calculate z score (test statistic)        $sem = self::sem($σ, $n);        $z   = self::zScore($Hₐ, $H₀, $sem, self::Z_RAW_VALUE);        // One- and two-tailed P values        $standardNormal = new StandardNormal();        if ($Hₐ < $H₀) {            $p1 = $standardNormal->cdf($z);        } else {            $p1 = $standardNormal->above($z);        }        $p2 = $standardNormal->outside(-\abs($z), \abs($z));        return [            'z'  => $z,            'p1' => $p1,            'p2' => $p2,        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Significance_3557, One-sample Student's t-test\n Compares sample mean to the population mean.\n https://en.wikipedia.org/wiki/Student%27s_t-test\n\n     Hₐ - H₀   M - μ   M - μ   M - μ\n t = ------- = ----- = ----- = -----\n        σ        σ      SEM     σ/√n\n\n p1 = CDF below if left tailed\n    = CDF above if right tailed\n p2 = CDF outside\n\n @param array $a Sample set\n @param float $H₀ Null hypothesis (μ₀ Population mean)\n\n @return array [\n   t    => t score\n   df   => degrees of freedom\n   p1   => one-tailed p value (left or right tail depends on how Hₐ differs from H₀)\n   p2   => two-tailed p value\n   mean => sample mean\n   sd   => standard deviation\n ]\n\n @throws Exception\\OutOfBoundsException\n, One-sample Student's t-test,"    public static function tTestOneSample(array $a, float $H₀): array    {        $n  = \count($a);        $Hₐ = Average::mean($a);        $σ  = Descriptive::standardDeviation($a, Descriptive::SAMPLE);        return self::tTestOneSampleFromSummaryData($Hₐ, $σ, $n, $H₀);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Significance_3558, One-sample Student's t-test from summary data\\n Compares sample mean to the population mean.\\n https://en.wikipedia.org/wiki/Student%27s_t-test\\n\\n     Hₐ - H₀   M - μ   M - μ   M - μ\\n t = ------- = ----- = ----- = -----\\n        σ        σ      SEM     σ/√n\\n\\n p1 = CDF below if left tailed\\n    = CDF above if right tailed\\n p2 = CDF outside\\n\\n @param float $Hₐ Alternate hypothesis (M Sample mean)\\n @param float $s  SD of sample\\n @param int    $n  Sample size\\n @param float $H₀ Null hypothesis (μ₀ Population mean)\\n\\n @return array [\\n   t    => t score\\n   df   => degrees of freedom\\n   p1   => one-tailed p value (left or right tail depends on how Hₐ differs from H₀)\\n   p2   => two-tailed p value\\n   mean => sample mean\\n   sd   => standard deviation\\n ]\\n, One-sample Student's t-test from summary data,"    public static function tTestOneSampleFromSummaryData(float $Hₐ, float $s, int $n, float $H₀): array    {        // Calculate test statistic t        $t = self::tScore($Hₐ, $s, $n, $H₀);        // Degrees of freedom        $ν = $n - 1;        // One- and two-tailed P values        $studentT = new StudentT($ν);        if ($Hₐ < $H₀) {            $p1 = $studentT->cdf($t);        } else {            $p1 = $studentT->above($t);        }        $p2 = $studentT->outside(-\abs($t), \abs($t));        return [            't'    => $t,            'df'   => $ν,            'p1'   => $p1,            'p2'   => $p2,            'mean' => $Hₐ,            'sd'   => $s,        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Significance_3559, Two-sample t-test (Welch's test)\\n Test the means of two samples.\\n https://en.wikipedia.org/wiki/Student%27s_t-test\\n\\n        μ₁ - μ₂\\n t = --------------\\n        _________\\n       /σ₁²   σ₂²\\n      / --- + ---\\n     √   n₁    n₂\\n\\n\\n         / σ₁²   σ₂² \\\\²\\n        | --- + ---  |\\n         \\\\ n₁    n₂  /\\n ν =  -------------------\\n      (σ₁²/n₁)²  (σ₂²/n₂)²\\n      -------- + --------\\n       n₁ - 1     n₂ - 1\\n\\n where\\n  μ₁ is sample mean 1\\n  μ₂ is sample mean 2\\n  σ₁ is standard deviation of sample mean 1\\n  σ₂ is standard deviation of sample mean 2\\n  n₁ is sample size of mean 1\\n  n₂ is sample size of mean 2\\n  t  is test statistic\\n  ν  is degrees of freedom\\n\\n p1 = CDF above\\n p2 = CDF outside\\n\\n @param array $x₁ sample set 1\\n @param array $x₂ sample set 2\\n\\n @return array [\\n   t     => t score\\n   df    => degrees of freedom\\n   p1    => one-tailed p value\\n   p2    => two-tailed p value\\n   mean1 => mean of sample set 1\\n   mean2 => mean of sample set 2\\n   sd1   => standard deviation of sample set 1\\n   sd2   => standard deviation of sample set 2\\n ]\\n\\n @throws Exception\\\\OutOfBoundsException\\n, Two-sample t-test (Welch's test),"    public static function tTestTwoSample(array $x₁, array $x₂): array    {        $n₁ = \count($x₁);        $n₂ = \count($x₂);        $μ₁ = Average::mean($x₁);        $μ₂ = Average::mean($x₂);        $σ₁ = Descriptive::sd($x₁, Descriptive::SAMPLE);        $σ₂ = Descriptive::sd($x₂, Descriptive::SAMPLE);        return self::tTestTwoSampleFromSummaryData($μ₁, $μ₂, $n₁, $n₂, $σ₁, $σ₂);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Significance_3560, Two-sample t-test (Welch's test) from summary data\n Test the means of two samples.\n https://en.wikipedia.org/wiki/Student%27s_t-test\n\n        μ₁ - μ₂\n t = --------------\n        _________\n       /σ₁²   σ₂²\n      / --- + ---\n     √   n₁    n₂\n\n\n         / σ₁²   σ₂² \\²\n        | --- + ---  |\n         \\ n₁    n₂  /\n ν =  -------------------\n      (σ₁²/n₁)²  (σ₂²/n₂)²\n      -------- + --------\n       n₁ - 1     n₂ - 1\n\n where\n  μ₁ is sample mean 1\n  μ₂ is sample mean 2\n  σ₁ is standard deviation of sample mean 1\n  σ₂ is standard deviation of sample mean 2\n  n₁ is sample size of mean 1\n  n₂ is sample size of mean 2\n  t  is test statistic\n  ν  is degrees of freedom\n\n p1 = CDF above\n p2 = CDF outside\n\n @param float $μ₁ Sample mean of population 1\n @param float $μ₂ Sample mean of population 2\n @param int   $n₁ Sample size of population 1\n @param int   $n₂ Sample size of population 1\n @param float $σ₁ Standard deviation of sample mean 1\n @param float $σ₂ Standard deviation of sample mean 2\n\n @return array [\n   t     => t score\n   df    => degrees of freedom\n   p1    => one-tailed p value\n   p2    => two-tailed p value\n   mean1 => mean of sample set 1\n   mean2 => mean of sample set 2\n   sd1   => standard deviation of sample set 1\n   sd2   => standard deviation of sample set 2\n ]\n, Two-sample t-test (Welch's test) from summary data,"    public static function tTestTwoSampleFromSummaryData(float $μ₁, float $μ₂, int $n₁, int $n₂, float $σ₁, float $σ₂): array    {        // Calculate t score (test statistic)        $t = ($μ₁ - $μ₂) / \sqrt((($σ₁ ** 2) / $n₁) + (($σ₂ ** 2) / $n₂));        // Degrees of freedom        $ν = ((($σ₁ ** 2) / $n₁) + (($σ₂ ** 2) / $n₂)) ** 2            /            (((($σ₁ ** 2) / $n₁) ** 2 / ($n₁ - 1)) + ((($σ₂ ** 2) / $n₂) ** 2 / ($n₂ - 1)));        // One- and two-tailed P values        $studentT = new StudentT($ν);        $p1 = $studentT->above(\abs($t));        $p2 = $studentT->outside(-\abs($t), \abs($t));        return [            't'  => $t,            'df' => $ν,            'p1' => $p1,            'p2' => $p2,            'mean1' => $μ₁,            'mean2' => $μ₂,            'sd1'   => $σ₁,            'sd2'   => $σ₂,        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Significance_3563, Standard error of the mean (SEM)\\n Can be considered true standard deviation of the sample mean.\\n Used in the Z test.\\n https://en.wikipedia.org/wiki/Standard_error\\n\\n       σ\\n SEM = --\\n       √n\\n\\n @param float $σ Population standard deviation\\n @param int   $n Sample size (number of observations of the sample)\\n\\n @return float\\n, Standard error of the mean (SEM),"    public static function sem(float $σ, int $n): float    {        return $σ / \sqrt($n);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SimpsonsRule_3027," Simpsons Rule\n\n In numerical analysis, Simpson's rule is a technique for approximating\n the definite integral of a function.\n\n Simpson's rule belongs to the closed Newton-Cotes formulas, a group of methods\n for numerical integration which approximate the integral of a function. We\n can either directly supply a set of inputs and their corresponding outputs for\n said function, or if we explicitly know the function, we can define it as a\n callback function and then generate a set of points by evaluating that function\n at n points between a start and end point. We then use these values to\n interpolate a Lagrange polynomial. Finally, we integrate the Lagrange\n polynomial to approximate the integral of our original function.\n\n Simpson's rule is produced by integrating the second Lagrange polynomial.\n\n https://en.wikipedia.org/wiki/Simpson%27s_rule\n http://mathworld.wolfram.com/SimpsonsRule.html\n http://www.efunda.com/math/num_integration/num_int_newton.cfm\n", Simpsons Rule,"class SimpsonsRule extends NumericalIntegration{    /**     * Use Simpson's Rule to approximate the definite integral of a     * function f(x). Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose definite integral we     * are approximating.     *     * Note: Simpson's method requires that we have an even number of     * subintervals (we must supply an odd number of points) and also that the     * size of each subinterval is equal (spacing between each point is equal).     *     * The bounds of the definite integral to which we are approximating is     * determined by the our inputs.     *     * Example: approximate([0, 10], [5, 5], [10, 7]) will approximate the definite     * integral of the function that produces these coordinates with a lower     * bound of 0, and an upper bound of 10.     *     * Example: approximate(function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Simpson's Rule:     *     * xn        ⁿ⁻¹ xᵢ₊₁     * ∫ f(x)dx = ∑   ∫ f(x)dx     * x₁        ⁱ⁼¹  xᵢ     *     *         ⁽ⁿ⁻¹⁾/² h     *          = ∑    - [f⟮x₂ᵢ₋₁⟯ + 4f⟮x₂ᵢ⟯ + f⟮x₂ᵢ₊₁⟯] + O(h⁵f⁗(x))     *           ⁱ⁼¹   3     * where h = (xn - x₁) / (n - 1)     *     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4]].     *                                Example callback: function($x) {return $x**2;}     * @param number         ...$args The arguments of our callback function: start,     *                                end, and n. Example: approximate($source, 0, 8, 5).     *                                If $source is a set of points, do not input any     *                                $args. Example: approximate($source).     *     * @return float                  The approximation to the integral of f(x)     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     */    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 3);        Validation::isSubintervalsMultiple($points, $m = 2);        $sorted = self::sort($points);        Validation::isSpacingConstant($sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $subintervals  = $n - 1;        $a             = $sorted[0][$x];        $b             = $sorted[$n - 1][$x];        $h             = ($b - $a) / $subintervals;        $approximation = 0;        /*         * Summation         * ⁽ⁿ⁻¹⁾/² h         *    ∑    - [f⟮x₂ᵢ₋₁⟯ + 4f⟮x₂ᵢ⟯ + f⟮x₂ᵢ₊₁⟯] + O(h⁵f⁗(x))         *   ⁱ⁼¹   3         *  where h = (xn - x₁) / (n - 1)         */        for ($i = 1; $i < ($subintervals / 2) + 1; $i++) {            $x₂ᵢ₋₁          = $sorted[(2 * $i) - 2][$x];            $x₂ᵢ            = $sorted[(2 * $i) - 1][$x];            $x₂ᵢ₊₁          = $sorted[(2 * $i)][$x];            $f⟮x₂ᵢ₋₁⟯        = $sorted[(2 * $i) - 2][$y];  // y₂ᵢ₋₁            $f⟮x₂ᵢ⟯          = $sorted[(2 * $i) - 1][$y];  // y₂ᵢ            $f⟮x₂ᵢ₊₁⟯        = $sorted[(2 * $i)][$y];    // y₂ᵢ₊₁            $lagrange       = LagrangePolynomial::interpolate([[$x₂ᵢ₋₁, $f⟮x₂ᵢ₋₁⟯], [$x₂ᵢ, $f⟮x₂ᵢ⟯], [$x₂ᵢ₊₁, $f⟮x₂ᵢ₊₁⟯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($x₂ᵢ₊₁) - $integral($x₂ᵢ₋₁); // definite integral of lagrange polynomial        }        return $approximation;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SimpsonsThreeEighthsRule_3029," Simpsons 3/8 Rule\n\n In numerical analysis, Simpson's 3/8 rule is a technique for approximating\n the definite integral of a function.\n\n Simpson's 3/8 rule belongs to the closed Newton-Cotes formulas, a group of methods\n for numerical integration which approximate the integral of a function. We\n can either directly supply a set of inputs and their corresponding outputs for\n said function, or if we explicitly know the function, we can define it as a\n callback function and then generate a set of points by evaluating that function\n at n points between a start and end point. We then use these values to\n interpolate a Lagrange polynomial. Finally, we integrate the Lagrange\n polynomial to approximate the integral of our original function.\n\n Simpson's 3/8 rule is produced by integrating the third Lagrange polynomial.\n\n https://en.wikipedia.org/wiki/Simpson%27s_rule#Simpson.27s_3.2F8_rule\n http://mathworld.wolfram.com/Simpsons38Rule.html\n http://www.efunda.com/math/num_integration/num_int_newton.cfm\n", Simpsons 3/8 Rule,"class SimpsonsThreeEighthsRule extends NumericalIntegration{    /**     * Use Simpson's 3/8 Rule to aproximate the definite integral of a     * function f(x). Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose definite integral we     * are approximating.     *     * Note: Simpson's 3/8 rule requires that our number of subintervals is a factor     * of three (we must supply an n points such that n-1 is a multiple of three)     * and also that the size of each subinterval is equal (spacing between each     * point is equal).     *     * The bounds of the definite integral to which we are approximating is     * determined by the our inputs.     *     * Example: approximate([0, 10], [2, 5], [4, 7], [6,3]) will approximate the     * definite integral of the function that produces these coordinates with a     * lower bound of 0, and an upper bound of 6.     *     * Example: approximate(function($x) {return $x**2;}, [0, 3 ,4]) will produce     * a set of arrays by evaluating the callback at 4 evenly spaced points     * between 0 and 3. Then, this array will be used in our approximation.     *     * Simpson's 3/8 Rule:     *     * xn        ⁿ⁻¹ xᵢ₊₁     * ∫ f(x)dx = ∑   ∫ f(x)dx     * x₁        ⁱ⁼¹  xᵢ     *     *         ⁽ⁿ⁻¹⁾/³ 3h     *          = ∑    - [f⟮x₂ᵢ₋₁⟯ + 3f⟮x₂ᵢ⟯ + 3f⟮x₂ᵢ₊₁⟯ + f⟮x₂ᵢ₊₂⟯] + O(h⁵f⁗(x))     *           ⁱ⁼¹   8     * where h = (xn - x₁) / (n - 1)     *     * @param callable|array $source   The source of our approximation. Should be either     *                                 a callback function or a set of arrays. Each array     *                                 (point) contains precisely two numbers, an x and y.     *                                 Example array: [[1,2], [2,3], [3,4], [4,5]].     *                                 Example callback: function($x) {return $x**2;}     * @param number          ...$args The arguments of our callback function: start,     *                                 end, and n. Example: approximate($source, 0, 8, 4).     *                                 If $source is a set of points, do not input any     *                                 $args. Example: approximate($source).     *     * @return float                   The approximation to the integral of f(x)     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     */    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 4);        Validation::isSubintervalsMultiple($points, $m = 3);        $sorted = self::sort($points);        Validation::isSpacingConstant($sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $subintervals  = $n - 1;        $a             = $sorted[0][$x];        $b             = $sorted[$n - 1][$x];        $h             = ($b - $a) / $subintervals;        $approximation = 0;        /*         * ⁽ⁿ⁻¹⁾/³ 3h         *    ∑    -- [f⟮x₂ᵢ₋₁⟯ + 3f⟮x₂ᵢ⟯ + 3f⟮x₂ᵢ₊₁⟯ + f⟮x₂ᵢ₊₂⟯] + O(h⁵f⁗(x))         *   ⁱ⁼¹   8         *  where h = (xn - x₁) / (n - 1)         */        for ($i = 1; $i < ($subintervals / 3) + 1; $i++) {            $x₂ᵢ₋₁          = $sorted[(2 * $i) - 2][$x];            $x₂ᵢ            = $sorted[(2 * $i) - 1][$x];            $x₂ᵢ₊₁          = $sorted[(2 * $i)][$x];            $x₂ᵢ₊₂          = $sorted[(2 * $i) + 1][$x];            $f⟮x₂ᵢ₋₁⟯        = $sorted[(2 * $i) - 2][$y]; // y₂₋₁            $f⟮x₂ᵢ⟯          = $sorted[(2 * $i) - 1][$y]; // y₂ᵢ            $f⟮x₂ᵢ₊₁⟯        = $sorted[(2 * $i)][$y];   // y₂ᵢ₊₁            $f⟮x₂ᵢ₊₂⟯        = $sorted[(2 * $i) + 1][$y]; // y₂ᵢ₊₂            $lagrange       = LagrangePolynomial::interpolate([[$x₂ᵢ₋₁, $f⟮x₂ᵢ₋₁⟯], [$x₂ᵢ, $f⟮x₂ᵢ⟯], [$x₂ᵢ₊₁, $f⟮x₂ᵢ₊₁⟯], [$x₂ᵢ₊₂, $f⟮x₂ᵢ₊₂⟯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($x₂ᵢ₊₂) - $integral($x₂ᵢ₋₁); // definite integral of lagrange polynomial        }        return $approximation;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Single_2588, Map functions against a single array\n, Map functions against a single array,"class Single{    /**     * Map addition     *     * @param  array $xs     * @param  number $k Number to add to each element     *     * @return array     */    public static function add(array $xs, $k): array    {        return \array_map(            function ($x) use ($k) {                return $x + $k;            },            $xs        );    }    /**     * Map subtract     *     * @param  array $xs     * @param  number $k Number to subtract from each element     *     * @return array     */    public static function subtract(array $xs, $k): array    {        return \array_map(            function ($x) use ($k) {                return $x - $k;            },            $xs        );    }    /**     * Map multiply     *     * @param  array $xs     * @param  number $k Number to multiply to each element     *     * @return array     */    public static function multiply(array $xs, $k): array    {        return \array_map(            function ($x) use ($k) {                return $x * $k;            },            $xs        );    }    /**     * Map Divide     *     * @param  array $xs     * @param  number $k Number to divide each element by     *     * @return array     */    public static function divide(array $xs, $k): array    {        return \array_map(            function ($x) use ($k) {                return $x / $k;            },            $xs        );    }    /**     * Map square     *     * @param  array  $xs     *     * @return array     */    public static function square(array $xs): array    {        return \array_map(            function ($x) {                return $x ** 2;            },            $xs        );    }    /**     * Map cube     *     * @param  array  $xs     *     * @return array     */    public static function cube(array $xs): array    {        return \array_map(            function ($x) {                return $x ** 3;            },            $xs        );    }    /**     * Map reciprocal     * x := 1/x     *     * @param  array  $xs     *     * @return array     *     * @throws Exception\BadDataException if 0 is one of the numbers     */    public static function reciprocal(array $xs): array    {        $zeros = \array_filter(            $xs,            function (float $x) {                return $x == 0;            }        );        if (!empty($zeros)) {            throw new Exception\BadDataException('Cannot compute the reciprocal of 0');        }        return \array_map(            function ($x) {                return 1 / $x;            },            $xs        );    }    /**     * Map raise to a power     *     * @param  array  $xs     * @param  number $n     *     * @return array     */    public static function pow(array $xs, $n): array    {        return \array_map(            function ($x) use ($n) {                return $x ** $n;            },            $xs        );    }    /**     * Map square root     *     * @param  array  $xs     *     * @return array     */    public static function sqrt(array $xs): array    {        return \array_map(            function ($x) {                return \sqrt($x);            },            $xs        );    }    /**     * Map absolute value     *     * @param  array $xs     *     * @return array     */    public static function abs(array $xs): array    {        return \array_map(            function ($x) {                return \abs($x);            },            $xs        );    }    /**     * Map min value     * Each element in array is compared against the value,     * and the min of each is returned.     *     * @param  array  $xs     * @param  number $value     *     * @return array     */    public static function min(array $xs, $value): array    {        return \array_map(            function ($x) use ($value) {                return \min($x, $value);            },            $xs        );    }    /**     * Map max value     * Each element in the array is compared against the value,     * and the max of each is returned.     *     * @param  array  $xs     * @param  number $value     *     * @return array     */    public static function max(array $xs, $value): array    {        return \array_map(            function ($x) use ($value) {                return \max($x, $value);            },            $xs        );    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Single_2589, Map addition\\n\\n @param  array $xs\\n @param  number $k Number to add to each element\\n\\n @return array\\n, Map addition,"    public static function add(array $xs, $k): array    {        return \array_map(            function ($x) use ($k) {                return $x + $k;            },            $xs        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Single_2590, Map subtract\\n\\n @param  array $xs\\n @param  number $k Number to subtract from each element\\n\\n @return array\\n, Map subtract,"    public static function subtract(array $xs, $k): array    {        return \array_map(            function ($x) use ($k) {                return $x - $k;            },            $xs        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Single_2591, Map multiply\n\n @param  array $xs\n @param  number $k Number to multiply to each element\n\n @return array\n, Map multiply,"    public static function multiply(array $xs, $k): array    {        return \array_map(            function ($x) use ($k) {                return $x * $k;            },            $xs        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Single_2594, Map cube\\n\\n @param  array  $xs\\n\\n @return array\\n, Map cube,"    public static function cube(array $xs): array    {        return \array_map(            function ($x) {                return $x ** 3;            },            $xs        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SpecialTest_3867," Test data created with high-precision online calculator: https://keisan.casio.com/exec/system/1180573444\\n @return array (z, Γ, ε)\\n", Test data created with high-precision online calculator: https://keisan.casio.com/exec/system/1180573444,"    public function dataProviderForGammaLargeValues(): array    {        return [            [15, 87178291200, 0.000001],            [20, 121645100408832000, 0.000001],            [50, 6.082818640342675608723E+62, 1e50],            [100, 9.33262154439441526817E+155, 1e140],            [100.6, 1.477347552911177316693E+157, 1e145],            [171, 7.257415615307998967397E+306, 1e295],            [200, 3.943289336823952517762E+372, 1e360],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SpecialTest_3875," Test data created with R (sigmoid) sigmoid(x)\\n @return array (x, sigmoid)\\n", Test data created with R (sigmoid) sigmoid(x),"    public function dataProviderForSigmoid(): array    {        return [            [0, 0.5],            [1, 0.7310586],            [2, 0.8807971],            [3, 0.9525741],            [4, 0.9820138],            [5, 0.9933071],            [6, 0.9975274],            [10, 0.9999546],            [13, 0.9999977],            [15, 0.9999997],            [16, 0.9999999],            [17, 1],            [20, 1],            [-1, 0.2689414],            [-2, 0.1192029],            [-3, 0.04742587],            [-4, 0.01798621],            [-5, 0.006692851],            [-6, 0.002472623],            [-10, 4.539787e-05],            [-15, 3.059022e-07],            [-20, 2.061154e-09],            [0.5, 0.6224593],            [5.5, 0.9959299],            [-0.5, 0.3775407],            [-5.5, 0.004070138],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2557," Gamma function - Lanczos' approximation\\n https://en.wikipedia.org/wiki/Gamma_function\\n https://en.wikipedia.org/wiki/Lanczos_approximation\\n\\n For postive integers:\\n  Γ(n) = (n - 1)!\\n\\n If z is < 0.5, use reflection formula:\\n\\n                   π\\n  Γ(1 - z)Γ(z) = ------\\n                 sin πz\\n\\n  therefore:\\n\\n                π\\n  Γ(z) = -----------------\\n         sin πz \\n otherwise:\\n              __  /        1 \\\\ z+½\\n  Γ(z + 1) = √2π | z + g + -  |    e^-(z+g+½) A(z)\\n                  \\\\        2 /\\n\\n  use pre-computed p coefficients: g = 7, n = 9\\n\\n @param float $z\\n\\n @return float\\n\\n @throws Exception\\\\OutOfBoundsException\\n", Gamma function - Lanczos' approximation,"    public static function gammaLanczos(float $z): float    {        // Basic integer/factorial cases        if ($z == 0) {            return \INF;        }        // Negative integer, or negative int as a float        if ((\abs($z - \round($z)) < 0.00001) && $z < 0) {            return -\INF;        }        // Positive integer, or positive int as a float (Ex: from beta(0.1, 0.9) since it will call Γ(x + y))        if ((\abs($z - \round($z)) < 0.00001) && $z > 0) {            return Combinatorics::factorial((int) \round($z) - 1);        }        // p coefficients: g = 7, n = 9        $p = [            0.99999999999980993227684700473478,            676.520368121885098567009190444019,            -1259.13921672240287047156078755283,            771.3234287776530788486528258894,            -176.61502916214059906584551354,            12.507343278686904814458936853,            -0.13857109526572011689554707,            9.984369578019570859563e-6,            1.50563273514931155834e-7,        ];        $g = 7;        $π = \M_PI;        /**         * Use reflection formula when z < 0.5         *                π         *  Γ(z) = -----------------         *         sin πz * Γ(1 - z)         */        if ($z < 0.5) {            $Γ⟮1 − z⟯ = self::gammaLanczos(1 - $z);            return $π / ( \sin($π * $z) * $Γ⟮1 − z⟯);        }        // Standard Lanczos formula when z ≥ 0.5        // Compute A(z)        $z--;        $A⟮z⟯ = $p[0];        for ($i = 1; $i < \count($p); $i++) {            $A⟮z⟯ += $p[$i] / ($z + $i);        }        // Compute parts of equation        $√2π = \sqrt(2 * $π);        $⟮z ＋ g ＋½⟯ᶻ⁺½ = \pow($z + $g + 0.5, $z + 0.5);        $ℯ＾−⟮z ＋ g ＋½⟯ = \exp(-($z + $g + 0.5));        /**         * Put it all together:         *   __  /        1 \ z+½         *  √2π | z + g + -  |    e^-(z+g+½) A(z)         *       \        2 /         */        return $√2π * $⟮z ＋ g ＋½⟯ᶻ⁺½ * $ℯ＾−⟮z ＋ g ＋½⟯ * $A⟮z⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2558, Gamma function - Stirling approximation\n https://en.wikipedia.org/wiki/Gamma_function\n https://en.wikipedia.org/wiki/Stirling%27s_approximation\n https://www.wolframalpha.com/input/?i=Gamma(n)&lk=3\n\n For postive integers:\n  Γ(n) = (n - 1)!\n\n For positive real numbers -- approximation:\n                   ___\n         __       / 1  /         1      \\ n\n  Γ(n)≈ √2π ℯ⁻ⁿ  /  - | n + ----------- |\n                √   n  \\    12n - 1/10n /\n\n @param float $n\n\n @return float\n\n @throws Exception\\OutOfBoundsException\n, Gamma function - Stirling approximation,"    public static function gammaStirling(float $n): float    {        // Basic integer/factorial cases        if ($n == 0) {            return \INF;        }        // Negative integer, or negative int as a float        if ((\abs($n - \round($n)) < 0.00001) && $n < 0) {            return -\INF;        }        // Positive integer, or postive int as a float        if ((\abs($n - \round($n)) < 0.00001) && $n > 0) {            return Combinatorics::factorial((int) \round($n) - 1);        }        // Compute parts of equation        $√2π                    = \sqrt(2 * \M_PI);        $ℯ⁻ⁿ                    = \exp(-$n);        $√1／n                  = \sqrt(1 / $n);        $⟮n ＋ 1／⟮12n − 1／10n⟯⟯ⁿ = \pow($n + 1 / (12 * $n - 1 / (10 * $n)), $n);        /**         * Put it all together:         *                   ___         *         __       / 1  /         1      \ n         *  Γ(n)≈ √2π ℯ⁻ⁿ  /  - | n + ----------- |         *                √   n  \    12n - 1/10n /         */        return $√2π * $ℯ⁻ⁿ * $√1／n * $⟮n ＋ 1／⟮12n − 1／10n⟯⟯ⁿ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2562," Logistic function (logistic sigmoid function)\\n A logistic function or logistic curve is a common ""S"" shape (sigmoid curve).\\n https://en.wikipedia.org/wiki/Logistic_function\\n\\n             L\\n f(x) = -----------\\n        1 + ℯ⁻ᵏ⁽ˣ⁻ˣ⁰⁾\\n\\n\\n @param float $x₀ x-value of the sigmoid\\\'s midpoint\\n @param float $L  the curve\\\'s maximum value\\n @param float $k  the steepness of the curve\\n @param float $x\\n\\n @return float\\n", Logistic function (logistic sigmoid function),"    public static function logistic(float $x₀, float $L, float $k, float $x): float    {        $ℯ⁻ᵏ⁽ˣ⁻ˣ⁰⁾ = \exp(-$k * ($x - $x₀));        return $L / (1 + $ℯ⁻ᵏ⁽ˣ⁻ˣ⁰⁾);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2563," Sigmoid function\\n A sigmoid function is a mathematical function having an ""S"" shaped curve (sigmoid curve).\\n Often, sigmoid function refers to the special case of the logistic function\\n https://en.wikipedia.org/wiki/Sigmoid_function\\n\\n           1\\n S(t) = -------\\n        1 + ℯ⁻ᵗ\\n\\n @param  float $t\\n\\n @return float\\n", Sigmoid function,    public static function sigmoid(float $t): float    {        $ℯ⁻ᵗ = \exp(-$t);        return 1 / (1 + $ℯ⁻ᵗ);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2564," Error function (Gauss error function)\\n https://en.wikipedia.org/wiki/Error_function\\n\\n This is an approximation of the error function (maximum error: 1.5×10−7)\\n\\n erf(x) ≈ 1 - (a₁t + a₂t² + a₃t³ + a₄t⁴ + a₅t⁵)ℯ^-x²\\n\\n       1\\n t = ------\\n     1 + px\\n\\n p = 0.3275911\\n a₁ = 0.254829592, a₂ = −0.284496736, a₃ = 1.421413741, a₄ = −1.453152027, a₅ = 1.061405429\\n\\n @param  float $x\\n\\n @return float\\n", Error function (Gauss error function),    public static function errorFunction(float $x): float    {        if ($x == 0) {            return 0;        }        $p  = 0.3275911;        $t  = 1 / ( 1 + $p * \abs($x) );        $a₁ = 0.254829592;        $a₂ = -0.284496736;        $a₃ = 1.421413741;        $a₄ = -1.453152027;        $a₅ = 1.061405429;        $error = 1 - ( $a₁ * $t + $a₂ * $t ** 2 + $a₃ * $t ** 3 + $a₄ * $t ** 4 + $a₅ * $t ** 5 ) * \exp(-\abs($x) ** 2);        return ( $x > 0 ) ? $error : -$error;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2566, Complementary error function (erfc)\\n erfc(x) ≡ 1 - erf(x)\\n\\n @param  number $x\\n\\n @return float\\n, Complementary error function (erfc),    public static function complementaryErrorFunction($x): float    {        return 1 - self::erf($x);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2570, γ - Convenience method for lower incomplete gamma function\n https://en.wikipedia.org/wiki/Incomplete_gamma_function#Lower_incomplete_Gamma_function\n\n @param float $s > 0\n @param float $x ≥ 0\n\n @return float\n, γ - Convenience method for lower incomplete gamma function,"    public static function γ(float $s, float $x): float    {        return self::lowerIncompleteGamma($s, $x);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2571," Regularized lower incomplete gamma function - P(s,x)\n https://en.wikipedia.org/wiki/Incomplete_gamma_function#Regularized_Gamma_functions_and_Poisson_random_variables\n\n          γ(s,x)\n P(s,x) = ------\n           Γ(s)\n\n P(s,x) is the cumulative distribution function for Gamma random variables with shape parameter s and scale parameter 1\n\n\n @param float $s > 0\n @param float $x ≥ 0\n\n @return float\n\n @throws Exception\\OutOfBoundsException\n"," Regularized lower incomplete gamma function - P(s,x)","    public static function regularizedLowerIncompleteGamma(float $s, float $x): float    {        $γ⟮s、x⟯ = self::lowerIncompleteGamma($s, $x);        $Γ⟮s⟯    = self::gamma($s);        return $γ⟮s、x⟯ / $Γ⟮s⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2572," Incomplete Beta Function - B(x;a,b)\\n\\n Generalized form of the beta function\\n https://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function\\n\\n @param float $x Upper limit of the integration 0 ≦ x ≦ 1\\n @param float $a Shape parameter a > 0\\n @param float $b Shape parameter b > 0\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\OutOfBoundsException\\n"," Incomplete Beta Function - B(x;a,b)","    public static function incompleteBeta(float $x, float $a, float $b): float    {        return self::regularizedIncompleteBeta($x, $a, $b) * self::beta($a, $b);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2574," Regularized incomplete beta function - Iₓ(a, b)\n\n https://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function\n\n This function looks at the values of x, a, and b, and determines which algorithm is best to calculate\n the value of Iₓ(a, b)\n\n http://www.boost.org/doc/libs/1_35_0/libs/math/doc/sf_and_dist/html/math_toolkit/special/sf_beta/ibeta_function.html\n https://github.com/boostorg/math/blob/develop/include/boost/math/special_functions/beta.hpp\n\n @param float $x Upper limit of the integration 0 ≦ x ≦ 1\n @param float $a Shape parameter a > 0\n @param float $b Shape parameter b > 0\n\n @return float\n\n @throws Exception\\BadDataException\n @throws Exception\\BadParameterException\n @throws Exception\\OutOfBoundsException\n"," Regularized incomplete beta function - Iₓ(a, b)","    public static function regularizedIncompleteBeta(float $x, float $a, float $b): float    {        $limits = [            'x' => '[0, 1]',            'a' => '(0,∞)',            'b' => '(0,∞)',        ];        Support::checkLimits($limits, ['x' => $x, 'a' => $a, 'b' => $b]);        if ($x == 1 || $x == 0) {            return $x;        }        if ($a == 1) {            return 1 - (1 - $x) ** $b;        }        if ($b == 1) {            return $x ** $a;        }        if ($x > .9 || $b > $a && $x > .5) {            $y = 1 - $x;            return 1 - self::regularizedIncompleteBeta($y, $b, $a);        }        if ($a > 1 && $b > 1) {            // Tolerance on evaluating the continued fraction.            $tol = .000000000000001;            $dif = $tol + 1; // Initialize            // We will calculate the continuous fraction with a minimum depth of 10.            $m = 10;  // Counter            $I = 0;            do {                $I_new = self::iBetaCF($m, $x, $a, $b);                if ($m > 10) {                    $dif = \abs(($I - $I_new) / $I_new);                }                $I = $I_new;                $m++;            } while ($dif > $tol);            return $I;        } else {            if ($a <= 1) {                // We shift a up by one, to the region that the continuous fraction works best.                $offset = $x ** $a * (1 - $x) ** $b / $a / self::beta($a, $b);                return self::regularizedIncompleteBeta($x, $a + 1, $b) + $offset;            } else { // $b <= 1                // We shift b up by one, to the region that the continuous fraction works best.                $offset = $x ** $a * (1 - $x) ** $b / $b / self::beta($a, $b);                return self::regularizedIncompleteBeta($x, $a, $b + 1) - $offset;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2576, Confluent Hypergeometric Function\\n\\n https://en.wikipedia.org/wiki/Confluent_hypergeometric_function\\n         ∞\\n        ____\\n        \\\\     a⁽ⁿ⁾   ₁F₁ =  >    ---------\\n        /     b⁽ⁿ⁾         ‾‾‾‾\\n        n=0\\n\\n @param float $a the numerator value\\n @param float $b the denominator value\\n @param float $z\\n\\n @return float\\n\\n @throws Exception\\\\BadParameterException\\n, Confluent Hypergeometric Function,"    public static function confluentHypergeometric(float $a, float $b, float $z): float    {        return self::generalizedHypergeometric(1, 1, $a, $b, $z);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_StandardNormal_3183," Standard normal distribution\n The simplest case of a normal distribution.\n This is a special case when μ = 0 and σ = 1,\n", Standard normal distribution,"class StandardNormal extends Normal{    /**     * Mean is always 0     * @var int     */    protected const μ = 0;    /**     * Standard deviation is always 1     * @var int     */    protected const σ = 1;    /**     * Distribution parameter bounds limits     * μ ∈ [0,0]     * σ ∈ [1,1]     * @var array     */    public const PARAMETER_LIMITS = [        'μ' => '[-0,0]',        'σ' => '[1,1]',    ];    /**     * Distribution support bounds limits     * z ∈ (-∞,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'z' => '(-∞,∞)',    ];    /**     * StandardNormal constructor     */    public function __construct()    {        parent::__construct(self::μ, self::σ);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_StandardNormal_3289," Standard normal tables for Z and related methods\\n\\n A standard normal table, also called the unit normal table or Z table,\\n is a mathematical table for the values of Φ, which are the values of the\\n cumulative distribution function of the normal distribution.\\n\\n It is used to find the probability that a statistic is observed below,\\n above, or between values on the standard normal distribution, and by extension,\\n any normal distribution.\\n\\n Since probability tables cannot be printed for every normal distribution,\\n as there are an infinite variety of normal distributions,\\n it is common practice to convert a normal to a standard normal\\n and then use the standard normal table to find probabilities.\\n\\n https://en.wikipedia.org/wiki/Standard_normal_table\\n\\n This table is provided only for completeness. It is common for statistics\\n textbooks to include this table, so this library does as well. It is better\\n to use the standard normal distribution CDF function when a Z score is required.\\n", Standard normal tables for Z and related methods,"class StandardNormal{    /**     * Z scores table - cumulative from mean     * Contains positive and negative Z scores.     * Negative z-score - value is to the left of the mean.     * Positive z-score - value is to the right of the mean.     * @var array     */    public const Z_SCORES = [    '-3.4' => [ 9 => 0.0002, 8 => 0.0003, 7 => 0.0003, 6 => 0.0003, 5 => 0.0003, 4 => 0.0003, 3 => 0.0003, 2 => 0.0003, 1 => 0.0003, 0 => 0.0003 ],    '-3.3' => [ 9 => 0.0003, 8 => 0.0004, 7 => 0.0004, 6 => 0.0004, 5 => 0.0004, 4 => 0.0004, 3 => 0.0004, 2 => 0.0005, 1 => 0.0005, 0 => 0.0005 ],    '-3.2' => [ 9 => 0.0005, 8 => 0.0005, 7 => 0.0005, 6 => 0.0006, 5 => 0.0006, 4 => 0.0006, 3 => 0.0006, 2 => 0.0006, 1 => 0.0007, 0 => 0.0007 ],    '-3.1' => [ 9 => 0.0007, 8 => 0.0007, 7 => 0.0008, 6 => 0.0008, 5 => 0.0008, 4 => 0.0008, 3 => 0.0009, 2 => 0.0009, 1 => 0.0009, 0 => 0.0010 ],    '-3.0' => [ 9 => 0.0010, 8 => 0.0010, 7 => 0.0011, 6 => 0.0011, 5 => 0.0011, 4 => 0.0012, 3 => 0.0012, 2 => 0.0013, 1 => 0.0013, 0 => 0.0013 ],    '-2.9' => [ 9 => 0.0014, 8 => 0.0014, 7 => 0.0015, 6 => 0.0015, 5 => 0.0016, 4 => 0.0016, 3 => 0.0017, 2 => 0.0018, 1 => 0.0018, 0 => 0.0019 ],    '-2.8' => [ 9 => 0.0019, 8 => 0.0020, 7 => 0.0021, 6 => 0.0021, 5 => 0.0022, 4 => 0.0023, 3 => 0.0023, 2 => 0.0024, 1 => 0.0025, 0 => 0.0026 ],    '-2.7' => [ 9 => 0.0026, 8 => 0.0027, 7 => 0.0028, 6 => 0.0029, 5 => 0.0030, 4 => 0.0031, 3 => 0.0032, 2 => 0.0033, 1 => 0.0034, 0 => 0.0035 ],    '-2.6' => [ 9 => 0.0036, 8 => 0.0037, 7 => 0.0038, 6 => 0.0039, 5 => 0.0040, 4 => 0.0041, 3 => 0.0043, 2 => 0.0044, 1 => 0.0045, 0 => 0.0047 ],    '-2.5' => [ 9 => 0.0048, 8 => 0.0049, 7 => 0.0051, 6 => 0.0052, 5 => 0.0054, 4 => 0.0055, 3 => 0.0057, 2 => 0.0059, 1 => 0.0060, 0 => 0.0062 ],    '-2.4' => [ 9 => 0.0064, 8 => 0.0066, 7 => 0.0068, 6 => 0.0069, 5 => 0.0071, 4 => 0.0073, 3 => 0.0075, 2 => 0.0078, 1 => 0.0080, 0 => 0.0082 ],    '-2.3' => [ 9 => 0.0084, 8 => 0.0087, 7 => 0.0089, 6 => 0.0091, 5 => 0.0094, 4 => 0.0096, 3 => 0.0099, 2 => 0.0102, 1 => 0.0104, 0 => 0.0107 ],    '-2.2' => [ 9 => 0.0110, 8 => 0.0113, 7 => 0.0116, 6 => 0.0119, 5 => 0.0122, 4 => 0.0125, 3 => 0.0129, 2 => 0.0132, 1 => 0.0136, 0 => 0.0139 ],    '-2.1' => [ 9 => 0.0143, 8 => 0.0146, 7 => 0.0150, 6 => 0.0154, 5 => 0.0158, 4 => 0.0162, 3 => 0.0166, 2 => 0.0170, 1 => 0.0174, 0 => 0.0179 ],    '-2.0' => [ 9 => 0.0183, 8 => 0.0188, 7 => 0.0192, 6 => 0.0197, 5 => 0.0202, 4 => 0.0207, 3 => 0.0212, 2 => 0.0217, 1 => 0.0222, 0 => 0.0228 ],    '-1.9' => [ 9 => 0.0233, 8 => 0.0239, 7 => 0.0244, 6 => 0.0250, 5 => 0.0256, 4 => 0.0262, 3 => 0.0268, 2 => 0.0274, 1 => 0.0281, 0 => 0.0287 ],    '-1.8' => [ 9 => 0.0294, 8 => 0.0301, 7 => 0.0307, 6 => 0.0314, 5 => 0.0322, 4 => 0.0329, 3 => 0.0336, 2 => 0.0344, 1 => 0.0351, 0 => 0.0359 ],    '-1.7' => [ 9 => 0.0367, 8 => 0.0375, 7 => 0.0384, 6 => 0.0392, 5 => 0.0401, 4 => 0.0409, 3 => 0.0418, 2 => 0.0427, 1 => 0.0436, 0 => 0.0446 ],    '-1.6' => [ 9 => 0.0455, 8 => 0.0465, 7 => 0.0475, 6 => 0.0485, 5 => 0.0495, 4 => 0.0505, 3 => 0.0516, 2 => 0.0526, 1 => 0.0537, 0 => 0.0548 ],    '-1.5' => [ 9 => 0.0559, 8 => 0.0571, 7 => 0.0582, 6 => 0.0594, 5 => 0.0606, 4 => 0.0618, 3 => 0.0630, 2 => 0.0643, 1 => 0.0655, 0 => 0.0668 ],    '-1.4' => [ 9 => 0.0681, 8 => 0.0694, 7 => 0.0708, 6 => 0.0721, 5 => 0.0735, 4 => 0.0749, 3 => 0.0764, 2 => 0.0778, 1 => 0.0793, 0 => 0.0808 ],    '-1.3' => [ 9 => 0.0823, 8 => 0.0838, 7 => 0.0853, 6 => 0.0869, 5 => 0.0885, 4 => 0.0901, 3 => 0.0918, 2 => 0.0934, 1 => 0.0951, 0 => 0.0968 ],    '-1.2' => [ 9 => 0.0985, 8 => 0.1003, 7 => 0.1020, 6 => 0.1038, 5 => 0.1056, 4 => 0.1075, 3 => 0.1093, 2 => 0.1112, 1 => 0.1131, 0 => 0.1151 ],    '-1.1' => [ 9 => 0.1170, 8 => 0.1190, 7 => 0.1210, 6 => 0.1230, 5 => 0.1251, 4 => 0.1271, 3 => 0.1292, 2 => 0.1314, 1 => 0.1335, 0 => 0.1357 ],    '-1.0' => [ 9 => 0.1379, 8 => 0.1401, 7 => 0.1423, 6 => 0.1446, 5 => 0.1469, 4 => 0.1492, 3 => 0.1515, 2 => 0.1539, 1 => 0.1562, 0 => 0.1587 ],    '-0.9' => [ 9 => 0.1611, 8 => 0.1635, 7 => 0.1660, 6 => 0.1685, 5 => 0.1711, 4 => 0.1736, 3 => 0.1762, 2 => 0.1788, 1 => 0.1814, 0 => 0.1841 ],    '-0.8' => [ 9 => 0.1867, 8 => 0.1894, 7 => 0.1922, 6 => 0.1949, 5 => 0.1977, 4 => 0.2005, 3 => 0.2033, 2 => 0.2061, 1 => 0.2090, 0 => 0.2119 ],    '-0.7' => [ 9 => 0.2148, 8 => 0.2177, 7 => 0.2206, 6 => 0.2236, 5 => 0.2266, 4 => 0.2296, 3 => 0.2327, 2 => 0.2358, 1 => 0.2389, 0 => 0.2420 ],    '-0.6' => [ 9 => 0.2451, 8 => 0.2483, 7 => 0.2514, 6 => 0.2546, 5 => 0.2578, 4 => 0.2611, 3 => 0.2643, 2 => 0.2676, 1 => 0.2709, 0 => 0.2743 ],    '-0.5' => [ 9 => 0.2776, 8 => 0.2810, 7 => 0.2843, 6 => 0.2877, 5 => 0.2912, 4 => 0.2946, 3 => 0.2981, 2 => 0.3015, 1 => 0.3050, 0 => 0.3085 ],    '-0.4' => [ 9 => 0.3121, 8 => 0.3156, 7 => 0.3192, 6 => 0.3228, 5 => 0.3264, 4 => 0.3300, 3 => 0.3336, 2 => 0.3372, 1 => 0.3409, 0 => 0.3446 ],    '-0.3' => [ 9 => 0.3483, 8 => 0.3520, 7 => 0.3557, 6 => 0.3594, 5 => 0.3632, 4 => 0.3669, 3 => 0.3707, 2 => 0.3745, 1 => 0.3783, 0 => 0.3821 ],    '-0.2' => [ 9 => 0.3829, 8 => 0.3897, 7 => 0.3936, 6 => 0.3974, 5 => 0.4013, 4 => 0.4052, 3 => 0.4090, 2 => 0.4129, 1 => 0.4168, 0 => 0.4207 ],    '-0.1' => [ 9 => 0.4247, 8 => 0.4286, 7 => 0.4325, 6 => 0.4364, 5 => 0.4404, 4 => 0.4443, 3 => 0.4483, 2 => 0.4522, 1 => 0.4562, 0 => 0.4602 ],    '-0.0' => [ 9 => 0.4641, 8 => 0.4681, 7 => 0.4721, 6 => 0.4761, 5 => 0.4801, 4 => 0.4840, 3 => 0.4880, 2 => 0.4920, 1 => 0.4960, 0 => 0.5000 ],     '0.0' => [ 0 => 0.50000, 1 => 0.50399, 2 => 0.50798, 3 => 0.51197, 4 => 0.51595, 5 => 0.51994, 6 => 0.52392, 7 => 0.52790, 8 => 0.53188, 9 => 0.53586 ],     '0.1' => [ 0 => 0.53980, 1 => 0.54380, 2 => 0.54776, 3 => 0.55172, 4 => 0.55567, 5 => 0.55966, 6 => 0.56360, 7 => 0.56749, 8 => 0.57142, 9 => 0.57535 ],     '0.2' => [ 0 => 0.57930, 1 => 0.58317, 2 => 0.58706, 3 => 0.59095, 4 => 0.59483, 5 => 0.59871, 6 => 0.60257, 7 => 0.60642, 8 => 0.61026, 9 => 0.61409 ],     '0.3' => [ 0 => 0.61791, 1 => 0.62172, 2 => 0.62552, 3 => 0.62930, 4 => 0.63307, 5 => 0.63683, 6 => 0.64058, 7 => 0.64431, 8 => 0.64803, 9 => 0.65173 ],     '0.4' => [ 0 => 0.65542, 1 => 0.65910, 2 => 0.66276, 3 => 0.66640, 4 => 0.67003, 5 => 0.67364, 6 => 0.67724, 7 => 0.68082, 8 => 0.68439, 9 => 0.68793 ],     '0.5' => [ 0 => 0.69146, 1 => 0.69497, 2 => 0.69847, 3 => 0.70194, 4 => 0.70540, 5 => 0.70884, 6 => 0.71226, 7 => 0.71566, 8 => 0.71904, 9 => 0.72240 ],     '0.6' => [ 0 => 0.72575, 1 => 0.72907, 2 => 0.73237, 3 => 0.73565, 4 => 0.73891, 5 => 0.74215, 6 => 0.74537, 7 => 0.74857, 8 => 0.75175, 9 => 0.75490 ],     '0.7' => [ 0 => 0.75804, 1 => 0.76115, 2 => 0.76424, 3 => 0.76730, 4 => 0.77035, 5 => 0.77337, 6 => 0.77637, 7 => 0.77935, 8 => 0.78230, 9 => 0.78524 ],     '0.8' => [ 0 => 0.78814, 1 => 0.79103, 2 => 0.79389, 3 => 0.79673, 4 => 0.79955, 5 => 0.80234, 6 => 0.80511, 7 => 0.80785, 8 => 0.81057, 9 => 0.81327 ],     '0.9' => [ 0 => 0.81594, 1 => 0.81859, 2 => 0.82121, 3 => 0.82381, 4 => 0.82639, 5 => 0.82894, 6 => 0.83147, 7 => 0.83398, 8 => 0.83646, 9 => 0.83891 ],     '1.0' => [ 0 => 0.84134, 1 => 0.84375, 2 => 0.84614, 3 => 0.84849, 4 => 0.85083, 5 => 0.85314, 6 => 0.85543, 7 => 0.85769, 8 => 0.85993, 9 => 0.86214 ],     '1.1' => [ 0 => 0.86433, 1 => 0.86650, 2 => 0.86864, 3 => 0.87076, 4 => 0.87286, 5 => 0.87493, 6 => 0.87698, 7 => 0.87900, 8 => 0.88100, 9 => 0.88298 ],     '1.2' => [ 0 => 0.88493, 1 => 0.88686, 2 => 0.88877, 3 => 0.89065, 4 => 0.89251, 5 => 0.89435, 6 => 0.89617, 7 => 0.89796, 8 => 0.89973, 9 => 0.90147 ],     '1.3' => [ 0 => 0.90320, 1 => 0.90490, 2 => 0.90658, 3 => 0.90824, 4 => 0.90988, 5 => 0.91149, 6 => 0.91308, 7 => 0.91466, 8 => 0.91621, 9 => 0.91774 ],     '1.4' => [ 0 => 0.91924, 1 => 0.92073, 2 => 0.92220, 3 => 0.92364, 4 => 0.92507, 5 => 0.92647, 6 => 0.92785, 7 => 0.92922, 8 => 0.93056, 9 => 0.93189 ],     '1.5' => [ 0 => 0.93319, 1 => 0.93448, 2 => 0.93574, 3 => 0.93699, 4 => 0.93822, 5 => 0.93943, 6 => 0.94062, 7 => 0.94179, 8 => 0.94295, 9 => 0.94408 ],     '1.6' => [ 0 => 0.94520, 1 => 0.94630, 2 => 0.94738, 3 => 0.94845, 4 => 0.94950, 5 => 0.95053, 6 => 0.95154, 7 => 0.95254, 8 => 0.95352, 9 => 0.95449 ],     '1.7' => [ 0 => 0.95543, 1 => 0.95637, 2 => 0.95728, 3 => 0.95818, 4 => 0.95907, 5 => 0.95994, 6 => 0.96080, 7 => 0.96164, 8 => 0.96246, 9 => 0.96327 ],     '1.8' => [ 0 => 0.96407, 1 => 0.96485, 2 => 0.96562, 3 => 0.96638, 4 => 0.96712, 5 => 0.96784, 6 => 0.96856, 7 => 0.96926, 8 => 0.96995, 9 => 0.97062 ],     '1.9' => [ 0 => 0.97128, 1 => 0.97193, 2 => 0.97257, 3 => 0.97320, 4 => 0.97381, 5 => 0.97441, 6 => 0.97500, 7 => 0.97558, 8 => 0.97615, 9 => 0.97670 ],     '2.0' => [ 0 => 0.97725, 1 => 0.97778, 2 => 0.97831, 3 => 0.97882, 4 => 0.97932, 5 => 0.97982, 6 => 0.98030, 7 => 0.98077, 8 => 0.98124, 9 => 0.98169 ],     '2.1' => [ 0 => 0.98214, 1 => 0.98257, 2 => 0.98300, 3 => 0.98341, 4 => 0.98382, 5 => 0.98422, 6 => 0.98461, 7 => 0.98500, 8 => 0.98537, 9 => 0.98574 ],     '2.2' => [ 0 => 0.98610, 1 => 0.98645, 2 => 0.98679, 3 => 0.98713, 4 => 0.98745, 5 => 0.98778, 6 => 0.98809, 7 => 0.98840, 8 => 0.98870, 9 => 0.98899 ],     '2.3' => [ 0 => 0.98928, 1 => 0.98956, 2 => 0.98983, 3 => 0.99010, 4 => 0.99036, 5 => 0.99061, 6 => 0.99086, 7 => 0.99111, 8 => 0.99134, 9 => 0.99158 ],     '2.4' => [ 0 => 0.99180, 1 => 0.99202, 2 => 0.99224, 3 => 0.99245, 4 => 0.99266, 5 => 0.99286, 6 => 0.99305, 7 => 0.99324, 8 => 0.99343, 9 => 0.99361 ],     '2.5' => [ 0 => 0.99379, 1 => 0.99396, 2 => 0.99413, 3 => 0.99430, 4 => 0.99446, 5 => 0.99461, 6 => 0.99477, 7 => 0.99492, 8 => 0.99506, 9 => 0.99520 ],     '2.6' => [ 0 => 0.99534, 1 => 0.99547, 2 => 0.99560, 3 => 0.99573, 4 => 0.99585, 5 => 0.99598, 6 => 0.99609, 7 => 0.99621, 8 => 0.99632, 9 => 0.99643 ],     '2.7' => [ 0 => 0.99653, 1 => 0.99664, 2 => 0.99674, 3 => 0.99683, 4 => 0.99693, 5 => 0.99702, 6 => 0.99711, 7 => 0.99720, 8 => 0.99728, 9 => 0.99736 ],     '2.8' => [ 0 => 0.99744, 1 => 0.99752, 2 => 0.99760, 3 => 0.99767, 4 => 0.99774, 5 => 0.99781, 6 => 0.99788, 7 => 0.99795, 8 => 0.99801, 9 => 0.99807 ],     '2.9' => [ 0 => 0.99813, 1 => 0.99819, 2 => 0.99825, 3 => 0.99831, 4 => 0.99836, 5 => 0.99841, 6 => 0.99846, 7 => 0.99851, 8 => 0.99856, 9 => 0.99861 ],     '3.0' => [ 0 => 0.99865, 1 => 0.99869, 2 => 0.99874, 3 => 0.99878, 4 => 0.99882, 5 => 0.99886, 6 => 0.99889, 7 => 0.99893, 8 => 0.99896, 9 => 0.99900 ],    ];    /**     * Get Z score probability (Φ)     *     * @param float $Z     *     * @return float probability     *     * @throws Exception\BadDataException     */    public static function getZScoreProbability(float $Z): float    {        if (!preg_match('/^ (\-? \d [.] \d) (\d) $/x', \sprintf('%1.2f', $Z), $matches)) {            throw new Exception\BadParameterException(""Z does not match format X.XX: $Z"");        }        [$z, $＋0．0x] = [ $matches[1], $matches[2] ];        return self::Z_SCORES[$z][$＋0．0x];    }    /**     * Z scores for confidence intervals     * Key: confidence level %     * Value: Z score     * @var array     */    private const Z_SCORES_FOR_CONFIDENCE_INTERVALS = [        50     => 0.67449,        70     => 1.04,        75     => 1.15035,        80     => 1.282,        85     => 1.44,        90     => 1.64485,        92     => 1.75,        95     => 1.95996,        96     => 2.05,        97     => 2.17009,        98     => 2.326,        99     => 2.57583,        '99.5' => 2.81,        '99.8' => 3.08,        '99.9' => 3.29053,    ];    /**     * Get Z score for confidence interval     *     * @param  string $cl confidence level     *     * @return float Z score     *     * @throws Exception\BadDataException     */    public static function getZScoreForConfidenceInterval(string $cl): float    {        if (!\array_key_exists($cl, self::Z_SCORES_FOR_CONFIDENCE_INTERVALS)) {            throw new Exception\BadDataException('Not a valid confidence level');        }        return self::Z_SCORES_FOR_CONFIDENCE_INTERVALS[$cl];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Support_2579," Checks that the values of the parameters passed\n to a function fall within the defined bounds.\n The parameter limits are defined using ISO 31-11 notation.\n https://en.wikipedia.org/wiki/ISO_31-11\n\n  (a,b) = a <  x <  b\n  [a,b) = a <= x <  b\n  (a,b] = a <  x <= b\n  [a,b] = a <= x <= b\n\n @param array $limits Boundary limit definitions for each parameter\n                      ['var1' => limit, 'var2' => limit, ...]\n @param array $params Parameters and their value to check against the defined limits\n                      ['var1' => value, 'var2' => value, ...]\n\n @return bool True if all parameters are within defined limits\n\n @throws Exception\\BadParameterException if a parameter without bounds limits is defined\n @throws Exception\\OutOfBoundsException if any parameter is outside the defined limits\n @throws Exception\\BadDataException if an unknown bounds character is used\n", Checks that the values of the parameters passed,"    public static function checkLimits(array $limits, array $params)    {        // All parameters should have limit bounds defined        $undefined_limits = \array_diff_key($params, $limits);        if (!empty($undefined_limits)) {            throw new Exception\BadParameterException('Parameter without bounds limit defined: ' . \print_r($undefined_limits, true));        }        foreach ($params as $variable => $value) {            // Remove the first character: ( or [            $lower_endpoint = \substr($limits[$variable], 0, 1);            // Remove the last character: ) or ]            $upper_endpoint = \substr($limits[$variable], -1, 1);            // Set the lower and upper limits: #,#            [$lower_limit, $upper_limit] = \explode(',', \substr($limits[$variable], 1, -1));            // If the lower limit is -∞, we are always in bounds.            if ($lower_limit != ""-∞"") {                switch ($lower_endpoint) {                    case '(':                        if ($value <= $lower_limit) {                            throw new Exception\OutOfBoundsException(""{$variable} must be > {$lower_limit} (lower bound), given {$value}"");                        }                        break;                    case '[':                        if ($value < $lower_limit) {                            throw new Exception\OutOfBoundsException(""{$variable} must be >= {$lower_limit} (lower bound), given {$value}"");                        }                        break;                    default:                        throw new Exception\BadDataException(""Unknown lower endpoint character: {$lower_limit}"");                }            }            // If the upper limit is ∞, we are always in bounds.            if ($upper_limit != ""∞"") {                switch ($upper_endpoint) {                    case ')':                        if ($value >= $upper_limit) {                            throw new Exception\OutOfBoundsException(""{$variable} must be < {$upper_limit} (upper bound), given {$value}"");                        }                        break;                    case ']':                        if ($value > $upper_limit) {                            throw new Exception\OutOfBoundsException(""{$variable} must be <= {$upper_limit} (upper bound), given {$value}"");                        }                        break;                    default:                        throw new Exception\BadDataException(""Unknown upper endpoint character: {$upper_endpoint}"");                }            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_TDistribution_3292," Student's t distribution table of selected values\n\n Tables for one sided and two sided,\n Initial index is degrees of freedom (ν).\n Second index is confidence level precentage, or alpha value (α).\n\n https://en.wikipedia.org/wiki/Student%27s_t-distribution#Table_of_selected_values\n\n This table is provided only for completeness. It is common for statistics\n textbooks to include this table, so this library does as well. It is better\n to use the StudentT distribution functions when a t value is required.\n", Student's t distribution table of selected values,"class TDistribution{    /**     * One-sided t distribution table     * Confidence level percentaces     * @var array     */    private const ONE_SIDED_CONFIDENCE_LEVEL = [        1          => [ 0 => 0, 75 => 1.000, 80 => 1.376, 85 => 1.963, 90 => 3.078, 95 => 6.314, '97.5' => 12.71, 99 => 31.82, '99.5' => 63.66, '99.75' => 127.3, '99.9' => 318.3, '99.95' => 636.6 ],        2          => [ 0 => 0, 75 => 0.816, 80 => 1.080, 85 => 1.386, 90 => 1.886, 95 => 2.920, '97.5' => 4.303, 99 => 6.965, '99.5' => 9.925, '99.75' => 14.09, '99.9' => 22.33, '99.95' => 31.60 ],        3          => [ 0 => 0, 75 => 0.765, 80 => 0.978, 85 => 1.250, 90 => 1.638, 95 => 2.353, '97.5' => 3.182, 99 => 4.541, '99.5' => 5.841, '99.75' => 7.453, '99.9' => 10.21, '99.95' => 12.92 ],        4          => [ 0 => 0, 75 => 0.741, 80 => 0.941, 85 => 1.190, 90 => 1.533, 95 => 2.132, '97.5' => 2.776, 99 => 3.747, '99.5' => 4.604, '99.75' => 5.598, '99.9' => 7.173, '99.95' => 8.610 ],        5          => [ 0 => 0, 75 => 0.727, 80 => 0.920, 85 => 1.156, 90 => 1.476, 95 => 2.015, '97.5' => 2.571, 99 => 3.365, '99.5' => 4.032, '99.75' => 4.773, '99.9' => 5.893, '99.95' => 6.869 ],        6          => [ 0 => 0, 75 => 0.718, 80 => 0.906, 85 => 1.134, 90 => 1.440, 95 => 1.943, '97.5' => 2.447, 99 => 3.143, '99.5' => 3.707, '99.75' => 4.317, '99.9' => 5.208, '99.95' => 5.959 ],        7          => [ 0 => 0, 75 => 0.711, 80 => 0.896, 85 => 1.119, 90 => 1.415, 95 => 1.895, '97.5' => 2.365, 99 => 2.998, '99.5' => 3.499, '99.75' => 4.029, '99.9' => 4.785, '99.95' => 5.408 ],        8          => [ 0 => 0, 75 => 0.706, 80 => 0.889, 85 => 1.108, 90 => 1.397, 95 => 1.860, '97.5' => 2.306, 99 => 2.896, '99.5' => 3.355, '99.75' => 3.833, '99.9' => 4.501, '99.95' => 5.041 ],        9          => [ 0 => 0, 75 => 0.703, 80 => 0.883, 85 => 1.100, 90 => 1.383, 95 => 1.833, '97.5' => 2.262, 99 => 2.821, '99.5' => 3.250, '99.75' => 3.690, '99.9' => 4.297, '99.95' => 4.781 ],        10         => [ 0 => 0, 75 => 0.700, 80 => 0.879, 85 => 1.093, 90 => 1.372, 95 => 1.812, '97.5' => 2.228, 99 => 2.764, '99.5' => 3.169, '99.75' => 3.581, '99.9' => 4.144, '99.95' => 4.587 ],        11         => [ 0 => 0, 75 => 0.697, 80 => 0.876, 85 => 1.088, 90 => 1.363, 95 => 1.796, '97.5' => 2.201, 99 => 2.718, '99.5' => 3.106, '99.75' => 3.497, '99.9' => 4.025, '99.95' => 4.437 ],        12         => [ 0 => 0, 75 => 0.695, 80 => 0.873, 85 => 1.083, 90 => 1.356, 95 => 1.782, '97.5' => 2.179, 99 => 2.681, '99.5' => 3.055, '99.75' => 3.428, '99.9' => 3.930, '99.95' => 4.318 ],        13         => [ 0 => 0, 75 => 0.694, 80 => 0.870, 85 => 1.079, 90 => 1.350, 95 => 1.771, '97.5' => 2.160, 99 => 2.650, '99.5' => 3.012, '99.75' => 3.372, '99.9' => 3.852, '99.95' => 4.221 ],        14         => [ 0 => 0, 75 => 0.692, 80 => 0.868, 85 => 1.076, 90 => 1.345, 95 => 1.761, '97.5' => 2.145, 99 => 2.624, '99.5' => 2.977, '99.75' => 3.326, '99.9' => 3.787, '99.95' => 4.140 ],        15         => [ 0 => 0, 75 => 0.691, 80 => 0.866, 85 => 1.074, 90 => 1.341, 95 => 1.753, '97.5' => 2.131, 99 => 2.602, '99.5' => 2.947, '99.75' => 3.286, '99.9' => 3.733, '99.95' => 4.073 ],        16         => [ 0 => 0, 75 => 0.690, 80 => 0.865, 85 => 1.071, 90 => 1.337, 95 => 1.746, '97.5' => 2.120, 99 => 2.583, '99.5' => 2.921, '99.75' => 3.252, '99.9' => 3.686, '99.95' => 4.015 ],        17         => [ 0 => 0, 75 => 0.689, 80 => 0.863, 85 => 1.069, 90 => 1.333, 95 => 1.740, '97.5' => 2.110, 99 => 2.567, '99.5' => 2.898, '99.75' => 3.222, '99.9' => 3.646, '99.95' => 3.965 ],        18         => [ 0 => 0, 75 => 0.688, 80 => 0.862, 85 => 1.067, 90 => 1.330, 95 => 1.734, '97.5' => 2.101, 99 => 2.552, '99.5' => 2.878, '99.75' => 3.197, '99.9' => 3.610, '99.95' => 3.922 ],        19         => [ 0 => 0, 75 => 0.688, 80 => 0.861, 85 => 1.066, 90 => 1.328, 95 => 1.729, '97.5' => 2.093, 99 => 2.539, '99.5' => 2.861, '99.75' => 3.174, '99.9' => 3.579, '99.95' => 3.883 ],        20         => [ 0 => 0, 75 => 0.687, 80 => 0.860, 85 => 1.064, 90 => 1.325, 95 => 1.725, '97.5' => 2.086, 99 => 2.528, '99.5' => 2.845, '99.75' => 3.153, '99.9' => 3.552, '99.95' => 3.850 ],        21         => [ 0 => 0, 75 => 0.686, 80 => 0.859, 85 => 1.063, 90 => 1.323, 95 => 1.721, '97.5' => 2.080, 99 => 2.518, '99.5' => 2.831, '99.75' => 3.135, '99.9' => 3.527, '99.95' => 3.819 ],        22         => [ 0 => 0, 75 => 0.686, 80 => 0.858, 85 => 1.061, 90 => 1.321, 95 => 1.717, '97.5' => 2.074, 99 => 2.508, '99.5' => 2.819, '99.75' => 3.119, '99.9' => 3.505, '99.95' => 3.792 ],        23         => [ 0 => 0, 75 => 0.685, 80 => 0.858, 85 => 1.060, 90 => 1.319, 95 => 1.714, '97.5' => 2.069, 99 => 2.500, '99.5' => 2.807, '99.75' => 3.104, '99.9' => 3.485, '99.95' => 3.767 ],        24         => [ 0 => 0, 75 => 0.685, 80 => 0.857, 85 => 1.059, 90 => 1.318, 95 => 1.711, '97.5' => 2.064, 99 => 2.492, '99.5' => 2.797, '99.75' => 3.091, '99.9' => 3.467, '99.95' => 3.745 ],        25         => [ 0 => 0, 75 => 0.684, 80 => 0.856, 85 => 1.058, 90 => 1.316, 95 => 1.708, '97.5' => 2.060, 99 => 2.485, '99.5' => 2.787, '99.75' => 3.078, '99.9' => 3.450, '99.95' => 3.725 ],        26         => [ 0 => 0, 75 => 0.684, 80 => 0.856, 85 => 1.058, 90 => 1.315, 95 => 1.706, '97.5' => 2.056, 99 => 2.479, '99.5' => 2.779, '99.75' => 3.067, '99.9' => 3.435, '99.95' => 3.707 ],        27         => [ 0 => 0, 75 => 0.684, 80 => 0.855, 85 => 1.057, 90 => 1.314, 95 => 1.703, '97.5' => 2.052, 99 => 2.473, '99.5' => 2.771, '99.75' => 3.057, '99.9' => 3.421, '99.95' => 3.690 ],        28         => [ 0 => 0, 75 => 0.683, 80 => 0.855, 85 => 1.056, 90 => 1.313, 95 => 1.701, '97.5' => 2.048, 99 => 2.467, '99.5' => 2.763, '99.75' => 3.047, '99.9' => 3.408, '99.95' => 3.674 ],        29         => [ 0 => 0, 75 => 0.683, 80 => 0.854, 85 => 1.055, 90 => 1.311, 95 => 1.699, '97.5' => 2.045, 99 => 2.462, '99.5' => 2.756, '99.75' => 3.038, '99.9' => 3.396, '99.95' => 3.659 ],        30         => [ 0 => 0, 75 => 0.683, 80 => 0.854, 85 => 1.055, 90 => 1.310, 95 => 1.697, '97.5' => 2.042, 99 => 2.457, '99.5' => 2.750, '99.75' => 3.030, '99.9' => 3.385, '99.95' => 3.646 ],        40         => [ 0 => 0, 75 => 0.681, 80 => 0.851, 85 => 1.050, 90 => 1.303, 95 => 1.684, '97.5' => 2.021, 99 => 2.423, '99.5' => 2.704, '99.75' => 2.971, '99.9' => 3.307, '99.95' => 3.551 ],        50         => [ 0 => 0, 75 => 0.679, 80 => 0.849, 85 => 1.047, 90 => 1.299, 95 => 1.676, '97.5' => 2.009, 99 => 2.403, '99.5' => 2.678, '99.75' => 2.937, '99.9' => 3.261, '99.95' => 3.496 ],        60         => [ 0 => 0, 75 => 0.679, 80 => 0.848, 85 => 1.045, 90 => 1.296, 95 => 1.671, '97.5' => 2.000, 99 => 2.390, '99.5' => 2.660, '99.75' => 2.915, '99.9' => 3.232, '99.95' => 3.460 ],        80         => [ 0 => 0, 75 => 0.678, 80 => 0.846, 85 => 1.043, 90 => 1.292, 95 => 1.664, '97.5' => 1.990, 99 => 2.374, '99.5' => 2.639, '99.75' => 2.887, '99.9' => 3.195, '99.95' => 3.416 ],        100        => [ 0 => 0, 75 => 0.677, 80 => 0.845, 85 => 1.042, 90 => 1.290, 95 => 1.660, '97.5' => 1.984, 99 => 2.364, '99.5' => 2.626, '99.75' => 2.871, '99.9' => 3.174, '99.95' => 3.390 ],        120        => [ 0 => 0, 75 => 0.677, 80 => 0.845, 85 => 1.041, 90 => 1.289, 95 => 1.658, '97.5' => 1.980, 99 => 2.358, '99.5' => 2.617, '99.75' => 2.860, '99.9' => 3.160, '99.95' => 3.373 ],        'infinity' => [ 0 => 0, 75 => 0.674, 80 => 0.842, 85 => 1.036, 90 => 1.282, 95 => 1.645, '97.5' => 1.960, 99 => 2.326, '99.5' => 2.576, '99.75' => 2.807, '99.9' => 3.090, '99.95' => 3.291 ],    ];    /**     * One-sided t distribution table     * Alphas     * @var array     */    private const ONE_SIDED_ALPHA = [        1          => [ '0.50' => 0, '0.25' => 1.000, '0.20' => 1.376, '0.15' => 1.963, '0.10' => 3.078, '0.05' => 6.314, '0.025' => 12.71, '0.01' => 31.82, '0.005' => 63.66, '0.0025' => 127.3, '0.001' => 318.3, '0.0005' => 636.6 ],        2          => [ '0.50' => 0, '0.25' => 0.816, '0.20' => 1.080, '0.15' => 1.386, '0.10' => 1.886, '0.05' => 2.920, '0.025' => 4.303, '0.01' => 6.965, '0.005' => 9.925, '0.0025' => 14.09, '0.001' => 22.33, '0.0005' => 31.60 ],        3          => [ '0.50' => 0, '0.25' => 0.765, '0.20' => 0.978, '0.15' => 1.250, '0.10' => 1.638, '0.05' => 2.353, '0.025' => 3.182, '0.01' => 4.541, '0.005' => 5.841, '0.0025' => 7.453, '0.001' => 10.21, '0.0005' => 12.92 ],        4          => [ '0.50' => 0, '0.25' => 0.741, '0.20' => 0.941, '0.15' => 1.190, '0.10' => 1.533, '0.05' => 2.132, '0.025' => 2.776, '0.01' => 3.747, '0.005' => 4.604, '0.0025' => 5.598, '0.001' => 7.173, '0.0005' => 8.610 ],        5          => [ '0.50' => 0, '0.25' => 0.727, '0.20' => 0.920, '0.15' => 1.156, '0.10' => 1.476, '0.05' => 2.015, '0.025' => 2.571, '0.01' => 3.365, '0.005' => 4.032, '0.0025' => 4.773, '0.001' => 5.893, '0.0005' => 6.869 ],        6          => [ '0.50' => 0, '0.25' => 0.718, '0.20' => 0.906, '0.15' => 1.134, '0.10' => 1.440, '0.05' => 1.943, '0.025' => 2.447, '0.01' => 3.143, '0.005' => 3.707, '0.0025' => 4.317, '0.001' => 5.208, '0.0005' => 5.959 ],        7          => [ '0.50' => 0, '0.25' => 0.711, '0.20' => 0.896, '0.15' => 1.119, '0.10' => 1.415, '0.05' => 1.895, '0.025' => 2.365, '0.01' => 2.998, '0.005' => 3.499, '0.0025' => 4.029, '0.001' => 4.785, '0.0005' => 5.408 ],        8          => [ '0.50' => 0, '0.25' => 0.706, '0.20' => 0.889, '0.15' => 1.108, '0.10' => 1.397, '0.05' => 1.860, '0.025' => 2.306, '0.01' => 2.896, '0.005' => 3.355, '0.0025' => 3.833, '0.001' => 4.501, '0.0005' => 5.041 ],        9          => [ '0.50' => 0, '0.25' => 0.703, '0.20' => 0.883, '0.15' => 1.100, '0.10' => 1.383, '0.05' => 1.833, '0.025' => 2.262, '0.01' => 2.821, '0.005' => 3.250, '0.0025' => 3.690, '0.001' => 4.297, '0.0005' => 4.781 ],        10         => [ '0.50' => 0, '0.25' => 0.700, '0.20' => 0.879, '0.15' => 1.093, '0.10' => 1.372, '0.05' => 1.812, '0.025' => 2.228, '0.01' => 2.764, '0.005' => 3.169, '0.0025' => 3.581, '0.001' => 4.144, '0.0005' => 4.587 ],        11         => [ '0.50' => 0, '0.25' => 0.697, '0.20' => 0.876, '0.15' => 1.088, '0.10' => 1.363, '0.05' => 1.796, '0.025' => 2.201, '0.01' => 2.718, '0.005' => 3.106, '0.0025' => 3.497, '0.001' => 4.025, '0.0005' => 4.437 ],        12         => [ '0.50' => 0, '0.25' => 0.695, '0.20' => 0.873, '0.15' => 1.083, '0.10' => 1.356, '0.05' => 1.782, '0.025' => 2.179, '0.01' => 2.681, '0.005' => 3.055, '0.0025' => 3.428, '0.001' => 3.930, '0.0005' => 4.318 ],        13         => [ '0.50' => 0, '0.25' => 0.694, '0.20' => 0.870, '0.15' => 1.079, '0.10' => 1.350, '0.05' => 1.771, '0.025' => 2.160, '0.01' => 2.650, '0.005' => 3.012, '0.0025' => 3.372, '0.001' => 3.852, '0.0005' => 4.221 ],        14         => [ '0.50' => 0, '0.25' => 0.692, '0.20' => 0.868, '0.15' => 1.076, '0.10' => 1.345, '0.05' => 1.761, '0.025' => 2.145, '0.01' => 2.624, '0.005' => 2.977, '0.0025' => 3.326, '0.001' => 3.787, '0.0005' => 4.140 ],        15         => [ '0.50' => 0, '0.25' => 0.691, '0.20' => 0.866, '0.15' => 1.074, '0.10' => 1.341, '0.05' => 1.753, '0.025' => 2.131, '0.01' => 2.602, '0.005' => 2.947, '0.0025' => 3.286, '0.001' => 3.733, '0.0005' => 4.073 ],        16         => [ '0.50' => 0, '0.25' => 0.690, '0.20' => 0.865, '0.15' => 1.071, '0.10' => 1.337, '0.05' => 1.746, '0.025' => 2.120, '0.01' => 2.583, '0.005' => 2.921, '0.0025' => 3.252, '0.001' => 3.686, '0.0005' => 4.015 ],        17         => [ '0.50' => 0, '0.25' => 0.689, '0.20' => 0.863, '0.15' => 1.069, '0.10' => 1.333, '0.05' => 1.740, '0.025' => 2.110, '0.01' => 2.567, '0.005' => 2.898, '0.0025' => 3.222, '0.001' => 3.646, '0.0005' => 3.965 ],        18         => [ '0.50' => 0, '0.25' => 0.688, '0.20' => 0.862, '0.15' => 1.067, '0.10' => 1.330, '0.05' => 1.734, '0.025' => 2.101, '0.01' => 2.552, '0.005' => 2.878, '0.0025' => 3.197, '0.001' => 3.610, '0.0005' => 3.922 ],        19         => [ '0.50' => 0, '0.25' => 0.688, '0.20' => 0.861, '0.15' => 1.066, '0.10' => 1.328, '0.05' => 1.729, '0.025' => 2.093, '0.01' => 2.539, '0.005' => 2.861, '0.0025' => 3.174, '0.001' => 3.579, '0.0005' => 3.883 ],        20         => [ '0.50' => 0, '0.25' => 0.687, '0.20' => 0.860, '0.15' => 1.064, '0.10' => 1.325, '0.05' => 1.725, '0.025' => 2.086, '0.01' => 2.528, '0.005' => 2.845, '0.0025' => 3.153, '0.001' => 3.552, '0.0005' => 3.850 ],        21         => [ '0.50' => 0, '0.25' => 0.686, '0.20' => 0.859, '0.15' => 1.063, '0.10' => 1.323, '0.05' => 1.721, '0.025' => 2.080, '0.01' => 2.518, '0.005' => 2.831, '0.0025' => 3.135, '0.001' => 3.527, '0.0005' => 3.819 ],        22         => [ '0.50' => 0, '0.25' => 0.686, '0.20' => 0.858, '0.15' => 1.061, '0.10' => 1.321, '0.05' => 1.717, '0.025' => 2.074, '0.01' => 2.508, '0.005' => 2.819, '0.0025' => 3.119, '0.001' => 3.505, '0.0005' => 3.792 ],        23         => [ '0.50' => 0, '0.25' => 0.685, '0.20' => 0.858, '0.15' => 1.060, '0.10' => 1.319, '0.05' => 1.714, '0.025' => 2.069, '0.01' => 2.500, '0.005' => 2.807, '0.0025' => 3.104, '0.001' => 3.485, '0.0005' => 3.767 ],        24         => [ '0.50' => 0, '0.25' => 0.685, '0.20' => 0.857, '0.15' => 1.059, '0.10' => 1.318, '0.05' => 1.711, '0.025' => 2.064, '0.01' => 2.492, '0.005' => 2.797, '0.0025' => 3.091, '0.001' => 3.467, '0.0005' => 3.745 ],        25         => [ '0.50' => 0, '0.25' => 0.684, '0.20' => 0.856, '0.15' => 1.058, '0.10' => 1.316, '0.05' => 1.708, '0.025' => 2.060, '0.01' => 2.485, '0.005' => 2.787, '0.0025' => 3.078, '0.001' => 3.450, '0.0005' => 3.725 ],        26         => [ '0.50' => 0, '0.25' => 0.684, '0.20' => 0.856, '0.15' => 1.058, '0.10' => 1.315, '0.05' => 1.706, '0.025' => 2.056, '0.01' => 2.479, '0.005' => 2.779, '0.0025' => 3.067, '0.001' => 3.435, '0.0005' => 3.707 ],        27         => [ '0.50' => 0, '0.25' => 0.684, '0.20' => 0.855, '0.15' => 1.057, '0.10' => 1.314, '0.05' => 1.703, '0.025' => 2.052, '0.01' => 2.473, '0.005' => 2.771, '0.0025' => 3.057, '0.001' => 3.421, '0.0005' => 3.690 ],        28         => [ '0.50' => 0, '0.25' => 0.683, '0.20' => 0.855, '0.15' => 1.056, '0.10' => 1.313, '0.05' => 1.701, '0.025' => 2.048, '0.01' => 2.467, '0.005' => 2.763, '0.0025' => 3.047, '0.001' => 3.408, '0.0005' => 3.674 ],        29         => [ '0.50' => 0, '0.25' => 0.683, '0.20' => 0.854, '0.15' => 1.055, '0.10' => 1.311, '0.05' => 1.699, '0.025' => 2.045, '0.01' => 2.462, '0.005' => 2.756, '0.0025' => 3.038, '0.001' => 3.396, '0.0005' => 3.659 ],        30         => [ '0.50' => 0, '0.25' => 0.683, '0.20' => 0.854, '0.15' => 1.055, '0.10' => 1.310, '0.05' => 1.697, '0.025' => 2.042, '0.01' => 2.457, '0.005' => 2.750, '0.0025' => 3.030, '0.001' => 3.385, '0.0005' => 3.646 ],        40         => [ '0.50' => 0, '0.25' => 0.681, '0.20' => 0.851, '0.15' => 1.050, '0.10' => 1.303, '0.05' => 1.684, '0.025' => 2.021, '0.01' => 2.423, '0.005' => 2.704, '0.0025' => 2.971, '0.001' => 3.307, '0.0005' => 3.551 ],        50         => [ '0.50' => 0, '0.25' => 0.679, '0.20' => 0.849, '0.15' => 1.047, '0.10' => 1.299, '0.05' => 1.676, '0.025' => 2.009, '0.01' => 2.403, '0.005' => 2.678, '0.0025' => 2.937, '0.001' => 3.261, '0.0005' => 3.496 ],        60         => [ '0.50' => 0, '0.25' => 0.679, '0.20' => 0.848, '0.15' => 1.045, '0.10' => 1.296, '0.05' => 1.671, '0.025' => 2.000, '0.01' => 2.390, '0.005' => 2.660, '0.0025' => 2.915, '0.001' => 3.232, '0.0005' => 3.460 ],        80         => [ '0.50' => 0, '0.25' => 0.678, '0.20' => 0.846, '0.15' => 1.043, '0.10' => 1.292, '0.05' => 1.664, '0.025' => 1.990, '0.01' => 2.374, '0.005' => 2.639, '0.0025' => 2.887, '0.001' => 3.195, '0.0005' => 3.416 ],        100        => [ '0.50' => 0, '0.25' => 0.677, '0.20' => 0.845, '0.15' => 1.042, '0.10' => 1.290, '0.05' => 1.660, '0.025' => 1.984, '0.01' => 2.364, '0.005' => 2.626, '0.0025' => 2.871, '0.001' => 3.174, '0.0005' => 3.390 ],        120        => [ '0.50' => 0, '0.25' => 0.677, '0.20' => 0.845, '0.15' => 1.041, '0.10' => 1.289, '0.05' => 1.658, '0.025' => 1.980, '0.01' => 2.358, '0.005' => 2.617, '0.0025' => 2.860, '0.001' => 3.160, '0.0005' => 3.373 ],        'infinity' => [ '0.50' => 0, '0.25' => 0.674, '0.20' => 0.842, '0.15' => 1.036, '0.10' => 1.282, '0.05' => 1.645, '0.025' => 1.960, '0.01' => 2.326, '0.005' => 2.576, '0.0025' => 2.807, '0.001' => 3.090, '0.0005' => 3.291 ],    ];    /**     * Two-sided t distribution table     * Confidence level percentaces     * @var array     */    private const TWO_SIDED_CONFIDENCE_LEVEL = [        1          => [ 0 => 0, 50 => 1.000, 60 => 1.376, 70 => 1.963, 80 => 3.078, 90 => 6.314, 95 => 12.71, 98 => 31.82, 99 => 63.66, '99.5' => 127.3, '99.8' => 318.3, '99.9' => 636.6 ],        2          => [ 0 => 0, 50 => 0.816, 60 => 1.080, 70 => 1.386, 80 => 1.886, 90 => 2.920, 95 => 4.303, 98 => 6.965, 99 => 9.925, '99.5' => 14.09, '99.8' => 22.33, '99.9' => 31.60 ],        3          => [ 0 => 0, 50 => 0.765, 60 => 0.978, 70 => 1.250, 80 => 1.638, 90 => 2.353, 95 => 3.182, 98 => 4.541, 99 => 5.841, '99.5' => 7.453, '99.8' => 10.21, '99.9' => 12.92 ],        4          => [ 0 => 0, 50 => 0.741, 60 => 0.941, 70 => 1.190, 80 => 1.533, 90 => 2.132, 95 => 2.776, 98 => 3.747, 99 => 4.604, '99.5' => 5.598, '99.8' => 7.173, '99.9' => 8.610 ],        5          => [ 0 => 0, 50 => 0.727, 60 => 0.920, 70 => 1.156, 80 => 1.476, 90 => 2.015, 95 => 2.571, 98 => 3.365, 99 => 4.032, '99.5' => 4.773, '99.8' => 5.893, '99.9' => 6.869 ],        6          => [ 0 => 0, 50 => 0.718, 60 => 0.906, 70 => 1.134, 80 => 1.440, 90 => 1.943, 95 => 2.447, 98 => 3.143, 99 => 3.707, '99.5' => 4.317, '99.8' => 5.208, '99.9' => 5.959 ],        7          => [ 0 => 0, 50 => 0.711, 60 => 0.896, 70 => 1.119, 80 => 1.415, 90 => 1.895, 95 => 2.365, 98 => 2.998, 99 => 3.499, '99.5' => 4.029, '99.8' => 4.785, '99.9' => 5.408 ],        8          => [ 0 => 0, 50 => 0.706, 60 => 0.889, 70 => 1.108, 80 => 1.397, 90 => 1.860, 95 => 2.306, 98 => 2.896, 99 => 3.355, '99.5' => 3.833, '99.8' => 4.501, '99.9' => 5.041 ],        9          => [ 0 => 0, 50 => 0.703, 60 => 0.883, 70 => 1.100, 80 => 1.383, 90 => 1.833, 95 => 2.262, 98 => 2.821, 99 => 3.250, '99.5' => 3.690, '99.8' => 4.297, '99.9' => 4.781 ],        10         => [ 0 => 0, 50 => 0.700, 60 => 0.879, 70 => 1.093, 80 => 1.372, 90 => 1.812, 95 => 2.228, 98 => 2.764, 99 => 3.169, '99.5' => 3.581, '99.8' => 4.144, '99.9' => 4.587 ],        11         => [ 0 => 0, 50 => 0.697, 60 => 0.876, 70 => 1.088, 80 => 1.363, 90 => 1.796, 95 => 2.201, 98 => 2.718, 99 => 3.106, '99.5' => 3.497, '99.8' => 4.025, '99.9' => 4.437 ],        12         => [ 0 => 0, 50 => 0.695, 60 => 0.873, 70 => 1.083, 80 => 1.356, 90 => 1.782, 95 => 2.179, 98 => 2.681, 99 => 3.055, '99.5' => 3.428, '99.8' => 3.930, '99.9' => 4.318 ],        13         => [ 0 => 0, 50 => 0.694, 60 => 0.870, 70 => 1.079, 80 => 1.350, 90 => 1.771, 95 => 2.160, 98 => 2.650, 99 => 3.012, '99.5' => 3.372, '99.8' => 3.852, '99.9' => 4.221 ],        14         => [ 0 => 0, 50 => 0.692, 60 => 0.868, 70 => 1.076, 80 => 1.345, 90 => 1.761, 95 => 2.145, 98 => 2.624, 99 => 2.977, '99.5' => 3.326, '99.8' => 3.787, '99.9' => 4.140 ],        15         => [ 0 => 0, 50 => 0.691, 60 => 0.866, 70 => 1.074, 80 => 1.341, 90 => 1.753, 95 => 2.131, 98 => 2.602, 99 => 2.947, '99.5' => 3.286, '99.8' => 3.733, '99.9' => 4.073 ],        16         => [ 0 => 0, 50 => 0.690, 60 => 0.865, 70 => 1.071, 80 => 1.337, 90 => 1.746, 95 => 2.120, 98 => 2.583, 99 => 2.921, '99.5' => 3.252, '99.8' => 3.686, '99.9' => 4.015 ],        17         => [ 0 => 0, 50 => 0.689, 60 => 0.863, 70 => 1.069, 80 => 1.333, 90 => 1.740, 95 => 2.110, 98 => 2.567, 99 => 2.898, '99.5' => 3.222, '99.8' => 3.646, '99.9' => 3.965 ],        18         => [ 0 => 0, 50 => 0.688, 60 => 0.862, 70 => 1.067, 80 => 1.330, 90 => 1.734, 95 => 2.101, 98 => 2.552, 99 => 2.878, '99.5' => 3.197, '99.8' => 3.610, '99.9' => 3.922 ],        19         => [ 0 => 0, 50 => 0.688, 60 => 0.861, 70 => 1.066, 80 => 1.328, 90 => 1.729, 95 => 2.093, 98 => 2.539, 99 => 2.861, '99.5' => 3.174, '99.8' => 3.579, '99.9' => 3.883 ],        20         => [ 0 => 0, 50 => 0.687, 60 => 0.860, 70 => 1.064, 80 => 1.325, 90 => 1.725, 95 => 2.086, 98 => 2.528, 99 => 2.845, '99.5' => 3.153, '99.8' => 3.552, '99.9' => 3.850 ],        21         => [ 0 => 0, 50 => 0.686, 60 => 0.859, 70 => 1.063, 80 => 1.323, 90 => 1.721, 95 => 2.080, 98 => 2.518, 99 => 2.831, '99.5' => 3.135, '99.8' => 3.527, '99.9' => 3.819 ],        22         => [ 0 => 0, 50 => 0.686, 60 => 0.858, 70 => 1.061, 80 => 1.321, 90 => 1.717, 95 => 2.074, 98 => 2.508, 99 => 2.819, '99.5' => 3.119, '99.8' => 3.505, '99.9' => 3.792 ],        23         => [ 0 => 0, 50 => 0.685, 60 => 0.858, 70 => 1.060, 80 => 1.319, 90 => 1.714, 95 => 2.069, 98 => 2.500, 99 => 2.807, '99.5' => 3.104, '99.8' => 3.485, '99.9' => 3.767 ],        24         => [ 0 => 0, 50 => 0.685, 60 => 0.857, 70 => 1.059, 80 => 1.318, 90 => 1.711, 95 => 2.064, 98 => 2.492, 99 => 2.797, '99.5' => 3.091, '99.8' => 3.467, '99.9' => 3.745 ],        25         => [ 0 => 0, 50 => 0.684, 60 => 0.856, 70 => 1.058, 80 => 1.316, 90 => 1.708, 95 => 2.060, 98 => 2.485, 99 => 2.787, '99.5' => 3.078, '99.8' => 3.450, '99.9' => 3.725 ],        26         => [ 0 => 0, 50 => 0.684, 60 => 0.856, 70 => 1.058, 80 => 1.315, 90 => 1.706, 95 => 2.056, 98 => 2.479, 99 => 2.779, '99.5' => 3.067, '99.8' => 3.435, '99.9' => 3.707 ],        27         => [ 0 => 0, 50 => 0.684, 60 => 0.855, 70 => 1.057, 80 => 1.314, 90 => 1.703, 95 => 2.052, 98 => 2.473, 99 => 2.771, '99.5' => 3.057, '99.8' => 3.421, '99.9' => 3.690 ],        28         => [ 0 => 0, 50 => 0.683, 60 => 0.855, 70 => 1.056, 80 => 1.313, 90 => 1.701, 95 => 2.048, 98 => 2.467, 99 => 2.763, '99.5' => 3.047, '99.8' => 3.408, '99.9' => 3.674 ],        29         => [ 0 => 0, 50 => 0.683, 60 => 0.854, 70 => 1.055, 80 => 1.311, 90 => 1.699, 95 => 2.045, 98 => 2.462, 99 => 2.756, '99.5' => 3.038, '99.8' => 3.396, '99.9' => 3.659 ],        30         => [ 0 => 0, 50 => 0.683, 60 => 0.854, 70 => 1.055, 80 => 1.310, 90 => 1.697, 95 => 2.042, 98 => 2.457, 99 => 2.750, '99.5' => 3.030, '99.8' => 3.385, '99.9' => 3.646 ],        40         => [ 0 => 0, 50 => 0.681, 60 => 0.851, 70 => 1.050, 80 => 1.303, 90 => 1.684, 95 => 2.021, 98 => 2.423, 99 => 2.704, '99.5' => 2.971, '99.8' => 3.307, '99.9' => 3.551 ],        50         => [ 0 => 0, 50 => 0.679, 60 => 0.849, 70 => 1.047, 80 => 1.299, 90 => 1.676, 95 => 2.009, 98 => 2.403, 99 => 2.678, '99.5' => 2.937, '99.8' => 3.261, '99.9' => 3.496 ],        60         => [ 0 => 0, 50 => 0.679, 60 => 0.848, 70 => 1.045, 80 => 1.296, 90 => 1.671, 95 => 2.000, 98 => 2.390, 99 => 2.660, '99.5' => 2.915, '99.8' => 3.232, '99.9' => 3.460 ],        80         => [ 0 => 0, 50 => 0.678, 60 => 0.846, 70 => 1.043, 80 => 1.292, 90 => 1.664, 95 => 1.990, 98 => 2.374, 99 => 2.639, '99.5' => 2.887, '99.8' => 3.195, '99.9' => 3.416 ],        100        => [ 0 => 0, 50 => 0.677, 60 => 0.845, 70 => 1.042, 80 => 1.290, 90 => 1.660, 95 => 1.984, 98 => 2.364, 99 => 2.626, '99.5' => 2.871, '99.8' => 3.174, '99.9' => 3.390 ],        120        => [ 0 => 0, 50 => 0.677, 60 => 0.845, 70 => 1.041, 80 => 1.289, 90 => 1.658, 95 => 1.980, 98 => 2.358, 99 => 2.617, '99.5' => 2.860, '99.8' => 3.160, '99.9' => 3.373 ],        'infinity' => [ 0 => 0, 50 => 0.674, 60 => 0.842, 70 => 1.036, 80 => 1.282, 90 => 1.645, 95 => 1.960, 98 => 2.326, 99 => 2.576, '99.5' => 2.807, '99.8' => 3.090, '99.9' => 3.291 ],    ];    /**     * Two-sided t distribution table     * Alphas     * @var array     */    private const TWO_SIDED_ALPHA = [        1          => [ '1.00' => 0, '0.50' => 1.000, '0.40' => 1.376, '0.30' => 1.963, '0.20' => 3.078, '0.10' => 6.314, '0.05' => 12.71, '0.02' => 31.82, '0.01' => 63.66, '0.005' => 127.3, '0.002' => 318.3, '0.001' => 636.6 ],        2          => [ '1.00' => 0, '0.50' => 0.816, '0.40' => 1.080, '0.30' => 1.386, '0.20' => 1.886, '0.10' => 2.920, '0.05' => 4.303, '0.02' => 6.965, '0.01' => 9.925, '0.005' => 14.09, '0.002' => 22.33, '0.001' => 31.60 ],        3          => [ '1.00' => 0, '0.50' => 0.765, '0.40' => 0.978, '0.30' => 1.250, '0.20' => 1.638, '0.10' => 2.353, '0.05' => 3.182, '0.02' => 4.541, '0.01' => 5.841, '0.005' => 7.453, '0.002' => 10.21, '0.001' => 12.92 ],        4          => [ '1.00' => 0, '0.50' => 0.741, '0.40' => 0.941, '0.30' => 1.190, '0.20' => 1.533, '0.10' => 2.132, '0.05' => 2.776, '0.02' => 3.747, '0.01' => 4.604, '0.005' => 5.598, '0.002' => 7.173, '0.001' => 8.610 ],        5          => [ '1.00' => 0, '0.50' => 0.727, '0.40' => 0.920, '0.30' => 1.156, '0.20' => 1.476, '0.10' => 2.015, '0.05' => 2.571, '0.02' => 3.365, '0.01' => 4.032, '0.005' => 4.773, '0.002' => 5.893, '0.001' => 6.869 ],        6          => [ '1.00' => 0, '0.50' => 0.718, '0.40' => 0.906, '0.30' => 1.134, '0.20' => 1.440, '0.10' => 1.943, '0.05' => 2.447, '0.02' => 3.143, '0.01' => 3.707, '0.005' => 4.317, '0.002' => 5.208, '0.001' => 5.959 ],        7          => [ '1.00' => 0, '0.50' => 0.711, '0.40' => 0.896, '0.30' => 1.119, '0.20' => 1.415, '0.10' => 1.895, '0.05' => 2.365, '0.02' => 2.998, '0.01' => 3.499, '0.005' => 4.029, '0.002' => 4.785, '0.001' => 5.408 ],        8          => [ '1.00' => 0, '0.50' => 0.706, '0.40' => 0.889, '0.30' => 1.108, '0.20' => 1.397, '0.10' => 1.860, '0.05' => 2.306, '0.02' => 2.896, '0.01' => 3.355, '0.005' => 3.833, '0.002' => 4.501, '0.001' => 5.041 ],        9          => [ '1.00' => 0, '0.50' => 0.703, '0.40' => 0.883, '0.30' => 1.100, '0.20' => 1.383, '0.10' => 1.833, '0.05' => 2.262, '0.02' => 2.821, '0.01' => 3.250, '0.005' => 3.690, '0.002' => 4.297, '0.001' => 4.781 ],        10         => [ '1.00' => 0, '0.50' => 0.700, '0.40' => 0.879, '0.30' => 1.093, '0.20' => 1.372, '0.10' => 1.812, '0.05' => 2.228, '0.02' => 2.764, '0.01' => 3.169, '0.005' => 3.581, '0.002' => 4.144, '0.001' => 4.587 ],        11         => [ '1.00' => 0, '0.50' => 0.697, '0.40' => 0.876, '0.30' => 1.088, '0.20' => 1.363, '0.10' => 1.796, '0.05' => 2.201, '0.02' => 2.718, '0.01' => 3.106, '0.005' => 3.497, '0.002' => 4.025, '0.001' => 4.437 ],        12         => [ '1.00' => 0, '0.50' => 0.695, '0.40' => 0.873, '0.30' => 1.083, '0.20' => 1.356, '0.10' => 1.782, '0.05' => 2.179, '0.02' => 2.681, '0.01' => 3.055, '0.005' => 3.428, '0.002' => 3.930, '0.001' => 4.318 ],        13         => [ '1.00' => 0, '0.50' => 0.694, '0.40' => 0.870, '0.30' => 1.079, '0.20' => 1.350, '0.10' => 1.771, '0.05' => 2.160, '0.02' => 2.650, '0.01' => 3.012, '0.005' => 3.372, '0.002' => 3.852, '0.001' => 4.221 ],        14         => [ '1.00' => 0, '0.50' => 0.692, '0.40' => 0.868, '0.30' => 1.076, '0.20' => 1.345, '0.10' => 1.761, '0.05' => 2.145, '0.02' => 2.624, '0.01' => 2.977, '0.005' => 3.326, '0.002' => 3.787, '0.001' => 4.140 ],        15         => [ '1.00' => 0, '0.50' => 0.691, '0.40' => 0.866, '0.30' => 1.074, '0.20' => 1.341, '0.10' => 1.753, '0.05' => 2.131, '0.02' => 2.602, '0.01' => 2.947, '0.005' => 3.286, '0.002' => 3.733, '0.001' => 4.073 ],        16         => [ '1.00' => 0, '0.50' => 0.690, '0.40' => 0.865, '0.30' => 1.071, '0.20' => 1.337, '0.10' => 1.746, '0.05' => 2.120, '0.02' => 2.583, '0.01' => 2.921, '0.005' => 3.252, '0.002' => 3.686, '0.001' => 4.015 ],        17         => [ '1.00' => 0, '0.50' => 0.689, '0.40' => 0.863, '0.30' => 1.069, '0.20' => 1.333, '0.10' => 1.740, '0.05' => 2.110, '0.02' => 2.567, '0.01' => 2.898, '0.005' => 3.222, '0.002' => 3.646, '0.001' => 3.965 ],        18         => [ '1.00' => 0, '0.50' => 0.688, '0.40' => 0.862, '0.30' => 1.067, '0.20' => 1.330, '0.10' => 1.734, '0.05' => 2.101, '0.02' => 2.552, '0.01' => 2.878, '0.005' => 3.197, '0.002' => 3.610, '0.001' => 3.922 ],        19         => [ '1.00' => 0, '0.50' => 0.688, '0.40' => 0.861, '0.30' => 1.066, '0.20' => 1.328, '0.10' => 1.729, '0.05' => 2.093, '0.02' => 2.539, '0.01' => 2.861, '0.005' => 3.174, '0.002' => 3.579, '0.001' => 3.883 ],        20         => [ '1.00' => 0, '0.50' => 0.687, '0.40' => 0.860, '0.30' => 1.064, '0.20' => 1.325, '0.10' => 1.725, '0.05' => 2.086, '0.02' => 2.528, '0.01' => 2.845, '0.005' => 3.153, '0.002' => 3.552, '0.001' => 3.850 ],        21         => [ '1.00' => 0, '0.50' => 0.686, '0.40' => 0.859, '0.30' => 1.063, '0.20' => 1.323, '0.10' => 1.721, '0.05' => 2.080, '0.02' => 2.518, '0.01' => 2.831, '0.005' => 3.135, '0.002' => 3.527, '0.001' => 3.819 ],        22         => [ '1.00' => 0, '0.50' => 0.686, '0.40' => 0.858, '0.30' => 1.061, '0.20' => 1.321, '0.10' => 1.717, '0.05' => 2.074, '0.02' => 2.508, '0.01' => 2.819, '0.005' => 3.119, '0.002' => 3.505, '0.001' => 3.792 ],        23         => [ '1.00' => 0, '0.50' => 0.685, '0.40' => 0.858, '0.30' => 1.060, '0.20' => 1.319, '0.10' => 1.714, '0.05' => 2.069, '0.02' => 2.500, '0.01' => 2.807, '0.005' => 3.104, '0.002' => 3.485, '0.001' => 3.767 ],        24         => [ '1.00' => 0, '0.50' => 0.685, '0.40' => 0.857, '0.30' => 1.059, '0.20' => 1.318, '0.10' => 1.711, '0.05' => 2.064, '0.02' => 2.492, '0.01' => 2.797, '0.005' => 3.091, '0.002' => 3.467, '0.001' => 3.745 ],        25         => [ '1.00' => 0, '0.50' => 0.684, '0.40' => 0.856, '0.30' => 1.058, '0.20' => 1.316, '0.10' => 1.708, '0.05' => 2.060, '0.02' => 2.485, '0.01' => 2.787, '0.005' => 3.078, '0.002' => 3.450, '0.001' => 3.725 ],        26         => [ '1.00' => 0, '0.50' => 0.684, '0.40' => 0.856, '0.30' => 1.058, '0.20' => 1.315, '0.10' => 1.706, '0.05' => 2.056, '0.02' => 2.479, '0.01' => 2.779, '0.005' => 3.067, '0.002' => 3.435, '0.001' => 3.707 ],        27         => [ '1.00' => 0, '0.50' => 0.684, '0.40' => 0.855, '0.30' => 1.057, '0.20' => 1.314, '0.10' => 1.703, '0.05' => 2.052, '0.02' => 2.473, '0.01' => 2.771, '0.005' => 3.057, '0.002' => 3.421, '0.001' => 3.690 ],        28         => [ '1.00' => 0, '0.50' => 0.683, '0.40' => 0.855, '0.30' => 1.056, '0.20' => 1.313, '0.10' => 1.701, '0.05' => 2.048, '0.02' => 2.467, '0.01' => 2.763, '0.005' => 3.047, '0.002' => 3.408, '0.001' => 3.674 ],        29         => [ '1.00' => 0, '0.50' => 0.683, '0.40' => 0.854, '0.30' => 1.055, '0.20' => 1.311, '0.10' => 1.699, '0.05' => 2.045, '0.02' => 2.462, '0.01' => 2.756, '0.005' => 3.038, '0.002' => 3.396, '0.001' => 3.659 ],        30         => [ '1.00' => 0, '0.50' => 0.683, '0.40' => 0.854, '0.30' => 1.055, '0.20' => 1.310, '0.10' => 1.697, '0.05' => 2.042, '0.02' => 2.457, '0.01' => 2.750, '0.005' => 3.030, '0.002' => 3.385, '0.001' => 3.646 ],        40         => [ '1.00' => 0, '0.50' => 0.681, '0.40' => 0.851, '0.30' => 1.050, '0.20' => 1.303, '0.10' => 1.684, '0.05' => 2.021, '0.02' => 2.423, '0.01' => 2.704, '0.005' => 2.971, '0.002' => 3.307, '0.001' => 3.551 ],        50         => [ '1.00' => 0, '0.50' => 0.679, '0.40' => 0.849, '0.30' => 1.047, '0.20' => 1.299, '0.10' => 1.676, '0.05' => 2.009, '0.02' => 2.403, '0.01' => 2.678, '0.005' => 2.937, '0.002' => 3.261, '0.001' => 3.496 ],        60         => [ '1.00' => 0, '0.50' => 0.679, '0.40' => 0.848, '0.30' => 1.045, '0.20' => 1.296, '0.10' => 1.671, '0.05' => 2.000, '0.02' => 2.390, '0.01' => 2.660, '0.005' => 2.915, '0.002' => 3.232, '0.001' => 3.460 ],        80         => [ '1.00' => 0, '0.50' => 0.678, '0.40' => 0.846, '0.30' => 1.043, '0.20' => 1.292, '0.10' => 1.664, '0.05' => 1.990, '0.02' => 2.374, '0.01' => 2.639, '0.005' => 2.887, '0.002' => 3.195, '0.001' => 3.416 ],        100        => [ '1.00' => 0, '0.50' => 0.677, '0.40' => 0.845, '0.30' => 1.042, '0.20' => 1.290, '0.10' => 1.660, '0.05' => 1.984, '0.02' => 2.364, '0.01' => 2.626, '0.005' => 2.871, '0.002' => 3.174, '0.001' => 3.390 ],        120        => [ '1.00' => 0, '0.50' => 0.677, '0.40' => 0.845, '0.30' => 1.041, '0.20' => 1.289, '0.10' => 1.658, '0.05' => 1.980, '0.02' => 2.358, '0.01' => 2.617, '0.005' => 2.860, '0.002' => 3.160, '0.001' => 3.373 ],        'infinity' => [ '1.00' => 0, '0.50' => 0.674, '0.40' => 0.842, '0.30' => 1.036, '0.20' => 1.282, '0.10' => 1.645, '0.05' => 1.960, '0.02' => 2.326, '0.01' => 2.576, '0.005' => 2.807, '0.002' => 3.090, '0.001' => 3.291 ],    ];    /**     * Get one-sided t value using confidence level percentage     *     * @param string $ν degrees of freedom     * @param string $cl confidence level percentage     *     * @return float t value     *     * @throws Exception\BadDataException     */    public static function getOneSidedTValueFromConfidenceLevel(string $ν, string $cl): float    {        if (!isset(self::ONE_SIDED_CONFIDENCE_LEVEL[$ν])) {            throw new Exception\BadDataException(""Degrees of freedom $ν is not in the t table."");        }        if (!isset(self::ONE_SIDED_CONFIDENCE_LEVEL[$ν][$cl])) {            throw new Exception\BadDataException(""Confidence level percentage $cl is not in the t table."");        }        return self::ONE_SIDED_CONFIDENCE_LEVEL[$ν][$cl];    }    /**     * Get two-sided t value using confidence level percentage     *     * @param string $ν degrees",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
markrogoyski_math-php_TDistribution_3296, Get two-sided t value using alpha\n\n @param string $ν degrees of freedom\n @param string $α alpha\n\n @return float t value\n\n @throws Exception\\BadDataException\n, Get two-sided t value using alpha,"    public static function getTwoSidedTValueFromAlpha(string $ν, string $α): float    {        if (!isset(self::TWO_SIDED_ALPHA[$ν])) {            throw new Exception\BadDataException(""Degrees of freedom $ν is not in the t table."");        }        if (!isset(self::TWO_SIDED_ALPHA[$ν][$α])) {            throw new Exception\BadDataException(""Alpha $α is not in the t table."");        }        return self::TWO_SIDED_ALPHA[$ν][$α];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ThreePointFormula_3016," Three Point Formula\\n\\n In numerical analysis, the three point formula is used for approximating\\n the derivative of a function at a point in its domain.\\n\\n We can either directly supply a set of inputs and their corresponding outputs\\n for said function, or if we explicitly know the function, we can define it as a\\n callback function and then generate a set of points by evaluating that function\\n at 3 points between a start and end point.\\n", Three Point Formula,"class ThreePointFormula extends NumericalDifferentiation{    /**     * Use the Three Point Formula to approximate the derivative of a function at     * our $target. Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose derivative we are     * approximating.     *     * The Three Point Formula requires we supply 3 points that are evenly spaced     * apart, and that our target equals the x-components of one of our 3 points.     *     * Example: differentiation(2, function($x) {return $x**2;}, 0, 4 ,3) will produce     * a set of arrays by evaluating the callback at 3 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Three Point Formula:     *     *   - If the 2nd point is our $target, use the Midpoint Formula:     *     *              1                     h²     *     f′(x₀) = - [f(x₀+h)-f(x₀-h)] - - f⁽³⁾(ζ₁)     *              2h                    6     *     *         where ζ₁ lies between x₀ - h and x₀ + h     *     *   - If the 1st or 3rd point is our $target, use the Endpoint Formula:     *   - Note that when the 3rd point is our $target, we use a negative h.     *     *              1                               h²     *     f′(x₀) = - [-3f(x₀)+4f(x₀+h)-f(x₀+2h)] + - f⁽³⁾(ζ₀)     *              2h                              3     *     *         where ζ₀ lies between x₀ and x₀ + 2h     *     * @param float          $target  The value at which we are approximating the derivative     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4]].     *                                Example callback: function($x) {return $x**2;}     * @param number         ...$args The arguments of our callback function: start,     *                                end, and n. Example: differentiate($target, $source, 0, 8, 3).     *                                If $source is a set of points, do not input any     *                                $args. Example: approximate($source).     *     * @return float                  The approximation of f'($target), i.e. the derivative     *                                of our input at our target point     *     * @throws Exception\BadDataException     */    public static function differentiate(float $target, $source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input, sort points, make sure spacing is constant, and make        // sure our target is contained in an interval supplied by our $source        self::validate($points, $degree = 3);        $sorted = self::sort($points);        self::isSpacingConstant($sorted);        self::isTargetInPoints($target, $sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $h = ($sorted[2][$x] - $sorted[0][$x]) / 2;        /*         * If the 2nd point is our $target, use the Midpoint Formula:         *         *          1                     h²         * f′(x₀) = - [f(x₀+h)-f(x₀-h)] - - f⁽³⁾(ζ₁)         *          2h                    6         *         *     where ζ₁ lies between x₀ - h and x₀ + h         */        if ($sorted[1][$x] == $target) {            $f⟮x₀⧿h⟯     = $sorted[0][$y];            $f⟮x₀⧾h⟯     = $sorted[2][$y];            $derivative = ($f⟮x₀⧾h⟯ - $f⟮x₀⧿h⟯) / (2 * $h);            return $derivative;        }        /*         * If the 1st or 3rd point is our $target, use the Endpoint Formula:         * Note that when the 3rd point is our $target, we use a negative h.         *         *          1                               h²         * f′(x₀) = - [-3f(x₀)+4f(x₀+h)-f(x₀+2h)] + - f⁽³⁾(ζ₀)         *          2h                              3         *         *     where ζ₀ lies between x₀ and x₀ + 2h         */        if ($sorted[0][$x] == $target) {  // The 1st point is our $target            $f⟮x₀⟯    = $sorted[0][$y];            $f⟮x₀⧾h⟯  = $sorted[1][$y];            $f⟮x₀⧾2h⟯ = $sorted[2][$y];        } else {                          // The 3rd point is our $target, use negative h            $h       = -$h;            $f⟮x₀⟯    = $sorted[2][$y];            $f⟮x₀⧾h⟯  = $sorted[1][$y];            $f⟮x₀⧾2h⟯ = $sorted[0][$y];        }        $derivative = (-3 * $f⟮x₀⟯ + 4 * $f⟮x₀⧾h⟯ - $f⟮x₀⧾2h⟯) / (2 * $h);        return $derivative;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ThreePointFormula_3017," Use the Three Point Formula to approximate the derivative of a function at\\n our $target. Our input can support either a set of arrays, or a callback\\n function with arguments (to produce a set of arrays). Each array in our\\n input contains two numbers which correspond to coordinates (x, y) or\\n equivalently, (x, f(x)), of the function f(x) whose derivative we are\\n approximating.\\n\\n The Three Point Formula requires we supply 3 points that are evenly spaced\\n apart, and that our target equals the x-components of one of our 3 points.\\n\\n Example: differentiation(2, function($x) {return $x a set of arrays by evaluating the callback at 3 evenly spaced points\\n between 0 and 4. Then, this array will be used in our approximation.\\n\\n Three Point Formula:\\n\\n   - If the 2nd point is our $target, use the Midpoint Formula:\\n\\n              1                     h²\\n     f′(x₀) = - [f(x₀+h)-f(x₀-h)] - - f⁽³⁾(ζ₁)\\n              2h                    6\\n\\n         where ζ₁ lies between x₀ - h and x₀ + h\\n\\n   - If the 1st or 3rd point is our $target, use the Endpoint Formula:\\n   - Note that when the 3rd point is our $target, we use a negative h.\\n\\n              1                               h²\\n     f′(x₀) = - [-3f(x₀)+4f(x₀+h)-f(x₀+2h)] + - f⁽³⁾(ζ₀)\\n              2h                              3\\n\\n         where ζ₀ lies between x₀ and x₀ + 2h\\n\\n @param float          $target  The value at which we are approximating the derivative\\n @param callable|array $source  The source of our approximation. Should be either\\n                                a callback function or a set of arrays. Each array\\n                                (point) contains precisely two numbers, an x and y.\\n                                Example array: [[1,2], [2,3], [3,4]].\\n                                Example callback: function($x) {return $x @param number         ...$args The arguments of our callback function: start,\\n                                end, and n. Example: differentiate($target, $source, 0, 8, 3).\\n                                If $source is a set of points, do not input any\\n                                $args. Example: approximate($source).\\n\\n @return float                  The approximation of f'($target), i.e. the derivative\\n                                of our input at our target point\\n\\n @throws Exception\\\\BadDataException\\n", Use the Three Point Formula to approximate the derivative of a function at,"    public static function differentiate(float $target, $source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input, sort points, make sure spacing is constant, and make        // sure our target is contained in an interval supplied by our $source        self::validate($points, $degree = 3);        $sorted = self::sort($points);        self::isSpacingConstant($sorted);        self::isTargetInPoints($target, $sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $h = ($sorted[2][$x] - $sorted[0][$x]) / 2;        /*         * If the 2nd point is our $target, use the Midpoint Formula:         *         *          1                     h²         * f′(x₀) = - [f(x₀+h)-f(x₀-h)] - - f⁽³⁾(ζ₁)         *          2h                    6         *         *     where ζ₁ lies between x₀ - h and x₀ + h         */        if ($sorted[1][$x] == $target) {            $f⟮x₀⧿h⟯     = $sorted[0][$y];            $f⟮x₀⧾h⟯     = $sorted[2][$y];            $derivative = ($f⟮x₀⧾h⟯ - $f⟮x₀⧿h⟯) / (2 * $h);            return $derivative;        }        /*         * If the 1st or 3rd point is our $target, use the Endpoint Formula:         * Note that when the 3rd point is our $target, we use a negative h.         *         *          1                               h²         * f′(x₀) = - [-3f(x₀)+4f(x₀+h)-f(x₀+2h)] + - f⁽³⁾(ζ₀)         *          2h                              3         *         *     where ζ₀ lies between x₀ and x₀ + 2h         */        if ($sorted[0][$x] == $target) {  // The 1st point is our $target            $f⟮x₀⟯    = $sorted[0][$y];            $f⟮x₀⧾h⟯  = $sorted[1][$y];            $f⟮x₀⧾2h⟯ = $sorted[2][$y];        } else {                          // The 3rd point is our $target, use negative h            $h       = -$h;            $f⟮x₀⟯    = $sorted[2][$y];            $f⟮x₀⧾h⟯  = $sorted[1][$y];            $f⟮x₀⧾2h⟯ = $sorted[0][$y];        }        $derivative = (-3 * $f⟮x₀⟯ + 4 * $f⟮x₀⧾h⟯ - $f⟮x₀⧾2h⟯) / (2 * $h);        return $derivative;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ToothGrowth_3358, Dose in milligrams/day observations\n\n @return number[]\n, Dose in milligrams/day observations,"    public function getDose(): array    {        return \array_column(self::DATA, 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_TrapezoidalRule_3031," Trapezoidal Rule\\n\\n In numerical analysis, the trapezoidal rule is a technique for approximating\\n the definite integral of a function.\\n\\n The trapezoidal rule belongs to the closed Newton-Cotes formulas, a group of\\n methods for numerical integration which approximate the integral of a function.\\n We can either directly supply a set of inputs and their corresponding outputs\\n for said function, or if we explicitly know the function, we can define it as a\\n callback function and then generate a set of points by evaluating that function\\n at n points between a start and end point. We then use these values to\\n interpolate a Lagrange polynomial. Finally, we integrate the Lagrange\\n polynomial to approximate the integral of our original function.\\n\\n The trapezoidal rule is produced by integrating the first Lagrange polynomial.\\n\\n https://en.wikipedia.org/wiki/Trapezoidal_rule\\n http://mathworld.wolfram.com/TrapezoidalRule.html\\n http://www.efunda.com/math/num_integration/num_int_newton.cfm\\n", Trapezoidal Rule,"class TrapezoidalRule extends NumericalIntegration{    /**     * Use the Trapezoidal Rule to approximate the definite integral of a     * function f(x). Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose definite integral we     * are approximating.     *     * The bounds of the definite integral to which we are approximating is     * determined by the our inputs.     *     * Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite     * integral of the function that produces these coordinates with a lower     * bound of 0, and an upper bound of 10.     *     * Example: approximate(function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Trapezoidal Rule:     *     * xn        ⁿ⁻¹ xᵢ₊₁     * ∫ f(x)dx = ∑   ∫ f(x)dx     * x₁        ⁱ⁼¹  xᵢ     *     *           ⁿ⁻¹  h     *          = ∑   - [f(xᵢ₊₁) + f(xᵢ)] + O(h³f″(x))     *           ⁱ⁼¹  2     *     *  where h = xᵢ₊₁ - xᵢ     *  note: this implementation does not compute the error term.     * @param callable|array $source The source of our approximation. Should be either     *                               a callback function or a set of arrays. Each array     *                               (point) contains precisely two numbers, an x and y.     *                               Example array: [[1,2], [2,3], [3,4]].     *                               Example callback: function($x) {return $x**2;}     * @param number        ...$args The arguments of our callback function: start,     *                               end, and n. Example: approximate($source, 0, 8, 5).     *                               If $source is a set of points, do not input any     *                               $args. Example: approximate($source).     *     * @return float                The approximation to the integral of f(x)     *     * @throws Exception\BadDataException     * @throws \MathPHP\Exception\IncorrectTypeException     */    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         * ⁿ⁻¹  h         *  ∑   - [f(xᵢ₊₁) + f(xᵢ)]         * ⁱ⁼¹  2         *  where h = xᵢ₊₁ - xᵢ         */        for ($i = 0; $i < $steps; $i++) {            $xᵢ             = $sorted[$i][$x];            $xᵢ₊₁           = $sorted[$i + 1][$x];            $f⟮xᵢ⟯           = $sorted[$i][$y];    // yᵢ            $f⟮xᵢ₊₁⟯         = $sorted[$i + 1][$y];  // yᵢ₊₁            $lagrange       = LagrangePolynomial::interpolate([[$xᵢ, $f⟮xᵢ⟯], [$xᵢ₊₁, $f⟮xᵢ₊₁⟯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xᵢ₊₁) - $integral($xᵢ); // definite integral of lagrange polynomial        }        return $approximation;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_TrapezoidalRule_3032," Use the Trapezoidal Rule to approximate the definite integral of a\n function f(x). Our input can support either a set of arrays, or a callback\n function with arguments (to produce a set of arrays). Each array in our\n input contains two numbers which correspond to coordinates (x, y) or\n equivalently, (x, f(x)), of the function f(x) whose definite integral we\n are approximating.\n\n The bounds of the definite integral to which we are approximating is\n determined by the our inputs.\n\n Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite\n integral of the function that produces these coordinates with a lower\n bound of 0, and an upper bound of 10.\n\n Example: approximate(function($x) {return $x a set of arrays by evaluating the callback at 5 evenly spaced points\n between 0 and 4. Then, this array will be used in our approximation.\n\n Trapezoidal Rule:\n\n xn        ⁿ⁻¹ xᵢ₊₁\n ∫ f(x)dx = ∑   ∫ f(x)dx\n x₁        ⁱ⁼¹  xᵢ\n\n           ⁿ⁻¹  h\n          = ∑   - [f(xᵢ₊₁) + f(xᵢ)] + O(h³f″(x))\n           ⁱ⁼¹  2\n\n  where h = xᵢ₊₁ - xᵢ\n  note: this implementation does not compute the error term.\n @param callable|array $source The source of our approximation. Should be either\n                               a callback function or a set of arrays. Each array\n                               (point) contains precisely two numbers, an x and y.\n                               Example array: [[1,2], [2,3], [3,4]].\n                               Example callback: function($x) {return $x @param number        ...$args The arguments of our callback function: start,\n                               end, and n. Example: approximate($source, 0, 8, 5).\n                               If $source is a set of points, do not input any\n                               $args. Example: approximate($source).\n\n @return float                The approximation to the integral of f(x)\n\n @throws Exception\\BadDataException\n @throws \\MathPHP\\Exception\\IncorrectTypeException\n", Use the Trapezoidal Rule to approximate the definite integral of a,"    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         * ⁿ⁻¹  h         *  ∑   - [f(xᵢ₊₁) + f(xᵢ)]         * ⁱ⁼¹  2         *  where h = xᵢ₊₁ - xᵢ         */        for ($i = 0; $i < $steps; $i++) {            $xᵢ             = $sorted[$i][$x];            $xᵢ₊₁           = $sorted[$i + 1][$x];            $f⟮xᵢ⟯           = $sorted[$i][$y];    // yᵢ            $f⟮xᵢ₊₁⟯         = $sorted[$i + 1][$y];  // yᵢ₊₁            $lagrange       = LagrangePolynomial::interpolate([[$xᵢ, $f⟮xᵢ⟯], [$xᵢ₊₁, $f⟮xᵢ₊₁⟯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xᵢ₊₁) - $integral($xᵢ); // definite integral of lagrange polynomial        }        return $approximation;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Uniform_3196, Continuous uniform distribution - cumulative distribution function\n https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)\n\n cdf = 0      for x < a\n\n       x - a\n cdf = -----  for a ≤ x < b\n       b - a\n\n cdf = 1      x ≥ b\n\n @param float $x percentile\n\n @return float\n, Continuous uniform distribution - cumulative distribution function,    public function cdf(float $x): float    {        $a = $this->a;        $b = $this->b;        if ($x < $a) {            return 0;        }        if ($x >= $b) {            return 1;        }        return ($x - $a) / ($b - $a);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Uniform_3200, Variance of the distribution\n\n      (b - a)²\n σ² = --------\n         12\n\n @return float\n, Variance of the distribution,"    public function variance(): float    {        return \pow($this->b - $this->a, 2) / 12;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Uniform_3268, Discrete uniform distribution\\n https://en.wikipedia.org/wiki/Discrete_uniform_distribution\\n, Discrete uniform distribution,"class Uniform extends Discrete{    /**     * Distribution parameter bounds limits     * a ∈ (-∞,∞)     * b ∈ (-∞,∞)  b > a     * @var array     */    public const PARAMETER_LIMITS = [        'a' => '(-∞,∞)',        'b' => '(-∞,∞)',    ];    /**     * Distribution support bounds limits     * k ∈ (-∞,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'k' => '(-∞,∞)',    ];    /** @var int number of events */    protected $a;    /** @var float probability of success */    protected $b;    /**     * Constructor     *     * @param int $a lower boundary of the distribution     * @param int $b upper boundary of the distribution     *     * @throws Exception\BadDataException if b is ≤ a     */    public function __construct(int $a, int $b)    {        if ($b <= $a) {            throw new Exception\BadDataException(""b must be > a (b:$b a:$a)"");        }        parent::__construct($a, $b);    }    /**     * Probability mass function     *     *       1     * pmf = -     *       n     *     * Percentile n = b - a + 1     *     * @return float     */    public function pmf(): float    {        $a = $this->a;        $b = $this->b;        $n = $b - $a + 1;        return 1 / $n;    }    /**     * Cumulative distribution function     *     *       k - a + 1     * pmf = ---------     *           n     *     * Percentile n = b - a + 1     *     * @param int $k percentile     *     * @return float     */    public function cdf(int $k): float    {        $a = $this->a;        $b = $this->b;        if ($k < $a) {            return 0;        }        if ($k > $b) {            return 1;        }        $n = $b - $a + 1;        return ($k - $a + 1) / $n;    }    /**     * Mean of the distribution     *     *     a + b     * μ = -----     *       2     *     * @return float     */    public function mean(): float    {        $a = $this->a;        $b = $this->b;        return ($a + $b) / 2;    }    /**     * Median of the distribution     *     *     a + b     * μ = -----     *       2     *     * @return float     */    public function median(): float    {        $a = $this->a;        $b = $this->b;        return ($a + $b) / 2;    }    /**     * Variance of the distribution     *     *      (b - a + 1)² - 1     * σ² = ----------------     *             12     *     * @return float     */    public function variance(): float    {        $a = $this->a;        $b = $this->b;        return (($b - $a + 1) ** 2 - 1) / 12;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Uniform_3271, Cumulative distribution function\n\n       k - a + 1\n pmf = ---------\n           n\n\n Percentile n = b - a + 1\n\n @param int $k percentile\n\n @return float\n, Cumulative distribution function,    public function cdf(int $k): float    {        $a = $this->a;        $b = $this->b;        if ($k < $a) {            return 0;        }        if ($k > $b) {            return 1;        }        $n = $b - $a + 1;        return ($k - $a + 1) / $n;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Uniform_3272, Mean of the distribution\n\n     a + b\n μ = -----\n       2\n\n @return float\n, Mean of the distribution,    public function mean(): float    {        $a = $this->a;        $b = $this->b;        return ($a + $b) / 2;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Uniform_3273, Median of the distribution\n\n     a + b\n μ = -----\n       2\n\n @return float\n, Median of the distribution,    public function median(): float    {        $a = $this->a;        $b = $this->b;        return ($a + $b) / 2;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_UsArrests_3362, State names names\\n\\n @return string[]\\n, State names names,    public function getStates(): array    {        return \array_keys(self::DATA);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_UsArrests_3363," Data for a state, with labels\n ['murder' => 13.2, 'assault' => 236, 'urbanPop' => 58, 'rape' => 21.2]\n\n @param string $state\n\n @return number[]\n"," Data for a state, with labels","    public function getStateData(string $state): array    {        return \array_combine(self::LABELS, self::DATA[$state]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_UsArrests_3365," Assault observations for all states\\n ['Alabama' => 236, 'Alaska' => 263, ... ]\\n\\n @return number[]\\n", Assault observations for all states,"    public function getAssault(): array    {        return \array_combine($this->getStates(), \array_column(self::DATA, 1));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_UsArrests_3367," Rape observations for all states\\n ['Alabama' => 21.2, 'Alaska' => 44.5, ... ]\\n\\n @return number[]\\n", Rape observations for all states,"    public function getRape(): array    {        return \array_combine($this->getStates(), \array_column(self::DATA, 3));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Validation_3035," Ensures that the number of subintervals is a multiple of m, or\\n equivalently, if there are n points, that n-1 is a multiple of m\\n\\n @param  array $points\\n @param  int   $m      The number that n-1 should be a multiple of\\n\\n @throws Exception\\\\BadDataException if the number of points minus 1 is not a multiple of m\\n"," Ensures that the number of subintervals is a multiple of m, or","    public static function isSubintervalsMultiple(array $points, int $m)    {        if ((\count($points) - 1) % $m !== 0) {            throw new Exception\BadDataException(                'The number of subintervals must be a multiple of m. Your input must either be a set of n points, where n-1 is a multiple of m, or a callback function evaluated at an n points, where n-1 is a multiple of m'            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Validation_3043, Common validation methods for root finding techniques\n, Common validation methods for root finding techniques,"class Validation{    /**     * Throw an exception if the tolerance is negative.     *     * @param number $tol Tolerance; How close to the actual solution we would like.     *     * @throws Exception\OutOfBoundsException if $tol (the tolerance) is negative     */    public static function tolerance($tol)    {        if ($tol < 0) {            throw new Exception\OutOfBoundsException('Tolerance must be greater than zero.');        }    }    /**     * Verify that the start and end of of an interval are distinct numbers.     *     * @param number $a The start of the interval     * @param number $b The end of the interval     *     * @throws Exception\BadDataException if $a = $b     */    public static function interval($a, $b)    {        if ($a === $b) {            throw new Exception\BadDataException('Start point and end point of interval cannot be the same.');        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_VectorAngleTest_4612, Test data created with online calculator: https://www.emathhelp.net/calculators/linear-algebra/angle-between-two-vectors-calculator\\n @return array\\n, Test data created with online calculator: https://www.emathhelp.net/calculators/linear-algebra/angle-between-two-vectors-calculator,"    public function dataProviderForRadAngle(): array    {        return [            [                [1, 2, 3],                [3, 2, 1],                acos(5 / 7),            ],            [                [1, 2, 3],                [3, 2, 1],                0.775193373310361,            ],            [                [1, 0, 0],                [0, 0, 1],                acos(0),            ],            [                [1, 0, 0],                [0, 0, 1],                1.5707963267949,            ],            [                [1, 0, 0],                [0, 1, 0],                acos(0),            ],            [                [1, 0, 0],                [0, 1, 0],                1.5707963267949            ],            [                [1, 0, 0],                [1, 0, 0],                acos(1),            ],            [                [1, 0, 0],                [1, 0, 0],                0,            ],            [                [-1, 1, 0],                [0, 1, -1],                acos(1 / 2),            ],            [                [-1, 1, 0],                [0, 1, -1],                1.0471975511966,            ],            [                [1, 0, 0],                [-1, 0, 0],                acos(-1),            ],            [                [1, 0, 0],                [-1, 0, 0],                \M_PI            ],            [                [23, 41, 33],                [31, 56, 21],                acos(1851 * \sqrt(2 / 7485431)),            ],            [                [23, 41, 33],                [31, 56, 21],                0.295069161349504,            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_VectorAxiomsTest_4615," Tests of Vector axioms\\n These tests don't test specific functions,\\n but rather matrix axioms which in term make use of multiple functions.\\n If all the Vector math is implemented properly, these tests should\\n all work out according to the axioms.\\n\\n Axioms tested:\\n  - Norms\\n    - |x|₂ ≤ |x|₁ ≤ √n |x|₂\\n    - |x|∞ ≤ |x|₂ ≤ √n |x|∞\\n    - |x|∞ ≤ |x|₁ ≤ √n |x|∞\\n  - Dot product\\n    - A⋅B = B⋅A\\n    - 0⋅A = A⋅0 = 0\\n  - Cross product\\n    - A x B = -(B x A)\\n    - A x 0 = 0\\n    - A x (B + C) = (A x B) + (A x C)\\n  - Cross product / dot product\\n    - (A x B) ⋅ A = 0\\n    - (A x B) ⋅ B = 0\\n    - A ⋅ (B x C) = (A x B) ⋅ C\\n    - A x (B x C) = (A ⋅ C)B - (A ⋅ B)C\\n  - Outer product\\n    - A⨂B = ABᵀ\\n    - A⨂B = AB (direct product)\\n  - Scalar multiplication\\n    - (c + d)A = cA + dA\\n    - c(A + B) = cA + cB\\n    - 1A = A\\n    - 0A = 0\\n    - -1A = -A\\n  - Perpendicular / Perp dot product\\n    - A⋅A⊥ = 0\\n    - A⊥⋅A = 0\\n    - A⋅A⊥ = -A⊥⋅A\\n  - Projections / Perps\\n    - projᵇA + perpᵇA = A\\n    - |projᵇA|² + |perpᵇA|² = |A|²\\n    - projᵇA ⋅ perpᵇA = 0\\n    - |projᵇA⊥ ⋅ perpᵇA| = |projᵇA| |perpᵇA|\\n", Tests of Vector axioms,"class VectorAxiomsTest extends \PHPUnit\Framework\TestCase{    /**     * @test Axiom: |x|₂ ≤ |x|₁ ≤ √n |x|₂     * l²-norm is less than equal to l₁-norm which is less than equal to sqrt n * l²-norm.     *     * @dataProvider dataProviderForSingleVector     */    public function testL2NormLessThanL1NormLessThanSqrtNL2Norm(array $V)    {        // Given        $V = new Vector($V);        $n = $V->getN();        // When        $l₁norm   = $V->l1Norm();        $l²norm   = $V->l2Norm();        $√nl²norm = $n * $l²norm;        // Then        $this->assertLessThanOrEqual($l₁norm, $l²norm);        $this->assertLessThanOrEqual($√nl²norm, $l₁norm);        $this->assertLessThanOrEqual($√nl²norm, $l²norm);    }    /**     * @test Axiom: |x|∞ ≤ |x|₂ ≤ √n |x|∞     * Max norm is less than equal to l₂-norm which is less than equal to sqrt n * max norm.     *     * @dataProvider dataProviderForSingleVector     */    public function testMaxNormLessThtanEQualL2NormLessThanEqualSqrtNMaxNorm(array $V)    {        // Given        $V = new Vector($V);        $n = $V->getN();        // When        $max_norm    = $V->maxNorm();        $l²norm      = $V->l2Norm();        $√n_max_norm = $n * $max_norm;        // Then        $this->assertLessThanOrEqual($l²norm, $max_norm);        $this->assertLessThanOrEqual($√n_max_norm, $l²norm);        $this->assertLessThanOrEqual($√n_max_norm, $max_norm);    }    /**     * @test Axiom: |x|∞ ≤ |x|₁ ≤ √n |x|∞     * Max norm is less than equal to l₁-norm which is less than equal to sqrt n * max norm.     *     * @dataProvider dataProviderForSingleVector     */    public function testMaxNormLessThanEqualL1NormLessThanEqualSqrtNMaxNorm(array $V)    {        // Given        $V = new Vector($V);        $n = $V->getN();        // When        $max_norm    = $V->maxNorm();        $l₁norm      = $V->l1Norm();        $√n_max_norm = $n * $max_norm;        // Then        $this->assertLessThanOrEqual($l₁norm, $max_norm);        $this->assertLessThanOrEqual($√n_max_norm, $l₁norm);        $this->assertLessThanOrEqual($√n_max_norm, $max_norm);    }    public function dataProviderForSingleVector(): array    {        return [            [ [0] ],            [ [1] ],            [ [1, 2] ],            [ [1, 2, 3, 4, 5] ],            [ [5, 2, 7, 4, 2, 7, 4] ],            [ [-4, 6, 3, 7, -4, 5, -8, -11, 5, 0, 5, -2] ],            [ [1, 0, 3, 5, 3, 0, 0, 9, 0] ],            [ [34, 100, 4, 532, 6, 43, 78, 32, 853, 23, 532, 327 ] ],        ];    }    /**     * @test Axiom: A⋅B = B⋅A     * Dot product is commutative     * @dataProvider dataProviderForTwoVectors     */    public function testDotProductCommutative(array $A, array $B)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        // When        $A⋅B = $A->dotProduct($B);        $B⋅A = $B->dotProduct($A);        // Then        $this->assertEquals($A⋅B, $B⋅A);    }    public function dataProviderForTwoVectors(): array    {        return [            [                [1],                [1],            ],            [                [1, 2],                [2, 3],            ],            [                [1, 2, 3, 4, 5],                [4, 5, 6, 7, 8],            ],            [                [3, -5, 2, -12, 4, 9, -4],                [-9, 4, 5, 6, -11, 2, -4],            ],            [                [1, 0, 3],                [0, 1 ,9],            ],        ];    }    /**     * @test Axiom: 0⋅A = A⋅0 = 0     * Dot product of a vector and zero is zero.     * @dataProvider dataProviderForDotProductZero     */    public function testDotProductZero(array $A, array $zero)    {        // Given        $A    = new Vector($A);        $zero = new Vector($zero);        // When        $A⋅zero = $A->dotProduct($zero);        $zero⋅A = $zero->dotProduct($A);        // Then        $this->assertEquals(0, $A⋅zero);        $this->assertEquals(0, $zero⋅A);        $this->assertEquals($A⋅zero, $zero⋅A);    }    public function dataProviderForDotProductZero(): array    {        return [            [                [1],                [0],            ],            [                [1, 2],                [0, 0],            ],            [                [1, 2, 3],                [0, 0, 0],            ],            [                [5, 6, 7, 3, 4, 5, 6, 7, 8, 6, 5],                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],            ],        ];    }    /**     * @test Axiom: A x B = -(B x A)     * Anticommutivity: Reverse order cross product results in a negative cross product     * @dataProvider dataProviderForCrossProduct     */    public function testReverseCrossProduct(array $A, array $B)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        // When        $AxB = $A->crossProduct($B);        $BxA = $B->crossProduct($A);        // Then        $this->assertEquals($AxB[0], -$BxA[0]);        $this->assertEquals($AxB[1], -$BxA[1]);        $this->assertEquals($AxB[2], -$BxA[2]);    }    /**     * @test Axiom: A x 0 = 0     * Cross product property of 0     * @dataProvider dataProviderForCrossProduct     */    public function testCrossProductPropertyOfZero(array $A, array $_)    {        // Given        $A    = new Vector($A);        $zero = new Vector(\array_fill(0, $A->getN(), 0));        // When        $Ax0 = $A->crossProduct($zero);        // Then        $this->assertEquals($zero, $Ax0);        $this->assertEquals($zero->getVector(), $Ax0->getVector());    }    /**     * @test Axiom: A x (B + C) = (A x B) + (A x C)     * Cross product distributivity     * @dataProvider dataProviderForCrossProductThreeVectors     */    public function testCrossProductDistributivity(array $A, array $B, array $C)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        $C = new Vector($C);        // When        $Ax⟮B＋C⟯    = $A->crossProduct($B->add($C));        $⟮AxB⟯＋⟮AxC⟯ = $A->crossProduct($B)->add($A->crossProduct($C));        // Then        $this->assertEquals($Ax⟮B＋C⟯, $⟮AxB⟯＋⟮AxC⟯);        $this->assertEquals($Ax⟮B＋C⟯->getVector(), $⟮AxB⟯＋⟮AxC⟯->getVector());    }    public function dataProviderForCrossProductThreeVectors(): array    {        return [            [                [1, 2, 3],                [4, 5, 6],                [5, 6, 7],            ],            [                [1, 2, 3],                [4, -5, 6],                [5, 6, 7],            ],            [                [-1, 2, -3],                [4,-5,6],                [5, 6, 7],            ],            [                [0,0,0],                [0,0,0],                [0, 0, 0],            ],            [                [4, 5, 6],                [7, 8, 9],                [5, 6, 7],            ],            [                [4, 9, 3],                [12, 11, 4],                [9, 6, 5],            ],            [                [-4, 9, 3],                [12, 11, 4],                [2, 6, 7],            ],            [                [4, -9, 3],                [12, 11, 4],                [5, 3, 7],            ],            [                [4, 9, -3],                [12, 11, 4],                [1, 6, 7],            ],            [                [4, 9, 3],                [-12, 11, 4],                [6, 6, 0],            ],            [                [4, 9, 3],                [12, -11, 4],                [5, 6, 7],            ],            [                [4, 9, 3],                [12, 11, -4],                [1, 2, -7],            ],        ];    }    /**     * @test Axiom: (A x B) ⋅ A = 0     * @test Axiom: (A x B) ⋅ B = 0     * Dot product of either vector with the cross product is always zero.     * @dataProvider dataProviderForCrossProduct     */    public function testCrossProductInnerProductWithEitherVectorIsZero(array $A, array $B)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        // When        $AxB = $A->crossProduct($B);        // Then        $this->assertEquals(0, $AxB->innerProduct($A));        $this->assertEquals(0, $AxB->innerProduct($B));    }    public function dataProviderForCrossProduct(): array    {        return [            [                [1, 2, 3],                [4, 5, 6],            ],            [                [1, 2, 3],                [4, -5, 6],            ],            [                [-1, 2, -3],                [4,-5,6],            ],            [                [0,0,0],                [0,0,0],            ],            [                [4, 5, 6],                [7, 8, 9],            ],            [                [4, 9, 3],                [12, 11, 4],            ],            [                [-4, 9, 3],                [12, 11, 4],            ],            [                [4, -9, 3],                [12, 11, 4],            ],            [                [4, 9, -3],                [12, 11, 4],            ],            [                [4, 9, 3],                [-12, 11, 4],            ],            [                [4, 9, 3],                [12, -11, 4],            ],            [                [4, 9, 3],                [12, 11, -4],            ],        ];    }    /**     * @test Axiom: A ⋅ (B x C) = (A x B) ⋅ C     * Cross product volumn property     * @dataProvider dataProviderForCrossProductThreeVectors     */    public function testCrossProductVolumeProperty(array $A, array $B, array $C)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        $C = new Vector($C);        // When        $A⋅⟮BxC⟯ = $A->dotProduct($B->crossProduct($C));        $⟮AxB⟯⋅C = $A->crossProduct($B)->dotProduct($C);        // Then        $this->assertEquals($A⋅⟮BxC⟯, $⟮AxB⟯⋅C);    }    /**     * @test Axiom: A x (B x C) = (A ⋅ C)B - (A ⋅ B)C     * Lagrange's formula     * @dataProvider dataProviderForCrossProductThreeVectors     */    public function testCrossProductLagrangeFormula(array $A, array $B, array $C)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        $C = new Vector($C);        // When        $Ax⟮BxC⟯ = $A->crossProduct($B->crossProduct($C));        $⟮A⋅C⟯B = $B->scalarMultiply($A->dotProduct($C));        $⟮A⋅B⟯C = $C->scalarMultiply($A->dotProduct($B));        $⟮A⋅C⟯B−⟮A⋅B⟯C = $⟮A⋅C⟯B->subtract($⟮A⋅B⟯C);        // Then        $this->assertEquals($Ax⟮BxC⟯, $⟮A⋅C⟯B−⟮A⋅B⟯C);        $this->assertEquals($Ax⟮BxC⟯->getVector(), $⟮A⋅C⟯B−⟮A⋅B⟯C->getVector());    }    /**     * @test Axiom: A⨂B = ABᵀ     * Outer product is the same as matrix multiplication of A and transpose of B     * @dataProvider dataProviderForOuterProduct     */    public function testOuterProductIsMatrixMultiplicationOfAAndBTranspose(array $A, array $B)    {        // Given Vector A⨂B        $Av   = new Vector($A);        $Bv   = new Vector($B);        $A⨂B = $Av->outerProduct($Bv);        // When Matrix multiplication ABᵀ        $Am = $Av->asColumnMatrix();        $Bᵀ  = new NumericMatrix([            $Bv->getVector()        ]);        $ABᵀ = $Am->multiply($Bᵀ);        // Then        $this->assertEquals($A⨂B, $ABᵀ);    }    public function dataProviderForOuterProduct(): array    {        return [            [                [2],                [6],            ],            [                [2, 5, 8],                [6, 4, 9],            ],            [                [3, 6, 3, 5, 8, 21],                [12, 4, 5, 3, 21, 4],            ],        ];    }    /**     * @test Axiom: A⨂B = AB (direct product)     * Outer product is the same as the direct product     * @dataProvider dataProviderForTwoVectors     */    public function testOuterProductIsDirectProduct(array $A, array $B)    {        // Given Outer product        $Av   = new Vector($A);        $Bv   = new Vector($B);        $A⨂B = $Av->outerProduct($Bv);        // When Direct product        $AB = $Av->directProduct($Bv);        // Then        $this->assertEquals($A⨂B->getMatrix(), $AB->getMatrix());    }    /**     * @test Axiom: (c + d)A = cA + dA     * Additivity in the scalar     * @dataProvider dataProviderForSingleVector     */    public function testAdditivityInTheScalarForScalarMultiplication(array $A)    {        // Given        $A = new Vector($A);        $c = 2;        $d = 9;        // When        $⟮c＋d⟯A  = $A->scalarMultiply($c + $d);        $⟮cA＋dA⟯ = $A->scalarMultiply($c)->add($A->scalarMultiply($d));        // Then        $this->assertEquals($⟮c＋d⟯A, $⟮cA＋dA⟯);        $this->assertEquals($⟮c＋d⟯A->getVector(), $⟮cA＋dA⟯->getVector());    }    /**     * @test Axiom: c(A + B) = cA + cB     * Additivity in the vector     * @dataProvider dataProviderForTwoVectors     */    public function testAdditivityInTheVectorForScalarMultiplication(array $A, array $B)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        $c = 4;        // When        $c⟮A＋B⟯ = $A->add($B)->scalarMultiply($c);        $⟮cA＋cB⟯ = $A->scalarMultiply($c)->add($B->scalarMultiply($c));        // Then        $this->assertEquals($c⟮A＋B⟯, $⟮cA＋cB⟯);        $this->assertEquals($c⟮A＋B⟯->getVector(), $⟮cA＋cB⟯->getVector());    }    /**     * @test Axiom: 1A = A     * Multiplying (scaling) by 1 does not change the vector     * @dataProvider dataProviderForSingleVector     */    public function testScalarMultiplyOneIdentity(array $A)    {        // Given        $A = new Vector($A);        // When        $１A = $A->scalarMultiply(1);        // Then        $this->assertEquals($A, $１A);        $this->assertEquals($A->getVector(), $１A->getVector());    }    /**     * @test Axiom: 0A = 0     * Multiplying (scaling) by 0 gives the zero vector     * @dataProvider dataProviderForSingleVector     */    public function testScalarMultiplyZeroIdentity(array $A)    {        // Given        $A = new Vector($A);        // When        $０A  = $A->scalarMultiply(0);        $zero = new Vector(\array_fill(0, $A->getN(), 0));        // Then        $this->assertEquals($zero, $０A);        $this->assertEquals($zero->getVector(), $０A->getVector());    }    /**     * @test Axiom: -1A = -A     * Additive inverse     * @dataProvider dataProviderForAdditiveInverse     */    public function testScalarMultiplyNegativeOneIdentity(array $A, array $R)    {        // Given        $A = new Vector($A);        // When        $ーA  = $A->scalarMultiply(-1);        $R    = new Vector($R);        // Then        $this->assertEquals($R, $ーA);        $this->assertEquals($R->getVector(), $ーA->getVector());    }    public function dataProviderForAdditiveInverse(): array    {        return [            [                [2],                [-2],            ],            [                [0, 1, 2, 3, 4, 5, -6, -7, 8],                [0, -1, -2, -3, -4, -5, 6, 7, -8],            ],        ];    }    /**     * @test Axiom: A⋅A⊥ = 0     * Vector dot product with a vector perpendicular to it will be zero.     * @dataProvider dataProviderForPerpendicularIdentity     */    public function testPerpendicularDotProduct(array $A)    {        // Given        $A = new Vector($A);        // When        $A⊥   = $A->perpendicular();        $A⋅A⊥ = $A->dotProduct($A⊥);        // Then        $this->assertEquals(0, $A⋅A⊥);    }    /**     * @test Axiom: A⊥⋅A = 0     * Perp dot product with itself will be zero.     * @dataProvider dataProviderForPerpendicularIdentity     */    public function testPerpDotProductZero(array $A)    {        // Given        $A = new Vector($A);        // When        $A⊥⋅A = $A->perpDotProduct($A);        // Then        $this->assertEquals(0, $A⊥⋅A);    }    public function dataProviderForPerpendicularIdentity(): array    {        return [            [[0, 0]],            [[0, 1]],            [[1, 0]],            [[1, 1]],            [[1, 2]],            [[1, 2]],            [[1, 3]],            [[1, 4]],            [[2, 0]],            [[2, 1]],            [[2, 2]],            [[2, 3]],            [[2, 4]],            [[4, 7]],            [[5, 3]],            [[-2, 1]],            [[2, -1]],            [[-2, -1]],            [[6, 9]],            [[-9, 12]],        ];    }    /**     * @test Axiom: A⋅A⊥ = -A⊥⋅A     * Swapping operands changes the sign of the perp dot product     * @dataProvider dataProviderForPerpendicularIdentity     */    public function testPerpDotProdcutSwapOperandsChangeSign(array $A)    {        // Given        $A  = new Vector($A);        $A⊥ = $A->perpendicular();        // When        $A⋅A⊥ = $A->dotProduct($A⊥);        $A⊥⋅A = $A⊥->dotProduct($A);        // Then        $this->assertEquals($A⋅A⊥, -$A⊥⋅A);    }    /**     * @test Axiom: projᵇA + perpᵇA = A     * Sum of the proj and perp of A on B equals A     * @dataProvider dataProviderForProjPerp     */    public function testProjPerpSumEqualsA(array $A, array $B)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        // When        $projᵇA = $A->projection($B);        $perpᵇA = $A->perp($B);        $projᵇA＋perpᵇA = $projᵇA->add($perpᵇA);        // Then        $this->assertEquals($A, $projᵇA＋perpᵇA);        $this->assertEquals($A->getVector(), $projᵇA＋perpᵇA->getVector());    }    /**     * @test Axiom: |projᵇA|² + |perpᵇA|² = |A|²     * Sum of squared lengths of proj and perp equals squared length of A     * @dataProvider dataProviderForProjPerp     */    public function testProjPerpSumOfSquares(array $A, array $B)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        // When        $│A│²      = ($A->length()) ** 2;        $│projᵇA│² = ($A->projection($B)->length()) ** 2;        $│perpᵇA│² = ($A->perp($B)->length()) ** 2;        // Then        $this->assertEquals($│A│², $│projᵇA│² + $│perpᵇA│²);    }    /**     * @test Axiom: projᵇA ⋅ perpᵇA = 0     * Dot product of proj and perp of A on B is 0     * @dataProvider dataProviderForProjPerp     */    public function testProjPerpDotProductEqualsZero(array $A, array $B)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        // When        $projᵇA = $A->projection($B);        $perpᵇA = $A->perp($B);        $projᵇA⋅perpᵇA = $projᵇA->dotProduct($perpᵇA);        // Then        $this->assertEquals(0, $projᵇA⋅perpᵇA);    }    /**     * @test Axiom: |projᵇA⊥ ⋅ perpᵇA| = |projᵇA| |perpᵇA|     * Absolute value of proj and perp dot product equals product of their lengths.     * @dataProvider dataProviderForProjPerp     */    public function testProjPerpPerpDotProductEqualsProductOfLengths(array $A, array $B)    {        // Given        $A = new Vector($A);        $B = new Vector($B);        // When        $projᵇA  = $A->projection($B);        $projᵇA⊥ = $A->projection($B)->perpendicular();        $perpᵇA  = $A->perp($B);        $projᵇA⊥⋅perpᵇA = \abs($projᵇA⊥->dotProduct($perpᵇA));        $│projᵇA│       = $projᵇA->length();        $│perpᵇA│       = $perpᵇA->length();        // Then        $this->assertEquals($projᵇA⊥⋅perpᵇA, $│projᵇA│ * $│perpᵇA│);    }    public function dataProviderForProjPerp(): array    {        return [            [                [1, 2],                [2, 3],            ],            [                [2, 2],                [2, 7],            ],            [                [1, 1],                [2, 2],            ],            [                [2, 2],                [1, 1],            ],            [                [5, 9],                [12, 8],            ],            [                [5, 2],                [3, 3],            ],        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2821, Get a specific value at position i\\n\\n @param  int $i index\\n\\n @return number\\n\\n @throws Exception\\\\VectorException\\n, Get a specific value at position i,"    public function get(int $i)    {        if ($i >= $this->n) {            throw new Exception\VectorException(""Element $i does not exist"");        }        return $this->A[$i];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2822," Get the vector as an nx1 column matrix\\n\\n Example:\\n  V = [1, 2, 3]\\n\\n      [1]\\n  R = [2]\\n      [3]\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\MathException\\n", Get the vector as an nx1 column matrix,"    public function asColumnMatrix(): NumericMatrix    {        $matrix = \array_map(            function ($element) {                return [$element];            },            $this->A        );        return new NumericMatrix($matrix);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2824, Sum of all elements\\n\\n @return number\\n, Sum of all elements,    public function sum()    {        return \array_sum($this->A);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2825, Vector length (magnitude)\n Same as l2-norm\n\n @return number\n, Vector length (magnitude),    public function length()    {        return $this->l2Norm();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2827, Min of all the elements\n\n @return number\n, Min of all the elements,    public function min()    {        return \min($this->A);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2828, Dot product (inner product) (A⋅B)\\n https://en.wikipedia.org/wiki/Dot_product\\n\\n @param Vector $B\\n\\n @return number\\n\\n @throws Exception\\\\VectorException\\n, Dot product (inner product) (A⋅B),"    public function dotProduct(Vector $B)    {        if ($B->getN() !== $this->n) {            throw new Exception\VectorException('Vectors have different number of items');        }        return \array_sum(\array_map(            function ($a, $b) {                return $a * $b;            },            $this->A,            $B->getVector()        ));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2833, Calculates the minkowski distance between vectors\\n https://en.wikipedia.org/wiki/Minkowski_distance\\n\\n (Σ|xᵢ - yᵢ|ᵖ)¹/ᵖ\\n\\n @param Vector $B\\n @param int    $p\\n\\n @return float|int\\n\\n @throws Exception\\\\BadDataException\\n, Calculates the minkowski distance between vectors,"    public function minkowskiDistance(Vector $B, int $p): float    {        return Distance::minkowski($this->getVector(), $B->getVector(), $p);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2836," Multiply (A \n A = [a₁, a₂, a₃]\n B = [b₁, b₂, b₃]\n A \n @param Vector $B\n\n @return Vector\n\n @throws Exception\\VectorException\n @throws Exception\\BadDataException\n", Multiply (A ,"    public function multiply(Vector $B): Vector    {        if ($B->getN() !== $this->n) {            throw new Exception\VectorException('Vectors must be the same length for multiplication');        }        $R = Map\Multi::multiply($this->A, $B->getVector());        return new Vector($R);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2841, Direct product (dyadic)\\n https://en.wikipedia.org/wiki/Direct_product\\n http://mathworld.wolfram.com/VectorDirectProduct.html\\n\\n              [A₁]              [A₁B₁ A₁B₂ A₁B₃]\\n AB = A⨂Bᵀ = [A₂] [B₁ B₂ B₃] = [A₂B₁ A₂B₂ A₂B₃]\\n              [A₃]              [A₃B₁ A₃B₂ A₃B₃]\\n\\n Where ⨂ is the Kronecker product.\\n\\n @param Vector $B\\n\\n @return NumericMatrix\\n, Direct product (dyadic),    public function directProduct(Vector $B): NumericMatrix    {        $A  = $this->asColumnMatrix();        $Bᵀ = $B->asRowMatrix();        return $A->kroneckerProduct($Bᵀ);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2843, Normalize (Â)\n The normalized vector Â is a vector in the same direction of A\n but with a norm (length) of 1. It is a unit vector.\n http://mathworld.wolfram.com/NormalizedVector.html\n\n      A\n Â ≡ ---\n     |A|\n\n  where |A| is the l²-norm (|A|₂)\n\n @return Vector\n, Normalize (Â),    public function normalize(): Vector    {        $│A│ = $this->l2Norm();        return $this->scalarDivide($│A│);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2844, Perpendicular (A⊥)\n A vector perpendicular to A (A-perp) with the length that is rotated 90º\n counter clockwise.\n\n     [a]       [-b]\n A = [b]  A⊥ = [a]\n\n @return Vector\n\n @throws Exception\\VectorException\n, Perpendicular (A⊥),"    public function perpendicular(): Vector    {        if ($this->n !== 2) {            throw new Exception\VectorException('Perpendicular operation only makes sense for 2D vector. 3D and higher vectors have infinite perpendular vectors.');        }        $A⊥ = [-$this->A[1], $this->A[0]];        return new Vector($A⊥);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2847, Kronecker product A⨂B\\n The kronecker product of two column vectors is a column vector.\\n\\n Example:  [1]    [3]   [3]\\n           [2] ⨂ [4] = [4]\\n                        [6]\\n                        [8]\\n\\n @param  Vector $B\\n\\n @return Vector\\n, Kronecker product A⨂B,    public function kroneckerProduct(Vector $B): Vector    {        $A = $this->asColumnMatrix();        $B = $B->asColumnMatrix();        $A⨂B = $A->kroneckerProduct($B);        return new Vector($A⨂B->getColumn(0));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2850, p-norm (|x|p)\n Also known as lp norm\n\n https://en.wikipedia.org/wiki/Norm_(mathematics)#p-norm\n\n |x|p = (∑|xᵢ|ᵖ)¹/ᵖ\n\n @param number $p\n\n @return number\n, p-norm (|x|p),"    public function pNorm($p)    {        return \array_sum(Map\Single::pow(Map\Single::abs($this->A), $p)) ** (1 / $p);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2859, Iterator INTERFACE\\n, Iterator INTERFACE,    public function rewind(): void    {        $this->i = 0;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Weibull_3206, Median of the distribution\\n\\n median = λ(ln 2)¹ᐟᵏ\\n\\n @return float\\n, Median of the distribution,"    public function median(): float    {        $k = $this->k;        $λ = $this->λ;        $⟮ln 2⟯¹ᐟᵏ = \pow(\log(2), 1 / $k);        return $λ * $⟮ln 2⟯¹ᐟᵏ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Weibull_3207, Mode of the distribution\n\n    / k - 1  \\¹ᐟᵏ\n λ |  -----  |\n    \\   k    /\n\n 0  k ≤ 1\n\n @return float\n, Mode of the distribution,"    public function mode(): float    {        $k = $this->k;        $λ = $this->λ;        if ($k <= 1) {            return 0;        }        $⟮⟮k − 1⟯／k⟯¹ᐟᵏ = \pow(($k - 1) / $k, 1 / $k);        return $λ * $⟮⟮k − 1⟯／k⟯¹ᐟᵏ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_WeightedLinear_3605, Calculates the regression parameters.\n\n @throws Exception\\MatrixException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MathException\n, Calculates the regression parameters.,"    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs, $this->ws)->getColumn(0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_214," This API is the <a href=\\\'http://matomo.org/docs/analytics-api/metadata/\\\' rel=\\\'noreferrer\\\' target=\\\'_blank\\\'>Metadata API</a>: it gives information about all other available APIs methods, as well as providing\\n human readable and more complete outputs than normal API methods.\\n\\n Some of the information that is returned by the Metadata API:\\n <ul>\\n <li>the dynamically generated list of all API methods via ""getReportMetadata""</li>\\n <li>the list of metrics that will be returned by each method, along with their human readable name, via ""getDefaultMetrics"" and ""getDefaultProcessedMetrics""</li>\\n <li>the list of segments metadata supported by all functions that have a \\\'segment\\\' parameter</li>\\n <li>the (truly magic) method ""getProcessedReport"" will return a human readable version of any other report, and include the processed metrics such as\\n conversion rate, time on site, etc. which are not directly available in other methods.</li>\\n <li>the method ""getSuggestedValuesForSegment"" returns top suggested values for a particular segment. It uses the Live.getLastVisitsDetails API to fetch the most recently used values, and will return the most often used values first.</li>\\n </ul>\\n The Metadata API is for example used by the Matomo Mobile App to automatically display all Matomo reports, with translated report & columns names and nicely formatted values.\\n More information on the <a href=\\\'http://matomo.org/docs/analytics-api/metadata/\\\' rel=\\\'noreferrer\\\' target=\\\'_blank\\\'>Metadata API documentation page</a>\\n\\n @method static \\\\Piwik\\\\Plugins\\\\API\\\\API getInstance()\\n", This API is the <a href=,"class API extends \Piwik\Plugin\API{    /**     * @var SettingsProvider     */    private $settingsProvider;    /**     * @var ProcessedReport     */    private $processedReport;    /**     * For Testing purpose only     * @var int     */    public static $_autoSuggestLookBack = 60;    public function __construct(SettingsProvider $settingsProvider, ProcessedReport $processedReport)    {        $this->settingsProvider = $settingsProvider;        $this->processedReport = $processedReport;    }    /**     * Get Matomo version     * @return string     */    public function getMatomoVersion()    {        Piwik::checkUserHasSomeViewAccess();        return Version::VERSION;    }    /**     * Get PHP version     * @return array     */    public function getPhpVersion()    {        Piwik::checkUserHasSuperUserAccess();        return array(            'version' => PHP_VERSION,            'major' => PHP_MAJOR_VERSION,            'minor' => PHP_MINOR_VERSION,            'release' => PHP_RELEASE_VERSION,            'versionId' => PHP_VERSION_ID,            'extra' => PHP_EXTRA_VERSION,        );    }    /**     * Get Matomo version     * @return string     * @deprecated Deprecated but we keep it for historical reasons to not break BC     */    public function getPiwikVersion()    {        return $this->getMatomoVersion();    }    /**     * Returns the most accurate IP address available for the current user, in     * IPv4 format. This could be the proxy client's IP address.     *     * @return string IP address in presentation format.     */    public function getIpFromHeader()    {        Piwik::checkUserHasSomeViewAccess();        return IP::getIpFromHeader();    }    /**     * Returns the section [APISettings] if defined in config.ini.php     * @return array     */    public function getSettings()    {        return Config::getInstance()->APISettings;    }    /**     * Returns all available measurable types.     * Marked as deprecated so it won't appear in API page. It won't be a public API for now.     * @deprecated     * @return array     */    public function getAvailableMeasurableTypes()    {        Piwik::checkUserHasSomeViewAccess();        $typeManager = new TypeManager();        $types = $typeManager->getAllTypes();        $available = array();        foreach ($types as $type) {            $measurableSettings = $this->settingsProvider->getAllMeasurableSettings($idSite = 0, $type->getId());            $settingsMetadata = new SettingsMetadata();            $available[] = array(                'id' => $type->getId(),                'name' => Piwik::translate($type->getName()),                'description' => Piwik::translate($type->getDescription()),                'howToSetupUrl' => $type->getHowToSetupUrl(),                'settings' => $settingsMetadata->formatSettings($measurableSettings)            );        }        return $available;    }    public function getSegmentsMetadata($idSites = array(), $_hideImplementationData = true, $_showAllSegments = false)    {        if (empty($idSites)) {            Piwik::checkUserHasSomeViewAccess();        } else {            $idSites = Site::getIdSitesFromIdSitesString($idSites);            Piwik::checkUserHasViewAccess($idSites);        }        $isNotAnonymous = !Piwik::isUserIsAnonymous();        $sites   = (is_array($idSites) ? implode('.', $idSites) : (int) $idSites);        $cache   = Cache::getTransientCache();        $cacheKey = 'API.getSegmentsMetadata' . $sites . '_' . (int) $_hideImplementationData . '_' . (int) $isNotAnonymous . '_' . (int) $_showAllSegments;        $cacheKey = CacheId::pluginAware($cacheKey);        if ($cache->contains($cacheKey)) {            return $cache->fetch($cacheKey);        }        $metadata = new SegmentMetadata();        $segments = $metadata->getSegmentsMetadata($idSites, $_hideImplementationData, $isNotAnonymous, $_showAllSegments);        $cache->save($cacheKey, $segments);        return $segments;    }    /**     * @param $segmentName     * @param $table     * @return array     */    protected function getSegmentValuesFromVisitorLog($segmentName, $table)    {        // Cleanup data to return the top suggested (non empty) labels for this segment        $values = $table->getColumn($segmentName);        // Select also flattened keys (custom variables ""page"" scope, page URLs for one visit, page titles for one visit)        $valuesBis = $table->getColumnsStartingWith($segmentName . ColumnDelete::APPEND_TO_COLUMN_NAME_TO_KEEP);        $values = array_merge($values, $valuesBis);        // Select values from the action details if needed for this particular segment        if (empty(array_filter($values)) && $this->doesSegmentNeedActionsData($segmentName)) {            foreach ($table->getRows() as $row) {                foreach ($row->getColumn('actionDetails') as $actionRow) {                    if (isset($actionRow[$segmentName])) {                        $values[] = $actionRow[$segmentName];                    }                }            }        }        return $values;    }    /**     * Loads reports metadata, then return the requested one,     * matching optional API parameters.     */    public function getMetadata($idSite, $apiModule, $apiAction, $apiParameters = array(), $language = false,                                $period = false, $date = false, $hideMetricsDoc = false, $showSubtableReports = false)    {        Piwik::checkUserHasViewAccess($idSite);        if ($language) {            /** @var Translator $translator */            $translator = StaticContainer::get('Piwik\Translation\Translator');            $translator->setCurrentLanguage($language);        }        $metadata = $this->processedReport->getMetadata($idSite, $apiModule, $apiAction, $apiParameters, $language, $period, $date, $hideMetricsDoc, $showSubtableReports);        return $metadata;    }    /**     * Triggers a hook to ask plugins for available Reports.     * Returns metadata information about each report (category, name, dimension, metrics, etc.)     *     * @param string $idSites THIS PARAMETER IS DEPRECATED AND WILL BE REMOVED IN PIWIK 4     * @param bool|string $period     * @param bool|Date $date     * @param bool $hideMetricsDoc     * @param bool $showSubtableReports     * @param int $idSite     * @return array     */    public function getReportMetadata($idSites = '', $period = false, $date = false, $hideMetricsDoc = false,                                      $showSubtableReports = false, $idSite = false)    {        if (empty($idSite) && !empty($idSites)) {            if (is_array($idSites)) {                $idSite = array_shift($idSites);            } else {                $idSite = $idSites;            }        } elseif (empty($idSite) && empty($idSites)) {            throw new \Exception('Calling API.getReportMetadata without any idSite is no longer supported since Matomo 3.0.0. Please specify at least one idSite via the ""idSite"" parameter.');        }        Piwik::checkUserHasViewAccess($idSite);        $metadata = $this->processedReport->getReportMetadata($idSite, $period, $date, $hideMetricsDoc, $showSubtableReports);        return $metadata;    }    public function getProcessedReport($idSite, $period, $date, $apiModule, $apiAction, $segment = false,                                       $apiParameters = false, $idGoal = false, $language = false,                                       $showTimer = true, $hideMetricsDoc = false, $idSubtable = false, $showRawMetrics = false,                                       $format_metrics = null, $idDimension = false)    {        Piwik::checkUserHasViewAccess($idSite);        $processed = $this->processedReport->getProcessedReport($idSite, $period, $date, $apiModule, $apiAction, $segment,            $apiParameters, $idGoal, $language, $showTimer, $hideMetricsDoc, $idSubtable, $showRawMetrics, $format_metrics, $idDimension);        return $processed;    }    /**     * Get a list of all pages that shall be shown in a Matomo UI including a list of all widgets that shall     * be shown within each page.     *     * @param int $idSite     * @return array     */    public function getReportPagesMetadata($idSite)    {        Piwik::checkUserHasViewAccess($idSite);        $widgetsList  = WidgetsList::get();        $categoryList = CategoryList::get();        $metadata     = new WidgetMetadata();        return $metadata->getPagesMetadata($categoryList, $widgetsList);    }    /**     * Get a list of all widgetizable widgets.     *     * @param int $idSite     * @return array     */    public function getWidgetMetadata($idSite)    {        Piwik::checkUserHasViewAccess($idSite);        $widgetsList  = WidgetsList::get();        $categoryList = CategoryList::get();        $metadata     = new WidgetMetadata();        return $metadata->getWidgetMetadata($categoryList, $widgetsList);    }    /**     * Get a combined report of the *.get API methods.     */    public function get($idSite, $period, $date, $segment = false, $columns = false)    {        Piwik::checkUserHasViewAccess($idSite);        $columns = Piwik::getArrayFromApiParameter($columns);        // build columns map for faster checks later on        $columnsMap = array();        foreach ($columns as $column) {            $columnsMap[$column] = true;        }        // find out which columns belong to which plugin        $columnsByPlugin = array();        $meta = \Piwik\Plugins\API\API::getInstance()->getReportMetadata($idSite, $period, $date);        foreach ($meta as $reportMeta) {            // scan all *.get reports            if ($reportMeta['action'] == 'get'                && !isset($reportMeta['parameters'])                && $reportMeta['module'] != 'API'                && !empty($reportMeta['metrics'])            ) {                $plugin = $reportMeta['module'];                $allMetrics = array_merge($reportMeta['metrics'], @$reportMeta['processedMetrics'] ?: array());                foreach ($allMetrics as $column => $columnTranslation) {                    // a metric from this report has been requested                    if (isset($columnsMap[$column])                        // or by default, return all metrics                        || empty($columnsMap)                    ) {                        $columnsByPlugin[$plugin][] = $column;                    }                }            }        }        krsort($columnsByPlugin);        $mergedDataTable = false;        $params = compact('idSite', 'period', 'date', 'segment');        foreach ($columnsByPlugin as $plugin => $columns) {            // load the data            $className = Request::getClassNameAPI($plugin);            $params['columns'] = implode(',', $columns);            $dataTable = Proxy::getInstance()->call($className, 'get', $params);            $dataTable->filter(function (DataTable $table) {                $table->clearQueuedFilters();            });            // merge reports            if ($mergedDataTable === false) {                $mergedDataTable = $dataTable;            } else {                $merger = new MergeDataTables();                $merger->mergeDataTables($mergedDataTable, $dataTable);            }        }        if (!empty($columnsMap)            && !empty($mergedDataTable)        ) {            $mergedDataTable->queueFilter('ColumnDelete', array(false, array_keys($columnsMap)));        }        return $mergedDataTable;    }    /**     * Given an API report to query (eg. ""Referrers.getKeywords"", and a Label (eg. ""free%20software""),     * this function will query the API for the previous days/weeks/etc. and will return     * a ready to use data structure containing the metrics for the requested Label, along with enriched information (min/max values, etc.)     *     * @param int $idSite     * @param string $period     * @param Date $date     * @param string $apiModule     * @param string $apiAction     * @param bool|string $label     * @param bool|string $segment     * @param bool|string $column     * @param bool|string $language     * @param bool|int $idGoal     * @param bool|string $legendAppendMetric     * @param bool|string $labelUseAbsoluteUrl     * @param bool|int $idDimension     * @return array     */    public function getRowEvolution($idSite, $period, $date, $apiModule, $apiAction, $label = false, $segment = false, $column = false, $language = false, $idGoal = false, $legendAppendMetric = true, $labelUseAbsoluteUrl = true, $idDimension = false, $labelSeries = false)    {        // check if site exists        $idSite = (int) $idSite;        $site = new Site($idSite);        Piwik::checkUserHasViewAccess($idSite);        $apiParameters = array();        $entityNames = StaticContainer::get('entities.idNames');        foreach ($entityNames as $entityName) {            if ($entityName === 'idGoal' && is_numeric($idGoal)) {                $apiParameters['idGoal'] = $idGoal;            } elseif ($entityName === 'idDimension' && $idDimension) {                $apiParameters['idDimension'] = $idDimension;            } else {                // ideally it would get the value from API params but dynamic params is not possible yet in API. If this                // method is called eg in Request::processRequest, it could in theory pick up a param from the original request                // and not from the API request within the original request.                $idEntity = Common::getRequestVar($entityName, 0, 'int');                if ($idEntity > 0) {                    $apiParameters[$entityName] = $idEntity;                }            }        }        $rowEvolution = new RowEvolution();        return $rowEvolution->getRowEvolution($idSite, $period, $date, $apiModule, $apiAction, $label, $segment, $column,            $language, $apiParameters, $legendAppendMetric, $labelUseAbsoluteUrl, $labelSeries);    }    /**     * Performs multiple API requests at once and returns every result.     *     * @param array $urls The array of API requests.     * @return array     */    public function getBulkRequest($urls)    {        if (empty($urls)) {            return array();        }        $urls = array_map('urldecode', $urls);        $urls = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $urls);        $result = array();        foreach ($urls as $url) {            $params = Request::getRequestArrayFromString($url . '&format=json');            if (!empty($params['method']) && $params['method'] === 'API.getBulkRequest') {                continue;            }            if (isset($params['urls']) && $params['urls'] == $urls) {                // by default 'urls' is added to $params as Request::getRequestArrayFromString adds all $_GET/$_POST                // default parameters                unset($params['urls']);            }            if (!empty($params['segment']) && strpos($url, 'segment=') > -1) {                // only unsanitize input when segment is actually present in URL, not when it was used from                // $defaultRequest in Request::getRequestArrayFromString from $_GET/$_POST                $params['segment'] = urlencode(Common::unsanitizeInputValue($params['segment']));            }            $req = new Request($params);            $result[] = json_decode($req->process(), true);        }        return $result;    }    /**     * Return true if plugin is activated, false otherwise     *     * @param string $pluginName     * @return bool     */    public function isPluginActivated($pluginName)    {        Piwik::checkUserHasSomeViewAccess();        return \Piwik\Plugin\Manager::getInstance()->isPluginActivated($pluginName);    }    /**     * Given a segment, will return a list of the most used values for this particular segment.     * @param $segmentName     * @param $idSite     * @throws \Exception     * @return array     */    public function getSuggestedValuesForSegment($segmentName, $idSite)    {        if (empty(Config::getInstance()->General['enable_segment_suggested_values'])) {            return array();        }        Piwik::checkUserHasViewAccess($idSite);        $maxSuggestionsToReturn = 30;        $segment = $this->findSegment($segmentName, $idSite);        // if segment has suggested values callback then return result from it instead        $suggestedValuesCallbackRequiresTable = false;        if (!empty($segment['suggestedValuesApi']) && is_string($segment['suggestedValuesApi']) && !Rules::isBrowserTriggerEnabled()) {            $now = Date::now()->setTimezone(Site::getTimezoneFor($idSite));            if (self::$_autoSuggestLookBack != 60) {                // in Auto suggest tests we need to assume now is in 2018...                // we do - 20 to make sure the year is still correct otherwise could end up being 2017-12-31 and the recorded visits are over several days in the tests we make sure to select the last day a visit was recorded                $now = $now->subDay(self::$_autoSuggestLookBack - 20);            }            // we want to avoid launching the archiver should browser archiving be enabled as this can be very slow... we then rather            // use the live api.            $period = 'year';            $date = $now->toString();            if ($now->toString('m') == '01') {                if (Rules::isArchivingDisabledFor(array($idSite), new Segment('', array($idSite)), 'range')) {                    $date = $now->subYear(1)->toString(); // use previous year data to avoid using range                } else {                    $period = 'range';                    $date = $now->subMonth(1)->toString() . ',' . $now->addDay(1)->toString();                }            }            $apiParts = explode('.', $segment['suggestedValuesApi']);            $meta = $this->getMetadata($idSite, $apiParts[0], $apiParts[1]);            $flat = !empty($meta[0]['actionToLoadSubTables']) && $meta[0]['actionToLoadSubTables'] == $apiParts[1];            $table = Request::processRequest($segment['suggestedValuesApi'], array(                'idSite' => $idSite,                'period' => $period,                'date' => $date,                'segment' => '',                'filter_offset' => 0,                'flat' => (int) $flat,                'filter_limit' => $maxSuggestionsToReturn            ));            if ($table && $table instanceof DataTable && $table->getRowsCount()) {                $values = [];                foreach ($table->getRowsWithoutSummaryRow() as $row) {                    $segment = $row->getMetadata('segment');                    $remove = array(                        $segmentName . Segment\SegmentExpression::MATCH_EQUAL,                        $segmentName . Segment\SegmentExpression::MATCH_STARTS_WITH                    );                    // we don't look at row columns since this could include rows that won't work eg Other summary rows. etc                    // and it is generally not reliable.                    if (!empty($segment) && preg_match('/^' . implode('|',$remove) . '/', $segment)) {                        $values[] = urldecode(urldecode(str_replace($remove, '', $segment)));                    }                }                $values = array_slice($values, 0, $maxSuggestionsToReturn);                $values = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $values);                return $values;            }        }        if (isset($segment['suggestedValuesCallback'])) {            $suggestedValuesCallbackRequiresTable = $this->doesSuggestedValuesCallbackNeedData(                $segment['suggestedValuesCallback']);            if (!$suggestedValuesCallbackRequiresTable) {                return call_user_func($segment['suggestedValuesCallback'], $idSite, $maxSuggestionsToReturn);            }        }        // if period=range is disabled, do not proceed        if (!Period\Factory::isPeriodEnabledForAPI('range')) {            return array();        }        if (!empty($segment['unionOfSegments'])) {            $values = array();            foreach ($segment['unionOfSegments'] as $unionSegmentName) {                $unionSegment = $this->findSegment($unionSegmentName, $idSite, $_showAllSegments = true);                try {                    $result = $this->getSuggestedValuesForSegmentName($idSite, $unionSegment, $maxSuggestionsToReturn);                    if (!empty($result)) {                        $values = array_merge($result, $values);                    }                } catch (\Exception $e) {                    // we ignore if there was no data found for $unionSegmentName                }            }            if (empty($values)) {                throw new \Exception(""There was no data to suggest for $segmentName"");            }        } else {            $values = $this->getSuggestedValuesForSegmentName($idSite, $segment, $maxSuggestionsToReturn);        }        $values = $this->getMostFrequentValues($values);        $values = array_slice($values, 0, $maxSuggestionsToReturn);        $values = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $values);        return $values;    }    /**     * Returns category/subcategory pairs as ""CategoryId.SubcategoryId"" for whom comparison features should     * be disabled.     *     * @return string[]     */    public function getPagesComparisonsDisabledFor()    {        $pages = [];        /**         * If your plugin has pages where you'd like comparison features to be disabled, you can add them         * via this event. Add the pages as ""CategoryId.SubcategoryId"".         *         * **Example**         *         * ```         * public function getPagesComparisonsDisabledFor(&$pages)         * {         *     $pages[] = ""General_Visitors.MyPlugin_MySubcategory"";         *     $pages[] = ""MyPlugin.myControllerAction""; // if your plugin defines a whole page you want comparison disabled for         * }         * ```         *         * @param string[] &$pages         */        Piwik::postEvent('API.getPagesComparisonsDisabledFor', [&$pages]);        return $pages;    }    private function findSegment($segmentName, $idSite, $_showAllSegments = false)    {        $segmentsMetadata = $this->getSegmentsMetadata($idSite, $_hideImplementationData = false, $_showAllSegments);        $segmentFound = false;        foreach ($segmentsMetadata as $segmentMetadata) {            if ($segmentMetadata['segment'] == $segmentName) {                $segmentFound = $segmentMetadata;                break;            }        }        if (empty($segmentFound)) {            throw new \Exception(""Requested segment $segmentName not found."");        }        return $segmentFound;    }    private function getSuggestedValuesForSegmentName($idSite, $segment, $maxSuggestionsToReturn)    {        $startDate = Date::now()->subDay(self::$_autoSuggestLookBack)->toString();        $requestLastVisits = ""method=Live.getLastVisitsDetails        &idSite=$idSite        &period=range        &date=$startDate,today        &format=original        &serialize=0        &flat=1"";        $segmentName = $segment['segment'];        // Select non empty fields only        // Note: this optimization has only a very minor impact        $requestLastVisits .= ""&segment=$segmentName"" . urlencode('!=');        // By default Live fetches all actions for all visitors, but we'd rather do this only when required        if ($this->doesSegmentNeedActionsData($segmentName)) {            $requestLastVisits .= ""&filter_limit=400"";        } else {            $requestLastVisits .= ""&doNotFetchActions=1"";            $requestLastVisits .= ""&filter_limit=800"";        }        $request = new Request($requestLastVisits);        $table = $request->process();        if (empty($table)) {            throw new \Exception(""There was no data to suggest for $segmentName"");        }        if (isset($segment['suggestedValuesCallback']) &&            $this->doesSuggestedValuesCallbackNeedData($segment['suggestedValuesCallback'])) {            $values = call_user_func($segment['suggestedValuesCallback'], $idSite, $maxSuggestionsToReturn, $table);        } else {            $values = $this->getSegmentValuesFromVisitorLog($segmentName, $table);        }        return $values;    }    /**     * A glossary of all reports and their definition     *     * @param $idSite     * @return array     */    public function getGlossaryReports($idSite)    {        $glossary = StaticContainer::get('Piwik\Plugins\API\Glossary');        return $glossary->reportsGlossary($idSite);    }    /**     * A glossary of all metrics and their definition     *     * @param $idSite     * @return array     */    public function getGlossaryMetrics($idSite)    {        $glossary = StaticContainer::get('Piwik\Plugins\API\Glossary');        return $glossary->metricsGlossary($idSite);    }    /**     * @param $segmentName     * @return bool     */    protected function doesSegmentNeedActionsData($segmentName)    {        // If you update this, also update flattenVisitorDetailsArray        $segmentsNeedActionsInfo = array('visitConvertedGoalId',            'pageUrl', 'pageTitle', 'siteSearchKeyword', 'siteSearchCategory', 'siteSearchCount',            'entryPageTitle', 'entryPageUrl', 'exitPageTitle', 'exitPageUrl',            'outlinkUrl', 'downloadUrl', 'eventUrl', 'orderId', 'productViewName', 'productViewSku', 'productViewPrice',            'productViewCategory1', 'productViewCategory2', 'productViewCategory3', 'productViewCategory4', 'productViewCategory5'        );        $isCustomVariablePage = stripos($segmentName, 'customVariablePage') !== false;        $isEventSegment = stripos($segmentName, 'event') !== false;        $isContentSegment = stripos($segmentName, 'content') !== false;        $doesSegmentNeedActionsInfo = in_array($segmentName, $segmentsNeedActionsInfo) || $isCustomVariablePage || $isEventSegment || $isContentSegment;        return $doesSegmentNeedActionsInfo;    }    /**     * @param $values     *     * @return array     */    private function getMostFrequentValues($values)    {        // remove false values (while keeping zeros)        $values = array_filter($values, 'strlen');        // array_count_values requires strings or integer, convert floats to string (mysqli)        foreach ($values as &$value) {            if (is_numeric($value)) {                $value = (string)round($value, 3);            }        }        // we have a list of all values. let's show the most frequently used first.        $values = array_count_values($values);        // Sort this list by converting and sorting the array with custom method, so the result doesn't differ between PHP versions        $sortArray = [];        foreach ($values as $value => $count) {            $sortArray[] = [                'value' => $value,                'count' => $count            ];        }        usort($sortArray, function($a, $b) {            if ($a['count'] == $b['count']) {                return strcmp($a['value'], $b['value']);            }            return $a['count'] > $b['count'] ? -1 : 1;        });        return array_column($sortArray, 'value');    }    private function doesSuggestedValuesCallbackNeedData($suggestedValuesCallback)    {        if (is_string($suggestedValuesCallback)            && strpos($suggestedValuesCallback, '::') !== false        ) {            $suggestedValuesCallback = explode('::', $suggestedValuesCallback);        }        if (is_array($suggestedValuesCallback)) {            $methodMetadata = new \ReflectionMethod($suggestedValuesCallback[0], $suggestedValuesCallback[1]);        } else {            $methodMetadata = new \ReflectionFunction($suggestedValuesCallback);        }        return $methodMetadata->getNumberOfParameters() >= 3;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_215, Get Matomo version\\n @return string\\n, Get Matomo version,    public function getMatomoVersion()    {        Piwik::checkUserHasSomeViewAccess();        return Version::VERSION;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_219, Returns the section [APISettings] if defined in config.ini.php\\n @return array\\n, Returns the section [APISettings] if defined in config.ini.php,    public function getSettings()    {        return Config::getInstance()->APISettings;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_223, Get a list of all widgetizable widgets.\\n\\n @param int $idSite\\n @return array\\n, Get a list of all widgetizable widgets.,"    public function getWidgetMetadata($idSite)    {        Piwik::checkUserHasViewAccess($idSite);        $widgetsList  = WidgetsList::get();        $categoryList = CategoryList::get();        $metadata     = new WidgetMetadata();        return $metadata->getWidgetMetadata($categoryList, $widgetsList);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_224, Performs multiple API requests at once and returns every result.\\n\\n @param array $urls The array of API requests.\\n @return array\\n, Performs multiple API requests at once and returns every result.,"    public function getBulkRequest($urls)    {        if (empty($urls)) {            return array();        }        $urls = array_map('urldecode', $urls);        $urls = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $urls);        $result = array();        foreach ($urls as $url) {            $params = Request::getRequestArrayFromString($url . '&format=json');            if (!empty($params['method']) && $params['method'] === 'API.getBulkRequest') {                continue;            }            if (isset($params['urls']) && $params['urls'] == $urls) {                // by default 'urls' is added to $params as Request::getRequestArrayFromString adds all $_GET/$_POST                // default parameters                unset($params['urls']);            }            if (!empty($params['segment']) && strpos($url, 'segment=') > -1) {                // only unsanitize input when segment is actually present in URL, not when it was used from                // $defaultRequest in Request::getRequestArrayFromString from $_GET/$_POST                $params['segment'] = urlencode(Common::unsanitizeInputValue($params['segment']));            }            $req = new Request($params);            $result[] = json_decode($req->process(), true);        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_227," Returns category/subcategory pairs as ""CategoryId.SubcategoryId"" for whom comparison features should\\n be disabled.\\n\\n @return string[]\\n"," Returns category/subcategory pairs as ""CategoryId.SubcategoryId"" for whom comparison features should","    public function getPagesComparisonsDisabledFor()    {        $pages = [];        /**         * If your plugin has pages where you'd like comparison features to be disabled, you can add them         * via this event. Add the pages as ""CategoryId.SubcategoryId"".         *         * **Example**         *         * ```         * public function getPagesComparisonsDisabledFor(&$pages)         * {         *     $pages[] = ""General_Visitors.MyPlugin_MySubcategory"";         *     $pages[] = ""MyPlugin.myControllerAction""; // if your plugin defines a whole page you want comparison disabled for         * }         * ```         *         * @param string[] &$pages         */        Piwik::postEvent('API.getPagesComparisonsDisabledFor', [&$pages]);        return $pages;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_951, Get PHP version\n @return array\n, Get PHP version,"    public function getPhpVersion()    {        Piwik::checkUserHasSuperUserAccess();        return array(            'version' => PHP_VERSION,            'major' => PHP_MAJOR_VERSION,            'minor' => PHP_MINOR_VERSION,            'release' => PHP_RELEASE_VERSION,            'versionId' => PHP_VERSION_ID,            'extra' => PHP_EXTRA_VERSION,        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_953," Returns the most accurate IP address available for the current user, in\n IPv4 format. This could be the proxy client's IP address.\n\n @return string IP address in presentation format.\n"," Returns the most accurate IP address available for the current user, in",    public function getIpFromHeader()    {        Piwik::checkUserHasSomeViewAccess();        return IP::getIpFromHeader();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_20," Singleton that manages user access to Piwik resources.\\n\\n To check whether a user has access to a resource, use one of the {@link Piwik Piwik::checkUser...}\\n methods.\\n\\n In Piwik there are four different access levels:\\n\\n -  -  -  -                           whatever they want.\\n\\n                          Super user access is required to set some configuration options.\\n                          All other options are specific to the user or to a website.\\n\\n Access is granted per website. Uses with access for a website can view all\\n data associated with that website.\\n\\n", Singleton that manages user access to Piwik resources.,"class Access{    /**     * Array of idsites available to the current user, indexed by permission level     * @see getSitesIdWith*()     *     * @var array     */    protected $idsitesByAccess = null;    /**     * Login of the current user     *     * @var string     */    protected $login = null;    /**     * token_auth of the current user     *     * @var string     */    protected $token_auth = null;    /**     * Defines if the current user is the Super User     * @see hasSuperUserAccess()     *     * @var bool     */    protected $hasSuperUserAccess = false;    /**     * Authentification object (see Auth)     *     * @var Auth     */    private $auth = null;    /**     * Gets the singleton instance. Creates it if necessary.     *     * @return self     */    public static function getInstance()    {        return StaticContainer::get('Piwik\Access');    }    /**     * @var CapabilitiesProvider     */    protected $capabilityProvider;    /**     * @var RolesProvider     */    private $roleProvider;    /**     * Constructor     */    public function __construct(RolesProvider $roleProvider = null, CapabilitiesProvider $capabilityProvider = null)    {        if (!isset($roleProvider)) {            $roleProvider = StaticContainer::get('Piwik\Access\RolesProvider');        }        if (!isset($capabilityProvider)) {            $capabilityProvider = StaticContainer::get('Piwik\Access\CapabilitiesProvider');        }        $this->roleProvider = $roleProvider;        $this->capabilityProvider = $capabilityProvider;        $this->resetSites();    }    private function resetSites()    {        $this->idsitesByAccess = array(            'view'      => array(),            'write'     => array(),            'admin'     => array(),            'superuser' => array(),        );    }    /**     * Loads the access levels for the current user.     *     * Calls the authentication method to try to log the user in the system.     * If the user credentials are not correct we don't load anything.     * If the login/password is correct the user is either the SuperUser or a normal user.     * We load the access levels for this user for all the websites.     *     * @param null|Auth $auth Auth adapter     * @return bool  true on success, false if reloading access failed (when auth object wasn't specified and user is not enforced to be Super User)     */    public function reloadAccess(Auth $auth = null)    {        $this->resetSites();        if (isset($auth)) {            $this->auth = $auth;        }        if ($this->hasSuperUserAccess()) {            $this->makeSureLoginNameIsSet();            return true;        }        $this->token_auth = null;        $this->login = null;        // if the Auth wasn't set, we may be in the special case of setSuperUser(), otherwise we fail TODO: docs + review        if (!isset($this->auth)) {            return false;        }        $result = null;        $forceApiSessionPost = Common::getRequestVar('force_api_session', 0, 'int', $_POST);        $forceApiSessionGet = Common::getRequestVar('force_api_session', 0, 'int', $_GET);        $isApiRequest = Piwik::getModule() === 'API' && (Piwik::getAction() === 'index' || !Piwik::getAction());        $apiMethod = Request::getMethodIfApiRequest(null);        $isGetApiRequest = 1 === substr_count($apiMethod, '.') && strpos($apiMethod, '.get') > 0;        if (($forceApiSessionPost && $isApiRequest) || ($forceApiSessionGet && $isApiRequest && $isGetApiRequest)) {            $request = ($forceApiSessionGet && $isApiRequest && $isGetApiRequest) ? $_GET : $_POST;            $tokenAuth = Common::getRequestVar('token_auth', '', 'string', $request);            Session::start();            $auth = StaticContainer::get(SessionAuth::class);            $auth->setTokenAuth($tokenAuth);            $result = $auth->authenticate();            if (!$result->wasAuthenticationSuccessful()) {                /**                 * Ensures brute force logic to be executed                 * @ignore                 * @internal                 */                Piwik::postEvent('API.Request.authenticate.failed');            }            Session::close();            // if not successful, we will fallback to regular auth        }        // access = array ( idsite => accessIdSite, idsite2 => accessIdSite2)        if (!$result || !$result->wasAuthenticationSuccessful()) {            $result = $this->auth->authenticate();        }        if (!$result->wasAuthenticationSuccessful()) {            return false;        }        $this->login = $result->getIdentity();        $this->token_auth = $result->getTokenAuth();        // case the superUser is logged in        if ($result->hasSuperUserAccess()) {            $this->setSuperUserAccess(true);        }        return true;    }    public function getRawSitesWithSomeViewAccess($login)    {        $sql = self::getSqlAccessSite(""access, t2.idsite"");        return Db::fetchAll($sql, $login);    }    /**     * Returns the SQL query joining sites and access table for a given login     *     * @param string $select Columns or expression to SELECT FROM table, eg. ""MIN(ts_created)""     * @return string  SQL query     */    public static function getSqlAccessSite($select)    {        $access    = Common::prefixTable('access');        $siteTable = Common::prefixTable('site');        return ""SELECT "" . $select . "" FROM "" . $access . "" as t1JOIN "" . $siteTable . "" as t2 USING (idsite) WHERE login = ?"";    }    /**     * Make sure a login name is set     *     * @return true     */    protected function makeSureLoginNameIsSet()    {        if (empty($this->login)) {            // flag to force non empty login so Super User is not mistaken for anonymous            $this->login = 'super user was set';        }    }    protected function loadSitesIfNeeded()    {        if ($this->hasSuperUserAccess) {            if (empty($this->idsitesByAccess['superuser'])) {                try {                    $api = SitesManagerApi::getInstance();                    $allSitesId = $api->getAllSitesId();                } catch (\Exception $e) {                    $allSitesId = array();                }                $this->idsitesByAccess['superuser'] = $allSitesId;            }        } elseif (isset($this->login)) {            if (empty($this->idsitesByAccess['view'])                && empty($this->idsitesByAccess['write'])                && empty($this->idsitesByAccess['admin'])            ) {                // we join with site in case there are rows in access for an idsite that doesn't exist anymore                // (backward compatibility ; before we deleted the site without deleting rows in _access table)                $accessRaw = $this->getRawSitesWithSomeViewAccess($this->login);                foreach ($accessRaw as $access) {                    $accessType = $access['access'];                    $this->idsitesByAccess[$accessType][] = $access['idsite'];                    if ($this->roleProvider->isValidRole($accessType)) {                        foreach ($this->capabilityProvider->getAllCapabilities() as $capability) {                            if ($capability->hasRoleCapability($accessType)) {                                // we automatically add this capability                                if (!isset($this->idsitesByAccess[$capability->getId()])) {                                    $this->idsitesByAccess[$capability->getId()] = array();                                }                                $this->idsitesByAccess[$capability->getId()][] = $access['idsite'];                            }                        }                    }                }                /**                 * Triggered after the initial access levels and permissions for the current user are loaded. Use this                 * event to modify the current user's permissions (for example, making sure every user has view access                 * to a specific site).                 *                 * **Example**                 *                 *     function (&$idsitesByAccess, $login) {                 *         if ($login == 'somespecialuser') {                 *             return;                 *         }                 *                 *         $idsitesByAccess['view'][] = $mySpecialIdSite;                 *     }                 *                 * @param array[] &$idsitesByAccess The current user's access levels for individual sites. Maps role and                 *                                  capability IDs to list of site IDs, eg:                 *                 *                                  ```                 *                                  [                 *                                      'view' => [1, 2, 3],                 *                                      'write' => [4, 5],                 *                                      'admin' => [],                 *                                  ]                 *                                  ```                 * @param string $login The current user's login.                 */                Piwik::postEvent('Access.modifyUserAccess', [&$this->idsitesByAccess, $this->login]);            }        }    }    /**     * We bypass the normal auth method and give the current user Super User rights.     * This should be very carefully used.     *     * @param bool $bool     */    public function setSuperUserAccess($bool = true)    {        $this->hasSuperUserAccess = (bool) $bool;        if ($bool) {            $this->makeSureLoginNameIsSet();        } else {            $this->resetSites();        }    }    /**     * Returns true if the current user is logged in as the Super User     *     * @return bool     */    public function hasSuperUserAccess()    {        return $this->hasSuperUserAccess;    }    /**     * Returns the current user login     *     * @return string|null     */    public function getLogin()    {        return $this->login;    }    /**     * Returns the token_auth used to authenticate this user in the API     *     * @return string|null     */    public function getTokenAuth()    {        return $this->token_auth;    }    /**     * Returns an array of ID sites for which the user has at least a VIEW access.     * Which means VIEW OR WRITE or ADMIN or SUPERUSER.     *     * @return array  Example if the user is ADMIN for 4     *                and has VIEW access for 1 and 7, it returns array(1, 4, 7);     */    public function getSitesIdWithAtLeastViewAccess()    {        $this->loadSitesIfNeeded();        return array_unique(array_merge(                $this->idsitesByAccess['view'],                $this->idsitesByAccess['write'],                $this->idsitesByAccess['admin'],                $this->idsitesByAccess['superuser'])        );    }    /**     * Returns an array of ID sites for which the user has at least a WRITE access.     * Which means WRITE or ADMIN or SUPERUSER.     *     * @return array  Example if the user is WRITE for 4 and 8     *                and has VIEW access for 1 and 7, it returns array(4, 8);     */    public function getSitesIdWithAtLeastWriteAccess()    {        $this->loadSitesIfNeeded();        return array_unique(array_merge(                $this->idsitesByAccess['write'],                $this->idsitesByAccess['admin'],                $this->idsitesByAccess['superuser'])        );    }    /**     * Returns an array of ID sites for which the user has an ADMIN access.     *     * @return array  Example if the user is ADMIN for 4 and 8     *                and has VIEW access for 1 and 7, it returns array(4, 8);     */    public function getSitesIdWithAdminAccess()    {        $this->loadSitesIfNeeded();        return array_unique(array_merge(                $this->idsitesByAccess['admin'],                $this->idsitesByAccess['superuser'])        );    }    /**     * Returns an array of ID sites for which the user has a VIEW access only.     *     * @return array  Example if the user is ADMIN for 4     *                and has VIEW access for 1 and 7, it returns array(1, 7);     * @see getSitesIdWithAtLeastViewAccess()     */    public function getSitesIdWithViewAccess()    {        $this->loadSitesIfNeeded();        return $this->idsitesByAccess['view'];    }    /**     * Returns an array of ID sites for which the user has a WRITE access only.     *     * @return array  Example if the user is ADMIN for 4     *                and has WRITE access for 1 and 7, it returns array(1, 7);     * @see getSitesIdWithAtLeastWriteAccess()     */    public function getSitesIdWithWriteAccess()    {        $this->loadSitesIfNeeded();        return $this->idsitesByAccess['write'];    }    /**     * Throws an exception if the user is not the SuperUser     *     * @throws \Piwik\NoAccessException     */    public function checkUserHasSuperUserAccess()    {        if (!$this->hasSuperUserAccess()) {            $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilege', array(""'superuser'"")));        }    }    /**     * Returns `true` if the current user has admin access to at least one site.     *     * @return bool     */    public function isUserHasSomeWriteAccess()    {        if ($this->hasSuperUserAccess()) {            return true;        }        $idSitesAccessible = $this->getSitesIdWithAtLeastWriteAccess();        return count($idSitesAccessible) > 0;    }    /**     * Returns `true` if the current user has admin access to at least one site.     *     * @return bool     */    public function isUserHasSomeAdminAccess()    {        if ($this->hasSuperUserAccess()) {            return true;        }        $idSitesAccessible = $this->getSitesIdWithAdminAccess();        return count($idSitesAccessible) > 0;    }    /**     * If the user doesn't have an WRITE access for at least one website, throws an exception     *     * @throws \Piwik\NoAccessException     */    public function checkUserHasSomeWriteAccess()    {        if (!$this->isUserHasSomeWriteAccess()) {            $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilegeAtLeastOneWebsite', array('write')));        }    }    /**     * If the user doesn't have an ADMIN access for at least one website, throws an exception     *     * @throws \Piwik\NoAccessException     */    public function checkUserHasSomeAdminAccess()    {        if (!$this->isUserHasSomeAdminAccess()) {            $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilegeAtLeastOneWebsite', array('admin')));        }    }    /**     * If the user doesn't have any view permission, throw exception     *     * @throws \Piwik\NoAccessException     */    public function checkUserHasSomeViewAccess()    {        if ($this->hasSuperUserAccess()) {            return;        }        $idSitesAccessible = $this->getSitesIdWithAtLeastViewAccess();        if (count($idSitesAccessible) == 0) {            $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilegeAtLeastOneWebsite', array('view')));        }    }    /**     * This method checks that the user has ADMIN access for the given list of websites.     * If the user doesn't have ADMIN access for at least one website of the list, we throw an exception.     *     * @param int|array $idSites List of ID sites to check     * @throws \Piwik\NoAccessException If for any of the websites the user doesn't have an ADMIN access     */    public function checkUserHasAdminAccess($idSites)    {        if ($this->hasSuperUserAccess()) {            return;        }        $idSites = $this->getIdSites($idSites);        $idSitesAccessible = $this->getSitesIdWithAdminAccess();        foreach ($idSites as $idsite) {            if (!in_array($idsite, $idSitesAccessible)) {                $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilegeAccessWebsite', array(""'admin'"", $idsite)));            }        }    }    /**     * This method checks that the user has VIEW or ADMIN access for the given list of websites.     * If the user doesn't have VIEW or ADMIN access for at least one website of the list, we throw an exception.     *     * @param int|array|string $idSites List of ID sites to check (integer, array of integers, string comma separated list of integers)     * @throws \Piwik\NoAccessException  If for any of the websites the user doesn't have an VIEW or ADMIN access     */    public function checkUserHasViewAccess($idSites)    {        if ($this->hasSuperUserAccess()) {            return;        }        $idSites = $this->getIdSites($idSites);        $idSitesAccessible = $this->getSitesIdWithAtLeastViewAccess();        foreach ($idSites as $idsite) {            if (!in_array($idsite, $idSitesAccessible)) {                $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilegeAccessWebsite', array(""'view'"", $idsite)));            }        }    }    /**     * This method checks that the user has VIEW or ADMIN access for the given list of websites.     * If the user doesn't have VIEW or ADMIN access for at least one website of the list, we throw an exception.     *     * @param int|array|string $idSites List of ID sites to check (integer, array of integers, string comma separated list of integers)     * @throws \Piwik\NoAccessException  If for any of the websites the user doesn't have an VIEW or ADMIN access     */    public function checkUserHasWriteAccess($idSites)    {        if ($this->hasSuperUserAccess()) {            return;        }        $idSites = $this->getIdSites($idSites);        $idSitesAccessible = $this->getSitesIdWithAtLeastWriteAccess();        foreach ($idSites as $idsite) {            if (!in_array($idsite, $idSitesAccessible)) {                $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilegeAccessWebsite', array(""'write'"", $idsite)));            }        }    }    public function checkUserIsNotAnonymous()    {        if ($this->hasSuperUserAccess()) {            return;        }        if (Piwik::isUserIsAnonymous()) {            $this->throwNoAccessException(Piwik::translate('General_YouMustBeLoggedIn'));        }    }    private function getSitesIdWithCapability($capability)    {        if (!empty($this->idsitesByAccess[$capability])) {            return $this->idsitesByAccess[$capability];        }        return array();    }    public function checkUserHasCapability($idSites, $capability)    {        if ($this->hasSuperUserAccess()) {            return;        }        $idSites = $this->getIdSites($idSites);        $idSitesAccessible = $this->getSitesIdWithCapability($capability);        foreach ($idSites as $idsite) {            if (!in_array($idsite, $idSitesAccessible)) {                $this->throwNoAccessException(Piwik::translate('ExceptionCapabilityAccessWebsite', array(""'"" . $capability .""'"", $idsite)));            }        }        // a capability applies only when the user also has at least view access        $this->checkUserHasViewAccess($idSites);    }    /**     * @param int|array|string $idSites     * @return array     * @throws \Piwik\NoAccessException     */    protected function getIdSites($idSites)    {        if ($idSites === 'all') {            $idSites = $this->getSitesIdWithAtLeastViewAccess();        }        $idSites = Site::getIdSitesFromIdSitesString($idSites);        if (empty($idSites)) {            $this->throwNoAccessException(""The parameter 'idSite=' is missing from the request."");        }        return $idSites;    }    /**     * Executes a callback with superuser privileges, making sure those privileges are rescinded     * before this method exits. Privileges will be rescinded even if an exception is thrown.     *     * @param callback $function The callback to execute. Should accept no arguments.     * @return mixed The result of `$function`.     * @throws Exception rethrows any exceptions thrown by `$function`.     * @api     */    public static function doAsSuperUser($function)    {        $isSuperUser = self::getInstance()->hasSuperUserAccess();        if ($isSuperUser) {            return $function();        }        $access = self::getInstance();        $login = $access->getLogin();        $shouldResetLogin = empty($login); // make sure to reset login if a login was set by ""makeSureLoginNameIsSet()""        $access->setSuperUserAccess(true);        try {            $result = $function();        } catch (\Throwable $ex) {            $access->setSuperUserAccess($isSuperUser);            if ($shouldResetLogin) {                $access->login = null;            }            throw $ex;        }        if ($shouldResetLogin) {            $access->login = null;        }        $access->setSuperUserAccess($isSuperUser);        return $result;    }    /**     * Returns the level of access the current user has to the given site.     *     * @param int $idSite The site to check.     * @return string The access level, eg, 'view', 'admin', 'noaccess'.     */    public function getRoleForSite($idSite)    {        if ($this->hasSuperUserAccess            || in_array($idSite, $this->getSitesIdWithAdminAccess())        ) {            return 'admin';        }        if (in_array($idSite, $this->getSitesIdWithWriteAccess())) {            return 'write';        }        if (in_array($idSite, $this->getSitesIdWithViewAccess())) {            return 'view';        }        return 'noaccess';    }    /**     * Returns the capabilities the current user has for a given site.     *     * @param int $idSite The site to check.     * @return string[] The capabilities the user has.     */    public function getCapabilitiesForSite($idSite)    {        $result = [];        foreach ($this->capabilityProvider->getAllCapabilityIds() as $capabilityId) {            if (empty($this->idsitesByAccess[$capabilityId])) {                continue;            }            if (in_array($idSite, $this->idsitesByAccess[$capabilityId])) {                $result[] = $capabilityId;            }        }        return $result;    }    /**     * Throw a NoAccessException with the given message, or a more generic 'You need to log in' message if the     * user is not currently logged in (e.g. if session has expired).     *     * @param $message     * @throws NoAccessException     */    private function throwNoAccessException($message)    {        if (Piwik::isUserIsAnonymous() && !Request::isRootRequestApiRequest()) {            $message = Piwik::translate('General_YouMustBeLoggedIn');            // Try to detect whether user was previously logged in so that we can display a different message            $referrer = Url::getReferrer();            $matomoUrl = SettingsPiwik::getPiwikUrl();            if ($referrer && $matomoUrl && Url::isValidHost(Url::getHostFromUrl($referrer)) &&                strpos($referrer, $matomoUrl) === 0            ) {                $message = Piwik::translate('General_YourSessionHasExpired');            }        }        throw new NoAccessException($message);    }    /**     * Returns true if the current user is logged in or not.     *     * @return bool     */    public function isUserLoggedIn()    {        return !empty($this->login);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_27," Returns an array of ID sites for which the user has at least a VIEW access.\\n Which means VIEW OR WRITE or ADMIN or SUPERUSER.\\n\\n @return array  Example if the user is ADMIN for 4\\n                and has VIEW access for 1 and 7, it returns array(1, 4, 7);\\n", Returns an array of ID sites for which the user has at least a VIEW access.,"    public function getSitesIdWithAtLeastViewAccess()    {        $this->loadSitesIfNeeded();        return array_unique(array_merge(                $this->idsitesByAccess['view'],                $this->idsitesByAccess['write'],                $this->idsitesByAccess['admin'],                $this->idsitesByAccess['superuser'])        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_28," Returns an array of ID sites for which the user has at least a WRITE access.\\n Which means WRITE or ADMIN or SUPERUSER.\\n\\n @return array  Example if the user is WRITE for 4 and 8\\n                and has VIEW access for 1 and 7, it returns array(4, 8);\\n", Returns an array of ID sites for which the user has at least a WRITE access.,"    public function getSitesIdWithAtLeastWriteAccess()    {        $this->loadSitesIfNeeded();        return array_unique(array_merge(                $this->idsitesByAccess['write'],                $this->idsitesByAccess['admin'],                $this->idsitesByAccess['superuser'])        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_34, Returns `true` if the current user has admin access to at least one site.\\n\\n @return bool\\n, Returns `true` if the current user has admin access to at least one site.,    public function isUserHasSomeAdminAccess()    {        if ($this->hasSuperUserAccess()) {            return true;        }        $idSitesAccessible = $this->getSitesIdWithAdminAccess();        return count($idSitesAccessible) > 0;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_42," Executes a callback with superuser privileges, making sure those privileges are rescinded\\n before this method exits. Privileges will be rescinded even if an exception is thrown.\\n\\n @param callback $function The callback to execute. Should accept no arguments.\\n @return mixed The result of `$function`.\\n @throws Exception rethrows any exceptions thrown by `$function`.\\n @api\\n"," Executes a callback with superuser privileges, making sure those privileges are rescinded","    public static function doAsSuperUser($function)    {        $isSuperUser = self::getInstance()->hasSuperUserAccess();        if ($isSuperUser) {            return $function();        }        $access = self::getInstance();        $login = $access->getLogin();        $shouldResetLogin = empty($login); // make sure to reset login if a login was set by ""makeSureLoginNameIsSet()""        $access->setSuperUserAccess(true);        try {            $result = $function();        } catch (\Throwable $ex) {            $access->setSuperUserAccess($isSuperUser);            if ($shouldResetLogin) {                $access->login = null;            }            throw $ex;        }        if ($shouldResetLogin) {            $access->login = null;        }        $access->setSuperUserAccess($isSuperUser);        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_45," Throw a NoAccessException with the given message, or a more generic 'You need to log in' message if the\\n user is not currently logged in (e.g. if session has expired).\\n\\n @param $message\\n @throws NoAccessException\\n"," Throw a NoAccessException with the given message, or a more generic 'You need to log in' message if the","    private function throwNoAccessException($message)    {        if (Piwik::isUserIsAnonymous() && !Request::isRootRequestApiRequest()) {            $message = Piwik::translate('General_YouMustBeLoggedIn');            // Try to detect whether user was previously logged in so that we can display a different message            $referrer = Url::getReferrer();            $matomoUrl = SettingsPiwik::getPiwikUrl();            if ($referrer && $matomoUrl && Url::isValidHost(Url::getHostFromUrl($referrer)) &&                strpos($referrer, $matomoUrl) === 0            ) {                $message = Piwik::translate('General_YourSessionHasExpired');            }        }        throw new NoAccessException($message);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_756, Gets the singleton instance. Creates it if necessary.\n\n @return self\n, Gets the singleton instance. Creates it if necessary.,    public static function getInstance()    {        return StaticContainer::get('Piwik\Access');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_774," This method checks that the user has VIEW or ADMIN access for the given list of websites.\n If the user doesn't have VIEW or ADMIN access for at least one website of the list, we throw an exception.\n\n @param int|array|string $idSites List of ID sites to check (integer, array of integers, string comma separated list of integers)\n @throws \\Piwik\\NoAccessException  If for any of the websites the user doesn't have an VIEW or ADMIN access\n", This method checks that the user has VIEW or ADMIN access for the given list of websites.,"    public function checkUserHasViewAccess($idSites)    {        if ($this->hasSuperUserAccess()) {            return;        }        $idSites = $this->getIdSites($idSites);        $idSitesAccessible = $this->getSitesIdWithAtLeastViewAccess();        foreach ($idSites as $idsite) {            if (!in_array($idsite, $idSitesAccessible)) {                $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilegeAccessWebsite', array(""'view'"", $idsite)));            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_779, Returns the capabilities the current user has for a given site.\n\n @param int $idSite The site to check.\n @return string[] The capabilities the user has.\n, Returns the capabilities the current user has for a given site.,"    public function getCapabilitiesForSite($idSite)    {        $result = [];        foreach ($this->capabilityProvider->getAllCapabilityIds() as $capabilityId) {            if (empty($this->idsitesByAccess[$capabilityId])) {                continue;            }            if (in_array($idSite, $this->idsitesByAccess[$capabilityId])) {                $result[] = $capabilityId;            }        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_781, Returns true if the current user is logged in or not.\n\n @return bool\n, Returns true if the current user is logged in or not.,    public function isUserLoggedIn()    {        return !empty($this->login);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ArchiveProcessor_802," Caches multiple numeric records in the archive for this processor's site, period\n and segment.\n\n @param array $numericRecords A name-value mapping of numeric values that should be\n                              archived, eg,\n\n                                  array('Referrers_distinctKeywords' => 23, 'Referrers_distinctCampaigns' => 234)\n @api\n"," Caches multiple numeric records in the archive for this processor's site, period","    public function insertNumericRecords($numericRecords)    {        foreach ($numericRecords as $name => $value) {            $this->insertNumericRecord($name, $value);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ArchiveProcessor_806," Processes number of unique visitors for the given period\n\n This is the only Period metric (ie. week/month/year/range) that we process from the logs directly,\n since unique visitors cannot be summed like other metrics.\n\n @param array $metrics Metrics Ids for which to aggregates count of values\n @param int[] $sites  A list of idSites that should be included\n @return array|null An array of metrics, where the key is metricid and the value is the metric value or null if\n                      the query was cancelled and not executed.\n", Processes number of unique visitors for the given period,"    protected function computeNbUniques($metrics, $sites)    {        $logAggregator = $this->getLogAggregator();        $sitesBackup = $logAggregator->getSites();        $logAggregator->setSites($sites);        try {            $query = $logAggregator->queryVisitsByDimension(array(), false, array(), $metrics);        } finally {            $logAggregator->setSites($sitesBackup);        }        $data = $query->fetch();        return $data;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ArchiveProcessor_808, Aggregates the DataTable\\Map into the destination $aggregated\n @param $map\n @param $aggregated\n, Aggregates the DataTable,"    protected function aggregatedDataTableMapsAsOne(Map $map, DataTable $aggregated)    {        foreach ($map->getDataTables() as $tableToAggregate) {            if ($tableToAggregate instanceof Map) {                $this->aggregatedDataTableMapsAsOne($tableToAggregate, $aggregated);            } else {                $aggregated->addDataTable($tableToAggregate);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ArchiveProcessor_809, Initiate archiving for a plugin during an ongoing archiving. The plugin can be another\n plugin or the same plugin.\n\n This method should be called during archiving when one plugin uses the report of another\n plugin with a segment. It will ensure reports for that segment & plugin will be archived\n without initiating archiving for every plugin with that segment (which would be a performance\n killer).\n\n @param string $plugin\n @param string $segment\n, Initiate archiving for a plugin during an ongoing archiving. The plugin can be another,"    public function processDependentArchive($plugin, $segment)    {        $params = $this->getParams();        if (!$params->isRootArchiveRequest()) { // prevent all recursion            return;        }        $idSites = [$params->getSite()->getId()];        $newSegment = Segment::combine($params->getSegment()->getString(), SegmentExpression::AND_DELIMITER, $segment);        if ($newSegment === $segment && $params->getRequestedPlugin() === $plugin) { // being processed now            return;        }        $newSegment = new Segment($newSegment, $idSites, $params->getDateStart(), $params->getDateEnd());        if (ArchiveProcessor\Rules::isSegmentPreProcessed($idSites, $newSegment)) {            // will be processed anyway            return;        }        $parameters = new ArchiveProcessor\Parameters($params->getSite(), $params->getPeriod(), $newSegment);        $parameters->onlyArchiveRequestedPlugin();        $parameters->setIsRootArchiveRequest(false);        $archiveLoader = new ArchiveProcessor\Loader($parameters);        $archiveLoader->prepareArchive($plugin);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_57, Returns an array describing what metadata to use when indexing a query result.\\n For use with DataCollection.\\n\\n @return array\\n, Returns an array describing what metadata to use when indexing a query result.,    private function getResultIndices()    {        $indices = array();        if (count($this->params->getIdSites()) > 1            || $this->forceIndexedBySite        ) {            $indices['site'] = 'idSite';        }        if (count($this->params->getPeriods()) > 1            || $this->forceIndexedByDate        ) {            $indices['period'] = 'date';        }        return $indices;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_58," Initializes the archive ID cache ($this->idarchives) for a particular 'done' flag.\\n\\n It is necessary that each archive ID caching function call this method for each\\n unique 'done' flag it encounters, since the getArchiveIds function determines\\n whether archiving should be launched based on whether $this->idarchives has a\\n an entry for a specific 'done' flag.\\n\\n If this  function is not called, then periods with no visits will not add\\n entries to the cache. If the archive is used again, SQL will be executed to\\n try and find the archive IDs even though we know there are none.\\n\\n @param string $doneFlag\\n", Initializes the archive ID cache ($this->idarchives) for a particular 'done' flag.,    private function initializeArchiveIdCache($doneFlag)    {        if (!isset($this->idarchives[$doneFlag])) {            $this->idarchives[$doneFlag] = array();        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_782," The  (termed ""archive data"").\n\n You can use  for one or more periods and one optional segment.\n\n If archive data is not found, this class will initiate the archiving process. [1](#footnote-1)\n\n  they cannot be constructed.\n\n You can search for metrics (such as `nb_visits`) using the {@link getNumeric()} and\n {@link getDataTableFromNumeric()} methods. You can search for\n reports using the {@link getBlob()}, {@link getDataTable()} and {@link getDataTableExpanded()} methods.\n\n If you\'re creating an API that returns report data, you may want to use the\n {@link createDataTableFromArchive()} helper function.\n\n ### Learn more\n\n Learn more about _archiving_ [here](/guides/all-about-analytics-data).\n\n ### Limitations\n\n - You cannot get data for multiple range periods in a single query.\n - You cannot get data for periods of different types in a single query.\n\n ### Examples\n\n \n     // one site and one period\n     $archive = Archive::build($idSite = 1, $period = \'week\', $date = \'2013-03-08\');\n     return $archive->getDataTableFromNumeric(array(\'nb_visits\', \'nb_actions\'));\n\n     // all sites and multiple dates\n     $archive = Archive::build($idSite = \'all\', $period = \'month\', $date = \'2013-01-02,2013-03-08\');\n     return $archive->getDataTableFromNumeric(array(\'nb_visits\', \'nb_actions\'));\n\n \n     // one site and one period\n     $archive = Archive::build($idSite = 1, $period = \'week\', $date = \'2013-03-08\');\n     $data = $archive->getNumeric(array(\'nb_visits\', \'nb_actions\'));\n\n     $visits = $data[\'nb_visits\'];\n     $actions = $data[\'nb_actions\'];\n\n     // ... do something w/ metric data ...\n\n     // multiple sites and multiple dates\n     $archive = Archive::build($idSite = \'1,2,3\', $period = \'month\', $date = \'2013-01-02,2013-03-08\');\n     $data = $archive->getNumeric(\'nb_visits\');\n\n     $janSite1Visits = $data[\'1\'][\'2013-01-01,2013-01-31\'][\'nb_visits\'];\n     $febSite1Visits = $data[\'1\'][\'2013-02-01,2013-02-28\'][\'nb_visits\'];\n     // ... etc.\n\n \n     $archive = Archive::build($idSite = 1, $period = \'week\', $date = \'2013-03-08\');\n     $dataTable = $archive->getDataTable(\'MyPlugin_MyReport\');\n     // ... manipulate $dataTable ...\n     return $dataTable;\n\n \n     public function getMyReport($idSite, $period, $date, $segment = false, $expanded = false)\n     {\n         $dataTable = Archive::createDataTableFromArchive(\'MyPlugin_MyReport\', $idSite, $period, $date, $segment, $expanded);\n         return $dataTable;\n     }\n\n \n     // get data for first range\n     $archive = Archive::build($idSite = 1, $period = \'range\', $date = \'2013-03-08,2013-03-12\');\n     $dataTable = $archive->getDataTableFromNumeric(array(\'nb_visits\', \'nb_actions\'));\n\n     // get data for second range\n     $archive = Archive::build($idSite = 1, $period = \'range\', $date = \'2013-03-15,2013-03-20\');\n     $dataTable = $archive->getDataTableFromNumeric(array(\'nb_visits\', \'nb_actions\'));\n\n <a name=""footnote-1""></a>\n [1]: The archiving process will not be launched if browser archiving is disabled\n      and the current request came from a browser.\n\n\n @api\n"," The  (termed ""archive data"").","class Archive implements ArchiveQuery{    const REQUEST_ALL_WEBSITES_FLAG = 'all';    const ARCHIVE_ALL_PLUGINS_FLAG = 'all';    const ID_SUBTABLE_LOAD_ALL_SUBTABLES = 'all';    /**     * List of archive IDs for the site, periods and segment we are querying with.     * Archive IDs are indexed by done flag and period, ie:     *     * array(     *     'done.Referrers' => array(     *         '2010-01-01' => 1,     *         '2010-01-02' => 2,     *     ),     *     'done.VisitsSummary' => array(     *         '2010-01-01' => 3,     *         '2010-01-02' => 4,     *     ),     * )     *     * or,     *     * array(     *     'done.all' => array(     *         '2010-01-01' => 1,     *         '2010-01-02' => 2     *     )     * )     *     * @var array     */    private $idarchives = array();    /**     * If set to true, the result of all get functions (ie, getNumeric, getBlob, etc.)     * will be indexed by the site ID, even if we're only querying data for one site.     *     * @var bool     */    private $forceIndexedBySite;    /**     * If set to true, the result of all get functions (ie, getNumeric, getBlob, etc.)     * will be indexed by the period, even if we're only querying data for one period.     *     * @var bool     */    private $forceIndexedByDate;    /**     * @var Parameters     */    private $params;    /**     * @var \Matomo\Cache\Cache     */    private static $cache;    /**     * If true, this Archive instance will not launch the archiving process, even if the current request     * is authorized to.     *     * @var bool     */    private $forceFetchingWithoutLaunchingArchiving;    /**     * @param Parameters $params     * @param bool $forceIndexedBySite Whether to force index the result of a query by site ID.     * @param bool $forceIndexedByDate Whether to force index the result of a query by period.     */    public function __construct(Parameters $params, $forceIndexedBySite = false,                                   $forceIndexedByDate = false)    {        $this->params = $params;        $this->forceIndexedBySite = $forceIndexedBySite;        $this->forceIndexedByDate = $forceIndexedByDate;    }    /**     * Returns a new Archive instance that will query archive data for the given set of     * sites and periods, using an optional Segment.     *     * This method uses data that is found in query parameters, so the parameters to this     * function can be string values.     *     * If you want to create an Archive instance with an array of Period instances, use     * {@link Archive::factory()}.     *     * @param string|int|array $idSites A single ID (eg, `'1'`), multiple IDs (eg, `'1,2,3'` or `array(1, 2, 3)`),     *                                  or `'all'`.     * @param string $period 'day', `'week'`, `'month'`, `'year'` or `'range'`     * @param Date|string $strDate 'YYYY-MM-DD', magic keywords (ie, 'today'; {@link Date::factory()}     *                             or date range (ie, 'YYYY-MM-DD,YYYY-MM-DD').     * @param bool|false|string $segment Segment definition or false if no segment should be used. {@link Piwik\Segment}     * @param bool|false|string $_restrictSitesToLogin Used only when running as a scheduled task.     * @return ArchiveQuery     */    public static function build($idSites, $period, $strDate, $segment = false, $_restrictSitesToLogin = false)    {        return StaticContainer::get(ArchiveQueryFactory::class)->build($idSites, $period, $strDate, $segment,            $_restrictSitesToLogin);    }    /**     * Returns a new Archive instance that will query archive data for the given set of     * sites and periods, using an optional segment.     *     * This method uses an array of Period instances and a Segment instance, instead of strings     * like {@link build()}.     *     * If you want to create an Archive instance using data found in query parameters,     * use {@link build()}.     *     * @param Segment $segment The segment to use. For no segment, use `new Segment('', $idSites)`.     * @param array $periods An array of Period instances.     * @param array $idSites An array of site IDs (eg, `array(1, 2, 3)`).     * @param bool $idSiteIsAll Whether `'all'` sites are being queried or not. If true, then     *                          the result of querying functions will be indexed by site, regardless     *                          of whether `count($idSites) == 1`.     * @param bool $isMultipleDate Whether multiple dates are being queried or not. If true, then     *                             the result of querying functions will be indexed by period,     *                             regardless of whether `count($periods) == 1`.     *     * @return ArchiveQuery     */    public static function factory(Segment $segment, array $periods, array $idSites, $idSiteIsAll = false,                                   $isMultipleDate = false)    {        return StaticContainer::get(ArchiveQueryFactory::class)->factory($segment, $periods, $idSites, $idSiteIsAll,            $isMultipleDate);    }    public static function shouldSkipArchiveIfSkippingSegmentArchiveForToday(Site $site, Period $period, Segment $segment)    {        $now = Date::factory('now', $site->getTimezone());        return $period->getLabel() === 'day'            && !$segment->isEmpty()            && $period->getDateStart()->toString() === $now->toString();    }    /**     * Queries and returns metric data in an array.     *     * If multiple sites were requested in {@link build()} or {@link factory()} the result will     * be indexed by site ID.     *     * If multiple periods were requested in {@link build()} or {@link factory()} the result will     * be indexed by period.     *     * The site ID index is always first, so if multiple sites & periods were requested, the result     * will be indexed by site ID first, then period.     *     * @param string|array $names One or more archive names, eg, `'nb_visits'`, `'Referrers_distinctKeywords'`,     *                            etc.     * @return false|integer|array `false` if there is no data to return, a single numeric value if we're not querying     *                             for multiple sites/periods, or an array if multiple sites, periods or names are     *                             queried for.     */    public function getNumeric($names)    {        $data = $this->get($names, 'numeric');        $resultIndices = $this->getResultIndices();        $result = $data->getIndexedArray($resultIndices);        // if only one metric is returned, just return it as a numeric value        if (empty($resultIndices)            && count($result) <= 1            && (!is_array($names) || count($names) === 1)        ) {            $result = (float)reset($result); // convert to float in case $result is empty        }        return $result;    }    /**     * Queries and returns metric data in a DataTable instance.     *     * If multiple sites were requested in {@link build()} or {@link factory()} the result will     * be a DataTable\Map that is indexed by site ID.     *     * If multiple periods were requested in {@link build()} or {@link factory()} the result will     * be a {@link DataTable\Map} that is indexed by period.     *     * The site ID index is always first, so if multiple sites & periods were requested, the result     * will be a {@link DataTable\Map} indexed by site ID which contains {@link DataTable\Map} instances that are     * indexed by period.     *     * _Note: Every DataTable instance returned will have at most one row in it. The contents of each     *        row will be the requested metrics for the appropriate site and period._     *     * @param string|array $names One or more archive names, eg, 'nb_visits', 'Referrers_distinctKeywords',     *                            etc.     * @return DataTable|DataTable\Map A DataTable if multiple sites and periods were not requested.     *                                 An appropriately indexed DataTable\Map if otherwise.     */    public function getDataTableFromNumeric($names)    {        $data = $this->get($names, 'numeric');        return $data->getDataTable($this->getResultIndices());    }    /**     * Similar to {@link getDataTableFromNumeric()} but merges all children on the created DataTable.     *     * This is the same as doing `$this->getDataTableFromNumeric()->mergeChildren()` but this way it is much faster.     *     * @return DataTable|DataTable\Map     *     * @internal Currently only used by MultiSites.getAll plugin. Feel free to remove internal tag if needed somewhere     *           else. If no longer needed by MultiSites.getAll please remove this method. If you need this to work in     *           a bit different way feel free to refactor as always.     */    public function getDataTableFromNumericAndMergeChildren($names)    {        $data  = $this->get($names, 'numeric');        $resultIndexes = $this->getResultIndices();        return $data->getMergedDataTable($resultIndexes);    }    /**     * Queries and returns one or more reports as DataTable instances.     *     * This method will query blob data that is a serialized array of of {@link DataTable\Row}'s and     * unserialize it.     *     * If multiple sites were requested in {@link build()} or {@link factory()} the result will     * be a {@link DataTable\Map} that is indexed by site ID.     *     * If multiple periods were requested in {@link build()} or {@link factory()} the result will     * be a DataTable\Map that is indexed by period.     *     * The site ID index is always first, so if multiple sites & periods were requested, the result     * will be a {@link DataTable\Map} indexed by site ID which contains {@link DataTable\Map} instances that are     * indexed by period.     *     * @param string $name The name of the record to get. This method can only query one record at a time.     * @param int|string|null $idSubtable The ID of the subtable to get (if any).     * @return DataTable|DataTable\Map A DataTable if multiple sites and periods were not requested.     *                                 An appropriately indexed {@link DataTable\Map} if otherwise.     */    public function getDataTable($name, $idSubtable = null)    {        $data = $this->get($name, 'blob', $idSubtable);        return $data->getDataTable($this->getResultIndices());    }    /**     * Queries and returns one report with all of its subtables loaded.     *     * If multiple sites were requested in {@link build()} or {@link factory()} the result will     * be a DataTable\Map that is indexed by site ID.     *     * If multiple periods were requested in {@link build()} or {@link factory()} the result will     * be a DataTable\Map that is indexed by period.     *     * The site ID index is always first, so if multiple sites & periods were requested, the result     * will be a {@link DataTable\Map indexed} by site ID which contains {@link DataTable\Map} instances that are     * indexed by period.     *     * @param string $name The name of the record to get.     * @param int|string|null $idSubtable The ID of the subtable to get (if any). The subtable will be expanded.     * @param int|null $depth The maximum number of subtable levels to load. If null, all levels are loaded.     *                        For example, if `1` is supplied, then the DataTable returned will have its subtables     *                        loaded. Those subtables, however, will NOT have their subtables loaded.     * @param bool $addMetadataSubtableId Whether to add the database subtable ID as metadata to each datatable,     *                                    or not.     * @return DataTable|DataTable\Map     */    public function getDataTableExpanded($name, $idSubtable = null, $depth = null, $addMetadataSubtableId = true)    {        $data = $this->get($name, 'blob', self::ID_SUBTABLE_LOAD_ALL_SUBTABLES);        return $data->getExpandedDataTable($this->getResultIndices(), $idSubtable, $depth, $addMetadataSubtableId);    }    /**     * Returns the list of plugins that archive the given reports.     *     * @param array $archiveNames     * @return array     */    private function getRequestedPlugins($archiveNames)    {        $result = array();        foreach ($archiveNames as $name) {            $result[] = self::getPluginForReport($name);        }        return array_unique($result);    }    /**     * Returns an object describing the set of sites, the set of periods and the segment     * this Archive will query data for.     *     * @return Parameters     */    public function getParams()    {        return $this->params;    }    /**     * Helper function that creates an Archive instance and queries for report data using     * query parameter data. API methods can use this method to reduce code redundancy.     *     * @param string $recordName The name of the report to return.     * @param int|string|array $idSite @see {@link build()}     * @param string $period @see {@link build()}     * @param string $date @see {@link build()}     * @param string $segment @see {@link build()}     * @param bool $expanded If true, loads all subtables. See {@link getDataTableExpanded()}     * @param bool $flat If true, loads all subtables and disabled all recursive filters.     * @param int|null $idSubtable See {@link getDataTableExpanded()}     * @param int|null $depth See {@link getDataTableExpanded()}     * @return DataTable|DataTable\Map     */    public static function createDataTableFromArchive($recordName, $idSite, $period, $date, $segment, $expanded = false, $flat = false, $idSubtable = null, $depth = null)    {        Piwik::checkUserHasViewAccess($idSite);        if ($flat && !$idSubtable) {            $expanded = true;        }        $archive = Archive::build($idSite, $period, $date, $segment, $_restrictSitesToLogin = false);        if ($idSubtable === false) {            $idSubtable = null;        }        if ($expanded) {            $dataTable = $archive->getDataTableExpanded($recordName, $idSubtable, $depth);        } else {            $dataTable = $archive->getDataTable($recordName, $idSubtable);        }        $dataTable->queueFilter('ReplaceSummaryRowLabel');        $dataTable->queueFilter('ReplaceColumnNames');        if ($expanded) {            $dataTable->queueFilterSubtables('ReplaceColumnNames');        }        if ($flat) {            $dataTable->disableRecursiveFilters();        }        return $dataTable;    }    /**     * Queries archive tables for data and returns the result.     * @param array|string $archiveNames     * @param $archiveDataType     * @param null|int $idSubtable     * @return Archive\DataCollection     */    protected function get($archiveNames, $archiveDataType, $idSubtable = null)    {        if (!is_array($archiveNames)) {            $archiveNames = array($archiveNames);        }        $archiveNames = array_filter($archiveNames);        // apply idSubtable        if ($idSubtable !== null            && $idSubtable !== self::ID_SUBTABLE_LOAD_ALL_SUBTABLES        ) {            // this is also done in ArchiveSelector. It should be actually only done in ArchiveSelector but DataCollection            // does require to have the subtableId appended. Needs to be changed in refactoring to have it only in one            // place.            $dataNames = array();            foreach ($archiveNames as $name) {                $dataNames[] = ArchiveSelector::appendIdsubtable($name, $idSubtable);            }        } else {            $dataNames = $archiveNames;        }        $result = new Archive\DataCollection(            $dataNames, $archiveDataType, $this->params->getIdSites(), $this->params->getPeriods(), $this->params->getSegment(), $defaultRow = null);        if (empty($dataNames)) {            return $result; // NOTE: note posting Archive.noArchivedData here, because there might be archive data, someone just requested nothing        }        $archiveIds = $this->getArchiveIds($archiveNames);        if (empty($archiveIds)) {            /**             * Triggered when no archive data is found in an API request.             * @ignore             */            Piwik::postEvent('Archive.noArchivedData');            return $result;        }        $archiveData = ArchiveSelector::getArchiveData($archiveIds, $archiveNames, $archiveDataType, $idSubtable);        $isNumeric = $archiveDataType === 'numeric';        foreach ($archiveData as $row) {            // values are grouped by idsite (site ID), date1-date2 (date range), then name (field name)            $periodStr = $row['date1'] . ',' . $row['date2'];            if ($isNumeric) {                $row['value'] = $this->formatNumericValue($row['value']);            } else {                $result->addMetadata($row['idsite'], $periodStr, DataTable::ARCHIVED_DATE_METADATA_NAME, $row['ts_archived']);            }            $result->set($row['idsite'], $periodStr, $row['name'], $row['value']);        }        return $result;    }    /**     * Returns archive IDs for the sites, periods and archive names that are being     * queried. This function will use the idarchive cache if it has the right data,     * query archive tables for IDs w/o launching archiving, or launch archiving and     * get the idarchive from ArchiveProcessor instances.     *     * @param string $archiveNames     * @return array     */    private function getArchiveIds($archiveNames)    {        $plugins = $this->getRequestedPlugins($archiveNames);        // figure out which archives haven't been processed (if an archive has been processed,        // then we have the archive IDs in $this->idarchives)        $doneFlags     = array();        $archiveGroups = array();        foreach (array_merge($plugins, ['all']) as $plugin) {            $doneFlag = $this->getDoneStringForPlugin($plugin, $this->params->getIdSites());            $doneFlags[$doneFlag] = true;            if (!isset($this->idarchives[$doneFlag])) {                $archiveGroup = $this->getArchiveGroupOfPlugin($plugin);                if ($archiveGroup === self::ARCHIVE_ALL_PLUGINS_FLAG) {                    $archiveGroup = reset($plugins);                }                $archiveGroups[] = $archiveGroup;            }            $doneFlag = Rules::getDoneFlagArchiveContainsOnePlugin($this->params->getSegment(), $plugin);            $doneFlags[$doneFlag] = true;        }        $globalDoneFlag = Rules::getDoneFlagArchiveContainsAllPlugins($this->params->getSegment());        $doneFlags[$globalDoneFlag] = true;        $archiveGroups = array_unique($archiveGroups);        // cache id archives for plugins we haven't processed yet        if (!empty($archiveGroups)) {            if (Rules::isArchivingEnabledFor($this->params->getIdSites(), $this->params->getSegment(), $this->getPeriodLabel())                && !$this->forceFetchingWithoutLaunchingArchiving            ) {                $this->cacheArchiveIdsAfterLaunching($archiveGroups, $plugins);            } else {                $this->cacheArchiveIdsWithoutLaunching($plugins);            }        }        $idArchivesByMonth = $this->getIdArchivesByMonth($doneFlags);        return $idArchivesByMonth;    }    /**     * Gets the IDs of the archives we're querying for and stores them in $this->archives.     * This function will launch the archiving process for each period/site/plugin if     * metrics/reports have not been calculated/archived already.     *     * @param array $archiveGroups @see getArchiveGroupOfReport     * @param array $plugins List of plugin names to archive.     */    private function cacheArchiveIdsAfterLaunching($archiveGroups, $plugins)    {        $today = Date::today();        foreach ($this->params->getPeriods() as $period) {            $twoDaysBeforePeriod = $period->getDateStart()->subDay(2);            $twoDaysAfterPeriod = $period->getDateEnd()->addDay(2);            foreach ($this->params->getIdSites() as $idSite) {                $site = new Site($idSite);                if (Common::getRequestVar('skipArchiveSegmentToday', 0, 'int')                    && self::shouldSkipArchiveIfSkippingSegmentArchiveForToday($site, $period, $this->params->getSegment())                ) {                    Log::debug(""Skipping archive %s for %s as segment today is disabled"", $period->getLabel(), $period->getPrettyString());                    continue;                }                // if the END of the period is BEFORE the website creation date                // we already know there are no stats for this period                // we add one day to make sure we don't miss the day of the website creation                if ($twoDaysAfterPeriod->isEarlier($site->getCreationDate())) {                    Log::debug(""Archive site %s, %s (%s) skipped, archive is before the website was created."",                        $idSite, $period->getLabel(), $period->getPrettyString());                    continue;                }                // if the starting date is in the future we know there is no visiidsite = ?t                if ($twoDaysBeforePeriod->isLater($today)) {                    Log::debug(""Archive site %s, %s (%s) skipped, archive is after today."",                        $idSite, $period->getLabel(), $period->getPrettyString());                    continue;                }                $this->prepareArchive($archiveGroups, $site, $period);            }        }    }    /**     * Gets the IDs of the archives we're querying for and stores them in $this->archives.     * This function will not launch the archiving process (and is thus much, much faster     * than cacheArchiveIdsAfterLaunching).     *     * @param array $plugins List of plugin names from which data is being requested.     */    private function cacheArchiveIdsWithoutLaunching($plugins)    {        $idarchivesByReport = ArchiveSelector::getArchiveIds(            $this->params->getIdSites(), $this->params->getPeriods(), $this->params->getSegment(), $plugins);        // initialize archive ID cache for each report        foreach ($plugins as $plugin) {            $doneFlag = $this->getDoneStringForPlugin($plugin, $this->params->getIdSites());            $this->initializeArchiveIdCache($doneFlag);            $globalDoneFlag = Rules::getDoneFlagArchiveContainsAllPlugins($this->params->getSegment());            $this->initializeArchiveIdCache($globalDoneFlag);        }        foreach ($idarchivesByReport as $doneFlag => $idarchivesByDate) {            foreach ($idarchivesByDate as $dateRange => $idarchives) {                foreach ($idarchives as $idarchive) {                    // idarchives selected can include all plugin archives, plugin specific archives and partial report                    // archives. only the latest data in all of these archives will be selected.                    $this->idarchives[$doneFlag][$dateRange][] = $idarchive;                }            }        }    }    /**     * Returns the done string flag for a plugin using this instance's segment & periods.     * @param string $plugin     * @return string     */    private function getDoneStringForPlugin($plugin, $idSites)    {        return Rules::getDoneStringFlagFor(                    $idSites,                    $this->params->getSegment(),                    $this->getPeriodLabel(),                    $plugin        );    }    private function getPeriodLabel()    {        $periods = $this->params->getPeriods();        return reset($periods)->getLabel();    }    /**     * Returns an array describing what metadata to use when indexing a query result.     * For use with DataCollection.     *     * @return array     */    private function getResultIndices()    {        $indices = array();        if (count($this->params->getIdSites()) > 1            || $this->forceIndexedBySite        ) {            $indices['site'] = 'idSite';        }        if (count($this->params->getPeriods()) > 1            || $this->forceIndexedByDate        ) {            $indices['period'] = 'date';        }        return $indices;    }    private function formatNumericValue($value)    {        // If there is no dot, we return as is        // Note: this could be an integer bigger than 32 bits        if (strpos($value, '.') === false) {            if ($value === false) {                return 0;            }            return (float)$value;        }        // Round up the value with 2 decimals        // we cast the result as float because returns false when no visitors        return round((float)$value, 2);    }    /**     * Initializes the archive ID cache ($this->idarchives) for a particular 'done' flag.     *     * It is necessary that each archive ID caching function call this method for each     * unique 'done' flag it encounters, since the getArchiveIds function determines     * whether archiving should be launched based on whether $this->idarchives has a     * an entry for a specific 'done' flag.     *     * If this  function is not called, then periods with no visits will not add     * entries to the cache. If the archive is used again, SQL will be executed to     * try and find the archive IDs even though we know there are none.     *     * @param string $doneFlag     */    private function initializeArchiveIdCache($doneFlag)    {        if (!isset($this->idarchives[$doneFlag])) {            $this->idarchives[$doneFlag] = array();        }    }    /**     * Returns the archiving group identifier given a plugin.     *     * More than one plugin can be called at once when archiving. In such a case     * we don't want to launch archiving three times for three plugins if doing     * it once is enough, so getArchiveIds makes sure to get the archive group of     * all reports.     *     * If the period isn't a range, then all plugins' archiving code is executed.     * If the period is a range, then archiving code is executed individually for     * each plugin.     */    private function getArchiveGroupOfPlugin($plugin)    {        $periods = $this->params->getPeriods();        $periodLabel = reset($periods)->getLabel();        if (Rules::shouldProcessReportsAllPlugins($this->params->getIdSites(), $this->params->getSegment(), $periodLabel)) {            return self::ARCHIVE_ALL_PLUGINS_FLAG;        }        return $plugin;    }    /**     * Returns the name of the plugin that archives a given report.     *     * @param string $report Archive data name, eg, `'nb_visits'`, `'DevicesDetection_...'`, etc.     * @return string Plugin name.     * @throws \Exception If a plugin cannot be found or if the plugin for the report isn't     *                    activated.     */    public static function getPluginForReport($report)    {        // Core metrics are always processed in Core, for the requested date/period/segment        if (in_array($report, Metrics::getVisitsMetricNames())) {            $report = 'VisitsSummary_CoreMetrics';        } // Goal_* metrics are processed by the Goals plugin (HACK)        elseif (strpos($report, 'Goal_') === 0) {            $report = 'Goals_Metrics';        } elseif (            strrpos($report, '_returning') === strlen($report) - strlen('_returning') ||            strrpos($report, '_new') === strlen($report) - strlen('_new')        ) { // HACK            $report = 'VisitFrequency_Metrics';        }        $plugin = substr($report, 0, strpos($report, '_'));        if (empty($plugin)            || !\Piwik\Plugin\Manager::getInstance()->isPluginActivated($plugin)        ) {            throw new \Exception(""Error: The report '$report' was requested but it is not available at this stage.""                               . "" (Plugin '$plugin' is not activated.)"");        }        return $plugin;    }    /**     * @param $archiveGroups     * @param $site     * @param $period     */    private function prepareArchive(array $archiveGroups, Site $site, Period $period)    {        $coreAdminHomeApi = API::getInstance();        $requestedReport = null;        if (SettingsServer::isArchivePhpTriggered()) {            $requestedReport = Common::getRequestVar('requestedReport', '', 'string');        }        $periodString = $period->getRangeString();        $periodDateStr = $period->getLabel() == 'range' ? $periodString : $period->getDateStart()->toString();        $idSites = array($site->getId());        // process for each plugin as well        foreach ($archiveGroups as $plugin) {            $doneFlag = $this->getDoneStringForPlugin($plugin, $idSites);            $this->initializeArchiveIdCache($doneFlag);            $prepareResult = $coreAdminHomeApi->archiveReports(                $site->getId(), $period->getLabel(), $periodDateStr, $this->params->getSegment()->getOriginalString(),                $plugin, $requestedReport);            if (!empty($prepareResult)                && !empty($prepareResult['idarchives'])            ) {                foreach ($prepareResult['idarchives'] as $idArchive) {                    $this->idarchives[$doneFlag][$periodString][] = $idArchive;                }            }        }    }    private function getIdArchivesByMonth($doneFlags)    {        // order idarchives by the table month they belong to        $idArchivesByMonth = array();        foreach (array_keys($doneFlags) as $doneFlag) {            if (empty($this->idarchives[$doneFlag])) {                continue;            }            foreach ($this->idarchives[$doneFlag] as $dateRange => $idarchives) {                foreach ($idarchives as $id) {                    $idArchivesByMonth[$dateRange][] = $id;                }            }        }        return $idArchivesByMonth;    }    /**     * @internal     */    public static function clearStaticCache()    {        self::$cache = null;    }    public function forceFetchingWithoutLaunchingArchiving()    {        $this->forceFetchingWithoutLaunchingArchiving = true;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_784," Queries and returns metric data in a DataTable instance.\n\n If multiple sites were requested in {@link build()} or {@link factory()} the result will\n be a DataTable\\Map that is indexed by site ID.\n\n If multiple periods were requested in {@link build()} or {@link factory()} the result will\n be a {@link DataTable\\Map} that is indexed by period.\n\n The site ID index is always first, so if multiple sites & periods were requested, the result\n will be a {@link DataTable\\Map} indexed by site ID which contains {@link DataTable\\Map} instances that are\n indexed by period.\n\n _Note: Every DataTable instance returned will have at most one row in it. The contents of each\n        row will be the requested metrics for the appropriate site and period._\n\n @param string|array $names One or more archive names, eg, 'nb_visits', 'Referrers_distinctKeywords',\n                            etc.\n @return DataTable|DataTable\\Map A DataTable if multiple sites and periods were not requested.\n                                 An appropriately indexed DataTable\\Map if otherwise.\n", Queries and returns metric data in a DataTable instance.,"    public function getDataTableFromNumeric($names)    {        $data = $this->get($names, 'numeric');        return $data->getDataTable($this->getResultIndices());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_785, Similar to {@link getDataTableFromNumeric()} but merges all children on the created DataTable.\n\n This is the same as doing `$this->getDataTableFromNumeric()->mergeChildren()` but this way it is much faster.\n\n @return DataTable|DataTable\\Map\n\n @internal Currently only used by MultiSites.getAll plugin. Feel free to remove internal tag if needed somewhere\n           else. If no longer needed by MultiSites.getAll please remove this method. If you need this to work in\n           a bit different way feel free to refactor as always.\n, Similar to {@link getDataTableFromNumeric()} but merges all children on the created DataTable.,"    public function getDataTableFromNumericAndMergeChildren($names)    {        $data  = $this->get($names, 'numeric');        $resultIndexes = $this->getResultIndices();        return $data->getMergedDataTable($resultIndexes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_790," Gets the IDs of the archives we're querying for and stores them in $this->archives.\n This function will not launch the archiving process (and is thus much, much faster\n than cacheArchiveIdsAfterLaunching).\n\n @param array $plugins List of plugin names from which data is being requested.\n", Gets the IDs of the archives we're querying for and stores them in $this->archives.,"    private function cacheArchiveIdsWithoutLaunching($plugins)    {        $idarchivesByReport = ArchiveSelector::getArchiveIds(            $this->params->getIdSites(), $this->params->getPeriods(), $this->params->getSegment(), $plugins);        // initialize archive ID cache for each report        foreach ($plugins as $plugin) {            $doneFlag = $this->getDoneStringForPlugin($plugin, $this->params->getIdSites());            $this->initializeArchiveIdCache($doneFlag);            $globalDoneFlag = Rules::getDoneFlagArchiveContainsAllPlugins($this->params->getSegment());            $this->initializeArchiveIdCache($globalDoneFlag);        }        foreach ($idarchivesByReport as $doneFlag => $idarchivesByDate) {            foreach ($idarchivesByDate as $dateRange => $idarchives) {                foreach ($idarchives as $idarchive) {                    // idarchives selected can include all plugin archives, plugin specific archives and partial report                    // archives. only the latest data in all of these archives will be selected.                    $this->idarchives[$doneFlag][$dateRange][] = $idarchive;                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_AssetManager_75, AssetManager is the class used to manage the inclusion of UI assets:\\n JavaScript and CSS files.\\n\\n It performs the following actions:\\n  - Identifies required assets\\n  - Includes assets in the rendered HTML page\\n  - Manages asset merging and minifying\\n  - Manages server-side cache\\n\\n Whether assets are included individually or as merged files is defined by\\n the global option 'disable_merged_assets'. See the documentation in the global\\n config for more information.\\n, AssetManager is the class used to manage the inclusion of UI assets:,"class AssetManager extends Singleton{    const MERGED_CSS_FILE = ""asset_manager_global_css.css"";    const MERGED_CORE_JS_FILE = ""asset_manager_core_js.js"";    const MERGED_NON_CORE_JS_FILE = ""asset_manager_non_core_js.js"";    const CSS_IMPORT_DIRECTIVE = ""<link rel=\""stylesheet\"" type=\""text/css\"" href=\""%s\"" />\n"";    const JS_IMPORT_DIRECTIVE = ""<script type=\""text/javascript\"" src=\""%s\""></script>\n"";    const GET_CSS_MODULE_ACTION = ""index.php?module=Proxy&action=getCss"";    const GET_CORE_JS_MODULE_ACTION = ""index.php?module=Proxy&action=getCoreJs"";    const GET_NON_CORE_JS_MODULE_ACTION = ""index.php?module=Proxy&action=getNonCoreJs"";    /**     * @var UIAssetCacheBuster     */    private $cacheBuster;    /**     * @var UIAssetFetcher     */    private $minimalStylesheetFetcher;    /**     * @var Theme     */    private $theme;    public function __construct()    {        $this->cacheBuster = UIAssetCacheBuster::getInstance();        $this->minimalStylesheetFetcher = new StaticUIAssetFetcher(array(), array(), $this->theme);        $theme = Manager::getInstance()->getThemeEnabled();        if (!empty($theme)) {            $this->theme = new Theme();        }    }    /**     * @inheritDoc     * @return AssetManager     */    public static function getInstance()    {        $assetManager = parent::getInstance();        /**         * Triggered when creating an instance of the asset manager. Lets you overwrite the         * asset manager behavior.         *         * @param AssetManager &$assetManager         *         * @ignore         * This event is not a public event since we don't want to make the asset manager itself public         * API         */        Piwik::postEvent('AssetManager.makeNewAssetManagerObject', array(&$assetManager));        return $assetManager;    }    /**     * @param UIAssetCacheBuster $cacheBuster     */    public function setCacheBuster($cacheBuster)    {        $this->cacheBuster = $cacheBuster;    }    /**     * @param UIAssetFetcher $minimalStylesheetFetcher     */    public function setMinimalStylesheetFetcher($minimalStylesheetFetcher)    {        $this->minimalStylesheetFetcher = $minimalStylesheetFetcher;    }    /**     * @param Theme $theme     */    public function setTheme($theme)    {        $this->theme = $theme;    }    /**     * Return CSS file inclusion directive(s) using the markup <link>     *     * @return string     */    public function getCssInclusionDirective()    {        return sprintf(self::CSS_IMPORT_DIRECTIVE, self::GET_CSS_MODULE_ACTION);    }    /**     * Return JS file inclusion directive(s) using the markup <script>     *     * @return string     */    public function getJsInclusionDirective()    {        $result = ""<script type=\""text/javascript\"">\n"" . StaticContainer::get('Piwik\Translation\Translator')->getJavascriptTranslations() . ""\n</script>"";        if ($this->isMergedAssetsDisabled()) {            $this->getMergedCoreJSAsset()->delete();            $this->getMergedNonCoreJSAsset()->delete();            $result .= $this->getIndividualCoreAndNonCoreJsIncludes();        } else {            $result .= sprintf(self::JS_IMPORT_DIRECTIVE, self::GET_CORE_JS_MODULE_ACTION);            $result .= sprintf(self::JS_IMPORT_DIRECTIVE, self::GET_NON_CORE_JS_MODULE_ACTION);        }        return $result;    }    /**     * Return the base.less compiled to css     *     * @return UIAsset     */    public function getCompiledBaseCss()    {        $mergedAsset = new InMemoryUIAsset();        $assetMerger = new StylesheetUIAssetMerger($mergedAsset, $this->minimalStylesheetFetcher, $this->cacheBuster);        $assetMerger->generateFile();        return $mergedAsset;    }    /**     * Return the css merged file absolute location.     * If there is none, the generation process will be triggered.     *     * @return UIAsset     */    public function getMergedStylesheet()    {        $mergedAsset = $this->getMergedStylesheetAsset();        $assetFetcher = new StylesheetUIAssetFetcher(Manager::getInstance()->getLoadedPluginsName(), $this->theme);        $assetMerger = new StylesheetUIAssetMerger($mergedAsset, $assetFetcher, $this->cacheBuster);        $assetMerger->generateFile();        return $mergedAsset;    }    /**     * Return the core js merged file absolute location.     * If there is none, the generation process will be triggered.     *     * @return UIAsset     */    public function getMergedCoreJavaScript()    {        return $this->getMergedJavascript($this->getCoreJScriptFetcher(), $this->getMergedCoreJSAsset());    }    /**     * Return the non core js merged file absolute location.     * If there is none, the generation process will be triggered.     *     * @return UIAsset     */    public function getMergedNonCoreJavaScript()    {        return $this->getMergedJavascript($this->getNonCoreJScriptFetcher(), $this->getMergedNonCoreJSAsset());    }    /**     * @param boolean $core     * @return string[]     */    public function getLoadedPlugins($core)    {        $loadedPlugins = array();        foreach (Manager::getInstance()->getPluginsLoadedAndActivated() as $plugin) {            $pluginName = $plugin->getPluginName();            $pluginIsCore = Manager::getInstance()->isPluginBundledWithCore($pluginName);            if (($pluginIsCore && $core) || (!$pluginIsCore && !$core)) {                $loadedPlugins[] = $pluginName;            }        }        return $loadedPlugins;    }    /**     * Remove previous merged assets     */    public function removeMergedAssets($pluginName = false)    {        $assetsToRemove = array($this->getMergedStylesheetAsset());        if ($pluginName) {            if ($this->pluginContainsJScriptAssets($pluginName)) {                if (Manager::getInstance()->isPluginBundledWithCore($pluginName)) {                    $assetsToRemove[] = $this->getMergedCoreJSAsset();                } else {                    $assetsToRemove[] = $this->getMergedNonCoreJSAsset();                }            }        } else {            $assetsToRemove[] = $this->getMergedCoreJSAsset();            $assetsToRemove[] = $this->getMergedNonCoreJSAsset();        }        $this->removeAssets($assetsToRemove);    }    /**     * Check if the merged file directory exists and is writable.     *     * @return string The directory location     * @throws Exception if directory is not writable.     */    public function getAssetDirectory()    {        $mergedFileDirectory = StaticContainer::get('path.tmp') . '/assets';        if (!is_dir($mergedFileDirectory)) {            Filesystem::mkdir($mergedFileDirectory);        }        if (!is_writable($mergedFileDirectory)) {            throw new Exception(""Directory "" . $mergedFileDirectory . "" has to be writable."");        }        return $mergedFileDirectory;    }    /**     * Return the global option disable_merged_assets     *     * @return boolean     */    public function isMergedAssetsDisabled()    {        if (Config::getInstance()->Development['disable_merged_assets'] == 1) {            return true;        }                if (isset($_GET['disable_merged_assets']) && $_GET['disable_merged_assets'] == 1) {            return true;        }                return false;    }    /**     * @param UIAssetFetcher $assetFetcher     * @param UIAsset $mergedAsset     * @return UIAsset     */    private function getMergedJavascript($assetFetcher, $mergedAsset)    {        $assetMerger = new JScriptUIAssetMerger($mergedAsset, $assetFetcher, $this->cacheBuster);        $assetMerger->generateFile();        return $mergedAsset;    }    /**     * Return individual JS file inclusion directive(s) using the markup <script>     *     * @return string     */    protected function getIndividualCoreAndNonCoreJsIncludes()    {        return            $this->getIndividualJsIncludesFromAssetFetcher($this->getCoreJScriptFetcher()) .            $this->getIndividualJsIncludesFromAssetFetcher($this->getNonCoreJScriptFetcher());    }    /**     * @param UIAssetFetcher $assetFetcher     * @return string     */    protected function getIndividualJsIncludesFromAssetFetcher($assetFetcher)    {        $jsIncludeString = '';        $assets = $assetFetcher->getCatalog()->getAssets();        foreach ($assets as $jsFile) {            $jsFile->validateFile();            $jsIncludeString = $jsIncludeString . sprintf(self::JS_IMPORT_DIRECTIVE, $jsFile->getRelativeLocation());        }        return $jsIncludeString;    }    private function getCoreJScriptFetcher()    {        return new JScriptUIAssetFetcher($this->getLoadedPlugins(true), $this->theme);    }    protected function getNonCoreJScriptFetcher()    {        return new JScriptUIAssetFetcher($this->getLoadedPlugins(false), $this->theme);    }    /**     * @param string $pluginName     * @return boolean     */    private function pluginContainsJScriptAssets($pluginName)    {        $fetcher = new JScriptUIAssetFetcher(array($pluginName), $this->theme);        try {            $assets = $fetcher->getCatalog()->getAssets();        } catch (\Exception $e) {            // This can happen when a plugin is not valid (eg. Piwik 1.x format)            // When posting the event to the plugin, it returns an exception ""Plugin has not been loaded""            return false;        }        $pluginManager = Manager::getInstance();        $plugin = null;        if ($pluginManager->isPluginLoaded($pluginName)) {            $plugin = $pluginManager->getLoadedPlugin($pluginName);        }        if ($plugin && $plugin->isTheme()) {            $theme = $pluginManager->getTheme($pluginName);            $javaScriptFiles = $theme->getJavaScriptFiles();            if (!empty($javaScriptFiles)) {                $assets = array_merge($assets, $javaScriptFiles);            }        }        return !empty($assets);    }    /**     * @param UIAsset[] $uiAssets     */    public function removeAssets($uiAssets)    {        foreach ($uiAssets as $uiAsset) {            $uiAsset->delete();        }    }    /**     * @return UIAsset     */    public function getMergedStylesheetAsset()    {        return $this->getMergedUIAsset(self::MERGED_CSS_FILE);    }    /**     * @return UIAsset     */    private function getMergedCoreJSAsset()    {        return $this->getMergedUIAsset(self::MERGED_CORE_JS_FILE);    }    /**     * @return UIAsset     */    protected function getMergedNonCoreJSAsset()    {        return $this->getMergedUIAsset(self::MERGED_NON_CORE_JS_FILE);    }    /**     * @param string $fileName     * @return UIAsset     */    private function getMergedUIAsset($fileName)    {        return new OnDiskUIAsset($this->getAssetDirectory(), $fileName);    }    public static function compileCustomStylesheets($files)    {        $assetManager = new AssetManager();        $fetcher = new StaticUIAssetFetcher($files, $priorityOrder = array(), $theme = null);        $assetManager->setMinimalStylesheetFetcher($fetcher);        return $assetManager->getCompiledBaseCss()->getContent();    }    public static function compileCustomJs($files)    {        $mergedAsset = new InMemoryUIAsset();        $fetcher = new StaticUIAssetFetcher($files, $priorityOrder = array(), $theme = null);                $cacheBuster = UIAssetCacheBuster::getInstance();        $assetMerger = new JScriptUIAssetMerger($mergedAsset, $fetcher, $cacheBuster);        $assetMerger->generateFile();                return $mergedAsset->getContent();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_AssetManager_816, Return JS file inclusion directive(s) using the markup <script>\n\n @return string\n, Return JS file inclusion directive(s) using the markup <script>,"    public function getJsInclusionDirective()    {        $result = ""<script type=\""text/javascript\"">\n"" . StaticContainer::get('Piwik\Translation\Translator')->getJavascriptTranslations() . ""\n</script>"";        if ($this->isMergedAssetsDisabled()) {            $this->getMergedCoreJSAsset()->delete();            $this->getMergedNonCoreJSAsset()->delete();            $result .= $this->getIndividualCoreAndNonCoreJsIncludes();        } else {            $result .= sprintf(self::JS_IMPORT_DIRECTIVE, self::GET_CORE_JS_MODULE_ACTION);            $result .= sprintf(self::JS_IMPORT_DIRECTIVE, self::GET_NON_CORE_JS_MODULE_ACTION);        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_AssetManager_817, Return the base.less compiled to css\n\n @return UIAsset\n, Return the base.less compiled to css,"    public function getCompiledBaseCss()    {        $mergedAsset = new InMemoryUIAsset();        $assetMerger = new StylesheetUIAssetMerger($mergedAsset, $this->minimalStylesheetFetcher, $this->cacheBuster);        $assetMerger->generateFile();        return $mergedAsset;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_AuthResult_847, Returns true if this result was successfully authentication.\n\n @return bool\n, Returns true if this result was successfully authentication.,    public function wasAuthenticationSuccessful()    {        return $this->code > self::FAILURE;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_BaseFactory_849, Creates a new instance of a class using a string ID.\n\n @param string $classId The ID of the class.\n @return \\Piwik\\DataTable\\Renderer\n @throws Exception if $classId is invalid.\n, Creates a new instance of a class using a string ID.,    public static function factory($classId)    {        $className = static::getClassNameFromClassId($classId);        if (!class_exists($className)) {            self::sendPlainHeader();            throw new Exception(static::getInvalidClassIdExceptionMessage($classId));        }        return new $className;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Cache_853," This class is used to cache any data during one request. It won't be persisted between requests and it can\n cache all kind of data, even objects or resources. This cache is very fast.\n\n @return \\Matomo\\Cache\\Transient\n", This class is used to cache any data during one request. It won't be persisted between requests and it can,    public static function getTransientCache()    {        return StaticContainer::get('Matomo\Cache\Transient');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_CliMulti_122," It will request all given URLs in parallel (async) using the CLI and wait until all requests are finished.\\n If multi cli is not supported (eg windows) it will initiate an HTTP request instead (not async).\\n\\n @param string[]  $piwikUrls   An array of urls, for instance:\\n\\n                               `array('http://www.example.com/piwik?module=API...')`\\n\\n                               \\n @return array The response of each URL in the same order as the URLs. The array can contain null values in case\\n               there was a problem with a request, for instance if the process died unexpected.\\n", It will request all given URLs in parallel (async) using the CLI and wait until all requests are finished.,"    public function request(array $piwikUrls)    {        if ($this->isTimingRequests) {            foreach ($piwikUrls as $url) {                $this->timers[] = new Timer();            }        }        $chunks = array($piwikUrls);        if ($this->concurrentProcessesLimit) {            $chunks = array_chunk($piwikUrls, $this->concurrentProcessesLimit);        }        $results = array();        foreach ($chunks as $urlsChunk) {            $results = array_merge($results, $this->requestUrls($urlsChunk));        }        return $results;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_CliMulti_859," Ok, this sounds weird. Why should we care about ssl certificates when we are in CLI mode? It is needed for\n our simple fallback mode for Windows where we initiate HTTP requests instead of CLI.\n @param $acceptInvalidSSLCertificate\n"," Ok, this sounds weird. Why should we care about ssl certificates when we are in CLI mode? It is needed for",    public function setAcceptInvalidSSLCertificate($acceptInvalidSSLCertificate)    {        $this->acceptInvalidSSLCertificate = $acceptInvalidSSLCertificate;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_CliMulti_861, What is missing under windows? Detection whether a process is still running in Process::isProcessStillRunning\n and how to send a process into background in start()\n, What is missing under windows? Detection whether a process is still running in Process::isProcessStillRunning,"    public function supportsAsync()    {        $supportsAsync = Process::isSupported() && !Common::isPhpCgiType() && $this->findPhpBinary();        /**         * Triggered to allow plugins to force the usage of async cli multi execution or to disable it.         *         * **Example**         *         *     public function supportsAsync(&$supportsAsync)         *     {         *         $supportsAsync = false; // do not allow async climulti execution         *     }         *         * @param bool &$supportsAsync Whether async is supported or not.         */        Piwik::postEvent('CliMulti.supportsAsync', array(&$supportsAsync));        return $supportsAsync;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_CliMulti_862, Remove files older than one week. They should be cleaned up automatically after each request but for whatever\n reason there can be always some files left.\n, Remove files older than one week. They should be cleaned up automatically after each request but for whatever,    public static function cleanupNotRemovedFiles()    {        $timeOneWeekAgo = strtotime('-1 week');        $files = _glob(self::getTmpPath() . '/*');        if (empty($files)) {            return;        }        foreach ($files as $file) {            if (file_exists($file)) {                $timeLastModified = filemtime($file);                if ($timeLastModified !== false && $timeOneWeekAgo > $timeLastModified) {                    unlink($file);                }            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_CliMulti_864," every minute that passes adds an extra 100ms to the wait time. so 5 minutes results in 500ms extra, 20mins results in 2s extra.\n"," every minute that passes adds an extra 100ms to the wait time. so 5 minutes results in 500ms extra, 20mins results in 2s extra.",    private function getTimeToWaitBeforeNextCheck($elapsed)    {        $minutes = floor($elapsed / 60);        return self::BASE_WAIT_TIME + $minutes * 100000; // 100 * 1000 = 100ms    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Common2_135, Parses the HTML attributes given as string\\n\\n @param    string  HTML attribute string\\n @return   array   An associative aray of attributes\\n, Parses the HTML attributes given as string,"    protected static function parseAttributes($attrString)    {        $attributes = array();        if (preg_match_all(                ""/(([A-Za-z_:]|[^\\x00-\\x7F])([A-Za-z0-9_:.-]|[^\\x00-\\x7F])*)"" .                ""([ \\n\\t\\r]+)?(=([ \\n\\t\\r]+)?(\""[^\""]*\""|'[^']*'|[^ \\n\\t\\r]*))?/"",                $attrString,                $regs           )) {            for ($i = 0; $i < count($regs[1]); $i++) {                $name  = trim($regs[1][$i]);                $check = trim($regs[0][$i]);                $value = trim($regs[7][$i]);                if ($name == $check) {                    $attributes[strtolower($name)] = strtolower($name);                } else {                    if (!empty($value) && ($value[0] == '\'' || $value[0] == '""')) {                        $value = substr($value, 1, -1);                    }                    $attributes[strtolower($name)] = $value;                }            }        }        return $attributes;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Common2_136, Creates a valid attribute array from either a string or an array\\n\\n @param    mixed   Array of attributes or HTML attribute string\\n @return   array   An associative aray of attributes\\n, Creates a valid attribute array from either a string or an array,    protected static function prepareAttributes($attributes)    {        $prepared = array();        if (is_string($attributes)) {            return self::parseAttributes($attributes);        } elseif (is_array($attributes)) {            foreach ($attributes as $key => $value) {                if (is_int($key)) {                    $key = strtolower($value);                    $prepared[$key] = $key;                } else {                    $prepared[strtolower($key)] = (string)$value;                }            }        }        return $prepared;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Common2_140, Sets the attributes\\n\\n @param    mixed   Array of attribute 'name' => 'value' pairs or HTML attribute string\\n @return   HTML_Common2\\n, Sets the attributes,"    public function setAttributes($attributes)    {        $attributes = self::prepareAttributes($attributes);        $watched    = array();        foreach ($this->watchedAttributes as $watchedKey) {            if (isset($attributes[$watchedKey])) {                $this->setAttribute($watchedKey, $attributes[$watchedKey]);                unset($attributes[$watchedKey]);            } else {                $this->removeAttribute($watchedKey);            }            if (isset($this->attributes[$watchedKey])) {                $watched[$watchedKey] = $this->attributes[$watchedKey];            }        }        $this->attributes = array_merge($watched, $attributes);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Common2_142, Removes an attribute\\n\\n @param    string  Name of attribute to remove\\n @return   HTML_Common2\\n, Removes an attribute,"    public function removeAttribute($attribute)    {        if (in_array(strtolower($attribute), $this->watchedAttributes)) {            $this->onAttributeChange(strtolower($attribute), null);        } else {            self::removeAttributeArray($this->attributes, $attribute);        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Common2_145, Returns the string to indent the element\\n\\n @return   string\\n, Returns the string to indent the element,"    protected function getIndent()    {        return str_repeat(self::getOption('indent'), $this->getIndentLevel());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Common2_150," Removes the given CSS class(es) from the element\\n\\n @param    string|array    Class name, multiple class names separated by\\n                           whitespace, array of class names\\n @return   HTML_Common2\\n", Removes the given CSS class(es) from the element,"    public function removeClass($class)    {        if (!is_array($class)) {            $class = preg_split('/\s+/', $class, null, PREG_SPLIT_NO_EMPTY);        }        $curClass = array_diff(            preg_split('/\s+/', $this->getAttribute('class'),                       null, PREG_SPLIT_NO_EMPTY),            $class        );        if (0 == count($curClass)) {            $this->removeAttribute('class');        } else {            $this->setAttribute('class', implode(' ', $curClass));        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Common2_873, Creates HTML attribute string from array\n\n @param    array   Attribute array\n @return   string  Attribute string\n, Creates HTML attribute string from array,"    protected static function getAttributesString($attributes)    {        $str = '';        if (is_array($attributes)) {            $charset = self::getOption('charset');            foreach ($attributes as $key => $value) {                $str .= ' ' . $key . '=""' . htmlspecialchars($value, ENT_QUOTES, $charset) . '""';            }        }        return $str;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Common2_878, Sets the indentation level\n\n @param    int\n @return   HTML_Common2\n, Sets the indentation level,    public function setIndentLevel($level)    {        $level = intval($level);        if (0 <= $level) {            $this->_indentLevel = $level;        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_163," Appends an element to the container\\n\\n If the element was previously added to the container or to another\\n container, it is first removed there.\\n\\n @param    HTML_QuickForm2_Node     Element to add\\n @return   HTML_QuickForm2_Node     Added element\\n @throws   HTML_QuickForm2_InvalidArgumentException\\n", Appends an element to the container,    public function appendChild(HTML_QuickForm2_Node $element)    {        if ($this === $element->getContainer()) {            $this->removeChild($element);        }        $element->setContainer($this);        $this->elements[] = $element;        return $element;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_164," Removes the element from this container\\n\\n If the reference object is not given, the element will be appended.\\n\\n @param    HTML_QuickForm2_Node     Element to remove\\n @return   HTML_QuickForm2_Node     Removed object\\n", Removes the element from this container,"    public function removeChild(HTML_QuickForm2_Node $element)    {        if ($element->getContainer() !== $this) {            throw new HTML_QuickForm2_NotFoundException(                ""Element with name '"".$element->getName().""' was not found""            );        }        foreach ($this as $key => $child){            if ($child === $element) {                unset($this->elements[$key]);                $element->setContainer(null);                break;            }        }        return $element;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_169," Called when the element needs to update its value from form's data sources\\n\\n The default behaviour is just to call the updateValue() methods of\\n contained elements, since default Container doesn't have any value itself\\n", Called when the element needs to update its value from form's data sources,    public function updateValue()    {        foreach ($this as $child) {            $child->updateValue();        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_170, Performs the server-side validation\\n\\n This method also calls validate() on all contained elements.\\n\\n @return   boolean Whether the container and all contained elements are valid\\n, Performs the server-side validation,    protected function validate()    {        $valid = parent::validate();        foreach ($this as $child) {            $valid = $child->validate() && $valid;        }        return $valid;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_896," Merges two arrays\n\n Merges two arrays like the PHP function array_merge_recursive does,\n the difference being that existing integer keys will not be renumbered.\n\n @param    array\n @param    array\n @return   array   resulting array\n", Merges two arrays,"    protected static function arrayMerge($a, $b)    {        foreach ($b as $k => $v) {            if (!is_array($v) || isset($a[$k]) && !is_array($a[$k])) {                $a[$k] = $v;            } else {                $a[$k] = self::arrayMerge(isset($a[$k])? $a[$k]: array(), $v);            }        }        return $a;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_897, Returns an array of this container's elements\n\n @return   array   Container elements\n, Returns an array of this container's elements,    public function getElements()    {        return $this->elements;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_902, Returns a recursive iterator for the container elements\n\n @return    HTML_QuickForm2_ContainerIterator\n, Returns a recursive iterator for the container elements,    public function getIterator()    {        return new HTML_QuickForm2_ContainerIterator($this);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_181, Returns the session container with the controller data\\n\\n @return   HTML_QuickForm2_Controller_SessionContainer\\n, Returns the session container with the controller data,    public function getSessionContainer()    {        if (empty($this->sessionContainer)) {            $this->sessionContainer = new HTML_QuickForm2_Controller_SessionContainer($this);        }        return $this->sessionContainer;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_185, Adds a handler for a specific action\\n\\n @param  string                            action name\\n @param  HTML_QuickForm2_Controller_Action the handler for the action\\n, Adds a handler for a specific action,"    public function addHandler($actionName, HTML_QuickForm2_Controller_Action $action)    {        $this->handlers[$actionName] = $action;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_187, Adds a new page to the form\\n\\n @param    HTML_QuickForm2_Controller_Page\\n, Adds a new page to the form,"    public function addPage(HTML_QuickForm2_Controller_Page $page)    {        $pageId = $page->getForm()->getId();        if (!empty($this->pages[$pageId])) {            throw new HTML_QuickForm2_InvalidArgumentException(                ""Duplicate page ID '{$pageId}'""            );        }        $page->setController($this);        $this->pages[$pageId] = $page;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_190, Returns the page following the given one\\n\\n @param    HTML_QuickForm2_Controller_Page\\n @return   HTML_QuickForm2_Controller_Page|null\\n, Returns the page following the given one,    public function nextPage(HTML_QuickForm2_Controller_Page $reference)    {        $previous = null;        foreach ($this->pages as $page) {            if ($previous === $reference) {                return $page;            }            $previous = $page;        }        return null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_191, Returns the first page that failed validation\\n\\n @return   HTML_QuickForm2_Controller_Page|null\\n, Returns the first page that failed validation,    public function getFirstInvalidPage()    {        foreach ($this->pages as $id => $page) {            if (!$this->getSessionContainer()->getValidationStatus($id)) {                return $page;            }        }        return null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_915, Returns whether to send form id with GET and POST parameters\n\n @return   boolean\n, Returns whether to send form id with GET and POST parameters,    public function propagateId()    {        return $this->propagate;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_918," Extracts the name of the page and the action to perform with it from HTTP request data\n\n @return array     first element is page name, second is action name\n", Extracts the name of the page and the action to perform with it from HTTP request data,"    public function getActionName()    {        if (is_array($this->actionName)) {            return $this->actionName;        }        if (empty($this->pages)) {            throw new HTML_QuickForm2_NotFoundException('No pages added to the form');        }        $names = array_map('preg_quote', array_keys($this->pages));        $regex = '/^_qf_(' . implode('|', $names) . ')_(.+?)(_x)?$/';        foreach (array_keys($_REQUEST) as $key) {            if (preg_match($regex, $key, $matches)) {                $this->actionName = array($matches[1], $matches[2]);                break;            }        }        if (!is_array($this->actionName)) {            reset($this->pages);            $this->actionName = array(key($this->pages), 'display');        }        return $this->actionName;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_919," Processes the request\n\n This finds the page, the action to perform with it and passes the action\n to the page's handle() method.\n\n @throws HTML_QuickForm2_Exception\n", Processes the request,"    public function run()    {        list($page, $action) = $this->getActionName();        return $this->pages[$page]->handle($action);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_923, Returns a page\n\n @param  string    Page ID\n @return HTML_QuickForm2_Controller_Page\n @throws HTML_QuickForm2_NotFoundException if there is no page with\n           the given ID\n, Returns a page,"    public function getPage($pageId)    {        if (!empty($this->pages[$pageId])) {            return $this->pages[$pageId];        } else {            throw new HTML_QuickForm2_NotFoundException(                ""Unknown page '{$pageId}'""            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_924, Returns the page preceding the given one\n\n @param    HTML_QuickForm2_Controller_Page\n @return   HTML_QuickForm2_Controller_Page|null\n, Returns the page preceding the given one,    public function previousPage(HTML_QuickForm2_Controller_Page $reference)    {        $previous = null;        foreach ($this->pages as $page) {            if ($page === $reference) {                return $previous;            }            $previous = $page;        }        return null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_928, Returns the form's values\n\n @return   array\n, Returns the form's values,"    public function getValue()    {        $values = array();        foreach (array_keys($this->pages) as $id) {            $pageValues = $this->getSessionContainer()->getValues($id);            // skip elements representing actions            foreach ($pageValues as $key => $value) {                if (0 !== strpos($key, '_qf')) {                    if (isset($values[$key]) && is_array($value)) {                        $values[$key] = self::arrayMerge($values[$key], $value);                    } else {                        $values[$key] = $value;                    }                }            }        }        return $values;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_930, Returns an Iterator for the form's pages\n\n @return   ArrayIterator\n, Returns an Iterator for the form's pages,    public function getIterator()    {        return new ArrayIterator($this->pages);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_DataComparisonFilter_994, add comparison parameters as metadata\n, add comparison parameters as metadata,"        $table->filter(function (DataTable $singleTable) use ($comparisonSeries) {            if (isset($this->compareSegments)) {                $singleTable->setMetadata('compareSegments', $this->compareSegments);            }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_DataComparisonFilter_996, Returns the pretty series label for a specific comparison based on the currently set comparison query parameters.\n\n @param int $labelSeriesIndex The index of the comparison. Comparison series order is determined by {@see self::getReportsToCompare()}.\n, Returns the pretty series label for a specific comparison based on the currently set comparison query parameters.,"    public static function getPrettyComparisonLabelFromSeriesIndex($labelSeriesIndex)    {        $compareSegments = self::getCompareSegments();        $comparePeriods = self::getComparePeriods();        $compareDates = self::getCompareDates();        list($periodIndex, $segmentIndex) = self::getIndividualComparisonRowIndices(null, $labelSeriesIndex, count($compareSegments));        $segmentObj = new Segment($compareSegments[$segmentIndex], []);        $prettySegment = $segmentObj->getStoredSegmentName(false);        $prettyPeriod = Factory::build($comparePeriods[$periodIndex], $compareDates[$periodIndex])->getLocalizedLongString();        $prettyPeriod = ucfirst($prettyPeriod);        return self::getComparisonSeriesLabelSuffixFromParts($prettyPeriod, $prettySegment);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Element_200, Renders the element using the given renderer\\n\\n @param    HTML_QuickForm2_Renderer    Renderer instance\\n @return   HTML_QuickForm2_Renderer\\n, Renders the element using the given renderer,    public function render(HTML_QuickForm2_Renderer $renderer)    {        foreach ($this->rules as $rule) {            if ($rule[1] & HTML_QuickForm2_Rule::RUNAT_CLIENT) {                $renderer->getJavascriptBuilder()->addRule($rule[0]);            }        }        $renderer->renderElement($this);        return $renderer;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Element_933, Generates hidden form field containing the element's value\n\n This is used to pass the frozen element's value if 'persistent freeze'\n feature is on\n\n @return string\n, Generates hidden form field containing the element's value,"    protected function getPersistentContent()    {        if (!$this->persistent || null === ($value = $this->getValue())) {            return '';        }        return '<input type=""hidden""' . self::getAttributesString(array(            'name'  => $this->getName(),            'value' => $value,            'id'    => $this->getId()        )) . ' />';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Exception_203," Exception that denotes some resource was not found\\n\\n One example is trying to instantiate a nonexistent class in Factory\\n <code>\\n try {\\n     HTML_QuickForm2_Factory::registerElement(\\\'missing\\\', \\\'NonExistent\\\');\\n     $el = HTML_QuickForm2_Factory::createElement(\\\'missing\\\');\\n } catch (HTML_QuickForm2_NotFoundException $e) {\\n     echo $e->getMessage();\\n }\\n </code>\\n This code fill output ""Class \\\'NonExistent\\\' does not exist and no file to load""\\n\\n @category   HTML\\n @package    HTML_QuickForm2\\n @version    Release: @package_version@\\n", Exception that denotes some resource was not found,class HTML_QuickForm2_NotFoundException extends HTML_QuickForm2_Exception{},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Factory_205, Static factory class\\n\\n The class handles instantiation of Element and Rule objects as well as\\n registering of new Element and Rule classes.\\n\\n @category   HTML\\n @package    HTML_QuickForm2\\n @author     Alexey Borzov <avb@php.net>\\n @author     Bertrand Mansion <golgote@mamasam.com>\\n @version    Release: @package_version@\\n, Static factory class,"class HTML_QuickForm2_Factory{   /**    * List of element types known to Factory    * @var array    */    protected static $elementTypes = array(        'button'        => array('HTML_QuickForm2_Element_Button', null),        'checkbox'      => array('HTML_QuickForm2_Element_InputCheckbox', null),        'date'          => array('HTML_QuickForm2_Element_Date', null),        'fieldset'      => array('HTML_QuickForm2_Container_Fieldset', null),        'group'         => array('HTML_QuickForm2_Container_Group', null),        'file'          => array('HTML_QuickForm2_Element_InputFile', null),        'hidden'        => array('HTML_QuickForm2_Element_InputHidden', null),        'image'         => array('HTML_QuickForm2_Element_InputImage', null),        'inputbutton'   => array('HTML_QuickForm2_Element_InputButton', null),        'password'      => array('HTML_QuickForm2_Element_InputPassword', null),        'radio'         => array('HTML_QuickForm2_Element_InputRadio', null),        'reset'         => array('HTML_QuickForm2_Element_InputReset', null),        'select'        => array('HTML_QuickForm2_Element_Select', null),        'submit'        => array('HTML_QuickForm2_Element_InputSubmit', null),        'text'          => array('HTML_QuickForm2_Element_InputText', null),        'textarea'      => array('HTML_QuickForm2_Element_Textarea', null)    );   /**    * List of registered rules    * @var array    */    protected static $registeredRules = array(        'nonempty'      => array('HTML_QuickForm2_Rule_Nonempty', null),        'empty'         => array('HTML_QuickForm2_Rule_Empty', null),        'required'      => array('HTML_QuickForm2_Rule_Required', null),        'compare'       => array('HTML_QuickForm2_Rule_Compare', null),        'eq'            => array('HTML_QuickForm2_Rule_Compare', null,                                 array('operator' => '===')),        'neq'           => array('HTML_QuickForm2_Rule_Compare', null,                                 array('operator' => '!==')),        'lt'            => array('HTML_QuickForm2_Rule_Compare', null,                                 array('operator' => '<')),        'lte'           => array('HTML_QuickForm2_Rule_Compare', null,                                 array('operator' => '<=')),        'gt'            => array('HTML_QuickForm2_Rule_Compare', null,                                 array('operator' => '>')),        'gte'           => array('HTML_QuickForm2_Rule_Compare', null,                                 array('operator' => '>=')),        'regex'         => array('HTML_QuickForm2_Rule_Regex', null),        'callback'      => array('HTML_QuickForm2_Rule_Callback', null),        'length'        => array('HTML_QuickForm2_Rule_Length', null),        'minlength'     => array('HTML_QuickForm2_Rule_Length', null,                                 array('max' => 0)),        'maxlength'     => array('HTML_QuickForm2_Rule_Length', null,                                 array('min' => 0)),        'maxfilesize'   => array('HTML_QuickForm2_Rule_MaxFileSize', null),        'mimetype'      => array('HTML_QuickForm2_Rule_MimeType', null),        'each'          => array('HTML_QuickForm2_Rule_Each', null),        'notcallback'   => array('HTML_QuickForm2_Rule_NotCallback', null),        'notregex'      => array('HTML_QuickForm2_Rule_NotRegex', null)    );   /**    * Registers a new element type    *    * @param    string  Type name (treated case-insensitively)    * @param    string  Class name    * @param    string  File containing the class, leave empty if class already loaded    */    public static function registerElement($type, $className, $includeFile = null)    {        self::$elementTypes[strtolower($type)] = array($className, $includeFile);    }   /**    * Checks whether an element type is known to factory    *    * @param    string  Type name (treated case-insensitively)    * @return   bool    */    public static function isElementRegistered($type)    {        return isset(self::$elementTypes[strtolower($type)]);    }   /**    * Creates a new element object of the given type    *    * @param    string  Type name (treated case-insensitively)    * @param    mixed   Element name (passed to element's constructor)    * @param    mixed   Element attributes (passed to element's constructor)    * @param    array   Element-specific data (passed to element's constructor)    * @return   HTML_QuickForm2_Node     A created element    * @throws   HTML_QuickForm2_InvalidArgumentException If type name is unknown    * @throws   HTML_QuickForm2_NotFoundException If class for the element can    *           not be found and/or loaded from file    */    public static function createElement($type, $name = null, $attributes = null,                                         array $data = array())    {        $type = strtolower($type);        if (!isset(self::$elementTypes[$type])) {            throw new HTML_QuickForm2_InvalidArgumentException(""Element type '$type' is not known"");        }        list($className, $includeFile) = self::$elementTypes[$type];        if (!class_exists($className)) {            HTML_QuickForm2_Loader::loadClass($className, $includeFile);        }        return new $className($name, $attributes, $data);    }   /**    * Registers a new rule type    *    * @param    string  Rule type name (treated case-insensitively)    * @param    string  Class name    * @param    string  File containing the class, leave empty if class already loaded    * @param    mixed   Configuration data for rules of the given type    */    public static function registerRule($type, $className, $includeFile = null,                                        $config = null)    {        self::$registeredRules[strtolower($type)] = array($className, $includeFile, $config);    }   /**    * Checks whether a rule type is known to Factory    *    * @param    string  Rule type name (treated case-insensitively)    * @return   bool    */    public static function isRuleRegistered($type)    {        return isset(self::$registeredRules[strtolower($type)]);    }   /**    * Creates a new Rule of the given type    *    * @param    string                  Rule type name (treated case-insensitively)    * @param    HTML_QuickForm2_Node    Element to validate by the rule    * @param    string                  Message to display if validation fails    * @param    mixed                   Configuration data for the rule    * @return   HTML_QuickForm2_Rule    A created Rule    * @throws   HTML_QuickForm2_InvalidArgumentException If rule type is unknown    * @throws   HTML_QuickForm2_NotFoundException        If class for the rule    *           can't be found and/or loaded from file    */    public static function createRule($type, HTML_QuickForm2_Node $owner,                                      $message = '', $config = null)    {        $type = strtolower($type);        if (!isset(self::$registeredRules[$type])) {            throw new HTML_QuickForm2_InvalidArgumentException(""Rule '$type' is not known"");        }        list($className, $includeFile) = self::$registeredRules[$type];        if (!class_exists($className)) {            HTML_QuickForm2_Loader::loadClass($className, $includeFile);        }        if (isset(self::$registeredRules[$type][2])) {            $config = call_user_func(array($className, 'mergeConfig'), $config,                                     self::$registeredRules[$type][2]);        }        return new $className($owner, $message, $config);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Factory_207, Checks whether a rule type is known to Factory\\n\\n @param    string  Rule type name (treated case-insensitively)\\n @return   bool\\n, Checks whether a rule type is known to Factory,    public static function isRuleRegistered($type)    {        return isset(self::$registeredRules[strtolower($type)]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Factory_208, Creates a new Rule of the given type\\n\\n @param    string                  Rule type name (treated case-insensitively)\\n @param    HTML_QuickForm2_Node    Element to validate by the rule\\n @param    string                  Message to display if validation fails\\n @param    mixed                   Configuration data for the rule\\n @return   HTML_QuickForm2_Rule    A created Rule\\n @throws   HTML_QuickForm2_InvalidArgumentException If rule type is unknown\\n @throws   HTML_QuickForm2_NotFoundException        If class for the rule\\n           can't be found and/or loaded from file\\n, Creates a new Rule of the given type,"    public static function createRule($type, HTML_QuickForm2_Node $owner,",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_FewVisitsWithSetVisitorId_264, Adds one site and tracks a couple visits using a custom visitor ID.\\n, Adds one site and tracks a couple visits using a custom visitor ID.,"class FewVisitsWithSetVisitorId extends Fixture{    public $idSite = 1;    public $idGoal = 1;    public $dateTime = '2010-03-06 11:22:33';    const USER_ID_EXAMPLE_COM = 'email@example.com';    public function setUp(): void    {        $this->setUpWebsitesAndGoals();        $this->trackVisits_setVisitorId();        $this->trackVisits_setUserId();        // generate data for the period = week, month, year use cases        $this->trackVisits_oneWeekLater_setUserId();    }    public function tearDown(): void    {        // empty    }    private function setUpWebsitesAndGoals()    {        // tests run in UTC, the Tracker in UTC        if (!self::siteCreated($this->idSite)) {            self::createWebsite($this->dateTime);        }        if (!self::goalExists($this->idSite, $this->idGoal)) {            API::getInstance()->addGoal($this->idSite, 'triggered js', 'manually', '', '');        }    }    private function trackVisits_setVisitorId()    {        // total = 2 visitors, 3 page views        $t = self::getTracker($this->idSite, $this->dateTime, $defaultInit = true);        // First, some basic tests        $this->settingInvalidVisitorIdShouldThrow($t);        // We create VISITOR A        $t->setUrl('http://example.org/index.htm');        $t->setVisitorId('a13b7c5a62f72dea');        self::checkResponse($t->doTrackPageView('incredible title!'));        // VISITOR B: few minutes later, we trigger the same tracker but with a custom visitor ID,        // => this will create a new visit B        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(0.05)->getDatetime());        $t->setUrl('http://example.org/index2.htm');        $t->setVisitorId('f66bc315f2a01a79');        self::checkResponse($t->doTrackPageView('incredible title!'));        // This new visit B will have 2 page views        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(0.1)->getDatetime());        $t->setUrl('http://example.org/index3.htm');        self::checkResponse($t->doTrackPageView('incredible title!'));    }    private function trackVisits_setUserId()    {        $userId = self::USER_ID_EXAMPLE_COM;        // total = 2 visitors, 3 page views        $t = self::getTracker($this->idSite, $this->dateTime, $defaultInit = true);        // First, some basic tests        $this->settingInvalidUserIdShouldThrow($t);        // We create a visit with no User ID.        // When User ID  will be set below, then it will UPDATE this visit here that starts without UserID        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(1.9)->getDatetime());        $t->setVisitorId('6be121d126d93581');        $t->setUrl('http://example.org/no-user-id-set-but-should-appear-in-user-id-visit');        self::checkResponse($t->doTrackPageView('no User Id set but it should appear in '. $userId .'!'));        // A NEW VISIT        // Setting both Visitor ID and User ID        // -> User ID takes precedence        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(2)->getDatetime());        $t->setUrl('http://example.org/index.htm');        // Set Visitor ID first.        $generatedVisitorId = '6ccebef4faef4969';        $t->setVisitorId($generatedVisitorId);        $this->assertEquals($generatedVisitorId, $t->getVisitorId());        // Set User ID        $t->setUserId($userId);        // User ID does not take precedence over any previously set Visitor ID        $this->assertEquals($generatedVisitorId, $t->getVisitorId());        $this->assertEquals($userId, $t->getUserId());        // Track a pageview with this user id        self::checkResponse($t->doTrackPageView('incredible title!'));        // Track another pageview        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(2.1)->getDatetime());        $this->assertEquals($userId, $t->getUserId());        self::checkResponse($t->doTrackPageView('second page'));        // A NEW VISIT WITH A SET USER ID        // Change User ID -> This will create a new visit        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(2.2)->getDatetime());        $t->setVisitorId('2f16b4d842cc294d');        $secondUserId = 'new-email@example.com';        $t->setUserId($secondUserId);        self::checkResponse($t->doTrackPageView('a new user id was set -> new visit'));        // A NEW VISIT BY THE SAME USER        // Few hours later, the same user ID comes in from a different place and computer        $t = self::getTracker($this->idSite, $this->dateTime, $defaultInit = true);        $t->setVisitorId('7dcebef4faef4969'); // set manually so tests are not random        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(5)->getDatetime());        // Make sure the computer and IP look really different from previous visit        $t->setIp('67.51.31.21');        $t->setUserAgent(""Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729)"");        $t->setBrowserLanguage('fr');        $t->setUserId($secondUserId);        $t->setUrl('http://example.org/home');        self::checkResponse($t->doTrackPageView('same user id was set -> this is the same unique user'));        // Do not pass User ID in this request, it should still attribute to previous visit        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(5.1)->getDatetime());        self::checkResponse($t->doTrackPageView('second pageview - by this user id'));        // Request from a different computer not yet logged in, this should not be added to our User ID session        $t->setUserId(false);        // make sure the Id is not so random as to not fail the test        $t->setVisitorId('5e15b4d842cc294d');        $t->setIp('1.2.4.7');        $t->setUserAgent(""New unique device"");        self::checkResponse($t->doTrackPageView('pageview - should not be tracked by our user id but in a new visit'));        // User has now logged in so we measure her interactions to her User ID        $t->setUserId($secondUserId);        // Trigger a goal conversion        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(5.2)->getDatetime());        self::checkResponse($t->doTrackGoal(1));        // An ecommerce add to cart        // (helpful to test that &segment=userId==x will return all items purchased by a specific user ID        $t->setForceVisitDateTime(Date::factory($this->dateTime)->addHour(5.3)->getDatetime());        $t->setUrl('http://nsa.gov/buy/prism');        $t->addEcommerceItem('sku-007-PRISM', 'My secret spy tech', 'Surveillance', '10000000000');        $t->doTrackEcommerceCartUpdate(10000000000 + 500 /* add some for shipping PRISM */);    }    private function trackVisits_oneWeekLater_setUserId()    {        $oneWeekLater = Date::factory($this->dateTime)->addDay(8);        // Set User ID to a known user id        $t = self::getTracker($this->idSite, $this->dateTime, $defaultInit = true);        $t->setVisitorId('7dcebef4faef4325'); // set manually so tests are not random        $t->setForceVisitDateTime($oneWeekLater->getDatetime());        $t->setUrl('http://example.org/index.htm');        $t->setUserId(self::USER_ID_EXAMPLE_COM);        self::checkResponse($t->doTrackPageView('Page view by ' . self::USER_ID_EXAMPLE_COM));        // Set a new User ID not set before        $t->setForceVisitDateTime($oneWeekLater->addHour(0.4)->getDatetime());        $t->setUrl('http://example.org/index.htm');        $userId = 'new-user-id@one-weeklater';        $t->setUserId($userId);        $t->setVisitorId('6ccebef4faef4969'); // this should not be ignored        self::checkResponse($t->doTrackPageView('A page view by ' . $userId));        $t->setForceVisitDateTime($oneWeekLater->addHour(0.8)->getDatetime());    }    private function settingInvalidVisitorIdShouldThrow(MatomoTracker $t)    {        try {            $t->setVisitorId('test');            $this->fail('should throw');        } catch (Exception $e) {            //OK        }        try {            $t->setVisitorId('61e8');            $this->fail('should throw');        } catch (Exception $e) {            //OK        }        try {            $t->setVisitorId('61e8cc2d51fea26dabcabcabc');            $this->fail('should throw');        } catch (Exception $e) {            //OK        }    }    private function settingInvalidUserIdShouldThrow(MatomoTracker $t)    {        try {            $t->setUserId('');            $this->fail('should throw');        } catch (Exception $e) {            //OK        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_InvalidVisits_1000, Adds one site and sends several invalid tracking requests. The result should be\n one website with no visits.\n, Adds one site and sends several invalid tracking requests. The result should be,"class InvalidVisits extends Fixture{    public $idSite = 1;    public $dateTime = '2009-01-04 00:11:42';    public $trackInvalidRequests = true;    public function setUp(): void    {        $this->setUpWebsitesAndGoals();        $this->trackVisits();    }    public function tearDown(): void    {        // empty    }    private function setUpWebsitesAndGoals()    {        if (!self::siteCreated($idSite = 1)) {            self::createWebsite($this->dateTime);        }    }    private function trackVisits()    {        if (!$this->trackInvalidRequests) {            return;        }        $dateTime = $this->dateTime;        $idSite = $this->idSite;        API::getInstance()->setGlobalExcludedUserAgents('globalexcludeduseragent');        Cache::regenerateCacheWebsiteAttributes([1]);        // Trigger empty request        $trackerUrl = self::getTrackerUrl();        $response = Http::fetchRemoteFile($trackerUrl);        self::assertTrue(strpos($response, 'Keep full control of your data with the leading free') !== false, 'Piwik empty request response not correct: ' . $response);        $t = self::getTracker($idSite, $dateTime, $defaultInit = true);        // test GoogleBot UA visitor        $t->setUserAgent('Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)');        self::checkResponse($t->doTrackPageView('bot visit, please do not record'));        // Test IP Exclusion works with or without IP exclusion        foreach (array(false, true) as $enable) {            $excludedIp = '154.1.12.34';            API::getInstance()->updateSite($idSite, 'new site name', $url = array('http://site.com'), $ecommerce = 0, $ss = 1, $ss_kwd = '', $ss_cat = '', $excludedIp . ',1.2.3.4', $excludedQueryParameters = null, $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = 'excludeduseragentstring');            Cache::regenerateCacheWebsiteAttributes([1]);            // Enable IP Anonymization            $t->DEBUG_APPEND_URL = '&forceIpAnonymization=' . (int)$enable;            // test with excluded User Agent            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729) (excludeduseragentstring)');            $t->setIp('211.1.2.3');            self::checkResponse($t->doTrackPageView('visit from excluded User Agent'));            $t->setUserAgent('Mozilla/5.0 (Windows NT 6.1; rv:6.0) Gecko/20110814 Firefox/6.0 Google (+https://developers.google.com/+/web/snippet/)');            self::checkResponse($t->doTrackPageView('visit from excluded User Agent'));            // test w/ global excluded User Agent            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729) (globalexcludeduseragent)');            $t->setIp('211.1.2.3');            self::checkResponse($t->doTrackPageView('visit from global excluded User Agent'));            // test with excluded IP            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729)'); // restore normal user agent            $t->setIp($excludedIp);            self::checkResponse($t->doTrackPageView('visit from IP excluded'));            // test with global list of excluded IPs            $excludedIpBis = '145.5.3.4';            API::getInstance()->setGlobalExcludedIps($excludedIpBis);            Cache::regenerateCacheWebsiteAttributes([1]);            $t->setIp($excludedIpBis);            self::checkResponse($t->doTrackPageView('visit from IP globally excluded'));        }        // test unknown url exclusion works        $urls = array(""http://piwik.net"", ""http://my.stuff.com/"");        API::getInstance()->updateSite($idSite, $siteName = null, $urls, $ecommerce = null, $siteSearch = null,            $searchKeywordParameters = null, $searchCategoryParameters = null, $excludedIps = null, $excludedQueryParams = null,            $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = null,            $keepUrlFragments = null, $type = null, $settings = null, $excludeUnknownUrls = 1);        Cache::regenerateCacheWebsiteAttributes([1]);        $t->setIp(""125.4.5.6"");        $t->setUrl(""http://piwik.com/to/the/moon"");        $t->doTrackPageView(""ignored, not from piwik.net"");        $t->setUrl(""http://their.stuff.com/back/to/the/future"");        $t->doTrackPageView(""ignored, not from my.stuff.com"");        // undo exclude unknown urls change (important when multiple fixtures are setup together, as is done in OmniFixture)        API::getInstance()->updateSite($idSite, $siteName = null, $urls, $ecommerce = null, $siteSearch = null,            $searchKeywordParameters = null, $searchCategoryParameters = null, $excludedIps = null, $excludedQueryParams = null,            $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = null,            $keepUrlFragments = null, $type = null, $settings = null, $excludeUnknownUrls = 0);        Cache::regenerateCacheWebsiteAttributes([1]);        try {            @$t->setAttributionInfo(array());            self::fail();        } catch (Exception $e) {        }        try {            $t->setAttributionInfo(json_encode('test'));            self::fail();        } catch (Exception $e) {        }        $t->setAttributionInfo(json_encode(array()));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_JavascriptBuilder_944, Javascript aggregator and builder class\n\n @category   HTML\n @package    HTML_QuickForm2\n @author     Alexey Borzov <avb@php.net>\n @author     Bertrand Mansion <golgote@mamasam.com>\n @version    Release: @package_version@\n, Javascript aggregator and builder class,"class HTML_QuickForm2_JavascriptBuilder{   /**    * Client-side rules    * @var array    */    protected $rules = array();   /**    * Current form ID    * @var string    */    protected $formId = null;   /**    * Sets the form currently being processed    *    * @param HTML_QuickForm2    */    public function startForm(HTML_QuickForm2 $form)    {        $this->formId = $form->getId();        $this->rules[$this->formId] = array();    }   /**    * Adds the Rule javascript to the list of current form Rules    *    * @param HTML_QuickForm2_Rule    */    public function addRule(HTML_QuickForm2_Rule $rule)    {        $this->rules[$this->formId][] = $rule->getJavascript();    }   /**    * Returns client-side validation code    *    * @todo This shouldn't probably be __toString() as we can't throw exceptions from that    * @todo Of course we shouldn't put library files into each page, need some means to include them via <script> tags    */    public function __toString()    {        $js = '';        foreach ($this->rules as $formId => $rules) {            if (!empty($rules)) {                $js .= ""new qf.validator(document.getElementById('{$formId}'), [\n"" .                       implode("",\n"", $rules) .                       ""\n]);"";            }        }        if ('' != $js) {            $js = ""<script type=\""text/javascript\"">\n//<![CDATA[\n"" .                  file_get_contents('@data_dir@/HTML_QuickForm2/quickform.js') .                  ""qf.events.contentReady(function() {\n{$js}\n});\n"" .                  ""//]]>\n</script>"";        }        return $js;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_LocalTracker_262, Tracker that uses core/Tracker.php directly.\\n, Tracker that uses core/Tracker.php directly.,"class Matomo_LocalTracker extends MatomoTracker{    protected function sendRequest($url, $method = 'GET', $data = null, $force = false)    {        self::$DEBUG_LAST_REQUESTED_URL = $url;        if ($this->DEBUG_APPEND_URL) {            $url .= $this->DEBUG_APPEND_URL;        }        // if doing a bulk request, store the url        if ($this->doBulkRequests && !$force) {            $this->storedTrackingActions[] = $url;            return true;        }        if ($method == 'POST') {            $requests = array();            foreach ($this->storedTrackingActions as $action) {                $requests[] = $this->parseUrl($action);            }            $testEnvironmentArgs = array();        } else {            $testEnvironmentArgs = $this->parseUrl($url);            if (!empty($this->token_auth)) {                $testEnvironmentArgs['token_auth'] = $this->token_auth;            }            $requests = array($testEnvironmentArgs);        }        // unset cached values        Cache::$cache = null;        Tracker\Visit::$dimensions = null;        // save some values        $plugins = Config::getInstance()->Plugins['Plugins'];        $oldTrackerConfig = Config::getInstance()->Tracker;        \Piwik\Plugin\Manager::getInstance()->unloadPlugins();        // modify config        \Piwik\SettingsServer::setIsTrackerApiRequest();        $GLOBALS['PIWIK_TRACKER_LOCAL_TRACKING'] = true;        Tracker::$initTrackerMode = false;        Tracker::setTestEnvironment($testEnvironmentArgs, $method);        // set language        $oldLang = isset($_SERVER['HTTP_ACCEPT_LANGUAGE']) ? $_SERVER['HTTP_ACCEPT_LANGUAGE'] : '';        $_SERVER['HTTP_ACCEPT_LANGUAGE'] = $this->acceptLanguage;        // set user agent        $oldUserAgent = isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '';        $_SERVER['HTTP_USER_AGENT'] = $this->userAgent;        // set cookie        $oldCookie = $_COOKIE;//        parse_str(parse_url($this->requestCookie, PHP_URL_QUERY), $_COOKIE);        // do tracking and capture output        ob_start();        $localTracker = new Tracker();        $request = new Tracker\RequestSet();        $request->setRequests($requests);        \Piwik\Plugin\Manager::getInstance()->loadTrackerPlugins();        $handler = Tracker\Handler\Factory::make();        $response = $localTracker->main($handler, $request);        if (!is_null($response)) {            echo $response;        }        $output = ob_get_contents();        ob_end_clean();        // restore vars        Config::getInstance()->Tracker = $oldTrackerConfig;        $_SERVER['HTTP_ACCEPT_LANGUAGE'] = $oldLang;        $_SERVER['HTTP_USER_AGENT'] = $oldUserAgent;        $_COOKIE = $oldCookie;        $GLOBALS['PIWIK_TRACKER_LOCAL_TRACKING'] = false;        \Piwik\SettingsServer::setIsNotTrackerApiRequest();        unset($_GET['bots']);        // reload plugins        \Piwik\Plugin\Manager::getInstance()->loadPlugins($plugins);        return $output;    }    private function parseUrl($url)    {        // parse url        $query = parse_url($url, PHP_URL_QUERY);        if ($query === false) {            return;        }        parse_str($query, $args);        // make sure bots is set if needed        if (isset($args['bots'])) {            $_GET['bots'] = true;        }        return $args;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ManySitesImportedLogs_1002," Logs a couple visits for Aug 9, Aug 10, Aug 11 of 2012, for site we create.\n"," Logs a couple visits for Aug 9, Aug 10, Aug 11 of 2012, for site we create.","    private function logVisitsWithStaticResolver()    {        $logFile = PIWIK_INCLUDE_PATH . '/tests/resources/access-logs/fake_logs.log'; # log file        // We do not pass the ""--token_auth"" parameter here to make sure import_logs.py finds the auth_token        // automatically if needed        $opts = array('--idsite'                    => $this->idSite,                      '--enable-testmode'           => false,                      '--recorders'                 => '1',                      '--recorder-max-payload-size' => '1');        self::executeLogImporter($logFile, $opts);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ManySitesImportedLogs_268, Logs a couple visits for the site we created w/ all log importer options\\n enabled. Visits are for Aug 11 of 2012.\\n, Logs a couple visits for the site we created w/ all log importer options,"    private function logVisitsWithAllEnabled()    {        $logFile = PIWIK_INCLUDE_PATH . '/tests/resources/access-logs/fake_logs_enable_all.log';        $opts = array('--idsite'                    => $this->idSite,                      '--token-auth'                => self::getTokenAuth(),                      '--recorders'                 => '1',                      '--recorder-max-payload-size' => '1',                      '--enable-static'             => false,                      '--enable-bots'               => false,                      '--enable-http-errors'        => false,                      '--enable-http-redirects'     => false,                      '--enable-reverse-dns'        => false,                      '--force-lowercase-path'      => false,                      '--tracker-endpoint-path'     => '/matomo.php');        self::executeLogImporter($logFile, $opts);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ManyVisitsWithGeoIP_1007," Insert a new visit into the database.\n @param \\MatomoTracker $t          The tracker to record the visits on\n @param int $fixtureCounter       Number of times this fixture has been run \n @param int $visitorCounter       Visitor counter within this execution of the fixture\n @param boolean $doBulk           Should this visit be left for bulk insert later, or processed now?\n @param array $params             Other params as required to set up the visit\n", Insert a new visit into the database.,"    protected function trackVisit(\MatomoTracker $t, $fixtureCounter, $visitorCounter, $doBulk, array $params)    {        $setIp = isset($params['setIp']) && $params['setIp'];        // NOTE: floor() is so some visits share the same visit ID        $t->setVisitorId( substr(md5(floor($visitorCounter / 2) + $fixtureCounter * 1000), 0, $t::LENGTH_VISITOR_ID));        $userAgent = null;        if ($setIp) {            $userAgent = current($this->userAgents);            $t->setIp(current($this->ips));            $t->setUserAgent($userAgent);            next($this->userAgents);            next($this->ips);        } else {            $t->setIp(""1.2.4.$visitorCounter"");        }        // first visit        $date = Date::factory($this->dateTime)->addDay($visitorCounter);        $t->setForceVisitDateTime($date->getDatetime());        $t->setUrl(""http://piwik.net/grue/lair"");        $t->setCustomVariable(1, 'Cvar 1 name', 'Cvar1 value is ' .$visitorCounter , 'visit');        $t->setCustomVariable(5, 'Cvar 5 name', 'Cvar5 value is ' .$visitorCounter , 'visit');        $t->setCustomVariable(2, 'Cvar 2 PAGE name', 'Cvar2 PAGE value is ' .$visitorCounter, 'page');        $t->setCustomVariable(5, 'Cvar 5 PAGE name', 'Cvar5 PAGE value is ' .$visitorCounter, 'page');        $r = $t->doTrackPageView('It\'s <script> pitch black...');        if (!$doBulk) {            self::checkResponse($r);        }        // second visit        if ($userAgent) {            $t->setUserAgent($userAgent); // unset in doTrack...        }        $date = $date->addHour(1);        $t->setForceVisitDateTime($date->getDatetime());        $t->setUrl(""http://piwik.net/space/quest/iv"");        // Manually record some data        $r = $t->doTrackPageView(""Space Quest XII"");        if (!$doBulk) {            self::checkResponse($r);        }        if ($userAgent) {            $t->setUserAgent($userAgent); // unset in doTrack...        }        // Track site search (for AutoSuggestAPI test)        // Only for half visitors so they don't all have a ""site search"" as last action and some of them have a standard page view as last action        $date = $date->addHour(0.1);        $t->setForceVisitDateTime($date->getDatetime());        if( ($visitorCounter % 2) == 0) {            $r = $t->doTrackSiteSearch('Bring on the party', 'CAT', $visitorCounter*6);        }        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.2);        $t->setForceVisitDateTime($date->getDatetime());        $r = $t->doTrackGoal($this->idGoal2);        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.05);        $t->setForceVisitDateTime($date->getDatetime());        $t->doTrackAction('http://example.org/path/file' . $visitorCounter . '.zip', ""download"" );        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.05);        $t->setForceVisitDateTime($date->getDatetime());        $r = $t->doTrackAction('http://example-outlink.org/' . $visitorCounter . '.html', ""link"" );        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.05);        $t->setForceVisitDateTime($date->getDatetime());        $r = $t->doTrackEvent('Cat' . $visitorCounter,             'Action' . $visitorCounter,             'Name' . $visitorCounter,             345.678 + $visitorCounter        );        if (!$doBulk) {            self::checkResponse($r);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_MergeDataTables_991, Merge the columns of two data tables. Only takes into consideration the first row of each table.\n Manipulates the first table.\n\n @param DataTable|DataTable\\Map $table1 The table to eventually filter.\n @param DataTable|DataTable\\Map $table2 Whether to delete rows with no visits or not.\n, Merge the columns of two data tables. Only takes into consideration the first row of each table.,"    public function mergeDataTables($table1, $table2)    {        // handle table arrays        if ($table1 instanceof DataTable\Map && $table2 instanceof DataTable\Map) {            $subTables1 = $table1->getDataTables();            foreach ($table2->getDataTables() as $index => $subTable2) {                if (!array_key_exists($index, $subTables1)) {                    $subTable1 = $this->makeNewDataTable($subTable2);                    $table1->addTable($subTable1, $index);                } else {                    $subTable1 = $subTables1[$index];                }                $this->mergeDataTables($subTable1, $subTable2);            }            return;        }        $firstRow2 = $table2->getFirstRow();        if (!($firstRow2 instanceof Row)) {            return;        }        $firstRow1 = $table1->getFirstRow();        if (empty($firstRow1)) {            $firstRow1 = $table1->addRow(new Row());        }        foreach ($firstRow2->getColumns() as $metric => $value) {            $firstRow1->setColumn($metric, $value);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ProcessedReport_235, Verfies whether the given report exists for the given site.\\n\\n @param int $idSite\\n @param string $apiMethodUniqueId  For example 'MultiSites_getAll'\\n\\n @return bool\\n, Verfies whether the given report exists for the given site.,"    public function isValidReportForSite($idSite, $apiMethodUniqueId)    {        $report = $this->getReportMetadataByUniqueId($idSite, $apiMethodUniqueId);        return !empty($report);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ProcessedReport_971, Verfies whether the given metric belongs to the given report.\n\n @param int $idSite\n @param string $metric     For example 'nb_visits'\n @param string $apiMethodUniqueId  For example 'MultiSites_getAll'\n\n @return bool\n, Verfies whether the given metric belongs to the given report.,"    public function isValidMetricForReport($metric, $idSite, $apiMethodUniqueId)    {        $translation = $this->translateMetric($metric, $idSite, $apiMethodUniqueId);        return !empty($translation);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ProcessedReport_972, Translates the given metric in case the report exists and in case the metric actually belongs to the report.\n\n @param string $metric     For example 'nb_visits'\n @param int    $idSite\n @param string $apiMethodUniqueId  For example 'MultiSites_getAll'\n\n @return null|string\n, Translates the given metric in case the report exists and in case the metric actually belongs to the report.,"    public function translateMetric($metric, $idSite, $apiMethodUniqueId)    {        $report = $this->getReportMetadataByUniqueId($idSite, $apiMethodUniqueId);        if (empty($report)) {            return;        }        $properties = array('metrics', 'processedMetrics', 'processedMetricsGoal');        foreach ($properties as $prop) {            if (!empty($report[$prop]) && is_array($report[$prop]) && array_key_exists($metric, $report[$prop])) {                return $report[$prop][$metric];            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ProcessedReport_974, Removes metrics from the list of columns and the report meta data if they are marked empty\n in the data table meta data.\n, Removes metrics from the list of columns and the report meta data if they are marked empty,"    private function removeEmptyColumns(&$columns, &$reportMetadata, $dataTable)    {        $emptyColumns = $dataTable->getMetadata(DataTable::EMPTY_COLUMNS_METADATA_NAME);        if (!is_array($emptyColumns)) {            return;        }        $columnsToRemove = $this->getColumnsToRemove();        $columnsToKeep   = $this->getColumnsToKeep();        $columns = $this->hideShowMetricsWithParams($columns, $columnsToRemove, $columnsToKeep, $emptyColumns);        if (isset($reportMetadata['metrics'])) {            $reportMetadata['metrics'] = $this->hideShowMetricsWithParams($reportMetadata['metrics'], $columnsToRemove, $columnsToKeep, $emptyColumns);        }        if (isset($reportMetadata['metricsDocumentation'])) {            $reportMetadata['metricsDocumentation'] = $this->hideShowMetricsWithParams($reportMetadata['metricsDocumentation'], $columnsToRemove, $columnsToKeep, $emptyColumns);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_QuickForm2_152, Class representing a HTML form\\n\\n @category   HTML\\n @package    HTML_QuickForm2\\n @author     Alexey Borzov <avb@php.net>\\n @author     Bertrand Mansion <golgote@mamasam.com>\\n @version    Release: @package_version@\\n, Class representing a HTML form,"class HTML_QuickForm2 extends HTML_QuickForm2_Container{   /**    * Data sources providing values for form elements    * @var array    */    protected $datasources = array();   /**    * We do not allow setting ""method"" and ""id"" other than through constructor    * @var array    */    protected $watchedAttributes = array('id', 'method');   /**    * Class constructor, form's ""id"" and ""method"" attributes can only be set here    *    * @param    string  ""id"" attribute of <form> tag    * @param    string  HTTP method used to submit the form    * @param    mixed   Additional attributes (either a string or an array)    * @param    bool    Whether to track if the form was submitted by adding    *                   a special hidden field    */    public function __construct($id, $method = 'post', $attributes = null, $trackSubmit = true)    {        $method = ('GET' == strtoupper($method))? 'get': 'post';        if (empty($id)) {            $id          = self::generateId('');            $trackSubmit = false;        } else {            self::storeId($id);        }        $this->attributes = array_merge(                                self::prepareAttributes($attributes),                                array('id' => (string)$id, 'method' => $method)                            );        if (!isset($this->attributes['action'])) {            $this->attributes['action'] = $_SERVER['PHP_SELF'];        }        if ($trackSubmit && isset($_REQUEST['_qf__' . $id]) ||            !$trackSubmit && ('get' == $method && !empty($_GET) ||                              'post' == $method && (!empty($_POST) || !empty($_FILES))))        {            $this->addDataSource(new HTML_QuickForm2_DataSource_SuperGlobal(                $method, False            ));        }        if ($trackSubmit) {            $this->appendChild(HTML_QuickForm2_Factory::createElement(                'hidden', '_qf__' . $id            ));        }    }    protected function onAttributeChange($name, $value = null)    {        throw new HTML_QuickForm2_InvalidArgumentException(            'Attribute \'' . $name . '\' is read-only'        );    }    protected function setContainer(HTML_QuickForm2_Container $container = null)    {        throw new HTML_QuickForm2_Exception('Form cannot be added to container');    }    public function setId($id = null)    {        throw new HTML_QuickForm2_InvalidArgumentException(            ""Attribute 'id' is read-only""        );    }   /**    * Adds a new data source to the form    *    * @param    HTML_QuickForm2_DataSource  Data source    */    public function addDataSource(HTML_QuickForm2_DataSource $datasource)    {        $this->datasources[] = $datasource;        $this->updateValue();    }   /**    * Replaces the list of form's data sources with a completely new one    *    * @param    array   A new data source list    * @throws   HTML_QuickForm2_InvalidArgumentException    if given array    *               contains something that is not a valid data source    */    public function setDataSources(array $datasources)    {        foreach ($datasources as $ds) {            if (!$ds instanceof HTML_QuickForm2_DataSource) {                throw new HTML_QuickForm2_InvalidArgumentException(                    'Array should contain only DataSource instances'                );            }        }        $this->datasources = $datasources;        $this->updateValue();    }   /**    * Returns the list of data sources attached to the form    *    * @return   array    */    public function getDataSources()    {        return $this->datasources;    }    public function getType()    {        return 'form';    }    public function setValue($value)    {        throw new HTML_QuickForm2_Exception('Not implemented');    }   /**    * Performs the server-side validation    *    * @return   boolean Whether all form's elements are valid    */    public function validate()    {        $isSubmitted = false;        foreach ($this->datasources as $ds) {            if ($ds instanceof HTML_QuickForm2_DataSource_Submit) {                $isSubmitted = true;                break;            }        }        return $isSubmitted? parent::validate(): false;    }   /**    * Renders the form using the given renderer    *    * @param    HTML_QuickForm2_Renderer    Renderer instance    * @return   HTML_QuickForm2_Renderer    */    public function render(HTML_QuickForm2_Renderer $renderer)    {        $renderer->startForm($this);        $renderer->getJavascriptBuilder()->startForm($this);        foreach ($this as $element) {            $element->render($renderer);        }        $renderer->finishForm($this);        return $renderer;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_QuickForm2_154, Replaces the list of form's data sources with a completely new one\\n\\n @param    array   A new data source list\\n @throws   HTML_QuickForm2_InvalidArgumentException    if given array\\n               contains something that is not a valid data source\\n, Replaces the list of form's data sources with a completely new one,    public function setDataSources(array $datasources)    {        foreach ($datasources as $ds) {            if (!$ds instanceof HTML_QuickForm2_DataSource) {                throw new HTML_QuickForm2_InvalidArgumentException(                    'Array should contain only DataSource instances'                );            }        }        $this->datasources = $datasources;        $this->updateValue();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_QuickForm2_155, Returns the list of data sources attached to the form\\n\\n @return   array\\n, Returns the list of data sources attached to the form,    public function getDataSources()    {        return $this->datasources;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_RowEvolution_977," This class generates a Row evolution dataset, from input request\n\n"," This class generates a Row evolution dataset, from input request","class RowEvolution{    private static $actionsUrlReports = array(        'getPageUrls',        'getPageUrlsFollowingSiteSearch',        'getEntryPageUrls',        'getExitPageUrls',        'getPageUrl'    );    public function getRowEvolution($idSite, $period, $date, $apiModule, $apiAction, $label = false, $segment = false, $column = false, $language = false, $apiParameters = array(), $legendAppendMetric = true, $labelUseAbsoluteUrl = true, $labelSeries = '')    {        // validation of requested $period & $date        if ($period == 'range') {            // load days in the range            $period = 'day';        }        if (!Period::isMultiplePeriod($date, $period)) {            throw new Exception(""Row evolutions can not be processed with this combination of \'date\' and \'period\' parameters."");        }        $label = DataTablePostProcessor::unsanitizeLabelParameter($label);        $labels = Piwik::getArrayFromApiParameter($label, $onlyUnique = empty($labelSeries));        $metadata = $this->getRowEvolutionMetaData($idSite, $period, $date, $apiModule, $apiAction, $language, $apiParameters);        $dataTable = $this->loadRowEvolutionDataFromAPI($metadata, $idSite, $period, $date, $apiModule, $apiAction, $labels, $segment, $apiParameters);        if (empty($dataTable->getDataTables())) {            return array();        }        if (empty($labels)) {            $labels = $this->getLabelsFromDataTable($dataTable, $labels);            $dataTable = $this->enrichRowAddMetadataLabelIndex($labels, $dataTable);        }        if (count($labels) != 1) {            $data = $this->getMultiRowEvolution(                $dataTable,                $metadata,                $apiModule,                $apiAction,                $labels,                $column,                $legendAppendMetric,                $labelUseAbsoluteUrl,                $labelSeries            );        } else {            $data = $this->getSingleRowEvolution(                $idSite,                $dataTable,                $metadata,                $apiModule,                $apiAction,                $labels[0],                $labelUseAbsoluteUrl            );        }        return $data;    }    /**     * @param array $labels     * @param DataTable\Map $dataTable     * @return mixed     */    protected function enrichRowAddMetadataLabelIndex($labels, $dataTable)    {        // set label index metadata        $labelsToIndex = array_flip($labels);        foreach ($dataTable->getDataTables() as $table) {            foreach ($table->getRows() as $row) {                $label = $row->getColumn('label');                if (isset($labelsToIndex[$label])) {                    $row->setMetadata(LabelFilter::FLAG_IS_ROW_EVOLUTION, $labelsToIndex[$label]);                }            }        }        return $dataTable;    }    /**     * @param DataTable\Map $dataTable     * @param array $labels     * @return array     */    protected function getLabelsFromDataTable($dataTable, $labels)    {        // if no labels specified, use all possible labels as list        foreach ($dataTable->getDataTables() as $table) {            $labels = array_merge($labels, $table->getColumn('label'));        }        $labels = array_values(array_unique($labels));        // if the filter_limit query param is set, treat it as a request to limit        // the number of labels used        $limit = Common::getRequestVar('filter_limit', false);        if ($limit != false            && $limit >= 0        ) {            $labels = array_slice($labels, 0, $limit);        }        return $labels;    }    /**     * Get row evolution for a single label     * @param DataTable\Map $dataTable     * @param array $metadata     * @param string $apiModule     * @param string $apiAction     * @param string $label     * @param bool $labelUseAbsoluteUrl     * @return array containing  report data, metadata, label, logo     */    private function getSingleRowEvolution($idSite, $dataTable, $metadata, $apiModule, $apiAction, $label, $labelUseAbsoluteUrl = true)    {        $metricNames = array_keys($metadata['metrics']);        $logo = $actualLabel = false;        $urlFound = false;        foreach ($dataTable->getDataTables() as $subTable) {            /** @var $subTable DataTable */            $subTable->applyQueuedFilters();            if ($subTable->getRowsCount() > 0) {                /** @var $row Row */                $row = $subTable->getFirstRow();                if (!$actualLabel) {                    $logo = $row->getMetadata('logo');                    $actualLabel = $this->getRowUrlForEvolutionLabel($row, $apiModule, $apiAction, $labelUseAbsoluteUrl);                    $urlFound = $actualLabel !== false;                    if (empty($actualLabel)) {                        $actualLabel = $row->getColumn('label');                    }                }                // remove all columns that are not in the available metrics.                // this removes the label as well (which is desired for two reasons: (1) it was passed                // in the request, (2) it would cause the evolution graph to show the label in the legend).                foreach ($row->getColumns() as $column => $value) {                    if (!in_array($column, $metricNames) && $column != 'label_html') {                        $row->deleteColumn($column);                    }                }                $row->deleteMetadata();            }        }        $this->enhanceRowEvolutionMetaData($metadata, $dataTable);        // if we have a recursive label and no url, use the path        if (!$urlFound) {            $actualLabel = $this->formatQueryLabelForDisplay($idSite, $apiModule, $apiAction, $label);        }        $return = array(            'label'      => SafeDecodeLabel::decodeLabelSafe($actualLabel),            'reportData' => $dataTable,            'metadata'   => $metadata        );        if (!empty($logo)) {            $return['logo'] = $logo;        }        return $return;    }    private function formatQueryLabelForDisplay($idSite, $apiModule, $apiAction, $label)    {        // rows with subtables do not contain URL metadata. this hack makes sure the label titles in row        // evolution popovers look like URLs.        if ($apiModule == 'Actions'            && in_array($apiAction, self::$actionsUrlReports)        ) {            $mainUrl = Site::getMainUrlFor($idSite);            $mainUrlHost = @parse_url($mainUrl, PHP_URL_HOST);            $replaceRegex = ""/\\s*"" . preg_quote(LabelFilter::SEPARATOR_RECURSIVE_LABEL) . ""\\s*/"";            $cleanLabel = preg_replace($replaceRegex, '/', $label);            $result = $mainUrlHost . '/' . $cleanLabel . '/';        } else {            $result = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        }        // remove @ terminal operator occurrences        return str_replace(LabelFilter::TERMINAL_OPERATOR, '', $result);    }    /**     * @param Row $row     * @param string $apiModule     * @param string $apiAction     * @param bool $labelUseAbsoluteUrl     * @return bool|string     */    private function getRowUrlForEvolutionLabel($row, $apiModule, $apiAction, $labelUseAbsoluteUrl)    {        $url = $row->getMetadata('url');        if ($url            && ($apiModule == 'Actions'                || ($apiModule == 'Referrers'                    && $apiAction == 'getWebsites'))            && $labelUseAbsoluteUrl        ) {            $actualLabel = preg_replace(';^http(s)?://(www.)?;i', '', $url);            return $actualLabel;        }        return false;    }    /**     * @param array $metadata see getRowEvolutionMetaData()     * @param int $idSite     * @param string $period     * @param string $date     * @param string $apiModule     * @param string $apiAction     * @param string|bool $label     * @param string|bool $segment     * @param array $apiParameters     * @throws Exception     * @return DataTable\Map|DataTable     */    private function loadRowEvolutionDataFromAPI($metadata, $idSite, $period, $date, $apiModule, $apiAction, $label, $segment, $apiParameters)    {        if (!is_array($label)) {            $label = array($label);        }        $label = array_map('rawurlencode', $label);        $parameters = array(            'method'                   => $apiModule . '.' . $apiAction,            'label'                    => $label,            'idSite'                   => $idSite,            'period'                   => $period,            'date'                     => $date,            'format'                   => 'original',            'serialize'                => '0',            'segment'                  => $segment,            // data for row evolution should NOT be limited            'filter_limit'             => -1,            // if more than one label is used, we add metadata to ensure we know which            // row corresponds with which label (since the labels can change, and rows            // can be sorted in a different order)            'labelFilterAddLabelIndex' => count($label) > 1 ? 1 : 0,        );        if (!empty($apiParameters) && is_array($apiParameters)) {            foreach ($apiParameters as $param => $value) {                $parameters[$param] = $value;            }        }        // add ""processed metrics"" like actions per visit or bounce rate        // note: some reports should not be filtered with AddColumnProcessedMetrics        // specifically, reports without the Metrics::INDEX_NB_VISITS metric such as Goals.getVisitsUntilConversion & Goal.getDaysToConversion        // this is because the AddColumnProcessedMetrics filter removes all datable rows lacking this metric        if (isset($metadata['metrics']['nb_visits'])) {            $parameters['filter_add_columns_when_show_all_columns'] = '0';        }        $url = Url::getQueryStringFromParameters($parameters);        $request = new Request($url);        try {            $dataTable = $request->process();        } catch (Exception $e) {            throw new Exception(""API returned an error: "" . $e->getMessage() . ""\n"");        }        return $dataTable;    }    /**     * For a given API report, returns a simpler version     * of the metadata (will return only the metrics and the dimension name)     * @param $idSite     * @param $period     * @param $date     * @param $apiModule     * @param $apiAction     * @param $language     * @param $apiParameters     * @throws Exception     * @return array     */    private function getRowEvolutionMetaData($idSite, $period, $date, $apiModule, $apiAction, $language, $apiParameters)    {        $reportMetadata = API::getInstance()->getMetadata($idSite, $apiModule, $apiAction, $apiParameters, $language,            $period, $date, $hideMetricsDoc = false, $showSubtableReports = true);        if (empty($reportMetadata)) {            throw new Exception(""Requested report $apiModule.$apiAction for Website id=$idSite ""                . ""not found in the list of available reports. \n"");        }        $reportMetadata = reset($reportMetadata);        $metrics = $reportMetadata['metrics'];        if (isset($reportMetadata['processedMetrics']) && is_array($reportMetadata['processedMetrics'])) {            $metrics = $metrics + $reportMetadata['processedMetrics'];        }        if (empty($reportMetadata['dimension'])) {            throw new Exception(sprintf('Reports like %s.%s which do not have a dimension are not supported by row evolution', $apiModule, $apiAction));        }        $dimension = $reportMetadata['dimension'];        return compact('metrics', 'dimension');    }    /**     * Given the Row evolution dataTable, and the associated metadata,     * enriches the metadata with min/max values, and % change between the first period and the last one     * @param array $metadata     * @param DataTable\Map $dataTable     */    private function enhanceRowEvolutionMetaData(&$metadata, $dataTable)    {        // prepare result array for metrics        $metricsResult = array();        foreach ($metadata['metrics'] as $metric => $name) {            $metricsResult[$metric] = array('name' => $name);            if (!empty($metadata['logos'][$metric])) {                $metricsResult[$metric]['logo'] = $metadata['logos'][$metric];            }        }        unset($metadata['logos']);        $subDataTables = $dataTable->getDataTables();        if (empty($subDataTables)) {            throw new \Exception(""Unexpected state: row evolution API call returned empty DataTable\\Map."");        }        $firstDataTable = reset($subDataTables);        $this->checkDataTableInstance($firstDataTable);        $firstDataTableRow = $firstDataTable->getFirstRow();        $lastDataTable = end($subDataTables);        $this->checkDataTableInstance($lastDataTable);        $lastDataTableRow = $lastDataTable->getFirstRow();        // Process min/max values        $firstNonZeroFound = array();        foreach ($subDataTables as $subDataTable) {            // $subDataTable is the report for one period, it has only one row            $firstRow = $subDataTable->getFirstRow();            foreach ($metadata['metrics'] as $metric => $label) {                $value = $firstRow ? floatval($firstRow->getColumn($metric)) : 0;                if ($value > 0) {                    $firstNonZeroFound[$metric] = true;                } else if (!isset($firstNonZeroFound[$metric])) {                    continue;                }                if (!isset($metricsResult[$metric]['min'])                    || $metricsResult[$metric]['min'] > $value                ) {                    $metricsResult[$metric]['min'] = $value;                }                if (!isset($metricsResult[$metric]['max'])                    || $metricsResult[$metric]['max'] < $value                ) {                    $metricsResult[$metric]['max'] = $value;                }            }        }        // Process % change between first/last values        foreach ($metadata['metrics'] as $metric => $label) {            $first = $firstDataTableRow ? floatval($firstDataTableRow->getColumn($metric)) : 0;            $last = $lastDataTableRow ? floatval($lastDataTableRow->getColumn($metric)) : 0;            // do not calculate evolution if the first value is 0 (to avoid divide-by-zero)            if ($first == 0) {                continue;            }            $change = CalculateEvolutionFilter::calculate($last, $first, $quotientPrecision = 0, true, true);            $metricsResult[$metric]['change'] = $change;        }        $metadata['metrics'] = $metricsResult;    }    /** Get row evolution for a multiple labels */    private function getMultiRowEvolution(DataTable\Map $dataTable, $metadata, $apiModule, $apiAction, $labels, $column,                                          $legendAppendMetric = true,                                          $labelUseAbsoluteUrl = true,                                          $labelSeries = '')    {        $labelSeries = explode(',', $labelSeries);        $labelSeries = array_filter($labelSeries, 'strlen');        $labelSeries = array_map('intval', $labelSeries);        if (!isset($metadata['metrics'][$column])) {            // invalid column => use the first one that's available            $metrics = array_keys($metadata['metrics']);            $column = reset($metrics);        }        // get the processed label and logo (if any) for every requested label        $actualLabels = $logos = array();        foreach ($labels as $labelIdx => $label) {            foreach ($dataTable->getDataTables() as $table) {                $labelRow = $this->getRowEvolutionRowFromLabelIdx($table, $labelIdx);                if ($labelRow) {                    $actualLabels[$labelIdx] = $this->getRowUrlForEvolutionLabel(                        $labelRow, $apiModule, $apiAction, $labelUseAbsoluteUrl);                    $prettyLabel = $labelRow->getColumn('label_html');                    if ($prettyLabel !== false) {                        $actualLabels[$labelIdx] = $prettyLabel;                    }                    $logos[$labelIdx] = $labelRow->getMetadata('logo');                    if (!empty($actualLabels[$labelIdx])) {                        break;                    }                }            }            if (empty($actualLabels[$labelIdx])) {                $cleanLabel = $this->cleanOriginalLabel($label);                $actualLabels[$labelIdx] = $cleanLabel;            }            if (isset($labelSeries[$labelIdx])) {                $labelSeriesIndex = $labelSeries[$labelIdx];                $actualLabels[$labelIdx] .= ' ' . DataComparisonFilter::getPrettyComparisonLabelFromSeriesIndex($labelSeriesIndex);            }        }        // convert rows to be array($column.'_'.$labelIdx => $value) as opposed to        // array('label' => $label, 'column' => $value).        $dataTableMulti = $dataTable->getEmptyClone();        foreach ($dataTable->getDataTables() as $tableLabel => $table) {            $newRow = new Row();            foreach ($labels as $labelIdx => $label) {                $row = $this->getRowEvolutionRowFromLabelIdx($table, $labelIdx);                $value = 0;                if ($row) {                    $value = $row->getColumn($column);                    $value = floatVal(str_replace(',', '.', $value));                }                if ($value == '') {                    $value = 0;                }                $newLabel = $column . '_' . (int)$labelIdx;                $newRow->addColumn($newLabel, $value);            }            $newTable = $table->getEmptyClone();            if (!empty($labels)) { // only add a row if the row has data (no labels === no data)                $newTable->addRow($newRow);            }            $dataTableMulti->addTable($newTable, $tableLabel);        }        // the available metrics for the report are returned as metadata / columns        $metadata['columns'] = $metadata['metrics'];        // metadata / metrics should document the rows that are compared        // this way, UI code can be reused        $metadata['metrics'] = array();        foreach ($actualLabels as $labelIndex => $label) {            if ($legendAppendMetric) {                $label .= ' (' . $metadata['columns'][$column] . ')';            }            $metricName = $column . '_' . $labelIndex;            $metadata['metrics'][$metricName] = $label;            if (!empty($logos[$labelIndex])) {                $metadata['logos'][$metricName] = $logos[$labelIndex];            }        }        $this->enhanceRowEvolutionMetaData($metadata, $dataTableMulti);        return array(            'column'     => $column,            'reportData' => $dataTableMulti,            'metadata'   => $metadata        );    }    /**     * Returns the row in a datatable by its LabelFilter::FLAG_IS_ROW_EVOLUTION metadata.     *     * @param DataTable $table     * @param int $labelIdx     * @return Row|false     */    private function getRowEvolutionRowFromLabelIdx($table, $labelIdx)    {        $labelIdx = (int)$labelIdx;        foreach ($table->getRows() as $row) {            if ($row->getMetadata(LabelFilter::FLAG_IS_ROW_EVOLUTION) === $labelIdx) {                return $row;            }        }        return false;    }    /**     * Returns a prettier, more comprehensible version of a row evolution label for display.     */    private function cleanOriginalLabel($label)    {        $label = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        $label = SafeDecodeLabel::decodeLabelSafe($label);        return $label;    }    private function checkDataTableInstance($lastDataTable)    {        if (!($lastDataTable instanceof DataTable)) {            throw new \Exception(""Unexpected state: row evolution returned DataTable\\Map w/ incorrect child table type: "" . get_class($lastDataTable));        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_RowEvolution_985, Returns the row in a datatable by its LabelFilter::FLAG_IS_ROW_EVOLUTION metadata.\n\n @param DataTable $table\n @param int $labelIdx\n @return Row|false\n, Returns the row in a datatable by its LabelFilter::FLAG_IS_ROW_EVOLUTION metadata.,"    private function getRowEvolutionRowFromLabelIdx($table, $labelIdx)    {        $labelIdx = (int)$labelIdx;        foreach ($table->getRows() as $row) {            if ($row->getMetadata(LabelFilter::FLAG_IS_ROW_EVOLUTION) === $labelIdx) {                return $row;            }        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_TwoFactorAuthenticator_130, PHP Class for handling Google Authenticator 2-factor authentication\\n\\n @author Michael Kliewe\\n @copyright 2012 Michael Kliewe\\n @license http://www.opensource.org/licenses/bsd-license.php BSD License\\n @link http://www.phpgangsta.de/\\n\\n small adjustments by @sgiehl / matomo.org\\n - renamed class\\n - removed method getQRCodeGoogleUrl\\n small adjustments by matomo.org\\n - use better random secret generator\\n, PHP Class for handling Google Authenticator 2-factor authentication,"class TwoFactorAuthenticator{    protected $_codeLength = 6;    /**     * Create new secret.     * 16 characters, randomly chosen from the allowed base32 characters.     *     * @param int $secretLength     * @return string     */    public function createSecret($secretLength = 16)    {        $validChars = $this->_getBase32LookupTable();        unset($validChars[32]);        // modified by matomo.org        return \Piwik\Common::getRandomString($secretLength, implode('', $validChars));    }    /**     * Calculate the code, with given secret and point in time     *     * @param string $secret     * @param int|null $timeSlice     * @return string     */    public function getCode($secret, $timeSlice = null)    {        if ($timeSlice === null) {            $timeSlice = floor(time() / 30);        }        $secretkey = $this->_base32Decode($secret);        // Pack time into binary string        $time = chr(0).chr(0).chr(0).chr(0).pack('N*', $timeSlice);        // Hash it with users secret key        $hm = hash_hmac('SHA1', $time, $secretkey, true);        // Use last nipple of result as index/offset        $offset = ord(substr($hm, -1)) & 0x0F;        // grab 4 bytes of the result        $hashpart = substr($hm, $offset, 4);        // Unpak binary value        $value = unpack('N', $hashpart);        $value = $value[1];        // Only 32 bits        $value = $value & 0x7FFFFFFF;        $modulo = pow(10, $this->_codeLength);        return str_pad($value % $modulo, $this->_codeLength, '0', STR_PAD_LEFT);    }    /**     * Check if the code is correct. This will accept codes starting from $discrepancy*30sec ago to $discrepancy*30sec from now     *     * @param string $secret     * @param string $code     * @param int $discrepancy This is the allowed time drift in 30 second units (8 means 4 minutes before or after)     * @param int|null $currentTimeSlice time slice if we want use other that time()     * @return bool     */    public function verifyCode($secret, $code, $discrepancy = 1, $currentTimeSlice = null)    {        if ($currentTimeSlice === null) {            $currentTimeSlice = floor(time() / 30);        }        for ($i = -$discrepancy; $i <= $discrepancy; $i++) {            $calculatedCode = $this->getCode($secret, $currentTimeSlice + $i);            if ($calculatedCode == $code ) {                return true;            }        }        return false;    }    /**     * Set the code length, should be >=6     *     * @param int $length     * @return self     */    public function setCodeLength($length)    {        $this->_codeLength = $length;        return $this;    }    /**     * Helper class to decode base32     *     * @param $secret     * @return bool|string     */    protected function _base32Decode($secret)    {        if (empty($secret)) return '';        $base32chars = $this->_getBase32LookupTable();        $base32charsFlipped = array_flip($base32chars);        $paddingCharCount = substr_count($secret, $base32chars[32]);        $allowedValues = array(6, 4, 3, 1, 0);        if (!in_array($paddingCharCount, $allowedValues)) return false;        for ($i = 0; $i < 4; $i++){            if ($paddingCharCount == $allowedValues[$i] &&                substr($secret, -($allowedValues[$i])) != str_repeat($base32chars[32], $allowedValues[$i])) return false;        }        $secret = str_replace('=','', $secret);        $secret = str_split($secret);        $binaryString = """";        for ($i = 0; $i < count($secret); $i = $i+8) {            $x = """";            if (!in_array($secret[$i], $base32chars)) return false;            for ($j = 0; $j < 8; $j++) {                $x .= str_pad(base_convert(@$base32charsFlipped[@$secret[$i + $j]], 10, 2), 5, '0', STR_PAD_LEFT);            }            $eightBits = str_split($x, 8);            for ($z = 0; $z < count($eightBits); $z++) {                $binaryString .= ( ($y = chr(base_convert($eightBits[$z], 2, 10))) || ord($y) == 48 ) ? $y:"""";            }        }        return $binaryString;    }    /**     * Helper class to encode base32     *     * @param string $secret     * @param bool $padding     * @return string     */    protected function _base32Encode($secret, $padding = true)    {        if (empty($secret)) return '';        $base32chars = $this->_getBase32LookupTable();        $secret = str_split($secret);        $binaryString = """";        for ($i = 0; $i < count($secret); $i++) {            $binaryString .= str_pad(base_convert(ord($secret[$i]), 10, 2), 8, '0', STR_PAD_LEFT);        }        $fiveBitBinaryArray = str_split($binaryString, 5);        $base32 = """";        $i = 0;        while ($i < count($fiveBitBinaryArray)) {            $base32 .= $base32chars[base_convert(str_pad($fiveBitBinaryArray[$i], 5, '0'), 2, 10)];            $i++;        }        if ($padding && ($x = strlen($binaryString) % 40) != 0) {            if ($x == 8) $base32 .= str_repeat($base32chars[32], 6);            elseif ($x == 16) $base32 .= str_repeat($base32chars[32], 4);            elseif ($x == 24) $base32 .= str_repeat($base32chars[32], 3);            elseif ($x == 32) $base32 .= $base32chars[32];        }        return $base32;    }    /**     * Get array with all 32 characters for decoding from/encoding to base32     *     * @return array     */    protected function _getBase32LookupTable()    {        return array(            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', //  7            'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', // 15            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', // 23            'Y', 'Z', '2', '3', '4', '5', '6', '7', // 31            '='  // padding char        );    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_CompositeExpectation_409, Add an expectation to the composite\\\\n\\\\n @param \\\\\\\\Mockery\\\\\\\\Expectation|\\\\\\\\Mockery\\\\\\\\CompositeExpectation $expectation\\\\n @return void\\\\n, Add an expectation to the composite,    public function add($expectation)    {        $this->_expectations[] = $expectation;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_CompositeExpectation_413, Return order number of the first expectation\\n\\n @return int\\n, Return order number of the first expectation,    public function getOrderNumber()    {        reset($this->_expectations);        $first = current($this->_expectations);        return $first->getOrderNumber();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_CompositeExpectation_414, Return the parent mock of the first expectation\\n\\n @return \\\\Mockery\\\\MockInterface|\\\\Mockery\\\\LegacyMockInterface\\n, Return the parent mock of the first expectation,    public function getMock()    {        reset($this->_expectations);        $first = current($this->_expectations);        return $first->getMock();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_CompositeExpectation_415, Mockery API alias to getMock\n\n @return \\Mockery\\LegacyMockInterface|\\Mockery\\MockInterface\n, Mockery API alias to getMock,    public function mock()    {        return $this->getMock();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_CompositeExpectation_416, Starts a new expectation addition on the first mock which is the primary\\n target outside of a demeter chain\\n\\n @param mixed ...$args\\n @return \\\\Mockery\\\\Expectation\\n, Starts a new expectation addition on the first mock which is the primary,"    public function shouldReceive(...$args)    {        reset($this->_expectations);        $first = current($this->_expectations);        return call_user_func_array(array($first->getMock(), 'shouldReceive'), $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_CompositeExpectation_418, Return the string summary of this composite expectation\\\\n\\\\n @return string\\\\n, Return the string summary of this composite expectation,"    public function __toString()    {        $return = '[';        $parts = array();        foreach ($this->_expectations as $exp) {            $parts[] = (string) $exp;        }        $return .= implode(', ', $parts) . ']';        return $return;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Configuration_419, Return flag indicating whether mocking non-existent methods allowed\n\n @return bool\n, Return flag indicating whether mocking non-existent methods allowed,    public function mockingNonExistentMethodsAllowed()    {        return $this->_allowMockingNonExistentMethod;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Configuration_420, Return flag indicating whether mocking non-existent methods allowed\\n\\n @return bool\\n\\n @deprecated since 1.4.0\\n, Return flag indicating whether mocking non-existent methods allowed,"    public function mockingMethodsUnnecessarilyAllowed()    {        @trigger_error(sprintf(""The %s method is deprecated and will be removed in a future version of Mockery"", __METHOD__), E_USER_DEPRECATED);        return $this->_allowMockingMethodsUnnecessarily;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Configuration_421, Set a parameter map (array of param signature strings) for the method\\\\\\\\n of an internal PHP class.\\\\\\\\n\\\\\\\\n @param string $class\\\\\\\\n @param string $method\\\\\\\\n @param array $map\\\\\\\\n, Set a parameter map (array of param signature strings) for the method,"    public function setInternalClassMethodParamMap($class, $method, array $map)    {        if (\PHP_MAJOR_VERSION > 7) {            throw new \LogicException('Internal class parameter overriding is not available in PHP 8. Incompatible signatures have been reclassified as fatal errors.');        }        if (!isset($this->_internalClassParamMap[strtolower($class)])) {            $this->_internalClassParamMap[strtolower($class)] = array();        }        $this->_internalClassParamMap[strtolower($class)][strtolower($method)] = $map;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Configuration_423, Get the parameter map of an internal PHP class method\n\n @return array|null\n, Get the parameter map of an internal PHP class method,"    public function getInternalClassMethodParamMap($class, $method)    {        if (isset($this->_internalClassParamMap[strtolower($class)][strtolower($method)])) {            return $this->_internalClassParamMap[strtolower($class)][strtolower($method)];        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Configuration_425," Disable reflection caching\\n\\n It should be always enabled, except when using\\n PHPUnit's --static-backup option.\\n\\n @see https://github.com/mockery/mockery/issues/268\\n", Disable reflection caching,    public function disableReflectionCache()    {        $this->_reflectionCacheEnabled = false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Configuration_426," Enable reflection caching\\\\\\\\n\\\\\\\\n It should be always enabled, except when using\\\\\\\\n PHPUnit's --static-backup option.\\\\\\\\n\\\\\\\\n @see https://github.com/mockery/mockery/issues/268\\\\\\\\n", Enable reflection caching,    public function enableReflectionCache()    {        $this->_reflectionCacheEnabled = true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Configuration_427, Is reflection cache enabled?\n, Is reflection cache enabled?,    public function reflectionCacheEnabled()    {        return $this->_reflectionCacheEnabled;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ContainerTest_564," Meant to test the same logic as\\\\\\\\n testCanOverrideExpectedParametersOfExtensionPHPClassesToPreserveRefs,\\\\\\\\n but:\\\\\\\\n - doesn't require an extension\\\\\\\\n - isn't actually known to be used\\\\\\\\n", Meant to test the same logic as,"    public function testCanOverrideExpectedParametersOfInternalPHPClassesToPreserveRefs()    {        if (\PHP_MAJOR_VERSION > 7) {            $this->expectException('LogicException');        }        Mockery::getConfiguration()->setInternalClassMethodParamMap(            'DateTime',            'modify',            array('&$string')        );        // @ used to avoid E_STRICT for incompatible signature        @$m = mock('DateTime');        $this->assertInstanceOf(""Mockery\MockInterface"", $m, ""Mocking failed, remove @ error suppresion to debug"");        $m->shouldReceive('modify')->with(            Mockery::on(function (&$string) {                $string = 'foo';                return true;            })        );        $data ='bar';        $m->modify($data);        $this->assertEquals('foo', $data);        Mockery::getConfiguration()->resetInternalClassMethodParamMaps();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ContainerTest_565, Real world version of\n testCanOverrideExpectedParametersOfInternalPHPClassesToPreserveRefs\n, Real world version of,"    public function testCanOverrideExpectedParametersOfExtensionPHPClassesToPreserveRefs()    {        if (!class_exists('MongoCollection', false)) {            $this->markTestSkipped('ext/mongo not installed');        }        if (\PHP_MAJOR_VERSION > 7) {            $this->expectException('LogicException');        }        Mockery::getConfiguration()->setInternalClassMethodParamMap(            'MongoCollection',            'insert',            array('&$data', '$options')        );        // @ used to avoid E_STRICT for incompatible signature        @$m = mock('MongoCollection');        $this->assertInstanceOf(""Mockery\MockInterface"", $m, ""Mocking failed, remove @ error suppresion to debug"");        $m->shouldReceive('insert')->with(            Mockery::on(function (&$data) {                $data['_id'] = 123;                return true;            }),            Mockery::type('array')        );        $data = array('a'=>1,'b'=>2);        $m->insert($data, array());        $this->assertArrayHasKey('_id', $data);        $this->assertEquals(123, $data['_id']);        Mockery::getConfiguration()->resetInternalClassMethodParamMaps();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ContainerTest_587, issue/18\\\\n, issue/18,class SoCool{    public function iDoSomethingReallyCoolHere()    {        return 3;    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_428," Generates a new mock object for this container\\\\\\\\n\\\\\\\\n I apologies in advance for this. A God Method just fits the API which\\\\\\\\n doesn't require differentiating between classes, interfaces, abstracts,\\\\\\\\n names or partials - just so long as it's something that can be mocked.\\\\\\\\n I'll refactor it one day so it's easier to follow.\\\\\\\\n\\\\\\\\n @param array ...$args\\\\\\\\n\\\\\\\\n @return Mock\\\\\\\\n @throws Exception\\\\\\\\\\\\\\\\RuntimeException\\\\\\\\n", Generates a new mock object for this container,"    public function mock(...$args)    {        $expectationClosure = null;        $quickdefs = array();        $constructorArgs = null;        $blocks = array();        $class = null;        if (count($args) > 1) {            $finalArg = end($args);            reset($args);            if (is_callable($finalArg) && is_object($finalArg)) {                $expectationClosure = array_pop($args);            }        }        $builder = new MockConfigurationBuilder();        foreach ($args as $k => $arg) {            if ($arg instanceof MockConfigurationBuilder) {                $builder = $arg;                unset($args[$k]);            }        }        reset($args);        $builder->setParameterOverrides(\Mockery::getConfiguration()->getInternalClassMethodParamMaps());        $builder->setConstantsMap(\Mockery::getConfiguration()->getConstantsMap());        while (count($args) > 0) {            $arg = array_shift($args);            // check for multiple interfaces            if (is_string($arg)) {                foreach (explode('|', $arg) as $type) {                    if ($arg === 'null') {                        // skip PHP 8 'null's                    } elseif (strpos($type, ',') && !strpos($type, ']')) {                        $interfaces = explode(',', str_replace(' ', '', $type));                        $builder->addTargets($interfaces);                    } elseif (substr($type, 0, 6) == 'alias:') {                        $type = str_replace('alias:', '', $type);                        $builder->addTarget('stdClass');                        $builder->setName($type);                    } elseif (substr($type, 0, 9) == 'overload:') {                        $type = str_replace('overload:', '', $type);                        $builder->setInstanceMock(true);                        $builder->addTarget('stdClass');                        $builder->setName($type);                    } elseif (substr($type, strlen($type)-1, 1) == ']') {                        $parts = explode('[', $type);                        if (!class_exists($parts[0], true) && !interface_exists($parts[0], true)) {                            throw new \Mockery\Exception('Can only create a partial mock from'                            . ' an existing class or interface');                        }                        $class = $parts[0];                        $parts[1] = str_replace(' ', '', $parts[1]);                        $partialMethods = array_filter(explode(',', strtolower(rtrim($parts[1], ']'))));                        $builder->addTarget($class);                        foreach ($partialMethods as $partialMethod) {                            if ($partialMethod[0] === '!') {                                $builder->addBlackListedMethod(substr($partialMethod, 1));                                continue;                            }                            $builder->addWhiteListedMethod($partialMethod);                        }                    } elseif (class_exists($type, true) || interface_exists($type, true) || trait_exists($type, true)) {                        $builder->addTarget($type);                    } elseif (!\Mockery::getConfiguration()->mockingNonExistentMethodsAllowed() && (!class_exists($type, true) && !interface_exists($type, true))) {                        throw new \Mockery\Exception(""Mockery can't find '$type' so can't mock it"");                    } else {                        if (!$this->isValidClassName($type)) {                            throw new \Mockery\Exception('Class name contains invalid characters');                        }                        $builder->addTarget($type);                    }                    break; // unions are ""sum"" types and not ""intersections"", and so we must only process the first part                }            } elseif (is_object($arg)) {                $builder->addTarget($arg);            } elseif (is_array($arg)) {                if (!empty($arg) && array_keys($arg) !== range(0, count($arg) - 1)) {                    // if associative array                    if (array_key_exists(self::BLOCKS, $arg)) {                        $blocks = $arg[self::BLOCKS];                    }                    unset($arg[self::BLOCKS]);                    $quickdefs = $arg;                } else {                    $constructorArgs = $arg;                }            } else {                throw new \Mockery\Exception(                    'Unable to parse arguments sent to '                    . get_class($this) . '::mock()'                );            }        }        $builder->addBlackListedMethods($blocks);        if (!is_null($constructorArgs)) {            $builder->addBlackListedMethod(""__construct""); // we need to pass through        } else {            $builder->setMockOriginalDestructor(true);        }        if (!empty($partialMethods) && $constructorArgs === null) {            $constructorArgs = array();        }        $config = $builder->getMockConfiguration();        $this->checkForNamedMockClashes($config);        $def = $this->getGenerator()->generate($config);        if (class_exists($def->getClassName(), $attemptAutoload = false)) {            $rfc = new \ReflectionClass($def->getClassName());            if (!$rfc->implementsInterface(""Mockery\LegacyMockInterface"")) {                throw new \Mockery\Exception\RuntimeException(""Could not load mock {$def->getClassName()}, class already exists"");            }        }        $this->getLoader()->load($def);        $mock = $this->_getInstance($def->getClassName(), $constructorArgs);        $mock->mockery_init($this, $config->getTargetObject(), $config->isInstanceMock());        if (!empty($quickdefs)) {            if (\Mockery::getConfiguration()->getQuickDefinitions()->shouldBeCalledAtLeastOnce()) {                $mock->shouldReceive($quickdefs)->atLeast()->once();            } else {                $mock->shouldReceive($quickdefs)->byDefault();            }        }        if (!empty($expectationClosure)) {            $expectationClosure($mock);        }        $this->rememberMock($mock);        return $mock;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_432, Verify the container mocks\\\\n\\\\n @return void\\\\n, Verify the container mocks,    public function mockery_verify()    {        foreach ($this->_mocks as $mock) {            $mock->mockery_verify();        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_436, Set ordering for a group\\\\\\\\n\\\\\\\\n @param mixed $group\\\\\\\\n @param int $order\\\\\\\\n, Set ordering for a group,"    public function mockery_setGroup($group, $order)    {        $this->_groups[$group] = $order;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_437, Fetch array of ordered groups\n\n @return array\n, Fetch array of ordered groups,    public function mockery_getGroups()    {        return $this->_groups;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_438, Set current ordered number\\\\\\\\n\\\\\\\\n @param int $order\\\\\\\\n @return int The current order number that was set\\\\\\\\n, Set current ordered number,    public function mockery_setCurrentOrder($order)    {        $this->_currentOrder = $order;        return $this->_currentOrder;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_440, Validate the current mock's ordering\\\\\\\\n\\\\\\\\n @param string $method\\\\\\\\n @param int $order\\\\\\\\n @throws \\\\\\\\\\\\\\\\Mockery\\\\\\\\\\\\\\\\Exception\\\\\\\\n @return void\\\\\\\\n, Validate the current mock's ordering,"    public function mockery_validateOrder($method, $order, \Mockery\LegacyMockInterface $mock)    {        if ($order < $this->_currentOrder) {            $exception = new \Mockery\Exception\InvalidOrderException(                'Method ' . $method . ' called out of order: expected order '                . $order . ', was ' . $this->_currentOrder            );            $exception->setMock($mock)                ->setMethodName($method)                ->setExpectedOrder($order)                ->setActualOrder($this->_currentOrder);            throw $exception;        }        $this->mockery_setCurrentOrder($order);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_441, Gets the count of expectations on the mocks\n\n @return int\n, Gets the count of expectations on the mocks,    public function mockery_getExpectationCount()    {        $count = 0;        foreach ($this->_mocks as $mock) {            $count += $mock->mockery_getExpectationCount();        }        return $count;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_443," Retrieve the last remembered mock object, which is the same as saying\n retrieve the current mock being programmed where you have yet to call\n mock() to change it - thus why the method name is ""self"" since it will be\n be used during the programming of the same mock.\n\n @return \\Mockery\\Mock\n"," Retrieve the last remembered mock object, which is the same as saying",    public function self()    {        $mocks = array_values($this->_mocks);        $index = count($mocks) - 1;        return $mocks[$index];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_444, Return a specific remembered mock according to the array index it\\n was stored to in this container instance\\n\\n @return \\\\Mockery\\\\Mock\\n, Return a specific remembered mock according to the array index it,    public function fetchMock($reference)    {        if (isset($this->_mocks[$reference])) {            return $this->_mocks[$reference];        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_445, see http://php.net/manual/en/language.oop5.basic.php\\n @param string $className\\n @return bool\\n, see http://php.net/manual/en/language.oop5.basic.php,"    public function isValidClassName($className)    {        $pos = strpos($className, '\\');        if ($pos === 0) {            $className = substr($className, 1); // remove the first backslash        }        // all the namespaces and class name should match the regex        $invalidNames = array_filter(explode('\\', $className), function ($name) {            return !preg_match('/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/', $name);        });        return empty($invalidNames);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ExpectationDirector_494, Add a new expectation to the director\\n\\n @param \\\\Mockery\\\\Expectation $expectation\\n, Add a new expectation to the director,    public function addExpectation(\Mockery\Expectation $expectation)    {        $this->_expectations[] = $expectation;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ExpectationDirector_495, Handle a method call being directed by this instance\\\\\\\\n\\\\\\\\n @param array $args\\\\\\\\n @return mixed\\\\\\\\n, Handle a method call being directed by this instance,"    public function call(array $args)    {        $expectation = $this->findExpectation($args);        if (is_null($expectation)) {            $exception = new \Mockery\Exception\NoMatchingExpectationException(                'No matching handler found for '                . $this->_mock->mockery_getName() . '::'                . \Mockery::formatArgs($this->_name, $args)                . '. Either the method was unexpected or its arguments matched'                . ' no expected argument list for this method'                . PHP_EOL . PHP_EOL                . \Mockery::formatObjects($args)            );            $exception->setMock($this->_mock)                ->setMethodName($this->_name)                ->setActualArguments($args);            throw $exception;        }        return $expectation->verifyCall($args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ExpectationDirector_496, Verify all expectations of the director\\\\\\\\n\\\\\\\\n @throws \\\\\\\\\\\\\\\\Mockery\\\\\\\\\\\\\\\\CountValidator\\\\\\\\\\\\\\\\Exception\\\\\\\\n @return void\\\\\\\\n, Verify all expectations of the director,    public function verify()    {        if (!empty($this->_expectations)) {            foreach ($this->_expectations as $exp) {                $exp->verify();            }        } else {            foreach ($this->_defaults as $exp) {                $exp->verify();            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ExpectationDirector_498, Make the given expectation a default for all others assuming it was\n correctly created last\n\n @param \\Mockery\\Expectation $expectation\n, Make the given expectation a default for all others assuming it was,"    public function makeExpectationDefault(\Mockery\Expectation $expectation)    {        $last = end($this->_expectations);        if ($last === $expectation) {            array_pop($this->_expectations);            array_unshift($this->_defaults, $expectation);        } else {            throw new \Mockery\Exception(                'Cannot turn a previously defined expectation into a default'            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ExpectationDirector_499, Search current array of expectations for a match\\n\\n @param array $expectations\\n @param array $args\\n @return mixed\\n, Search current array of expectations for a match,"    protected function _findExpectationIn(array $expectations, array $args)    {        foreach ($expectations as $exp) {            if ($exp->isEligible() && $exp->matchArgs($args)) {                return $exp;            }        }        foreach ($expectations as $exp) {            if ($exp->matchArgs($args)) {                return $exp;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ExpectationDirector_500, Return all expectations assigned to this director\\\\n\\\\n @return array\\\\n, Return all expectations assigned to this director,    public function getExpectations()    {        return $this->_expectations;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_ExpectationDirector_502, Return the number of expectations assigned to this director.\\n\\n @return int\\n, Return the number of expectations assigned to this director.,    public function getExpectationCount()    {        return count($this->getExpectations()) ?: count($this->getDefaultExpectations());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_447, Return a string with the method name and arguments formatted\n\n @param string $name Name of the expected method\n @param array $args List of arguments to the method\n @return string\n, Return a string with the method name and arguments formatted,"    public function __toString()    {        return \Mockery::formatArgs($this->_name, $this->_expectedArgs);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_449, Throws an exception if the expectation has been configured to do so\\\\\\\\n\\\\\\\\n @throws \\\\\\\\\\\\\\\\Throwable\\\\\\\\n @return void\\\\\\\\n, Throws an exception if the expectation has been configured to do so,    private function throwAsNecessary($return)    {        if (!$this->_throw) {            return;        }        if ($return instanceof \Throwable) {            throw $return;        }        return;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_450, Sets public properties with queued values to the mock object\\n\\n @param array $args\\n @return mixed\\n, Sets public properties with queued values to the mock object,"    protected function _setValues()    {        $mockClass = get_class($this->_mock);        $container = $this->_mock->mockery_getContainer();        /** @var Mock[] $mocks */        $mocks = $container->getMocks();        foreach ($this->_setQueue as $name => &$values) {            if (count($values) > 0) {                $value = array_shift($values);                $this->_mock->{$name} = $value;                foreach ($mocks as $mock) {                    if (is_a($mock, $mockClass) && $mock->mockery_isInstance()) {                        $mock->{$name} = $value;                    }                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_451, Fetch the return value for the matching args\\\\\\\\n\\\\\\\\n @param array $args\\\\\\\\n @return mixed\\\\\\\\n, Fetch the return value for the matching args,"    protected function _getReturnValue(array $args)    {        if (count($this->_closureQueue) > 1) {            return call_user_func_array(array_shift($this->_closureQueue), $args);        } elseif (count($this->_closureQueue) > 0) {            return call_user_func_array(current($this->_closureQueue), $args);        } elseif (count($this->_returnQueue) > 1) {            return array_shift($this->_returnQueue);        } elseif (count($this->_returnQueue) > 0) {            return current($this->_returnQueue);        }        return $this->_mock->mockery_returnValueForMethod($this->_name);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_452, Checks if this expectation is eligible for additional calls\\\\\\\\n\\\\\\\\n @return bool\\\\\\\\n, Checks if this expectation is eligible for additional calls,    public function isEligible()    {        foreach ($this->_countValidators as $validator) {            if (!$validator->isEligible($this->_actualCount)) {                return false;            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_454, Verify call order\\n\\n @return void\\n, Verify call order,"    public function validateOrder()    {        if ($this->_orderNumber) {            $this->_mock->mockery_validateOrder((string) $this, $this->_orderNumber, $this->_mock);        }        if ($this->_globalOrderNumber) {            $this->_mock->mockery_getContainer()                ->mockery_validateOrder((string) $this, $this->_globalOrderNumber, $this->_mock);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_455, Verify this expectation\\\\n\\\\n @return void\\\\n, Verify this expectation,    public function verify()    {        foreach ($this->_countValidators as $validator) {            $validator->validate($this->_actualCount);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_457, Check if passed arguments match an argument expectation\\n\\n @param array $args\\n @return bool\\n, Check if passed arguments match an argument expectation,"    public function matchArgs(array $args)    {        if ($this->isArgumentListMatcher()) {            return $this->_matchArg($this->_expectedArgs[0], $args);        }        $argCount = count($args);        if ($argCount !== count((array) $this->_expectedArgs)) {            $lastExpectedArgument = end($this->_expectedArgs);            reset($this->_expectedArgs);            if ($this->isAndAnyOtherArgumentsMatcher($lastExpectedArgument)) {                $args = array_slice($args, 0, array_search($lastExpectedArgument, $this->_expectedArgs, true));                return $this->_matchArgs($args);            }            return false;        }        return $this->_matchArgs($args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_458," Check if the passed arguments match the expectations, one by one.\\n\\n @param array $args\\n @return bool\\n"," Check if the passed arguments match the expectations, one by one.","    protected function _matchArgs($args)    {        $argCount = count($args);        for ($i=0; $i<$argCount; $i++) {            $param =& $args[$i];            if (!$this->_matchArg($this->_expectedArgs[$i], $param)) {                return false;            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_462, Expected arguments have to be matched by the given closure.\\n\\n @param Closure $closure\\n @return self\\n, Expected arguments have to be matched by the given closure.,    private function withArgsMatchedByClosure(Closure $closure)    {        $this->_expectedArgs = [new MultiArgumentClosure($closure)];        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_463, Expected arguments for the expectation passed as an array or a closure that matches each passed argument on\\n each function call.\\n\\n @param array|Closure $argsOrClosure\\n @return self\\n, Expected arguments for the expectation passed as an array or a closure that matches each passed argument on,"    public function withArgs($argsOrClosure)    {        if (is_array($argsOrClosure)) {            $this->withArgsInArray($argsOrClosure);        } elseif ($argsOrClosure instanceof Closure) {            $this->withArgsMatchedByClosure($argsOrClosure);        } else {            throw new \InvalidArgumentException(sprintf('Call to %s with an invalid argument (%s), only array and ' .                'closure are allowed', __METHOD__, $argsOrClosure));        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_465, Set expectation that any arguments are acceptable\\n\\n @return self\\n, Set expectation that any arguments are acceptable,    public function withAnyArgs()    {        $this->_expectedArgs = [new AnyArgs()];        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_466, Expected arguments should partially match the real arguments\n\n @param mixed ...$expectedArgs\n @return self\n, Expected arguments should partially match the real arguments,"    public function withSomeOfArgs(...$expectedArgs)    {        return $this->withArgs(function (...$args) use ($expectedArgs) {            foreach ($expectedArgs as $expectedArg) {                if (!in_array($expectedArg, $args, true)) {                    return false;                }            }            return true;        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_467," Set a return value, or sequential queue of return values\\n\\n @param mixed ...$args\\n @return self\\n"," Set a return value, or sequential queue of return values",    public function andReturn(...$args)    {        $this->_returnQueue = $args;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_469," Return this mock, like a fluent interface\\\\\\\\n\\\\\\\\n @return self\\\\\\\\n"," Return this mock, like a fluent interface",    public function andReturnSelf()    {        return $this->andReturn($this->_mock);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_470, Set a sequential queue of return values with an array\\\\n\\\\n @param array $values\\\\n @return self\\\\n, Set a sequential queue of return values with an array,"    public function andReturnValues(array $values)    {        call_user_func_array(array($this, 'andReturn'), $values);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_471, Set a closure or sequence of closures with which to generate return\\n values. The arguments passed to the expected method are passed to the\\n closures as parameters.\\n\\n @param callable ...$args\\n @return self\\n, Set a closure or sequence of closures with which to generate return,    public function andReturnUsing(...$args)    {        $this->_closureQueue = $args;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_472, Sets up a closure to return the nth argument from the expected method call\\\\\\\\n\\\\\\\\n @param int $index\\\\\\\\n @return self\\\\\\\\n, Sets up a closure to return the nth argument from the expected method call,"    public function andReturnArg($index)    {        if (!is_int($index) || $index < 0) {            throw new \InvalidArgumentException(""Invalid argument index supplied. Index must be a positive integer."");        }        $closure = function (...$args) use ($index) {            if (array_key_exists($index, $args)) {                return $args[$index];            }            throw new \OutOfBoundsException(""Cannot return an argument value. No argument exists for the index $index"");        };        $this->_closureQueue = [$closure];        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_473, Return a self-returning black hole object.\\n\\n @return self\\n, Return a self-returning black hole object.,    public function andReturnUndefined()    {        $this->andReturn(new \Mockery\Undefined());        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_474, Return null. This is merely a language construct for Mock describing.\\n\\n @return self\\n, Return null. This is merely a language construct for Mock describing.,    public function andReturnNull()    {        return $this->andReturn(null);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_476, Register values to be set to a public property each time this expectation occurs\\n\\n @param string $name\\n @param array ...$values\\n @return self\\n, Register values to be set to a public property each time this expectation occurs,"    public function andSet($name, ...$values)    {        $this->_setQueue[$name] = $values;        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_478, Indicates this expectation should occur zero or more times\\\\\\\\n\\\\\\\\n @return self\\\\\\\\n, Indicates this expectation should occur zero or more times,    public function zeroOrMoreTimes()    {        $this->atLeast()->never();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_482, Sets next count validator to the AtLeast instance\n\n @return self\n, Sets next count validator to the AtLeast instance,    public function atLeast()    {        $this->_countValidatorClass = 'Mockery\CountValidator\AtLeast';        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_483, Sets next count validator to the AtMost instance\\n\\n @return self\\n, Sets next count validator to the AtMost instance,    public function atMost()    {        $this->_countValidatorClass = 'Mockery\CountValidator\AtMost';        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_484, Shorthand for setting minimum and maximum constraints on call counts\\\\\\\\n\\\\\\\\n @param int $minimum\\\\\\\\n @param int $maximum\\\\\\\\n, Shorthand for setting minimum and maximum constraints on call counts,"    public function between($minimum, $maximum)    {        return $this->atLeast()->times($minimum)->atMost()->times($maximum);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_485, Set the exception message\n\n @param string $message\n @return $this\n, Set the exception message,    public function because($message)    {        $this->_because = $message;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_487, Setup the ordering tracking on the mock or mock container\\\\n\\\\n @param string $group\\\\n @param object $ordering\\\\n @return int\\\\n, Setup the ordering tracking on the mock or mock container,"    protected function _defineOrdered($group, $ordering)    {        $groups = $ordering->mockery_getGroups();        if (is_null($group)) {            $result = $ordering->mockery_allocateOrder();        } elseif (isset($groups[$group])) {            $result = $groups[$group];        } else {            $result = $ordering->mockery_allocateOrder();            $ordering->mockery_setGroup($group, $result);        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_492, Cloning logic\\n\\n, Cloning logic,    public function __clone()    {        $newValidators = array();        $countValidators = $this->_countValidators;        foreach ($countValidators as $validator) {            $newValidators[] = clone $validator;        }        $this->_countValidators = $newValidators;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_365, Defines the global helper functions\\\\n\\\\n @return void\\\\n, Defines the global helper functions,    public static function globalHelpers()    {        require_once __DIR__ . '/helpers.php';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_369, Static and semantic shortcut for getting a mock from the container\n and applying the spy's expected behavior into it.\n\n @param mixed ...$args\n\n @return \\Mockery\\MockInterface|\\Mockery\\LegacyMockInterface\n, Static and semantic shortcut for getting a mock from the container,"    public static function spy(...$args)    {        if (count($args) && $args[0] instanceof \Closure) {            $args[0] = new ClosureWrapper($args[0]);        }        return call_user_func_array(array(self::getContainer(), 'mock'), $args)->shouldIgnoreMissing();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_370, Static and Semantic shortcut to \\\\Mockery\\\\Container::mock().\\n\\n @param mixed ...$args\\n\\n @return \\\\Mockery\\\\MockInterface|\\\\Mockery\\\\LegacyMockInterface\\n, Static and Semantic shortcut to ,"    public static function instanceMock(...$args)    {        return call_user_func_array(array(self::getContainer(), 'mock'), $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_371," Static shortcut to \\\\Mockery\\\\Container::mock(), first argument names the mock.\\n\\n @param mixed ...$args\\n\\n @return \\\\Mockery\\\\MockInterface|\\\\Mockery\\\\LegacyMockInterface\\n", Static shortcut to ,"    public static function namedMock(...$args)    {        $name = array_shift($args);        $builder = new MockConfigurationBuilder();        $builder->setName($name);        array_unshift($args, $builder);        return call_user_func_array(array(self::getContainer(), 'mock'), $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_372, Static shortcut to \\\\\\\\Mockery\\\\\\\\Container::self().\\\\n\\\\n @throws LogicException\\\\n\\\\n @return \\\\\\\\Mockery\\\\\\\\MockInterface|\\\\\\\\Mockery\\\\\\\\LegacyMockInterface\\\\n, Static shortcut to ,    public static function self()    {        if (is_null(self::$_container)) {            throw new \LogicException('You have not declared any mocks yet');        }        return self::$_container->self();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_373," Static shortcut to closing up and verifying all mocks in the global\n container, and resetting the container static variable to null.\n\n @return void\n", Static shortcut to closing up and verifying all mocks in the global,    public static function close()    {        foreach (self::$_filesToCleanUp as $fileName) {            @unlink($fileName);        }        self::$_filesToCleanUp = [];        if (is_null(self::$_container)) {            return;        }        $container = self::$_container;        self::$_container = null;        $container->mockery_teardown();        $container->mockery_close();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_374, Static fetching of a mock associated with a name or explicit class poser.\\n\\n @param string $name\\n\\n @return \\\\Mockery\\\\Mock\\n, Static fetching of a mock associated with a name or explicit class poser.,    public static function fetchMock($name)    {        return self::getContainer()->fetchMock($name);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_376, Setter for the $_generator static property.\n\n @param \\Mockery\\Generator\\Generator $generator\n, Setter for the $_generator static property.,    public static function setGenerator(Generator $generator)    {        self::$_generator = $generator;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_377, Lazy loader method and getter for\n the generator property.\n\n @return Generator\n, Lazy loader method and getter for,    public static function getGenerator()    {        if (is_null(self::$_generator)) {            self::$_generator = self::getDefaultGenerator();        }        return self::$_generator;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_378, Creates and returns a default generator\\\\\\\\n used inside this class.\\\\\\\\n\\\\\\\\n @return CachingGenerator\\\\\\\\n, Creates and returns a default generator,    public static function getDefaultGenerator()    {        return new CachingGenerator(StringManipulationGenerator::withDefaultPasses());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_379, Setter for the $_loader static property.\\\\n\\\\n @param Loader $loader\\\\n, Setter for the $_loader static property.,    public static function setLoader(Loader $loader)    {        self::$_loader = $loader;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_380, Lazy loader method and getter for\\n the $_loader property.\\n\\n @return Loader\\n, Lazy loader method and getter for,    public static function getLoader()    {        if (is_null(self::$_loader)) {            self::$_loader = self::getDefaultLoader();        }        return self::$_loader;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_381, Gets an EvalLoader to be used as default.\\\\n\\\\n @return EvalLoader\\\\n, Gets an EvalLoader to be used as default.,    public static function getDefaultLoader()    {        return new EvalLoader();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_382, Set the container.\\\\\\\\n\\\\\\\\n @param \\\\\\\\\\\\\\\\Mockery\\\\\\\\\\\\\\\\Container $container\\\\\\\\n\\\\\\\\n @return \\\\\\\\\\\\\\\\Mockery\\\\\\\\\\\\\\\\Container\\\\\\\\n, Set the container.,    public static function setContainer(Mockery\Container $container)    {        return self::$_container = $container;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_383, Reset the container to null.\n\n @return void\n, Reset the container to null.,    public static function resetContainer()    {        self::$_container = null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_399, Lazy loader and Getter for the global\n configuration container.\n\n @return \\Mockery\\Configuration\n, Lazy loader and Getter for the global,    public static function getConfiguration()    {        if (is_null(self::$_config)) {            self::$_config = new \Mockery\Configuration();        }        return self::$_config;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_400, Returns all public instance properties.\\\\n\\\\n @param mixed $object\\\\n @param int $nesting\\\\n\\\\n @return array\\\\n, Returns all public instance properties.,"    private static function extractInstancePublicProperties($object, $nesting)    {        $reflection = new \ReflectionClass(get_class($object));        $properties = $reflection->getProperties(\ReflectionProperty::IS_PUBLIC);        $cleanedProperties = array();        foreach ($properties as $publicProperty) {            if (!$publicProperty->isStatic()) {                $name = $publicProperty->getName();                try {                    $cleanedProperties[$name] = self::cleanupNesting($object->$name, $nesting);                } catch (\Exception $exception) {                    $cleanedProperties[$name] = $exception->getMessage();                }            }        }        return $cleanedProperties;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_401, Utility method used for recursively generating\n an object or array representation.\n\n @param mixed $argument\n @param int $nesting\n\n @return mixed\n, Utility method used for recursively generating,"    private static function cleanupNesting($argument, $nesting)    {        if (is_object($argument)) {            $object = self::objectToArray($argument, $nesting - 1);            $object['class'] = get_class($argument);            return $object;        }        if (is_array($argument)) {            return self::cleanupArray($argument, $nesting - 1);        }        return $argument;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_403, Sets up expectations on the members of the CompositeExpectation and\\\\\\\\n builds up any demeter chain that was passed to shouldReceive.\\\\\\\\n\\\\\\\\n @param \\\\\\\\\\\\\\\\Mockery\\\\\\\\\\\\\\\\LegacyMockInterface $mock\\\\\\\\n @param string $arg\\\\\\\\n @param callable $add\\\\\\\\n @throws Mockery\\\\\\\\\\\\\\\\Exception\\\\\\\\n @return \\\\\\\\\\\\\\\\Mockery\\\\\\\\\\\\\\\\ExpectationInterface\\\\\\\\n, Sets up expectations on the members of the CompositeExpectation and,"    protected static function buildDemeterChain(\Mockery\LegacyMockInterface $mock, $arg, $add)    {        /** @var Mockery\Container $container */        $container = $mock->mockery_getContainer();        $methodNames = explode('->', $arg);        reset($methodNames);        if (!\Mockery::getConfiguration()->mockingNonExistentMethodsAllowed()            && !$mock->mockery_isAnonymous()            && !in_array(current($methodNames), $mock->mockery_getMockableMethods())        ) {            throw new \Mockery\Exception(                'Mockery\'s configuration currently forbids mocking the method '                . current($methodNames) . ' as it does not exist on the class or object '                . 'being mocked'            );        }        /** @var ExpectationInterface|null $expectations */        $expectations = null;        /** @var Callable $nextExp */        $nextExp = function ($method) use ($add) {            return $add($method);        };        $parent = get_class($mock);        while (true) {            $method = array_shift($methodNames);            $expectations = $mock->mockery_getExpectationsFor($method);            if (is_null($expectations) || self::noMoreElementsInChain($methodNames)) {                $expectations = $nextExp($method);                if (self::noMoreElementsInChain($methodNames)) {                    break;                }                $mock = self::getNewDemeterMock($container, $parent, $method, $expectations);            } else {                $demeterMockKey = $container->getKeyOfDemeterMockFor($method, $parent);                if ($demeterMockKey) {                    $mock = self::getExistingDemeterMock($container, $demeterMockKey);                }            }            $parent .= '->' . $method;            $nextExp = function ($n) use ($mock) {                return $mock->shouldReceive($n);            };        }        return $expectations;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Mockery_406, Checks if the passed array representing a demeter\\n chain with the method names is empty.\\n\\n @param array $methodNames\\n\\n @return bool\\n, Checks if the passed array representing a demeter,    private static function noMoreElementsInChain(array $methodNames)    {        return empty($methodNames);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
monicahq_monica_DuskTestCase_2628, Prepare for Dusk test execution.\n\n @beforeClass\n @return void\n, Prepare for Dusk test execution.,    public static function prepare()    {        if (! static::runningInSail()) {            static::startChromeDriver();        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
monicahq_monica_DuskTestCase_2630, Determine whether the Dusk command has disabled headless mode.\n\n @return bool\n, Determine whether the Dusk command has disabled headless mode.,    protected function hasHeadlessDisabled()    {        return isset($_SERVER['DUSK_HEADLESS_DISABLED']) ||               isset($_ENV['DUSK_HEADLESS_DISABLED']);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
monicahq_monica_GetVersion_2610, Execute the console command.\n\n @return void\n, Execute the console command.,    public function handle(): void    {        $this->line(config('monica.app_version'));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
monicahq_monica_ImportCSV_2613, Get the default contact field email id for the account.\n\n @return int\n, Get the default contact field email id for the account.,"    private function contactFieldEmailId()    {        if (! $this->contactFieldEmailId) {            $contactFieldType = ContactFieldType::where('type', 'email')->first();            $this->contactFieldEmailId = $contactFieldType->id;        }        return $this->contactFieldEmailId;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
monicahq_monica_ImportCSV_2614, Get the default contact field phone id for the account.\n\n @return int\n, Get the default contact field phone id for the account.,"    private function contactFieldPhoneId()    {        if (! $this->contactFieldPhoneId) {            $contactFieldType = ContactFieldType::where('type', 'phone')->first();            $this->contactFieldPhoneId = $contactFieldType->id;        }        return $this->contactFieldPhoneId;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
monicahq_monica_TestCase_2632, Set protected/private property of a class.\n\n @param  object &$object\n @param  string $propertyName\n @param  mixed  $value\n @return void\n, Set protected/private property of a class.,"    public function setPrivateValue(&$object, string $propertyName, $value)    {        $reflection = new \ReflectionClass(get_class($object));        $property = $reflection->getProperty($propertyName);        $property->setAccessible(true);        $property->setValue($object, $value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
monicahq_monica_TestCase_2633, Test that the response contains an ObjectDeleted response.\n\n @param TestResponse $response\n @param int $id\n, Test that the response contains an ObjectDeleted response.,"    public function expectObjectDeleted(TestResponse $response, int $id)    {        $response->assertStatus(200);        $response->assertJson([            'deleted' => true,            'id' => $id,        ]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_BuilderHelpers_29, Normalizes a node: Converts builder objects to nodes.\\\\n\\\\n @param Node|Builder $node The node to normalize\\\\n\\\\n @return Node The normalized node\\\\n, Normalizes a node: Converts builder objects to nodes.,    public static function normalizeNode($node) : Node {        if ($node instanceof Builder) {            return $node->getNode();        } elseif ($node instanceof Node) {            return $node;        },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_BuilderHelpers_35," Normalizes a name: Converts string names to Name nodes, optionally allowing expressions.\\\\n\\\\n @param Expr|Name|string $name      The name to normalize\\\\n @param bool             $allowExpr Whether to also allow expressions\\\\n\\\\n @return Name|Expr The normalized name, or expression (if allowed)\\\\n"," Normalizes a name: Converts string names to Name nodes, optionally allowing expressions.","    private static function normalizeNameCommon($name, bool $allowExpr) {        if ($name instanceof Name) {            return $name;        } elseif (is_string($name)) {            if (!$name) {                throw new \LogicException('Name cannot be empty');            }            if ($name[0] === '\\') {                return new Name\FullyQualified(substr($name, 1));            } elseif (0 === strpos($name, 'namespace\\')) {                return new Name\Relative(substr($name, strlen('namespace\\')));            } else {                return new Name($name);            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_BuilderHelpers_36," Normalizes a type: Converts plain-text type names into proper AST representation.\\\\n\\\\n In particular, builtin types become Identifiers, custom types become Names and nullables\\\\n are wrapped in NullableType nodes.\\\\n\\\\n @param string|Name|Identifier|NullableType|UnionType $type The type to normalize\\\\n\\\\n @return Name|Identifier|NullableType|UnionType The normalized type\\\\n", Normalizes a type: Converts plain-text type names into proper AST representation.,"    public static function normalizeType($type) {        if (!is_string($type)) {            if (                !$type instanceof Name && !$type instanceof Identifier &&                !$type instanceof NullableType && !$type instanceof UnionType            ) {                throw new \LogicException(                    'Type must be a string, or an instance of Name, Identifier, NullableType or UnionType'                );            }            return $type;        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_BuilderHelpers_37," Normalizes a value: Converts nulls, booleans, integers,\n floats, strings and arrays into their respective nodes\n\n @param Node\\Expr|bool|null|int|float|string|array $value The value to normalize\n\n @return Expr The normalized value\n"," Normalizes a value: Converts nulls, booleans, integers,","    public static function normalizeValue($value) : Expr {        if ($value instanceof Node\Expr) {            return $value;        } elseif (is_null($value)) {            return new Expr\ConstFetch(                new Name('null')            );        } elseif (is_bool($value)) {            return new Expr\ConstFetch(                new Name($value ? 'true' : 'false')            );        } elseif (is_int($value)) {            return new Scalar\LNumber($value);        } elseif (is_float($value)) {            return new Scalar\DNumber($value);        } elseif (is_string($value)) {            return new Scalar\String_($value);        } elseif (is_array($value)) {            $items = [];            $lastKey = -1;            foreach ($value as $itemKey => $itemValue) {                // for consecutive, numeric keys don't generate keys                if (null !== $lastKey && ++$lastKey === $itemKey) {                    $items[] = new Expr\ArrayItem(                        self::normalizeValue($itemValue)                    );                } else {                    $lastKey = null;                    $items[] = new Expr\ArrayItem(                        self::normalizeValue($itemValue),                        self::normalizeValue($itemKey)                    );                }            }            return new Expr\Array_($items);        } else {            throw new \LogicException('Invalid value');        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_BuilderHelpers_38, Normalizes a doc comment: Converts plain strings to PhpParser\\Comment\\Doc.\n\n @param Comment\\Doc|string $docComment The doc comment to normalize\n\n @return Comment\\Doc The normalized doc comment\n, Normalizes a doc comment: Converts plain strings to PhpParser,    public static function normalizeDocComment($docComment) : Comment\Doc {        if ($docComment instanceof Comment\Doc) {            return $docComment;        } elseif (is_string($docComment)) {            return new Comment\Doc($docComment);        } else {            throw new \LogicException('Doc comment must be a string or an instance of PhpParser\Comment\Doc');        },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_ConstExprEvaluator_55," Evaluates constant expressions.\n\n This evaluator is able to evaluate all constant expressions (as defined by PHP), which can be\n evaluated without further context. If a subexpression is not of this type, a user-provided\n fallback evaluator is invoked. To support all constant expressions that are also supported by\n PHP (and not already handled by this class), the fallback evaluator must be able to handle the\n following node types:\n\n      \n The fallback evaluator should throw ConstExprEvaluationException for nodes it cannot evaluate.\n\n The evaluation is dependent on runtime configuration in two respects: Firstly, floating\n point to string conversions are affected by the precision ini setting. Secondly, they are also\n affected by the LC_NUMERIC locale.\n", Evaluates constant expressions.,"class ConstExprEvaluator{    private $fallbackEvaluator;    /**     * Create a constant expression evaluator.     *     * The provided fallback evaluator is invoked whenever a subexpression cannot be evaluated. See     * class doc comment for more information.     *     * @param callable|null $fallbackEvaluator To call if subexpression cannot be evaluated     */    public function __construct(callable $fallbackEvaluator = null) {        $this->fallbackEvaluator = $fallbackEvaluator ?? function(Expr $expr) {            throw new ConstExprEvaluationException(                ""Expression of type {$expr->getType()} cannot be evaluated""            );        };    }    /**     * Silently evaluates a constant expression into a PHP value.     *     * Thrown Errors, warnings or notices will be converted into a ConstExprEvaluationException.     * The original source of the exception is available through getPrevious().     *     * If some part of the expression cannot be evaluated, the fallback evaluator passed to the     * constructor will be invoked. By default, if no fallback is provided, an exception of type     * ConstExprEvaluationException is thrown.     *     * See class doc comment for caveats and limitations.     *     * @param Expr $expr Constant expression to evaluate     * @return mixed Result of evaluation     *     * @throws ConstExprEvaluationException if the expression cannot be evaluated or an error occurred     */    public function evaluateSilently(Expr $expr) {        set_error_handler(function($num, $str, $file, $line) {            throw new \ErrorException($str, 0, $num, $file, $line);        });        try {            return $this->evaluate($expr);        } catch (\Throwable $e) {            if (!$e instanceof ConstExprEvaluationException) {                $e = new ConstExprEvaluationException(                    ""An error occurred during constant expression evaluation"", 0, $e);            }            throw $e;        } finally {            restore_error_handler();        }    }    /**     * Directly evaluates a constant expression into a PHP value.     *     * May generate Error exceptions, warnings or notices. Use evaluateSilently() to convert these     * into a ConstExprEvaluationException.     *     * If some part of the expression cannot be evaluated, the fallback evaluator passed to the     * constructor will be invoked. By default, if no fallback is provided, an exception of type     * ConstExprEvaluationException is thrown.     *     * See class doc comment for caveats and limitations.     *     * @param Expr $expr Constant expression to evaluate     * @return mixed Result of evaluation     *     * @throws ConstExprEvaluationException if the expression cannot be evaluated     */    public function evaluateDirectly(Expr $expr) {        return $this->evaluate($expr);    }    private function evaluate(Expr $expr) {        if ($expr instanceof Scalar\LNumber            || $expr instanceof Scalar\DNumber            || $expr instanceof Scalar\String_        ) {            return $expr->value;        }        if ($expr instanceof Expr\Array_) {            return $this->evaluateArray($expr);        }        // Unary operators        if ($expr instanceof Expr\UnaryPlus) {            return +$this->evaluate($expr->expr);        }        if ($expr instanceof Expr\UnaryMinus) {            return -$this->evaluate($expr->expr);        }        if ($expr instanceof Expr\BooleanNot) {            return !$this->evaluate($expr->expr);        }        if ($expr instanceof Expr\BitwiseNot) {            return ~$this->evaluate($expr->expr);        }        if ($expr instanceof Expr\BinaryOp) {            return $this->evaluateBinaryOp($expr);        }        if ($expr instanceof Expr\Ternary) {            return $this->evaluateTernary($expr);        }        if ($expr instanceof Expr\ArrayDimFetch && null !== $expr->dim) {            return $this->evaluate($expr->var)[$this->evaluate($expr->dim)];        }        if ($expr instanceof Expr\ConstFetch) {            return $this->evaluateConstFetch($expr);        }        return ($this->fallbackEvaluator)($expr);    }    private function evaluateArray(Expr\Array_ $expr) {        $array = [];        foreach ($expr->items as $item) {            if (null !== $item->key) {                $array[$this->evaluate($item->key)] = $this->evaluate($item->value);            } else {                $array[] = $this->evaluate($item->value);            }        }        return $array;    }    private function evaluateTernary(Expr\Ternary $expr) {        if (null === $expr->if) {            return $this->evaluate($expr->cond) ?: $this->evaluate($expr->else);        }        return $this->evaluate($expr->cond)            ? $this->evaluate($expr->if)            : $this->evaluate($expr->else);    }    private function evaluateBinaryOp(Expr\BinaryOp $expr) {        if ($expr instanceof Expr\BinaryOp\Coalesce            && $expr->left instanceof Expr\ArrayDimFetch        ) {            // This needs to be special cased to respect BP_VAR_IS fetch semantics            return $this->evaluate($expr->left->var)[$this->evaluate($expr->left->dim)]                ?? $this->evaluate($expr->right);        }        // The evaluate() calls are repeated in each branch, because some of the operators are        // short-circuiting and evaluating the RHS in advance may be illegal in that case        $l = $expr->left;        $r = $expr->right;        switch ($expr->getOperatorSigil()) {            case '&':   return $this->evaluate($l) &   $this->evaluate($r);            case '|':   return $this->evaluate($l) |   $this->evaluate($r);            case '^':   return $this->evaluate($l) ^   $this->evaluate($r);            case '&&':  return $this->evaluate($l) &&  $this->evaluate($r);            case '||':  return $this->evaluate($l) ||  $this->evaluate($r);            case '??':  return $this->evaluate($l) ??  $this->evaluate($r);            case '.':   return $this->evaluate($l) .   $this->evaluate($r);            case '/':   return $this->evaluate($l) /   $this->evaluate($r);            case '==':  return $this->evaluate($l) ==  $this->evaluate($r);            case '>':   return $this->evaluate($l) >   $this->evaluate($r);            case '>=':  return $this->evaluate($l) >=  $this->evaluate($r);            case '===': return $this->evaluate($l) === $this->evaluate($r);            case 'and': return $this->evaluate($l) and $this->evaluate($r);            case 'or':  return $this->evaluate($l) or  $this->evaluate($r);            case 'xor': return $this->evaluate($l) xor $this->evaluate($r);            case '-':   return $this->evaluate($l) -   $this->evaluate($r);            case '%':   return $this->evaluate($l) %   $this->evaluate($r);            case '*':   return $this->evaluate($l) *   $this->evaluate($r);            case '!=':  return $this->evaluate($l) !=  $this->evaluate($r);            case '!==': return $this->evaluate($l) !== $this->evaluate($r);            case '+':   return $this->evaluate($l) +   $this->evaluate($r);            case '**':  return $this->evaluate($l) **  $this->evaluate($r);            case '<<':  return $this->evaluate($l) <<  $this->evaluate($r);            case '>>':  return $this->evaluate($l) >>  $this->evaluate($r);            case '<':   return $this->evaluate($l) <   $this->evaluate($r);            case '<=':  return $this->evaluate($l) <=  $this->evaluate($r);            case '<=>': return $this->evaluate($l) <=> $this->evaluate($r);        }        throw new \Exception('Should not happen');    }    private function evaluateConstFetch(Expr\ConstFetch $expr) {        $name = $expr->name->toLowerString();        switch ($name) {            case 'null': return null;            case 'false': return false;            case 'true': return true;        }        return ($this->fallbackEvaluator)($expr);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_ConstExprEvaluator_56," Silently evaluates a constant expression into a PHP value.\\\\n\\\\n Thrown Errors, warnings or notices will be converted into a ConstExprEvaluationException.\\\\n The original source of the exception is available through getPrevious().\\\\n\\\\n If some part of the expression cannot be evaluated, the fallback evaluator passed to the\\\\n constructor will be invoked. By default, if no fallback is provided, an exception of type\\\\n ConstExprEvaluationException is thrown.\\\\n\\\\n See class doc comment for caveats and limitations.\\\\n\\\\n @param Expr $expr Constant expression to evaluate\\\\n @return mixed Result of evaluation\\\\n\\\\n @throws ConstExprEvaluationException if the expression cannot be evaluated or an error occurred\\\\n", Silently evaluates a constant expression into a PHP value.,"    public function evaluateSilently(Expr $expr) {        set_error_handler(function($num, $str, $file, $line) {            throw new \ErrorException($str, 0, $num, $file, $line);        });",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_Error_66, Gets the start column (1-based) into the line where the error started.\\\\\\\\n\\\\\\\\n @param string $code Source code of the file\\\\\\\\n @return int\\\\\\\\n, Gets the start column (1-based) into the line where the error started.,    public function getStartColumn(string $code) : int {        if (!$this->hasColumnInfo()) {            throw new \RuntimeException('Error does not have column information');        },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_Error_69, Converts a file offset into a column.\n\n @param string $code Source code that $pos indexes into\n @param int    $pos  0-based position in $code\n\n @return int 1-based column (relative to start of line)\n, Converts a file offset into a column.,"    private function toColumn(string $code, int $pos) : int {        if ($pos > strlen($code)) {            throw new \RuntimeException('Invalid position information');        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AllConfig_1332," TODO - FIXME This fixes an issue with base.php that cause cyclic\\\\n dependencies, especially with autoconfig setup\\\\n\\\\n Replace this by properly injected database connection. Currently the\\\\n base.php triggers the getDatabaseConnection too early which causes in\\\\n autoconfig setup case a too early distributed database connection and\\\\n the autoconfig then needs to reinit all already initialized dependencies\\\\n that use the database connection.\\\\n\\\\n otherwise a SQLite database is created in the wrong directory\\\\n because the database connection was created with an uninitialized config\\\\n", TODO - FIXME This fixes an issue with base.php that cause cyclic,private function fixDIInit() {if ($this->connection === null) {$this->connection = \OC::$server->getDatabaseConnection();},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1355, Deletes a key\\n\\n @param string $app app\\n @param string $key key\\n @return boolean|null\\n, Deletes a key,"public function deleteKey($app, $key) {$this->emittingCall(function () use (&$app, &$key) {$this->loadConfigValues();$sql = $this->conn->getQueryBuilder();$sql->delete('appconfig')->where($sql->expr()->eq('appid', $sql->createParameter('app')))->andWhere($sql->expr()->eq('configkey', $sql->createParameter('configkey')))->setParameter('app', $app)->setParameter('configkey', $key);$sql->execute();unset($this->cache[$app][$key]);return true;}, [",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1356, Remove app from appconfig\\n\\n @param string $app app\\n @return boolean|null\\n\\n Removes all keys in appconfig belonging to the app.\\n, Remove app from appconfig,"public function deleteApp($app) {$this->emittingCall(function () use (&$app) {$this->loadConfigValues();$sql = $this->conn->getQueryBuilder();$sql->delete('appconfig')->where($sql->expr()->eq('appid', $sql->createParameter('app')))->setParameter('app', $app);$sql->execute();unset($this->cache[$app]);return true;}, [",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1357," get multiple values, either the app or key can be used as wildcard by setting it to false\\n\\n @param string|false $app\\n @param string|false $key\\n @return array|false\\n"," get multiple values, either the app or key can be used as wildcard by setting it to false","public function getValues($app, $key) {if (($app !== false) === ($key !== false)) {return false;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_Avatar_1371, Get the extension of the avatar. If there is no avatar throw Exception\\\\n\\\\n @return string\\\\n @throws NotFoundException\\\\n @throws StorageNotAvailableException\\\\n, Get the extension of the avatar. If there is no avatar throw Exception,"private function getExtension() {if ($this->storage->file_exists(""{$this->path}/avatar.jpg"")) {return 'jpg';}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_CheckSetupController_1421, Checks if the ownCloud server can connect to the internet using HTTPS and HTTP\n @return bool\n, Checks if the ownCloud server can connect to the internet using HTTPS and HTTP,"private function isInternetConnectionWorking() {if ($this->config->getSystemValue('has_internet_connection', true) === false) {return false;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_CheckSetupController_1423, Whether /dev/urandom is available to the PHP controller\n\n @return bool\n, Whether /dev/urandom is available to the PHP controller,"private function isUrandomAvailable() {if (@\file_exists('/dev/urandom')) {$file = \fopen('/dev/urandom', 'rb');if ($file) {\fclose($file);return true;}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_CommentNode_1253," Returns a list of properties for this nodes.\\\\n\\\\n The properties list is a list of propertynames the client requested,\\\\n encoded in clark-notation {xmlnamespace}tagname\\\\n\\\\n If the array is empty, it means 'all properties' were requested.\\\\n\\\\n Note that it's fine to liberally give properties back, instead of\\\\n conforming to the list of requested properties.\\\\n The Server class will filter out the extra.\\\\n\\\\n @param array|null $properties requested properties or null for all\\\\n @return array\\\\n", Returns a list of properties for this nodes.,public function getProperties($properties) {if (($properties === null) || ($properties === [])) {$properties = \array_keys($this->properties);},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_Config_1380," Sets and deletes values and writes the config.php\n\n @param array $configs Associative array with `key => value` pairs\n                       If value is null, the config key will be deleted\n", Sets and deletes values and writes the config.php,public function setValues(array $configs) {if ($this->isReadOnly()) {throw new \Exception('Config file is read only.');},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_ContactsManager_1396, Load all address books registered with 'register'\\n, Load all address books registered with 'register',protected function loadAddressBooks() {foreach ($this->addressBookLoaders as $callable) {$callable($this);},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_CorsController_1436, WhiteLists a domain for CORS\\\\n\\\\n @NoAdminRequired\\\\n @NoSubadminRequired\\\\n\\\\n @param string $domain The domain to whitelist\\\\n @return JSONResponse\\\\n, WhiteLists a domain for CORS,"public function addDomain($domain) {if ($this->isValidUrl($domain)) {$userId = $this->userId;$domains = \json_decode($this->config->getUserValue($userId, 'core', 'domains', '[]'), true);$domains = \array_filter($domains);\array_push($domains, $domain);// In case same domain is added$domains = \array_unique($domains);// Store as comma separated string$domainsString = \json_encode($domains);$this->config->setUserValue($userId, 'core', 'domains', $domainsString);$this->logger->debug(""The domain {$domain} has been white-listed."", ['app' => $this->appName]);return new JSONResponse([ 'domains' => $domains]);} else {$errorMsg = $this->l10n->t(""Invalid url '%s'. Urls should be set up like 'http://www.example.com' or 'https://www.example.com'"", \strip_tags($domain));return new JSONResponse([ 'message' => $errorMsg ]);}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_EntityCollection_1260," Class EntityCollection\\\\n\\\\n this represents a specific holder of comments, identified by an entity type\\\\n (class member $name) and an entity id (class member $id).\\\\n\\\\n @package OCA\\\\\\\\Comments\\\\\\\\Dav\\\\n", Class EntityCollection,"class EntityCollection extends RootCollection implements IProperties {public const PROPERTY_NAME_READ_MARKER  = '{http://owncloud.org/ns}readMarker';/** @var  string */protected $id;/** * @param string $id * @param string $name * @param ICommentsManager $commentsManager * @param IUserManager $userManager * @param IUserSession $userSession * @param EventDispatcherInterface $dispatcher * @param ILogger $logger */public function __construct($id,$name,ICommentsManager $commentsManager,IUserManager $userManager,IUserSession $userSession,EventDispatcherInterface $dispatcher,ILogger $logger) {parent::__construct($commentsManager, $userManager, $userSession, $dispatcher, $logger);foreach (['id', 'name'] as $property) {$$property = \trim($$property);if (empty($$property) || !\is_string($$property)) {throw new \InvalidArgumentException('""' . $property . '"" parameter must be non-empty string');}}$this->id = $id;$this->name = $name;}/** * returns the ID of this entity * * @return string */public function getId() {return $this->id;}/** * Returns a specific child node, referenced by its name * * This method must throw Sabre\DAV\Exception\NotFound if the node does not * exist. * * @param string $name * @return \Sabre\DAV\INode * @throws NotFound */public function getChild($name) {try {$comment = $this->commentsManager->get($name);return new CommentNode($this->commentsManager,$comment,$this->userManager,$this->userSession,$this->logger);} catch (NotFoundException $e) {throw new NotFound();}}/** * Returns an array with all the child nodes * * @return \Sabre\DAV\INode[] */public function getChildren() {return $this->findChildren();}/** * Returns an array of comment nodes. Result can be influenced by offset, * limit and date time parameters. * * @param int $limit * @param int $offset * @param \DateTime|null $datetime * @return CommentNode[] */public function findChildren($limit = 0, $offset = 0, \DateTime $datetime = null) {$comments = $this->commentsManager->getForObject($this->name, $this->id, $limit, $offset, $datetime);$result = [];foreach ($comments as $comment) {$result[] = new CommentNode($this->commentsManager,$comment,$this->userManager,$this->userSession,$this->logger);}return $result;}/** * Checks if a child-node with the specified name exists * * @param string $name * @return bool */public function childExists($name) {try {$this->commentsManager->get($name);return true;} catch (NotFoundException $e) {return false;}}/** * Sets the read marker to the specified date for the logged in user * * @param \DateTime $value * @return bool */public function setReadMarker($value) {$dateTime = new \DateTime($value);$user = $this->userSession->getUser();$this->commentsManager->setReadMark($this->name, $this->id, $dateTime, $user);return true;}/** * @inheritdoc */public function propPatch(PropPatch $propPatch) {$propPatch->handle(self::PROPERTY_NAME_READ_MARKER, [$this, 'setReadMarker']);}/** * @inheritdoc */public function getProperties($properties) {$marker = null;$user = $this->userSession->getUser();if ($user !== null) {$marker = $this->commentsManager->getReadMark($this->name, $this->id, $user);}return [self::PROPERTY_NAME_READ_MARKER => $marker];}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_EntityCollection_1265, Checks if a child-node with the specified name exists\\n\\n @param string $name\\n @return bool\\n, Checks if a child-node with the specified name exists,public function childExists($name) {try {$this->commentsManager->get($name);return true;} catch (NotFoundException $e) {return false;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_Extension_1231, A string naming the css class for the icon to be used can be returned.\n If no icon is known for the given type false is to be returned.\n\n @param string $type\n @return string|false\n, A string naming the css class for the icon to be used can be returned.,public function getTypeIcon($type) {switch ($type) {case self::APP_NAME:return 'icon-comment';},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_Extension_1235," Check if the author is the current user\n\n @param string $user Parameter e.g. `<user display-name=""admin"">admin</user>`\n @return bool\n", Check if the author is the current user,protected function authorIsCurrentUser($user) {try {return \strip_tags($user) === $this->activityManager->getCurrentUserId();} catch (\UnexpectedValueException $e) {return false;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_Extension_1236, The extension can define the type of parameters for translation\n\n Currently known types are:\n  \n @param string $app\n @param string $text\n @return array|false\n, The extension can define the type of parameters for translation,"public function getSpecialParameterList($app, $text) {if ($app === self::APP_NAME) {switch ($text) {case self::ADD_COMMENT_SUBJECT:return [0 => 'username',1 => 'file',];}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_OCPSinceChecker_1294, Checks tags for invalid versions\\n, Checks tags for invalid versions,"private function checkInvalidVersions($text) {foreach (self::INVALID_VERSIONS as $ver) {if (\preg_match('/' . \preg_quote('@since') . '\s*' . \preg_quote($ver) . '/', $text) === 1) {return $ver;}if (\preg_match('/' . \preg_quote('@deprecated') . '\s*' . \preg_quote($ver) . '/', $text) === 1) {return $ver;}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_RootCollection_1275," initializes the collection. At this point of time, we need the logged in\n user. Since it is not the case when the instance is created, we cannot\n have this in the constructor.\n\n @throws NotAuthenticated\n"," initializes the collection. At this point of time, we need the logged in",protected function initCollections() {if ($this->entityTypeCollections !== null) {return;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
pagekit_pagekit_ExtensionTranslateCommand_892, Returns all files of an extension to extract translations.\\\\\\\\n\\\\\\\\n @param  string $path\\\\\\\\n @return array\\\\\\\\n, Returns all files of an extension to extract translations.,"    protected function getFiles($path, $extension)    {        $files = Finder::create()->files()->in($path);        if ($extension == ""system"") {            // add installer files            $files->in($this->container->path().'/app/installer');        }        return $files->name('*.{php,vue,js,html,twig}');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
pagekit_pagekit_ExtensionTranslateCommand_893, Returns the extension path.\\\\n\\\\n @param  string $path\\\\n @return array\\\\n, Returns the extension path.,"    protected function getPath($path)    {        if ($path == 'system') {            // system module            $root = $this->container->path().'/app';        } else {            // extensions            $root = $this->container->path().'/packages';        }        if (!is_dir($path = ""$root/$path"")) {            $this->abort(""Can't find extension in '$path'"");        }        return $path;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
pagekit_pagekit_ExtensionTranslateCommand_894, Writes the translation file for the given extension.\\n\\n @param array  $messages\\n @param string $extension\\n @param string $path\\n, Writes the translation file for the given extension.,"    protected function writeTranslationFile($messages, $extension, $path)    {        foreach ($messages as $domain => $strings) {            $data = $this->getHeader($extension, $domain);            foreach ($strings as $string) {                $string = str_replace('""', '\""', $string);                $data .= ""msgid \"""".$string.""\""\nmsgstr \""\""\n\n"";            }            $refFile = $path.'/'.$domain.'.pot';            if (!file_exists($refFile) || !($compare = preg_replace('/^""POT-Creation-Date: (.*)$/im', '', [file_get_contents($refFile), $data]) and $compare[0] === $compare[1])) {                file_put_contents($refFile, $data);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
paragonie_random_compat_StatTest_740," This should be between 55% and 75%, always\n"," This should be between 55% and 75%, always","    public function testCoverage()    {        $integers = array_fill(0, 2000, 0);        for ($i = 0; $i < 2000; ++$i) {            ++$integers[random_int(0,1999)];        }        $coverage = 0;        for ($i = 0; $i < 2000; ++$i) {            if ($integers[$i] > 0) {                ++$coverage;            }        }        $this->assertTrue($coverage >= 1150);        $this->assertTrue($coverage <= 1350);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
paragonie_random_compat_random_723," We don't have any more options, so let's throw an exception right now\\n and hope the developer won't let it fail silently.\\n\\n @param mixed $length\\n @psalm-suppress InvalidReturnType\\n @throws Exception\\n @return string\\n"," We don't have any more options, so let's throw an exception right now","        function random_bytes($length)        {            unset($length); // Suppress ""variable not used"" warnings.            throw new Exception(                'There is no suitable CSPRNG installed on your system'            );            return '';        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
paragonie_random_compat_random_bytes_libsodium_legacy_727," If the libsodium PHP extension is loaded, we'll use it above any other\n solution.\n\n libsodium-php project:\n @ref https://github.com/jedisct1/libsodium-php\n\n @param int $bytes\n\n @throws Exception\n\n @return string\n"," If the libsodium PHP extension is loaded, we'll use it above any other","    function random_bytes($bytes)    {        try {            /** @var int $bytes */            $bytes = RandomCompat_intval($bytes);        } catch (TypeError $ex) {            throw new TypeError(                'random_bytes(): $bytes must be an integer'            );        }        if ($bytes < 1) {            throw new Error(                'Length must be greater than 0'            );        }        /**         * @var string         */        $buf = '';        /**         * \Sodium\randombytes_buf() doesn't allow more than 2147483647 bytes to be         * generated in one invocation.         */        if ($bytes > 2147483647) {            for ($i = 0; $i < $bytes; $i += 1073741824) {                $n = ($bytes - $i) > 1073741824                    ? 1073741824                    : $bytes - $i;                $buf .= Sodium::randombytes_buf((int) $n);            }        } else {            $buf .= Sodium::randombytes_buf((int) $bytes);        }        if (is_string($buf)) {            if (RandomCompat_strlen($buf) === $bytes) {                return $buf;            }        }        /**         * If we reach here, PHP has failed us.         */        throw new Exception(            'Could not gather sufficient random data'        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
paragonie_random_compat_random_int_729, Fetch a random integer between $min and $max inclusive\n\n @param int $min\n @param int $max\n\n @throws Exception\n\n @return int\n, Fetch a random integer between $min and $max inclusive,"    function random_int($min, $max)    {        /**         * Type and input logic checks         *         * If you pass it a float in the range (~PHP_INT_MAX, PHP_INT_MAX)         * (non-inclusive), it will sanely cast it to an int. If you it's equal to         * ~PHP_INT_MAX or PHP_INT_MAX, we let it fail as not an integer. Floats         * lose precision, so the <= and => operators might accidentally let a float         * through.         */        try {            /** @var int $min */            $min = RandomCompat_intval($min);        } catch (TypeError $ex) {            throw new TypeError(                'random_int(): $min must be an integer'            );        }        try {            /** @var int $max */            $max = RandomCompat_intval($max);        } catch (TypeError $ex) {            throw new TypeError(                'random_int(): $max must be an integer'            );        }        /**         * Now that we've verified our weak typing system has given us an integer,         * let's validate the logic then we can move forward with generating random         * integers along a given range.         */        if ($min > $max) {            throw new Error(                'Minimum value must be less than or equal to the maximum value'            );        }        if ($max === $min) {            return (int) $min;        }        /**         * Initialize variables to 0         *         * We want to store:         * $bytes => the number of random bytes we need         * $mask => an integer bitmask (for use with the &) operator         *          so we can minimize the number of discards         */        $attempts = $bits = $bytes = $mask = $valueShift = 0;        /** @var int $attempts */        /** @var int $bits */        /** @var int $bytes */        /** @var int $mask */        /** @var int $valueShift */        /**         * At this point, $range is a positive number greater than 0. It might         * overflow, however, if $max - $min > PHP_INT_MAX. PHP will cast it to         * a float and we will lose some precision.         *         * @var int|float $range         */        $range = $max - $min;        /**         * Test for integer overflow:         */        if (!is_int($range)) {            /**             * Still safely calculate wider ranges.             * Provided by @CodesInChaos, @oittaa             *             * @ref https://gist.github.com/CodesInChaos/03f9ea0b58e8b2b8d435             *             * We use ~0 as a mask in this case because it generates all 1s             *             * @ref https://eval.in/400356 (32-bit)             * @ref http://3v4l.org/XX9r5  (64-bit)             */            $bytes = PHP_INT_SIZE;            /** @var int $mask */            $mask = ~0;        } else {            /**             * $bits is effectively ceil(log($range, 2)) without dealing with             * type juggling             */            while ($range > 0) {                if ($bits % 8 === 0) {                    ++$bytes;                }                ++$bits;                $range >>= 1;                /** @var int $mask */                $mask = $mask << 1 | 1;            }            $valueShift = $min;        }        /** @var int $val */        $val = 0;        /**         * Now that we have our parameters set up, let's begin generating         * random integers until one falls between $min and $max         */        /** @psalm-suppress RedundantCondition */        do {            /**             * The rejection probability is at most 0.5, so this corresponds             * to a failure probability of 2^-128 for a working RNG             */            if ($attempts > 128) {                throw new Exception(                    'random_int: RNG is broken - too many rejections'                );            }            /**             * Let's grab the necessary number of random bytes             */            $randomByteString = random_bytes($bytes);            /**             * Let's turn $randomByteString into an integer             *             * This uses bitwise operators (<< and |) to build an integer             * out of the values extracted from ord()             *             * Example: [9F] | [6D] | [32] | [0C] =>             *   159 + 27904 + 3276800 + 201326592 =>             *   204631455             */            $val &= 0;            for ($i = 0; $i < $bytes; ++$i) {                $val |= ord($randomByteString[$i]) << ($i * 8);            }            /** @var int $val */            /**             * Apply mask             */            $val &= $mask;            $val += $valueShift;            ++$attempts;            /**             * If $val overflows to a floating point number,             * ... or is larger than $max,             * ... or smaller than $min,             * then try again.             */        } while (!is_int($val) || $val > $max || $val < $min);        return (int) $val;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_Figlet_518, It is preg_replace callback function that makes horizontal letter smushing\n\n @param array $r preg_replace matches array\n\n @return string\n @access private\n, It is preg_replace callback function that makes horizontal letter smushing,"    function _rep($r)    {        if ($this->oldlayout & 1 && $r[1] == $r[2]) {            $this->smush_flag = 1;            return $r[1];        }        if ($this->oldlayout & 2) {            $symb = '|/\\[]{}()<>';            if ($r[1] == '_' && strpos($symb, $r[2]) !== false ||                $r[2] == '_' && strpos($symb, $r[1]) !== false) {                $this->smush_flag = 1;                return $r[1];            }        }        if ($this->oldlayout & 4) {            $classes = '|/\\[]{}()<>';            if (($left = strpos($classes, $r[1])) !== false) {                if (($right = strpos($classes, $r[2])) !== false) {                    $this->smush_flag = 1;                    return $right > $left ? $r[2] : $r[1];                }            }        }        if ($this->oldlayout & 8) {            $t = array('[' => ']', ']' => '[', '{' => '}', '}' => '{',            '(' => ')', ')' => '(');            if (isset($t[$r[2]]) && $r[1] == $t[$r[2]]) {                $this->smush_flag = 1;                return '|';            }        }        if ($this->oldlayout & 16) {            $t = array(""/\\"" => '|', ""\\/"" => 'Y', '><' => 'X');            if (isset($t[$r[1].$r[2]])) {                $this->smush_flag = 1;                return $t[$r[1].$r[2]];            }        }        if ($this->oldlayout & 32) {            if ($r[1] == $r[2] && $r[1] == $this->hardblank) {                $this->smush_flag = 1;                return $this->hardblank;            }        }        return $r[1].""\00"".$r[2];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_MimeMailParser.class_493, Retrieve the Email Headers\\n @return Array\\n, Retrieve the Email Headers,public function getHeaders() {if (isset($this->parts[1])) {return $this->getPartHeaders($this->parts[1]);} else {throw new Exception('MimeMailParser::setPath() or MimeMailParser::setText() must be called before retrieving email headers.');},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_MimeMailParser.class_495, Retrieve a specific Email Header\n @return String\n @param $name String Header name\n, Retrieve a specific Email Header,public function getHeader($name) {if (isset($this->parts[1])) {$headers = $this->getPartHeaders($this->parts[1]);if (isset($headers[$name])) {return $headers[$name];}} else {throw new Exception('MimeMailParser::setPath() or MimeMailParser::setText() must be called before retrieving email headers.');},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_MimeMailParser.class_497, Return the Headers for a MIME part\\n @return Array\\n @param $part Array\\n, Return the Headers for a MIME part,private function getPartHeaders($part) {if (isset($part['headers'])) {return $part['headers'];},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_attachment.class_514, Retrieve the file extension\n @return String\n, Retrieve the file extension,"public function getFileExtension() {if (!$this->extension) {$ext = substr(strrchr($this->filename, '.'), 1);if ($ext == 'gz') {// special case, tar.gz// todo: other special cases?$ext = preg_match(""/\.tar\.gz$/i"", $ext) ? 'tar.gz' : 'gz';}$this->extension = $ext;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_525," Check that a string looks roughly like an email address should\\n Static so it can be used without instantiation\\n Tries to use PHP built-in validator in the filter extension (from PHP 5.2), falls back to a reasonably competent regex validator\\n Conforms approximately to RFC2822\\n @link http://www.hexillion.com/samples/#Regex Original pattern found here\\n @param string $address The email address to check\\n @return boolean\\n @static\\n @access public\\n", Check that a string looks roughly like an email address should,"  public static function ValidateAddress($address) {    if (function_exists('filter_var')) { //Introduced in PHP 5.2      if(filter_var($address, FILTER_VALIDATE_EMAIL) === FALSE) {        return false;      } else {        return true;      }    } else {      return preg_match('/^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!\.)){0,61}[a-zA-Z0-9_-]?\.)+[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!$)){0,61}[a-zA-Z0-9_]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/', $address);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_539, Sets the message type.\\n @access private\\n @return void\\n, Sets the message type.,  private function SetMessageType() {    if(count($this->attachment) < 1 && strlen($this->AltBody) < 1) {      $this->message_type = 'plain';    } else {      if(count($this->attachment) > 0) {        $this->message_type = 'attachments';      }      if(strlen($this->AltBody) > 0 && count($this->attachment) < 1) {        $this->message_type = 'alt';      }      if(strlen($this->AltBody) > 0 && count($this->attachment) > 0) {        $this->message_type = 'alt_attachments';      }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_544, Checks if a string contains multibyte characters.\\n @access public\\n @param string $str multi-byte text to wrap encode\\n @return bool\\n, Checks if a string contains multibyte characters.,"  public function HasMultiBytes($str) {    if (function_exists('mb_strlen')) {      return (strlen($str) > mb_strlen($str, $this->CharSet));    } else { // Assume no multibytes (we can't handle without mbstring functions anyway)      return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_548, Clears all recipients assigned in the TO array.  Returns void.\n @return void\n, Clears all recipients assigned in the TO array.  Returns void.,  public function ClearAddresses() {    foreach($this->to as $to) {      unset($this->all_recipients[strtolower($to[0])]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_557, Returns the server hostname or 'localhost.localdomain' if unknown.\n @access private\n @return string\n, Returns the server hostname or 'localhost.localdomain' if unknown.,  private function ServerHostname() {    if (!empty($this->Hostname)) {      $result = $this->Hostname;    } elseif (isset($_SERVER['SERVER_NAME'])) {      $result = $_SERVER['SERVER_NAME'];    } else {      $result = 'localhost.localdomain';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_558, Returns a message in the appropriate language.\\n @access private\\n @return string\\n, Returns a message in the appropriate language.,  private function Lang($key) {    if(count($this->language) < 1) {      $this->SetLanguage('en'); // set the default language    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer_572, Sets Mailer to send message using the qmail MTA.\n @return void\n, Sets Mailer to send message using the qmail MTA.,"  public function IsQmail() {    if (stristr(ini_get('sendmail_path'), 'qmail')) {      $this->Sendmail = '/var/qmail/bin/sendmail';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer_574, Creates message and assigns Mailer. If the message is\\n not sent successfully then it returns false.  Use the ErrorInfo\\n variable to view description of the error.\\n @return bool\\n, Creates message and assigns Mailer. If the message is,"  public function Send() {    try {      if ((count($this->to) + count($this->cc) + count($this->bcc)) < 1) {        throw new phpmailerException($this->Lang('provide_address'), self::STOP_CRITICAL);      }      // Set whether the message is multipart/alternative      if(!empty($this->AltBody)) {        $this->ContentType = 'multipart/alternative';      }      $this->error_count = 0; // reset errors      $this->SetMessageType();      $header = $this->CreateHeader();      $body = $this->CreateBody();      if (empty($this->Body)) {        throw new phpmailerException($this->Lang('empty_message'), self::STOP_CRITICAL);      }      // digitally sign with DKIM if enabled      if ($this->DKIM_domain && $this->DKIM_private) {        $header_dkim = $this->DKIM_Add($header,$this->Subject,$body);        $header = str_replace(""\r\n"",""\n"",$header_dkim) . $header;      }      // Choose the mailer and send through it      switch($this->Mailer) {        case 'sendmail':          return $this->SendmailSend($header, $body);        case 'smtp':          return $this->SmtpSend($header, $body);        default:          return $this->MailSend($header, $body);      }    } catch (phpmailerException $e) {      $this->SetError($e->getMessage());      if ($this->exceptions) {        throw $e;      }      echo $e->getMessage().""\n"";      return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer_578, Initiates a connection to an SMTP server.\\n Returns false if the operation failed.\\n @uses SMTP\\n @access public\\n @return bool\\n, Initiates a connection to an SMTP server.,  public function SmtpConnect() {    if(is_null($this->smtp)) {      $this->smtp = new SMTP();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer_582, Formats an address correctly.\\n @access public\\n @return string\\n, Formats an address correctly.,"  public function AddrFormat($addr) {    if (empty($addr[1])) {      return $this->SecureHeader($addr[0]);    } else {      return $this->EncodeHeader($this->SecureHeader($addr[1]), 'phrase') . "" <"" . $this->SecureHeader($addr[0]) . "">"";    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer_584, Set the body wrapping.\n @access public\n @return void\n, Set the body wrapping.,  public function SetWordWrap() {    if($this->WordWrap < 1) {      return;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer_601, Clears all recipients assigned in the BCC array.  Returns void.\\n @return void\\n, Clears all recipients assigned in the BCC array.  Returns void.,  public function ClearBCCs() {    foreach($this->bcc as $bcc) {      unset($this->all_recipients[strtolower($bcc[0])]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.smtp_630, Returns true if connected to a server otherwise false\r\n @access public\r\n @return bool\r\n, Returns true if connected to a server otherwise false,"  public function Connected() {    if(!empty($this->smtp_conn)) {      $sock_status = socket_get_status($this->smtp_conn);      if($sock_status[""eof""]) {        // the socket is valid but we are not connected        if($this->do_debug >= 1) {            echo ""SMTP -> NOTICE:"" . $this->CRLF . ""EOF caught while checking if connected"";        }        $this->Close();        return false;      }      return true; // everything looks good    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_473, Locate the best instance of 'pattern' in 'text' near 'loc' using the\n Bitap algorithm.\n @param {string} text The text to search.\n @param {string} pattern The pattern to search for.\n @param {number} loc The location to search around.\n @return {number} Best match index or -1.\n @private\n, Locate the best instance of 'pattern' in 'text' near 'loc' using the,"function match_bitap($text, $pattern, $loc) {if (mb_strlen($pattern) > Match_MaxBits) {echo_Exception('Pattern too long for this browser.');}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_478," Merge a set of patches onto the text.  Return a patched text, as well\n as a list of true/false values indicating which patches were applied.\n @param {Array.<patch_obj>} patches Array of patch objects.\n @param {string} text Old text.\n @return {Array.<string|Array.<boolean>>} Two element Array, containing the\n      new text and an array of boolean values.\n"," Merge a set of patches onto the text.  Return a patched text, as well","function patch_apply($patches, $text) {if ( count($patches) == 0) {return array($text,array());}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_480, Look through the patches and break up any which are longer than the maximum\\n limit of the match algorithm.\\n @param {Array.<patch_obj>} patches Array of patch objects.\\n, Look through the patches and break up any which are longer than the maximum,"function patch_splitMax(&$patches) {for ($x = 0; $x < count($patches); $x++) {if ( $patches[$x]->length1 > Match_MaxBits) {$bigpatch = $patches[$x];// Remove the big old patch.array_splice($patches,$x--,1);$patch_size = Match_MaxBits;$start1 = $bigpatch->start1;$start2 = $bigpatch->start2;$precontext = '';while ( count($bigpatch->diffs) !== 0) {// Create one of several smaller patches.$patch = new patch_obj();$empty = true;$patch->start1 = $start1 - mb_strlen($precontext);$patch->start2 = $start2 - mb_strlen($precontext);if ($precontext !== '') {$patch->length1 = $patch->length2 = mb_strlen($precontext);array_push($patch->diffs, array(DIFF_EQUAL, $precontext) );}while ( count($bigpatch->diffs) !== 0 && $patch->length1 < $patch_size - $this->Patch_Margin) {$diff_type = $bigpatch->diffs[0][0];$diff_text = $bigpatch->diffs[0][1];if ($diff_type === DIFF_INSERT) {// Insertions are harmless.$patch->length2 += mb_strlen($diff_text);$start2 += mb_strlen($diff_text);array_push($patch->diffs, array_shift($bigpatch->diffs) );$empty = false;} elseif ($diff_type === DIFF_DELETE && count($patch->diffs) == 1 && $patch->diffs[0][0] == DIFF_EQUAL && (mb_strlen($diff_text) > 2 * $patch_size) ) {// This is a large deletion.  Let it pass in one chunk.$patch->length1 += mb_strlen($diff_text);$start1 += mb_strlen($diff_text);$empty = false;array_push( $patch->diffs, array($diff_type, $diff_text) );array_shift($bigpatch->diffs);} else {// Deletion or equality.  Only take as much as we can stomach.$diff_text = mb_substr($diff_text, 0, $patch_size - $patch->length1 - $this->Patch_Margin);$patch->length1 += mb_strlen($diff_text);$start1 += mb_strlen($diff_text);if ($diff_type === DIFF_EQUAL) {$patch->length2 += mb_strlen($diff_text);$start2 += mb_strlen($diff_text);} else {$empty = false;}array_push($patch->diffs, array($diff_type, $diff_text) );if ($diff_text == $bigpatch->diffs[0][1]) {array_shift($bigpatch->diffs);} else {$bigpatch->diffs[0][1] = mb_substr( $bigpatch->diffs[0][1],mb_strlen($diff_text) );}}}// Compute the head context for the next patch.$precontext = $this->diff_text2($patch->diffs);$precontext = mb_substr($precontext, mb_strlen($precontext)-$this->Patch_Margin);// Append the end context for this patch.$postcontext = mb_substr( $this->diff_text1($bigpatch->diffs), 0, $this->Patch_Margin );if ($postcontext !== '') {$patch->length1 += mb_strlen($postcontext);$patch->length2 += mb_strlen($postcontext);if ( count($patch->diffs) !== 0 && $patch->diffs[ count($patch->diffs) - 1][0] === DIFF_EQUAL) {$patch->diffs[ count($patch->diffs) - 1][1] .= $postcontext;} else {array_push($patch->diffs, array(DIFF_EQUAL, $postcontext));}}if (!$empty) {array_splice($patches, ++$x, 0, array($patch));}}}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_483, Class representing one patch operation.\n @constructor\n, Class representing one patch operation.,"class patch_obj {/** @type {Array.<Array.<number|string>>} */public $diffs = array();/** @type {number?} */public $start1 = null;/** @type {number?} */public $start2 = null;/** @type {number} */public $length1 = 0;/** @type {number} */public $length2 = 0;/** * Emmulate GNU diff's format. * Header: @@ -382,8 +481,9 @@ * Indicies are printed as 1-based, not 0-based. * @return {string} The GNU diff string. */function toString() {if ($this->length1 === 0) {$coords1 = $this->start1 . ',0';} elseif ($this->length1 == 1) {$coords1 = $this->start1 + 1;} else {$coords1 = ($this->start1 + 1) . ',' . $this->length1;}if ($this->length2 === 0) {$coords2 = $this->start2 . ',0';} elseif ($this->length2 == 1) {$coords2 = $this->start2 + 1;} else {$coords2 = ($this->start2 + 1) . ',' . $this->length2;}$text = array ( '@@ -' . $coords1 . ' +' . $coords2 . "" @@\n"" );// Escape the body of the patch with %xx notation.for ($x = 0; $x < count($this->diffs); $x++) {switch ($this->diffs[$x][0]) {case DIFF_INSERT :$op = '+';break;case DIFF_DELETE :$op = '-';break;case DIFF_EQUAL :$op = ' ';break;}$text[$x +1] = $op . encodeURI($this->diffs[$x][1]) . ""\n"";}return str_replace('%20', ' ', implode('',$text));}function __toString(){return $this->toString();}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Autoloader_1222, Add autoloader to autoloaders queue\n, Add autoloader to autoloaders queue,"    public function register()    {        spl_autoload_register(array($this, 'autoload'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Autoloader_1223," This function is not intended for public calls. It is public just because in PHP 5.3 it is not possible\\n to create a callable to a protected method, which will be called outside of the class.\\n\\n @param $className\\n", This function is not intended for public calls. It is public just because in PHP 5.3 it is not possible,"    public function autoload($className)    {        $className = str_replace(__NAMESPACE__, '', $className);        $className = ltrim($className, '\\');        $fileName = $this->baseDir . '/' . str_replace(array('_', '\\'), '/', $className) . '.php';        if (file_exists($fileName)) { // If not found, then let any subsequent autoloader load the class file            require($fileName);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_ConfigM4_183," Create config.m4 from the original one, by leaving only ""phalcon.c"" among included source files\\n\\n @return bool\\n"," Create config.m4 from the original one, by leaving only ""phalcon.c"" among included source files","    public function generate(): bool    {        return copy($this->sourceFile, $this->outputFile);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Generator_1225, Generate safe and optimized builds\n, Generate safe and optimized builds,"    public function run()    {        $generator = new Generator_Safe($this->rootDir, $this->safeDir);        $generator->run();        $generatorOptimized = new Generator_Optimized($this->safeDir, $this->optimized32Dir, $this->optimized64Dir);        $generatorOptimized->run();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_MemorySession_1265, Class MemorySession\n, Class MemorySession,"class MemorySession implements ManagerInterface{    /**     * @var array     */    protected $memory = [];    /**     * @var string     */    protected $name;    /**     * @var array     */    protected $options = [];    /**     * @var string     */    protected $sessionId;    /**     * @var bool     */    protected $started = false;    /**     * MemorySession constructor.     */    public function __construct(array $options = null)    {        $this->sessionId = $this->generateId();        if (is_array($options)) {            $this->setOptions($options);        }    }    private function generateId(): string    {        return md5(            time()        );    }    /**     * Alias: Gets a session variable from an application context     */    public function __get(string $index)    {        return $this->get($index);    }    /**     * Alias: Sets a session variable in an application context     */    public function __set(string $index, $value)    {        $this->set($index, $value);    }    /**     * @inheritdoc     */    public function get(string $index, $defaultValue = null, bool $remove = false)    {        $key = $this->prepareIndex($index);        if (!isset($this->memory[$key])) {            return $defaultValue;        }        $return = $this->memory[$key];        if ($remove) {            unset($this->memory[$key]);        }        return $return;    }    private function prepareIndex(string $index): string    {        if ($this->sessionId) {            $key = $this->sessionId . '#' . $index;        } else {            $key = $index;        }        return $key;    }    /**     * @inheritdoc     */    public function set(string $index, $value)    {        $this->memory[$this->prepareIndex($index)] = $value;    }    /**     * Alias: Check whether a session variable is set in an application context     */    public function __isset(string $index): bool    {        return $this->has($index);    }    /**     * @inheritdoc     */    public function has(string $index): bool    {        return isset(            $this->memory[$this->prepareIndex($index)]        );    }    /**     * Alias: Removes a session variable from an application context     */    public function __unset(string $index)    {        $this->remove($index);    }    /**     * @inheritdoc     */    public function remove(string $index)    {        unset(            $this->memory[$this->prepareIndex($index)]        );    }    /**     * @inheritdoc     */    public function destroy(bool $removeData = false): bool    {        if ($removeData) {            if (!empty($this->sessionId)) {                foreach ($this->memory as $key => $value) {                    if (0 === strpos($key, $this->sessionId . '#')) {                        unset($this->memory[$key]);                    }                }            } else {                $this->memory = [];            }        }        $this->started = false;        return true;    }    /**     * @inheritdoc     */    public function exists(): bool    {        return $this->started;    }    /**     * @inheritdoc     */    public function getId(): string    {        return $this->sessionId;    }    /**     * @inheritdoc     */    public function getName(): string    {        return $this->name;    }    /**     * @inheritdoc     */    public function setName(string $name)    {        $this->name = $name;    }    /**     * @inheritdoc     */    public function getOptions(): array    {        return $this->options;    }    /**     * @inheritdoc     */    public function setOptions(array $options)    {        if (isset($options['uniqueId'])) {            $this->sessionId = $options['uniqueId'];        }        $this->options = $options;    }    /**     * @inheritdoc     *     * @return AdapterInterface     */    public function regenerateId(bool $deleteOldSession = true): ManagerInterface    {        $this->sessionId = $this->generateId();        return $this;    }    /**     * @inheritdoc     */    public function setId(string $id)    {        $this->sessionId = $id;    }    /**     * @inheritdoc     */    public function start(): bool    {        if ($this->status() !== PHP_SESSION_ACTIVE) {            $this->memory  = [];            $this->started = true;            return true;        }        return false;    }    /**     * Returns the status of the current session     *     * ``` php     * <?php     * if ($session->status() !== PHP_SESSION_ACTIVE) {     *     $session->start();     * }     * ?>     * ```     */    public function status(): int    {        if ($this->isStarted()) {            return PHP_SESSION_ACTIVE;        }        return PHP_SESSION_NONE;    }    /**     * Dump all session     */    public function toArray(): array    {        return (array) $this->memory;    }    public function writeClose()    {    }    /**     * Returns the stored session handler     */    public function getAdapter(): SessionHandlerInterface    {        // TODO: Implement getAdapter() method.    }    /**     * Set the handler for the session     */    public function setAdapter(SessionHandlerInterface $handler): ManagerInterface    {        // TODO: Implement setAdapter() method.    }    /**     * Registers a handler with the session     */    public function registerHandler(SessionHandlerInterface $handler): bool    {        // TODO: Implement registerHandler() method.    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_MemorySession_1283, Returns the stored session handler\n, Returns the stored session handler,    public function getAdapter(): SessionHandlerInterface    {        // TODO: Implement getAdapter() method.    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_MemorySession_1284, Set the handler for the session\n, Set the handler for the session,    public function setAdapter(SessionHandlerInterface $handler): ManagerInterface    {        // TODO: Implement setAdapter() method.    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_MemorySession_1285, Registers a handler with the session\n, Registers a handler with the session,    public function registerHandler(SessionHandlerInterface $handler): bool    {        // TODO: Implement registerHandler() method.    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1230, Return array of supported platform settings for optimized builds\\n\\n @param string $output32Dir\\n @param string $output64Dir\\n @return array\\n, Return array of supported platform settings for optimized builds,"    protected function getPlatformsSettings(string $output32Dir, string $output64Dir)    {        return array(            '32bit' => array(                'dir' => $output32Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey32($string) . 'UL';                }            ),            '64bit' => array(                'dir' => $output64Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey64($string) . 'UL';                }            ),        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1233, Delete all files in target directories\n, Delete all files in target directories,    public function cleanBuildDirectories()    {        foreach ($this->settings as $setting) {            Util::cleanDirectory($setting['dir']);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1235," Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.\\n Precalculation is, actually, the optimization being performed.\\n", Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.,"    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1236, Pass line through filters and add the processed result to platform builds\n\n @param string $line\n @param array $result\n, Pass line through filters and add the processed result to platform builds,"    protected function filterLine($line, &$result)    {        /** @var callable|null $func */        $func = null;        foreach ($this->filters as $filter) {            if (!preg_match($filter['regexp'], $line, $matches)) {                continue;            }            $func = $filter['func'];            break; // We don't expect more than one replacement to be made on the same line        }        foreach ($this->settings as $platform => $setting) {            $result[$platform] .= $func ? $func($line, $matches, $setting['hashFunc']) : $line;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1558, Return filters for processing lines from safe universal phalcon.c\\n\\n @return array\\n, Return filters for processing lines from safe universal phalcon.c,"    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1561, Copy all files from the original safe universal build directory\n, Copy all files from the original safe universal build directory,"    protected function copyFilesFromSourceBuildDir()    {        $files = glob($this->sourceBuildDir . '/*.*');        foreach ($files as $file) {            // phalcon.c is processed in a separate optimization func            if (basename($file) == 'phalcon.zep.c') {                continue;            }            foreach ($this->settings as $setting) {                copy($file, $setting['dir'] . '/' . basename($file));            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_167, Uses previously generated safe universal build and generates optimized build for a specific platform\n, Uses previously generated safe universal build and generates optimized build for a specific platform,"class Generator_Optimized{    /**     * Directory, where safe universal build files are generated     *     * @var string     */    protected string $sourceBuildDir;    /**     * Platform settings for supported optimized builds     *     * @var array     */    protected array $settings;    /**     * Filters for processing (optimizing) lines from safe universal phalcon.c     *     * @var array     */    protected array $filters;    /**     * @param string $sourceBuildDir     * @param string $output32Dir     * @param string $output64Dir     */    public function __construct(string $sourceBuildDir, string $output32Dir, string $output64Dir)    {        $this->sourceBuildDir = $sourceBuildDir;        $this->settings = $this->getPlatformsSettings($output32Dir, $output64Dir);        $this->filters = $this->getFilters();    }    /**     * Return array of supported platform settings for optimized builds     *     * @param string $output32Dir     * @param string $output64Dir     * @return array     */    protected function getPlatformsSettings(string $output32Dir, string $output64Dir)    {        return array(            '32bit' => array(                'dir' => $output32Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey32($string) . 'UL';                }            ),            '64bit' => array(                'dir' => $output64Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey64($string) . 'UL';                }            ),        );    }    /**     * Return filters for processing lines from safe universal phalcon.c     *     * @return array     */    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }    /**     * Run generation process     */    public function run()    {        echo 'Generating builds, optimized for 32-bit and 64-bit platforms... ';        $this->cleanBuildDirectories();        $this->copyFilesFromSourceBuildDir();        $this->copyAndOptimizePhalconC();        echo ""OK\n"";    }    /**     * Delete all files in target directories     */    public function cleanBuildDirectories()    {        foreach ($this->settings as $setting) {            Util::cleanDirectory($setting['dir']);        }    }    /**     * Copy all files from the original safe universal build directory     */    protected function copyFilesFromSourceBuildDir()    {        $files = glob($this->sourceBuildDir . '/*.*');        foreach ($files as $file) {            // phalcon.c is processed in a separate optimization func            if (basename($file) == 'phalcon.zep.c') {                continue;            }            foreach ($this->settings as $setting) {                copy($file, $setting['dir'] . '/' . basename($file));            }        }    }    /**     * Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.     * Precalculation is, actually, the optimization being performed.     */    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }    /**     * Pass line through filters and add the processed result to platform builds     *     * @param string $line     * @param array $result     */    protected function filterLine($line, &$result)    {        /** @var callable|null $func */        $func = null;        foreach ($this->filters as $filter) {            if (!preg_match($filter['regexp'], $line, $matches)) {                continue;            }            $func = $filter['func'];            break; // We don't expect more than one replacement to be made on the same line        }        foreach ($this->settings as $platform => $setting) {            $result[$platform] .= $func ? $func($line, $matches, $setting['hashFunc']) : $line;        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_2069, Run generation process\\n, Run generation process,"    public function run()    {        echo 'Generating builds, optimized for 32-bit and 64-bit platforms... ';        $this->cleanBuildDirectories();        $this->copyFilesFromSourceBuildDir();        $this->copyAndOptimizePhalconC();        echo ""OK\n"";    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_PhalconEscapeCssOptimizer_1246, Zephir\\\\Optimizers\\\\FunctionCall\\\\PhalconEscapeCssOptimizer\\n\\n @package Zephir\\\\Optimizers\\\\FunctionCall\\n, Zephir,"class PhalconEscapeCssOptimizer extends OptimizerAbstract{    /**     * @param array              $expression     * @param Call               $call     * @param CompilationContext $context     *     * @return bool|CompiledExpression     *     * @throws CompilerException     */    public function optimize(array $expression, Call $call, CompilationContext $context)    {        if (!isset($expression['parameters'])) {            return false;        }        if (count($expression['parameters']) != 1) {            throw new CompilerException(                ""phalcon_escape_css only accepts one parameter"",                $expression            );        }        /**         * Process the expected symbol to be returned         */        $call->processExpectedReturn($context);        $symbolVariable = $call->getSymbolVariable();        if ($symbolVariable->getType() != 'variable') {            throw new CompilerException(                ""Returned values by functions can only be assigned to variant variables"",                $expression            );        }        if ($call->mustInitSymbolVariable()) {            $symbolVariable->initVariant($context);        }        $context->headersManager->add('kernel/filter');        $resolvedParams = $call->getResolvedParams(            $expression['parameters'],            $context,            $expression        );        $context->codePrinter->output(            'zephir_escape_css(' . $symbolVariable->getName() . ', ' . $resolvedParams[0] . ');'        );        return new CompiledExpression(            'variable',            $symbolVariable->getRealName(),            $expression        );    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_PhalconEscapeJsOptimizer_1248, Zephir\\\\Optimizers\\\\FunctionCall\\\\PhalconEscapeJsOptimizer\\n\\n @package Zephir\\\\Optimizers\\\\FunctionCall\\n, Zephir,"class PhalconEscapeJsOptimizer extends OptimizerAbstract{    /**     * @param array              $expression     * @param Call               $call     * @param CompilationContext $context     *     * @return bool|CompiledExpression     *     * @throws CompilerException     */    public function optimize(array $expression, Call $call, CompilationContext $context)    {        if (!isset($expression['parameters'])) {            return false;        }        if (count($expression['parameters']) != 1) {            throw new CompilerException(                ""phalcon_escape_js only accepts one parameter"",                $expression            );        }        /**         * Process the expected symbol to be returned         */        $call->processExpectedReturn($context);        $symbolVariable = $call->getSymbolVariable();        if ($symbolVariable->getType() != 'variable') {            throw new CompilerException(                ""Returned values by functions can only be assigned to variant variables"",                $expression            );        }        if ($call->mustInitSymbolVariable()) {            $symbolVariable->initVariant($context);        }        $context->headersManager->add('kernel/filter');        $resolvedParams = $call->getResolvedParams(            $expression['parameters'],            $context,            $expression        );        $symbol = $context->backend->getVariableCode($symbolVariable);        $context->codePrinter->output(            'zephir_escape_js(' . $symbol . ', ' . $resolvedParams[0] . ');'        );        return new CompiledExpression(            'variable',            $symbolVariable->getRealName(),            $expression        );    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Safe_1237," Generates safe Phalcon extension, which is suitable for any platform (32-bit, 64-bit)\\n"," Generates safe Phalcon extension, which is suitable for any platform (32-bit, 64-bit)","class Generator_Safe{    /**     * Directory with Phalcon source code     *     * @var string     */    protected string $sourceDir;    /**     * Directory, where source code for building Phalcon will be put     *     * @var string     */    protected string $outputDir;    /**     * Generator for phalcon.h     *     * @var Generator_File_PhalconH     */    protected $phalconH;    /**     * Generator for phalcon.c     *     * @var Generator_File_PhalconC     */    protected $phalconC;    /**     * Generator for config.m4     *     * @var Generator_File_ConfigM4     */    protected $configM4;    /**     * Generator for config.w32     *     * @var Generator_File_ConfigW32     */    protected $configW32;    /**     * @param string $rootDir     * @param string $outputDir     */    public function __construct(string $rootDir, string $outputDir)    {        $this->sourceDir = $rootDir . '/ext';        $this->outputDir = $outputDir;        $configDir = $rootDir . '/build/config';        $this->phalconH = new Generator_File_PhalconH($this->sourceDir, $outputDir);        $this->phalconC = new Generator_File_PhalconC($rootDir, $this->sourceDir, $configDir, $outputDir);        $this->configM4 = new Generator_File_ConfigM4($rootDir, $outputDir);        $this->configW32 = new Generator_File_ConfigW32($rootDir, $outputDir);    }    /**     * Generator source code, from which Phalcon extension can be built     */    public function run()    {        echo 'Generating safe build... ';        Util::cleanDirectory($this->outputDir);        $this->generateFiles();        echo ""OK\n"";    }    /**     * Generate all the files in the output directory     */    protected function generateFiles()    {        $includedHeaderFiles = $this->phalconH->generate();        $this->phalconC->generate($includedHeaderFiles);        $this->configM4->generate();        $this->configW32->generate();        copy($this->sourceDir . '/php_phalcon.h', $this->outputDir . '/php_phalcon.h');        $this->processKernelGlobals();    }    /**     * Resolves headers in the php_phalcon.h file     */    protected function processKernelGlobals()    {        $lines = [];        foreach (file($this->outputDir . '/php_phalcon.h') as $line) {            if (preg_match('@^#include ""(kernel/.+)""@', $line, $matches)) {                $content = file_get_contents($this->sourceDir . DIRECTORY_SEPARATOR . $matches[1]);                $lines[] = $content . PHP_EOL;            } else {                $lines[] = $line;            }        }        file_put_contents($this->outputDir . '/php_phalcon.h', join('', $lines));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Safe_1241, Resolves headers in the php_phalcon.h file\n, Resolves headers in the php_phalcon.h file,"    protected function processKernelGlobals()    {        $lines = [];        foreach (file($this->outputDir . '/php_phalcon.h') as $line) {            if (preg_match('@^#include ""(kernel/.+)""@', $line, $matches)) {                $content = file_get_contents($this->sourceDir . DIRECTORY_SEPARATOR . $matches[1]);                $lines[] = $content . PHP_EOL;            } else {                $lines[] = $line;            }        }        file_put_contents($this->outputDir . '/php_phalcon.h', join('', $lines));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Safe_1567, Generate all the files in the output directory\n, Generate all the files in the output directory,"    protected function generateFiles()    {        $includedHeaderFiles = $this->phalconH->generate();        $this->phalconC->generate($includedHeaderFiles);        $this->configM4->generate();        $this->configW32->generate();        copy($this->sourceDir . '/php_phalcon.h', $this->outputDir . '/php_phalcon.h');        $this->processKernelGlobals();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Util_1554, Recursively deletes everything in the directory\\n\\n @param string $dir\\n, Recursively deletes everything in the directory,    public static function cleanDirectory(string $dir): void    {        $iterator = new DirectoryIterator($dir);        foreach ($iterator as $entry) {            /** @var $entry DirectoryIterator */            if ($entry->isDot() || $entry->getBasename() == 'tests') {                continue;            }            if ($entry->isDir() && !$entry->isLink()) {                self::cleanDirectory($entry->getPathname());                rmdir($entry->getPathname());            } else {                if (is_writable($dir)) {                    unlink($entry->getPathname());                }            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Util_165," Normalize file path, convert all slashes to Linux-style and get rid of '..', '.'.\n\n @param string $filePath\n @return string|null\n"," Normalize file path, convert all slashes to Linux-style and get rid of '..', '.'.","    public static function normalize(string $filePath): ?string    {        $filePath = realpath($filePath);        if ($filePath === false) {            return null;        }        return str_replace('\\', DIRECTORY_SEPARATOR, $filePath);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_1257, Get Model cache options - Stream\n, Get Model cache options - Stream,"    function getOptionsModelCacheStream(): array    {        if (!is_dir(cacheDir('models'))) {            mkdir(                cacheDir('models')            );        }        return [            'lifetime'   => 3600,            'storageDir' => cacheModelsDir(),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_1261, Get sqlite db options\n, Get sqlite db options,"    function getOptionsSqlite(): array    {        return [            'dbname' => codecept_root_dir(env('DATA_SQLITE_NAME')),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_1586, Get postgresql db options\n, Get postgresql db options,"    function getOptionsPostgresql(): array    {        return [            'host'     => env('DATA_POSTGRES_HOST'),            'username' => env('DATA_POSTGRES_USER'),            'password' => env('DATA_POSTGRES_PASS'),            'port'     => env('DATA_POSTGRES_PORT'),            'dbname'   => env('DATA_POSTGRES_NAME'),            'schema'   => env('DATA_POSTGRES_SCHEMA'),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_197, Get mysql db options\\n, Get mysql db options,"    function getOptionsMysql(): array    {        return [            'host'     => env('DATA_MYSQL_HOST'),            'username' => env('DATA_MYSQL_USER'),            'password' => env('DATA_MYSQL_PASS'),            'dbname'   => env('DATA_MYSQL_NAME'),            'port'     => env('DATA_MYSQL_PORT'),            'charset'  => env('DATA_MYSQL_CHARSET'),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_199, Get Session Stream options\\n, Get Session Stream options,"    function getOptionsSessionStream(): array    {        if (!is_dir(cacheDir('sessions'))) {            mkdir(cacheDir('sessions'));        }        return [            'savePath' => cacheDir('sessions'),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_generate-api-docs_201, Read the file and parse it\\n, Read the file and parse it,"function processDocument(string $file): array{    $return   = [];    $contents = file_get_contents($file);    $parse    = zephir_parse_file($contents, '(eval code)');    foreach ($parse as $item) {        $type = $item['type'] ?? '';        if ('namespace' === $type) {            $return['namespace'] = $item['name'];            continue;        }        if ('comment' === $type) {            $return['comment'] = getDocblockMethod($item['value']);            continue;        }        if ('use' === $type) {            $uses    = $return['uses'] ?? [];            $aliases = $item['aliases'];            foreach ($aliases as $alias) {                $uses[] = $alias['name'];            }            $return['uses'] = $uses;        }        if ('class' === $type || 'interface' === $type) {            $signature = '';            if (1 === ($item['final'] ?? 0)) {                $signature .= ' Final';            }            if (1 === ($item['abstract'] ?? 0)) {                $signature .= ' Abstract';            }            $signature           .= ('class' === $type) ? ' Class ' : ' Interface ';            $signature           .= $return['namespace'] . '\\' . $item['name'];            $return['signature'] = ltrim($signature);            //$return['signature'] = ltrim(str_replace('Phalcon\\', '', $signature));            $return['extends'] = $item['extends'] ?? '';            if (true === is_array($return['extends'])) {                $return['extends'] = $return['extends'][0]['value'];            }            $implements = $item['implements'] ?? [];            if (count($implements) > 0) {                foreach ($implements as $implement) {                    $return['implements'][] = $implement['value'];                }            }            $definition           = $item['definition'] ?? [];            $return['constants']  = parseConstants($definition);            $return['properties'] = parseProperties($definition);            $return['methods']    = parseMethods($definition);        }    }    return $return;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessCommunicationTrait_1571, Parses a received message. Redirects to the appropriate `command\\n @param ConnectionInterface $conn\\n @param string $data\\n\\n @throws \\\\Exception when invalid 'cmd' in $data.\\n, Parses a received message. Redirects to the appropriate `command,"    public function processMessage(ConnectionInterface $conn, $data)    {        $array = \json_decode($data, true);        $method = 'command' . \ucfirst($array['cmd']);        if (\is_callable([$this, $method])) {            $this->$method($array, $conn);        } else {            throw new \Exception(\sprintf('Command %s not found. Got %s', $method, $data));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1576, To be called after all workers have been terminated and the event loop is no longer in use.\\n, To be called after all workers have been terminated and the event loop is no longer in use.,"    private function quit()    {        $this->output->writeln('Stopping the process manager.');        // this method is also called during startup when something crashed, so        // make sure we don't operate on nulls.        if ($this->controller) {            @$this->controller->close();        }        if ($this->web) {            @$this->web->close();        }        if ($this->loop) {            $this->loop->stop();        }        $this->removePidFile();        exit;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1600, Starts the main loop. Blocks.\n, Starts the main loop. Blocks.,"    public function run()    {        Debug::enable();        \register_shutdown_function([$this, 'shutdown']);        // make whatever is necessary to disable all stuff that could buffer output        \ini_set('zlib.output_compression', 0);        \ini_set('output_buffering', 0);        \ini_set('implicit_flush', 1);        \ob_implicit_flush(1);        $this->loop = Factory::create();        $this->web = new Server(\sprintf('%s:%d', $this->host, $this->port), $this->loop, ['backlog' => self::TCP_BACKLOG]);        $this->web->on('connection', [$this, 'onRequest']);        $this->controller = new UnixServer($this->getControllerSocketPath(), $this->loop);        $this->controller->on('connection', [$this, 'onSlaveConnection']);        $this->loop->addSignal(SIGTERM, [$this, 'shutdown']);        $this->loop->addSignal(SIGINT, [$this, 'shutdown']);        $this->loop->addSignal(SIGCHLD, [$this, 'handleSigchld']);        $this->loop->addSignal(SIGUSR1, [$this, 'restartSlaves']);        $this->loop->addSignal(SIGUSR2, [$this, 'reloadSlaves']);        if ($this->isDebug()) {            $this->loop->addPeriodicTimer(1, [$this, 'checkChangedFiles']);        }        $loopClass = (new \ReflectionClass($this->loop))->getShortName();        $this->output->writeln(""<info>Starting PHP-PM with {$this->slaveCount} workers, using {$loopClass} ...</info>"");        $this->writePidFile();        $this->createSlaves();        $this->loop->run();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1605, A slave sent a `status` command.\n\n @param array      $data\n @param ConnectionInterface $conn\n, A slave sent a `status` command.,"    protected function commandStatus(array $data, ConnectionInterface $conn)    {        // remove nasty info about worker's bootstrap fail        $conn->removeAllListeners('close');        if ($this->output->isVeryVerbose()) {            $conn->on('close', function () {                $this->output->writeln('Status command requested');            });        }        // create port -> requests map        $requests = \array_reduce(            $this->slaves->getByStatus(Slave::ANY),            function ($carry, Slave $slave) {                $carry[$slave->getPort()] = 0 + $slave->getHandledRequests();                return $carry;            },            []        );        switch ($this->status) {            case self::STATE_STARTING:                $status = 'starting';                break;            case self::STATE_RUNNING:                $status = 'healthy';                break;            case self::STATE_EMERGENCY:                $status = 'offline';                break;            default:                $status = 'unknown';        }        $conn->end(\json_encode([            'status' => $status,            'workers' => $this->slaves->getStatusSummary(),            'handled_requests' => $this->handledRequests,            'handled_requests_per_worker' => $requests        ]));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1606, A slave sent a `stop` command.\\\\n\\\\n @param array      $data\\\\n @param ConnectionInterface $conn\\\\n, A slave sent a `stop` command.,"    protected function commandStop(array $data, ConnectionInterface $conn)    {        if ($this->output->isVeryVerbose()) {            $conn->on('close', function () {                $this->output->writeln('Stop command requested');            });        }        $conn->end(\json_encode([]));        $this->shutdown();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1607, A slave sent a `reload` command.\\\\n\\\\n @param array      $data\\\\n @param ConnectionInterface $conn\\\\n, A slave sent a `reload` command.,"    protected function commandReload(array $data, ConnectionInterface $conn)    {        // remove nasty info about worker's bootstrap fail        $conn->removeAllListeners('close');        if ($this->output->isVeryVerbose()) {            $conn->on('close', function () {                $this->output->writeln('Reload command requested');            });        }        $conn->end(\json_encode([]));        $this->reloadSlaves();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1608, A slave sent a `register` command.\\\\n\\\\n @param array      $data\\\\n @param ConnectionInterface $conn\\\\n, A slave sent a `register` command.,"    protected function commandRegister(array $data, ConnectionInterface $conn)    {        $pid = (int)$data['pid'];        $port = (int)$data['port'];        try {            $slave = $this->slaves->getByPort($port);            $slave->register($pid, $conn);        } catch (\Exception $e) {            $this->output->writeln(\sprintf(                '<error>Worker #%d wanted to register on master which was not expected.</error>',                $port            ));            $conn->close();            return;        }        if ($this->output->isVeryVerbose()) {            $this->output->writeln(\sprintf('Worker #%d registered. Waiting for application bootstrap ... ', $port));        }        $this->sendMessage($conn, 'bootstrap');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1612, Receive stats from the worker such as current memory use\\n\\n @param array      $data\\n @param ConnectionInterface $conn\\n, Receive stats from the worker such as current memory use,"    protected function commandStats(array $data, ConnectionInterface $conn)    {        try {            $slave = $this->slaves->getByConnection($conn);            $slave->setUsedMemory($data['memory_usage']);            if ($this->output->isVeryVerbose()) {                $this->output->writeln(                    \sprintf(                        'Current memory usage for worker %d: %.2f MB',                        $slave->getPort(),                        $data['memory_usage']                    )                );            }        } catch (\Exception $e) {            // silent        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1613, Handles failed application bootstraps.\n\n @param int $port\n, Handles failed application bootstraps.,"    protected function bootstrapFailed($port)    {        if ($this->isDebug()) {            $this->output->writeln('');            if ($this->status !== self::STATE_EMERGENCY) {                $this->status = self::STATE_EMERGENCY;                $this->output->writeln(                    \sprintf(                        '<error>Application bootstrap failed. We are entering emergency mode now. All offline. ' .                        'Waiting for file changes ...</error>'                    )                );            } else {                $this->output->writeln(                    \sprintf(                        '<error>Application bootstrap failed. We are still in emergency mode. All offline. ' .                        'Waiting for file changes ...</error>'                    )                );            }            $this->reloadSlaves(false);        } else {            $this->output->writeln(                \sprintf(                    '<error>Application bootstrap failed. Restarting worker #%d ...</error>',                    $port                )            );            $this->newSlaveInstance($port);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1615, Populate slave pool\\\\n\\\\n @return void\\\\n, Populate slave pool,    public function createSlaves()    {        for ($i = 1; $i <= $this->slaveCount; $i++) {            $this->newSlaveInstance(self::CONTROLLER_PORT + $i);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1618, Restart all slaves. Necessary when watched files have changed.\\n, Restart all slaves. Necessary when watched files have changed.,    public function restartSlaves()    {        //Do not restart if we're still starting the slaves        if ($this->status === self::STATE_STARTING) {            return;        }        $this->status = self::STATE_STARTING;        $this->closeSlaves();        $this->createSlaves();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1619, Check if all slaves have become available\\\\n, Check if all slaves have become available,    protected function allSlavesReady()    {        if ($this->status === self::STATE_STARTING || $this->status === self::STATE_EMERGENCY) {            $readySlaves = $this->slaves->getByStatus(Slave::READY);            $busySlaves = $this->slaves->getByStatus(Slave::BUSY);            return \count($readySlaves) + \count($busySlaves) === $this->slaveCount;        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessManager_1620, Creates a new ProcessSlave instance.\\n\\n @param int $port\\n, Creates a new ProcessSlave instance.,"    protected function newSlaveInstance($port)    {        if ($this->status === self::STATE_SHUTDOWN) {            // during shutdown phase all connections are closed and as result new            // instances are created - which is forbidden during this phase            return;        }        if ($this->output->isVeryVerbose()) {            $this->output->writeln(\sprintf(""Start new worker #%d"", $port));        }        $socketpath = \var_export($this->getSocketPath(), true);        $bridge = \var_export($this->getBridge(), true);        $bootstrap = \var_export($this->getAppBootstrap(), true);        $config = [            'port' => $port,            'session_path' => \session_save_path(),            'app-env' => $this->getAppEnv(),            'debug' => $this->isDebug(),            'logging' => $this->isLogging(),            'static-directory' => $this->getStaticDirectory(),            'populate-server-var' => $this->isPopulateServer(),            'limit-concurrent-requests' => $this->limitConcurrentRequests,            'request-body-buffer' => $this->requestBodyBuffer        ];        $config = \var_export($config, true);        $dir = \var_export(__DIR__ . '/..', true);        $script = <<<EOF<?phpnamespace PHPPM;set_time_limit(0);require_once file_exists($dir . '/vendor/autoload.php')    ? $dir . '/vendor/autoload.php'    : $dir . '/../../autoload.php';if (!pcntl_installed()) {    error_log(        \sprintf(            'PCNTL is not enabled in the PHP installation at %s. See: http://php.net/manual/en/pcntl.installation.php',            PHP_BINARY        )    );}if (!pcntl_enabled()) {    error_log('Some required PCNTL functions are disabled. Check `disabled_functions` in `php.ini`.');    exit();}//global for all global functionsProcessSlave::\$slave = new ProcessSlave($socketpath, $bridge, $bootstrap, $config);ProcessSlave::\$slave->run();EOF;        // slave php file        $file = \tempnam(\sys_get_temp_dir(), 'dbg');        \file_put_contents($file, $script);        \register_shutdown_function('unlink', $file);        // we can not use -q since this disables basically all header support        // but since this is necessary at least in Symfony we can not use it.        // e.g. headers_sent() returns always true, although wrong.        $commandline = ['exec', $this->phpCgiExecutable, '-C', $file];        $processInstance = new \Symfony\Component\Process\Process($commandline);        $commandline = $processInstance->getCommandLine();        // use exec to omit wrapping shell        $process = new Process($commandline);        $slave = new Slave($port, $this->maxRequests, $this->memoryLimit, $this->ttl);        $slave->attach($process);        $this->slaves->add($slave);        $process->start($this->loop);        $process->stderr->on(            'data',            function ($data) use ($port) {                if ($this->lastWorkerErrorPrintBy !== $port) {                    $this->output->writeln(\sprintf('<info>--- Worker %u stderr ---</info>', $port));                    $this->lastWorkerErrorPrintBy = $port;                }                $this->output->writeln(\sprintf('<error>%s</error>', \trim($data)));            }        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1626, Shuts down the event loop. This basically exits the process.\\\\n, Shuts down the event loop. This basically exits the process.,    public function shutdown()    {        if ($this->prepareShutdown()) {            exit;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1629, Bootstraps the actual application.\\\\n\\\\n @param string  $appBootstrap\\\\n @param string  $appenv\\\\n @param boolean $debug\\\\n\\\\n @throws \\\\\\\\Exception\\\\n, Bootstraps the actual application.,"    protected function bootstrap($appBootstrap, $appenv, $debug)    {        if ($bridge = $this->getBridge()) {            $bridge->bootstrap($appBootstrap, $appenv, $debug);            $this->sendMessage($this->controller, 'ready');        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1630, Adds a file path to the watcher list queue which will be sent\\\\n to the master process after each request.\\\\n\\\\n @param string $path\\\\n, Adds a file path to the watcher list queue which will be sent,    public function registerFile($path)    {        if ($this->isDebug()) {            $this->watchedFiles[] = $path;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1633, Attempt a connection through the unix socket until it succeeds.\\n This is a workaround for an issue where the (hardcoded) 1s socket timeout is triggered due to a busy socket.\\n, Attempt a connection through the unix socket until it succeeds.,"    private function tryConnect()    {        try {            $this->doConnect();        } catch (\RuntimeException $ex) {            // Failed to connect to the controller, there was probably a timeout accessing the socket...            $this->loop->addTimer(1, function () {                $this->tryConnect();            });        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1642, Handle incoming client connection\\n\\n @param ConnectionInterface $incoming\\n, Handle incoming client connection,"    public function handle(ConnectionInterface $incoming)    {        $this->incoming = $incoming;        $this->incoming->on('data', [$this, 'handleData']);        $this->start = \microtime(true);        $this->requestSentAt = \microtime(true);        $this->getNextSlave();        if ($this->maxExecutionTime > 0) {            $this->maxExecutionTimer = $this->loop->addTimer($this->maxExecutionTime, [$this, 'maxExecutionTimeExceeded']);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1643, Buffer incoming data until slave connection is available\\n and headers have been received\\n\\n @param string $data\\n, Buffer incoming data until slave connection is available,"    public function handleData($data)    {        $this->incomingBuffer .= $data;        if ($this->connection && $this->isHeaderEnd($this->incomingBuffer)) {            $remoteAddress = (string) $this->incoming->getRemoteAddress();            $headersToReplace = [                'X-PHP-PM-Remote-IP' => \trim(\parse_url($remoteAddress, PHP_URL_HOST), '[]'),                'X-PHP-PM-Remote-Port' => \trim(\parse_url($remoteAddress, PHP_URL_PORT), '[]')            ];            $buffer = $this->replaceHeader($this->incomingBuffer, $headersToReplace);            $this->connection->write($buffer);            $this->incoming->removeListener('data', [$this, 'handleData']);            $this->incoming->pipe($this->connection);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1644, Get next free slave from pool\\n Asynchronously keep trying until slave becomes available\\n, Get next free slave from pool,"    public function getNextSlave()    {        // client went away while waiting for worker        if (!$this->incoming->isWritable()) {            return;        }        $available = $this->slaves->getByStatus(Slave::READY);        if (\count($available)) {            // pick first slave            $slave = \array_shift($available);            // slave available -> connect            if ($this->tryOccupySlave($slave)) {                return;            }        }        // keep retrying until slave becomes available, unless timeout has been exceeded        if (\time() < ($this->requestSentAt + $this->timeout)) {            $this->loop->futureTick([$this, 'getNextSlave']);        } else {            // Return a ""503 Service Unavailable"" response            $this->output->writeln(\sprintf('No slaves available to handle the request and timeout %d seconds exceeded', $this->timeout));            $this->incoming->write($this->createErrorResponse('503 Service Temporarily Unavailable', 'Service Temporarily Unavailable'));            $this->incoming->end();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1645, Slave available handler\n\n @param Slave $slave available slave instance\n @return bool Slave is available\n, Slave available handler,"    public function tryOccupySlave(Slave $slave)    {        if ($slave->isExpired()) {            $slave->close();            $this->output->writeln(\sprintf('Restart worker #%d because it reached its TTL', $slave->getPort()));            $slave->getConnection()->close();            return false;        }        $this->redirectionTries++;        $this->slave = $slave;        $this->verboseTimer(function ($took) {            return \sprintf('<info>took abnormal %.3f seconds for choosing next free worker</info>', $took);        });        // mark slave as busy        $this->slave->occupy();        $connector = new UnixConnector($this->loop);        $connector = new TimeoutConnector($connector, $this->timeout, $this->loop);        $socketPath = $this->getSlaveSocketPath($this->slave->getPort());        $connector->connect($socketPath)->then(            [$this, 'slaveConnected'],            [$this, 'slaveConnectFailed']        );        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1648, Stop the worker if the max execution time has been exceeded and return 504\n, Stop the worker if the max execution time has been exceeded and return 504,"    public function maxExecutionTimeExceeded()    {        // client went away while waiting for worker        if (!$this->incoming->isWritable()) {            return false;        }        $this->incoming->write($this->createErrorResponse('504 Gateway Timeout', 'Maximum execution time exceeded'));        $this->lastOutgoingData = 'not empty'; // Avoid triggering 502        $this->output->writeln(\sprintf('Maximum execution time of %d seconds exceeded. Closing worker.', $this->maxExecutionTime));        // mark slave as closed        if ($this->slave) {            $this->slave->close();            $this->slave->getConnection()->close();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1650, Handle failed slave connection\n\n Connection may fail because of timeouts or crashed or dying worker.\n Since the worker may only very busy or dying it's put back into the\n available worker list. If it is really dying it will be removed from the\n worker list by the connection:close event.\n\n @param \\Exception $e slave connection error\n, Handle failed slave connection,"    public function slaveConnectFailed(\Exception $e)    {        $this->slave->release();        $this->verboseTimer(function ($took) use ($e) {            return \sprintf(                '<error>Connection to worker %d failed. Try #%d, took %.3fs ' .                '(timeout %ds). Error message: [%d] %s</error>',                $this->slave->getPort(),                $this->redirectionTries,                $took,                $this->timeout,                $e->getCode(),                $e->getMessage()            );        }, true);        // should not get any more access to this slave instance        $this->slave = null;        // try next free slave, let loop schedule it (stack friendly)        // after 10th retry add 10ms delay, keep increasing until timeout        $delay = \min($this->timeout, \floor($this->redirectionTries / 10) / 100);        $this->loop->addTimer($delay, [$this, 'getNextSlave']);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1652, Replaces or injects header\\\\n\\\\n @param string   $header\\\\n @param string[] $headersToReplace\\\\n\\\\n @return string\\\\n, Replaces or injects header,"    protected function replaceHeader($header, $headersToReplace)    {        $result = $header;        foreach ($headersToReplace as $key => $value) {            if (false !== $headerPosition = \stripos($result, $key . ':')) {                // check how long the header is                $length = \strpos(\substr($header, $headerPosition), ""\r\n"");                $result = \substr_replace($result, ""$key: $value"", $headerPosition, $length);            } else {                // $key is not in header yet, add it at the end                $end = \strpos($result, ""\r\n\r\n"");                $result = \substr_replace($result, ""\r\n$key: $value"", $end, 0);            }        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_SlavePool_1672, SlavePool singleton is responsible for maintaining a pool of slave instances\n, SlavePool singleton is responsible for maintaining a pool of slave instances,"class SlavePool{    /** @var Slave[] */    private $slaves = [];    /**     * Add slave to pool     *     * Slave is in CREATED state     *     * @param Slave $slave     *     * @return void     */    public function add(Slave $slave)    {        $port = $slave->getPort();        if (isset($this->slaves[$port])) {            throw new \Exception(""Slave port $port already occupied."");        }        if ($slave->getPort() !== $port) {            throw new \Exception(""Slave mis-assigned."");        }        $this->slaves[$port] = $slave;    }    /**     * Remove from pool     *     * @param Slave $slave     *     * @return void     */    public function remove(Slave $slave)    {        $port = $slave->getPort();        // validate existence        $this->getByPort($port);        // remove        unset($this->slaves[$port]);    }    /**     * Get slave by port     *     * @param int $port     * @return Slave     */    public function getByPort($port)    {        if (!isset($this->slaves[$port])) {            throw new \Exception(""Slave port $port empty."");        }        return $this->slaves[$port];    }    /**     * Get slave slaves by connection     *     * @param ConnectionInterface $connection     *     * @return mixed     * @throws \Exception     */    public function getByConnection(ConnectionInterface $connection)    {        $hash = \spl_object_hash($connection);        foreach ($this->slaves as $slave) {            if ($slave->getConnection() && $hash === \spl_object_hash($slave->getConnection())) {                return $slave;            }        }        throw new \Exception(""Slave connection not registered."");    }    /**     * Get multiple slaves by status     */    public function getByStatus($status)    {        return \array_filter($this->slaves, function ($slave) use ($status) {            return $status === Slave::ANY || $status === $slave->getStatus();        });    }    /**     * Return a human-readable summary of the slaves in the pool.     *     * @return array     */    public function getStatusSummary()    {        $map = [            'total' => Slave::ANY,            'ready' => Slave::READY,            'busy' => Slave::BUSY,            'created' => Slave::CREATED,            'registered' => Slave::REGISTERED,            'closed' => Slave::CLOSED        ];        return \array_map(function ($state) {            return \count($this->getByStatus($state));        }, $map);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_SlavePool_1673, Add slave to pool\\\\n\\\\n Slave is in CREATED state\\\\n\\\\n @param Slave $slave\\\\n\\\\n @return void\\\\n, Add slave to pool,"    public function add(Slave $slave)    {        $port = $slave->getPort();        if (isset($this->slaves[$port])) {            throw new \Exception(""Slave port $port already occupied."");        }        if ($slave->getPort() !== $port) {            throw new \Exception(""Slave mis-assigned."");        }        $this->slaves[$port] = $slave;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_SlavePool_1675, Get slave by port\\n\\n @param int $port\\n @return Slave\\n, Get slave by port,"    public function getByPort($port)    {        if (!isset($this->slaves[$port])) {            throw new \Exception(""Slave port $port empty."");        }        return $this->slaves[$port];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_SlavePool_1678, Return a human-readable summary of the slaves in the pool.\n\n @return array\n, Return a human-readable summary of the slaves in the pool.,"    public function getStatusSummary()    {        $map = [            'total' => Slave::ANY,            'ready' => Slave::READY,            'busy' => Slave::BUSY,            'created' => Slave::CREATED,            'registered' => Slave::REGISTERED,            'closed' => Slave::CLOSED        ];        return \array_map(function ($state) {            return \count($this->getByStatus($state));        }, $map);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_Slave_1654, Register a slave after it's process started\\n\\n @param int $pid\\n @param ConnectionInterface $connection\\n\\n @return void\\n, Register a slave after it's process started,"    public function register($pid, ConnectionInterface $connection)    {        if ($this->status !== self::CREATED) {            throw new \LogicException('Cannot register a slave that is not in created state');        }        $this->pid = $pid;        $this->connection = $connection;        $this->status = self::REGISTERED;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_Utils_1679, Nitty gritty helper methods to hijack objects. Useful to reset properties that would otherwise run amok\n and result in memory leaks.\n, Nitty gritty helper methods to hijack objects. Useful to reset properties that would otherwise run amok,"class Utils{    /**     * Executes a function in the context of an object. This basically bypasses the private/protected check of PHP.     *     * @param callable $fn     * @param object $newThis     * @param array $args     * @param string $bindClass     */    public static function bindAndCall(callable $fn, $newThis, $args = [], $bindClass = null)    {        $func = \Closure::bind($fn, $newThis, $bindClass ?: \get_class($newThis));        if ($args) {            \call_user_func_array($func, $args);        } else {            $func(); //faster        }    }    /**     * Changes a property value of an object. (hijack because you can also change private/protected properties)     *     * @param object $object     * @param string $propertyName     * @param mixed $newValue     */    public static function hijackProperty($object, $propertyName, $newValue)    {        Utils::bindAndCall(function () use ($object, $propertyName, $newValue) {            $object->$propertyName = $newValue;        }, $object);    }    /**     * Generates stronger session ids for session handling.     *     * @return string     */    public static function generateSessionId()    {        return \bin2hex(\random_bytes(32));    }    /**     * @return int bytes     */    public static function getMaxMemory()    {        $memoryLimit = \ini_get('memory_limit');        // if no limit        if (-1 == $memoryLimit) {            return 134217728; //128 * 1024 * 1024 default 128mb        }        // if set to exact byte        if (\is_numeric($memoryLimit)) {            return (int) $memoryLimit;        }        // if short hand version http://php.net/manual/en/faq.using.php#faq.using.shorthandbytes        return (int) \substr($memoryLimit, 0, -1) * [            'g' => 1073741824, // 1024 * 1024 * 1024            'm' => 1048576, // 1024 * 1024            'k' => 1024        ][\strtolower(\substr($memoryLimit, -1))];    }    /**     * @param string $path     *     * @return string|boolean false when path resolution resolved to out of range     */    public static function parseQueryPath($path)    {        $path = '/' . \ltrim($path, '/');        $path = \preg_replace('/[\x00-\x1F\x7F]/', '', $path);        //examples:        //1.> /images/../foo.png        //2.> /foo.png        //1.> /images/../../foo.png        //2.> /foo.png        //3.> false        while (false !== $pos = \strpos($path, '/../')) {            $leftSlashNext = \strrpos(\substr($path, 0, $pos), '/');            if (false === $leftSlashNext) {                // one /../ too much, without space to the left/up                return false;            }            $path = \substr($path, 0, $leftSlashNext + 1) . \substr($path, $pos + 4);        }        return $path;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_Utils_1680, Changes a property value of an object. (hijack because you can also change private/protected properties)\n\n @param object $object\n @param string $propertyName\n @param mixed $newValue\n, Changes a property value of an object. (hijack because you can also change private/protected properties),"    public static function hijackProperty($object, $propertyName, $newValue)    {        Utils::bindAndCall(function () use ($object, $propertyName, $newValue) {            $object->$propertyName = $newValue;        }, $object);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_functions_1686, Makes sure required PCNTL functions aren't included in disable_functions.\\n\\n @return bool\\n, Makes sure required PCNTL functions aren't included in disable_functions.,"function pcntl_enabled(){    $requiredFunctions = ['pcntl_signal', 'pcntl_signal_dispatch', 'pcntl_waitpid'];    $disabledFunctions = \explode(',', (string) \ini_get('disable_functions'));    $disabledFunctions = \array_map(function ($item) {        return \trim($item);    }, $disabledFunctions);    foreach ($requiredFunctions as $function) {        if (\in_array($function, $disabledFunctions)) {            return false;        }    }    return true;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phpspec_prophecy_AnyValuesToken_2943, Any values token.\n\n @author Konstantin Kudryashov <ever.zet@gmail.com>\n, Any values token.,"class AnyValuesToken implements TokenInterface{    /**     * Always scores 2 for any argument.     *     * @param $argument     *     * @return int     */    public function scoreArgument($argument)    {        return 2;    }    /**     * Returns true to stop wildcard from processing other tokens.     *     * @return bool     */    public function isLast()    {        return true;    }    /**     * Returns string representation for token.     *     * @return string     */    public function __toString()    {        return '* [, ...]';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phpspec_prophecy_ApproximateValueToken_2947, Approximate value token\n\n @author Daniel Leech <daniel@dantleech.com>\n, Approximate value token,"class ApproximateValueToken implements TokenInterface{    private $value;    private $precision;    public function __construct($value, $precision = 0)    {        $this->value = $value;        $this->precision = $precision;    }    /**     * {@inheritdoc}     */    public function scoreArgument($argument)    {        return round((float)$argument, $this->precision) === round($this->value, $this->precision) ? 10 : false;    }    /**     * {@inheritdoc}     */    public function isLast()    {        return false;    }    /**     * Returns string representation for token.     *     * @return string     */    public function __toString()    {        return sprintf('≅%s', round($this->value, $this->precision));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phpspec_prophecy_ArgumentsWildcard_2936, Calculates wildcard match score for provided arguments.\n\n @param array $arguments\n\n @return false|int False OR integer score (higher - better)\n, Calculates wildcard match score for provided arguments.,    public function scoreArguments(array $arguments)    {        if (0 == count($arguments) && 0 == count($this->tokens)) {            return 1;        }        $arguments  = array_values($arguments);        $totalScore = 0;        foreach ($this->tokens as $i => $token) {            $argument = isset($arguments[$i]) ? $arguments[$i] : null;            if (1 >= $score = $token->scoreArgument($argument)) {                return false;            }            $totalScore += $score;            if (true === $token->isLast()) {                return $totalScore;            }        }        if (count($arguments) > count($this->tokens)) {            return false;        }        return $totalScore;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phpspec_prophecy_ArrayCountToken_2951, Array elements count token.\n\n @author Boris Mikhaylov <kaguxmail@gmail.com>\n, Array elements count token.,"class ArrayCountToken implements TokenInterface{    private $count;    /**     * @param integer $value     */    public function __construct($value)    {        $this->count = $value;    }    /**     * Scores 6 when argument has preset number of elements.     *     * @param $argument     *     * @return bool|int     */    public function scoreArgument($argument)    {        return $this->isCountable($argument) && $this->hasProperCount($argument) ? 6 : false;    }    /**     * Returns false.     *     * @return boolean     */    public function isLast()    {        return false;    }    /**     * Returns string representation for token.     *     * @return string     */    public function __toString()    {        return sprintf('count(%s)', $this->count);    }    /**     * Returns true if object is either array or instance of \Countable     *     * @param $argument     * @return bool     */    private function isCountable($argument)    {        return (is_array($argument) || $argument instanceof \Countable);    }    /**     * Returns true if $argument has expected number of elements     *     * @param array|\Countable $argument     *     * @return bool     */    private function hasProperCount($argument)    {        return $this->count === count($argument);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phpspec_prophecy_ArrayCountToken_2957, Returns true if $argument has expected number of elements\n\n @param array|\\Countable $argument\n\n @return bool\n, Returns true if $argument has expected number of elements,    private function hasProperCount($argument)    {        return $this->count === count($argument);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phpspec_prophecy_ArrayEntryToken_2958, Array entry token.\n\n @author Boris Mikhaylov <kaguxmail@gmail.com>\n, Array entry token.,"class ArrayEntryToken implements TokenInterface{    /** @var \Prophecy\Argument\Token\TokenInterface */    private $key;    /** @var \Prophecy\Argument\Token\TokenInterface */    private $value;    /**     * @param mixed $key   exact value or token     * @param mixed $value exact value or token     */    public function __construct($key, $value)    {        $this->key = $this->wrapIntoExactValueToken($key);        $this->value = $this->wrapIntoExactValueToken($value);    }    /**     * Scores half of combined scores from key and value tokens for same entry. Capped at 8.     * If argument implements \ArrayAccess without \Traversable, then key token is restricted to ExactValueToken.     *     * @param array|\ArrayAccess|\Traversable $argument     *     * @throws \Prophecy\Exception\InvalidArgumentException     * @return bool|int     */    public function scoreArgument($argument)    {        if ($argument instanceof \Traversable) {            $argument = iterator_to_array($argument);        }        if ($argument instanceof \ArrayAccess) {            $argument = $this->convertArrayAccessToEntry($argument);        }        if (!is_array($argument) || empty($argument)) {            return false;        }        $keyScores = array_map(array($this->key,'scoreArgument'), array_keys($argument));        $valueScores = array_map(array($this->value,'scoreArgument'), $argument);        $scoreEntry = function ($value, $key) {            return $value && $key ? min(8, ($key + $value) / 2) : false;        };        return max(array_map($scoreEntry, $valueScores, $keyScores));    }    /**     * Returns false.     *     * @return boolean     */    public function isLast()    {        return false;    }    /**     * Returns string representation for token.     *     * @return string     */    public function __toString()    {        return sprintf('[..., %s => %s, ...]', $this->key, $this->value);    }    /**     * Returns key     *     * @return TokenInterface     */    public function getKey()    {        return $this->key;    }    /**     * Returns value     *     * @return TokenInterface     */    public function getValue()    {        return $this->value;    }    /**     * Wraps non token $value into ExactValueToken     *     * @param $value     * @return TokenInterface     */    private function wrapIntoExactValueToken($value)    {        return $value instanceof TokenInterface ? $value : new ExactValueToken($value);    }    /**     * Converts instance of \ArrayAccess to key => value array entry     *     * @param \ArrayAccess $object     *     * @return array|null     * @throws \Prophecy\Exception\InvalidArgumentException     */    private function convertArrayAccessToEntry(\ArrayAccess $object)    {        if (!$this->key instanceof ExactValueToken) {            throw new InvalidArgumentException(sprintf(                'You can only use exact value tokens to match key of ArrayAccess object'.PHP_EOL.                'But you used `%s`.',                $this->key            ));        }        $key = $this->key->getValue();        return $object->offsetExists($key) ? array($key => $object[$key]) : array();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phpspec_prophecy_ArrayEntryToken_2965, Wraps non token $value into ExactValueToken\n\n @param $value\n @return TokenInterface\n, Wraps non token $value into ExactValueToken,    private function wrapIntoExactValueToken($value)    {        return $value instanceof TokenInterface ? $value : new ExactValueToken($value);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ArrayHasSameValuesConstraint_2178, PHPUnit constraint matching arrays with same elemnts even in different order.\n, PHPUnit constraint matching arrays with same elemnts even in different order.,"class ArrayHasSameValuesConstraint extends \PHPUnit\Framework\Constraint\Constraint{    protected $array;    /**     * @param array $array     */    public function __construct(array $array)    {        $this->array = $array;    }    /**     * {@inheritdoc}     */    public function matches($other): bool    {        if (count($this->array) !== count($other)) {            return false;        }        if (array_diff($this->array, $other)) {            return false;        }        return true;    }    /**     * {@inheritdoc}     */    public function toString(): string    {        return 'two arrays contain the same elements.';    }    /**     * {@inheritdoc}     */    protected function failureDescription($other): string    {        return $this->toString();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClientTest_2314, Returns a mock object simulating an aggregate connection initializer.\\n\\n @param ParametersInterface|array|string $parameters Expected connection parameters\\n\\n @return callable|MockObject\\n, Returns a mock object simulating an aggregate connection initializer.,"    protected function getAggregateInitializer($parameters)    {        $connection = $this->getMockBuilder('Predis\Connection\AggregateConnectionInterface')->getMock();        $callable = $this->getMockBuilder('stdClass')            ->addMethods(array('__invoke'))            ->getMock();        $callable            ->expects($this->once())            ->method('__invoke')            ->with(                $parameters,                $this->isInstanceOf('Predis\Configuration\OptionsInterface'),                $this->isInstanceOf('Predis\Configuration\OptionInterface')            )            ->willReturn($connection);        return $callable;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_Client_2131, Returns the current state of the underlying connection.\\n\\n @return bool\\n, Returns the current state of the underlying connection.,    public function isConnected()    {        return $this->connection->isConnected();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_Client_2136," Creates a new pipeline context and returns it, or returns the results of\n a pipeline executed inside the optionally provided callable object.\n\n @param mixed ... Array of options, a callable for execution, or both.\n\n @return Pipeline|array\n"," Creates a new pipeline context and returns it, or returns the results of","    public function pipeline(/* arguments */)    {        return $this->sharedContextFactory('createPipeline', func_get_args());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_Client_2137," Creates a new transaction context and returns it, or returns the results\n of a transaction executed inside the optionally provided callable object.\n\n @param mixed ... Array of options, a callable for execution, or both.\n\n @return MultiExecTransaction|array\n"," Creates a new transaction context and returns it, or returns the results","    public function transaction(/* arguments */)    {        return $this->sharedContextFactory('createTransaction', func_get_args());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2165, Extracts the key from SORT command.\n\n @param CommandInterface $command Command instance.\n\n @return string|null\n, Extracts the key from SORT command.,    protected function getKeyFromSortCommand(CommandInterface $command)    {        $arguments = $command->getArguments();        $firstKey = $arguments[0];        if (1 === $argc = count($arguments)) {            return $firstKey;        }        $keys = array($firstKey);        for ($i = 1; $i < $argc; ++$i) {            if (strtoupper($arguments[$i]) === 'STORE') {                $keys[] = $arguments[++$i];            }        }        if ($this->checkSameSlotForKeys($keys)) {            return $firstKey;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2166, Extracts the key from BLPOP and BRPOP commands.\n\n @param CommandInterface $command Command instance.\n\n @return string|null\n, Extracts the key from BLPOP and BRPOP commands.,"    protected function getKeyFromBlockingListCommands(CommandInterface $command)    {        $arguments = $command->getArguments();        if ($this->checkSameSlotForKeys(array_slice($arguments, 0, count($arguments) - 1))) {            return $arguments[0];        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2169, Extracts the key from ZINTERSTORE and ZUNIONSTORE commands.\n\n @param CommandInterface $command Command instance.\n\n @return string|null\n, Extracts the key from ZINTERSTORE and ZUNIONSTORE commands.,"    protected function getKeyFromZsetAggregationCommands(CommandInterface $command)    {        $arguments = $command->getArguments();        $keys = array_merge(array($arguments[0]), array_slice($arguments, 2, $arguments[1]));        if ($this->checkSameSlotForKeys($keys)) {            return $arguments[0];        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2173," Returns only the hashable part of a key (delimited by ""{...}""), or the\\n whole key if a key tag is not found in the string.\\n\\n @param string $key A key.\\n\\n @return string\\n"," Returns only the hashable part of a key (delimited by ""{...}""), or the","    protected function extractKeyTag($key)    {        if (false !== $start = strpos($key, '{')) {            if (false !== ($end = strpos($key, '}', $start)) && $end !== ++$start) {                $key = substr($key, $start, $end - $start);            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_CommunicationException_2154, Indicates if the receiver should reset the underlying connection.\\n\\n @return bool\\n, Indicates if the receiver should reset the underlying connection.,    public function shouldResetConnection()    {        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_PredisCommandTestCase_2187, Verifies if the command implements the prefixable interface.\n\n @return bool\n, Verifies if the command implements the prefixable interface.,    protected function isPrefixable(): bool    {        return $this->getCommand() instanceof Command\PrefixableCommandInterface;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_PredisConnectionTestCase_2227, Returns a named array with the default connection parameters and their values.\\n\\n @return array Default connection parameters.\\n, Returns a named array with the default connection parameters and their values.,"    protected function getDefaultParametersArray(): array    {        return array(            'scheme' => 'tcp',            'host' => constant('REDIS_SERVER_HOST'),            'port' => constant('REDIS_SERVER_PORT'),            'database' => constant('REDIS_SERVER_DBNUM'),            'read_write_timeout' => 2,        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_PredisStrategy_2174, Default cluster strategy used by Predis to handle client-side sharding.\\n\\n @author Daniele Alessandri <suppakilla@gmail.com>\\n, Default cluster strategy used by Predis to handle client-side sharding.,class PredisStrategy extends ClusterStrategy{    protected $distributor;    /**     * @param DistributorInterface $distributor Optional distributor instance.     */    public function __construct(DistributorInterface $distributor = null)    {        parent::__construct();        $this->distributor = $distributor ?: new HashRing();    }    /**     * {@inheritdoc}     */    public function getSlotByKey($key)    {        $key = $this->extractKeyTag($key);        $hash = $this->distributor->hash($key);        $slot = $this->distributor->getSlot($hash);        return $slot;    }    /**     * {@inheritdoc}     */    protected function checkSameSlotForKeys(array $keys)    {        if (!$count = count($keys)) {            return false;        }        $currentKey = $this->extractKeyTag($keys[0]);        for ($i = 1; $i < $count; ++$i) {            $nextKey = $this->extractKeyTag($keys[$i]);            if ($currentKey !== $nextKey) {                return false;            }            $currentKey = $nextKey;        }        return true;    }    /**     * {@inheritdoc}     */    public function getDistributor()    {        return $this->distributor;    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_PredisTestCase_2237, Pauses the test case for the specified amount of time in seconds.\\n\\n @param float $seconds Seconds to sleep\\n, Pauses the test case for the specified amount of time in seconds.,    protected function sleep(float $seconds): void    {        usleep($seconds * 1000000);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_PredisTestCase_2240, Merges a named array of connection parameters with current defaults.\n\n @param array $additional Additional connection parameters\n\n @return array\n, Merges a named array of connection parameters with current defaults.,"    protected function getParametersArray(array $additional): array    {        return array_merge($this->getDefaultParametersArray(), $additional);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_PredisTestCase_2244, Compares the specified version string against the Redis server version in\n use for integration tests.\n\n @param string $operator Comparison operator\n @param string $version  Version to compare\n\n @return bool\n, Compares the specified version string against the Redis server version in,"    public function isRedisServerVersion(string $operator, string $version): bool    {        $serverVersion = $this->getRedisServerVersion();        $comparation = version_compare($serverVersion, $version);        return (bool) eval(""return $comparation $operator 0;"");    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_dispatcher_loop_2119, Attach a function to control the dispatcher loop termination with a message.\n, Attach a function to control the dispatcher loop termination with a message.,"$dispatcher->attachCallback('control', function ($payload, $dispatcher) {    if ($payload === 'terminate_dispatcher') {        $dispatcher->stop();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_BinaryUtils_1882, Provides binary math utilities\\n, Provides binary math utilities,"class BinaryUtils{    /**     * Applies the RFC 4122 variant field to the 16-bit clock sequence     *     * @link http://tools.ietf.org/html/rfc4122#section-4.1.1 RFC 4122, § 4.1.1: Variant     *     * @param int $clockSeq The 16-bit clock sequence value before the RFC 4122     *     variant is applied     *     * @return int The 16-bit clock sequence multiplexed with the UUID variant     *     * @psalm-pure     */    public static function applyVariant(int $clockSeq): int    {        $clockSeq = $clockSeq & 0x3fff;        $clockSeq |= 0x8000;        return $clockSeq;    }    /**     * Applies the RFC 4122 version number to the 16-bit `time_hi_and_version` field     *     * @link http://tools.ietf.org/html/rfc4122#section-4.1.3 RFC 4122, § 4.1.3: Version     *     * @param int $timeHi The value of the 16-bit `time_hi_and_version` field     *     before the RFC 4122 version is applied     * @param int $version The RFC 4122 version to apply to the `time_hi` field     *     * @return int The 16-bit time_hi field of the timestamp multiplexed with     *     the UUID version number     *     * @psalm-pure     */    public static function applyVersion(int $timeHi, int $version): int    {        $timeHi = $timeHi & 0x0fff;        $timeHi |= $version << 12;        return $timeHi;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_BinaryUtils_1883," Applies the RFC 4122 variant field to the 16-bit clock sequence\\n\\n @link http://tools.ietf.org/html/rfc4122#section-4.1.1 RFC 4122, § 4.1.1: Variant\\n\\n @param int $clockSeq The 16-bit clock sequence value before the RFC 4122\\n     variant is applied\\n\\n @return int The 16-bit clock sequence multiplexed with the UUID variant\\n\\n @psalm-pure\\n", Applies the RFC 4122 variant field to the 16-bit clock sequence,    public static function applyVariant(int $clockSeq): int    {        $clockSeq = $clockSeq & 0x3fff;        $clockSeq |= 0x8000;        return $clockSeq;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_BinaryUtils_1884," Applies the RFC 4122 version number to the 16-bit `time_hi_and_version` field\\n\\n @link http://tools.ietf.org/html/rfc4122#section-4.1.3 RFC 4122, § 4.1.3: Version\\n\\n @param int $timeHi The value of the 16-bit `time_hi_and_version` field\\n     before the RFC 4122 version is applied\\n @param int $version The RFC 4122 version to apply to the `time_hi` field\\n\\n @return int The 16-bit time_hi field of the timestamp multiplexed with\\n     the UUID version number\\n\\n @psalm-pure\\n", Applies the RFC 4122 version number to the 16-bit `time_hi_and_version` field,"    public static function applyVersion(int $timeHi, int $version): int    {        $timeHi = $timeHi & 0x0fff;        $timeHi |= $version << 12;        return $timeHi;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_ExpectedBehaviorTest_2024," These tests exist to ensure a seamless upgrade path from 3.x to 4.x. If any\n of these tests fail in 4.x, then it's because we've changed functionality\n in such a way that compatibility with 3.x is broken.\n\n Naturally, there are some BC-breaks between 3.x and 4.x, but these tests\n ensure that the base-level functionality that satisfies 80% of use-cases\n does not change. The remaining 20% of use-cases should refer to the README\n for details on the easiest path to transition from 3.x to 4.x.\n\n @codingStandardsIgnoreFile\n", These tests exist to ensure a seamless upgrade path from 3.x to 4.x. If any,"class ExpectedBehaviorTest extends TestCase{    /**     * @dataProvider provideStaticCreationMethods     */    public function testStaticCreationMethodsAndStandardBehavior($method, $args)    {        $uuid = call_user_func_array(['Ramsey\Uuid\Uuid', $method], $args);        $this->assertInstanceOf('Ramsey\Uuid\UuidInterface', $uuid);        $this->assertIsInt($uuid->compareTo(Uuid::uuid1()));        $this->assertNotSame(0, $uuid->compareTo(Uuid::uuid4()));        $this->assertSame(0, $uuid->compareTo(clone $uuid));        $this->assertFalse($uuid->equals(new stdClass()));        $this->assertTrue($uuid->equals(clone $uuid));        $this->assertIsString($uuid->getBytes());        $this->assertInstanceOf('Ramsey\Uuid\Converter\NumberConverterInterface', $uuid->getNumberConverter());        $this->assertIsString((string) $uuid->getHex());        $this->assertIsArray($uuid->getFieldsHex());        $this->assertArrayHasKey('time_low', $uuid->getFieldsHex());        $this->assertArrayHasKey('time_mid', $uuid->getFieldsHex());        $this->assertArrayHasKey('time_hi_and_version', $uuid->getFieldsHex());        $this->assertArrayHasKey('clock_seq_hi_and_reserved', $uuid->getFieldsHex());        $this->assertArrayHasKey('clock_seq_low', $uuid->getFieldsHex());        $this->assertArrayHasKey('node', $uuid->getFieldsHex());        $this->assertIsString($uuid->getTimeLowHex());        $this->assertIsString($uuid->getTimeMidHex());        $this->assertIsString($uuid->getTimeHiAndVersionHex());        $this->assertIsString($uuid->getClockSeqHiAndReservedHex());        $this->assertIsString($uuid->getClockSeqLowHex());        $this->assertIsString($uuid->getNodeHex());        $this->assertSame($uuid->getFieldsHex()['time_low'], $uuid->getTimeLowHex());        $this->assertSame($uuid->getFieldsHex()['time_mid'], $uuid->getTimeMidHex());        $this->assertSame($uuid->getFieldsHex()['time_hi_and_version'], $uuid->getTimeHiAndVersionHex());        $this->assertSame($uuid->getFieldsHex()['clock_seq_hi_and_reserved'], $uuid->getClockSeqHiAndReservedHex());        $this->assertSame($uuid->getFieldsHex()['clock_seq_low'], $uuid->getClockSeqLowHex());        $this->assertSame($uuid->getFieldsHex()['node'], $uuid->getNodeHex());        $this->assertSame(substr((string) $uuid->getHex(), 16), $uuid->getLeastSignificantBitsHex());        $this->assertSame(substr((string) $uuid->getHex(), 0, 16), $uuid->getMostSignificantBitsHex());        $this->assertSame(            (string) $uuid->getHex(),            $uuid->getTimeLowHex()            . $uuid->getTimeMidHex()            . $uuid->getTimeHiAndVersionHex()            . $uuid->getClockSeqHiAndReservedHex()            . $uuid->getClockSeqLowHex()            . $uuid->getNodeHex()        );        $this->assertSame(            (string) $uuid->getHex(),            $uuid->getFieldsHex()['time_low']            . $uuid->getFieldsHex()['time_mid']            . $uuid->getFieldsHex()['time_hi_and_version']            . $uuid->getFieldsHex()['clock_seq_hi_and_reserved']            . $uuid->getFieldsHex()['clock_seq_low']            . $uuid->getFieldsHex()['node']        );        $this->assertIsString($uuid->getUrn());        $this->assertStringStartsWith('urn:uuid:', $uuid->getUrn());        $this->assertSame('urn:uuid:' . (string) $uuid->getHex(), str_replace('-', '', $uuid->getUrn()));        $this->assertSame((string) $uuid->getHex(), str_replace('-', '', $uuid->toString()));        $this->assertSame((string) $uuid->getHex(), str_replace('-', '', (string) $uuid));        $this->assertSame(            $uuid->toString(),            $uuid->getTimeLowHex() . '-'            . $uuid->getTimeMidHex() . '-'            . $uuid->getTimeHiAndVersionHex() . '-'            . $uuid->getClockSeqHiAndReservedHex()            . $uuid->getClockSeqLowHex() . '-'            . $uuid->getNodeHex()        );        $this->assertSame(            (string) $uuid,            $uuid->getTimeLowHex() . '-'            . $uuid->getTimeMidHex() . '-'            . $uuid->getTimeHiAndVersionHex() . '-'            . $uuid->getClockSeqHiAndReservedHex()            . $uuid->getClockSeqLowHex() . '-'            . $uuid->getNodeHex()        );        $this->assertSame(2, $uuid->getVariant());        $this->assertSame((int) substr($method, -1), $uuid->getVersion());        $this->assertTrue(ctype_digit((string) $uuid->getInteger()));    }    public function provideStaticCreationMethods()    {        return [            ['uuid1', []],            ['uuid1', ['00000fffffff']],            ['uuid1', [null, 1234]],            ['uuid1', ['00000fffffff', 1234]],            ['uuid1', ['00000fffffff', null]],            ['uuid1', [268435455]],            ['uuid1', [268435455, 1234]],            ['uuid1', [268435455, null]],            ['uuid3', [Uuid::NAMESPACE_URL, 'https://example.com/foo']],            ['uuid4', []],            ['uuid5', [Uuid::NAMESPACE_URL, 'https://example.com/foo']],        ];    }    public function testUuidVersion1MethodBehavior()    {        $uuid = Uuid::uuid1('00000fffffff', 0xffff);        $this->assertInstanceOf('DateTimeInterface', $uuid->getDateTime());        $this->assertSame('00000fffffff', $uuid->getNodeHex());        $this->assertSame('3fff', $uuid->getClockSequenceHex());        $this->assertSame('16383', (string) $uuid->getClockSequence());    }    public function testUuidVersion1MethodBehavior64Bit()    {        $uuid = Uuid::uuid1('ffffffffffff', 0xffff);        $this->assertInstanceOf('DateTimeInterface', $uuid->getDateTime());        $this->assertSame('ffffffffffff', $uuid->getNodeHex());        $this->assertSame('281474976710655', (string) $uuid->getNode());        $this->assertSame('3fff', $uuid->getClockSequenceHex());        $this->assertSame('16383', (string) $uuid->getClockSequence());        $this->assertTrue(ctype_digit((string) $uuid->getTimestamp()));    }    /**     * @dataProvider provideIsValid     */    public function testIsValid($uuid, $expected)    {        $this->assertSame($expected, Uuid::isValid($uuid), ""{$uuid} is not a valid UUID"");        $this->assertSame($expected, Uuid::isValid(strtoupper($uuid)), strtoupper($uuid) . ' is not a valid UUID');    }    public function provideIsValid()    {        return [            // RFC 4122 UUIDs            ['00000000-0000-0000-0000-000000000000', true],            ['ff6f8cb0-c57d-11e1-8b21-0800200c9a66', true],            ['ff6f8cb0-c57d-11e1-9b21-0800200c9a66', true],            ['ff6f8cb0-c57d-11e1-ab21-0800200c9a66', true],            ['ff6f8cb0-c57d-11e1-bb21-0800200c9a66', true],            ['ff6f8cb0-c57d-21e1-8b21-0800200c9a66', true],            ['ff6f8cb0-c57d-21e1-9b21-0800200c9a66', true],            ['ff6f8cb0-c57d-21e1-ab21-0800200c9a66', true],            ['ff6f8cb0-c57d-21e1-bb21-0800200c9a66', true],            ['ff6f8cb0-c57d-31e1-8b21-0800200c9a66', true],            ['ff6f8cb0-c57d-31e1-9b21-0800200c9a66', true],            ['ff6f8cb0-c57d-31e1-ab21-0800200c9a66', true],            ['ff6f8cb0-c57d-31e1-bb21-0800200c9a66', true],            ['ff6f8cb0-c57d-41e1-8b21-0800200c9a66', true],            ['ff6f8cb0-c57d-41e1-9b21-0800200c9a66', true],            ['ff6f8cb0-c57d-41e1-ab21-0800200c9a66', true],            ['ff6f8cb0-c57d-41e1-bb21-0800200c9a66', true],            ['ff6f8cb0-c57d-51e1-8b21-0800200c9a66', true],            ['ff6f8cb0-c57d-51e1-9b21-0800200c9a66', true],            ['ff6f8cb0-c57d-51e1-ab21-0800200c9a66', true],            ['ff6f8cb0-c57d-51e1-bb21-0800200c9a66', true],            // Non RFC 4122 UUIDs            ['ffffffff-ffff-ffff-ffff-ffffffffffff', true],            ['ff6f8cb0-c57d-01e1-0b21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-1b21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-2b21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-3b21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-4b21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-5b21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-6b21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-7b21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-db21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-eb21-0800200c9a66', true],            ['ff6f8cb0-c57d-01e1-fb21-0800200c9a66', true],            // Other valid patterns            ['{ff6f8cb0-c57d-01e1-fb21-0800200c9a66}', true],            ['urn:uuid:ff6f8cb0-c57d-01e1-fb21-0800200c9a66', true],            // Invalid UUIDs            ['ffffffffffffffffffffffffffffffff', false],            ['00000000000000000000000000000000', false],            [0, false],            ['foobar', false],            ['ff6f8cb0c57d51e1bb210800200c9a66', false],            ['gf6f8cb0-c57d-51e1-bb21-0800200c9a66', false],        ];    }    /**     * @dataProvider provideFromStringInteger     */    public function testSerialization($string)    {        $uuid = Uuid::fromString($string);        $serialized = serialize($uuid);        $unserialized = unserialize($serialized);        $this->assertSame(0, $uuid->compareTo($unserialized));        $this->assertTrue($uuid->equals($unserialized));        $this->assertSame(""\""{$string}\"""", json_encode($uuid));    }    /**     * @dataProvider provideFromStringInteger     */    public function testNumericReturnValues($string)    {        $leastSignificantBitsHex = substr(str_replace('-', '', $string), 16);        $mostSignificantBitsHex = substr(str_replace('-', '', $string), 0, 16);        $leastSignificantBits = BigNumber::convertToBase10($leastSignificantBitsHex, 16);        $mostSignificantBits = BigNumber::convertToBase10($mostSignificantBitsHex, 16);        $components = explode('-', $string);        array_walk($components, function (&$value) {            $value = BigNumber::convertToBase10($value, 16);        });        $clockSeq = (int) $components[3] & 0x3fff;        $clockSeqHiAndReserved = (int) $components[3] >> 8;        $clockSeqLow = (int) $components[3] & 0x00ff;        $uuid = Uuid::fromString($string);        $this->assertSame($components[0], (string) $uuid->getTimeLow());        $this->assertSame($components[1], (string) $uuid->getTimeMid());        $this->assertSame($components[2], (string) $uuid->getTimeHiAndVersion());        $this->assertSame((string) $clockSeq, (string) $uuid->getClockSequence());        $this->assertSame((string) $clockSeqHiAndReserved, (string) $uuid->getClockSeqHiAndReserved());        $this->assertSame((string) $clockSeqLow, (string) $uuid->getClockSeqLow());        $this->assertSame($components[4], (string) $uuid->getNode());        $this->assertSame($leastSignificantBits, (string) $uuid->getLeastSignificantBits());        $this->assertSame($mostSignificantBits, (string) $uuid->getMostSignificantBits());    }    /**     * @dataProvider provideFromStringInteger     */    public function testFromBytes($string, $version, $variant, $integer)    {        $bytes = hex2bin(str_replace('-', '', $string));        $uuid = Uuid::fromBytes($bytes);        $this->assertInstanceOf('Ramsey\Uuid\UuidInterface', $uuid);        $this->assertSame($string, $uuid->toString());        $this->assertSame($version, $uuid->getVersion());        $this->assertSame($variant, $uuid->getVariant());        $components = explode('-', $string);        $this->assertSame($components[0], $uuid->getTimeLowHex());        $this->assertSame($components[1], $uuid->getTimeMidHex());        $this->assertSame($components[2], $uuid->getTimeHiAndVersionHex());        $this->assertSame($components[3], $uuid->getClockSeqHiAndReservedHex() . $uuid->getClockSeqLowHex());        $this->assertSame($components[4], $uuid->getNodeHex());        $this->assertSame($integer, (string) $uuid->getInteger());        $this->assertSame($bytes, $uuid->getBytes());    }    /**     * @dataProvider provideFromStringInteger     */    public function testFromInteger($string, $version, $variant, $integer)    {        $bytes = hex2bin(str_replace('-', '', $string));        $uuid = Uuid::fromInteger($integer);        $this->assertInstanceOf('Ramsey\Uuid\UuidInterface', $uuid);        $this->assertSame($string, $uuid->toString());        $this->assertSame($version, $uuid->getVersion());        $this->assertSame($variant, $uuid->getVariant());        $components = explode('-', $string);        $this->assertSame($components[0], $uuid->getTimeLowHex());        $this->assertSame($components[1], $uuid->getTimeMidHex());        $this->assertSame($components[2], $uuid->getTimeHiAndVersionHex());        $this->assertSame($components[3], $uuid->getClockSeqHiAndReservedHex() . $uuid->getClockSeqLowHex());        $this->assertSame($components[4], $uuid->getNodeHex());        $this->assertSame($integer, (string) $uuid->getInteger());        $this->assertSame($bytes, $uuid->getBytes());    }    /**     * @dataProvider provideFromStringInteger     */    public function testFromString($string, $version, $variant, $integer)    {        $bytes = hex2bin(str_replace('-', '', $string));        $uuid = Uuid::fromString($string);        $this->assertInstanceOf('Ramsey\Uuid\UuidInterface', $uuid);        $this->assertSame($string, $uuid->toString());        $this->assertSame($version, $uuid->getVersion());        $this->assertSame($variant, $uuid->getVariant());        $components = explode('-', $string);        $this->assertSame($components[0], $uuid->getTimeLowHex());        $this->assertSame($components[1], $uuid->getTimeMidHex());        $this->assertSame($components[2], $uuid->getTimeHiAndVersionHex());        $this->assertSame($components[3], $uuid->getClockSeqHiAndReservedHex() . $uuid->getClockSeqLowHex());        $this->assertSame($components[4], $uuid->getNodeHex());        $this->assertSame($integer, (string) $uuid->getInteger());        $this->assertSame($bytes, $uuid->getBytes());    }    public function provideFromStringInteger()    {        return [            ['00000000-0000-0000-0000-000000000000', null, 0, '0'],            ['ff6f8cb0-c57d-11e1-8b21-0800200c9a66', 1, 2, '339532337419071774304650190139318639206'],            ['ff6f8cb0-c57d-11e1-9b21-0800200c9a66', 1, 2, '339532337419071774305803111643925486182'],            ['ff6f8cb0-c57d-11e1-ab21-0800200c9a66', 1, 2, '339532337419071774306956033148532333158'],            ['ff6f8cb0-c57d-11e1-bb21-0800200c9a66', 1, 2, '339532337419071774308108954653139180134'],            ['ff6f8cb0-c57d-21e1-8b21-0800200c9a66', 2, 2, '339532337419071849862513916053642058342'],            ['ff6f8cb0-c57d-21e1-9b21-0800200c9a66', 2, 2, '339532337419071849863666837558248905318'],            ['ff6f8cb0-c57d-21e1-ab21-0800200c9a66', 2, 2, '339532337419071849864819759062855752294'],            ['ff6f8cb0-c57d-21e1-bb21-0800200c9a66', 2, 2, '339532337419071849865972680567462599270'],            ['ff6f8cb0-c57d-31e1-8b21-0800200c9a66', 3, 2, '339532337419071925420377641967965477478'],            ['ff6f8cb0-c57d-31e1-9b21-0800200c9a66', 3, 2, '339532337419071925421530563472572324454'],            ['ff6f8cb0-c57d-31e1-ab21-0800200c9a66', 3, 2, '339532337419071925422683484977179171430'],            ['ff6f8cb0-c57d-31e1-bb21-0800200c9a66', 3, 2, '339532337419071925423836406481786018406'],            ['ff6f8cb0-c57d-41e1-8b21-0800200c9a66', 4, 2, '339532337419072000978241367882288896614'],            ['ff6f8cb0-c57d-41e1-9b21-0800200c9a66', 4, 2, '339532337419072000979394289386895743590'],            ['ff6f8cb0-c57d-41e1-ab21-0800200c9a66', 4, 2, '339532337419072000980547210891502590566'],            ['ff6f8cb0-c57d-41e1-bb21-0800200c9a66', 4, 2, '339532337419072000981700132396109437542'],            ['ff6f8cb0-c57d-51e1-8b21-0800200c9a66', 5, 2, '339532337419072076536105093796612315750'],            ['ff6f8cb0-c57d-51e1-9b21-0800200c9a66', 5, 2, '339532337419072076537258015301219162726'],            ['ff6f8cb0-c57d-51e1-ab21-0800200c9a66', 5, 2, '339532337419072076538410936805826009702'],            ['ff6f8cb0-c57d-51e1-bb21-0800200c9a66', 5, 2, '339532337419072076539563858310432856678'],            ['ff6f8cb0-c57d-01e1-0b21-0800200c9a66', null, 0, '339532337419071698737563092188140444262'],            ['ff6f8cb0-c57d-01e1-1b21-0800200c9a66', null, 0, '339532337419071698738716013692747291238'],            ['ff6f8cb0-c57d-01e1-2b21-0800200c9a66', null, 0, '339532337419071698739868935197354138214'],            ['ff6f8cb0-c57d-01e1-3b21-0800200c9a66', null, 0, '339532337419071698741021856701960985190'],            ['ff6f8cb0-c57d-01e1-4b21-0800200c9a66', null, 0, '339532337419071698742174778206567832166'],            ['ff6f8cb0-c57d-01e1-5b21-0800200c9a66', null, 0, '339532337419071698743327699711174679142'],            ['ff6f8cb0-c57d-01e1-6b21-0800200c9a66', null, 0, '339532337419071698744480621215781526118'],            ['ff6f8cb0-c57d-01e1-7b21-0800200c9a66', null, 0, '339532337419071698745633542720388373094'],            ['ff6f8cb0-c57d-01e1-cb21-0800200c9a66', null, 6, '339532337419071698751398150243422607974'],            ['ff6f8cb0-c57d-01e1-db21-0800200c9a66', null, 6, '339532337419071698752551071748029454950'],            ['ff6f8cb0-c57d-01e1-eb21-0800200c9a66', null, 7, '339532337419071698753703993252636301926'],            ['ff6f8cb0-c57d-01e1-fb21-0800200c9a66', null, 7, '339532337419071698754856914757243148902'],            ['ffffffff-ffff-ffff-ffff-ffffffffffff', null, 7, '340282366920938463463374607431768211455'],        ];    }    /**     * @runInSeparateProcess     * @preserveGlobalState disabled     */    public function testGetSetFactory()    {        $this->assertInstanceOf('Ramsey\Uuid\UuidFactory', Uuid::getFactory());        $factory = \Mockery::mock('Ramsey\Uuid\UuidFactory');        Uuid::setFactory($factory);        $this->assertSame($factory, Uuid::getFactory());    }    /**     * @runInSeparateProcess     * @preserveGlobalState disabled     */    public function testFactoryProvidesFunctionality()    {        $uuid = \Mockery::mock('Ramsey\Uuid\UuidInterface');        $factory = \Mockery::mock('Ramsey\Uuid\UuidFactoryInterface', [            'uuid1' => $uuid,            'uuid3' => $uuid,            'uuid4' => $uuid,            'uuid5' => $uuid,            'fromBytes' => $uuid,            'fromString' => $uuid,            'fromInteger' => $uuid,        ]);        Uuid::setFactory($factory);        $this->assertSame($uuid, Uuid::uuid1('ffffffffffff', 0xffff));        $this->assertSame($uuid, Uuid::uuid3(Uuid::NAMESPACE_URL, 'https://example.com/foo'));        $this->assertSame($uuid, Uuid::uuid4());        $this->assertSame($uuid, Uuid::uuid5(Uuid::NAMESPACE_URL, 'https://example.com/foo'));        $this->assertSame($uuid, Uuid::fromBytes(hex2bin('ffffffffffffffffffffffffffffffff')));        $this->assertSame($uuid, Uuid::fromString('ffffffff-ffff-ffff-ffff-ffffffffffff'));        $this->assertSame($uuid, Uuid::fromInteger('340282366920938463463374607431768211455'));    }    /**     * @runInSeparateProcess     * @preserveGlobalState disabled     */    public function testUsingDegradedFeatures()    {        $numberConverter = new DegradedNumberConverter();        $builder = new DegradedUuidBuilder($numberConverter);        $factory = new UuidFactory();        $factory->setNumberConverter($numberConverter);        $factory->setUuidBuilder($builder);        Uuid::setFactory($factory);        $uuid = Uuid::uuid1();        $this->assertInstanceOf('Ramsey\Uuid\UuidInterface', $uuid);        $this->assertInstanceOf('Ramsey\Uuid\DegradedUuid', $uuid);        $this->assertInstanceOf('Ramsey\Uuid\Converter\Number\DegradedNumberConverter', $uuid->getNumberConverter());    }    /**     * @runInSeparateProcess     * @preserveGlobalState disabled     */    public function testUsingCustomCodec()    {        $mockUuid = \Mockery::mock('Ramsey\Uuid\UuidInterface');        $codec = \Mockery::mock('Ramsey\Uuid\Codec\CodecInterface', [            'encode' => 'abcd1234',            'encodeBinary' => hex2bin('abcd1234'),            'decode' => $mockUuid,            'decodeBytes' => $mockUuid,        ]);        $factory = new UuidFactory();        $factory->setCodec($codec);        Uuid::setFactory($factory);        $uuid = Uuid::uuid4();        $this->assertSame('abcd1234', $uuid->toString());        $this->assertSame(hex2bin('abcd1234'), $uuid->getBytes());        $this->assertSame($mockUuid, Uuid::fromString('f00ba2'));        $this->assertSame($mockUuid, Uuid::fromBytes(hex2bin('f00ba2')));    }    /**     * @runInSeparateProcess     * @preserveGlobalState disabled     */    public function testUsingCustomRandomGenerator()    {        $generator = \Mockery::mock('Ramsey\Uuid\Generator\RandomGeneratorInterface', [            'generate' => hex2bin('01234567abcd5432dcba0123456789ab'),        ]);        $factory = new UuidFactory();        $factory->setRandomGenerator($generator);        Uuid::setFactory($factory);        $uuid = Uuid::uuid4();        $this->assertSame('01234567-abcd-4432-9cba-0123456789ab', $uuid->toString());    }    /**     * @runInSeparateProcess     * @preserveGlobalState disabled     */    public function testUsingCustomTimeGenerator()    {        $generator = \Mockery::mock('Ramsey\Uuid\Generator\TimeGeneratorInterface', [            'generate' => hex2bin('01234567abcd5432dcba0123456789ab'),        ]);        $factory = new UuidFactory();        $factory->setTimeGenerator($generator);        Uuid::setFactory($factory);        $uuid = Uuid::uuid1();        $this->assertSame('01234567-abcd-1432-9cba-0123456789ab', $uuid->toString());    }    /**     * @runInSeparateProcess     * @preserveGlobalState disabled     */    public function testUsingDefaultTimeGeneratorWithCustomProviders()    {        $nodeProvider = \Mockery::mock('Ramsey\Uuid\Provider\NodeProviderInterface', [            'getNode' => new Hexadecimal('0123456789ab'),        ]);        $timeConverter = \Mockery::mock('Ramsey\Uuid\Converter\TimeConverterInterface');        $timeConverter            ->shouldReceive('calculateTime')            ->andReturnUsing(function ($seconds, $microseconds) {                return new Hexadecimal('abcd' . dechex($microseconds) . dechex($seconds));            });        $timeProvider = \Mockery::mock('Ramsey\Uuid\Provider\TimeProviderInterface', [            'currentTime' => [                'sec' => 1578522046,                'usec' => 10000,            ],            'getTime' => new Time(1578522046, 10000),        ]);        $generator = new DefaultTimeGenerator($nodeProvider, $timeConverter, $timeProvider);        $factory = new UuidFactory();        $factory->setTimeGenerator($generator);        Uuid::setFactory($factory);        $uuid = Uuid::uuid1(null, 4095);        $this->assertSame('5e1655be-2710-1bcd-8fff-0123456789ab', $uuid->toString());    }    /**     * @runInSeparateProcess     * @preserveGlobalState disabled     */    public function testHelperFunctions()    {        $uuid1 = \Mockery::mock('Ramsey\Uuid\UuidInterface', [            'toString' => 'aVersion1Uuid',        ]);        $uuid3 = \Mockery::mock('Ramsey\Uuid\UuidInterface', [            'toString' => 'aVersion3Uuid',        ]);        $uuid4 = \Mockery::mock('Ramsey\Uuid\UuidInterface', [            'toString' => 'aVersion4Uuid',        ]);        $uuid5 = \Mockery::mock('Ramsey\Uuid\UuidInterface', [            'toString' => 'aVersion5Uuid',        ]);        $factory = \Mockery::mock('Ramsey\Uuid\UuidFactoryInterface', [            'uuid1' => $uuid1,            'uuid3' => $uuid3,            'uuid4' => $uuid4,            'uuid5' => $uuid5,        ]);        Uuid::setFactory($factory);        $this->assertSame('aVersion1Uuid', \Ramsey\Uuid\v1('ffffffffffff', 0xffff));        $this->assertSame('aVersion3Uuid', \Ramsey\Uuid\v3(Uuid::NAMESPACE_URL, 'https://example.com/foo'));        $this->assertSame('aVersion4Uuid', \Ramsey\Uuid\v4());        $this->assertSame('aVersion5Uuid', \Ramsey\Uuid\v5(Uuid::NAMESPACE_URL, 'https://example.com/foo'));    }    /**     * @link https://git.io/JvJZo Use of TimestampFirstCombCodec in laravel/framework     */    public function testUseOfTimestampFirstCombCodec()    {        $factory = new UuidFactory();        $factory->setRandomGenerator(new CombGenerator(            $factory->getRandomGenerator(),            $factory->getNumberConverter()        ));        $factory->setCodec(new TimestampFirstCombCodec(            $factory->getUuidBuilder()        ));        $uuid = $factory->uuid4();        // Swap fields according to the rules for TimestampFirstCombCodec.        $fields = array_values($uuid->getFieldsHex());        $last48Bits = $fields[5];        $fields[5] = $fields[0] . $fields[1];        $fields[0] = substr($last48Bits, 0, 8);        $fields[1] = substr($last48Bits, 8, 4);        $expectedHex = implode('', $fields);        $expectedBytes = hex2bin($expectedHex);        $this->assertInstanceOf('Ramsey\Uuid\UuidInterface', $uuid);        $this->assertSame(2, $uuid->getVariant());        $this->assertSame(4, $uuid->getVersion());        $this->assertSame($expectedBytes, $uuid->getBytes());        $this->assertSame($expectedHex, (string) $uuid->getHex());    }    /**     * @dataProvider provideUuidConstantTests     */    public function testUuidConstants($constantName, $expected)    {        $this->assertSame($expected, constant(""Ramsey\\Uuid\\Uuid::{$constantName}""));    }    public function provideUuidConstantTests()    {        return [            ['NAMESPACE_DNS', '6ba7b810-9dad-11d1-80b4-00c04fd430c8'],            ['NAMESPACE_URL', '6ba7b811-9dad-11d1-80b4-00c04fd430c8'],            ['NAMESPACE_OID', '6ba7b812-9dad-11d1-80b4-00c04fd430c8'],            ['NAMESPACE_X500', '6ba7b814-9dad-11d1-80b4-00c04fd430c8'],            ['NIL', '00000000-0000-0000-0000-000000000000'],            ['RESERVED_NCS', 0],            ['RFC_4122', 2],            ['RESERVED_MICROSOFT', 6],            ['RESERVED_FUTURE', 7],            ['VALID_PATTERN', '^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$'],            ['UUID_TYPE_TIME', 1],            ['UUID_TYPE_IDENTIFIER', 2],            ['UUID_TYPE_HASH_MD5', 3],            ['UUID_TYPE_RANDOM', 4],            ['UUID_TYPE_HASH_SHA1', 5],        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_FeatureSet_1930, Returns the builder configured for this environment\\n, Returns the builder configured for this environment,    public function getBuilder(): UuidBuilderInterface    {        return $this->builder;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_FeatureSet_1938, Returns the time converter configured for this environment\n, Returns the time converter configured for this environment,    public function getTimeConverter(): TimeConverterInterface    {        return $this->timeConverter;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_FeatureSet_1945, Set the validator to use in this environment\n, Set the validator to use in this environment,    public function setValidator(ValidatorInterface $validator): void    {        $this->validator = $validator;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_FeatureSet_1948, Returns a number converter configured for this environment\n, Returns a number converter configured for this environment,    private function buildNumberConverter(CalculatorInterface $calculator): NumberConverterInterface    {        return new GenericNumberConverter($calculator);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_FeatureSet_1949, Returns a random generator configured for this environment\n, Returns a random generator configured for this environment,    private function buildRandomGenerator(): RandomGeneratorInterface    {        if ($this->enablePecl) {            return new PeclUuidRandomGenerator();        }        return (new RandomGeneratorFactory())->getGenerator();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_FeatureSet_1950, Returns a time generator configured for this environment\n\n @param TimeProviderInterface $timeProvider The time provider to use with\n     the time generator\n, Returns a time generator configured for this environment,"    private function buildTimeGenerator(TimeProviderInterface $timeProvider): TimeGeneratorInterface    {        if ($this->enablePecl) {            return new PeclUuidTimeGenerator();        }        return (new TimeGeneratorFactory(            $this->nodeProvider,            $this->timeConverter,            $timeProvider        ))->getGenerator();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidFactory_1974, Returns the codec used by this factory\\n, Returns the codec used by this factory,    public function getCodec(): CodecInterface    {        return $this->codec;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidFactory_1975, Sets the codec to use for this factory\n\n @param CodecInterface $codec A UUID encoder-decoder\n, Sets the codec to use for this factory,    public function setCodec(CodecInterface $codec): void    {        $this->isDefaultFeatureSet = false;        $this->codec = $codec;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidFactory_1979, Returns the random generator used by this factory\\n, Returns the random generator used by this factory,    public function getRandomGenerator(): RandomGeneratorInterface    {        return $this->randomGenerator;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidFactory_1985," Sets the random generator to use for this factory\\n\\n @param RandomGeneratorInterface $generator A generator to generate binary\\n     data, based on some random input\\n", Sets the random generator to use for this factory,    public function setRandomGenerator(RandomGeneratorInterface $generator): void    {        $this->isDefaultFeatureSet = false;        $this->randomGenerator = $generator;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidFactory_1986, Sets the number converter to use for this factory\\n\\n @param NumberConverterInterface $converter A converter to use for working\\n     with large integers (i.e. integers greater than PHP_INT_MAX)\\n, Sets the number converter to use for this factory,    public function setNumberConverter(NumberConverterInterface $converter): void    {        $this->isDefaultFeatureSet = false;        $this->numberConverter = $converter;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidFactory_1987, Returns the UUID builder used by this factory\n, Returns the UUID builder used by this factory,    public function getUuidBuilder(): UuidBuilderInterface    {        return $this->uuidBuilder;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidTest_2044, Tests that UUID and GUID's have the same textual representation but not\n the same binary representation.\n, Tests that UUID and GUID's have the same textual representation but not,"    public function testFromGuidString(): void    {        $uuid = Uuid::fromString('ff6f8cb0-c57d-11e1-9b21-0800200c9a66');        Uuid::setFactory(new UuidFactory(new FeatureSet(true)));        $guid = Guid::fromString('ff6f8cb0-c57d-11e1-9b21-0800200c9a66');        // UUID's and GUID's share the same textual representation.        $this->assertSame($uuid->toString(), $guid->toString());        // But not the same binary representation.        $this->assertNotSame($uuid->getBytes(), $guid->getBytes());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidTest_2050, Tests that generated UUID's using timestamp first COMB are sequential\n, Tests that generated UUID's using timestamp first COMB are sequential,"    public function testUuid4TimestampFirstComb(): void    {        $mock = $this->getMockBuilder(RandomGeneratorInterface::class)->getMock();        $mock->expects($this->any())            ->method('generate')            ->willReturnCallback(function ($length) {                // Makes first fields of UUIDs equal                return hex2bin(str_pad('', $length * 2, '0'));            });        $factory = new UuidFactory();        $generator = new CombGenerator($mock, $factory->getNumberConverter());        $codec = new TimestampFirstCombCodec($factory->getUuidBuilder());        $factory->setRandomGenerator($generator);        $factory->setCodec($codec);        $previous = $factory->uuid4();        for ($i = 0; $i < 1000; $i++) {            usleep(100);            $uuid = $factory->uuid4();            $this->assertGreaterThan($previous->toString(), $uuid->toString());            $previous = $uuid;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidTest_2051, Test that COMB UUID's have a version 4 flag\\n, Test that COMB UUID's have a version 4 flag,"    public function testUuid4CombVersion(): void    {        $factory = new UuidFactory();        $generator = new CombGenerator(            (new RandomGeneratorFactory())->getGenerator(),            $factory->getNumberConverter()        );        $factory->setRandomGenerator($generator);        $uuid = $factory->uuid4();        $this->assertSame(4, $uuid->getVersion());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidTest_2057, Taken from the Python UUID tests in\n http://hg.python.org/cpython/file/2f4c4db9aee5/Lib/test/test_uuid.py\n\n @phpcsSuppress SlevomatCodingStandard.TypeHints.ReturnTypeHint.MissingTraversableTypeHintSpecification\n, Taken from the Python UUID tests in,"    public function providePythonTests(): array    {        // This array is taken directly from the Python tests, more or less.        return [            [                'string' => '00000000-0000-0000-0000-000000000000',                'curly' => '{00000000-0000-0000-0000-000000000000}',                'hex' => '00000000000000000000000000000000',                'bytes' => 'AAAAAAAAAAAAAAAAAAAAAA==',                'int' => '0',                'fields' => [                    'time_low' => '00000000',                    'time_mid' => '0000',                    'time_hi_and_version' => '0000',                    'clock_seq_hi_and_reserved' => '00',                    'clock_seq_low' => '00',                    'node' => '000000000000',                ],                'urn' => 'urn:uuid:00000000-0000-0000-0000-000000000000',                'time' => '0',                'clock_seq' => '0000',                'variant' => Uuid::RESERVED_NCS,                'version' => null,            ],            [                'string' => '00010203-0405-0607-0809-0a0b0c0d0e0f',                'curly' => '{00010203-0405-0607-0809-0a0b0c0d0e0f}',                'hex' => '000102030405060708090a0b0c0d0e0f',                'bytes' => 'AAECAwQFBgcICQoLDA0ODw==',                'int' => '5233100606242806050955395731361295',                'fields' => [                    'time_low' => '00010203',                    'time_mid' => '0405',                    'time_hi_and_version' => '0607',                    'clock_seq_hi_and_reserved' => '08',                    'clock_seq_low' => '09',                    'node' => '0a0b0c0d0e0f',                ],                'urn' => 'urn:uuid:00010203-0405-0607-0809-0a0b0c0d0e0f',                'time' => '607040500010203',                'clock_seq' => '0809',                'variant' => Uuid::RESERVED_NCS,                'version' => null,            ],            [                'string' => '02d9e6d5-9467-382e-8f9b-9300a64ac3cd',                'curly' => '{02d9e6d5-9467-382e-8f9b-9300a64ac3cd}',                'hex' => '02d9e6d59467382e8f9b9300a64ac3cd',                'bytes' => 'Atnm1ZRnOC6Pm5MApkrDzQ==',                'int' => '3789866285607910888100818383505376205',                'fields' => [                    'time_low' => '02d9e6d5',                    'time_mid' => '9467',                    'time_hi_and_version' => '382e',                    'clock_seq_hi_and_reserved' => '8f',                    'clock_seq_low' => '9b',                    'node' => '9300a64ac3cd',                ],                'urn' => 'urn:uuid:02d9e6d5-9467-382e-8f9b-9300a64ac3cd',                'time' => '82e946702d9e6d5',                'clock_seq' => '0f9b',                'variant' => Uuid::RFC_4122,                'version' => Uuid::UUID_TYPE_HASH_MD5,            ],            [                'string' => '12345678-1234-5678-1234-567812345678',                'curly' => '{12345678-1234-5678-1234-567812345678}',                'hex' => '12345678123456781234567812345678',                'bytes' => 'EjRWeBI0VngSNFZ4EjRWeA==',                'int' => '24197857161011715162171839636988778104',                'fields' => [                    'time_low' => '12345678',                    'time_mid' => '1234',                    'time_hi_and_version' => '5678',                    'clock_seq_hi_and_reserved' => '12',                    'clock_seq_low' => '34',                    'node' => '567812345678',                ],                'urn' => 'urn:uuid:12345678-1234-5678-1234-567812345678',                'time' => '678123412345678',                'clock_seq' => '1234',                'variant' => Uuid::RESERVED_NCS,                'version' => null,            ],            [                'string' => '6ba7b810-9dad-11d1-80b4-00c04fd430c8',                'curly' => '{6ba7b810-9dad-11d1-80b4-00c04fd430c8}',                'hex' => '6ba7b8109dad11d180b400c04fd430c8',                'bytes' => 'a6e4EJ2tEdGAtADAT9QwyA==',                'int' => '143098242404177361603877621312831893704',                'fields' => [                    'time_low' => '6ba7b810',                    'time_mid' => '9dad',                    'time_hi_and_version' => '11d1',                    'clock_seq_hi_and_reserved' => '80',                    'clock_seq_low' => 'b4',                    'node' => '00c04fd430c8',                ],                'urn' => 'urn:uuid:6ba7b810-9dad-11d1-80b4-00c04fd430c8',                'time' => '1d19dad6ba7b810',                'clock_seq' => '00b4',                'variant' => Uuid::RFC_4122,                'version' => Uuid::UUID_TYPE_TIME,            ],            [                'string' => '6ba7b811-9dad-11d1-80b4-00c04fd430c8',                'curly' => '{6ba7b811-9dad-11d1-80b4-00c04fd430c8}',                'hex' => '6ba7b8119dad11d180b400c04fd430c8',                'bytes' => 'a6e4EZ2tEdGAtADAT9QwyA==',                'int' => '143098242483405524118141958906375844040',                'fields' => [                    'time_low' => '6ba7b811',                    'time_mid' => '9dad',                    'time_hi_and_version' => '11d1',                    'clock_seq_hi_and_reserved' => '80',                    'clock_seq_low' => 'b4',                    'node' => '00c04fd430c8',                ],                'urn' => 'urn:uuid:6ba7b811-9dad-11d1-80b4-00c04fd430c8',                'time' => '1d19dad6ba7b811',                'clock_seq' => '00b4',                'variant' => Uuid::RFC_4122,                'version' => Uuid::UUID_TYPE_TIME,            ],            [                'string' => '6ba7b812-9dad-11d1-80b4-00c04fd430c8',                'curly' => '{6ba7b812-9dad-11d1-80b4-00c04fd430c8}',                'hex' => '6ba7b8129dad11d180b400c04fd430c8',                'bytes' => 'a6e4Ep2tEdGAtADAT9QwyA==',                'int' => '143098242562633686632406296499919794376',                'fields' => [                    'time_low' => '6ba7b812',                    'time_mid' => '9dad',                    'time_hi_and_version' => '11d1',                    'clock_seq_hi_and_reserved' => '80',                    'clock_seq_low' => 'b4',                    'node' => '00c04fd430c8',                ],                'urn' => 'urn:uuid:6ba7b812-9dad-11d1-80b4-00c04fd430c8',                'time' => '1d19dad6ba7b812',                'clock_seq' => '00b4',                'variant' => Uuid::RFC_4122,                'version' => Uuid::UUID_TYPE_TIME,            ],            [                'string' => '6ba7b814-9dad-11d1-80b4-00c04fd430c8',                'curly' => '{6ba7b814-9dad-11d1-80b4-00c04fd430c8}',                'hex' => '6ba7b8149dad11d180b400c04fd430c8',                'bytes' => 'a6e4FJ2tEdGAtADAT9QwyA==',                'int' => '143098242721090011660934971687007695048',                'fields' => [                    'time_low' => '6ba7b814',                    'time_mid' => '9dad',                    'time_hi_and_version' => '11d1',                    'clock_seq_hi_and_reserved' => '80',                    'clock_seq_low' => 'b4',                    'node' => '00c04fd430c8',                ],                'urn' => 'urn:uuid:6ba7b814-9dad-11d1-80b4-00c04fd430c8',                'time' => '1d19dad6ba7b814',                'clock_seq' => '00b4',                'variant' => Uuid::RFC_4122,                'version' => Uuid::UUID_TYPE_TIME,            ],            [                'string' => '7d444840-9dc0-11d1-b245-5ffdce74fad2',                'curly' => '{7d444840-9dc0-11d1-b245-5ffdce74fad2}',                'hex' => '7d4448409dc011d1b2455ffdce74fad2',                'bytes' => 'fURIQJ3AEdGyRV/9znT60g==',                'int' => '166508041112410060672666770310773930706',                'fields' => [                    'time_low' => '7d444840',                    'time_mid' => '9dc0',                    'time_hi_and_version' => '11d1',                    'clock_seq_hi_and_reserved' => 'b2',                    'clock_seq_low' => '45',                    'node' => '5ffdce74fad2',                ],                'urn' => 'urn:uuid:7d444840-9dc0-11d1-b245-5ffdce74fad2',                'time' => '1d19dc07d444840',                'clock_seq' => '3245',                'variant' => Uuid::RFC_4122,                'version' => Uuid::UUID_TYPE_TIME,            ],            [                'string' => 'e902893a-9d22-3c7e-a7b8-d6e313b71d9f',                'curly' => '{e902893a-9d22-3c7e-a7b8-d6e313b71d9f}',                'hex' => 'e902893a9d223c7ea7b8d6e313b71d9f',                'bytes' => '6QKJOp0iPH6nuNbjE7cdnw==',                'int' => '309723290945582129846206211755626405279',                'fields' => [                    'time_low' => 'e902893a',                    'time_mid' => '9d22',                    'time_hi_and_version' => '3c7e',                    'clock_seq_hi_and_reserved' => 'a7',                    'clock_seq_low' => 'b8',                    'node' => 'd6e313b71d9f',                ],                'urn' => 'urn:uuid:e902893a-9d22-3c7e-a7b8-d6e313b71d9f',                'time' => 'c7e9d22e902893a',                'clock_seq' => '27b8',                'variant' => Uuid::RFC_4122,                'version' => Uuid::UUID_TYPE_HASH_MD5,            ],            [                'string' => 'eb424026-6f54-4ef8-a4d0-bb658a1fc6cf',                'curly' => '{eb424026-6f54-4ef8-a4d0-bb658a1fc6cf}',                'hex' => 'eb4240266f544ef8a4d0bb658a1fc6cf',                'bytes' => '60JAJm9UTvik0Ltlih/Gzw==',                'int' => '312712571721458096795100956955942831823',                'fields' => [                    'time_low' => 'eb424026',                    'time_mid' => '6f54',                    'time_hi_and_version' => '4ef8',                    'clock_seq_hi_and_reserved' => 'a4',                    'clock_seq_low' => 'd0',                    'node' => 'bb658a1fc6cf',                ],                'urn' => 'urn:uuid:eb424026-6f54-4ef8-a4d0-bb658a1fc6cf',                'time' => 'ef86f54eb424026',                'clock_seq' => '24d0',                'variant' => Uuid::RFC_4122,                'version' => Uuid::UUID_TYPE_RANDOM,            ],            [                'string' => 'f81d4fae-7dec-11d0-a765-00a0c91e6bf6',                'curly' => '{f81d4fae-7dec-11d0-a765-00a0c91e6bf6}',                'hex' => 'f81d4fae7dec11d0a76500a0c91e6bf6',                'bytes' => '+B1Prn3sEdCnZQCgyR5r9g==',                'int' => '329800735698586629295641978511506172918',                'fields' => [                    'time_low' => 'f81d4fae',                    'time_mid' => '7dec',                    'time_hi_and_version' => '11d0',                    'clock_seq_hi_and_reserved' => 'a7',                    'clock_seq_low' => '65',                    'node' => '00a0c91e6bf6',                ],                'urn' => 'urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6',                'time' => '1d07decf81d4fae',                'clock_seq' => '2765',                'variant' => Uuid::RFC_4122,                'version' => Uuid::UUID_TYPE_TIME,            ],            [                'string' => 'fffefdfc-fffe-fffe-fffe-fffefdfcfbfa',                'curly' => '{fffefdfc-fffe-fffe-fffe-fffefdfcfbfa}',                'hex' => 'fffefdfcfffefffefffefffefdfcfbfa',                'bytes' => '//79/P/+//7//v/+/fz7+g==',                'int' => '340277133821575024845345576078114880506',                'fields' => [                    'time_low' => 'fffefdfc',                    'time_mid' => 'fffe',                    'time_hi_and_version' => 'fffe',                    'clock_seq_hi_and_reserved' => 'ff',                    'clock_seq_low' => 'fe',                    'node' => 'fffefdfcfbfa',                ],                'urn' => 'urn:uuid:fffefdfc-fffe-fffe-fffe-fffefdfcfbfa',                'time' => 'ffefffefffefdfc',                'clock_seq' => '3ffe',                'variant' => Uuid::RESERVED_FUTURE,                'version' => null,            ],            [                'string' => 'ffffffff-ffff-ffff-ffff-ffffffffffff',                'curly' => '{ffffffff-ffff-ffff-ffff-ffffffffffff}',                'hex' => 'ffffffffffffffffffffffffffffffff',                'bytes' => '/////////////////////w==',                'int' => '340282366920938463463374607431768211455',                'fields' => [                    'time_low' => 'ffffffff',                    'time_mid' => 'ffff',                    'time_hi_and_version' => 'ffff',                    'clock_seq_hi_and_reserved' => 'ff',                    'clock_seq_low' => 'ff',                    'node' => 'ffffffffffff',                ],                'urn' => 'urn:uuid:ffffffff-ffff-ffff-ffff-ffffffffffff',                'time' => 'fffffffffffffff',                'clock_seq' => '3fff',                'variant' => Uuid::RESERVED_FUTURE,                'version' => null,            ],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_Uuid_1963, Sets the factory used to create UUIDs\\n\\n @param UuidFactoryInterface $factory A factory that will be used by this\\n     class to create UUIDs\\n, Sets the factory used to create UUIDs,"    public static function setFactory(UuidFactoryInterface $factory): void    {        // Note: non-strict equality is intentional here. If the factory is configured differently, every assumption        //       around purity is broken, and we have to internally decide everything differently.        // phpcs:ignore SlevomatCodingStandard.Operators.DisallowEqualOperators.DisallowedNotEqualOperator        self::$factoryReplaced = ($factory != new UuidFactory());        self::$factory = $factory;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_Uuid_1967," Creates a UUID from a 128-bit integer string\n\n @param string $integer String representation of 128-bit integer\n\n @return UuidInterface A UuidInterface instance created from the string\n     representation of a 128-bit integer\n\n @psalm-pure note: changing the internal factory is an edge case not covered by purity invariants,\n             but under constant factory setups, this method operates in functionally pure manners\n", Creates a UUID from a 128-bit integer string,    public static function fromInteger(string $integer): UuidInterface    {        return self::getFactory()->fromInteger($integer);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_Uuid_1968," Returns true if the provided string is a valid UUID\n\n @param string $uuid A string to validate as a UUID\n\n @return bool True if the string is a valid UUID, false otherwise\n\n @psalm-pure note: changing the internal factory is an edge case not covered by purity invariants,\n             but under constant factory setups, this method operates in functionally pure manners\n", Returns true if the provided string is a valid UUID,    public static function isValid(string $uuid): bool    {        return self::getFactory()->getValidator()->validate($uuid);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_Uuid_1971, Returns a version 4 (random) UUID\\n\\n @return UuidInterface A UuidInterface instance that represents a\\n     version 4 UUID\\n, Returns a version 4 (random) UUID,    public static function uuid4(): UuidInterface    {        return self::getFactory()->uuid4();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ratchetphp_Ratchet_MessageInterface_1052, Triggered when a client sends data through the socket\\n @param  \\\\Ratchet\\\\ConnectionInterface $from The socket/connection that sent the message to your application\\n @param  string                       $msg  The message received\\n @throws \\\\Exception\\n, Triggered when a client sends data through the socket,"    function onMessage(ConnectionInterface $from, $msg);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_ArrayComparator_2322, Compares arrays for equality.\n\n Arrays are equal if they contain the same key-value pairs.\n The order of the keys does not matter.\n The types of key-value pairs do not matter.\n, Compares arrays for equality.,"class ArrayComparator extends Comparator{    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return is_array($expected) && is_array($actual);    }    /**     * Asserts that two arrays are equal.     *     * @param mixed $expected     First value to compare     * @param mixed $actual       Second value to compare     * @param float $delta        Allowed numerical distance between two values to consider them equal     * @param bool  $canonicalize Arrays are sorted before comparison when set to true     * @param bool  $ignoreCase   Case is ignored when set to true     * @param array $processed    List of already processed elements (used to prevent infinite recursion)     *     * @throws ComparisonFailure     */    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false, array &$processed = [])/*: void*/    {        if ($canonicalize) {            sort($expected);            sort($actual);        }        $remaining        = $actual;        $actualAsString   = ""Array (\n"";        $expectedAsString = ""Array (\n"";        $equal            = true;        foreach ($expected as $key => $value) {            unset($remaining[$key]);            if (!array_key_exists($key, $actual)) {                $expectedAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $this->exporter->shortenedExport($value)                );                $equal = false;                continue;            }            try {                $comparator = $this->factory->getComparatorFor($value, $actual[$key]);                $comparator->assertEquals($value, $actual[$key], $delta, $canonicalize, $ignoreCase, $processed);                $expectedAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $this->exporter->shortenedExport($value)                );                $actualAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $this->exporter->shortenedExport($actual[$key])                );            } catch (ComparisonFailure $e) {                $expectedAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $e->getExpectedAsString() ? $this->indent($e->getExpectedAsString()) : $this->exporter->shortenedExport($e->getExpected())                );                $actualAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $e->getActualAsString() ? $this->indent($e->getActualAsString()) : $this->exporter->shortenedExport($e->getActual())                );                $equal = false;            }        }        foreach ($remaining as $key => $value) {            $actualAsString .= sprintf(                ""    %s => %s\n"",                $this->exporter->export($key),                $this->exporter->shortenedExport($value)            );            $equal = false;        }        $expectedAsString .= ')';        $actualAsString .= ')';        if (!$equal) {            throw new ComparisonFailure(                $expected,                $actual,                $expectedAsString,                $actualAsString,                false,                'Failed asserting that two arrays are equal.'            );        }    }    protected function indent($lines)    {        return trim(str_replace(""\n"", ""\n    "", $lines));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_ArrayComparator_2323, Returns whether the comparator can compare two values.\n\n @param mixed $expected The first value to compare\n @param mixed $actual   The second value to compare\n\n @return bool\n, Returns whether the comparator can compare two values.,"    public function accepts($expected, $actual)    {        return is_array($expected) && is_array($actual);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_DOMNodeComparator_2331, Compares DOMNode instances for equality.\n, Compares DOMNode instances for equality.,"class DOMNodeComparator extends ObjectComparator{    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return $expected instanceof DOMNode && $actual instanceof DOMNode;    }    /**     * Asserts that two values are equal.     *     * @param mixed $expected     First value to compare     * @param mixed $actual       Second value to compare     * @param float $delta        Allowed numerical distance between two values to consider them equal     * @param bool  $canonicalize Arrays are sorted before comparison when set to true     * @param bool  $ignoreCase   Case is ignored when set to true     * @param array $processed    List of already processed elements (used to prevent infinite recursion)     *     * @throws ComparisonFailure     */    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false, array &$processed = [])/*: void*/    {        $expectedAsString = $this->nodeToText($expected, true, $ignoreCase);        $actualAsString   = $this->nodeToText($actual, true, $ignoreCase);        if ($expectedAsString !== $actualAsString) {            $type = $expected instanceof DOMDocument ? 'documents' : 'nodes';            throw new ComparisonFailure(                $expected,                $actual,                $expectedAsString,                $actualAsString,                false,                sprintf(""Failed asserting that two DOM %s are equal.\n"", $type)            );        }    }    /**     * Returns the normalized, whitespace-cleaned, and indented textual     * representation of a DOMNode.     */    private function nodeToText(DOMNode $node, bool $canonicalize, bool $ignoreCase): string    {        if ($canonicalize) {            $document = new DOMDocument;            try {                @$document->loadXML($node->C14N());            } catch (ValueError $e) {            }            $node = $document;        }        $document = $node instanceof DOMDocument ? $node : $node->ownerDocument;        $document->formatOutput = true;        $document->normalizeDocument();        $text = $node instanceof DOMDocument ? $node->saveXML() : $document->saveXML($node);        return $ignoreCase ? strtolower($text) : $text;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_Factory_2346," Registers a new comparator.\\n\\n This comparator will be returned by getComparatorFor() if its accept() method\\n returns TRUE for the compared values. It has higher priority than the\\n existing comparators, meaning that its accept() method will be invoked\\n before those of the other comparators.\\n\\n @param Comparator $comparator The comparator to be registered\\n", Registers a new comparator.,"    public function register(Comparator $comparator)/*: void*/    {        array_unshift($this->customComparators, $comparator);        $comparator->setFactory($this);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_Factory_2347, Unregisters a comparator.\n\n This comparator will no longer be considered by getComparatorFor().\n\n @param Comparator $comparator The comparator to be unregistered\n, Unregisters a comparator.,    public function unregister(Comparator $comparator)/*: void*/    {        foreach ($this->customComparators as $key => $_comparator) {            if ($comparator === $_comparator) {                unset($this->customComparators[$key]);            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_MockObjectComparator_2349, Compares PHPUnit\\\\Framework\\\\MockObject\\\\MockObject instances for equality.\\n, Compares PHPUnit,"class MockObjectComparator extends ObjectComparator{    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return $expected instanceof MockObject && $actual instanceof MockObject;    }    /**     * Converts an object to an array containing all of its private, protected     * and public properties.     *     * @param object $object     *     * @return array     */    protected function toArray($object)    {        $array = parent::toArray($object);        unset($array['__phpunit_invocationMocker']);        return $array;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_environment_Console_1223, Returns true if STDOUT supports colorization.\n\n This code has been copied and adapted from\n Symfony\\Component\\Console\\Output\\StreamOutput.\n, Returns true if STDOUT supports colorization.,    public function hasColorSupport(): bool    {        if ('Hyper' === getenv('TERM_PROGRAM')) {            return true;        }        if ($this->isWindows()) {            // @codeCoverageIgnoreStart            return (defined('STDOUT') && function_exists('sapi_windows_vt100_support') && @sapi_windows_vt100_support(STDOUT)) ||                false !== getenv('ANSICON') ||                'ON' === getenv('ConEmuANSI') ||                'xterm' === getenv('TERM');            // @codeCoverageIgnoreEnd        }        if (!defined('STDOUT')) {            // @codeCoverageIgnoreStart            return false;            // @codeCoverageIgnoreEnd        }        return $this->isInteractive(STDOUT);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_environment_Runtime_1233, Returns true when the runtime used is PHP and Xdebug is loaded.\n, Returns true when the runtime used is PHP and Xdebug is loaded.,    public function hasXdebug(): bool    {        return ($this->isPHP() || $this->isHHVM()) && extension_loaded('xdebug');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_environment_Runtime_1236, Returns true when the runtime used is PHP with the PHPDBG SAPI.\n, Returns true when the runtime used is PHP with the PHPDBG SAPI.,    public function isPHPDBG(): bool    {        return PHP_SAPI === 'phpdbg' && !$this->isHHVM();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_environment_Runtime_1239, Parses the loaded php.ini file (if any) as well as all\n additional php.ini files from the additional ini dir for\n a list of all configuration settings loaded from files\n at startup. Then checks for each php.ini setting passed\n via the `$values` parameter whether this setting has\n been changed at runtime. Returns an array of strings\n where each string has the format `key=value` denoting\n the name of a changed php.ini setting with its new value.\n\n @return string[]\n, Parses the loaded php.ini file (if any) as well as all,"    public function getCurrentSettings(array $values): array    {        $diff  = [];        $files = [];        if ($file = php_ini_loaded_file()) {            $files[] = $file;        }        if ($scanned = php_ini_scanned_files()) {            $files = array_merge(                $files,                array_map(                    'trim',                    explode("",\n"", $scanned)                )            );        }        foreach ($files as $ini) {            $config = parse_ini_file($ini, true);            foreach ($values as $value) {                $set = ini_get($value);                if (isset($config[$value]) && $set != $config[$value]) {                    $diff[] = sprintf('%s=%s', $value, $set);                }            }        }        return $diff;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_environment_Runtime_496," Returns true when Zend OPcache is loaded, enabled,\\n and is configured to perform just-in-time compilation.\\n"," Returns true when Zend OPcache is loaded, enabled,","    public function performsJustInTimeCompilation(): bool    {        if (PHP_MAJOR_VERSION < 8) {            return false;        }        if (!$this->isOpcacheActive()) {            return false;        }        if (strpos(ini_get('opcache.jit'), '0') === 0) {            return false;        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_environment_Runtime_497, Returns the path to the binary of the current runtime.\\n Appends ' --php' to the path when the runtime is HHVM.\\n, Returns the path to the binary of the current runtime.,"    public function getBinary(): string    {        // HHVM        if (self::$binary === null && $this->isHHVM()) {            // @codeCoverageIgnoreStart            if ((self::$binary = getenv('PHP_BINARY')) === false) {                self::$binary = PHP_BINARY;            }            self::$binary = escapeshellarg(self::$binary) . ' --php' .                ' -d hhvm.php7.all=1';            // @codeCoverageIgnoreEnd        }        if (self::$binary === null && PHP_BINARY !== '') {            self::$binary = escapeshellarg(PHP_BINARY);        }        if (self::$binary === null) {            // @codeCoverageIgnoreStart            $possibleBinaryLocations = [                PHP_BINDIR . '/php',                PHP_BINDIR . '/php-cli.exe',                PHP_BINDIR . '/php.exe',            ];            foreach ($possibleBinaryLocations as $binary) {                if (is_readable($binary)) {                    self::$binary = escapeshellarg($binary);                    break;                }            }            // @codeCoverageIgnoreEnd        }        if (self::$binary === null) {            // @codeCoverageIgnoreStart            self::$binary = 'php';            // @codeCoverageIgnoreEnd        }        return self::$binary;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_environment_Runtime_500, Returns true when the runtime used is PHP without the PHPDBG SAPI.\\n, Returns true when the runtime used is PHP without the PHPDBG SAPI.,    public function isPHP(): bool    {        return !$this->isHHVM() && !$this->isPHPDBG();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_environment_Runtime_503, Returns true when the runtime used is PHP with PCOV loaded and enabled.\\n, Returns true when the runtime used is PHP with PCOV loaded and enabled.,    public function hasPCOV(): bool    {        return $this->isPHP() && extension_loaded('pcov') && ini_get('pcov.enabled');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_exporter_Exporter_1034, A nifty utility for visualizing PHP variables.\\\\n\\\\n <code>\\\\n <?php\\\\n use SebastianBergmann\\\\\\\\Exporter\\\\\\\\Exporter;\\\\n\\\\n $exporter = new Exporter;\\\\n print $exporter->export(new Exception);\\\\n </code>\\\\n, A nifty utility for visualizing PHP variables.,"final class Exporter{    /**     * Exports a value as a string.     *     * The output of this method is similar to the output of print_r(), but     * improved in various aspects:     *     *  - NULL is rendered as ""null"" (instead of """")     *  - TRUE is rendered as ""true"" (instead of ""1"")     *  - FALSE is rendered as ""false"" (instead of """")     *  - Strings are always quoted with single quotes     *  - Carriage returns and newlines are normalized to \n     *  - Recursion and repeated rendering is treated properly     */    public function export(mixed $value, int $indentation = 0): string    {        return $this->recursiveExport($value, $indentation);    }    public function shortenedRecursiveExport(array &$data, Context $context = null): string    {        $result   = [];        $exporter = new self();        if (!$context) {            $context = new Context;        }        $array = $data;        /* @noinspection UnusedFunctionResultInspection */        $context->add($data);        foreach ($array as $key => $value) {            if (is_array($value)) {                if ($context->contains($data[$key]) !== false) {                    $result[] = '*RECURSION*';                } else {                    $result[] = sprintf(                        'array(%s)',                        $this->shortenedRecursiveExport($data[$key], $context)                    );                }            } else {                $result[] = $exporter->shortenedExport($value);            }        }        return implode(', ', $result);    }    /**     * Exports a value into a single-line string.     *     * The output of this method is similar to the output of     * SebastianBergmann\Exporter\Exporter::export().     *     * Newlines are replaced by the visible string '\n'.     * Contents of arrays and objects (if any) are replaced by '...'.     */    public function shortenedExport(mixed $value): string    {        if (is_string($value)) {            $string = str_replace(""\n"", '', $this->export($value));            if (function_exists('mb_strlen') && function_exists('mb_substr') && mb_strlen($string) > 40) {                return mb_substr($string, 0, 30) . '...' . mb_substr($string, -7);            }            if (strlen($string) > 40) {                return substr($string, 0, 30) . '...' . substr($string, -7);            }            return $string;        }        if (is_object($value)) {            return sprintf(                '%s Object (%s)',                get_class($value),                count($this->toArray($value)) > 0 ? '...' : ''            );        }        if (is_array($value)) {            return sprintf(                'Array (%s)',                count($value) > 0 ? '...' : ''            );        }        return $this->export($value);    }    /**     * Converts an object to an array containing all of its private, protected     * and public properties.     */    public function toArray(mixed $value): array    {        if (!is_object($value)) {            return (array) $value;        }        $array = [];        foreach ((array) $value as $key => $val) {            // Exception traces commonly reference hundreds to thousands of            // objects currently loaded in memory. Including them in the result            // has a severe negative performance impact.            if (""\0Error\0trace"" === $key || ""\0Exception\0trace"" === $key) {                continue;            }            // properties are transformed to keys in the following way:            // private   $property => ""\0Classname\0property""            // protected $property => ""\0*\0property""            // public    $property => ""property""            if (preg_match('/^\0.+\0(.+)$/', (string) $key, $matches)) {                $key = $matches[1];            }            // See https://github.com/php/php-src/commit/5721132            if ($key === ""\0gcdata"") {                continue;            }            $array[$key] = $val;        }        // Some internal classes like SplObjectStorage don't work with the        // above (fast) mechanism nor with reflection in Zend.        // Format the output similarly to print_r() in this case        if ($value instanceof SplObjectStorage) {            foreach ($value as $_value) {                $array[spl_object_hash($_value)] = [                    'obj' => $_value,                    'inf' => $value->getInfo(),                ];            }        }        return $array;    }    /**     * Recursive implementation of export.     */    private function recursiveExport(mixed &$value, int $indentation, ?Context $processed = null): string    {        if ($value === null) {            return 'null';        }        if ($value === true) {            return 'true';        }        if ($value === false) {            return 'false';        }        if (is_float($value) && (float) ((int) $value) === $value) {            return $value . '.0';        }        if (is_resource($value)) {            return sprintf(                'resource(%d) of type (%s)',                $value,                get_resource_type($value)            );        }        if (is_string($value)) {            // Match for most non printable chars somewhat taking multibyte chars into account            if (preg_match('/[^\x09-\x0d\x1b\x20-\xff]/', $value)) {                return 'Binary String: 0x' . bin2hex($value);            }            return ""'"" .            str_replace(                '<lf>',                ""\n"",                str_replace(                    [""\r\n"", ""\n\r"", ""\r"", ""\n""],                    ['\r\n<lf>', '\n\r<lf>', '\r<lf>', '\n<lf>'],                    $value                )            ) .            ""'"";        }        $whitespace = str_repeat(' ', 4 * $indentation);        if (!$processed) {            $processed = new Context;        }        if (is_array($value)) {            if (($key = $processed->contains($value)) !== false) {                return 'Array &' . $key;            }            $array  = $value;            $key    = $processed->add($value);            $values = '';            if (count($array) > 0) {                foreach ($array as $k => $v) {                    $values .= sprintf(                        '%s    %s => %s' . ""\n"",                        $whitespace,                        $this->recursiveExport($k, $indentation),                        $this->recursiveExport($value[$k], $indentation + 1, $processed)                    );                }                $values = ""\n"" . $values . $whitespace;            }            return sprintf('Array &%s (%s)', $key, $values);        }        if (is_object($value)) {            $class = get_class($value);            if ($hash = $processed->contains($value)) {                return sprintf('%s Object &%s', $class, $hash);            }            $hash   = $processed->add($value);            $values = '';            $array  = $this->toArray($value);            if (count($array) > 0) {                foreach ($array as $k => $v) {                    $values .= sprintf(                        '%s    %s => %s' . ""\n"",                        $whitespace,                        $this->recursiveExport($k, $indentation),                        $this->recursiveExport($v, $indentation + 1, $processed)                    );                }                $values = ""\n"" . $values . $whitespace;            }            return sprintf('%s Object &%s (%s)', $class, $hash, $values);        }        return var_export($value, true);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_exporter_Exporter_1035, Exports a value into a single-line string.\\n\\n The output of this method is similar to the output of\\n SebastianBergmann\\\\Exporter\\\\Exporter::export().\\n\\n Newlines are replaced by the visible string '\\\\n'.\\n Contents of arrays and objects (if any) are replaced by '...'.\\n, Exports a value into a single-line string.,"    public function shortenedExport(mixed $value): string    {        if (is_string($value)) {            $string = str_replace(""\n"", '', $this->export($value));            if (function_exists('mb_strlen') && function_exists('mb_substr') && mb_strlen($string) > 40) {                return mb_substr($string, 0, 30) . '...' . mb_substr($string, -7);            }            if (strlen($string) > 40) {                return substr($string, 0, 30) . '...' . substr($string, -7);            }            return $string;        }        if (is_object($value)) {            return sprintf(                '%s Object (%s)',                get_class($value),                count($this->toArray($value)) > 0 ? '...' : ''            );        }        if (is_array($value)) {            return sprintf(                'Array (%s)',                count($value) > 0 ? '...' : ''            );        }        return $this->export($value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_php-code-coverage_CodeCoverage_1635, Provides collection functionality for PHP code coverage information.\n, Provides collection functionality for PHP code coverage information.,"final class CodeCoverage{    private const UNCOVERED_FILES = 'UNCOVERED_FILES';    private Driver $driver;    private Filter $filter;    private Wizard $wizard;    private bool $checkForUnintentionallyCoveredCode = false;    private bool $includeUncoveredFiles = true;    private bool $ignoreDeprecatedCode = false;    private PhptTestCase|string|TestCase|null $currentId;    private ProcessedCodeCoverageData $data;    private bool $useAnnotationsForIgnoringCode = true;    private array $tests = [];    /**     * @psalm-var list<class-string>     */    private array $parentClassesExcludedFromUnintentionallyCoveredCodeCheck = [];    private ?CoveredFileAnalyser $coveredFileAnalyser = null;    private ?UncoveredFileAnalyser $uncoveredFileAnalyser = null;    private ?string $cacheDirectory = null;    public function __construct(Driver $driver, Filter $filter)    {        $this->driver = $driver;        $this->filter = $filter;        $this->data   = new ProcessedCodeCoverageData;        $this->wizard = new Wizard;    }    /**     * Returns the code coverage information as a graph of node objects.     */    public function getReport(): Directory    {        return (new Builder($this->coveredFileAnalyser()))->build($this);    }    /**     * Clears collected code coverage data.     */    public function clear(): void    {        $this->currentId = null;        $this->data      = new ProcessedCodeCoverageData;        $this->tests     = [];    }    /**     * Returns the filter object used.     */    public function filter(): Filter    {        return $this->filter;    }    /**     * Returns the collected code coverage data.     */    public function getData(bool $raw = false): ProcessedCodeCoverageData    {        if (!$raw && $this->includeUncoveredFiles) {            $this->addUncoveredFilesFromFilter();        }        return $this->data;    }    /**     * Sets the coverage data.     */    public function setData(ProcessedCodeCoverageData $data): void    {        $this->data = $data;    }    /**     * Returns the test data.     */    public function getTests(): array    {        return $this->tests;    }    /**     * Sets the test data.     */    public function setTests(array $tests): void    {        $this->tests = $tests;    }    public function start(PhptTestCase|string|TestCase $id, bool $clear = false): void    {        if ($clear) {            $this->clear();        }        $this->currentId = $id;        $this->driver->start();    }    public function stop(bool $append = true, array|false $linesToBeCovered = [], array $linesToBeUsed = []): RawCodeCoverageData    {        if (!is_array($linesToBeCovered) && $linesToBeCovered !== false) {            throw new InvalidArgumentException(                '$linesToBeCovered must be an array or false'            );        }        $data = $this->driver->stop();        $this->append($data, null, $append, $linesToBeCovered, $linesToBeUsed);        $this->currentId = null;        return $data;    }    /**     * @throws ReflectionException     * @throws TestIdMissingException     * @throws UnintentionallyCoveredCodeException     */    public function append(RawCodeCoverageData $rawData, PhptTestCase|string|TestCase|null $id = null, bool $append = true, array|false $linesToBeCovered = [], array $linesToBeUsed = []): void    {        if ($id === null) {            $id = $this->currentId;        }        if ($id === null) {            throw new TestIdMissingException;        }        $this->applyFilter($rawData);        if ($this->useAnnotationsForIgnoringCode) {            $this->applyIgnoredLinesFilter($rawData);        }        $this->data->initializeUnseenData($rawData);        if (!$append) {            return;        }        if ($id !== self::UNCOVERED_FILES) {            $this->applyCoversAnnotationFilter(                $rawData,                $linesToBeCovered,                $linesToBeUsed            );            if (empty($rawData->lineCoverage())) {                return;            }            $size         = 'unknown';            $status       = 'unknown';            $fromTestcase = false;            if ($id instanceof TestCase) {                $fromTestcase = true;                $size   = $id->size()->asString();                $status = $id->status()->asString();                $id     = get_class($id) . '::' . $id->getName();            } elseif ($id instanceof PhptTestCase) {                $fromTestcase = true;                $size         = 'large';                $id           = $id->getName();            }            $this->tests[$id] = ['size' => $size, 'status' => $status, 'fromTestcase' => $fromTestcase];            $this->data->markCodeAsExecutedByTestCase($id, $rawData);        }    }    /**     * Merges the data from another instance.     */    public function merge(self $that): void    {        $this->filter->includeFiles(            $that->filter()->files()        );        $this->data->merge($that->data);        $this->tests = array_merge($this->tests, $that->getTests());    }    public function enableCheckForUnintentionallyCoveredCode(): void    {        $this->checkForUnintentionallyCoveredCode = true;    }    public function disableCheckForUnintentionallyCoveredCode(): void    {        $this->checkForUnintentionallyCoveredCode = false;    }    public function includeUncoveredFiles(): void    {        $this->includeUncoveredFiles = true;    }    public function excludeUncoveredFiles(): void    {        $this->includeUncoveredFiles = false;    }    public function enableAnnotationsForIgnoringCode(): void    {        $this->useAnnotationsForIgnoringCode = true;    }    public function disableAnnotationsForIgnoringCode(): void    {        $this->useAnnotationsForIgnoringCode = false;    }    public function ignoreDeprecatedCode(): void    {        $this->ignoreDeprecatedCode = true;    }    public function doNotIgnoreDeprecatedCode(): void    {        $this->ignoreDeprecatedCode = false;    }    /**     * @psalm-assert-if-true !null $this->cacheDirectory     */    public function cachesStaticAnalysis(): bool    {        return $this->cacheDirectory !== null;    }    public function cacheStaticAnalysis(string $directory): void    {        $this->cacheDirectory = $directory;    }    public function doNotCacheStaticAnalysis(): void    {        $this->cacheDirectory = null;    }    /**     * @throws StaticAnalysisCacheNotConfiguredException     */    public function cacheDirectory(): string    {        if (!$this->cachesStaticAnalysis()) {            throw new StaticAnalysisCacheNotConfiguredException(                'The static analysis cache is not configured'            );        }        return $this->cacheDirectory;    }    /**     * @psalm-param class-string $className     */    public function excludeSubclassesOfThisClassFromUnintentionallyCoveredCodeCheck(string $className): void    {        $this->parentClassesExcludedFromUnintentionallyCoveredCodeCheck[] = $className;    }    public function enableBranchAndPathCoverage(): void    {        $this->driver->enableBranchAndPathCoverage();    }    public function disableBranchAndPathCoverage(): void    {        $this->driver->disableBranchAndPathCoverage();    }    public function collectsBranchAndPathCoverage(): bool    {        return $this->driver->collectsBranchAndPathCoverage();    }    public function detectsDeadCode(): bool    {        return $this->driver->detectsDeadCode();    }    /**     * @throws ReflectionException     * @throws UnintentionallyCoveredCodeException     */    private function applyCoversAnnotationFilter(RawCodeCoverageData $rawData, array|false $linesToBeCovered, array $linesToBeUsed): void    {        if ($linesToBeCovered === false) {            $rawData->clear();            return;        }        if (empty($linesToBeCovered)) {            return;        }        if ($this->checkForUnintentionallyCoveredCode &&            (!$this->currentId instanceof TestCase ||            (!$this->currentId->size()->isMedium() && !$this->currentId->size()->isLarge()))) {            $this->performUnintentionallyCoveredCodeCheck($rawData, $linesToBeCovered, $linesToBeUsed);        }        $rawLineData         = $rawData->lineCoverage();        $filesWithNoCoverage = array_diff_key($rawLineData, $linesToBeCovered);        foreach (array_keys($filesWithNoCoverage) as $fileWithNoCoverage) {            $rawData->removeCoverageDataForFile($fileWithNoCoverage);        }        if (is_array($linesToBeCovered)) {            foreach ($linesToBeCovered as $fileToBeCovered => $includedLines) {                $rawData->keepCoverageDataOnlyForLines($fileToBeCovered, $includedLines);            }        }    }    private function applyFilter(RawCodeCoverageData $data): void    {        if ($this->filter->isEmpty()) {            return;        }        foreach (array_keys($data->lineCoverage()) as $filename) {            if ($this->filter->isExcluded($filename)) {                $data->removeCoverageDataForFile($filename);            }        }    }    private function applyIgnoredLinesFilter(RawCodeCoverageData $data): void    {        foreach (array_keys($data->lineCoverage()) as $filename) {            if (!$this->filter->isFile($filename)) {                continue;            }            $data->removeCoverageDataForLines(                $filename,                $this->coveredFileAnalyser()->ignoredLinesFor($filename)            );        }    }    /**     * @throws UnintentionallyCoveredCodeException     */    private function addUncoveredFilesFromFilter(): void    {        $uncoveredFiles = array_diff(            $this->filter->files(),            $this->data->coveredFiles()        );        foreach ($uncoveredFiles as $uncoveredFile) {            if (is_file($uncoveredFile)) {                $this->append(                    RawCodeCoverageData::fromUncoveredFile(                        $uncoveredFile,                        $this->uncoveredFileAnalyser()                    ),                    self::UNCOVERED_FILES                );            }        }    }    /**     * @throws ReflectionException     * @throws UnintentionallyCoveredCodeException     */    private function performUnintentionallyCoveredCodeCheck(RawCodeCoverageData $data, array $linesToBeCovered, array $linesToBeUsed): void    {        $allowedLines = $this->getAllowedLines(            $linesToBeCovered,            $linesToBeUsed        );        $unintentionallyCoveredUnits = [];        foreach ($data->lineCoverage() as $file => $_data) {            foreach ($_data as $line => $flag) {                if ($flag === 1 && !isset($allowedLines[$file][$line])) {                    $unintentionallyCoveredUnits[] = $this->wizard->lookup($file, $line);                }            }        }        $unintentionallyCoveredUnits = $this->processUnintentionallyCoveredUnits($unintentionallyCoveredUnits);        if (!empty($unintentionallyCoveredUnits)) {            throw new UnintentionallyCoveredCodeException(                $unintentionallyCoveredUnits            );        }    }    private function getAllowedLines(array $linesToBeCovered, array $linesToBeUsed): array    {        $allowedLines = [];        foreach (array_keys($linesToBeCovered) as $file) {            if (!isset($allowedLines[$file])) {                $allowedLines[$file] = [];            }            $allowedLines[$file] = array_merge(                $allowedLines[$file],                $linesToBeCovered[$file]            );        }        foreach (array_keys($linesToBeUsed) as $file) {            if (!isset($allowedLines[$file])) {                $allowedLines[$file] = [];            }            $allowedLines[$file] = array_merge(                $allowedLines[$file],                $linesToBeUsed[$file]            );        }        foreach (array_keys($allowedLines) as $file) {            $allowedLines[$file] = array_flip(                array_unique($allowedLines[$file])            );        }        return $allowedLines;    }    /**     * @param list<string> $unintentionallyCoveredUnits     *     * @throws ReflectionException     *     * @return list<string>     */    private function processUnintentionallyCoveredUnits(array $unintentionallyCoveredUnits): array    {        $unintentionallyCoveredUnits = array_unique($unintentionallyCoveredUnits);        sort($unintentionallyCoveredUnits);        foreach (array_keys($unintentionallyCoveredUnits) as $k => $v) {            $unit = explode('::', $unintentionallyCoveredUnits[$k]);            if (count($unit) !== 2) {                continue;            }            try {                $class = new ReflectionClass($unit[0]);                foreach ($this->parentClassesExcludedFromUnintentionallyCoveredCodeCheck as $parentClass) {                    if ($class->isSubclassOf($parentClass)) {                        unset($unintentionallyCoveredUnits[$k]);                        break;                    }                }            } catch (\ReflectionException $e) {                throw new ReflectionException(                    $e->getMessage(),                    (int) $e->getCode(),                    $e                );            }        }        return array_values($unintentionallyCoveredUnits);    }    private function coveredFileAnalyser(): CoveredFileAnalyser    {        if ($this->coveredFileAnalyser !== null) {            return $this->coveredFileAnalyser;        }        $this->coveredFileAnalyser = new ParsingCoveredFileAnalyser(            $this->useAnnotationsForIgnoringCode,            $this->ignoreDeprecatedCode        );        if ($this->cachesStaticAnalysis()) {            $this->coveredFileAnalyser = new CachingCoveredFileAnalyser(                $this->cacheDirectory,                $this->coveredFileAnalyser            );        }        return $this->coveredFileAnalyser;    }    private function uncoveredFileAnalyser(): UncoveredFileAnalyser    {        if ($this->uncoveredFileAnalyser !== null) {            return $this->uncoveredFileAnalyser;        }        $this->uncoveredFileAnalyser = new ParsingUncoveredFileAnalyser;        if ($this->cachesStaticAnalysis()) {            $this->uncoveredFileAnalyser = new CachingUncoveredFileAnalyser(                $this->cacheDirectory,                $this->uncoveredFileAnalyser            );        }        return $this->uncoveredFileAnalyser;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_php-code-coverage_CodeCoverage_1637, Clears collected code coverage data.\n, Clears collected code coverage data.,    public function clear(): void    {        $this->currentId = null;        $this->data      = new ProcessedCodeCoverageData;        $this->tests     = [];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_phpunit_generate-global-assert-wrappers_1099, Returns a matcher that matches when the method is never executed.\n, Returns a matcher that matches when the method is never executed.,    function never(): InvokedCountMatcher    {        return new InvokedCountMatcher(0);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_phpunit_generate-global-assert-wrappers_1100, Returns a matcher that matches when the method is executed\n at least N times.\n, Returns a matcher that matches when the method is executed,    function atLeast(int $requiredInvocations): InvokedAtLeastCountMatcher    {        return new InvokedAtLeastCountMatcher(            $requiredInvocations        );    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_phpunit_generate-global-assert-wrappers_1102, Returns a matcher that matches when the method is executed exactly once.\n, Returns a matcher that matches when the method is executed exactly once.,    function once(): InvokedCountMatcher    {        return new InvokedCountMatcher(1);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_recursion-context_Context_2473, A context containing previously processed arrays and objects\\n when recursively processing a value.\\n, A context containing previously processed arrays and objects,"final class Context{    /**     * @var array[]     */    private $arrays;    /**     * @var SplObjectStorage     */    private $objects;    /**     * Initialises the context.     */    public function __construct()    {        $this->arrays  = [];        $this->objects = new SplObjectStorage;    }    /**     * @codeCoverageIgnore     */    public function __destruct()    {        foreach ($this->arrays as &$array) {            if (is_array($array)) {                array_pop($array);                array_pop($array);            }        }    }    /**     * Adds a value to the context.     *     * @param array|object $value the value to add     *     * @throws InvalidArgumentException Thrown if $value is not an array or object     *     * @return bool|int|string the ID of the stored value, either as a string or integer     *     * @psalm-template T     * @psalm-param T $value     * @param-out T $value     */    public function add(&$value)    {        if (is_array($value)) {            return $this->addArray($value);        }        if (is_object($value)) {            return $this->addObject($value);        }        throw new InvalidArgumentException(            'Only arrays and objects are supported'        );    }    /**     * Checks if the given value exists within the context.     *     * @param array|object $value the value to check     *     * @throws InvalidArgumentException Thrown if $value is not an array or object     *     * @return false|int|string the string or integer ID of the stored value if it has already been seen, or false if the value is not stored     *     * @psalm-template T     * @psalm-param T $value     * @param-out T $value     */    public function contains(&$value)    {        if (is_array($value)) {            return $this->containsArray($value);        }        if (is_object($value)) {            return $this->containsObject($value);        }        throw new InvalidArgumentException(            'Only arrays and objects are supported'        );    }    /**     * @return bool|int     */    private function addArray(array &$array)    {        $key = $this->containsArray($array);        if ($key !== false) {            return $key;        }        $key            = count($this->arrays);        $this->arrays[] = &$array;        if (!isset($array[PHP_INT_MAX]) && !isset($array[PHP_INT_MAX - 1])) {            $array[] = $key;            $array[] = $this->objects;        } else { /* cover the improbable case too */            do {                $key = random_int(PHP_INT_MIN, PHP_INT_MAX);            } while (isset($array[$key]));            $array[$key] = $key;            do {                $key = random_int(PHP_INT_MIN, PHP_INT_MAX);            } while (isset($array[$key]));            $array[$key] = $this->objects;        }        return $key;    }    /**     * @param object $object     */    private function addObject($object): string    {        if (!$this->objects->contains($object)) {            $this->objects->attach($object);        }        return spl_object_hash($object);    }    /**     * @return false|int     */    private function containsArray(array &$array)    {        $end = array_slice($array, -2);        return isset($end[1]) && $end[1] === $this->objects ? $end[0] : false;    }    /**     * @param object $value     *     * @return false|string     */    private function containsObject($value)    {        if ($this->objects->contains($value)) {            return spl_object_hash($value);        }        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_recursion-context_Context_2476," Adds a value to the context.\n\n @param array|object $value the value to add\n\n @throws InvalidArgumentException Thrown if $value is not an array or object\n\n @return bool|int|string the ID of the stored value, either as a string or integer\n\n @psalm-template T\n @psalm-param T $value\n @param-out T $value\n", Adds a value to the context.,    public function add(&$value)    {        if (is_array($value)) {            return $this->addArray($value);        }        if (is_object($value)) {            return $this->addObject($value);        }        throw new InvalidArgumentException(            'Only arrays and objects are supported'        );    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_recursion-context_Context_2477," Checks if the given value exists within the context.\n\n @param array|object $value the value to check\n\n @throws InvalidArgumentException Thrown if $value is not an array or object\n\n @return false|int|string the string or integer ID of the stored value if it has already been seen, or false if the value is not stored\n\n @psalm-template T\n @psalm-param T $value\n @param-out T $value\n", Checks if the given value exists within the context.,    public function contains(&$value)    {        if (is_array($value)) {            return $this->containsArray($value);        }        if (is_object($value)) {            return $this->containsObject($value);        }        throw new InvalidArgumentException(            'Only arrays and objects are supported'        );    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_BasicsTest_1161,special headers that give 'quick' indication that a device is mobile\\\\n,special headers that give 'quick' indication that a device is mobile,"    public function quickHeadersData()    {        return array(            array(array(                'HTTP_ACCEPT' => 'application/json; q=0.2, application/x-obml2d; q=0.8, image/gif; q=0.99, */*'            )),            array(array(                'HTTP_ACCEPT' => 'text/*; q=0.1, application/vnd.rim.html'            )),            array(array(                'HTTP_ACCEPT' => 'text/vnd.wap.wml',            )),            array(array(                'HTTP_ACCEPT' => 'application/vnd.wap.xhtml+xml',            )),            array(array(                'HTTP_X_WAP_PROFILE' => 'hello',            )),            array(array(                'HTTP_X_WAP_CLIENTID' => ''            )),            array(array(                'HTTP_WAP_CONNECTION' => ''            )),            array(array(                'HTTP_PROFILE' => ''            )),            array(array(                'HTTP_X_OPERAMINI_PHONE_UA' => ''            )),            array(array(                'HTTP_X_NOKIA_GATEWAY_ID' => ''            )),            array(array(                'HTTP_X_ORANGE_ID' => ''            )),            array(array(                'HTTP_X_VODAFONE_3GPDPCONTEXT' => ''            )),            array(array(                'HTTP_X_HUAWEI_USERID' => ''            )),            array(array(                'HTTP_UA_OS' => ''            )),            array(array(                'HTTP_X_MOBILE_GATEWAY' => ''            )),            array(array(                'HTTP_X_ATT_DEVICEID' => ''            )),            array(array(                'HTTP_UA_CPU' => 'ARM'            ))        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_BasicsTest_1163, Headers that are not mobile.\\n, Headers that are not mobile.,"    public function quickNonMobileHeadersData()    {        return array(            array(array(                'HTTP_UA_CPU' => 'AMD64'                )),            array(array(                'HTTP_UA_CPU' => 'X86'                )),            array(array(                'HTTP_ACCEPT' => 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01'                )),            array(array(                'HTTP_REQUEST_METHOD' => 'DELETE'                )),            array(array(                'HTTP_VIA' => '1.1 ws-proxy.stuff.co.il C0A800FA'                )),        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1131," Get the current script version.\\n This is useful for the demo.php file,\\n so people can check on what version they are testing\\n for mobile devices.\\n\\n @return string The version number in semantic version format.\\n", Get the current script version.,    public static function getScriptVersion()    {        return self::VERSION;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1133," Retrieves a particular header. If it doesn\'t exist, no exception/error is caused.\n Simply null is returned.\n\n @param string $header The name of the header to retrieve. Can be HTTP compliant such as\n                       ""User-Agent"" or ""X-Device-User-Agent"" or can be php-esque with the\n                       all-caps, HTTP_ prefixed, underscore seperated awesomeness.\n\n @return string|null The value of the header.\n", Retrieves a particular header. If it doesn,"    public function getHttpHeader($header)    {        // are we using PHP-flavored headers?        if (strpos($header, '_') === false) {            $header = str_replace('-', '_', $header);            $header = strtoupper($header);        }        // test the alternate, too        $altHeader = 'HTTP_' . $header;        //Test both the regular and the HTTP_ prefix        if (isset($this->httpHeaders[$header])) {            return $this->httpHeaders[$header];        } elseif (isset($this->httpHeaders[$altHeader])) {            return $this->httpHeaders[$altHeader];        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1138, Retrieve the list of known phone devices.\\n\\n @return array List of phone devices.\\n, Retrieve the list of known phone devices.,    public static function getPhoneDevices()    {        return self::$phoneDevices;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1140, Alias for getBrowsers() method.\\n\\n @return array List of user agents.\\n, Alias for getBrowsers() method.,    public static function getUserAgents()    {        return self::getBrowsers();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1146, Retrieve the list of mobile operating systems.\\\\n\\\\n @return array The list of mobile operating systems.\\\\n, Retrieve the list of mobile operating systems.,    public static function getOperatingSystems()    {        return self::$operatingSystems;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1147, Check the HTTP headers for signs of mobile.\n This is the fastest mobile check possible; it's used\n inside isMobile() method.\n\n @return bool\n, Check the HTTP headers for signs of mobile.,"    public function checkHttpHeadersForMobile()    {        foreach ($this->getMobileHeaders() as $mobileHeader => $matchType) {            if (isset($this->httpHeaders[$mobileHeader])) {                if (isset($matchType['matches']) && is_array($matchType['matches'])) {                    foreach ($matchType['matches'] as $_match) {                        if (strpos($this->httpHeaders[$mobileHeader], $_match) !== false) {                            return true;                        }                    }                    return false;                } else {                    return true;                }            }        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1149, Search for a certain key in the rules array.\n If the key is found then try to match the corresponding\n regex against the User-Agent.\n\n @param string $key\n\n @return boolean\n, Search for a certain key in the rules array.,"    protected function matchUAAgainstKey($key)    {        // Make the keys lowercase so we can match: isIphone(), isiPhone(), isiphone(), etc.        $key = strtolower($key);        if (false === isset($this->cache[$key])) {            // change the keys to lower case            $_rules = array_change_key_case($this->getRules());            if (false === empty($_rules[$key])) {                $this->cache[$key] = $this->match($_rules[$key]);            }            if (false === isset($this->cache[$key])) {                $this->cache[$key] = false;            }        }        return $this->cache[$key];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1152," Retrieve the mobile grading, using self::MOBILE_GRADE_\\n @return string One of the self::MOBILE_GRADE_"," Retrieve the mobile grading, using self::MOBILE_GRADE_","    public function mobileGrade()    {        $isMobile = $this->isMobile();        if (            // Apple iOS 4-7.0 – Tested on the original iPad (4.3 / 5.0), iPad 2 (4.3 / 5.1 / 6.1), iPad 3 (5.1 / 6.0), iPad Mini (6.1), iPad Retina (7.0), iPhone 3GS (4.3), iPhone 4 (4.3 / 5.1), iPhone 4S (5.1 / 6.0), iPhone 5 (6.0), and iPhone 5S (7.0)            $this->is('iOS') && $this->version('iPad', self::VERSION_TYPE_FLOAT) >= 4.3 ||            $this->is('iOS') && $this->version('iPhone', self::VERSION_TYPE_FLOAT) >= 4.3 ||            $this->is('iOS') && $this->version('iPod', self::VERSION_TYPE_FLOAT) >= 4.3 ||            // Android 2.1-2.3 - Tested on the HTC Incredible (2.2), original Droid (2.2), HTC Aria (2.1), Google Nexus S (2.3). Functional on 1.5 & 1.6 but performance may be sluggish, tested on Google G1 (1.5)            // Android 3.1 (Honeycomb)  - Tested on the Samsung Galaxy Tab 10.1 and Motorola XOOM            // Android 4.0 (ICS)  - Tested on a Galaxy Nexus. Note: transition performance can be poor on upgraded devices            // Android 4.1 (Jelly Bean)  - Tested on a Galaxy Nexus and Galaxy 7            ( $this->version('Android', self::VERSION_TYPE_FLOAT)>2.1 && $this->is('Webkit') ) ||            // Windows Phone 7.5-8 - Tested on the HTC Surround (7.5), HTC Trophy (7.5), LG-E900 (7.5), Nokia 800 (7.8), HTC Mazaa (7.8), Nokia Lumia 520 (8), Nokia Lumia 920 (8), HTC 8x (8)            $this->version('Windows Phone OS', self::VERSION_TYPE_FLOAT) >= 7.5 ||            // Tested on the Torch 9800 (6) and Style 9670 (6), BlackBerry® Torch 9810 (7), BlackBerry Z10 (10)            $this->is('BlackBerry') && $this->version('BlackBerry', self::VERSION_TYPE_FLOAT) >= 6.0 ||            // Blackberry Playbook (1.0-2.0) - Tested on PlayBook            $this->match('Playbook.*Tablet') ||            // Palm WebOS (1.4-3.0) - Tested on the Palm Pixi (1.4), Pre (1.4), Pre 2 (2.0), HP TouchPad (3.0)            ( $this->version('webOS', self::VERSION_TYPE_FLOAT) >= 1.4 && $this->match('Palm|Pre|Pixi') ) ||            // Palm WebOS 3.0  - Tested on HP TouchPad            $this->match('hp.*TouchPad') ||            // Firefox Mobile 18 - Tested on Android 2.3 and 4.1 devices            ( $this->is('Firefox') && $this->version('Firefox', self::VERSION_TYPE_FLOAT) >= 18 ) ||            // Chrome for Android - Tested on Android 4.0, 4.1 device            ( $this->is('Chrome') && $this->is('AndroidOS') && $this->version('Android', self::VERSION_TYPE_FLOAT) >= 4.0 ) ||            // Skyfire 4.1 - Tested on Android 2.3 device            ( $this->is('Skyfire') && $this->version('Skyfire', self::VERSION_TYPE_FLOAT) >= 4.1 && $this->is('AndroidOS') && $this->version('Android', self::VERSION_TYPE_FLOAT) >= 2.3 ) ||            // Opera Mobile 11.5-12: Tested on Android 2.3            ( $this->is('Opera') && $this->version('Opera Mobi', self::VERSION_TYPE_FLOAT) >= 11.5 && $this->is('AndroidOS') ) ||            // Meego 1.2 - Tested on Nokia 950 and N9            $this->is('MeeGoOS') ||            // Sailfish OS            $this->is('SailfishOS') ||            // Tizen (pre-release) - Tested on early hardware            $this->is('Tizen') ||            // Samsung Bada 2.0 - Tested on a Samsung Wave 3, Dolphin browser            // @todo: more tests here!            $this->is('Dolfin') && $this->version('Bada', self::VERSION_TYPE_FLOAT) >= 2.0 ||            // UC Browser - Tested on Android 2.3 device            ( ($this->is('UC Browser') || $this->is('Dolfin')) && $this->version('Android', self::VERSION_TYPE_FLOAT) >= 2.3 ) ||            // Kindle 3 and Fire  - Tested on the built-in WebKit browser for each            ( $this->match('Kindle Fire') ||            $this->is('Kindle') && $this->version('Kindle', self::VERSION_TYPE_FLOAT) >= 3.0 ) ||            // Nook Color 1.4.1 - Tested on original Nook Color, not Nook Tablet            $this->is('AndroidOS') && $this->is('NookTablet') ||            // Chrome Desktop 16-24 - Tested on OS X 10.7 and Windows 7            $this->version('Chrome', self::VERSION_TYPE_FLOAT) >= 16 && !$isMobile ||            // Safari Desktop 5-6 - Tested on OS X 10.7 and Windows 7            $this->version('Safari', self::VERSION_TYPE_FLOAT) >= 5.0 && !$isMobile ||            // Firefox Desktop 10-18 - Tested on OS X 10.7 and Windows 7            $this->version('Firefox', self::VERSION_TYPE_FLOAT) >= 10.0 && !$isMobile ||            // Internet Explorer 7-9 - Tested on Windows XP, Vista and 7            $this->version('IE', self::VERSION_TYPE_FLOAT) >= 7.0 && !$isMobile ||            // Opera Desktop 10-12 - Tested on OS X 10.7 and Windows 7            $this->version('Opera', self::VERSION_TYPE_FLOAT) >= 10 && !$isMobile        ){            return self::MOBILE_GRADE_A;        }        if (            $this->is('iOS') && $this->version('iPad', self::VERSION_TYPE_FLOAT)<4.3 ||            $this->is('iOS') && $this->version('iPhone', self::VERSION_TYPE_FLOAT)<4.3 ||            $this->is('iOS') && $this->version('iPod', self::VERSION_TYPE_FLOAT)<4.3 ||            // Blackberry 5.0: Tested on the Storm 2 9550, Bold 9770            $this->is('Blackberry') && $this->version('BlackBerry', self::VERSION_TYPE_FLOAT) >= 5 && $this->version('BlackBerry', self::VERSION_TYPE_FLOAT)<6 ||            //Opera Mini (5.0-6.5) - Tested on iOS 3.2/4.3 and Android 2.3            ($this->version('Opera Mini', self::VERSION_TYPE_FLOAT) >= 5.0 && $this->version('Opera Mini', self::VERSION_TYPE_FLOAT) <= 7.0 &&            ($this->version('Android', self::VERSION_TYPE_FLOAT) >= 2.3 || $this->is('iOS')) ) ||            // Nokia Symbian^3 - Tested on Nokia N8 (Symbian^3), C7 (Symbian^3), also works on N97 (Symbian^1)            $this->match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') ||            // @todo: report this (tested on Nokia N71)            $this->version('Opera Mobi', self::VERSION_TYPE_FLOAT) >= 11 && $this->is('SymbianOS')        ){            return self::MOBILE_GRADE_B;        }        if (            // Blackberry 4.x - Tested on the Curve 8330            $this->version('BlackBerry', self::VERSION_TYPE_FLOAT) <= 5.0 ||            // Windows Mobile - Tested on the HTC Leo (WinMo 5.2)            $this->match('MSIEMobile|Windows CE.*Mobile') || $this->version('Windows Mobile', self::VERSION_TYPE_FLOAT) <= 5.2 ||            // Tested on original iPhone (3.1), iPhone 3 (3.2)            $this->is('iOS') && $this->version('iPad', self::VERSION_TYPE_FLOAT) <= 3.2 ||            $this->is('iOS') && $this->version('iPhone', self::VERSION_TYPE_FLOAT) <= 3.2 ||            $this->is('iOS') && $this->version('iPod', self::VERSION_TYPE_FLOAT) <= 3.2 ||            // Internet Explorer 7 and older - Tested on Windows XP            $this->version('IE', self::VERSION_TYPE_FLOAT) <= 7.0 && !$isMobile        ){            return self::MOBILE_GRADE_C;        }        // All older smartphone platforms and featurephones - Any device that doesn't support media queries        // will receive the basic, C grade experience.        return self::MOBILE_GRADE_C;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_session_example_1153, Your default site layouts.\\n Update this array if you have fewer layout types.\\n, Your default site layouts.,"function layoutTypes(){    return array('classic', 'mobile', 'tablet');}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
slimphp_Slim_AppTest_2751, Route collector proxy methods\n, Route collector proxy methods,"    public function upperCaseRequestMethodsProvider()    {        return [            ['GET'],            ['POST'],            ['PUT'],            ['PATCH'],            ['DELETE'],            ['OPTIONS'],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
slimphp_Slim_AppTest_2757, Middleware\n, Middleware,"    public function testAddMiddleware()    {        $streamProphecy = $this->prophesize(StreamInterface::class);        $streamProphecy->__toString()->willReturn('Hello World');        $responseProphecy = $this->prophesize(ResponseInterface::class);        $responseProphecy->getBody()->willReturn($streamProphecy->reveal());        $responseFactoryProphecy = $this->prophesize(ResponseFactoryInterface::class);        $responseFactoryProphecy->createResponse()->willReturn($responseProphecy->reveal());        $app = new App($responseFactoryProphecy->reveal());        $middlewareProphecy = $this->prophesize(MiddlewareInterface::class);        $middlewareProphecy->process(Argument::cetera())->will(function () use ($responseProphecy) {            return $responseProphecy->reveal();        });        $middlewareProphecy2 = $this->prophesize(MiddlewareInterface::class);        $middlewareProphecy2->process(            Argument::type(ServerRequestInterface::class),            Argument::type(RequestHandlerInterface::class)        )->will(function ($args) {            /** @var ServerRequestInterface $request */            $request = $args[0];            /** @var RequestHandlerInterface $handler */            $handler = $args[1];            return $handler->handle($request);        });        $app->add($middlewareProphecy->reveal());        $app->addMiddleware($middlewareProphecy2->reveal());        $app->get('/', function (ServerRequestInterface $request, $response) {            return $response;        });        $uriProphecy = $this->prophesize(UriInterface::class);        $uriProphecy->getPath()->willReturn('/');        $requestProphecy = $this->prophesize(ServerRequestInterface::class);        $requestProphecy->getMethod()->willReturn('GET');        $requestProphecy->getUri()->willReturn($uriProphecy->reveal());        $requestProphecy->getAttribute(RouteContext::ROUTING_RESULTS)->willReturn(null);        $requestProphecy->withAttribute(Argument::type('string'), Argument::any())->will(function ($args) {            $this->getAttribute($args[0])->willReturn($args[1]);            return $this;        });        $response = $app->handle($requestProphecy->reveal());        $middlewareProphecy->process(            Argument::type(ServerRequestInterface::class),            Argument::type(RequestHandlerInterface::class)        )->shouldHaveBeenCalled();        $middlewareProphecy2->process(            Argument::type(ServerRequestInterface::class),            Argument::type(RequestHandlerInterface::class)        )->shouldHaveBeenCalled();        $this->assertSame($responseProphecy->reveal(), $response);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
slimphp_Slim_AppTest_2761, TODO: Re-add testUnsupportedMethodWithRoute\n, TODO: Re-add testUnsupportedMethodWithRoute,"    public function testContainerSetToRoute()    {        $streamProphecy = $this->prophesize(StreamInterface::class);        $streamProphecy->__toString()->willReturn('Hello World');        $responseProphecy = $this->prophesize(ResponseInterface::class);        $responseProphecy->getBody()->willReturn($streamProphecy->reveal());        $responseFactoryProphecy = $this->prophesize(ResponseFactoryInterface::class);        $responseFactoryProphecy->createResponse()->willReturn($responseProphecy->reveal());        $containerProphecy = $this->prophesize(ContainerInterface::class);        $containerProphecy->has('handler')->willReturn(true);        $containerProphecy->get('handler')->willReturn(function () use ($responseProphecy) {            return $responseProphecy->reveal();        });        $app = new App($responseFactoryProphecy->reveal(), $containerProphecy->reveal());        $routeCollector = $app->getRouteCollector();        $routeCollector->map(['GET'], '/', 'handler');        $uriProphecy = $this->prophesize(UriInterface::class);        $uriProphecy->getPath()->willReturn('/');        $requestProphecy = $this->prophesize(ServerRequestInterface::class);        $requestProphecy->getMethod()->willReturn('GET');        $requestProphecy->getUri()->willReturn($uriProphecy->reveal());        $requestProphecy->getAttribute(RouteContext::ROUTING_RESULTS)->willReturn(null);        $requestProphecy->withAttribute(Argument::type('string'), Argument::any())->will(function ($args) {            $this->getAttribute($args[0])->willReturn($args[1]);            return $this;        });        $response = $app->handle($requestProphecy->reveal());        $this->assertEquals('Hello World', (string) $response->getBody());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
slimphp_Slim_HtmlErrorRenderer_2737, Default Slim application HTML Error Renderer\n, Default Slim application HTML Error Renderer,"class HtmlErrorRenderer extends AbstractErrorRenderer{    /**     * @param Throwable $exception     * @param bool      $displayErrorDetails     * @return string     */    public function __invoke(Throwable $exception, bool $displayErrorDetails): string    {        if ($displayErrorDetails) {            $html = '<p>The application could not run because of the following error:</p>';            $html .= '<h2>Details</h2>';            $html .= $this->renderExceptionFragment($exception);        } else {            $html = ""<p>{$this->getErrorDescription($exception)}</p>"";        }        return $this->renderHtmlBody($this->getErrorTitle($exception), $html);    }    /**     * @param Throwable $exception     * @return string     */    private function renderExceptionFragment(Throwable $exception): string    {        $html = sprintf('<div><strong>Type:</strong> %s</div>', get_class($exception));        $code = $exception->getCode();        if ($code !== null) {            $html .= sprintf('<div><strong>Code:</strong> %s</div>', $code);        }        $message = $exception->getMessage();        if ($message !== null) {            $html .= sprintf('<div><strong>Message:</strong> %s</div>', htmlentities($message));        }        $file = $exception->getFile();        if ($file !== null) {            $html .= sprintf('<div><strong>File:</strong> %s</div>', $file);        }        $line = $exception->getLine();        if ($line !== null) {            $html .= sprintf('<div><strong>Line:</strong> %s</div>', $line);        }        $trace = $exception->getTraceAsString();        if ($trace !== null) {            $html .= '<h2>Trace</h2>';            $html .= sprintf('<pre>%s</pre>', htmlentities($trace));        }        return $html;    }    /**     * @param string $title     * @param string $html     * @return string     */    public function renderHtmlBody(string $title = '', string $html = ''): string    {        return sprintf(            '<html>' .            '   <head>' .            ""       <meta http-equiv='Content-Type' content='text/html; charset=utf-8'>"" .            '       <title>%s</title>' .            '       <style>' .            '           body{margin:0;padding:30px;font:12px/1.5 Helvetica,Arial,Verdana,sans-serif}' .            '           h1{margin:0;font-size:48px;font-weight:normal;line-height:48px}' .            '           strong{display:inline-block;width:65px}' .            '       </style>' .            '   </head>' .            '   <body>' .            '       <h1>%s</h1>' .            '       <div>%s</div>' .            '       <a href=""#"" onClick=""window.history.go(-1)"">Go Back</a>' .            '   </body>' .            '</html>',            $title,            $title,            $html        );    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
slimphp_Slim_MiddlewareDispatcher_2727," Add a new middleware by class name\n\n Middleware are organized as a stack. That means middleware\n that have been added before will be executed after the newly\n added one (last in, first out).\n\n @param string $middleware\n @return self\n", Add a new middleware by class name,"    public function addDeferred(string $middleware): self    {        $next = $this->tip;        $this->tip = new class (            $middleware,            $next,            $this->container,            $this->callableResolver        ) implements RequestHandlerInterface {            /**             * @var string             */            private $middleware;            /**             * @var RequestHandlerInterface             */            private $next;            /**             * @var ContainerInterface|null             */            private $container;            /**             * @var CallableResolverInterface|null             */            private $callableResolver;            public function __construct(                string $middleware,                RequestHandlerInterface $next,                ?ContainerInterface $container = null,                ?CallableResolverInterface $callableResolver = null            ) {                $this->middleware = $middleware;                $this->next = $next;                $this->container = $container;                $this->callableResolver = $callableResolver;            }            public function handle(ServerRequestInterface $request): ResponseInterface            {                if ($this->callableResolver instanceof AdvancedCallableResolverInterface) {                    $callable = $this->callableResolver->resolveMiddleware($this->middleware);                    return $callable($request, $this->next);                }                $callable = null;                if ($this->callableResolver instanceof CallableResolverInterface) {                    try {                        $callable = $this->callableResolver->resolve($this->middleware);                    } catch (RuntimeException $e) {                        // Do Nothing                    }                }                if (!$callable) {                    $resolved = $this->middleware;                    $instance = null;                    $method = null;                    // Check for Slim callable as `class:method`                    if (preg_match(CallableResolver::$callablePattern, $resolved, $matches)) {                        $resolved = $matches[1];                        $method = $matches[2];                    }                    if ($this->container && $this->container->has($resolved)) {                        $instance = $this->container->get($resolved);                        if ($instance instanceof MiddlewareInterface) {                            return $instance->process($request, $this->next);                        }                    } elseif (!function_exists($resolved)) {                        if (!class_exists($resolved)) {                            throw new RuntimeException(sprintf('Middleware %s does not exist', $resolved));                        }                        $instance = new $resolved($this->container);                    }                    if ($instance && $instance instanceof MiddlewareInterface) {                        return $instance->process($request, $this->next);                    }                    $callable = $instance ?? $resolved;                    if ($instance && $method) {                        $callable = [$instance, $method];                    }                    if ($this->container && $callable instanceof Closure) {                        $callable = $callable->bindTo($this->container);                    }                }                if (!is_callable($callable)) {                    throw new RuntimeException(                        sprintf(                            'Middleware %s is not resolvable',                            $this->middleware                        )                    );                }                return $callable($request, $this->next);            }        };        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
slimphp_Slim_ResponseEmitter_2731, Emit Status Line\n\n @param ResponseInterface $response\n, Emit Status Line,"    private function emitStatusLine(ResponseInterface $response): void    {        $statusLine = sprintf(            'HTTP/%s %s %s',            $response->getProtocolVersion(),            $response->getStatusCode(),            $response->getReasonPhrase()        );        header($statusLine, true, $response->getStatusCode());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
spatie_array-functions_array_functions_1058," Get a random value from an array, with the ability to skew the results.\\n Example: array_rand_weighted(['foo' => 1, 'bar' => 2]) has a 66% chance of returning bar.\\n\\n @param array $array\\n\\n @return mixed\\n"," Get a random value from an array, with the ability to skew the results.","function array_rand_weighted(array $array){    $array = array_filter($array, function ($item) {        return $item >= 1;    });    if (! count($array)) {        return;    }    $totalWeight = array_sum($array);    foreach ($array as $value => $weight) {        if (rand(1, $totalWeight) <= $weight) {            return $value;        }        $totalWeight -= $weight;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
spatie_array-functions_array_functions_1059, Determine if all given needles are present in the haystack.\n\n @param array|string $needles\n @param array        $haystack\n\n @return bool\n, Determine if all given needles are present in the haystack.,"function values_in_array($needles, array $haystack){    if (! is_array($needles)) {        $needles = [$needles];    }    return count(array_intersect($needles, $haystack)) === count($needles);}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
spatie_array-functions_array_functions_1061," Returns an array with two elements.\\n\\n Iterates over each value in the array passing them to the callback function.\\n If the callback function returns true, the current value from array is returned in the first\\n element of result array. If not, it is return in the second element of result array.\\n\\n Array keys are preserved.\\n\\n @param array    $array\\n @param callable $callback\\n\\n @return array\\n", Returns an array with two elements.,"function array_split_filter(array $array, callable $callback){    $passesFilter = array_filter($array, $callback);    $negatedCallback = static function ($item) use ($callback) {        return ! $callback($item);    };    $doesNotPassFilter = array_filter($array, $negatedCallback);    return [$passesFilter, $doesNotPassFilter];}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
spatie_laravel-permission_Guard_157, return collection of (guard_name) property if exist on class or object\n otherwise will return collection of guards names that exists in config/auth.php.\n\n @param string|Model $model model class object or name\n @return Collection\n, return collection of (guard_name) property if exist on class or object,"    public static function getNames($model): Collection    {        if (is_object($model)) {            if (\method_exists($model, 'guardName')) {                $guardName = $model->guardName();            } else {                $guardName = $model->guard_name ?? null;            }        }        if (! isset($guardName)) {            $class = is_object($model) ? get_class($model) : $model;            $guardName = (new \ReflectionClass($class))->getDefaultProperties()['guard_name'] ?? null;        }        if ($guardName) {            return collect($guardName);        }        return collect(config('auth.guards'))            ->map(function ($guard) {                if (! isset($guard['provider'])) {                    return null;                }                return config(""auth.providers.{$guard['provider']}.model"");            })            ->filter(function ($model) use ($class) {                return $class === $model;            })            ->keys();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_AbstractMethodUnitTest_957," Initialize & tokenize \\\\\\\\PHP_CodeSniffer\\\\\\\\Files\\\\\\\\File with code from the test case file.\\\\n\\\\n The test case file for a unit test class has to be in the same directory\\\\n directory and use the same file name as the test class, using the .inc extension.\\\\n\\\\n @return void\\\\n", Initialize & tokenize ,"    public static function setUpBeforeClass()    {        $config            = new Config();        $config->standards = ['PSR1'];        $ruleset = new Ruleset($config);        // Default to a file with the same name as the test class. Extension is property based.        $relativeCN     = str_replace(__NAMESPACE__, '', get_called_class());        $relativePath   = str_replace('\\', DIRECTORY_SEPARATOR, $relativeCN);        $pathToTestFile = realpath(__DIR__).$relativePath.'.'.static::$fileExtension;        // Make sure the file gets parsed correctly based on the file type.        $contents  = 'phpcs_input_file: '.$pathToTestFile.PHP_EOL;        $contents .= file_get_contents($pathToTestFile);        self::$phpcsFile = new DummyFile($contents, $ruleset, $config);        self::$phpcsFile->process();    }//end setUpBeforeClass()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_AllTests_959, Prepare the test runner.\\n\\n @return void\\n, Prepare the test runner.,    public static function main()    {        TestRunner::run(self::suite());    }//end main(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_AllTests_960, Add all core unit tests into a test suite.\\n\\n @return \\\\PHPUnit\\\\Framework\\\\TestSuite\\n, Add all core unit tests into a test suite.,"    public static function suite()    {        $suite = new TestSuite('PHP CodeSniffer Core');        $testFileIterator = new FileList(__DIR__, '', '`Test\.php$`Di');        foreach ($testFileIterator->fileIterator as $file) {            if (strpos($file, 'AbstractMethodUnitTest.php') !== false) {                continue;            }            include_once $file;            $class = str_replace(__DIR__, '', $file);            $class = str_replace('.php', '', $class);            $class = str_replace('/', '\\', $class);            $class = 'PHP_CodeSniffer\Tests\Core'.$class;            $suite->addTestSuite($class);        }        return $suite;    }//end suite()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_861," Stores the configuration used to run PHPCS and PHPCBF.\\n\\n @property string[] $files           The files and directories to check.\\n @property string[] $standards       The standards being used for checking.\\n @property int      $verbosity       How verbose the output should be.\\n                                     0: no unnecessary output\\n                                     1: basic output for files being checked\\n                                     2: ruleset and file parsing output\\n                                     3: sniff execution output\\n @property bool     $interactive     Enable interactive checking mode.\\n @property bool     $parallel        Check files in parallel.\\n @property bool     $cache           Enable the use of the file cache.\\n @property bool     $cacheFile       A file where the cache data should be written\\n @property bool     $colors          Display colours in output.\\n @property bool     $explain         Explain the coding standards.\\n @property bool     $local           Process local files in directories only (no recursion).\\n @property bool     $showSources     Show sniff source codes in report output.\\n @property bool     $showProgress    Show basic progress information while running.\\n @property bool     $quiet           Quiet mode; disables progress and verbose output.\\n @property bool     $annotations     Process phpcs: annotations.\\n @property int      $tabWidth        How many spaces each tab is worth.\\n @property string   $encoding        The encoding of the files being checked.\\n @property string[] $sniffs          The sniffs that should be used for checking.\\n                                     If empty, all sniffs in the supplied standards will be used.\\n @property string[] $exclude         The sniffs that should be excluded from checking.\\n                                     If empty, all sniffs in the supplied standards will be used.\\n @property string[] $ignored         Regular expressions used to ignore files and folders during checking.\\n @property string   $reportFile      A file where the report output should be written.\\n @property string   $generator       The documentation generator to use.\\n @property string   $filter          The filter to use for the run.\\n @property string[] $bootstrap       One of more files to include before the run begins.\\n @property int      $reportWidth     The maximum number of columns that reports should use for output.\\n                                     Set to ""auto"" for have this value changed to the width of the terminal.\\n @property int      $errorSeverity   The minimum severity an error must have to be displayed.\\n @property int      $warningSeverity The minimum severity a warning must have to be displayed.\\n @property bool     $recordErrors    Record the content of error messages as well as error counts.\\n @property string   $suffix          A suffix to add to fixed files.\\n @property string   $basepath        A file system location to strip from the paths of files shown in reports.\\n @property bool     $stdin           Read content from STDIN instead of supplied files.\\n @property string   $stdinContent    Content passed directly to PHPCS on STDIN.\\n @property string   $stdinPath       The path to use for content passed on STDIN.\\n\\n @property array<string, string>      $extensions File extensions that should be checked, and what tokenizer to use.\\n                                                  E.g., array(\\\'inc\\\' => \\\'PHP\\\');\\n @property array<string, string|null> $reports    The reports to use for printing output after the run.\\n                                                  The format of the array is:\\n                                                      array(\\n                                                          \\\'reportName1\\\' => \\\'outputFile\\\',\\n                                                          \\\'reportName2\\\' => null,\\n                                                      );\\n                                                  If the array value is NULL, the report will be written to the screen.\\n\\n @property string[] $unknown Any arguments gathered on the command line that are unknown to us.\\n                             E.g., using `phpcs -c` will give array(\\\'c\\\');\\n", Stores the configuration used to run PHPCS and PHPCBF.,"class Config{    /**     * The current version.     *     * @var string     */    const VERSION = '3.6.1';    /**     * Package stability; either stable, beta or alpha.     *     * @var string     */    const STABILITY = 'stable';    /**     * An array of settings that PHPCS and PHPCBF accept.     *     * This array is not meant to be accessed directly. Instead, use the settings     * as if they are class member vars so the __get() and __set() magic methods     * can be used to validate the values. For example, to set the verbosity level to     * level 2, use $this->verbosity = 2; instead of accessing this property directly.     *     * Each of these settings is described in the class comment property list.     *     * @var array<string, mixed>     */    private $settings = [        'files'           => null,        'standards'       => null,        'verbosity'       => null,        'interactive'     => null,        'parallel'        => null,        'cache'           => null,        'cacheFile'       => null,        'colors'          => null,        'explain'         => null,        'local'           => null,        'showSources'     => null,        'showProgress'    => null,        'quiet'           => null,        'annotations'     => null,        'tabWidth'        => null,        'encoding'        => null,        'extensions'      => null,        'sniffs'          => null,        'exclude'         => null,        'ignored'         => null,        'reportFile'      => null,        'generator'       => null,        'filter'          => null,        'bootstrap'       => null,        'reports'         => null,        'basepath'        => null,        'reportWidth'     => null,        'errorSeverity'   => null,        'warningSeverity' => null,        'recordErrors'    => null,        'suffix'          => null,        'stdin'           => null,        'stdinContent'    => null,        'stdinPath'       => null,        'unknown'         => null,    ];    /**     * Whether or not to kill the process when an unknown command line arg is found.     *     * If FALSE, arguments that are not command line options or file/directory paths     * will be ignored and execution will continue. These values will be stored in     * $this->unknown.     *     * @var boolean     */    public $dieOnUnknownArg;    /**     * The current command line arguments we are processing.     *     * @var string[]     */    private $cliArgs = [];    /**     * Command line values that the user has supplied directly.     *     * @var array<string, TRUE>     */    private static $overriddenDefaults = [];    /**     * Config file data that has been loaded for the run.     *     * @var array<string, string>     */    private static $configData = null;    /**     * The full path to the config data file that has been loaded.     *     * @var string     */    private static $configDataFile = null;    /**     * Automatically discovered executable utility paths.     *     * @var array<string, string>     */    private static $executablePaths = [];    /**     * Get the value of an inaccessible property.     *     * @param string $name The name of the property.     *     * @return mixed     * @throws \PHP_CodeSniffer\Exceptions\RuntimeException If the setting name is invalid.     */    public function __get($name)    {        if (array_key_exists($name, $this->settings) === false) {            throw new RuntimeException(""ERROR: unable to get value of property \""$name\"""");        }        return $this->settings[$name];    }//end __get()    /**     * Set the value of an inaccessible property.     *     * @param string $name  The name of the property.     * @param mixed  $value The value of the property.     *     * @return void     * @throws \PHP_CodeSniffer\Exceptions\RuntimeException If the setting name is invalid.     */    public function __set($name, $value)    {        if (array_key_exists($name, $this->settings) === false) {            throw new RuntimeException(""Can't __set() $name; setting doesn't exist"");        }        switch ($name) {        case 'reportWidth' :            // Support auto terminal width.            if ($value === 'auto'                && function_exists('shell_exec') === true                && preg_match('|\d+ (\d+)|', shell_exec('stty size 2>&1'), $matches) === 1            ) {                $value = (int) $matches[1];            } else {                $value = (int) $value;            }            break;        case 'standards' :            $cleaned = [];            // Check if the standard name is valid, or if the case is invalid.            $installedStandards = Util\Standards::getInstalledStandards();            foreach ($value as $standard) {                foreach ($installedStandards as $validStandard) {                    if (strtolower($standard) === strtolower($validStandard)) {                        $standard = $validStandard;                        break;                    }                }                $cleaned[] = $standard;            }            $value = $cleaned;            break;        default :            // No validation required.            break;        }//end switch        $this->settings[$name] = $value;    }//end __set()    /**     * Check if the value of an inaccessible property is set.     *     * @param string $name The name of the property.     *     * @return bool     */    public function __isset($name)    {        return isset($this->settings[$name]);    }//end __isset()    /**     * Unset the value of an inaccessible property.     *     * @param string $name The name of the property.     *     * @return void     */    public function __unset($name)    {        $this->settings[$name] = null;    }//end __unset()    /**     * Get the array of all config settings.     *     * @return array<string, mixed>     */    public function getSettings()    {        return $this->settings;    }//end getSettings()    /**     * Set the array of all config settings.     *     * @param array<string, mixed> $settings The array of config settings.     *     * @return void     */    public function setSettings($settings)    {        return $this->settings = $settings;    }//end setSettings()    /**     * Creates a Config object and populates it with command line values.     *     * @param array $cliArgs         An array of values gathered from CLI args.     * @param bool  $dieOnUnknownArg Whether or not to kill the process when an     *                               unknown command line arg is found.     *     * @return void     */    public function __construct(array $cliArgs=[], $dieOnUnknownArg=true)    {        if (defined('PHP_CODESNIFFER_IN_TESTS') === true) {            // Let everything through during testing so that we can            // make use of PHPUnit command line arguments as well.            $this->dieOnUnknownArg = false;        } else {            $this->dieOnUnknownArg = $dieOnUnknownArg;        }        if (empty($cliArgs) === true) {            $cliArgs = $_SERVER['argv'];            array_shift($cliArgs);        }        $this->restoreDefaults();        $this->setCommandLineValues($cliArgs);        if (isset(self::$overriddenDefaults['standards']) === false) {            // They did not supply a standard to use.            // Look for a default ruleset in the current directory or higher.            $currentDir = getcwd();            $defaultFiles = [                '.phpcs.xml',                'phpcs.xml',                '.phpcs.xml.dist',                'phpcs.xml.dist',            ];            do {                foreach ($defaultFiles as $defaultFilename) {                    $default = $currentDir.DIRECTORY_SEPARATOR.$defaultFilename;                    if (is_file($default) === true) {                        $this->standards = [$default];                        break(2);                    }                }                $lastDir    = $currentDir;                $currentDir = dirname($currentDir);            } while ($currentDir !== '.' && $currentDir !== $lastDir && @is_readable($currentDir) === true);        }//end if        if (defined('STDIN') === false            || strtoupper(substr(PHP_OS, 0, 3)) === 'WIN'        ) {            return;        }        $handle = fopen('php://stdin', 'r');        // Check for content on STDIN.        if ($this->stdin === true            || (Util\Common::isStdinATTY() === false            && feof($handle) === false)        ) {            $readStreams = [$handle];            $writeSteams = null;            $fileContents = '';            while (is_resource($handle) === true && feof($handle) === false) {                // Set a timeout of 200ms.                if (stream_select($readStreams, $writeSteams, $writeSteams, 0, 200000) === 0) {                    break;                }                $fileContents .= fgets($handle);            }            if (trim($fileContents) !== '') {                $this->stdin        = true;                $this->stdinContent = $fileContents;                self::$overriddenDefaults['stdin']        = true;                self::$overriddenDefaults['stdinContent'] = true;            }        }//end if        fclose($handle);    }//end __construct()    /**     * Set the command line values.     *     * @param array $args An array of command line arguments to set.     *     * @return void     */    public function setCommandLineValues($args)    {        $this->cliArgs = $args;        $numArgs       = count($args);        for ($i = 0; $i < $numArgs; $i++) {            $arg = $this->cliArgs[$i];            if ($arg === '') {                continue;            }            if ($arg[0] === '-') {                if ($arg === '-') {                    // Asking to read from STDIN.                    $this->stdin = true;                    self::$overriddenDefaults['stdin'] = true;                    continue;                }                if ($arg === '--') {                    // Empty argument, ignore it.                    continue;                }                if ($arg[1] === '-') {                    $this->processLongArgument(substr($arg, 2), $i);                } else {                    $switches = str_split($arg);                    foreach ($switches as $switch) {                        if ($switch === '-') {                            continue;                        }                        $this->processShortArgument($switch, $i);                    }                }            } else {                $this->processUnknownArgument($arg, $i);            }//end if        }//end for    }//end setCommandLineValues()    /**     * Restore default values for all possible command line arguments.     *     * @return array     */    public function restoreDefaults()    {        $this->files           = [];        $this->standards       = ['PEAR'];        $this->verbosity       = 0;        $this->interactive     = false;        $this->cache           = false;        $this->cacheFile       = null;        $this->colors          = false;        $this->explain         = false;        $this->local           = false;        $this->showSources     = false;        $this->showProgress    = false;        $this->quiet           = false;        $this->annotations     = true;        $this->parallel        = 1;        $this->tabWidth        = 0;        $this->encoding        = 'utf-8';        $this->extensions      = [            'php' => 'PHP',            'inc' => 'PHP',            'js'  => 'JS',            'css' => 'CSS',        ];        $this->sniffs          = [];        $this->exclude         = [];        $this->ignored         = [];        $this->reportFile      = null;        $this->generator       = null;        $this->filter          = null;        $this->bootstrap       = [];        $this->basepath        = null;        $this->reports         = ['full' => null];        $this->reportWidth     = 'auto';        $this->errorSeverity   = 5;        $this->warningSeverity = 5;        $this->recordErrors    = true;        $this->suffix          = '';        $this->stdin           = false;        $this->stdinContent    = null;        $this->stdinPath       = null;        $this->unknown         = [];        $standard = self::getConfigData('default_standard');        if ($standard !== null) {            $this->standards = explode(',', $standard);        }        $reportFormat = self::getConfigData('report_format');        if ($reportFormat !== null) {            $this->reports = [$reportFormat => null];        }        $tabWidth = self::getConfigData('tab_width');        if ($tabWidth !== null) {            $this->tabWidth = (int) $tabWidth;        }        $encoding = self::getConfigData('encoding');        if ($encoding !== null) {            $this->encoding = strtolower($encoding);        }        $severity = self::getConfigData('severity');        if ($severity !== null) {            $this->errorSeverity   = (int) $severity;            $this->warningSeverity = (int) $severity;        }        $severity = self::getConfigData('error_severity');        if ($severity !== null) {            $this->errorSeverity = (int) $severity;        }        $severity = self::getConfigData('warning_severity');        if ($severity !== null) {            $this->warningSeverity = (int) $severity;        }        $showWarnings = self::getConfigData('show_warnings');        if ($showWarnings !== null) {            $showWarnings = (bool) $showWarnings;            if ($showWarnings === false) {                $this->warningSeverity = 0;            }        }        $reportWidth = self::getConfigData('report_width');        if ($reportWidth !== null) {            $this->reportWidth = $reportWidth;        }        $showProgress = self::getConfigData('show_progress');        if ($showProgress !== null) {            $this->showProgress = (bool) $showProgress;        }        $quiet = self::getConfigData('quiet');        if ($quiet !== null) {            $this->quiet = (bool) $quiet;        }        $colors = self::getConfigData('colors');        if ($colors !== null) {            $this->colors = (bool) $colors;        }        if (defined('PHP_CODESNIFFER_IN_TESTS') === false) {            $cache = self::getConfigData('cache');            if ($cache !== null) {                $this->cache = (bool) $cache;            }            $parallel = self::getConfigData('parallel');            if ($parallel !== null) {                $this->parallel = max((int) $parallel, 1);            }        }    }//end restoreDefaults()    /**     * Processes a short (-e) command line argument.     *     * @param string $arg The command line argument.     * @param int    $pos The position of the argument on the command line.     *     * @return void     * @throws \PHP_CodeSniffer\Exceptions\DeepExitException     */    public function processShortArgument($arg, $pos)    {        switch ($arg) {        case 'h':        case '?':            ob_start();            $this->printUsage();            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'i' :            ob_start();            Util\Standards::printInstalledStandards();            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'v' :            if ($this->quiet === true) {                // Ignore when quiet mode is enabled.                break;            }            $this->verbosity++;            self::$overriddenDefaults['verbosity'] = true;            break;        case 'l' :            $this->local = true;            self::$overriddenDefaults['local'] = true;            break;        case 's' :            $this->showSources = true;            self::$overriddenDefaults['showSources'] = true;            break;        case 'a' :            $this->interactive = true;            self::$overriddenDefaults['interactive'] = true;            break;        case 'e':            $this->explain = true;            self::$overriddenDefaults['explain'] = true;            break;        case 'p' :            if ($this->quiet === true) {                // Ignore when quiet mode is enabled.                break;            }            $this->showProgress = true;            self::$overriddenDefaults['showProgress'] = true;            break;        case 'q' :            // Quiet mode disables a few other settings as well.            $this->quiet        = true;            $this->showProgress = false;            $this->verbosity    = 0;            self::$overriddenDefaults['quiet'] = true;            break;        case 'm' :            $this->recordErrors = false;            self::$overriddenDefaults['recordErrors'] = true;            break;        case 'd' :            $ini = explode('=', $this->cliArgs[($pos + 1)]);            $this->cliArgs[($pos + 1)] = '';            if (isset($ini[1]) === true) {                ini_set($ini[0], $ini[1]);            } else {                ini_set($ini[0], true);            }            break;        case 'n' :            if (isset(self::$overriddenDefaults['warningSeverity']) === false) {                $this->warningSeverity = 0;                self::$overriddenDefaults['warningSeverity'] = true;            }            break;        case 'w' :            if (isset(self::$overriddenDefaults['warningSeverity']) === false) {                $this->warningSeverity = $this->errorSeverity;                self::$overriddenDefaults['warningSeverity'] = true;            }            break;        default:            if ($this->dieOnUnknownArg === false) {                $unknown       = $this->unknown;                $unknown[]     = $arg;                $this->unknown = $unknown;            } else {                $this->processUnknownArgument('-'.$arg, $pos);            }        }//end switch    }//end processShortArgument()    /**     * Processes a long (--example) command line argument.     *     * @param string $arg The command line argument.     * @param int    $pos The position of the argument on the command line.     *     * @return void     * @throws \PHP_CodeSniffer\Exceptions\DeepExitException     */    public function processLongArgument($arg, $pos)    {        switch ($arg) {        case 'help':            ob_start();            $this->printUsage();            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'version':            $output  = 'PHP_CodeSniffer version '.self::VERSION.' ('.self::STABILITY.') ';            $output .= 'by Squiz (http://www.squiz.net)'.PHP_EOL;            throw new DeepExitException($output, 0);        case 'colors':            if (isset(self::$overriddenDefaults['colors']) === true) {                break;            }            $this->colors = true;            self::$overriddenDefaults['colors'] = true;            break;        case 'no-colors':            if (isset(self::$overriddenDefaults['colors']) === true) {                break;            }            $this->colors = false;            self::$overriddenDefaults['colors'] = true;            break;        case 'cache':            if (isset(self::$overriddenDefaults['cache']) === true) {                break;            }            if (defined('PHP_CODESNIFFER_IN_TESTS') === false) {                $this->cache = true;                self::$overriddenDefaults['cache'] = true;            }            break;        case 'no-cache':            if (isset(self::$overriddenDefaults['cache']) === true) {                break;            }            $this->cache = false;            self::$overriddenDefaults['cache'] = true;            break;        case 'ignore-annotations':            if (isset(self::$overriddenDefaults['annotations']) === true) {                break;            }            $this->annotations = false;            self::$overriddenDefaults['annotations'] = true;            break;        case 'config-set':            if (isset($this->cliArgs[($pos + 1)]) === false                || isset($this->cliArgs[($pos + 2)]) === false            ) {                $error  = 'ERROR: Setting a config option requires a name and value'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $key     = $this->cliArgs[($pos + 1)];            $value   = $this->cliArgs[($pos + 2)];            $current = self::getConfigData($key);            try {                $this->setConfigData($key, $value);            } catch (\Exception $e) {                throw new DeepExitException($e->getMessage().PHP_EOL, 3);            }            $output = 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            if ($current === null) {                $output .= ""Config value \""$key\"" added successfully"".PHP_EOL;            } else {                $output .= ""Config value \""$key\"" updated successfully; old value was \""$current\"""".PHP_EOL;            }            throw new DeepExitException($output, 0);        case 'config-delete':            if (isset($this->cliArgs[($pos + 1)]) === false) {                $error  = 'ERROR: Deleting a config option requires the name of the option'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $output = 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            $key     = $this->cliArgs[($pos + 1)];            $current = self::getConfigData($key);            if ($current === null) {                $output .= ""Config value \""$key\"" has not been set"".PHP_EOL;            } else {                try {                    $this->setConfigData($key, null);                } catch (\Exception $e) {                    throw new DeepExitException($e->getMessage().PHP_EOL, 3);                }                $output .= ""Config value \""$key\"" removed successfully; old value was \""$current\"""".PHP_EOL;            }            throw new DeepExitException($output, 0);        case 'config-show':            ob_start();            $data = self::getAllConfigData();            echo 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            $this->printConfigData($data);            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'runtime-set':            if (isset($this->cliArgs[($pos + 1)]) === false                || isset($this->cliArgs[($pos + 2)]) === false            ) {                $error  = 'ERROR: Setting a runtime config option requires a name and value'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $key   = $this->cliArgs[($pos + 1)];            $value = $this->cliArgs[($pos + 2)];            $this->cliArgs[($pos + 1)] = '';            $this->cliArgs[($pos + 2)] = '';            self::setConfigData($key, $value, true);            if (isset(self::$overriddenDefaults['runtime-set']) === false) {                self::$overriddenDefaults['runtime-set'] = [];            }            self::$overriddenDefaults['runtime-set'][$key] = true;            break;        default:            if (substr($arg, 0, 7) === 'sniffs=') {                if (isset(self::$overriddenDefaults['sniffs']) === true) {                    break;                }                $sniffs = explode(',', substr($arg, 7));                foreach ($sniffs as $sniff) {                    if (substr_count($sniff, '.') !== 2) {                        $error  = 'ERROR: The specified sniff code ""'.$sniff.'"" is invalid'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                }                $this->sniffs = $sniffs;                self::$overriddenDefaults['sniffs'] = true;            } else if (substr($arg, 0, 8) === 'exclude=') {                if (isset(self::$overriddenDefaults['exclude']) === true) {                    break;                }                $sniffs = explode(',', substr($arg, 8));                foreach ($sniffs as $sniff) {                    if (substr_count($sniff, '.') !== 2) {                        $error  = 'ERROR: The specified sniff code ""'.$sniff.'"" is invalid'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                }                $this->exclude = $sniffs;                self::$overriddenDefaults['exclude'] = true;            } else if (defined('PHP_CODESNIFFER_IN_TESTS') === false                && substr($arg, 0, 6) === 'cache='            ) {                if ((isset(self::$overriddenDefaults['cache']) === true                    && $this->cache === false)                    || isset(self::$overriddenDefaults['cacheFile']) === true                ) {                    break;                }                // Turn caching on.                $this->cache = true;                self::$overriddenDefaults['cache'] = true;                $this->cacheFile = Util\Common::realpath(substr($arg, 6));                // It may not exist and return false instead.                if ($this->cacheFile === false) {                    $this->cacheFile = substr($arg, 6);                    $dir = dirname($this->cacheFile);                    if (is_dir($dir) === false) {                        $error  = 'ERROR: The specified cache file path ""'.$this->cacheFile.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    if ($dir === '.') {                        // Passed cache file is a file in the current directory.                        $this->cacheFile = getcwd().'/'.basename($this->cacheFile);                    } else {                        if ($dir[0] === '/') {                            // An absolute path.                            $dir = Util\Common::realpath($dir);                        } else {                            $dir = Util\Common::realpath(getcwd().'/'.$dir);                        }                        if ($dir !== false) {                            // Cache file path is relative.                            $this->cacheFile = $dir.'/'.basename($this->cacheFile);                        }                    }                }//end if                self::$overriddenDefaults['cacheFile'] = true;                if (is_dir($this->cacheFile) === true) {                    $error  = 'ERROR: The specified cache file path ""'.$this->cacheFile.'"" is a directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if (substr($arg, 0, 10) === 'bootstrap=') {                $files     = explode(',', substr($arg, 10));                $bootstrap = [];                foreach ($files as $file) {                    $path = Util\Common::realpath($file);                    if ($path === false) {                        $error  = 'ERROR: The specified bootstrap file ""'.$file.'"" does not exist'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    $bootstrap[] = $path;                }                $this->bootstrap = array_merge($this->bootstrap, $bootstrap);                self::$overriddenDefaults['bootstrap'] = true;            } else if (substr($arg, 0, 10) === 'file-list=') {                $fileList = substr($arg, 10);                $path     = Util\Common::realpath($fileList);                if ($path === false) {                    $error  = 'ERROR: The specified file list ""'.$fileList.'"" does not exist'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }                $files = file($path);                foreach ($files as $inputFile) {                    $inputFile = trim($inputFile);                    // Skip empty lines.                    if ($inputFile === '') {                        continue;                    }                    $this->processFilePath($inputFile);                }            } else if (substr($arg, 0, 11) === 'stdin-path=') {                if (isset(self::$overriddenDefaults['stdinPath']) === true) {                    break;                }                $this->stdinPath = Util\Common::realpath(substr($arg, 11));                // It may not exist and return false instead, so use whatever they gave us.                if ($this->stdinPath === false) {                    $this->stdinPath = trim(substr($arg, 11));                }                self::$overriddenDefaults['stdinPath'] = true;            } else if (PHP_CODESNIFFER_CBF === false && substr($arg, 0, 12) === 'report-file=') {                if (isset(self::$overriddenDefaults['reportFile']) === true) {                    break;                }                $this->reportFile = Util\Common::realpath(substr($arg, 12));                // It may not exist and return false instead.                if ($this->reportFile === false) {                    $this->reportFile = substr($arg, 12);                    $dir = Util\Common::realpath(dirname($this->reportFile));                    if (is_dir($dir) === false) {                        $error  = 'ERROR: The specified report file path ""'.$this->reportFile.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    $this->reportFile = $dir.'/'.basename($this->reportFile);                }//end if                self::$overriddenDefaults['reportFile'] = true;                if (is_dir($this->reportFile) === true) {                    $error  = 'ERROR: The specified report file path ""'.$this->reportFile.'"" is a directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if (substr($arg, 0, 13) === 'report-width=') {                if (isset(self::$overriddenDefaults['reportWidth']) === true) {                    break;                }                $this->reportWidth = substr($arg, 13);                self::$overriddenDefaults['reportWidth'] = true;            } else if (substr($arg, 0, 9) === 'basepath=') {                if (isset(self::$overriddenDefaults['basepath']) === true) {                    break;                }                self::$overriddenDefaults['basepath'] = true;                if (substr($arg, 9) === '') {                    $this->basepath = null;                    break;                }                $this->basepath = Util\Common::realpath(substr($arg, 9));                // It may not exist and return false instead.                if ($this->basepath === false) {                    $this->basepath = substr($arg, 9);                }                if (is_dir($this->basepath) === false) {                    $error  = 'ERROR: The specified basepath ""'.$this->basepath.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if ((substr($arg, 0, 7) === 'report=' || substr($arg, 0, 7) === 'report-')) {                $reports = [];                if ($arg[6] === '-') {                    // This is a report with file output.                    $split = strpos($arg, '=');                    if ($split === false) {                        $report = substr($arg, 7);                        $output = null;                    } else {                        $report = substr($arg, 7, ($split - 7));                        $output = substr($arg, ($split + 1));                        if ($output === false) {                            $output = null;                        } else {                            $dir = Util\Common::realpath(dirname($output));                            if (is_dir($dir) === false) {                                $error  = 'ERROR: The specified '.$report.' report file path ""'.$output.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                             ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
squizlabs_PHP_CodeSniffer_Config_863, Set the value of an inaccessible property.\n\n @param string $name  The name of the property.\n @param mixed  $value The value of the property.\n\n @return void\n @throws \\PHP_CodeSniffer\\Exceptions\\RuntimeException If the setting name is invalid.\n, Set the value of an inaccessible property.,"    public function __set($name, $value)    {        if (array_key_exists($name, $this->settings) === false) {            throw new RuntimeException(""Can't __set() $name; setting doesn't exist"");        }        switch ($name) {        case 'reportWidth' :            // Support auto terminal width.            if ($value === 'auto'                && function_exists('shell_exec') === true                && preg_match('|\d+ (\d+)|', shell_exec('stty size 2>&1'), $matches) === 1            ) {                $value = (int) $matches[1];            } else {                $value = (int) $value;            }            break;        case 'standards' :            $cleaned = [];            // Check if the standard name is valid, or if the case is invalid.            $installedStandards = Util\Standards::getInstalledStandards();            foreach ($value as $standard) {                foreach ($installedStandards as $validStandard) {                    if (strtolower($standard) === strtolower($validStandard)) {                        $standard = $validStandard;                        break;                    }                }                $cleaned[] = $standard;            }            $value = $cleaned;            break;        default :            // No validation required.            break;        }//end switch        $this->settings[$name] = $value;    }//end __set()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_867," Set the array of all config settings.\n\n @param array<string, mixed> $settings The array of config settings.\n\n @return void\n", Set the array of all config settings.,    public function setSettings($settings)    {        return $this->settings = $settings;    }//end setSettings(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_868, Set the command line values.\\n\\n @param array $args An array of command line arguments to set.\\n\\n @return void\\n, Set the command line values.,"    public function setCommandLineValues($args)    {        $this->cliArgs = $args;        $numArgs       = count($args);        for ($i = 0; $i < $numArgs; $i++) {            $arg = $this->cliArgs[$i];            if ($arg === '') {                continue;            }            if ($arg[0] === '-') {                if ($arg === '-') {                    // Asking to read from STDIN.                    $this->stdin = true;                    self::$overriddenDefaults['stdin'] = true;                    continue;                }                if ($arg === '--') {                    // Empty argument, ignore it.                    continue;                }                if ($arg[1] === '-') {                    $this->processLongArgument(substr($arg, 2), $i);                } else {                    $switches = str_split($arg);                    foreach ($switches as $switch) {                        if ($switch === '-') {                            continue;                        }                        $this->processShortArgument($switch, $i);                    }                }            } else {                $this->processUnknownArgument($arg, $i);            }//end if        }//end for    }//end setCommandLineValues()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_869, Restore default values for all possible command line arguments.\\n\\n @return array\\n, Restore default values for all possible command line arguments.,"    public function restoreDefaults()    {        $this->files           = [];        $this->standards       = ['PEAR'];        $this->verbosity       = 0;        $this->interactive     = false;        $this->cache           = false;        $this->cacheFile       = null;        $this->colors          = false;        $this->explain         = false;        $this->local           = false;        $this->showSources     = false;        $this->showProgress    = false;        $this->quiet           = false;        $this->annotations     = true;        $this->parallel        = 1;        $this->tabWidth        = 0;        $this->encoding        = 'utf-8';        $this->extensions      = [            'php' => 'PHP',            'inc' => 'PHP',            'js'  => 'JS',            'css' => 'CSS',        ];        $this->sniffs          = [];        $this->exclude         = [];        $this->ignored         = [];        $this->reportFile      = null;        $this->generator       = null;        $this->filter          = null;        $this->bootstrap       = [];        $this->basepath        = null;        $this->reports         = ['full' => null];        $this->reportWidth     = 'auto';        $this->errorSeverity   = 5;        $this->warningSeverity = 5;        $this->recordErrors    = true;        $this->suffix          = '';        $this->stdin           = false;        $this->stdinContent    = null;        $this->stdinPath       = null;        $this->unknown         = [];        $standard = self::getConfigData('default_standard');        if ($standard !== null) {            $this->standards = explode(',', $standard);        }        $reportFormat = self::getConfigData('report_format');        if ($reportFormat !== null) {            $this->reports = [$reportFormat => null];        }        $tabWidth = self::getConfigData('tab_width');        if ($tabWidth !== null) {            $this->tabWidth = (int) $tabWidth;        }        $encoding = self::getConfigData('encoding');        if ($encoding !== null) {            $this->encoding = strtolower($encoding);        }        $severity = self::getConfigData('severity');        if ($severity !== null) {            $this->errorSeverity   = (int) $severity;            $this->warningSeverity = (int) $severity;        }        $severity = self::getConfigData('error_severity');        if ($severity !== null) {            $this->errorSeverity = (int) $severity;        }        $severity = self::getConfigData('warning_severity');        if ($severity !== null) {            $this->warningSeverity = (int) $severity;        }        $showWarnings = self::getConfigData('show_warnings');        if ($showWarnings !== null) {            $showWarnings = (bool) $showWarnings;            if ($showWarnings === false) {                $this->warningSeverity = 0;            }        }        $reportWidth = self::getConfigData('report_width');        if ($reportWidth !== null) {            $this->reportWidth = $reportWidth;        }        $showProgress = self::getConfigData('show_progress');        if ($showProgress !== null) {            $this->showProgress = (bool) $showProgress;        }        $quiet = self::getConfigData('quiet');        if ($quiet !== null) {            $this->quiet = (bool) $quiet;        }        $colors = self::getConfigData('colors');        if ($colors !== null) {            $this->colors = (bool) $colors;        }        if (defined('PHP_CODESNIFFER_IN_TESTS') === false) {            $cache = self::getConfigData('cache');            if ($cache !== null) {                $this->cache = (bool) $cache;            }            $parallel = self::getConfigData('parallel');            if ($parallel !== null) {                $this->parallel = max((int) $parallel, 1);            }        }    }//end restoreDefaults()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_874, Prints out the usage information for this script.\\\\n\\\\n @return void\\\\n, Prints out the usage information for this script.,    public function printUsage()    {        echo PHP_EOL;        if (PHP_CODESNIFFER_CBF === true) {            $this->printPHPCBFUsage();        } else {            $this->printPHPCSUsage();        }        echo PHP_EOL;    }//end printUsage(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_877, Get a single config value.\\\\n\\\\n @param string $key The name of the config value.\\\\n\\\\n @return string|null\\\\n @see    setConfigData()\\\\n @see    getAllConfigData()\\\\n, Get a single config value.,    public static function getConfigData($key)    {        $phpCodeSnifferConfig = self::getAllConfigData();        if ($phpCodeSnifferConfig === null) {            return null;        }        if (isset($phpCodeSnifferConfig[$key]) === false) {            return null;        }        return $phpCodeSnifferConfig[$key];    }//end getConfigData(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_880, Prints out the gathered config data.\n\n @param array $data The config data to print.\n\n @return void\n, Prints out the gathered config data.,"    public function printConfigData($data)    {        $max  = 0;        $keys = array_keys($data);        foreach ($keys as $key) {            $len = strlen($key);            if (strlen($key) > $max) {                $max = $len;            }        }        if ($max === 0) {            return;        }        $max += 2;        ksort($data);        foreach ($data as $name => $value) {            echo str_pad($name.': ', $max).$value.PHP_EOL;        }    }//end printConfigData()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_DetermineLoadedClassTest_985, Load the test files.\\n\\n @return void\\n, Load the test files.,    public static function setUpBeforeClass()    {        include __DIR__.'/TestFiles/Sub/C.inc';    }//end setUpBeforeClass(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_DetermineLoadedClassTest_987, Test for when class list is out of order.\\n\\n @return void\\n, Test for when class list is out of order.,"    public function testUnordered()    {        $classesBeforeLoad = [            'classes'    => [],            'interfaces' => [],            'traits'     => [],        ];        $classesAfterLoad = [            'classes'    => [                'PHP_CodeSniffer\Tests\Core\Autoloader\A',                'PHP_CodeSniffer\Tests\Core\Autoloader\Sub\C',                'PHP_CodeSniffer\Tests\Core\Autoloader\C',                'PHP_CodeSniffer\Tests\Core\Autoloader\B',            ],            'interfaces' => [],            'traits'     => [],        ];        $className = \PHP_CodeSniffer\Autoload::determineLoadedClass($classesBeforeLoad, $classesAfterLoad);        $this->assertEquals('PHP_CodeSniffer\Tests\Core\Autoloader\Sub\C', $className);        $classesAfterLoad = [            'classes'    => [                'PHP_CodeSniffer\Tests\Core\Autoloader\A',                'PHP_CodeSniffer\Tests\Core\Autoloader\C',                'PHP_CodeSniffer\Tests\Core\Autoloader\Sub\C',                'PHP_CodeSniffer\Tests\Core\Autoloader\B',            ],            'interfaces' => [],            'traits'     => [],        ];        $className = \PHP_CodeSniffer\Autoload::determineLoadedClass($classesBeforeLoad, $classesAfterLoad);        $this->assertEquals('PHP_CodeSniffer\Tests\Core\Autoloader\Sub\C', $className);        $classesAfterLoad = [            'classes'    => [                'PHP_CodeSniffer\Tests\Core\Autoloader\Sub\C',                'PHP_CodeSniffer\Tests\Core\Autoloader\A',                'PHP_CodeSniffer\Tests\Core\Autoloader\C',                'PHP_CodeSniffer\Tests\Core\Autoloader\B',            ],            'interfaces' => [],            'traits'     => [],        ];        $className = \PHP_CodeSniffer\Autoload::determineLoadedClass($classesBeforeLoad, $classesAfterLoad);        $this->assertEquals('PHP_CodeSniffer\Tests\Core\Autoloader\Sub\C', $className);    }//end testUnordered()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_961, Data provider.\n\n @see testSuppressError()\n\n @return array\n, Data provider.,"    public function dataSuppressError()    {        return [            'no suppression'                                                           => [                'before'         => '',                'after'          => '',                'expectedErrors' => 1,            ],            // Inline slash comments.            'disable/enable: slash comment'                                            => [                'before' => '// phpcs:disable'.PHP_EOL,                'after'  => '// phpcs:enable',            ],            'disable/enable: multi-line slash comment, tab indented'                   => [                'before' => ""\t"".'// For reasons'.PHP_EOL.""\t"".'// phpcs:disable'.PHP_EOL.""\t"",                'after'  => ""\t"".'// phpcs:enable',            ],            'disable/enable: slash comment, with @'                                    => [                'before' => '// @phpcs:disable'.PHP_EOL,                'after'  => '// @phpcs:enable',            ],            'disable/enable: slash comment, mixed case'                                => [                'before' => '// PHPCS:Disable'.PHP_EOL,                'after'  => '// pHPcs:enabLE',            ],            // Inline hash comments.            'disable/enable: hash comment'                                             => [                'before' => '# phpcs:disable'.PHP_EOL,                'after'  => '# phpcs:enable',            ],            'disable/enable: multi-line hash comment, tab indented'                    => [                'before' => ""\t"".'# For reasons'.PHP_EOL.""\t"".'# phpcs:disable'.PHP_EOL.""\t"",                'after'  => ""\t"".'# phpcs:enable',            ],            'disable/enable: hash comment, with @'                                     => [                'before' => '# @phpcs:disable'.PHP_EOL,                'after'  => '# @phpcs:enable',            ],            'disable/enable: hash comment, mixed case'                                 => [                'before' => '# PHPCS:Disable'.PHP_EOL,                'after'  => '# pHPcs:enabLE',            ],            // Inline star (block) comments.            'disable/enable: star comment'                                             => [                'before' => '/* phpcs:disable */'.PHP_EOL,                'after'  => '/* phpcs:enable */',            ],            'disable/enable: multi-line star comment'                                  => [                'before' => '/*'.PHP_EOL.' phpcs:disable'.PHP_EOL.' */'.PHP_EOL,                'after'  => '/*'.PHP_EOL.' phpcs:enable'.PHP_EOL.' */',            ],            'disable/enable: multi-line star comment, each line starred'               => [                'before' => '/*'.PHP_EOL.' * phpcs:disable'.PHP_EOL.' */'.PHP_EOL,                'after'  => '/*'.PHP_EOL.' * phpcs:enable'.PHP_EOL.' */',            ],            'disable/enable: multi-line star comment, each line starred, tab indented' => [                'before' => ""\t"".'/*'.PHP_EOL.""\t"".' * phpcs:disable'.PHP_EOL.""\t"".' */'.PHP_EOL.""\t"",                'after'  => ""\t"".'/*'.PHP_EOL.' * phpcs:enable'.PHP_EOL.' */',            ],            // Docblock comments.            'disable/enable: single line docblock comment'                             => [                'before' => '/** phpcs:disable */'.PHP_EOL,                'after'  => '/** phpcs:enable */',            ],            // Deprecated syntax.            'old style: slash comment'                                                 => [                'before' => '// @codingStandardsIgnoreStart'.PHP_EOL,                'after'  => '// @codingStandardsIgnoreEnd',            ],            'old style: star comment'                                                  => [                'before' => '/* @codingStandardsIgnoreStart */'.PHP_EOL,                'after'  => '/* @codingStandardsIgnoreEnd */',            ],            'old style: multi-line star comment'                                       => [                'before' => '/*'.PHP_EOL.' @codingStandardsIgnoreStart'.PHP_EOL.' */'.PHP_EOL,                'after'  => '/*'.PHP_EOL.' @codingStandardsIgnoreEnd'.PHP_EOL.' */',            ],            'old style: single line docblock comment'                                  => [                'before' => '/** @codingStandardsIgnoreStart */'.PHP_EOL,                'after'  => '/** @codingStandardsIgnoreEnd */',            ],        ];    }//end dataSuppressError()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_962, Data provider.\\\\n\\\\n @see testSuppressSomeErrors()\\\\n\\\\n @return array\\\\n, Data provider.,"    public function dataSuppressSomeErrors()    {        return [            'no suppression'                               => [                'before'         => '',                'between'        => '',                'expectedErrors' => 2,            ],            // With suppression.            'disable/enable: slash comment'                => [                'before'  => '// phpcs:disable',                'between' => '// phpcs:enable',            ],            'disable/enable: slash comment, with @'        => [                'before'  => '// @phpcs:disable',                'between' => '// @phpcs:enable',            ],            'disable/enable: hash comment'                 => [                'before'  => '# phpcs:disable',                'between' => '# phpcs:enable',            ],            'disable/enable: hash comment, with @'         => [                'before'  => '# @phpcs:disable',                'between' => '# @phpcs:enable',            ],            'disable/enable: single line docblock comment' => [                'before'  => '/** phpcs:disable */',                'between' => '/** phpcs:enable */',            ],            // Deprecated syntax.            'old style: slash comment'                     => [                'before'  => '// @codingStandardsIgnoreStart',                'between' => '// @codingStandardsIgnoreEnd',            ],            'old style: single line docblock comment'      => [                'before'  => '/** @codingStandardsIgnoreStart */',                'between' => '/** @codingStandardsIgnoreEnd */',            ],        ];    }//end dataSuppressSomeErrors()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_964, Data provider.\n\n @see testSuppressLine()\n\n @return array\n, Data provider.,"    public function dataSuppressLine()    {        return [            'no suppression'                             => [                'before'         => '',                'after'          => '',                'expectedErrors' => 2,            ],            // With suppression on line before.            'ignore: line before, slash comment'         => ['before' => '// phpcs:ignore'],            'ignore: line before, slash comment, with @' => ['before' => '// @phpcs:ignore'],            'ignore: line before, hash comment'          => ['before' => '# phpcs:ignore'],            'ignore: line before, hash comment, with @'  => ['before' => '# @phpcs:ignore'],            'ignore: line before, star comment'          => ['before' => '/* phpcs:ignore */'],            'ignore: line before, star comment, with @'  => ['before' => '/* @phpcs:ignore */'],            // With suppression as trailing comment on code line.            'ignore: end of line, slash comment'         => [                'before' => '',                'after'  => ' // phpcs:ignore',            ],            'ignore: end of line, slash comment, with @' => [                'before' => '',                'after'  => ' // @phpcs:ignore',            ],            'ignore: end of line, hash comment'          => [                'before' => '',                'after'  => ' # phpcs:ignore',            ],            'ignore: end of line, hash comment, with @'  => [                'before' => '',                'after'  => ' # @phpcs:ignore',            ],            // Deprecated syntax.            'old style: line before, slash comment'      => ['before' => '// @codingStandardsIgnoreLine'],            'old style: end of line, slash comment'      => [                'before' => '',                'after'  => ' // @codingStandardsIgnoreLine',            ],        ];    }//end dataSuppressLine()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_966, Test suppressing a single error using a single line ignore within a docblock.\\\\n\\\\n @covers PHP_CodeSniffer\\\\\\\\Tokenizers\\\\\\\\Tokenizer::createPositionMap\\\\n\\\\n @return void\\\\n, Test suppressing a single error using a single line ignore within a docblock.,"    public function testSuppressLineWithinDocblock()    {        $config            = new Config();        $config->standards = ['Generic'];        $config->sniffs    = ['Generic.Files.LineLength'];        $ruleset = new Ruleset($config);        // Process with @ suppression on line before inside docblock.        $comment = str_repeat('a ', 50);        $content = <<<EOD<?php/** * Comment here * @phpcs:ignore * $comment */EOD;        $file    = new DummyFile($content, $ruleset, $config);        $file->process();        $this->assertSame(0, $file->getErrorCount());        $this->assertCount(0, $file->getErrors());    }//end testSuppressLineWithinDocblock()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_967, Test that using a single line ignore does not interfere with other suppressions.\n\n @param string $before Annotation to place before the code.\n @param string $after  Annotation to place after the code.\n\n @dataProvider dataNestedSuppressLine\n @covers       PHP_CodeSniffer\\Tokenizers\\Tokenizer::createPositionMap\n\n @return void\n, Test that using a single line ignore does not interfere with other suppressions.,"    public function testNestedSuppressLine($before, $after)    {        static $config, $ruleset;        if (isset($config, $ruleset) === false) {            $config            = new Config();            $config->standards = ['Generic'];            $config->sniffs    = ['Generic.PHP.LowerCaseConstant'];            $ruleset = new Ruleset($config);        }        $content = <<<EOD<?php$before\$var = FALSE;\$var = TRUE;$afterEOD;        $file    = new DummyFile($content, $ruleset, $config);        $file->process();        $this->assertSame(0, $file->getErrorCount());        $this->assertCount(0, $file->getErrors());    }//end testNestedSuppressLine()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_968, Data provider.\\\\n\\\\n @see testNestedSuppressLine()\\\\n\\\\n @return array\\\\n, Data provider.,"    public function dataNestedSuppressLine()    {        return [            // Process with disable/enable suppression and no single line suppression.            'disable/enable: slash comment, no single line suppression'                       => [                'before' => '// phpcs:disable',                'after'  => '// phpcs:enable',            ],            'disable/enable: slash comment, with @, no single line suppression'               => [                'before' => '// @phpcs:disable',                'after'  => '// @phpcs:enable',            ],            'disable/enable: hash comment, no single line suppression'                        => [                'before' => '# phpcs:disable',                'after'  => '# phpcs:enable',            ],            'old style: slash comment, no single line suppression'                            => [                'before' => '// @codingStandardsIgnoreStart',                'after'  => '// @codingStandardsIgnoreEnd',            ],            // Process with line suppression nested within disable/enable suppression.            'disable/enable: slash comment, next line nested single line suppression'         => [                'before' => '// phpcs:disable'.PHP_EOL.'// phpcs:ignore',                'after'  => '// phpcs:enable',            ],            'disable/enable: slash comment, with @, next line nested single line suppression' => [                'before' => '// @phpcs:disable'.PHP_EOL.'// @phpcs:ignore',                'after'  => '// @phpcs:enable',            ],            'disable/enable: hash comment, next line nested single line suppression'          => [                'before' => '# @phpcs:disable'.PHP_EOL.'# @phpcs:ignore',                'after'  => '# @phpcs:enable',            ],            'old style: slash comment, next line nested single line suppression'              => [                'before' => '// @codingStandardsIgnoreStart'.PHP_EOL.'// @codingStandardsIgnoreLine',                'after'  => '// @codingStandardsIgnoreEnd',            ],        ];    }//end dataNestedSuppressLine()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_969, Data provider.\\\\n\\\\n @see testSuppressScope()\\\\n\\\\n @return array\\\\n, Data provider.,"    public function dataSuppressScope()    {        return [            'no suppression'                                       => [                'before'         => '',                'after'          => '',                'expectedErrors' => 1,            ],            // Process with suppression.            'disable/enable: slash comment'                        => [                'before' => '//phpcs:disable',                'after'  => '//phpcs:enable',            ],            'disable/enable: slash comment, with @'                => [                'before' => '//@phpcs:disable',                'after'  => '//@phpcs:enable',            ],            'disable/enable: hash comment'                         => [                'before' => '#phpcs:disable',                'after'  => '#phpcs:enable',            ],            'disable/enable: single line docblock comment'         => [                'before' => '/** phpcs:disable */',                'after'  => '/** phpcs:enable */',            ],            'disable/enable: single line docblock comment, with @' => [                'before' => '/** @phpcs:disable */',                'after'  => '/** @phpcs:enable */',            ],            // Deprecated syntax.            'old style: start/end, slash comment'                  => [                'before' => '//@codingStandardsIgnoreStart',                'after'  => '//@codingStandardsIgnoreEnd',            ],            'old style: start/end, single line docblock comment'   => [                'before' => '/** @codingStandardsIgnoreStart */',                'after'  => '/** @codingStandardsIgnoreEnd */',            ],        ];    }//end dataSuppressScope()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_972, Test re-enabling specific sniffs that have been disabled.\\\\n\\\\n @param string $code             Code pattern to check.\\\\n @param int    $expectedErrors   Number of errors expected.\\\\n @param int    $expectedWarnings Number of warnings expected.\\\\n\\\\n @dataProvider dataEnableSelected\\\\n @covers       PHP_CodeSniffer\\\\\\\\Tokenizers\\\\\\\\Tokenizer::createPositionMap\\\\n\\\\n @return void\\\\n, Test re-enabling specific sniffs that have been disabled.,"    public function testEnableSelected($code, $expectedErrors, $expectedWarnings)    {        static $config, $ruleset;        if (isset($config, $ruleset) === false) {            $config            = new Config();            $config->standards = ['Generic'];            $config->sniffs    = [                'Generic.PHP.LowerCaseConstant',                'Generic.Commenting.Todo',            ];            $ruleset = new Ruleset($config);        }        $content = '<?php '.$code;        $file    = new DummyFile($content, $ruleset, $config);        $file->process();        $this->assertSame($expectedErrors, $file->getErrorCount());        $this->assertCount($expectedErrors, $file->getErrors());        $this->assertSame($expectedWarnings, $file->getWarningCount());        $this->assertCount($expectedWarnings, $file->getWarnings());    }//end testEnableSelected()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_973, Data provider.\\\\n\\\\n @see testEnableSelected()\\\\n\\\\n @return array\\\\n, Data provider.,"    public function dataEnableSelected()    {        return [            'disable/enable: a single sniff'                                                                                => [                'code'             => '                    // phpcs:disable Generic.Commenting.Todo                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic.Commenting.Todo                    //TODO: write some code',                'expectedErrors'   => 1,                'expectedWarnings' => 1,            ],            'disable/enable: multiple sniffs'                                                                               => [                'code'             => '                    // phpcs:disable Generic.Commenting.Todo,Generic.PHP.LowerCaseConstant                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic.Commenting.Todo,Generic.PHP.LowerCaseConstant                    //TODO: write some code                    $var = FALSE;',                'expectedErrors'   => 1,                'expectedWarnings' => 1,            ],            'disable: multiple sniffs; enable: one'                                                                         => [                'code'             => '                    # phpcs:disable Generic.Commenting.Todo,Generic.PHP.LowerCaseConstant                    $var = FALSE;                    //TODO: write some code                    # phpcs:enable Generic.Commenting.Todo                    //TODO: write some code                    $var = FALSE;',                'expectedErrors'   => 0,                'expectedWarnings' => 1,            ],            'disable/enable: complete category'                                                                             => [                'code'             => '                    // phpcs:disable Generic.Commenting                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic.Commenting                    //TODO: write some code',                'expectedErrors'   => 1,                'expectedWarnings' => 1,            ],            'disable/enable: whole standard'                                                                                => [                'code'             => '                    // phpcs:disable Generic                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic                    //TODO: write some code',                'expectedErrors'   => 0,                'expectedWarnings' => 1,            ],            'disable: whole standard; enable: category from the standard'                                                   => [                'code'             => '                    // phpcs:disable Generic                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic.Commenting                    //TODO: write some code',                'expectedErrors'   => 0,                'expectedWarnings' => 1,            ],            'disable: a category; enable: the whole standard containing the category'                                       => [                'code'             => '                    # phpcs:disable Generic.Commenting                    $var = FALSE;                    //TODO: write some code                    # phpcs:enable Generic                    //TODO: write some code',                'expectedErrors'   => 1,                'expectedWarnings' => 1,            ],            'disable: single sniff; enable: the category containing the sniff'                                              => [                'code'             => '                    // phpcs:disable Generic.Commenting.Todo                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic.Commenting                    //TODO: write some code',                'expectedErrors'   => 1,                'expectedWarnings' => 1,            ],            'disable: whole standard; enable: single sniff from the standard'                                               => [                'code'             => '                    // phpcs:disable Generic                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic.Commenting.Todo                    //TODO: write some code',                'expectedErrors'   => 0,                'expectedWarnings' => 1,            ],            'disable: whole standard; enable: single sniff from the standard; disable: that same sniff; enable: everything' => [                'code'             => '                    // phpcs:disable Generic                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic.Commenting.Todo                    //TODO: write some code                    // phpcs:disable Generic.Commenting.Todo                    //TODO: write some code                    // phpcs:enable                    //TODO: write some code',                'expectedErrors'   => 0,                'expectedWarnings' => 2,            ],            'disable: whole standard; enable: single sniff from the standard; enable: other sniff from the standard'        => [                'code'             => '                    // phpcs:disable Generic                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic.Commenting.Todo                    //TODO: write some code                    $var = FALSE;                    // phpcs:enable Generic.PHP.LowerCaseConstant                    //TODO: write some code                    $var = FALSE;',                'expectedErrors'   => 1,                'expectedWarnings' => 2,            ],        ];    }//end dataEnableSelected()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_975, Data provider.\n\n @see testIgnoreSelected()\n\n @return array\n, Data provider.,"    public function dataIgnoreSelected()    {        return [            'no suppression'                              => [                'before'           => '',                'expectedErrors'   => 2,                'expectedWarnings' => 2,            ],            // With suppression.            'ignore: single sniff'                        => [                'before'           => '// phpcs:ignore Generic.Commenting.Todo',                'expectedErrors'   => 2,                'expectedWarnings' => 1,            ],            'ignore: multiple sniffs'                     => [                'before'           => '// phpcs:ignore Generic.Commenting.Todo,Generic.PHP.LowerCaseConstant',                'expectedErrors'   => 1,                'expectedWarnings' => 1,            ],            'disable: single sniff; ignore: single sniff' => [                'before'           => '// phpcs:disable Generic.Commenting.Todo'.PHP_EOL.'// phpcs:ignore Generic.PHP.LowerCaseConstant',                'expectedErrors'   => 1,                'expectedWarnings' => 0,            ],            'ignore: category of sniffs'                  => [                'before'           => '# phpcs:ignore Generic.Commenting',                'expectedErrors'   => 2,                'expectedWarnings' => 1,            ],            'ignore: whole standard'                      => [                'before'           => '// phpcs:ignore Generic',                'expectedErrors'   => 1,                'expectedWarnings' => 1,            ],        ];    }//end dataIgnoreSelected()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ErrorSuppressionTest_977, Data provider.\\n\\n @see testCommenting()\\n\\n @return array\\n, Data provider.,"    public function dataCommenting()    {        return [            'ignore: single sniff'                                                                         => [                'code'             => '                    // phpcs:ignore Generic.Commenting.Todo -- Because reasons                    $var = FALSE; //TODO: write some code                    $var = FALSE; //TODO: write some code',                'expectedErrors'   => 2,                'expectedWarnings' => 1,            ],            'disable: single sniff; enable: same sniff - test whitespace handling around reason delimiter' => [                'code'             => '                    // phpcs:disable Generic.Commenting.Todo --Because reasons                    $var = FALSE;                    //TODO: write some code                    // phpcs:enable Generic.Commenting.Todo   --  Because reasons                    //TODO: write some code',                'expectedErrors'   => 1,                'expectedWarnings' => 1,            ],            'disable: single sniff, multi-line comment'                                                    => [                'code'             => '                    /*                        Disable some checks                        phpcs:disable Generic.Commenting.Todo                    */                    $var = FALSE;                    //TODO: write some code',                'expectedErrors'   => 1,                'expectedWarnings' => 0,            ],            'ignore: single sniff, multi-line slash comment'                                               => [                'code'             => '                    // Turn off a check for the next line of code.                    // phpcs:ignore Generic.Commenting.Todo                    $var = FALSE; //TODO: write some code                    $var = FALSE; //TODO: write some code',                'expectedErrors'   => 2,                'expectedWarnings' => 1,            ],            'enable before disable, sniff not in standard'                                                 => [                'code'             => '                    // phpcs:enable Generic.PHP.NoSilencedErrors -- Because reasons                    $var = @delete( $filename );                    ',                'expectedErrors'   => 0,                'expectedWarnings' => 0,            ],        ];    }//end dataCommenting()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_FileList_955, Retrieve the filtered file list as an array.\\\\n\\\\n @return array\\\\n, Retrieve the filtered file list as an array.,"    public function getList()    {        $fileList = [];        foreach ($this->fileIterator as $file) {            $fileList[] = str_replace($this->rootPath, '', $file);        }        return $fileList;    }//end getList()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_923, Tokenizes the file and prepares it for the test run.\\\\n\\\\n @return void\\\\n, Tokenizes the file and prepares it for the test run.,"    public function parse()    {        if (empty($this->tokens) === false) {            // File has already been parsed.            return;        }        try {            $tokenizerClass  = 'PHP_CodeSniffer\Tokenizers\\'.$this->tokenizerType;            $this->tokenizer = new $tokenizerClass($this->content, $this->config, $this->eolChar);            $this->tokens    = $this->tokenizer->getTokens();        } catch (TokenizerException $e) {            $this->ignored = true;            $this->addWarning($e->getMessage(), null, 'Internal.Tokenizer.Exception');            if (PHP_CODESNIFFER_VERBOSITY > 0) {                echo ""[$this->tokenizerType => tokenizer error]... "";                if (PHP_CODESNIFFER_VERBOSITY > 1) {                    echo PHP_EOL;                }            }            return;        }        $this->numTokens = count($this->tokens);        // Check for mixed line endings as these can cause tokenizer errors and we        // should let the user know that the results they get may be incorrect.        // This is done by removing all backslashes, removing the newline char we        // detected, then converting newlines chars into text. If any backslashes        // are left at the end, we have additional newline chars in use.        $contents = str_replace('\\', '', $this->content);        $contents = str_replace($this->eolChar, '', $contents);        $contents = str_replace(""\n"", '\n', $contents);        $contents = str_replace(""\r"", '\r', $contents);        if (strpos($contents, '\\') !== false) {            $error = 'File has mixed line endings; this may cause incorrect results';            $this->addWarningOnLine($error, 1, 'Internal.LineEndings.Mixed');        }        if (PHP_CODESNIFFER_VERBOSITY > 0) {            if ($this->numTokens === 0) {                $numLines = 0;            } else {                $numLines = $this->tokens[($this->numTokens - 1)]['line'];            }            echo ""[$this->tokenizerType => $this->numTokens tokens in $numLines lines]... "";            if (PHP_CODESNIFFER_VERBOSITY > 1) {                echo PHP_EOL;            }        }    }//end parse()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_924, Returns the token stack for this file.\n\n @return array\n, Returns the token stack for this file.,    public function getTokens()    {        return $this->tokens;    }//end getTokens(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_932, Adds an error to the error stack.\\n\\n @param boolean $error    Is this an error message?\\n @param string  $message  The text of the message.\\n @param int     $line     The line on which the message occurred.\\n @param int     $column   The column at which the message occurred.\\n @param string  $code     A violation code unique to the sniff message.\\n @param array   $data     Replacements for the message.\\n @param int     $severity The severity level for this message. A value of 0\\n                          will be converted into the default severity level.\\n @param boolean $fixable  Can the problem be fixed by the sniff?\\n\\n @return boolean\\n, Adds an error to the error stack.,"    protected function addMessage($error, $message, $line, $column, $code, $data, $severity, $fixable)    {        // Check if this line is ignoring all message codes.        if (isset($this->tokenizer->ignoredLines[$line]['.all']) === true) {            return false;        }        // Work out which sniff generated the message.        $parts = explode('.', $code);        if ($parts[0] === 'Internal') {            // An internal message.            $listenerCode = Util\Common::getSniffCode($this->activeListener);            $sniffCode    = $code;            $checkCodes   = [$sniffCode];        } else {            if ($parts[0] !== $code) {                // The full message code has been passed in.                $sniffCode    = $code;                $listenerCode = substr($sniffCode, 0, strrpos($sniffCode, '.'));            } else {                $listenerCode = Util\Common::getSniffCode($this->activeListener);                $sniffCode    = $listenerCode.'.'.$code;                $parts        = explode('.', $sniffCode);            }            $checkCodes = [                $sniffCode,                $parts[0].'.'.$parts[1].'.'.$parts[2],                $parts[0].'.'.$parts[1],                $parts[0],            ];        }//end if        if (isset($this->tokenizer->ignoredLines[$line]) === true) {            // Check if this line is ignoring this specific message.            $ignored = false;            foreach ($checkCodes as $checkCode) {                if (isset($this->tokenizer->ignoredLines[$line][$checkCode]) === true) {                    $ignored = true;                    break;                }            }            // If it is ignored, make sure it's not whitelisted.            if ($ignored === true                && isset($this->tokenizer->ignoredLines[$line]['.except']) === true            ) {                foreach ($checkCodes as $checkCode) {                    if (isset($this->tokenizer->ignoredLines[$line]['.except'][$checkCode]) === true) {                        $ignored = false;                        break;                    }                }            }            if ($ignored === true) {                return false;            }        }//end if        $includeAll = true;        if ($this->configCache['cache'] === false            || $this->configCache['recordErrors'] === false        ) {            $includeAll = false;        }        // Filter out any messages for sniffs that shouldn't have run        // due to the use of the --sniffs command line argument.        if ($includeAll === false            && ((empty($this->configCache['sniffs']) === false            && in_array(strtolower($listenerCode), $this->configCache['sniffs'], true) === false)            || (empty($this->configCache['exclude']) === false            && in_array(strtolower($listenerCode), $this->configCache['exclude'], true) === true))        ) {            return false;        }        // If we know this sniff code is being ignored for this file, return early.        foreach ($checkCodes as $checkCode) {            if (isset($this->ignoredCodes[$checkCode]) === true) {                return false;            }        }        $oppositeType = 'warning';        if ($error === false) {            $oppositeType = 'error';        }        foreach ($checkCodes as $checkCode) {            // Make sure this message type has not been set to the opposite message type.            if (isset($this->ruleset->ruleset[$checkCode]['type']) === true                && $this->ruleset->ruleset[$checkCode]['type'] === $oppositeType            ) {                $error = !$error;                break;            }        }        if ($error === true) {            $configSeverity = $this->configCache['errorSeverity'];            $messageCount   = &$this->errorCount;            $messages       = &$this->errors;        } else {            $configSeverity = $this->configCache['warningSeverity'];            $messageCount   = &$this->warningCount;            $messages       = &$this->warnings;        }        if ($includeAll === false && $configSeverity === 0) {            // Don't bother doing any processing as these messages are just going to            // be hidden in the reports anyway.            return false;        }        if ($severity === 0) {            $severity = 5;        }        foreach ($checkCodes as $checkCode) {            // Make sure we are interested in this severity level.            if (isset($this->ruleset->ruleset[$checkCode]['severity']) === true) {                $severity = $this->ruleset->ruleset[$checkCode]['severity'];                break;            }        }        if ($includeAll === false && $configSeverity > $severity) {            return false;        }        // Make sure we are not ignoring this file.        $included = null;        if (trim($this->path, '\'""') === 'STDIN') {            $included = true;        } else {            foreach ($checkCodes as $checkCode) {                $patterns = null;                if (isset($this->configCache['includePatterns'][$checkCode]) === true) {                    $patterns  = $this->configCache['includePatterns'][$checkCode];                    $excluding = false;                } else if (isset($this->configCache['ignorePatterns'][$checkCode]) === true) {                    $patterns  = $this->configCache['ignorePatterns'][$checkCode];                    $excluding = true;                }                if ($patterns === null) {                    continue;                }                foreach ($patterns as $pattern => $type) {                    // While there is support for a type of each pattern                    // (absolute or relative) we don't actually support it here.                    $replacements = [                        '\\,' => ',',                        '*'   => '.*',                    ];                    // We assume a / directory separator, as do the exclude rules                    // most developers write, so we need a special case for any system                    // that is different.                    if (DIRECTORY_SEPARATOR === '\\') {                        $replacements['/'] = '\\\\';                    }                    $pattern = '`'.strtr($pattern, $replacements).'`i';                    $matched = preg_match($pattern, $this->path);                    if ($matched === 0) {                        if ($excluding === false && $included === null) {                            // This file path is not being included.                            $included = false;                        }                        continue;                    }                    if ($excluding === true) {                        // This file path is being excluded.                        $this->ignoredCodes[$checkCode] = true;                        return false;                    }                    // This file path is being included.                    $included = true;                    break;                }//end foreach            }//end foreach        }//end if        if ($included === false) {            // There were include rules set, but this file            // path didn't match any of them.            return false;        }        $messageCount++;        if ($fixable === true) {            $this->fixableCount++;        }        if ($this->configCache['recordErrors'] === false            && $includeAll === false        ) {            return true;        }        // See if there is a custom error message format to use.        // But don't do this if we are replaying errors because replayed        // errors have already used the custom format and have had their        // data replaced.        if ($this->replayingErrors === false            && isset($this->ruleset->ruleset[$sniffCode]['message']) === true        ) {            $message = $this->ruleset->ruleset[$sniffCode]['message'];        }        if (empty($data) === false) {            $message = vsprintf($message, $data);        }        if (isset($messages[$line]) === false) {            $messages[$line] = [];        }        if (isset($messages[$line][$column]) === false) {            $messages[$line][$column] = [];        }        $messages[$line][$column][] = [            'message'  => $message,            'source'   => $sniffCode,            'listener' => $this->activeListener,            'severity' => $severity,            'fixable'  => $fixable,        ];        if (PHP_CODESNIFFER_VERBOSITY > 1            && $this->fixer->enabled === true            && $fixable === true        ) {            @ob_end_clean();            echo ""\tE: [Line $line] $message ($sniffCode)"".PHP_EOL;            ob_start();        }        return true;    }//end addMessage()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_933, Record a metric about the file being examined.\n\n @param int    $stackPtr The stack position where the metric was recorded.\n @param string $metric   The name of the metric being recorded.\n @param string $value    The value of the metric being recorded.\n\n @return boolean\n, Record a metric about the file being examined.,"    public function recordMetric($stackPtr, $metric, $value)    {        if (isset($this->metrics[$metric]) === false) {            $this->metrics[$metric] = ['values' => [$value => 1]];            $this->metricTokens[$metric][$stackPtr] = true;        } else if (isset($this->metricTokens[$metric][$stackPtr]) === false) {            $this->metricTokens[$metric][$stackPtr] = true;            if (isset($this->metrics[$metric]['values'][$value]) === false) {                $this->metrics[$metric]['values'][$value] = 1;            } else {                $this->metrics[$metric]['values'][$value]++;            }        }        return true;    }//end recordMetric()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_934, Returns the number of errors raised.\\\\n\\\\n @return int\\\\n, Returns the number of errors raised.,    public function getErrorCount()    {        return $this->errorCount;    }//end getErrorCount(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_937, Returns the number of fixed errors/warnings.\\n\\n @return int\\n, Returns the number of fixed errors/warnings.,    public function getFixedCount()    {        return $this->fixedCount;    }//end getFixedCount(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_940, Returns the warnings raised from processing this file.\\\\n\\\\n @return array\\\\n, Returns the warnings raised from processing this file.,    public function getWarnings()    {        return $this->warnings;    }//end getWarnings(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_944," Returns the method parameters for the specified function token.\\n\\n Also supports passing in a USE token for a closure use group.\\n\\n Each parameter is in the following format:\\n\\n <code>\\n   0 => array(\\n         'name'                => '$var',  // The variable name.\\n         'token'               => integer, // The stack pointer to the variable name.\\n         'content'             => string,  // The full content of the variable definition.\\n         'pass_by_reference'   => boolean, // Is the variable passed by reference?\\n         'reference_token'     => integer, // The stack pointer to the reference operator\\n                                           // or FALSE if the param is not passed by reference.\\n         'variable_length'     => boolean, // Is the param of variable length through use of `...` ?\\n         'variadic_token'      => integer, // The stack pointer to the ... operator\\n                                           // or FALSE if the param is not variable length.\\n         'type_hint'           => string,  // The type hint for the variable.\\n         'type_hint_token'     => integer, // The stack pointer to the start of the type hint\\n                                           // or FALSE if there is no type hint.\\n         'type_hint_end_token' => integer, // The stack pointer to the end of the type hint\\n                                           // or FALSE if there is no type hint.\\n         'nullable_type'       => boolean, // TRUE if the type is preceded by the nullability\\n                                           // operator.\\n         'comma_token'         => integer, // The stack pointer to the comma after the param\\n                                           // or FALSE if this is the last param.\\n        )\\n </code>\\n\\n Parameters with default values have additional array indexes of:\\n         'default'             => string,  // The full content of the default value.\\n         'default_token'       => integer, // The stack pointer to the start of the default value.\\n         'default_equal_token' => integer, // The stack pointer to the equals sign.\\n\\n Parameters declared using PHP 8 constructor property promotion, have these additional array indexes:\\n         'property_visibility' => string,  // The property visibility as declared.\\n         'visibility_token'    => integer, // The stack pointer to the visibility modifier token.\\n\\n @param int $stackPtr The position in the stack of the function token\\n                      to acquire the parameters for.\\n\\n @return array\\n @throws \\\\PHP_CodeSniffer\\\\Exceptions\\\\RuntimeException If the specified $stackPtr is not of\\n                                                      type T_FUNCTION, T_CLOSURE, T_USE,\\n                                                      or T_FN.\\n", Returns the method parameters for the specified function token.,"    public function getMethodParameters($stackPtr)    {        if ($this->tokens[$stackPtr]['code'] !== T_FUNCTION            && $this->tokens[$stackPtr]['code'] !== T_CLOSURE            && $this->tokens[$stackPtr]['code'] !== T_USE            && $this->tokens[$stackPtr]['code'] !== T_FN        ) {            throw new RuntimeException('$stackPtr must be of type T_FUNCTION or T_CLOSURE or T_USE or T_FN');        }        if ($this->tokens[$stackPtr]['code'] === T_USE) {            $opener = $this->findNext(T_OPEN_PARENTHESIS, ($stackPtr + 1));            if ($opener === false || isset($this->tokens[$opener]['parenthesis_owner']) === true) {                throw new RuntimeException('$stackPtr was not a valid T_USE');            }        } else {            if (isset($this->tokens[$stackPtr]['parenthesis_opener']) === false) {                // Live coding or syntax error, so no params to find.                return [];            }            $opener = $this->tokens[$stackPtr]['parenthesis_opener'];        }        if (isset($this->tokens[$opener]['parenthesis_closer']) === false) {            // Live coding or syntax error, so no params to find.            return [];        }        $closer = $this->tokens[$opener]['parenthesis_closer'];        $vars            = [];        $currVar         = null;        $paramStart      = ($opener + 1);        $defaultStart    = null;        $equalToken      = null;        $paramCount      = 0;        $passByReference = false;        $referenceToken  = false;        $variableLength  = false;        $variadicToken   = false;        $typeHint        = '';        $typeHintToken   = false;        $typeHintEndToken = false;        $nullableType     = false;        $visibilityToken  = null;        for ($i = $paramStart; $i <= $closer; $i++) {            // Check to see if this token has a parenthesis or bracket opener. If it does            // it's likely to be an array which might have arguments in it. This            // could cause problems in our parsing below, so lets just skip to the            // end of it.            if (isset($this->tokens[$i]['parenthesis_opener']) === true) {                // Don't do this if it's the close parenthesis for the method.                if ($i !== $this->tokens[$i]['parenthesis_closer']) {                    $i = ($this->tokens[$i]['parenthesis_closer'] + 1);                }            }            if (isset($this->tokens[$i]['bracket_opener']) === true) {                // Don't do this if it's the close parenthesis for the method.                if ($i !== $this->tokens[$i]['bracket_closer']) {                    $i = ($this->tokens[$i]['bracket_closer'] + 1);                }            }            switch ($this->tokens[$i]['code']) {            case T_BITWISE_AND:                if ($defaultStart === null) {                    $passByReference = true;                    $referenceToken  = $i;                }                break;            case T_VARIABLE:                $currVar = $i;                break;            case T_ELLIPSIS:                $variableLength = true;                $variadicToken  = $i;                break;            case T_CALLABLE:                if ($typeHintToken === false) {                    $typeHintToken = $i;                }                $typeHint        .= $this->tokens[$i]['content'];                $typeHintEndToken = $i;                break;            case T_SELF:            case T_PARENT:            case T_STATIC:                // Self and parent are valid, static invalid, but was probably intended as type hint.                if (isset($defaultStart) === false) {                    if ($typeHintToken === false) {                        $typeHintToken = $i;                    }                    $typeHint        .= $this->tokens[$i]['content'];                    $typeHintEndToken = $i;                }                break;            case T_STRING:                // This is a string, so it may be a type hint, but it could                // also be a constant used as a default value.                $prevComma = false;                for ($t = $i; $t >= $opener; $t--) {                    if ($this->tokens[$t]['code'] === T_COMMA) {                        $prevComma = $t;                        break;                    }                }                if ($prevComma !== false) {                    $nextEquals = false;                    for ($t = $prevComma; $t < $i; $t++) {                        if ($this->tokens[$t]['code'] === T_EQUAL) {                            $nextEquals = $t;                            break;                        }                    }                    if ($nextEquals !== false) {                        break;                    }                }                if ($defaultStart === null) {                    if ($typeHintToken === false) {                        $typeHintToken = $i;                    }                    $typeHint        .= $this->tokens[$i]['content'];                    $typeHintEndToken = $i;                }                break;            case T_NAMESPACE:            case T_NS_SEPARATOR:            case T_TYPE_UNION:            case T_FALSE:            case T_NULL:                // Part of a type hint or default value.                if ($defaultStart === null) {                    if ($typeHintToken === false) {                        $typeHintToken = $i;                    }                    $typeHint        .= $this->tokens[$i]['content'];                    $typeHintEndToken = $i;                }                break;            case T_NULLABLE:                if ($defaultStart === null) {                    $nullableType     = true;                    $typeHint        .= $this->tokens[$i]['content'];                    $typeHintEndToken = $i;                }                break;            case T_PUBLIC:            case T_PROTECTED:            case T_PRIVATE:                if ($defaultStart === null) {                    $visibilityToken = $i;                }                break;            case T_CLOSE_PARENTHESIS:            case T_COMMA:                // If it's null, then there must be no parameters for this                // method.                if ($currVar === null) {                    continue 2;                }                $vars[$paramCount]            = [];                $vars[$paramCount]['token']   = $currVar;                $vars[$paramCount]['name']    = $this->tokens[$currVar]['content'];                $vars[$paramCount]['content'] = trim($this->getTokensAsString($paramStart, ($i - $paramStart)));                if ($defaultStart !== null) {                    $vars[$paramCount]['default']       = trim($this->getTokensAsString($defaultStart, ($i - $defaultStart)));                    $vars[$paramCount]['default_token'] = $defaultStart;                    $vars[$paramCount]['default_equal_token'] = $equalToken;                }                $vars[$paramCount]['pass_by_reference']   = $passByReference;                $vars[$paramCount]['reference_token']     = $referenceToken;                $vars[$paramCount]['variable_length']     = $variableLength;                $vars[$paramCount]['variadic_token']      = $variadicToken;                $vars[$paramCount]['type_hint']           = $typeHint;                $vars[$paramCount]['type_hint_token']     = $typeHintToken;                $vars[$paramCount]['type_hint_end_token'] = $typeHintEndToken;                $vars[$paramCount]['nullable_type']       = $nullableType;                if ($visibilityToken !== null) {                    $vars[$paramCount]['property_visibility'] = $this->tokens[$visibilityToken]['content'];                    $vars[$paramCount]['visibility_token']    = $visibilityToken;                }                if ($this->tokens[$i]['code'] === T_COMMA) {                    $vars[$paramCount]['comma_token'] = $i;                } else {                    $vars[$paramCount]['comma_token'] = false;                }                // Reset the vars, as we are about to process the next parameter.                $currVar          = null;                $paramStart       = ($i + 1);                $defaultStart     = null;                $equalToken       = null;                $passByReference  = false;                $referenceToken   = false;                $variableLength   = false;                $variadicToken    = false;                $typeHint         = '';                $typeHintToken    = false;                $typeHintEndToken = false;                $nullableType     = false;                $visibilityToken  = null;                $paramCount++;                break;            case T_EQUAL:                $defaultStart = $this->findNext(Util\Tokens::$emptyTokens, ($i + 1), null, true);                $equalToken   = $i;                break;            }//end switch        }//end for        return $vars;    }//end getMethodParameters()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_945," Returns the visibility and implementation properties of a method.\\\\n\\\\n The format of the return value is:\\\\n <code>\\\\n   array(\\\\n    'scope'                 => 'public', // Public, private, or protected\\\\n    'scope_specified'       => true,     // TRUE if the scope keyword was found.\\\\n    'return_type'           => '',       // The return type of the method.\\\\n    'return_type_token'     => integer,  // The stack pointer to the start of the return type\\\\n                                         // or FALSE if there is no return type.\\\\n    'return_type_end_token' => integer,  // The stack pointer to the end of the return type\\\\n                                         // or FALSE if there is no return type.\\\\n    'nullable_return_type'  => false,    // TRUE if the return type is preceded by the\\\\n                                         // nullability operator.\\\\n    'is_abstract'           => false,    // TRUE if the abstract keyword was found.\\\\n    'is_final'              => false,    // TRUE if the final keyword was found.\\\\n    'is_static'             => false,    // TRUE if the static keyword was found.\\\\n    'has_body'              => false,    // TRUE if the method has a body\\\\n   );\\\\n </code>\\\\n\\\\n @param int $stackPtr The position in the stack of the function token to\\\\n                      acquire the properties for.\\\\n\\\\n @return array\\\\n @throws \\\\\\\\PHP_CodeSniffer\\\\\\\\Exceptions\\\\\\\\RuntimeException If the specified position is not a\\\\n                                                      T_FUNCTION, T_CLOSURE, or T_FN token.\\\\n", Returns the visibility and implementation properties of a method.,"    public function getMethodProperties($stackPtr)    {        if ($this->tokens[$stackPtr]['code'] !== T_FUNCTION            && $this->tokens[$stackPtr]['code'] !== T_CLOSURE            && $this->tokens[$stackPtr]['code'] !== T_FN        ) {            throw new RuntimeException('$stackPtr must be of type T_FUNCTION or T_CLOSURE or T_FN');        }        if ($this->tokens[$stackPtr]['code'] === T_FUNCTION) {            $valid = [                T_PUBLIC      => T_PUBLIC,                T_PRIVATE     => T_PRIVATE,                T_PROTECTED   => T_PROTECTED,                T_STATIC      => T_STATIC,                T_FINAL       => T_FINAL,                T_ABSTRACT    => T_ABSTRACT,                T_WHITESPACE  => T_WHITESPACE,                T_COMMENT     => T_COMMENT,                T_DOC_COMMENT => T_DOC_COMMENT,            ];        } else {            $valid = [                T_STATIC      => T_STATIC,                T_WHITESPACE  => T_WHITESPACE,                T_COMMENT     => T_COMMENT,                T_DOC_COMMENT => T_DOC_COMMENT,            ];        }        $scope          = 'public';        $scopeSpecified = false;        $isAbstract     = false;        $isFinal        = false;        $isStatic       = false;        for ($i = ($stackPtr - 1); $i > 0; $i--) {            if (isset($valid[$this->tokens[$i]['code']]) === false) {                break;            }            switch ($this->tokens[$i]['code']) {            case T_PUBLIC:                $scope          = 'public';                $scopeSpecified = true;                break;            case T_PRIVATE:                $scope          = 'private';                $scopeSpecified = true;                break;            case T_PROTECTED:                $scope          = 'protected';                $scopeSpecified = true;                break;            case T_ABSTRACT:                $isAbstract = true;                break;            case T_FINAL:                $isFinal = true;                break;            case T_STATIC:                $isStatic = true;                break;            }//end switch        }//end for        $returnType         = '';        $returnTypeToken    = false;        $returnTypeEndToken = false;        $nullableReturnType = false;        $hasBody            = true;        if (isset($this->tokens[$stackPtr]['parenthesis_closer']) === true) {            $scopeOpener = null;            if (isset($this->tokens[$stackPtr]['scope_opener']) === true) {                $scopeOpener = $this->tokens[$stackPtr]['scope_opener'];            }            $valid = [                T_STRING       => T_STRING,                T_CALLABLE     => T_CALLABLE,                T_SELF         => T_SELF,                T_PARENT       => T_PARENT,                T_STATIC       => T_STATIC,                T_FALSE        => T_FALSE,                T_NULL         => T_NULL,                T_NAMESPACE    => T_NAMESPACE,                T_NS_SEPARATOR => T_NS_SEPARATOR,                T_TYPE_UNION   => T_TYPE_UNION,            ];            for ($i = $this->tokens[$stackPtr]['parenthesis_closer']; $i < $this->numTokens; $i++) {                if (($scopeOpener === null && $this->tokens[$i]['code'] === T_SEMICOLON)                    || ($scopeOpener !== null && $i === $scopeOpener)                ) {                    // End of function definition.                    break;                }                if ($this->tokens[$i]['code'] === T_NULLABLE) {                    $nullableReturnType = true;                }                if (isset($valid[$this->tokens[$i]['code']]) === true) {                    if ($returnTypeToken === false) {                        $returnTypeToken = $i;                    }                    $returnType        .= $this->tokens[$i]['content'];                    $returnTypeEndToken = $i;                }            }//end for            if ($this->tokens[$stackPtr]['code'] === T_FN) {                $bodyToken = T_FN_ARROW;            } else {                $bodyToken = T_OPEN_CURLY_BRACKET;            }            $end     = $this->findNext([$bodyToken, T_SEMICOLON], $this->tokens[$stackPtr]['parenthesis_closer']);            $hasBody = $this->tokens[$end]['code'] === $bodyToken;        }//end if        if ($returnType !== '' && $nullableReturnType === true) {            $returnType = '?'.$returnType;        }        return [            'scope'                 => $scope,            'scope_specified'       => $scopeSpecified,            'return_type'           => $returnType,            'return_type_token'     => $returnTypeToken,            'return_type_end_token' => $returnTypeEndToken,            'nullable_return_type'  => $nullableReturnType,            'is_abstract'           => $isAbstract,            'is_final'              => $isFinal,            'is_static'             => $isStatic,            'has_body'              => $hasBody,        ];    }//end getMethodProperties()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_946," Returns the visibility and implementation properties of a class member var.\\\\n\\\\n The format of the return value is:\\\\n\\\\n <code>\\\\n   array(\\\\n    'scope'           => string,  // Public, private, or protected.\\\\n    'scope_specified' => boolean, // TRUE if the scope was explicitly specified.\\\\n    'is_static'       => boolean, // TRUE if the static keyword was found.\\\\n    'type'            => string,  // The type of the var (empty if no type specified).\\\\n    'type_token'      => integer, // The stack pointer to the start of the type\\\\n                                  // or FALSE if there is no type.\\\\n    'type_end_token'  => integer, // The stack pointer to the end of the type\\\\n                                  // or FALSE if there is no type.\\\\n    'nullable_type'   => boolean, // TRUE if the type is preceded by the nullability\\\\n                                  // operator.\\\\n   );\\\\n </code>\\\\n\\\\n @param int $stackPtr The position in the stack of the T_VARIABLE token to\\\\n                      acquire the properties for.\\\\n\\\\n @return array\\\\n @throws \\\\\\\\PHP_CodeSniffer\\\\\\\\Exceptions\\\\\\\\RuntimeException If the specified position is not a\\\\n                                                      T_VARIABLE token, or if the position is not\\\\n                                                      a class member variable.\\\\n", Returns the visibility and implementation properties of a class member var.,"    public function getMemberProperties($stackPtr)    {        if ($this->tokens[$stackPtr]['code'] !== T_VARIABLE) {            throw new RuntimeException('$stackPtr must be of type T_VARIABLE');        }        $conditions = array_keys($this->tokens[$stackPtr]['conditions']);        $ptr        = array_pop($conditions);        if (isset($this->tokens[$ptr]) === false            || ($this->tokens[$ptr]['code'] !== T_CLASS            && $this->tokens[$ptr]['code'] !== T_ANON_CLASS            && $this->tokens[$ptr]['code'] !== T_TRAIT)        ) {            if (isset($this->tokens[$ptr]) === true                && $this->tokens[$ptr]['code'] === T_INTERFACE            ) {                // T_VARIABLEs in interfaces can actually be method arguments                // but they wont be seen as being inside the method because there                // are no scope openers and closers for abstract methods. If it is in                // parentheses, we can be pretty sure it is a method argument.                if (isset($this->tokens[$stackPtr]['nested_parenthesis']) === false                    || empty($this->tokens[$stackPtr]['nested_parenthesis']) === true                ) {                    $error = 'Possible parse error: interfaces may not include member vars';                    $this->addWarning($error, $stackPtr, 'Internal.ParseError.InterfaceHasMemberVar');                    return [];                }            } else {                throw new RuntimeException('$stackPtr is not a class member var');            }        }        // Make sure it's not a method parameter.        if (empty($this->tokens[$stackPtr]['nested_parenthesis']) === false) {            $parenthesis = array_keys($this->tokens[$stackPtr]['nested_parenthesis']);            $deepestOpen = array_pop($parenthesis);            if ($deepestOpen > $ptr                && isset($this->tokens[$deepestOpen]['parenthesis_owner']) === true                && $this->tokens[$this->tokens[$deepestOpen]['parenthesis_owner']]['code'] === T_FUNCTION            ) {                throw new RuntimeException('$stackPtr is not a class member var');            }        }        $valid = [            T_PUBLIC    => T_PUBLIC,            T_PRIVATE   => T_PRIVATE,            T_PROTECTED => T_PROTECTED,            T_STATIC    => T_STATIC,            T_VAR       => T_VAR,        ];        $valid += Util\Tokens::$emptyTokens;        $scope          = 'public';        $scopeSpecified = false;        $isStatic       = false;        $startOfStatement = $this->findPrevious(            [                T_SEMICOLON,                T_OPEN_CURLY_BRACKET,                T_CLOSE_CURLY_BRACKET,                T_ATTRIBUTE_END,            ],            ($stackPtr - 1)        );        for ($i = ($startOfStatement + 1); $i < $stackPtr; $i++) {            if (isset($valid[$this->tokens[$i]['code']]) === false) {                break;            }            switch ($this->tokens[$i]['code']) {            case T_PUBLIC:                $scope          = 'public';                $scopeSpecified = true;                break;            case T_PRIVATE:                $scope          = 'private';                $scopeSpecified = true;                break;            case T_PROTECTED:                $scope          = 'protected';                $scopeSpecified = true;                break;            case T_STATIC:                $isStatic = true;                break;            }        }//end for        $type         = '';        $typeToken    = false;        $typeEndToken = false;        $nullableType = false;        if ($i < $stackPtr) {            // We've found a type.            $valid = [                T_STRING       => T_STRING,                T_CALLABLE     => T_CALLABLE,                T_SELF         => T_SELF,                T_PARENT       => T_PARENT,                T_FALSE        => T_FALSE,                T_NULL         => T_NULL,                T_NAMESPACE    => T_NAMESPACE,                T_NS_SEPARATOR => T_NS_SEPARATOR,                T_TYPE_UNION   => T_TYPE_UNION,            ];            for ($i; $i < $stackPtr; $i++) {                if ($this->tokens[$i]['code'] === T_VARIABLE) {                    // Hit another variable in a group definition.                    break;                }                if ($this->tokens[$i]['code'] === T_NULLABLE) {                    $nullableType = true;                }                if (isset($valid[$this->tokens[$i]['code']]) === true) {                    $typeEndToken = $i;                    if ($typeToken === false) {                        $typeToken = $i;                    }                    $type .= $this->tokens[$i]['content'];                }            }            if ($type !== '' && $nullableType === true) {                $type = '?'.$type;            }        }//end if        return [            'scope'           => $scope,            'scope_specified' => $scopeSpecified,            'is_static'       => $isStatic,            'type'            => $type,            'type_token'      => $typeToken,            'type_end_token'  => $typeEndToken,            'nullable_type'   => $nullableType,        ];    }//end getMemberProperties()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_947," Returns the visibility and implementation properties of a class.\\n\\n The format of the return value is:\\n <code>\\n   array(\\n    'is_abstract' => false, // true if the abstract keyword was found.\\n    'is_final'    => false, // true if the final keyword was found.\\n   );\\n </code>\\n\\n @param int $stackPtr The position in the stack of the T_CLASS token to\\n                      acquire the properties for.\\n\\n @return array\\n @throws \\\\PHP_CodeSniffer\\\\Exceptions\\\\RuntimeException If the specified position is not a\\n                                                      T_CLASS token.\\n", Returns the visibility and implementation properties of a class.,"    public function getClassProperties($stackPtr)    {        if ($this->tokens[$stackPtr]['code'] !== T_CLASS) {            throw new RuntimeException('$stackPtr must be of type T_CLASS');        }        $valid = [            T_FINAL       => T_FINAL,            T_ABSTRACT    => T_ABSTRACT,            T_WHITESPACE  => T_WHITESPACE,            T_COMMENT     => T_COMMENT,            T_DOC_COMMENT => T_DOC_COMMENT,        ];        $isAbstract = false;        $isFinal    = false;        for ($i = ($stackPtr - 1); $i > 0; $i--) {            if (isset($valid[$this->tokens[$i]['code']]) === false) {                break;            }            switch ($this->tokens[$i]['code']) {            case T_ABSTRACT:                $isAbstract = true;                break;            case T_FINAL:                $isFinal = true;                break;            }        }//end for        return [            'is_abstract' => $isAbstract,            'is_final'    => $isFinal,        ];    }//end getClassProperties()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_948, Determine if the passed token is a reference operator.\n\n Returns true if the specified token position represents a reference.\n Returns false if the token represents a bitwise operator.\n\n @param int $stackPtr The position of the T_BITWISE_AND token.\n\n @return boolean\n, Determine if the passed token is a reference operator.,"    public function isReference($stackPtr)    {        if ($this->tokens[$stackPtr]['code'] !== T_BITWISE_AND) {            return false;        }        $tokenBefore = $this->findPrevious(            Util\Tokens::$emptyTokens,            ($stackPtr - 1),            null,            true        );        if ($this->tokens[$tokenBefore]['code'] === T_FUNCTION            || $this->tokens[$tokenBefore]['code'] === T_CLOSURE            || $this->tokens[$tokenBefore]['code'] === T_FN        ) {            // Function returns a reference.            return true;        }        if ($this->tokens[$tokenBefore]['code'] === T_DOUBLE_ARROW) {            // Inside a foreach loop or array assignment, this is a reference.            return true;        }        if ($this->tokens[$tokenBefore]['code'] === T_AS) {            // Inside a foreach loop, this is a reference.            return true;        }        if (isset(Util\Tokens::$assignmentTokens[$this->tokens[$tokenBefore]['code']]) === true) {            // This is directly after an assignment. It's a reference. Even if            // it is part of an operation, the other tests will handle it.            return true;        }        $tokenAfter = $this->findNext(            Util\Tokens::$emptyTokens,            ($stackPtr + 1),            null,            true        );        if ($this->tokens[$tokenAfter]['code'] === T_NEW) {            return true;        }        if (isset($this->tokens[$stackPtr]['nested_parenthesis']) === true) {            $brackets    = $this->tokens[$stackPtr]['nested_parenthesis'];            $lastBracket = array_pop($brackets);            if (isset($this->tokens[$lastBracket]['parenthesis_owner']) === true) {                $owner = $this->tokens[$this->tokens[$lastBracket]['parenthesis_owner']];                if ($owner['code'] === T_FUNCTION                    || $owner['code'] === T_CLOSURE                    || $owner['code'] === T_FN                ) {                    $params = $this->getMethodParameters($this->tokens[$lastBracket]['parenthesis_owner']);                    foreach ($params as $param) {                        if ($param['reference_token'] === $stackPtr) {                            // Function parameter declared to be passed by reference.                            return true;                        }                    }                }//end if            } else {                $prev = false;                for ($t = ($this->tokens[$lastBracket]['parenthesis_opener'] - 1); $t >= 0; $t--) {                    if ($this->tokens[$t]['code'] !== T_WHITESPACE) {                        $prev = $t;                        break;                    }                }                if ($prev !== false && $this->tokens[$prev]['code'] === T_USE) {                    // Closure use by reference.                    return true;                }            }//end if        }//end if        // Pass by reference in function calls and assign by reference in arrays.        if ($this->tokens[$tokenBefore]['code'] === T_OPEN_PARENTHESIS            || $this->tokens[$tokenBefore]['code'] === T_COMMA            || $this->tokens[$tokenBefore]['code'] === T_OPEN_SHORT_ARRAY        ) {            if ($this->tokens[$tokenAfter]['code'] === T_VARIABLE) {                return true;            } else {                $skip   = Util\Tokens::$emptyTokens;                $skip[] = T_NS_SEPARATOR;                $skip[] = T_SELF;                $skip[] = T_PARENT;                $skip[] = T_STATIC;                $skip[] = T_STRING;                $skip[] = T_NAMESPACE;                $skip[] = T_DOUBLE_COLON;                $nextSignificantAfter = $this->findNext(                    $skip,                    ($stackPtr + 1),                    null,                    true                );                if ($this->tokens[$nextSignificantAfter]['code'] === T_VARIABLE) {                    return true;                }            }//end if        }//end if        return false;    }//end isReference()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Fixer_882, Attempt to fix the file by processing it until no fixes are made.\n\n @return boolean\n, Attempt to fix the file by processing it until no fixes are made.,"    public function fixFile()    {        $fixable = $this->currentFile->getFixableCount();        if ($fixable === 0) {            // Nothing to fix.            return false;        }        $this->enabled = true;        $this->loops = 0;        while ($this->loops < 50) {            ob_start();            // Only needed once file content has changed.            $contents = $this->getContents();            if (PHP_CODESNIFFER_VERBOSITY > 2) {                @ob_end_clean();                echo '---START FILE CONTENT---'.PHP_EOL;                $lines = explode($this->currentFile->eolChar, $contents);                $max   = strlen(count($lines));                foreach ($lines as $lineNum => $line) {                    $lineNum++;                    echo str_pad($lineNum, $max, ' ', STR_PAD_LEFT).'|'.$line.PHP_EOL;                }                echo '--- END FILE CONTENT ---'.PHP_EOL;                ob_start();            }            $this->inConflict = false;            $this->currentFile->ruleset->populateTokenListeners();            $this->currentFile->setContent($contents);            $this->currentFile->process();            ob_end_clean();            $this->loops++;            if (PHP_CODESNIFFER_CBF === true && PHP_CODESNIFFER_VERBOSITY > 0) {                echo ""\r"".str_repeat(' ', 80).""\r"";                echo ""\t=> Fixing file: $this->numFixes/$fixable violations remaining [made $this->loops pass"";                if ($this->loops > 1) {                    echo 'es';                }                echo ']... ';            }            if ($this->numFixes === 0 && $this->inConflict === false) {                // Nothing left to do.                break;            } else if (PHP_CODESNIFFER_VERBOSITY > 1) {                echo ""\t* fixed $this->numFixes violations, starting loop "".($this->loops + 1).' *'.PHP_EOL;            }        }//end while        $this->enabled = false;        if ($this->numFixes > 0) {            if (PHP_CODESNIFFER_VERBOSITY > 1) {                if (ob_get_level() > 0) {                    ob_end_clean();                }                echo ""\t*** Reached maximum number of loops with $this->numFixes violations left unfixed ***"".PHP_EOL;                ob_start();            }            return false;        }        return true;    }//end fixFile()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Fixer_886, Start recording actions for a changeset.\\n\\n @return void\\n, Start recording actions for a changeset.,"    public function beginChangeset()    {        if ($this->inConflict === true) {            return false;        }        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $bt = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);            if ($bt[1]['class'] === __CLASS__) {                $sniff = 'Fixer';            } else {                $sniff = Util\Common::getSniffCode($bt[1]['class']);            }            $line = $bt[0]['line'];            @ob_end_clean();            echo ""\t=> Changeset started by $sniff:$line"".PHP_EOL;            ob_start();        }        $this->changeset   = [];        $this->inChangeset = true;    }//end beginChangeset()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Fixer_887," Stop recording actions for a changeset, and apply logged changes.\\\\n\\\\n @return boolean\\\\n"," Stop recording actions for a changeset, and apply logged changes.","    public function endChangeset()    {        if ($this->inConflict === true) {            return false;        }        $this->inChangeset = false;        $success = true;        $applied = [];        foreach ($this->changeset as $stackPtr => $content) {            $success = $this->replaceToken($stackPtr, $content);            if ($success === false) {                break;            } else {                $applied[] = $stackPtr;            }        }        if ($success === false) {            // Rolling back all changes.            foreach ($applied as $stackPtr) {                $this->revertToken($stackPtr);            }            if (PHP_CODESNIFFER_VERBOSITY > 1) {                @ob_end_clean();                echo ""\t=> Changeset failed to apply"".PHP_EOL;                ob_start();            }        } else if (PHP_CODESNIFFER_VERBOSITY > 1) {            $fixes = count($this->changeset);            @ob_end_clean();            echo ""\t=> Changeset ended: $fixes changes applied"".PHP_EOL;            ob_start();        }        $this->changeset = [];    }//end endChangeset()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Fixer_891, Adds a newline to end of a token's content.\\\\n\\\\n @param int $stackPtr The position of the token in the token stack.\\\\n\\\\n @return bool If the change was accepted.\\\\n, Adds a newline to end of a token's content.,"    public function addNewline($stackPtr)    {        $current = $this->getTokenContent($stackPtr);        return $this->replaceToken($stackPtr, $current.$this->currentFile->eolChar);    }//end addNewline()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Fixer_892, Adds a newline to the start of a token's content.\\\\n\\\\n @param int $stackPtr The position of the token in the token stack.\\\\n\\\\n @return bool If the change was accepted.\\\\n, Adds a newline to the start of a token's content.,"    public function addNewlineBefore($stackPtr)    {        $current = $this->getTokenContent($stackPtr);        return $this->replaceToken($stackPtr, $this->currentFile->eolChar.$current);    }//end addNewlineBefore()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Fixer_893, Adds content to the end of a token's current content.\\\\n\\\\n @param int    $stackPtr The position of the token in the token stack.\\\\n @param string $content  The content to add.\\\\n\\\\n @return bool If the change was accepted.\\\\n, Adds content to the end of a token's current content.,"    public function addContent($stackPtr, $content)    {        $current = $this->getTokenContent($stackPtr);        return $this->replaceToken($stackPtr, $current.$content);    }//end addContent()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Fixer_895, Adjust the indent of a code block.\\n\\n @param int $start  The position of the token in the token stack\\n                    to start adjusting the indent from.\\n @param int $end    The position of the token in the token stack\\n                    to end adjusting the indent.\\n @param int $change The number of spaces to adjust the indent by\\n                    (positive or negative).\\n\\n @return void\\n, Adjust the indent of a code block.,"    public function changeCodeBlockIndent($start, $end, $change)    {        $tokens = $this->currentFile->getTokens();        $baseIndent = '';        if ($change > 0) {            $baseIndent = str_repeat(' ', $change);        }        $useChangeset = false;        if ($this->inChangeset === false) {            $this->beginChangeset();            $useChangeset = true;        }        for ($i = $start; $i <= $end; $i++) {            if ($tokens[$i]['column'] !== 1                || $tokens[($i + 1)]['line'] !== $tokens[$i]['line']            ) {                continue;            }            $length = 0;            if ($tokens[$i]['code'] === T_WHITESPACE                || $tokens[$i]['code'] === T_DOC_COMMENT_WHITESPACE            ) {                $length = $tokens[$i]['length'];                $padding = ($length + $change);                if ($padding > 0) {                    $padding = str_repeat(' ', $padding);                } else {                    $padding = '';                }                $newContent = $padding.ltrim($tokens[$i]['content']);            } else {                $newContent = $baseIndent.$tokens[$i]['content'];            }            $this->replaceToken($i, $newContent);        }//end for        if ($useChangeset === true) {            $this->endChangeset();        }    }//end changeCodeBlockIndent()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_IsCamelCapsTest_980, Test valid private method names.\n\n @return void\n, Test valid private method names.,"    public function testValidNotClassFormatPrivate()    {        $this->assertTrue(Common::isCamelCaps('_thisIsCamelCaps', false, false, true));        $this->assertTrue(Common::isCamelCaps('_thisISCamelCaps', false, false, false));        $this->assertTrue(Common::isCamelCaps('_i18N', false, false, true));        $this->assertTrue(Common::isCamelCaps('_i18n', false, false, true));    }//end testValidNotClassFormatPrivate()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_IsCamelCapsTest_982, Test valid class names.\\n\\n @return void\\n, Test valid class names.,"    public function testValidClassFormatPublic()    {        $this->assertTrue(Common::isCamelCaps('ThisIsCamelCaps', true, true, true));        $this->assertTrue(Common::isCamelCaps('ThisISCamelCaps', true, true, false));        $this->assertTrue(Common::isCamelCaps('This3IsCamelCaps', true, true, false));    }//end testValidClassFormatPublic()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_IsCamelCapsTest_983, Test invalid class names.\n\n @return void\n, Test invalid class names.,"    public function testInvalidClassFormat()    {        $this->assertFalse(Common::isCamelCaps('thisIsCamelCaps', true));        $this->assertFalse(Common::isCamelCaps('This-IsCamelCaps', true));        $this->assertFalse(Common::isCamelCaps('This_Is_Camel_Caps', true));    }//end testInvalidClassFormat()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_IsCamelCapsTest_984," Test invalid class names with the private flag set.\n\n Note that the private flag is ignored if the class format\n flag is set, so these names are all invalid.\n\n @return void\n", Test invalid class names with the private flag set.,"    public function testInvalidClassFormatPrivate()    {        $this->assertFalse(Common::isCamelCaps('_ThisIsCamelCaps', true, true));        $this->assertFalse(Common::isCamelCaps('_ThisIsCamelCaps', true, false));    }//end testInvalidClassFormatPrivate()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Reporter_898, Generates and prints a single final report.\\n\\n @param string $report The report type to print.\\n\\n @return void\\n, Generates and prints a single final report.,"    public function printReport($report)    {        $reportClass = $this->reports[$report]['class'];        $reportFile  = $this->reports[$report]['output'];        if ($reportFile !== null) {            $filename = $reportFile;            $toScreen = false;        } else {            if (isset($this->tmpFiles[$report]) === true) {                $filename = $this->tmpFiles[$report];            } else {                $filename = null;            }            $toScreen = true;        }        $reportCache = '';        if ($filename !== null) {            $reportCache = file_get_contents($filename);        }        ob_start();        $reportClass->generate(            $reportCache,            $this->totalFiles,            $this->totalErrors,            $this->totalWarnings,            $this->totalFixable,            $this->config->showSources,            $this->config->reportWidth,            $this->config->interactive,            $toScreen        );        $generatedReport = ob_get_contents();        ob_end_clean();        if ($this->config->colors !== true || $reportFile !== null) {            $generatedReport = preg_replace('`\033\[[0-9;]+m`', '', $generatedReport);        }        if ($reportFile !== null) {            if (PHP_CODESNIFFER_VERBOSITY > 0) {                echo $generatedReport;            }            file_put_contents($reportFile, $generatedReport.PHP_EOL);        } else {            echo $generatedReport;            if ($filename !== null && file_exists($filename) === true) {                unlink($filename);                unset($this->tmpFiles[$report]);            }        }    }//end printReport()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Reporter_900, Generate summary information to be used during report generation.\\\\n\\\\n @param \\\\\\\\PHP_CodeSniffer\\\\\\\\Files\\\\\\\\File $phpcsFile The file that has been processed.\\\\n\\\\n @return array\\\\n, Generate summary information to be used during report generation.,"    public function prepareFileReport(File $phpcsFile)    {        $report = [            'filename' => Common::stripBasepath($phpcsFile->getFilename(), $this->config->basepath),            'errors'   => $phpcsFile->getErrorCount(),            'warnings' => $phpcsFile->getWarningCount(),            'fixable'  => $phpcsFile->getFixableCount(),            'messages' => [],        ];        if ($report['errors'] === 0 && $report['warnings'] === 0) {            // Prefect score!            return $report;        }        if ($this->config->recordErrors === false) {            $message  = 'Errors are not being recorded but this report requires error messages. ';            $message .= 'This report will not show the correct information.';            $report['messages'][1][1] = [                [                    'message'  => $message,                    'source'   => 'Internal.RecordErrors',                    'severity' => 5,                    'fixable'  => false,                    'type'     => 'ERROR',                ],            ];            return $report;        }        $errors = [];        // Merge errors and warnings.        foreach ($phpcsFile->getErrors() as $line => $lineErrors) {            foreach ($lineErrors as $column => $colErrors) {                $newErrors = [];                foreach ($colErrors as $data) {                    $newErrors[] = [                        'message'  => $data['message'],                        'source'   => $data['source'],                        'severity' => $data['severity'],                        'fixable'  => $data['fixable'],                        'type'     => 'ERROR',                    ];                }                $errors[$line][$column] = $newErrors;            }            ksort($errors[$line]);        }//end foreach        foreach ($phpcsFile->getWarnings() as $line => $lineWarnings) {            foreach ($lineWarnings as $column => $colWarnings) {                $newWarnings = [];                foreach ($colWarnings as $data) {                    $newWarnings[] = [                        'message'  => $data['message'],                        'source'   => $data['source'],                        'severity' => $data['severity'],                        'fixable'  => $data['fixable'],                        'type'     => 'WARNING',                    ];                }                if (isset($errors[$line]) === false) {                    $errors[$line] = [];                }                if (isset($errors[$line][$column]) === true) {                    $errors[$line][$column] = array_merge(                        $newWarnings,                        $errors[$line][$column]                    );                } else {                    $errors[$line][$column] = $newWarnings;                }            }//end foreach            ksort($errors[$line]);        }//end foreach        ksort($errors);        $report['messages'] = $errors;        return $report;    }//end prepareFileReport()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Ruleset_903, Determine if an element should be processed or ignored.\\n\\n @param \\\\SimpleXMLElement $element An object from a ruleset XML file.\\n\\n @return bool\\n, Determine if an element should be processed or ignored.,    private function shouldProcessElement($element)    {        if (isset($element['phpcbf-only']) === false            && isset($element['phpcs-only']) === false        ) {            // No exceptions are being made.            return true;        }        if (PHP_CODESNIFFER_CBF === true            && isset($element['phpcbf-only']) === true            && (string) $element['phpcbf-only'] === 'true'        ) {            return true;        }        if (PHP_CODESNIFFER_CBF === false            && isset($element['phpcs-only']) === true            && (string) $element['phpcs-only'] === 'true'        ) {            return true;        }        return false;    }//end shouldProcessElement(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Ruleset_905, Populates the array of PHP_CodeSniffer_Sniff objects for this file.\\n\\n @return void\\n @throws \\\\PHP_CodeSniffer\\\\Exceptions\\\\RuntimeException If sniff registration fails.\\n, Populates the array of PHP_CodeSniffer_Sniff objects for this file.,"    public function populateTokenListeners()    {        // Construct a list of listeners indexed by token being listened for.        $this->tokenListeners = [];        foreach ($this->sniffs as $sniffClass => $sniffObject) {            $this->sniffs[$sniffClass] = null;            $this->sniffs[$sniffClass] = new $sniffClass();            $sniffCode = Util\Common::getSniffCode($sniffClass);            $this->sniffCodes[$sniffCode] = $sniffClass;            // Set custom properties.            if (isset($this->ruleset[$sniffCode]['properties']) === true) {                foreach ($this->ruleset[$sniffCode]['properties'] as $name => $value) {                    $this->setSniffProperty($sniffClass, $name, $value);                }            }            $tokenizers = [];            $vars       = get_class_vars($sniffClass);            if (isset($vars['supportedTokenizers']) === true) {                foreach ($vars['supportedTokenizers'] as $tokenizer) {                    $tokenizers[$tokenizer] = $tokenizer;                }            } else {                $tokenizers = ['PHP' => 'PHP'];            }            $tokens = $this->sniffs[$sniffClass]->register();            if (is_array($tokens) === false) {                $msg = ""Sniff $sniffClass register() method must return an array"";                throw new RuntimeException($msg);            }            $ignorePatterns = [];            $patterns       = $this->getIgnorePatterns($sniffCode);            foreach ($patterns as $pattern => $type) {                $replacements = [                    '\\,' => ',',                    '*'   => '.*',                ];                $ignorePatterns[] = strtr($pattern, $replacements);            }            $includePatterns = [];            $patterns        = $this->getIncludePatterns($sniffCode);            foreach ($patterns as $pattern => $type) {                $replacements = [                    '\\,' => ',',                    '*'   => '.*',                ];                $includePatterns[] = strtr($pattern, $replacements);            }            foreach ($tokens as $token) {                if (isset($this->tokenListeners[$token]) === false) {                    $this->tokenListeners[$token] = [];                }                if (isset($this->tokenListeners[$token][$sniffClass]) === false) {                    $this->tokenListeners[$token][$sniffClass] = [                        'class'      => $sniffClass,                        'source'     => $sniffCode,                        'tokenizers' => $tokenizers,                        'ignore'     => $ignorePatterns,                        'include'    => $includePatterns,                    ];                }            }        }//end foreach    }//end populateTokenListeners()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Ruleset_906, Set a single property for a sniff.\\n\\n @param string $sniffClass The class name of the sniff.\\n @param string $name       The name of the property to change.\\n @param string $value      The new value of the property.\\n\\n @return void\\n, Set a single property for a sniff.,"    public function setSniffProperty($sniffClass, $name, $value)    {        // Setting a property for a sniff we are not using.        if (isset($this->sniffs[$sniffClass]) === false) {            return;        }        $name = trim($name);        if (is_string($value) === true) {            $value = trim($value);        }        if ($value === '') {            $value = null;        }        // Special case for booleans.        if ($value === 'true') {            $value = true;        } else if ($value === 'false') {            $value = false;        } else if (substr($name, -2) === '[]') {            $name   = substr($name, 0, -2);            $values = [];            if ($value !== null) {                foreach (explode(',', $value) as $val) {                    list($k, $v) = explode('=>', $val.'=>');                    if ($v !== '') {                        $values[trim($k)] = trim($v);                    } else {                        $values[] = trim($k);                    }                }            }            $value = $values;        }        $this->sniffs[$sniffClass]->$name = $value;    }//end setSniffProperty()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Runner_908, Run the PHPCBF script.\n\n @return array\n, Run the PHPCBF script.,"    public function runPHPCBF()    {        if (defined('PHP_CODESNIFFER_CBF') === false) {            define('PHP_CODESNIFFER_CBF', true);        }        try {            Util\Timing::startTiming();            Runner::checkRequirements();            // Creating the Config object populates it with all required settings            // based on the CLI arguments provided to the script and any config            // values the user has set.            $this->config = new Config();            // When processing STDIN, we can't output anything to the screen            // or it will end up mixed in with the file output.            if ($this->config->stdin === true) {                $this->config->verbosity = 0;            }            // Init the run and load the rulesets to set additional config vars.            $this->init();            // When processing STDIN, we only process one file at a time and            // we don't process all the way through, so we can't use the parallel            // running system.            if ($this->config->stdin === true) {                $this->config->parallel = 1;            }            // Override some of the command line settings that might break the fixes.            $this->config->generator    = null;            $this->config->explain      = false;            $this->config->interactive  = false;            $this->config->cache        = false;            $this->config->showSources  = false;            $this->config->recordErrors = false;            $this->config->reportFile   = null;            $this->config->reports      = ['cbf' => null];            // If a standard tries to set command line arguments itself, some            // may be blocked because PHPCBF is running, so stop the script            // dying if any are found.            $this->config->dieOnUnknownArg = false;            $this->run();            $this->reporter->printReports();            echo PHP_EOL;            Util\Timing::printRunTime();        } catch (DeepExitException $e) {            echo $e->getMessage();            return $e->getCode();        }//end try        if ($this->reporter->totalFixed === 0) {            // Nothing was fixed by PHPCBF.            if ($this->reporter->totalFixable === 0) {                // Nothing found that could be fixed.                return 0;            } else {                // Something failed to fix.                return 2;            }        }        if ($this->reporter->totalFixable === 0) {            // PHPCBF fixed all fixable errors.            return 1;        }        // PHPCBF fixed some fixable errors, but others failed to fix.        return 2;    }//end runPHPCBF()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Runner_911, Performs the run.\\\\n\\\\n @return int The number of errors and warnings found.\\\\n @throws \\\\\\\\PHP_CodeSniffer\\\\\\\\Exceptions\\\\\\\\DeepExitException\\\\n @throws \\\\\\\\PHP_CodeSniffer\\\\\\\\Exceptions\\\\\\\\RuntimeException\\\\n, Performs the run.,"    private function run()    {        // The class that manages all reporters for the run.        $this->reporter = new Reporter($this->config);        // Include bootstrap files.        foreach ($this->config->bootstrap as $bootstrap) {            include $bootstrap;        }        if ($this->config->stdin === true) {            $fileContents = $this->config->stdinContent;            if ($fileContents === null) {                $handle = fopen('php://stdin', 'r');                stream_set_blocking($handle, true);                $fileContents = stream_get_contents($handle);                fclose($handle);            }            $todo  = new FileList($this->config, $this->ruleset);            $dummy = new DummyFile($fileContents, $this->ruleset, $this->config);            $todo->addFile($dummy->path, $dummy);        } else {            if (empty($this->config->files) === true) {                $error  = 'ERROR: You must supply at least one file or directory to process.'.PHP_EOL.PHP_EOL;                $error .= $this->config->printShortUsage(true);                throw new DeepExitException($error, 3);            }            if (PHP_CODESNIFFER_VERBOSITY > 0) {                echo 'Creating file list... ';            }            $todo = new FileList($this->config, $this->ruleset);            if (PHP_CODESNIFFER_VERBOSITY > 0) {                $numFiles = count($todo);                echo ""DONE ($numFiles files in queue)"".PHP_EOL;            }            if ($this->config->cache === true) {                if (PHP_CODESNIFFER_VERBOSITY > 0) {                    echo 'Loading cache... ';                }                Cache::load($this->ruleset, $this->config);                if (PHP_CODESNIFFER_VERBOSITY > 0) {                    $size = Cache::getSize();                    echo ""DONE ($size files in cache)"".PHP_EOL;                }            }        }//end if        // Turn all sniff errors into exceptions.        set_error_handler([$this, 'handleErrors']);        // If verbosity is too high, turn off parallelism so the        // debug output is clean.        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $this->config->parallel = 1;        }        // If the PCNTL extension isn't installed, we can't fork.        if (function_exists('pcntl_fork') === false) {            $this->config->parallel = 1;        }        $lastDir  = '';        $numFiles = count($todo);        if ($this->config->parallel === 1) {            // Running normally.            $numProcessed = 0;            foreach ($todo as $path => $file) {                if ($file->ignored === false) {                    $currDir = dirname($path);                    if ($lastDir !== $currDir) {                        if (PHP_CODESNIFFER_VERBOSITY > 0) {                            echo 'Changing into directory '.Common::stripBasepath($currDir, $this->config->basepath).PHP_EOL;                        }                        $lastDir = $currDir;                    }                    $this->processFile($file);                } else if (PHP_CODESNIFFER_VERBOSITY > 0) {                    echo 'Skipping '.basename($file->path).PHP_EOL;                }                $numProcessed++;                $this->printProgress($file, $numFiles, $numProcessed);            }        } else {            // Batching and forking.            $childProcs  = [];            $numPerBatch = ceil($numFiles / $this->config->parallel);            for ($batch = 0; $batch < $this->config->parallel; $batch++) {                $startAt = ($batch * $numPerBatch);                if ($startAt >= $numFiles) {                    break;                }                $endAt = ($startAt + $numPerBatch);                if ($endAt > $numFiles) {                    $endAt = $numFiles;                }                $childOutFilename = tempnam(sys_get_temp_dir(), 'phpcs-child');                $pid = pcntl_fork();                if ($pid === -1) {                    throw new RuntimeException('Failed to create child process');                } else if ($pid !== 0) {                    $childProcs[] = [                        'pid' => $pid,                        'out' => $childOutFilename,                    ];                } else {                    // Move forward to the start of the batch.                    $todo->rewind();                    for ($i = 0; $i < $startAt; $i++) {                        $todo->next();                    }                    // Reset the reporter to make sure only figures from this                    // file batch are recorded.                    $this->reporter->totalFiles    = 0;                    $this->reporter->totalErrors   = 0;                    $this->reporter->totalWarnings = 0;                    $this->reporter->totalFixable  = 0;                    $this->reporter->totalFixed    = 0;                    // Process the files.                    $pathsProcessed = [];                    ob_start();                    for ($i = $startAt; $i < $endAt; $i++) {                        $path = $todo->key();                        $file = $todo->current();                        if ($file->ignored === true) {                            $todo->next();                            continue;                        }                        $currDir = dirname($path);                        if ($lastDir !== $currDir) {                            if (PHP_CODESNIFFER_VERBOSITY > 0) {                                echo 'Changing into directory '.Common::stripBasepath($currDir, $this->config->basepath).PHP_EOL;                            }                            $lastDir = $currDir;                        }                        $this->processFile($file);                        $pathsProcessed[] = $path;                        $todo->next();                    }//end for                    $debugOutput = ob_get_contents();                    ob_end_clean();                    // Write information about the run to the filesystem                    // so it can be picked up by the main process.                    $childOutput = [                        'totalFiles'    => $this->reporter->totalFiles,                        'totalErrors'   => $this->reporter->totalErrors,                        'totalWarnings' => $this->reporter->totalWarnings,                        'totalFixable'  => $this->reporter->totalFixable,                        'totalFixed'    => $this->reporter->totalFixed,                    ];                    $output  = '<'.'?php'.""\n"".' $childOutput = ';                    $output .= var_export($childOutput, true);                    $output .= "";\n\$debugOutput = "";                    $output .= var_export($debugOutput, true);                    if ($this->config->cache === true) {                        $childCache = [];                        foreach ($pathsProcessed as $path) {                            $childCache[$path] = Cache::get($path);                        }                        $output .= "";\n\$childCache = "";                        $output .= var_export($childCache, true);                    }                    $output .= "";\n?"".'>';                    file_put_contents($childOutFilename, $output);                    exit($pid);                }//end if            }//end for            $success = $this->processChildProcs($childProcs);            if ($success === false) {                throw new RuntimeException('One or more child processes failed to run');            }        }//end if        restore_error_handler();        if (PHP_CODESNIFFER_VERBOSITY === 0            && $this->config->interactive === false            && $this->config->showProgress === true        ) {            echo PHP_EOL.PHP_EOL;        }        if ($this->config->cache === true) {            Cache::save();        }        $ignoreWarnings = Config::getConfigData('ignore_warnings_on_exit');        $ignoreErrors   = Config::getConfigData('ignore_errors_on_exit');        $return = ($this->reporter->totalErrors + $this->reporter->totalWarnings);        if ($ignoreErrors !== null) {            $ignoreErrors = (bool) $ignoreErrors;            if ($ignoreErrors === true) {                $return -= $this->reporter->totalErrors;            }        }        if ($ignoreWarnings !== null) {            $ignoreWarnings = (bool) $ignoreWarnings;            if ($ignoreWarnings === true) {                $return -= $this->reporter->totalWarnings;            }        }        return $return;    }//end run()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Runner_913," Processes a single file, including checking and fixing.\n\n @param \\PHP_CodeSniffer\\Files\\File $file The file to be processed.\n\n @return void\n @throws \\PHP_CodeSniffer\\Exceptions\\DeepExitException\n"," Processes a single file, including checking and fixing.","    public function processFile($file)    {        if (PHP_CODESNIFFER_VERBOSITY > 0) {            $startTime = microtime(true);            echo 'Processing '.basename($file->path).' ';            if (PHP_CODESNIFFER_VERBOSITY > 1) {                echo PHP_EOL;            }        }        try {            $file->process();            if (PHP_CODESNIFFER_VERBOSITY > 0) {                $timeTaken = ((microtime(true) - $startTime) * 1000);                if ($timeTaken < 1000) {                    $timeTaken = round($timeTaken);                    echo ""DONE in {$timeTaken}ms"";                } else {                    $timeTaken = round(($timeTaken / 1000), 2);                    echo ""DONE in $timeTaken secs"";                }                if (PHP_CODESNIFFER_CBF === true) {                    $errors = $file->getFixableCount();                    echo "" ($errors fixable violations)"".PHP_EOL;                } else {                    $errors   = $file->getErrorCount();                    $warnings = $file->getWarningCount();                    echo "" ($errors errors, $warnings warnings)"".PHP_EOL;                }            }        } catch (\Exception $e) {            $error = 'An error occurred during processing; checking has been aborted. The error message was: '.$e->getMessage();            $file->addErrorOnLine($error, 1, 'Internal.Exception');        }//end try        $this->reporter->cacheFileReport($file, $this->config);        if ($this->config->interactive === true) {            /*                Running interactively.                Print the error report for the current file and then wait for user input.            */            // Get current violations and then clear the list to make sure            // we only print violations for a single file each time.            $numErrors = null;            while ($numErrors !== 0) {                $numErrors = ($file->getErrorCount() + $file->getWarningCount());                if ($numErrors === 0) {                    continue;                }                $this->reporter->printReport('full');                echo '<ENTER> to recheck, [s] to skip or [q] to quit : ';                $input = fgets(STDIN);                $input = trim($input);                switch ($input) {                case 's':                    break(2);                case 'q':                    throw new DeepExitException('', 0);                default:                    // Repopulate the sniffs because some of them save their state                    // and only clear it when the file changes, but we are rechecking                    // the same file.                    $file->ruleset->populateTokenListeners();                    $file->reloadContent();                    $file->process();                    $this->reporter->cacheFileReport($file, $this->config);                    break;                }            }//end while        }//end if        // Clean up the file to save (a lot of) memory.        $file->cleanUp();    }//end processFile()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Runner_914, Waits for child processes to complete and cleans up after them.\\n\\n The reporting information returned by each child process is merged\\n into the main reporter class.\\n\\n @param array $childProcs An array of child processes to wait for.\\n\\n @return bool\\n, Waits for child processes to complete and cleans up after them.,"    private function processChildProcs($childProcs)    {        $numProcessed = 0;        $totalBatches = count($childProcs);        $success = true;        while (count($childProcs) > 0) {            foreach ($childProcs as $key => $procData) {                $res = pcntl_waitpid($procData['pid'], $status, WNOHANG);                if ($res === $procData['pid']) {                    if (file_exists($procData['out']) === true) {                        include $procData['out'];                        unlink($procData['out']);                        unset($childProcs[$key]);                        $numProcessed++;                        if (isset($childOutput) === false) {                            // The child process died, so the run has failed.                            $file = new DummyFile(null, $this->ruleset, $this->config);                            $file->setErrorCounts(1, 0, 0, 0);                            $this->printProgress($file, $totalBatches, $numProcessed);                            $success = false;                            continue;                        }                        $this->reporter->totalFiles    += $childOutput['totalFiles'];                        $this->reporter->totalErrors   += $childOutput['totalErrors'];                        $this->reporter->totalWarnings += $childOutput['totalWarnings'];                        $this->reporter->totalFixable  += $childOutput['totalFixable'];                        $this->reporter->totalFixed    += $childOutput['totalFixed'];                        if (isset($debugOutput) === true) {                            echo $debugOutput;                        }                        if (isset($childCache) === true) {                            foreach ($childCache as $path => $cache) {                                Cache::set($path, $cache);                            }                        }                        // Fake a processed file so we can print progress output for the batch.                        $file = new DummyFile(null, $this->ruleset, $this->config);                        $file->setErrorCounts(                            $childOutput['totalErrors'],                            $childOutput['totalWarnings'],                            $childOutput['totalFixable'],                            $childOutput['totalFixed']                        );                        $this->printProgress($file, $totalBatches, $numProcessed);                    }//end if                }//end if            }//end foreach        }//end while        return $success;    }//end processChildProcs()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Runner_915," Print progress information for a single processed file.\\n\\n @param \\\\PHP_CodeSniffer\\\\Files\\\\File $file         The file that was processed.\\n @param int                         $numFiles     The total number of files to process.\\n @param int                         $numProcessed The number of files that have been processed,\\n                                                  including this one.\\n\\n @return void\\n", Print progress information for a single processed file.,"    public function printProgress(File $file, $numFiles, $numProcessed)    {        if (PHP_CODESNIFFER_VERBOSITY > 0            || $this->config->showProgress === false        ) {            return;        }        // Show progress information.        if ($file->ignored === true) {            echo 'S';        } else {            $errors   = $file->getErrorCount();            $warnings = $file->getWarningCount();            $fixable  = $file->getFixableCount();            $fixed    = $file->getFixedCount();            if (PHP_CODESNIFFER_CBF === true) {                // Files with fixed errors or warnings are F (green).                // Files with unfixable errors or warnings are E (red).                // Files with no errors or warnings are . (black).                if ($fixable > 0) {                    if ($this->config->colors === true) {                        echo ""\033[31m"";                    }                    echo 'E';                    if ($this->config->colors === true) {                        echo ""\033[0m"";                    }                } else if ($fixed > 0) {                    if ($this->config->colors === true) {                        echo ""\033[32m"";                    }                    echo 'F';                    if ($this->config->colors === true) {                        echo ""\033[0m"";                    }                } else {                    echo '.';                }//end if            } else {                // Files with errors are E (red).                // Files with fixable errors are E (green).                // Files with warnings are W (yellow).                // Files with fixable warnings are W (green).                // Files with no errors or warnings are . (black).                if ($errors > 0) {                    if ($this->config->colors === true) {                        if ($fixable > 0) {                            echo ""\033[32m"";                        } else {                            echo ""\033[31m"";                        }                    }                    echo 'E';                    if ($this->config->colors === true) {                        echo ""\033[0m"";                    }                } else if ($warnings > 0) {                    if ($this->config->colors === true) {                        if ($fixable > 0) {                            echo ""\033[32m"";                        } else {                            echo ""\033[33m"";                        }                    }                    echo 'W';                    if ($this->config->colors === true) {                        echo ""\033[0m"";                    }                } else {                    echo '.';                }//end if            }//end if        }//end if        $numPerLine = 60;        if ($numProcessed !== $numFiles && ($numProcessed % $numPerLine) !== 0) {            return;        }        $percent = round(($numProcessed / $numFiles) * 100);        $padding = (strlen($numFiles) - strlen($numProcessed));        if ($numProcessed === $numFiles            && $numFiles > $numPerLine            && ($numProcessed % $numPerLine) !== 0        ) {            $padding += ($numPerLine - ($numFiles - (floor($numFiles / $numPerLine) * $numPerLine)));        }        echo str_repeat(' ', $padding)."" $numProcessed / $numFiles ($percent%)"".PHP_EOL;    }//end printProgress()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ValidatePEARPackageXML_858, Validate the file listings in the package.xml file.\n\n @return void\n, Validate the file listings in the package.xml file.,    public function validate()    {        $exitCode = 0;        if ($this->checkContents() !== true) {            $exitCode = 1;        }        if ($this->checkPHPRelease() !== true) {            $exitCode = 1;        }        exit($exitCode);    }//end validate(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ValidatePEARPackageXML_859, Validate the file listings in the <contents> tag.\\\\n\\\\n @return bool\\\\n, Validate the file listings in the <contents> tag.,"    protected function checkContents()    {        echo PHP_EOL.'Checking Contents tag'.PHP_EOL;        echo '====================='.PHP_EOL;        $valid = true;        /*         * - Check that every file that is mentioned in the `<content>` tag exists in the repo.         * - Check that the ""role"" value is valid.         * - Check that the ""baseinstalldir"" value is valid.         */        $valid = $this->walkDirTag($this->packageXML->contents);        if ($valid === true) {            echo ""Existing listings in the Contents tag are valid."".PHP_EOL;        }        /*         * Verify that all files in the `src` and the `tests` directories are listed in the `<contents>` tag.         */        $srcFiles   = (new FileList(            $this->projectRoot.'src/',            $this->projectRoot,            '`\.(css|fixed|inc|js|php|xml)$`Di'        ))->getList();        $testsFiles = (new FileList(            $this->projectRoot.'tests/',            $this->projectRoot,            '`\.(css|inc|js|php|xml)$`Di'        ))->getList();        $files      = array_merge($srcFiles, $testsFiles);        foreach ($files as $file) {            if (isset($this->listedContents[$file]) === true) {                continue;            }            echo ""- File '{$file}' is missing from Contents tag."".PHP_EOL;            $valid = false;        }        if ($valid === true) {            echo ""No missing files in the Contents tag."".PHP_EOL;        }        return $valid;    }//end checkContents()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_ValidatePEARPackageXML_860," Validate the file listings in the <phprelease> tags.\n\n @return bool True if the info in the ""phprelease"" tags is valid. False otherwise.\n", Validate the file listings in the <phprelease> tags.,"    protected function checkPHPRelease()    {        echo PHP_EOL.'Checking PHPRelease tags'.PHP_EOL;        echo '========================'.PHP_EOL;        $valid       = true;        $listedFiles = [];        $releaseTags = 1;        /*         * - Check that every file that is mentioned in the `<phprelease>` tags exists in the repo.         * - Check that the ""as"" value is valid.         */        foreach ($this->packageXML->phprelease as $release) {            foreach ($release->filelist->install as $install) {                $attributes = $install->attributes();                $name       = (string) $attributes['name'];                $as         = (string) $attributes['as'];                $listedFiles[$releaseTags][$name] = $as;                if (empty($as) === true || empty($name) === true) {                    continue;                }                if (isset($this->allFiles[$name]) === false) {                    echo ""- File '{$name}' does not exist."".PHP_EOL;                    $valid = false;                }                // Rest of the checks only apply to the test files.                if (strpos($name, 'tests/') !== 0) {                    continue;                }                // Check validity of the tags for files in the tests root directory.                if (preg_match('`^tests/([^/]+\.php)$`', $name, $matches) === 1                    && ($as === $name || $as === $matches[1])                ) {                    continue;                }                // Check validity of the tags for files in the tests root subdirectories.                if (preg_match('`^tests/.+\.(php|inc|js|css|xml)$`', $name) === 1                    && $as === str_replace('tests/', 'CodeSniffer/', $name)                ) {                    continue;                }                echo ""- Invalid 'as' attribute '{$as}' for test file '{$name}'."".PHP_EOL;                $valid = false;            }//end foreach            ++$releaseTags;        }//end foreach        if ($valid === true) {            echo ""Existing PHPRelease tags are valid."".PHP_EOL;        }        /*         * Verify that all files in the `tests` directory are listed in both `<phprelease>` tags.         */        $testFiles = (new FileList($this->projectRoot.'tests/', $this->projectRoot, '`\.(inc|php|js|css|xml)$`Di'))->getList();        foreach ($testFiles as $file) {            foreach ($listedFiles as $key => $listed) {                if (isset($listed[$file]) === true) {                    continue;                }                echo ""- File '{$file}' is missing from PHPRelease tag [{$key}] ."".PHP_EOL;                $valid = false;            }        }        if ($valid === true) {            echo ""No missing PHPRelease tags."".PHP_EOL;        }        return $valid;    }//end checkPHPRelease()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_autoload_848, Loads a class.\n\n This method only loads classes that exist in the PHP_CodeSniffer namespace.\n All other classes are ignored and loaded by subsequent autoloaders.\n\n @param string $class The name of the class to load.\n\n @return bool\n, Loads a class.,"        public static function load($class)        {            // Include the composer autoloader if there is one, but re-register it            // so this autoloader runs before the composer one as we need to include            // all files so we can figure out what the class/interface/trait name is.            if (self::$composerAutoloader === null) {                // Make sure we don't try to load any of Composer's classes                // while the autoloader is being setup.                if (strpos($class, 'Composer\\') === 0) {                    return;                }                if (strpos(__DIR__, 'phar://') !== 0                    && @file_exists(__DIR__.'/../../autoload.php') === true                ) {                    self::$composerAutoloader = include __DIR__.'/../../autoload.php';                    if (self::$composerAutoloader instanceof \Composer\Autoload\ClassLoader) {                        self::$composerAutoloader->unregister();                        self::$composerAutoloader->register();                    } else {                        // Something went wrong, so keep going without the autoloader                        // although namespaced sniffs might error.                        self::$composerAutoloader = false;                    }                } else {                    self::$composerAutoloader = false;                }            }//end if            $ds   = DIRECTORY_SEPARATOR;            $path = false;            if (substr($class, 0, 16) === 'PHP_CodeSniffer\\') {                if (substr($class, 0, 22) === 'PHP_CodeSniffer\Tests\\') {                    $isInstalled = !is_dir(__DIR__.$ds.'tests');                    if ($isInstalled === false) {                        $path = __DIR__.$ds.'tests';                    } else {                        $path = '@test_dir@'.$ds.'PHP_CodeSniffer'.$ds.'CodeSniffer';                    }                    $path .= $ds.substr(str_replace('\\', $ds, $class), 22).'.php';                } else {                    $path = __DIR__.$ds.'src'.$ds.substr(str_replace('\\', $ds, $class), 16).'.php';                }            }            // See if the composer autoloader knows where the class is.            if ($path === false && self::$composerAutoloader !== false) {                $path = self::$composerAutoloader->findFile($class);            }            // See if the class is inside one of our alternate search paths.            if ($path === false) {                foreach (self::$searchPaths as $searchPath => $nsPrefix) {                    $className = $class;                    if ($nsPrefix !== '' && substr($class, 0, strlen($nsPrefix)) === $nsPrefix) {                        $className = substr($class, (strlen($nsPrefix) + 1));                    }                    $path = $searchPath.$ds.str_replace('\\', $ds, $className).'.php';                    if (is_file($path) === true) {                        break;                    }                    $path = false;                }            }            if ($path !== false && is_file($path) === true) {                self::loadFile($path);                return true;            }            return false;        }//end load()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_autoload_849, Includes a file and tracks what class or interface was loaded as a result.\\\\n\\\\n @param string $path The path of the file to load.\\\\n\\\\n @return string The fully qualified name of the class in the loaded file.\\\\n, Includes a file and tracks what class or interface was loaded as a result.,"        public static function loadFile($path)        {            if (strpos(__DIR__, 'phar://') !== 0) {                $path = realpath($path);                if ($path === false) {                    return false;                }            }            if (isset(self::$loadedClasses[$path]) === true) {                return self::$loadedClasses[$path];            }            $classesBeforeLoad = [                'classes'    => get_declared_classes(),                'interfaces' => get_declared_interfaces(),                'traits'     => get_declared_traits(),            ];            include $path;            $classesAfterLoad = [                'classes'    => get_declared_classes(),                'interfaces' => get_declared_interfaces(),                'traits'     => get_declared_traits(),            ];            $className = self::determineLoadedClass($classesBeforeLoad, $classesAfterLoad);            self::$loadedClasses[$path]    = $className;            self::$loadedFiles[$className] = $path;            return self::$loadedClasses[$path];        }//end loadFile()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_autoload_851, Retrieve the namespaces and paths registered by external standards.\\n\\n @return array\\n, Retrieve the namespaces and paths registered by external standards.,        public static function getSearchPaths()        {            return self::$searchPaths;        }//end getSearchPaths(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_autoload_852, Gets the class name for the given file path.\\n\\n @param string $path The name of the file.\\n\\n @throws \\\\Exception If the file path has not been loaded.\\n @return string\\n, Gets the class name for the given file path.,"        public static function getLoadedClassName($path)        {            if (isset(self::$loadedClasses[$path]) === false) {                throw new \Exception(""Cannot get class name for $path; file has not been included"");            }            return self::$loadedClasses[$path];        }//end getLoadedClassName()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_autoload_853, Gets the file path for the given class name.\\n\\n @param string $class The name of the class.\\n\\n @throws \\\\Exception If the class name has not been loaded\\n @return string\\n, Gets the file path for the given class name.,"        public static function getLoadedFileName($class)        {            if (isset(self::$loadedFiles[$class]) === false) {                throw new \Exception(""Cannot get file name for $class; class has not been included"");            }            return self::$loadedFiles[$class];        }//end getLoadedFileName()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_autoload_854," Gets the mapping of file names to class names.\\n\\n @return array<string, string>\\n", Gets the mapping of file names to class names.,        public static function getLoadedClasses()        {            return self::$loadedClasses;        }//end getLoadedClasses(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_autoload_855," Gets the mapping of class names to file names.\\n\\n @return array<string, string>\\n", Gets the mapping of class names to file names.,        public static function getLoadedFiles()        {            return self::$loadedFiles;        }//end getLoadedFiles(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_AddressEncoderException_1617, AddressEncoderException when the specified email address is in a format that\\n cannot be encoded by a given address encoder.\\n\\n @author Christian Schmidt\\n, AddressEncoderException when the specified email address is in a format that,"class Swift_AddressEncoderException extends Swift_RfcComplianceException{    protected $address;    public function __construct(string $message, string $address)    {        parent::__construct($message);        $this->address = $address;    }    public function getAddress(): string    {        return $this->address;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_Attachment_1618, Attachment class for attaching files to a {@link Swift_Mime_SimpleMessage}.\n\n @author Chris Corbyn\n, Attachment class for attaching files to a {@link Swift_Mime_SimpleMessage}.,"class Swift_Attachment extends Swift_Mime_Attachment{    /**     * Create a new Attachment.     *     * Details may be optionally provided to the constructor.     *     * @param string|Swift_OutputByteStream $data     * @param string                        $filename     * @param string                        $contentType     */    public function __construct($data = null, $filename = null, $contentType = null)    {        \call_user_func_array(            [$this, 'Swift_Mime_Attachment::__construct'],            Swift_DependencyContainer::getInstance()                ->createDependenciesFor('mime.attachment')            );        $this->setBody($data, $contentType);        $this->setFilename($filename);    }    /**     * Create a new Attachment from a filesystem path.     *     * @param string $path     * @param string $contentType optional     *     * @return self     */    public static function fromPath($path, $contentType = null)    {        return (new self())->setFile(            new Swift_ByteStream_FileByteStream($path),            $contentType        );    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_CharacterReader_231, Returns the complete character map.\\n\\n @param string $string\\n @param int    $startOffset\\n @param array  $currentMap\\n @param mixed  $ignoredChars\\n\\n @return int\\n, Returns the complete character map.,"    public function getCharPositions($string, $startOffset, &$currentMap, &$ignoredChars);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_DependencyContainerAcceptanceTest_1303,"This is more of a ""cross your fingers and hope it works"" test!\n","This is more of a ""cross your fingers and hope it works"" test!",class Swift_DependencyContainerAcceptanceTest extends PHPUnit\Framework\TestCase{    public function testNoLookupsFail()    {        $di = Swift_DependencyContainer::getInstance();        foreach ($di->listItems() as $itemName) {            try {                $di->lookup($itemName);            } catch (Swift_DependencyException $e) {                $this->fail($e->getMessage());            }        }        // previous loop would fail if there is an issue        $this->addToAssertionCount(1);    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_IdenticalBinaryConstraint_1297, A binary safe string comparison.\n\n @author Chris Corbyn\n, A binary safe string comparison.,"class IdenticalBinaryConstraint extends \PHPUnit\Framework\Constraint\Constraint{    protected $value;    public function __construct($value)    {        $this->value = $value;    }    /**     * Evaluates the constraint for parameter $other. Returns TRUE if the     * constraint is met, FALSE otherwise.     *     * @param mixed $other value or object to evaluate     */    public function matches($other): bool    {        $aHex = $this->asHexString($this->value);        $bHex = $this->asHexString($other);        return $aHex === $bHex;    }    /**     * Returns a string representation of the constraint.     */    public function toString(): string    {        return 'identical binary';    }    /**     * Get the given string of bytes as a stirng of Hexadecimal sequences.     *     * @param string $binary     *     * @return string     */    private function asHexString($binary)    {        $hex = '';        $bytes = unpack('H*', $binary);        foreach ($bytes as &$byte) {            $byte = strtoupper($byte);        }        return implode('', $bytes);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_IdenticalBinaryConstraint_2137, Get the given string of bytes as a stirng of Hexadecimal sequences.\\n\\n @param string $binary\\n\\n @return string\\n, Get the given string of bytes as a stirng of Hexadecimal sequences.,"    private function asHexString($binary)    {        $hex = '';        $bytes = unpack('H*', $binary);        foreach ($bytes as &$byte) {            $byte = strtoupper($byte);        }        return implode('', $bytes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_IdenticalBinaryConstraint_237," Evaluates the constraint for parameter $other. Returns TRUE if the\n constraint is met, FALSE otherwise.\n\n @param mixed $other value or object to evaluate\n", Evaluates the constraint for parameter $other. Returns TRUE if the,    public function matches($other): bool    {        $aHex = $this->asHexString($this->value);        $bHex = $this->asHexString($other);        return $aHex === $bHex;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_IdenticalBinaryConstraint_238, Returns a string representation of the constraint.\\n, Returns a string representation of the constraint.,    public function toString(): string    {        return 'identical binary';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_SwiftMailerSmokeTestCase_1301, Base test for smoke tests.\\n\\n @author Rouven Weßling\\n, Base test for smoke tests.,class SwiftMailerSmokeTestCase extends SwiftMailerTestCase{    protected function setUp()    {        if (!\defined('SWIFT_SMOKE_TRANSPORT_TYPE')) {            $this->markTestSkipped(                'Smoke tests are skipped if tests/smoke.conf.php is not edited'             );        }    }    protected function getMailer()    {        switch (SWIFT_SMOKE_TRANSPORT_TYPE) {            case 'smtp':                $transport = Swift_DependencyContainer::getInstance()->lookup('transport.smtp')                    ->setHost(SWIFT_SMOKE_SMTP_HOST)                    ->setPort(SWIFT_SMOKE_SMTP_PORT)                    ->setUsername(SWIFT_SMOKE_SMTP_USER)                    ->setPassword(SWIFT_SMOKE_SMTP_PASS)                    ->setEncryption(SWIFT_SMOKE_SMTP_ENCRYPTION)                    ;                break;            case 'sendmail':                $transport = Swift_DependencyContainer::getInstance()->lookup('transport.sendmail')                    ->setCommand(SWIFT_SMOKE_SENDMAIL_COMMAND)                    ;                break;            case 'mail':            case 'nativemail':                $transport = Swift_DependencyContainer::getInstance()->lookup('transport.mail');                break;            default:                throw new Exception('Undefined transport ['.SWIFT_SMOKE_TRANSPORT_TYPE.']');        }        return new Swift_Mailer($transport);    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_SwiftMailerTestCase_1302, A base test case with some custom expectations.\\n\\n @author Rouven Weßling\\n, A base test case with some custom expectations.,"class SwiftMailerTestCase extends \PHPUnit\Framework\TestCase{    use MockeryPHPUnitIntegration;    public static function regExp($pattern)    {        if (!\is_string($pattern)) {            throw PHPUnit\Util\InvalidArgumentHelper::factory(1, 'string');        }        return new \PHPUnit\Framework\Constraint\RegularExpression($pattern);    }    public function assertIdenticalBinary($expected, $actual, $message = '')    {        $constraint = new IdenticalBinaryConstraint($expected);        self::assertThat($actual, $constraint, $message);    }    protected function getMockery($class)    {        return \Mockery::mock($class);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_Swift_1288, Internal autoloader for spl_autoload_register().\\n\\n @param string $class\\n, Internal autoloader for spl_autoload_register().,"    public static function autoload($class)    {        // Don't interfere with other autoloaders        if (0 !== strpos($class, 'Swift_')) {            return;        }        $path = __DIR__.'/'.str_replace('_', '/', $class).'.php';        if (!file_exists($path)) {            return;        }        require $path;        if (self::$inits && !self::$initialized) {            self::$initialized = true;            foreach (self::$inits as $init) {                \call_user_func($init);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_Swift_1614, Registers an initializer callable that will be called the first time\n a SwiftMailer class is autoloaded.\n\n This enables you to tweak the default configuration in a lazy way.\n\n @param mixed $callable A valid PHP callable that will be called when autoloading the first Swift class\n, Registers an initializer callable that will be called the first time,    public static function init($callable)    {        self::$inits[] = $callable;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swoft-cloud_swoft_AutoLoader_3516, Get namespace and dirs\n\n @return array\n, Get namespace and dirs,"    public function getPrefixDirs(): array    {        return [            __NAMESPACE__ => __DIR__,        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_AttributeMatchingExtension_3319," XPath expression translator attribute extension.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-François Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n", XPath expression translator attribute extension.,"class AttributeMatchingExtension extends AbstractExtension{    /**     * {@inheritdoc}     */    public function getAttributeMatchingTranslators(): array    {        return [            'exists' => [$this, 'translateExists'],            '=' => [$this, 'translateEquals'],            '~=' => [$this, 'translateIncludes'],            '|=' => [$this, 'translateDashMatch'],            '^=' => [$this, 'translatePrefixMatch'],            '$=' => [$this, 'translateSuffixMatch'],            '*=' => [$this, 'translateSubstringMatch'],            '!=' => [$this, 'translateDifferent'],        ];    }    public function translateExists(XPathExpr $xpath, string $attribute, ?string $value): XPathExpr    {        return $xpath->addCondition($attribute);    }    public function translateEquals(XPathExpr $xpath, string $attribute, ?string $value): XPathExpr    {        return $xpath->addCondition(sprintf('%s = %s', $attribute, Translator::getXpathLiteral($value)));    }    public function translateIncludes(XPathExpr $xpath, string $attribute, ?string $value): XPathExpr    {        return $xpath->addCondition($value ? sprintf(            '%1$s and contains(concat(\' \', normalize-space(%1$s), \' \'), %2$s)',            $attribute,            Translator::getXpathLiteral(' '.$value.' ')        ) : '0');    }    public function translateDashMatch(XPathExpr $xpath, string $attribute, ?string $value): XPathExpr    {        return $xpath->addCondition(sprintf(            '%1$s and (%1$s = %2$s or starts-with(%1$s, %3$s))',            $attribute,            Translator::getXpathLiteral($value),            Translator::getXpathLiteral($value.'-')        ));    }    public function translatePrefixMatch(XPathExpr $xpath, string $attribute, ?string $value): XPathExpr    {        return $xpath->addCondition($value ? sprintf(            '%1$s and starts-with(%1$s, %2$s)',            $attribute,            Translator::getXpathLiteral($value)        ) : '0');    }    public function translateSuffixMatch(XPathExpr $xpath, string $attribute, ?string $value): XPathExpr    {        return $xpath->addCondition($value ? sprintf(            '%1$s and substring(%1$s, string-length(%1$s)-%2$s) = %3$s',            $attribute,            \strlen($value) - 1,            Translator::getXpathLiteral($value)        ) : '0');    }    public function translateSubstringMatch(XPathExpr $xpath, string $attribute, ?string $value): XPathExpr    {        return $xpath->addCondition($value ? sprintf(            '%1$s and contains(%1$s, %2$s)',            $attribute,            Translator::getXpathLiteral($value)        ) : '0');    }    public function translateDifferent(XPathExpr $xpath, string $attribute, ?string $value): XPathExpr    {        return $xpath->addCondition(sprintf(            $value ? 'not(%1$s) or %1$s != %2$s' : '%s != %s',            $attribute,            Translator::getXpathLiteral($value)        ));    }    /**     * {@inheritdoc}     */    public function getName(): string    {        return 'attribute-matching';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_AttributeNode_3249," Represents a ""<selector>[<namespace>|<attribute> <operator> <value>]"" node.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-François Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n"," Represents a ""<selector>[<namespace>|<attribute> <operator> <value>]"" node.","class AttributeNode extends AbstractNode{    private $selector;    private $namespace;    private $attribute;    private $operator;    private $value;    public function __construct(NodeInterface $selector, ?string $namespace, string $attribute, string $operator, ?string $value)    {        $this->selector = $selector;        $this->namespace = $namespace;        $this->attribute = $attribute;        $this->operator = $operator;        $this->value = $value;    }    public function getSelector(): NodeInterface    {        return $this->selector;    }    public function getNamespace(): ?string    {        return $this->namespace;    }    public function getAttribute(): string    {        return $this->attribute;    }    public function getOperator(): string    {        return $this->operator;    }    public function getValue(): ?string    {        return $this->value;    }    /**     * {@inheritdoc}     */    public function getSpecificity(): Specificity    {        return $this->selector->getSpecificity()->plus(new Specificity(0, 1, 0));    }    /**     * {@inheritdoc}     */    public function __toString(): string    {        $attribute = $this->namespace ? $this->namespace.'|'.$this->attribute : $this->attribute;        return 'exists' === $this->operator            ? sprintf('%s[%s[%s]]', $this->getNodeName(), $this->selector, $attribute)            : sprintf(""%s[%s[%s %s '%s']]"", $this->getNodeName(), $this->selector, $attribute, $this->operator, $this->value);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_CssSelectorConverter_3238, CssSelectorConverter is the main entry point of the component and can convert CSS\n selectors to XPath expressions.\n\n @author Christophe Coevoet <stof@notk.org>\n, CssSelectorConverter is the main entry point of the component and can convert CSS,"class CssSelectorConverter{    private $translator;    private $cache;    private static $xmlCache = [];    private static $htmlCache = [];    /**     * @param bool $html Whether HTML support should be enabled. Disable it for XML documents     */    public function __construct(bool $html = true)    {        $this->translator = new Translator();        if ($html) {            $this->translator->registerExtension(new HtmlExtension($this->translator));            $this->cache = &self::$htmlCache;        } else {            $this->cache = &self::$xmlCache;        }        $this->translator            ->registerParserShortcut(new EmptyStringParser())            ->registerParserShortcut(new ElementParser())            ->registerParserShortcut(new ClassParser())            ->registerParserShortcut(new HashParser())        ;    }    /**     * Translates a CSS expression to its XPath equivalent.     *     * Optionally, a prefix can be added to the resulting XPath     * expression with the $prefix parameter.     *     * @return string     */    public function toXPath(string $cssExpr, string $prefix = 'descendant-or-self::')    {        return $this->cache[$prefix][$cssExpr] ?? $this->cache[$prefix][$cssExpr] = $this->translator->cssToXPath($cssExpr, $prefix);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_HashHandler_3292," CSS selector comment handler.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-François Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n", CSS selector comment handler.,"class HashHandler implements HandlerInterface{    private $patterns;    private $escaping;    public function __construct(TokenizerPatterns $patterns, TokenizerEscaping $escaping)    {        $this->patterns = $patterns;        $this->escaping = $escaping;    }    /**     * {@inheritdoc}     */    public function handle(Reader $reader, TokenStream $stream): bool    {        $match = $reader->findPattern($this->patterns->getHashPattern());        if (!$match) {            return false;        }        $value = $this->escaping->escapeUnicode($match[1]);        $stream->push(new Token(Token::TYPE_HASH, $value, $reader->getPosition()));        $reader->moveForward(\strlen($match[0]));        return true;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_ParseException_3241," ParseException is thrown when a CSS selector syntax is not valid.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Fabien Potencier <fabien@symfony.com>\n", ParseException is thrown when a CSS selector syntax is not valid.,class ParseException extends \Exception implements ExceptionInterface{},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_TokenStream_3281," CSS selector token stream.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-François Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n", CSS selector token stream.,"class TokenStream{    /**     * @var Token[]     */    private $tokens = [];    /**     * @var Token[]     */    private $used = [];    /**     * @var int     */    private $cursor = 0;    /**     * @var Token|null     */    private $peeked;    /**     * @var bool     */    private $peeking = false;    /**     * Pushes a token.     *     * @return $this     */    public function push(Token $token): self    {        $this->tokens[] = $token;        return $this;    }    /**     * Freezes stream.     *     * @return $this     */    public function freeze(): self    {        return $this;    }    /**     * Returns next token.     *     * @throws InternalErrorException If there is no more token     */    public function getNext(): Token    {        if ($this->peeking) {            $this->peeking = false;            $this->used[] = $this->peeked;            return $this->peeked;        }        if (!isset($this->tokens[$this->cursor])) {            throw new InternalErrorException('Unexpected token stream end.');        }        return $this->tokens[$this->cursor++];    }    /**     * Returns peeked token.     */    public function getPeek(): Token    {        if (!$this->peeking) {            $this->peeked = $this->getNext();            $this->peeking = true;        }        return $this->peeked;    }    /**     * Returns used tokens.     *     * @return Token[]     */    public function getUsed(): array    {        return $this->used;    }    /**     * Returns nex identifier token.     *     * @return string The identifier token value     *     * @throws SyntaxErrorException If next token is not an identifier     */    public function getNextIdentifier(): string    {        $next = $this->getNext();        if (!$next->isIdentifier()) {            throw SyntaxErrorException::unexpectedToken('identifier', $next);        }        return $next->getValue();    }    /**     * Returns nex identifier or star delimiter token.     *     * @return string|null The identifier token value or null if star found     *     * @throws SyntaxErrorException If next token is not an identifier or a star delimiter     */    public function getNextIdentifierOrStar(): ?string    {        $next = $this->getNext();        if ($next->isIdentifier()) {            return $next->getValue();        }        if ($next->isDelimiter(['*'])) {            return null;        }        throw SyntaxErrorException::unexpectedToken('identifier or ""*""', $next);    }    /**     * Skips next whitespace if any.     */    public function skipWhitespace()    {        $peek = $this->getPeek();        if ($peek->isWhitespace()) {            $this->getNext();        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_TokenStream_3284, Returns next token.\n\n @throws InternalErrorException If there is no more token\n, Returns next token.,    public function getNext(): Token    {        if ($this->peeking) {            $this->peeking = false;            $this->used[] = $this->peeked;            return $this->peeked;        }        if (!isset($this->tokens[$this->cursor])) {            throw new InternalErrorException('Unexpected token stream end.');        }        return $this->tokens[$this->cursor++];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_XPathExpr_3311," XPath expression translator interface.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-François Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n", XPath expression translator interface.,"class XPathExpr{    private $path;    private $element;    private $condition;    public function __construct(string $path = '', string $element = '*', string $condition = '', bool $starPrefix = false)    {        $this->path = $path;        $this->element = $element;        $this->condition = $condition;        if ($starPrefix) {            $this->addStarPrefix();        }    }    public function getElement(): string    {        return $this->element;    }    public function addCondition(string $condition): self    {        $this->condition = $this->condition ? sprintf('(%s) and (%s)', $this->condition, $condition) : $condition;        return $this;    }    public function getCondition(): string    {        return $this->condition;    }    public function addNameTest(): self    {        if ('*' !== $this->element) {            $this->addCondition('name() = '.Translator::getXpathLiteral($this->element));            $this->element = '*';        }        return $this;    }    public function addStarPrefix(): self    {        $this->path .= '*/';        return $this;    }    /**     * Joins another XPathExpr with a combiner.     *     * @return $this     */    public function join(string $combiner, self $expr): self    {        $path = $this->__toString().$combiner;        if ('*/' !== $expr->path) {            $path .= $expr->path;        }        $this->path = $path;        $this->element = $expr->element;        $this->condition = $expr->condition;        return $this;    }    public function __toString(): string    {        $path = $this->path.$this->element;        $condition = null === $this->condition || '' === $this->condition ? '' : '['.$this->condition.']';        return $path.$condition;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ClassNotFoundException_2261," Class (or Trait or Interface) Not Found Exception.\n\n @author Konstanton Myakshin <koc-dp@yandex.ru>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\Error\\ClassNotFoundError instead.\n", Class (or Trait or Interface) Not Found Exception.,"class ClassNotFoundException extends FatalErrorException{    public function __construct(string $message, \ErrorException $previous)    {        parent::__construct(            $message,            $previous->getCode(),            $previous->getSeverity(),            $previous->getFile(),            $previous->getLine(),            null,            true,            null,            $previous->getPrevious()        );        $this->setTrace($previous->getTrace());    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ClassNotFoundFatalErrorHandler_1769," ErrorHandler for classes that do not exist.\n\n @author Fabien Potencier <fabien@symfony.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\FatalErrorHandler\\ClassNotFoundFatalErrorHandler instead.\n", ErrorHandler for classes that do not exist.,"class ClassNotFoundFatalErrorHandler implements FatalErrorHandlerInterface{    /**     * {@inheritdoc}     */    public function handleError(array $error, FatalErrorException $exception)    {        if (!preg_match('/^(Class|Interface|Trait) [\'""]([^\'""]+)[\'""] not found$/', $error['message'], $matches)) {            return null;        }        $typeName = strtolower($matches[1]);        $fullyQualifiedClassName = $matches[2];        if (false !== $namespaceSeparatorIndex = strrpos($fullyQualifiedClassName, '\\')) {            $className = substr($fullyQualifiedClassName, $namespaceSeparatorIndex + 1);            $namespacePrefix = substr($fullyQualifiedClassName, 0, $namespaceSeparatorIndex);            $message = sprintf('Attempted to load %s ""%s"" from namespace ""%s"".', $typeName, $className, $namespacePrefix);            $tail = ' for another namespace?';        } else {            $className = $fullyQualifiedClassName;            $message = sprintf('Attempted to load %s ""%s"" from the global namespace.', $typeName, $className);            $tail = '?';        }        if ($candidates = $this->getClassCandidates($className)) {            $tail = array_pop($candidates).'""?';            if ($candidates) {                $tail = ' for e.g. ""'.implode('"", ""', $candidates).'"" or ""'.$tail;            } else {                $tail = ' for ""'.$tail;            }        }        $message .= ""\nDid you forget a \""use\"" statement"".$tail;        return new ClassNotFoundException($message, $exception);    }    /**     * Tries to guess the full namespace for a given class name.     *     * By default, it looks for PSR-0 and PSR-4 classes registered via a Symfony or a Composer     * autoloader (that should cover all common cases).     *     * @param string $class A class name (without its namespace)     *     * @return array An array of possible fully qualified class names     */    private function getClassCandidates(string $class): array    {        if (!\is_array($functions = spl_autoload_functions())) {            return [];        }        // find Symfony and Composer autoloaders        $classes = [];        foreach ($functions as $function) {            if (!\is_array($function)) {                continue;            }            // get class loaders wrapped by DebugClassLoader            if ($function[0] instanceof DebugClassLoader) {                $function = $function[0]->getClassLoader();                if (!\is_array($function)) {                    continue;                }            }            if ($function[0] instanceof ComposerClassLoader || $function[0] instanceof SymfonyClassLoader) {                foreach ($function[0]->getPrefixes() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }            if ($function[0] instanceof ComposerClassLoader) {                foreach ($function[0]->getPrefixesPsr4() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }        }        return array_unique($classes);    }    private function findClassInPath(string $path, string $class, string $prefix): array    {        if (!$path = realpath($path.'/'.strtr($prefix, '\\_', '//')) ?: realpath($path.'/'.\dirname(strtr($prefix, '\\_', '//'))) ?: realpath($path)) {            return [];        }        $classes = [];        $filename = $class.'.php';        foreach (new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS), \RecursiveIteratorIterator::LEAVES_ONLY) as $file) {            if ($filename == $file->getFileName() && $class = $this->convertFileToClass($path, $file->getPathName(), $prefix)) {                $classes[] = $class;            }        }        return $classes;    }    private function convertFileToClass(string $path, string $file, string $prefix): ?string    {        $candidates = [            // namespaced class            $namespacedClass = str_replace([$path.\DIRECTORY_SEPARATOR, '.php', '/'], ['', '', '\\'], $file),            // namespaced class (with target dir)            $prefix.$namespacedClass,            // namespaced class (with target dir and separator)            $prefix.'\\'.$namespacedClass,            // PEAR class            str_replace('\\', '_', $namespacedClass),            // PEAR class (with target dir)            str_replace('\\', '_', $prefix.$namespacedClass),            // PEAR class (with target dir and separator)            str_replace('\\', '_', $prefix.'\\'.$namespacedClass),        ];        if ($prefix) {            $candidates = array_filter($candidates, function ($candidate) use ($prefix) { return 0 === strpos($candidate, $prefix); });        }        // We cannot use the autoloader here as most of them use require; but if the class        // is not found, the new autoloader call will require the file again leading to a        // ""cannot redeclare class"" error.        foreach ($candidates as $candidate) {            if ($this->classExists($candidate)) {                return $candidate;            }        }        try {            require_once $file;        } catch (\Throwable $e) {            return null;        }        foreach ($candidates as $candidate) {            if ($this->classExists($candidate)) {                return $candidate;            }        }        return null;    }    private function classExists(string $class): bool    {        return class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ClassNotFoundFatalErrorHandler_1771," Tries to guess the full namespace for a given class name.\\n\\n By default, it looks for PSR-0 and PSR-4 classes registered via a Symfony or a Composer\\n autoloader (that should cover all common cases).\\n\\n @param string $class A class name (without its namespace)\\n\\n @return array An array of possible fully qualified class names\\n", Tries to guess the full namespace for a given class name.,"    private function getClassCandidates(string $class): array    {        if (!\is_array($functions = spl_autoload_functions())) {            return [];        }        // find Symfony and Composer autoloaders        $classes = [];        foreach ($functions as $function) {            if (!\is_array($function)) {                continue;            }            // get class loaders wrapped by DebugClassLoader            if ($function[0] instanceof DebugClassLoader) {                $function = $function[0]->getClassLoader();                if (!\is_array($function)) {                    continue;                }            }            if ($function[0] instanceof ComposerClassLoader || $function[0] instanceof SymfonyClassLoader) {                foreach ($function[0]->getPrefixes() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }            if ($function[0] instanceof ComposerClassLoader) {                foreach ($function[0]->getPrefixesPsr4() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }        }        return array_unique($classes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_DebugClassLoader_1727," Autoloader checking if the class is really defined in the file found.\\n\\n The ClassLoader will wrap all registered autoloaders\\n and will throw an exception if a file is found but does\\n not declare the class.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n @author Christophe Coevoet <stof@notk.org>\\n @author Nicolas Grekas <p@tchwork.com>\\n @author Guilhem Niot <guilhem.niot@gmail.com>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\DebugClassLoader instead.\\n", Autoloader checking if the class is really defined in the file found.,"class DebugClassLoader{    private $classLoader;    private $isFinder;    private $loaded = [];    private static $caseCheck;    private static $checkedClasses = [];    private static $final = [];    private static $finalMethods = [];    private static $deprecated = [];    private static $internal = [];    private static $internalMethods = [];    private static $annotatedParameters = [];    private static $darwinCache = ['/' => ['/', []]];    private static $method = [];    public function __construct(callable $classLoader)    {        $this->classLoader = $classLoader;        $this->isFinder = \is_array($classLoader) && method_exists($classLoader[0], 'findFile');        if (!isset(self::$caseCheck)) {            $file = file_exists(__FILE__) ? __FILE__ : rtrim(realpath('.'), \DIRECTORY_SEPARATOR);            $i = strrpos($file, \DIRECTORY_SEPARATOR);            $dir = substr($file, 0, 1 + $i);            $file = substr($file, 1 + $i);            $test = strtoupper($file) === $file ? strtolower($file) : strtoupper($file);            $test = realpath($dir.$test);            if (false === $test || false === $i) {                // filesystem is case sensitive                self::$caseCheck = 0;            } elseif (substr($test, -\strlen($file)) === $file) {                // filesystem is case insensitive and realpath() normalizes the case of characters                self::$caseCheck = 1;            } elseif (false !== stripos(\PHP_OS, 'darwin')) {                // on MacOSX, HFS+ is case insensitive but realpath() doesn't normalize the case of characters                self::$caseCheck = 2;            } else {                // filesystem case checks failed, fallback to disabling them                self::$caseCheck = 0;            }        }    }    /**     * Gets the wrapped class loader.     *     * @return callable The wrapped class loader     */    public function getClassLoader()    {        return $this->classLoader;    }    /**     * Wraps all autoloaders.     */    public static function enable()    {        // Ensures we don't hit https://bugs.php.net/42098        class_exists(\Symfony\Component\Debug\ErrorHandler::class);        class_exists(\Psr\Log\LogLevel::class);        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (!\is_array($function) || !$function[0] instanceof self) {                $function = [new static($function), 'loadClass'];            }            spl_autoload_register($function);        }    }    /**     * Disables the wrapping.     */    public static function disable()    {        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (\is_array($function) && $function[0] instanceof self) {                $function = $function[0]->getClassLoader();            }            spl_autoload_register($function);        }    }    /**     * @return string|null     */    public function findFile($class)    {        return $this->isFinder ? $this->classLoader[0]->findFile($class) ?: null : null;    }    /**     * Loads the given class or interface.     *     * @param string $class The name of the class     *     * @throws \RuntimeException     */    public function loadClass($class)    {        $e = error_reporting(error_reporting() | \E_PARSE | \E_ERROR | \E_CORE_ERROR | \E_COMPILE_ERROR);        try {            if ($this->isFinder && !isset($this->loaded[$class])) {                $this->loaded[$class] = true;                if (!$file = $this->classLoader[0]->findFile($class) ?: false) {                    // no-op                } elseif (\function_exists('opcache_is_script_cached') && @opcache_is_script_cached($file)) {                    include $file;                    return;                } elseif (false === include $file) {                    return;                }            } else {                ($this->classLoader)($class);                $file = false;            }        } finally {            error_reporting($e);        }        $this->checkClass($class, $file);    }    private function checkClass(string $class, string $file = null)    {        $exists = null === $file || class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);        if (null !== $file && $class && '\\' === $class[0]) {            $class = substr($class, 1);        }        if ($exists) {            if (isset(self::$checkedClasses[$class])) {                return;            }            self::$checkedClasses[$class] = true;            $refl = new \ReflectionClass($class);            if (null === $file && $refl->isInternal()) {                return;            }            $name = $refl->getName();            if ($name !== $class && 0 === strcasecmp($name, $class)) {                throw new \RuntimeException(sprintf('Case mismatch between loaded and declared class names: ""%s"" vs ""%s"".', $class, $name));            }            $deprecations = $this->checkAnnotations($refl, $name);            foreach ($deprecations as $message) {                @trigger_error($message, \E_USER_DEPRECATED);            }        }        if (!$file) {            return;        }        if (!$exists) {            if (false !== strpos($class, '/')) {                throw new \RuntimeException(sprintf('Trying to autoload a class with an invalid name ""%s"". Be careful that the namespace separator is ""\"" in PHP, not ""/"".', $class));            }            throw new \RuntimeException(sprintf('The autoloader expected class ""%s"" to be defined in file ""%s"". The file was found but the class was not in it, the class name or namespace probably has a typo.', $class, $file));        }        if (self::$caseCheck && $message = $this->checkCase($refl, $file, $class)) {            throw new \RuntimeException(sprintf('Case mismatch between class and real file names: ""%s"" vs ""%s"" in ""%s"".', $message[0], $message[1], $message[2]));        }    }    public function checkAnnotations(\ReflectionClass $refl, $class)    {        $deprecations = [];        // Don't trigger deprecations for classes in the same vendor        if (2 > $len = 1 + (strpos($class, '\\') ?: strpos($class, '_'))) {            $len = 0;            $ns = '';        } else {            $ns = str_replace('_', '\\', substr($class, 0, $len));        }        // Detect annotations on the class        if (false !== $doc = $refl->getDocComment()) {            foreach (['final', 'deprecated', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    self::${$annotation}[$class] = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                }            }            if ($refl->isInterface() && false !== strpos($doc, 'method') && preg_match_all('#\n \* @method\s+(static\s+)?+(?:[\w\|&\[\]\\\]+\s+)?(\w+(?:\s*\([^\)]*\))?)+(.+?([[:punct:]]\s*)?)?(?=\r?\n \*(?: @|/$|\r?\n))#', $doc, $notice, \PREG_SET_ORDER)) {                foreach ($notice as $method) {                    $static = '' !== $method[1];                    $name = $method[2];                    $description = $method[3] ?? null;                    if (false === strpos($name, '(')) {                        $name .= '()';                    }                    if (null !== $description) {                        $description = trim($description);                        if (!isset($method[4])) {                            $description .= '.';                        }                    }                    self::$method[$class][] = [$class, $name, $static, $description];                }            }        }        $parent = get_parent_class($class);        $parentAndOwnInterfaces = $this->getOwnInterfaces($class, $parent ?: null);        if ($parent) {            $parentAndOwnInterfaces[$parent] = $parent;            if (!isset(self::$checkedClasses[$parent])) {                $this->checkClass($parent);            }            if (isset(self::$final[$parent])) {                $deprecations[] = sprintf('The ""%s"" class is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $parent, self::$final[$parent], $class);            }        }        // Detect if the parent is annotated        foreach ($parentAndOwnInterfaces + class_uses($class, false) as $use) {            if (!isset(self::$checkedClasses[$use])) {                $this->checkClass($use);            }            if (isset(self::$deprecated[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len) && !isset(self::$deprecated[$class])) {                $type = class_exists($class, false) ? 'class' : (interface_exists($class, false) ? 'interface' : 'trait');                $verb = class_exists($use, false) || interface_exists($class, false) ? 'extends' : (interface_exists($use, false) ? 'implements' : 'uses');                $deprecations[] = sprintf('The ""%s"" %s %s ""%s"" that is deprecated%s.', $class, $type, $verb, $use, self::$deprecated[$use]);            }            if (isset(self::$internal[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len)) {                $deprecations[] = sprintf('The ""%s"" %s is considered internal%s. It may change without further notice. You should not use it from ""%s"".', $use, class_exists($use, false) ? 'class' : (interface_exists($use, false) ? 'interface' : 'trait'), self::$internal[$use], $class);            }            if (isset(self::$method[$use])) {                if ($refl->isAbstract()) {                    if (isset(self::$method[$class])) {                        self::$method[$class] = array_merge(self::$method[$class], self::$method[$use]);                    } else {                        self::$method[$class] = self::$method[$use];                    }                } elseif (!$refl->isInterface()) {                    $hasCall = $refl->hasMethod('__call');                    $hasStaticCall = $refl->hasMethod('__callStatic');                    foreach (self::$method[$use] as $method) {                        [$interface, $name, $static, $description] = $method;                        if ($static ? $hasStaticCall : $hasCall) {                            continue;                        }                        $realName = substr($name, 0, strpos($name, '('));                        if (!$refl->hasMethod($realName) || !($methodRefl = $refl->getMethod($realName))->isPublic() || ($static && !$methodRefl->isStatic()) || (!$static && $methodRefl->isStatic())) {                            $deprecations[] = sprintf('Class ""%s"" should implement method ""%s::%s""%s', $class, ($static ? 'static ' : '').$interface, $name, null == $description ? '.' : ': '.$description);                        }                    }                }            }        }        if (trait_exists($class)) {            return $deprecations;        }        // Inherit @final, @internal and @param annotations for methods        self::$finalMethods[$class] = [];        self::$internalMethods[$class] = [];        self::$annotatedParameters[$class] = [];        foreach ($parentAndOwnInterfaces as $use) {            foreach (['finalMethods', 'internalMethods', 'annotatedParameters'] as $property) {                if (isset(self::${$property}[$use])) {                    self::${$property}[$class] = self::${$property}[$class] ? self::${$property}[$use] + self::${$property}[$class] : self::${$property}[$use];                }            }        }        foreach ($refl->getMethods(\ReflectionMethod::IS_PUBLIC | \ReflectionMethod::IS_PROTECTED) as $method) {            if ($method->class !== $class) {                continue;            }            if ($parent && isset(self::$finalMethods[$parent][$method->name])) {                [$declaringClass, $message] = self::$finalMethods[$parent][$method->name];                $deprecations[] = sprintf('The ""%s::%s()"" method is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);            }            if (isset(self::$internalMethods[$class][$method->name])) {                [$declaringClass, $message] = self::$internalMethods[$class][$method->name];                if (strncmp($ns, $declaringClass, $len)) {                    $deprecations[] = sprintf('The ""%s::%s()"" method is considered internal%s. It may change without further notice. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);                }            }            // To read method annotations            $doc = $method->getDocComment();            if (isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }                foreach (self::$annotatedParameters[$class][$method->name] as $parameterName => $deprecation) {                    if (!isset($definedParameters[$parameterName]) && !($doc && preg_match(""/\\n\\s+\\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\\\${$parameterName}\\b/"", $doc))) {                        $deprecations[] = sprintf($deprecation, $class);                    }                }            }            if (!$doc) {                continue;            }            $finalOrInternal = false;            foreach (['final', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    $message = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                    self::${$annotation.'Methods'}[$class][$method->name] = [$class, $message];                    $finalOrInternal = true;                }            }            if ($finalOrInternal || $method->isConstructor() || false === strpos($doc, '@param') || StatelessInvocation::class === $class) {                continue;            }            if (!preg_match_all('#\n\s+\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\$([a-zA-Z0-9_\x7f-\xff]++)#', $doc, $matches, \PREG_SET_ORDER)) {                continue;            }            if (!isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }            }            foreach ($matches as [, $parameterType, $parameterName]) {                if (!isset($definedParameters[$parameterName])) {                    $parameterType = trim($parameterType);                    self::$annotatedParameters[$class][$method->name][$parameterName] = sprintf('The ""%%s::%s()"" method will require a new ""%s$%s"" argument in the next major version of its %s ""%s"", not defining it is deprecated.', $method->name, $parameterType ? $parameterType.' ' : '', $parameterName, interface_exists($class) ? 'interface' : 'parent class', $method->class);                }            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_DebugClassLoader_1732, Loads the given class or interface.\n\n @param string $class The name of the class\n\n @throws \\RuntimeException\n, Loads the given class or interface.,"    public function loadClass($class)    {        $e = error_reporting(error_reporting() | \E_PARSE | \E_ERROR | \E_CORE_ERROR | \E_COMPILE_ERROR);        try {            if ($this->isFinder && !isset($this->loaded[$class])) {                $this->loaded[$class] = true;                if (!$file = $this->classLoader[0]->findFile($class) ?: false) {                    // no-op                } elseif (\function_exists('opcache_is_script_cached') && @opcache_is_script_cached($file)) {                    include $file;                    return;                } elseif (false === include $file) {                    return;                }            } else {                ($this->classLoader)($class);                $file = false;            }        } finally {            error_reporting($e);        }        $this->checkClass($class, $file);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_DebugClassLoader_2240, Disables the wrapping.\\n, Disables the wrapping.,    public static function disable()    {        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (\is_array($function) && $function[0] instanceof self) {                $function = $function[0]->getClassLoader();            }            spl_autoload_register($function);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_DebugClassLoader_2244, `realpath` on MacOSX doesn't normalize the case of characters.\\n, `realpath` on MacOSX doesn't normalize the case of characters.,"    private function darwinRealpath(string $real): string    {        $i = 1 + strrpos($real, '/');        $file = substr($real, $i);        $real = substr($real, 0, $i);        if (isset(self::$darwinCache[$real])) {            $kDir = $real;        } else {            $kDir = strtolower($real);            if (isset(self::$darwinCache[$kDir])) {                $real = self::$darwinCache[$kDir][0];            } else {                $dir = getcwd();                if (!@chdir($real)) {                    return $real.$file;                }                $real = getcwd().'/';                chdir($dir);                $dir = $real;                $k = $kDir;                $i = \strlen($dir) - 1;                while (!isset(self::$darwinCache[$k])) {                    self::$darwinCache[$k] = [$dir, []];                    self::$darwinCache[$dir] = &self::$darwinCache[$k];                    while ('/' !== $dir[--$i]) {                    }                    $k = substr($k, 0, ++$i);                    $dir = substr($dir, 0, $i--);                }            }        }        $dirFiles = self::$darwinCache[$kDir][1];        if (!isset($dirFiles[$file]) && ') : eval()\'d code' === substr($file, -17)) {            // Get the file name from ""file_name.php(123) : eval()'d code""            $file = substr($file, 0, strrpos($file, '(', -17));        }        if (isset($dirFiles[$file])) {            return $real.$dirFiles[$file];        }        $kFile = strtolower($file);        if (!isset($dirFiles[$kFile])) {            foreach (scandir($real, 2) as $f) {                if ('.' !== $f[0]) {                    $dirFiles[$f] = $f;                    if ($f === $file) {                        $kFile = $k = $file;                    } elseif ($f !== $k = strtolower($f)) {                        $dirFiles[$k] = $f;                    }                }            }            self::$darwinCache[$kDir][1] = $dirFiles;        }        return $real.$dirFiles[$kFile];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_Debug_2236," Registers all the debug tools.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\Debug instead.\\n", Registers all the debug tools.,"class Debug{    private static $enabled = false;    /**     * Enables the debug tools.     *     * This method registers an error handler and an exception handler.     *     * @param int  $errorReportingLevel The level of error reporting you want     * @param bool $displayErrors       Whether to display errors (for development) or just log them (for production)     */    public static function enable($errorReportingLevel = \E_ALL, $displayErrors = true)    {        if (static::$enabled) {            return;        }        static::$enabled = true;        if (null !== $errorReportingLevel) {            error_reporting($errorReportingLevel);        } else {            error_reporting(\E_ALL);        }        if (!\in_array(\PHP_SAPI, ['cli', 'phpdbg'], true)) {            ini_set('display_errors', 0);            ExceptionHandler::register();        } elseif ($displayErrors && (!filter_var(ini_get('log_errors'), \FILTER_VALIDATE_BOOLEAN) || ini_get('error_log'))) {            // CLI - display errors only if they're not already logged to STDERR            ini_set('display_errors', 1);        }        if ($displayErrors) {            ErrorHandler::register(new ErrorHandler(new BufferingLogger()));        } else {            ErrorHandler::register()->throwAt(0, true);        }        DebugClassLoader::enable();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ErrorHandlerTest_2291, dummy function to test trace in error handler.\n, dummy function to test trace in error handler.,"    private static function triggerNotice($that)    {        $that->assertSame('', $foo.$foo.$bar);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ErrorHandler_1736," A generic ErrorHandler for the PHP engine.\\n\\n Provides five bit fields that control how errors are handled:\\n - thrownErrors: errors thrown as \\\\ErrorException\\n - loggedErrors: logged errors, when not @-silenced\\n - scopedErrors: errors thrown or logged with their local context\\n - tracedErrors: errors logged with their stack trace\\n - screamedErrors: never @-silenced errors\\n\\n Each error level can be logged by a dedicated PSR-3 logger object.\\n Screaming only applies to logging.\\n Throwing takes precedence over logging.\\n Uncaught exceptions are logged as E_ERROR.\\n E_DEPRECATED and E_USER_DEPRECATED levels never throw.\\n E_RECOVERABLE_ERROR and E_USER_ERROR levels always throw.\\n Non catchable errors that can be detected at shutdown time are logged when the scream bit field allows so.\\n As errors have a performance cost, repeated errors are all logged, so that the developer\\n can see them and weight them as more important to fix than others of the same level.\\n\\n @author Nicolas Grekas <p@tchwork.com>\\n @author Grégoire Pineau <lyrixx@lyrixx.info>\\n\\n @final since Symfony 4.3\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\ErrorHandler instead.\\n", A generic ErrorHandler for the PHP engine.,"class ErrorHandler{    private $levels = [        \E_DEPRECATED => 'Deprecated',        \E_USER_DEPRECATED => 'User Deprecated',        \E_NOTICE => 'Notice',        \E_USER_NOTICE => 'User Notice',        \E_STRICT => 'Runtime Notice',        \E_WARNING => 'Warning',        \E_USER_WARNING => 'User Warning',        \E_COMPILE_WARNING => 'Compile Warning',        \E_CORE_WARNING => 'Core Warning',        \E_USER_ERROR => 'User Error',        \E_RECOVERABLE_ERROR => 'Catchable Fatal Error',        \E_COMPILE_ERROR => 'Compile Error',        \E_PARSE => 'Parse Error',        \E_ERROR => 'Error',        \E_CORE_ERROR => 'Core Error',    ];    private $loggers = [        \E_DEPRECATED => [null, LogLevel::INFO],        \E_USER_DEPRECATED => [null, LogLevel::INFO],        \E_NOTICE => [null, LogLevel::WARNING],        \E_USER_NOTICE => [null, LogLevel::WARNING],        \E_STRICT => [null, LogLevel::WARNING],        \E_WARNING => [null, LogLevel::WARNING],        \E_USER_WARNING => [null, LogLevel::WARNING],        \E_COMPILE_WARNING => [null, LogLevel::WARNING],        \E_CORE_WARNING => [null, LogLevel::WARNING],        \E_USER_ERROR => [null, LogLevel::CRITICAL],        \E_RECOVERABLE_ERROR => [null, LogLevel::CRITICAL],        \E_COMPILE_ERROR => [null, LogLevel::CRITICAL],        \E_PARSE => [null, LogLevel::CRITICAL],        \E_ERROR => [null, LogLevel::CRITICAL],        \E_CORE_ERROR => [null, LogLevel::CRITICAL],    ];    private $thrownErrors = 0x1FFF; // E_ALL - E_DEPRECATED - E_USER_DEPRECATED    private $scopedErrors = 0x1FFF; // E_ALL - E_DEPRECATED - E_USER_DEPRECATED    private $tracedErrors = 0x77FB; // E_ALL - E_STRICT - E_PARSE    private $screamedErrors = 0x55; // E_ERROR + E_CORE_ERROR + E_COMPILE_ERROR + E_PARSE    private $loggedErrors = 0;    private $traceReflector;    private $isRecursive = 0;    private $isRoot = false;    private $exceptionHandler;    private $bootstrappingLogger;    private static $reservedMemory;    private static $toStringException = null;    private static $silencedErrorCache = [];    private static $silencedErrorCount = 0;    private static $exitCode = 0;    /**     * Registers the error handler.     *     * @param self|null $handler The handler to register     * @param bool      $replace Whether to replace or not any existing handler     *     * @return self The registered error handler     */    public static function register(self $handler = null, $replace = true)    {        if (null === self::$reservedMemory) {            self::$reservedMemory = str_repeat('x', 10240);            register_shutdown_function(__CLASS__.'::handleFatalError');        }        if ($handlerIsNew = null === $handler) {            $handler = new static();        }        if (null === $prev = set_error_handler([$handler, 'handleError'])) {            restore_error_handler();            // Specifying the error types earlier would expose us to https://bugs.php.net/63206            set_error_handler([$handler, 'handleError'], $handler->thrownErrors | $handler->loggedErrors);            $handler->isRoot = true;        }        if ($handlerIsNew && \is_array($prev) && $prev[0] instanceof self) {            $handler = $prev[0];            $replace = false;        }        if (!$replace && $prev) {            restore_error_handler();            $handlerIsRegistered = \is_array($prev) && $handler === $prev[0];        } else {            $handlerIsRegistered = true;        }        if (\is_array($prev = set_exception_handler([$handler, 'handleException'])) && $prev[0] instanceof self) {            restore_exception_handler();            if (!$handlerIsRegistered) {                $handler = $prev[0];            } elseif ($handler !== $prev[0] && $replace) {                set_exception_handler([$handler, 'handleException']);                $p = $prev[0]->setExceptionHandler(null);                $handler->setExceptionHandler($p);                $prev[0]->setExceptionHandler($p);            }        } else {            $handler->setExceptionHandler($prev);        }        $handler->throwAt(\E_ALL & $handler->thrownErrors, true);        return $handler;    }    public function __construct(BufferingLogger $bootstrappingLogger = null)    {        if ($bootstrappingLogger) {            $this->bootstrappingLogger = $bootstrappingLogger;            $this->setDefaultLogger($bootstrappingLogger);        }        $this->traceReflector = new \ReflectionProperty(\Exception::class, 'trace');        $this->traceReflector->setAccessible(true);    }    /**     * Sets a logger to non assigned errors levels.     *     * @param array|int $levels  An array map of E_* to LogLevel::* or an integer bit field of E_* constants     * @param bool      $replace Whether to replace or not any existing logger     */    public function setDefaultLogger(LoggerInterface $logger, $levels = \E_ALL, $replace = false)    {        $loggers = [];        if (\is_array($levels)) {            foreach ($levels as $type => $logLevel) {                if (empty($this->loggers[$type][0]) || $replace || $this->loggers[$type][0] === $this->bootstrappingLogger) {                    $loggers[$type] = [$logger, $logLevel];                }            }        } else {            if (null === $levels) {                $levels = \E_ALL;            }            foreach ($this->loggers as $type => $log) {                if (($type & $levels) && (empty($log[0]) || $replace || $log[0] === $this->bootstrappingLogger)) {                    $log[0] = $logger;                    $loggers[$type] = $log;                }            }        }        $this->setLoggers($loggers);    }    /**     * Sets a logger for each error level.     *     * @param array $loggers Error levels to [LoggerInterface|null, LogLevel::*] map     *     * @return array The previous map     *     * @throws \InvalidArgumentException     */    public function setLoggers(array $loggers)    {        $prevLogged = $this->loggedErrors;        $prev = $this->loggers;        $flush = [];        foreach ($loggers as $type => $log) {            if (!isset($prev[$type])) {                throw new \InvalidArgumentException('Unknown error type: '.$type);            }            if (!\is_array($log)) {                $log = [$log];            } elseif (!\array_key_exists(0, $log)) {                throw new \InvalidArgumentException('No logger provided.');            }            if (null === $log[0]) {                $this->loggedErrors &= ~$type;            } elseif ($log[0] instanceof LoggerInterface) {                $this->loggedErrors |= $type;            } else {                throw new \InvalidArgumentException('Invalid logger provided.');            }            $this->loggers[$type] = $log + $prev[$type];            if ($this->bootstrappingLogger && $prev[$type][0] === $this->bootstrappingLogger) {                $flush[$type] = $type;            }        }        $this->reRegister($prevLogged | $this->thrownErrors);        if ($flush) {            foreach ($this->bootstrappingLogger->cleanLogs() as $log) {                $type = $log[2]['exception'] instanceof \ErrorException ? $log[2]['exception']->getSeverity() : \E_ERROR;                if (!isset($flush[$type])) {                    $this->bootstrappingLogger->log($log[0], $log[1], $log[2]);                } elseif ($this->loggers[$type][0]) {                    $this->loggers[$type][0]->log($this->loggers[$type][1], $log[1], $log[2]);                }            }        }        return $prev;    }    /**     * Sets a user exception handler.     *     * @param callable $handler A handler that will be called on Exception     *     * @return callable|null The previous exception handler     */    public function setExceptionHandler(callable $handler = null)    {        $prev = $this->exceptionHandler;        $this->exceptionHandler = $handler;        return $prev;    }    /**     * Sets the PHP error levels that throw an exception when a PHP error occurs.     *     * @param int  $levels  A bit field of E_* constants for thrown errors     * @param bool $replace Replace or amend the previous value     *     * @return int The previous value     */    public function throwAt($levels, $replace = false)    {        $prev = $this->thrownErrors;        $this->thrownErrors = ($levels | \E_RECOVERABLE_ERROR | \E_USER_ERROR) & ~\E_USER_DEPRECATED & ~\E_DEPRECATED;        if (!$replace) {            $this->thrownErrors |= $prev;        }        $this->reRegister($prev | $this->loggedErrors);        return $prev;    }    /**     * Sets the PHP error levels for which local variables are preserved.     *     * @param int  $levels  A bit field of E_* constants for scoped errors     * @param bool $replace Replace or amend the previous value     *     * @return int The previous value     */    public function scopeAt($levels, $replace = false)    {        $prev = $this->scopedErrors;        $this->scopedErrors = (int) $levels;        if (!$replace) {            $this->scopedErrors |= $prev;        }        return $prev;    }    /**     * Sets the PHP error levels for which the stack trace is preserved.     *     * @param int  $levels  A bit field of E_* constants for traced errors     * @param bool $replace Replace or amend the previous value     *     * @return int The previous value     */    public function traceAt($levels, $replace = false)    {        $prev = $this->tracedErrors;        $this->tracedErrors = (int) $levels;        if (!$replace) {            $this->tracedErrors |= $prev;        }        return $prev;    }    /**     * Sets the error levels where the @-operator is ignored.     *     * @param int  $levels  A bit field of E_* constants for screamed errors     * @param bool $replace Replace or amend the previous value     *     * @return int The previous value     */    public function screamAt($levels, $replace = false)    {        $prev = $this->screamedErrors;        $this->screamedErrors = (int) $levels;        if (!$replace) {            $this->screamedErrors |= $prev;        }        return $prev;    }    /**     * Re-registers as a PHP error handler if levels changed.     */    private function reRegister(int $prev)    {        if ($prev !== $this->thrownErrors | $this->loggedErrors) {            $handler = set_error_handler('var_dump');            $handler = \is_array($handler) ? $handler[0] : null;            restore_error_handler();            if ($handler === $this) {                restore_error_handler();                if ($this->isRoot) {                    set_error_handler([$this, 'handleError'], $this->thrownErrors | $this->loggedErrors);                } else {                    set_error_handler([$this, 'handleError']);                }            }        }    }    /**     * Handles errors by filtering then logging them according to the configured bit fields.     *     * @param int    $type    One of the E_* constants     * @param string $message     * @param string $file     * @param int    $line     *     * @return bool Returns false when no handling happens so that the PHP engine can handle the error itself     *     * @throws \ErrorException When $this->thrownErrors requests so     *     * @internal     */    public function handleError($type, $message, $file, $line)    {        if (\PHP_VERSION_ID >= 70300 && \E_WARNING === $type && '""' === $message[0] && false !== strpos($message, '"" targeting switch is equivalent to ""break')) {            $type = \E_DEPRECATED;        }        // Level is the current error reporting level to manage silent error.        $level = error_reporting();        $silenced = 0 === ($level & $type);        // Strong errors are not authorized to be silenced.        $level |= \E_RECOVERABLE_ERROR | \E_USER_ERROR | \E_DEPRECATED | \E_USER_DEPRECATED;        $log = $this->loggedErrors & $type;        $throw = $this->thrownErrors & $type & $level;        $type &= $level | $this->screamedErrors;        if (!$type || (!$log && !$throw)) {            return !$silenced && $type && $log;        }        $scope = $this->scopedErrors & $type;        if (false !== strpos($message, ""@anonymous\0"")) {            $logMessage = $this->levels[$type].': '.(new FlattenException())->setMessage($message)->getMessage();        } else {            $logMessage = $this->levels[$type].': '.$message;        }        if (null !== self::$toStringException) {            $errorAsException = self::$toStringException;            self::$toStringException = null;        } elseif (!$throw && !($type & $level)) {            if (!isset(self::$silencedErrorCache[$id = $file.':'.$line])) {                $lightTrace = $this->tracedErrors & $type ? $this->cleanTrace(debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS, 5), $type, $file, $line, false) : [];                $errorAsException = new SilencedErrorContext($type, $file, $line, isset($lightTrace[1]) ? [$lightTrace[0]] : $lightTrace);            } elseif (isset(self::$silencedErrorCache[$id][$message])) {                $lightTrace = null;                $errorAsException = self::$silencedErrorCache[$id][$message];                ++$errorAsException->count;            } else {                $lightTrace = [];                $errorAsException = null;            }            if (100 < ++self::$silencedErrorCount) {                self::$silencedErrorCache = $lightTrace = [];                self::$silencedErrorCount = 1;            }            if ($errorAsException) {                self::$silencedErrorCache[$id][$message] = $errorAsException;            }            if (null === $lightTrace) {                return true;            }        } else {            $errorAsException = new \ErrorException($logMessage, 0, $type, $file, $line);            if ($throw || $this->tracedErrors & $type) {                $backtrace = $errorAsException->getTrace();                $lightTrace = $this->cleanTrace($backtrace, $type, $file, $line, $throw);                $this->traceReflector->setValue($errorAsException, $lightTrace);            } else {                $this->traceReflector->setValue($errorAsException, []);                $backtrace = [];            }        }        if ($throw) {            if (\PHP_VERSION_ID < 70400 && \E_USER_ERROR & $type) {                for ($i = 1; isset($backtrace[$i]); ++$i) {                    if (isset($backtrace[$i]['function'], $backtrace[$i]['type'], $backtrace[$i - 1]['function'])                        && '__toString' === $backtrace[$i]['function']                        && '->' === $backtrace[$i]['type']                        && !isset($backtrace[$i - 1]['class'])                        && ('trigger_error' === $backtrace[$i - 1]['function'] || 'user_error' === $backtrace[$i - 1]['function'])                    ) {                        // Here, we know trigger_error() has been called from __toString().                        // PHP triggers a fatal error when throwing from __toString().                        // A small convention allows working around the limitation:                        // given a caught $e exception in __toString(), quitting the method with                        // `return trigger_error($e, E_USER_ERROR);` allows this error handler                        // to make $e get through the __toString() barrier.                        $context = 4 < \func_num_args() ? (func_get_arg(4) ?: []) : [];                        foreach ($context as $e) {                            if ($e instanceof \Throwable && $e->__toString() === $message) {                                self::$toStringException = $e;                                return true;                            }                        }                        // Display the original error message instead of the default one.                        $this->handleException($errorAsException);                        // Stop the process by giving back the error to the native handler.                        return false;                    }                }            }            throw $errorAsException;        }        if ($this->isRecursive) {            $log = 0;        } else {            if (\PHP_VERSION_ID < (\PHP_VERSION_ID < 70400 ? 70316 : 70404)) {                $currentErrorHandler = set_error_handler('var_dump');                restore_error_handler();            }            try {                $this->isRecursive = true;                $level = ($type & $level) ? $this->loggers[$type][1] : LogLevel::DEBUG;                $this->loggers[$type][0]->log($level, $logMessage, $errorAsException ? ['exception' => $errorAsException] : []);            } finally {                $this->isRecursive = false;                if (\PHP_VERSION_ID < (\PHP_VERSION_ID < 70400 ? 70316 : 70404)) {                    set_error_handler($currentErrorHandler);                }            }        }        return !$silenced && $type && $log;    }    /**     * Handles an exception by logging then forwarding it to another handler.     *     * @param \Exception|\Throwable $exception An exception to handle     * @param array                 $error     An array as returned by error_get_last()     *     * @internal     */    public function handleException($exception, array $error = null)    {        if (null === $error) {            self::$exitCode = 255;        }        if (!$exception instanceof \Exception) {            $exception = new FatalThrowableError($exception);        }        $type = $exception instanceof FatalErrorException ? $exception->getSeverity() : \E_ERROR;        $handlerException = null;        if (($this->loggedErrors & $type) || $exception instanceof FatalThrowableError) {            if (false !== strpos($message = $exception->getMessage(), ""@anonymous\0"")) {                $message = (new FlattenException())->setMessage($message)->getMessage();            }            if ($exception instanceof FatalErrorException) {                if ($exception instanceof FatalThrowableError) {                    $error = [                        'type' => $type,                        'message' => $message,                        'file' => $exception->getFile(),                        'line' => $exception->getLine(),                    ];                } else {                    $message = 'Fatal '.$message;                }            } elseif ($exception instanceof \ErrorException) {                $message = 'Uncaught '.$message;            } else {                $message = 'Uncaught Exception: '.$message;            }        }        if ($this->loggedErrors & $type) {            try {                $this->loggers[$type][0]->log($this->loggers[$type][1], $message, ['exception' => $exception]);            } catch (\Throwable $handlerException) {            }        }        if ($exception instanceof FatalErrorException && !$exception instanceof OutOfMemoryException && $error) {            foreach ($this->getFatalErrorHandlers() as $handler) {                if ($e = $handler->handleError($error, $exception)) {                    $exception = $e;                    break;                }            }        }        $exceptionHandler = $this->exceptionHandler;        $this->exceptionHandler = null;        try {            if (null !== $exceptionHandler) {                $exceptionHandler($exception);                return;            }            $handlerException = $handlerException ?: $exception;        } catch (\Throwable $handlerException) {        }        if ($exception === $handlerException) {            self::$reservedMemory = null; // Disable the fatal error handler            throw $exception; // Give back $exception to the native handler        }        $this->handleException($handlerException);    }    /**     * Shutdown registered function for handling PHP fatal errors.     *     * @param array $error An array as returned by error_get_last()     *     * @internal     */    public static function handleFatalError(array $error = null)    {        if (null === self::$reservedMemory) {            return;        }        $handler = self::$reservedMemory = null;        $handlers = [];        $previousHandler = null;        $sameHandlerLimit = 10;        while (!\is_array($handler) || !$handler[0] instanceof self) {            $handler = set_exception_handler('var_dump');            restore_exception_handler();            if (!$handler) {                break;            }            restore_exception_handler();            if ($handler !== $previousHandler) {                array_unshift($handlers, $handler);                $previousHandler = $handler;            } elseif (0 === --$sameHandlerLimit) {                $handler = null;                break;            }        }        foreach ($handlers as $h) {            set_exception_handler($h);        }        if (!$handler) {            return;        }        if ($handler !== $h) {            $handler[0]->setExceptionHandler($h);        }        $handler = $handler[0];        $handlers = [];        if ($exit = null === $error) {            $error = error_get_last();        }        if ($error && $error['type'] &= \E_PARSE | \E_ERROR | \E_CORE_ERROR | \E_COMPILE_ERROR) {            // Let's not throw anymore but keep logging            $handler->throwAt(0, true);            $trace = $error['backtrace'] ?? null;            if (0 === strpos($error['message'], 'Allowed memory') || 0 === strpos($error['message'], 'Out of memory')) {                $exception = new OutOfMemoryException($handler->levels[$error['type']].': '.$error['message'], 0, $error['type'], $error['file'], $error['line'], 2, false, $trace);            } else {                $exception = new FatalErrorException($handler->levels[$error['type']].': '.$error['message'], 0, $error['type'], $error['file'], $error['line'], 2, true, $trace);            }        } else {            $exception = null;        }        try {            if (null !== $exception) {                self::$exitCode = 255;                $handler->handleException($exception, $error);            }        } catch (FatalErrorException $e) {            // Ignore this re-throw        }        if ($exit && self::$exitCode) {            $exitCode = self::$exitCode;            register_shutdown_function('register_shutdown_function', function () use ($exitCode) { exit($exitCode); });        }    }    /**     * Gets the fatal error handlers.     *     * Override this method if you want to define more fatal error handlers.     *     * @return FatalErrorHandlerInterface[] An array of FatalErrorHandlerInterface     */    protected function getFatalErrorHandlers()    {        return [            new UndefinedFunctionFatalErrorHandler(),            new UndefinedMethodFatalErrorHandler(),            new ClassNotFoundFatalErrorHandler(),        ];    }    /**     * Cleans the trace by removing function arguments and the frames added by the error handler and DebugClassLoader.     */    private function cleanTrace(array $backtrace, int $type, string $file, int $line, bool $throw): array    {        $lightTrace = $backtrace;        for ($i = 0; isset($backtrace[$i]); ++$i) {            if (isset($backtrace[$i]['file'], $backtrace[$i]['line']) && $backtrace[$i]['line'] === $line && $backtrace[$i]['file'] === $file) {                $lightTrace = \array_slice($lightTrace, 1 + $i);                break;            }        }        if (class_exists(DebugClassLoader::class, false)) {            for ($i = \count($lightTrace) - 2; 0 < $i; --$i) {                if (DebugClassLoader::class === ($lightTrace[$i]['class'] ?? null)) {                    array_splice($lightTrace, --$i, 2);                }            }        }        if (!($throw || $this->scopedErrors & $type)) {            for ($i = 0; isset($lightTrace[$i]); ++$i) {                unset($lightTrace[$i]['args'], $lightTrace[$i]['object']);            }        }        return $lightTrace;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ErrorHandler_1738, Re-registers as a PHP error handler if levels changed.\n, Re-registers as a PHP error handler if levels changed.,"    private function reRegister(int $prev)    {        if ($prev !== $this->thrownErrors | $this->loggedErrors) {            $handler = set_error_handler('var_dump');            $handler = \is_array($handler) ? $handler[0] : null;            restore_error_handler();            if ($handler === $this) {                restore_error_handler();                if ($this->isRoot) {                    set_error_handler([$this, 'handleError'], $this->thrownErrors | $this->loggedErrors);                } else {                    set_error_handler([$this, 'handleError']);                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ErrorHandler_1741, Cleans the trace by removing function arguments and the frames added by the error handler and DebugClassLoader.\n, Cleans the trace by removing function arguments and the frames added by the error handler and DebugClassLoader.,"    private function cleanTrace(array $backtrace, int $type, string $file, int $line, bool $throw): array    {        $lightTrace = $backtrace;        for ($i = 0; isset($backtrace[$i]); ++$i) {            if (isset($backtrace[$i]['file'], $backtrace[$i]['line']) && $backtrace[$i]['line'] === $line && $backtrace[$i]['file'] === $file) {                $lightTrace = \array_slice($lightTrace, 1 + $i);                break;            }        }        if (class_exists(DebugClassLoader::class, false)) {            for ($i = \count($lightTrace) - 2; 0 < $i; --$i) {                if (DebugClassLoader::class === ($lightTrace[$i]['class'] ?? null)) {                    array_splice($lightTrace, --$i, 2);                }            }        }        if (!($throw || $this->scopedErrors & $type)) {            for ($i = 0; isset($lightTrace[$i]); ++$i) {                unset($lightTrace[$i]['args'], $lightTrace[$i]['object']);            }        }        return $lightTrace;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_1745, Sends the error associated with the given Exception as a plain PHP response.\\n\\n This method uses plain PHP functions like header() and echo to output\\n the response.\\n\\n @param \\\\Throwable|FlattenException $exception A \\\\Throwable or FlattenException instance\\n, Sends the error associated with the given Exception as a plain PHP response.,"    public function sendPhpResponse($exception)    {        if ($exception instanceof \Throwable) {            $exception = FlattenException::createFromThrowable($exception);        }        if (!headers_sent()) {            header(sprintf('HTTP/1.0 %s', $exception->getStatusCode()));            foreach ($exception->getHeaders() as $name => $value) {                header($name.': '.$value, false);            }            header('Content-Type: text/html; charset='.$this->charset);        }        echo $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_1748, Gets the stylesheet associated with the given exception.\n\n @return string The stylesheet as a string\n, Gets the stylesheet associated with the given exception.,"    public function getStylesheet(FlattenException $exception)    {        if (!$this->debug) {            return <<<'EOF'                body { background-color: #fff; color: #222; font: 16px/1.5 -apple-system, BlinkMacSystemFont, ""Segoe UI"", Roboto, ""Helvetica Neue"", Arial, sans-serif; margin: 0; }                .container { margin: 30px; max-width: 600px; }                h1 { color: #dc3545; font-size: 24px; }EOF;        }        return <<<'EOF'            body { background-color: #F9F9F9; color: #222; font: 14px/1.4 Helvetica, Arial, sans-serif; margin: 0; padding-bottom: 45px; }            a { cursor: pointer; text-decoration: none; }            a:hover { text-decoration: underline; }            abbr[title] { border-bottom: none; cursor: help; text-decoration: none; }            code, pre { font: 13px/1.5 Consolas, Monaco, Menlo, ""Ubuntu Mono"", ""Liberation Mono"", monospace; }            table, tr, th, td { background: #FFF; border-collapse: collapse; vertical-align: top; }            table { background: #FFF; border: 1px solid #E0E0E0; box-shadow: 0px 0px 1px rgba(128, 128, 128, .2); margin: 1em 0; width: 100%; }            table th, table td { border: solid #E0E0E0; border-width: 1px 0; padding: 8px 10px; }            table th { background-color: #E0E0E0; font-weight: bold; text-align: left; }            .hidden-xs-down { display: none; }            .block { display: block; }            .break-long-words { -ms-word-break: break-all; word-break: break-all; word-break: break-word; -webkit-hyphens: auto; -moz-hyphens: auto; hyphens: auto; }            .text-muted { color: #999; }            .container { max-width: 1024px; margin: 0 auto; padding: 0 15px; }            .container::after { content: """"; display: table; clear: both; }            .exception-summary { background: #B0413E; border-bottom: 2px solid rgba(0, 0, 0, 0.1); border-top: 1px solid rgba(0, 0, 0, .3); flex: 0 0 auto; margin-bottom: 30px; }            .exception-message-wrapper { display: flex; align-items: center; min-height: 70px; }            .exception-message { flex-grow: 1; padding: 30px 0; }            .exception-message, .exception-message a { color: #FFF; font-size: 21px; font-weight: 400; margin: 0; }            .exception-message.long { font-size: 18px; }            .exception-message a { border-bottom: 1px solid rgba(255, 255, 255, 0.5); font-size: inherit; text-decoration: none; }            .exception-message a:hover { border-bottom-color: #ffffff; }            .exception-illustration { flex-basis: 111px; flex-shrink: 0; height: 66px; margin-left: 15px; opacity: .7; }            .trace + .trace { margin-top: 30px; }            .trace-head .trace-class { color: #222; font-size: 18px; font-weight: bold; line-height: 1.3; margin: 0; position: relative; }            .trace-message { font-size: 14px; font-weight: normal; margin: .5em 0 0; }            .trace-file-path, .trace-file-path a { color: #222; margin-top: 3px; font-size: 13px; }            .trace-class { color: #B0413E; }            .trace-type { padding: 0 2px; }            .trace-method { color: #B0413E; font-weight: bold; }            .trace-arguments { color: #777; font-weight: normal; padding-left: 2px; }            @media (min-width: 575px) {                .hidden-xs-down { display: initial; }            }EOF;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_1749, Formats an array as a string.\n, Formats an array as a string.,"    private function formatArgs(array $args): string    {        $result = [];        foreach ($args as $key => $item) {            if ('object' === $item[0]) {                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));            } elseif ('array' === $item[0]) {                $formattedValue = sprintf('<em>array</em>(%s)', \is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);            } elseif ('null' === $item[0]) {                $formattedValue = '<em>null</em>';            } elseif ('boolean' === $item[0]) {                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';            } elseif ('resource' === $item[0]) {                $formattedValue = '<em>resource</em>';            } else {                $formattedValue = str_replace(""\n"", '', $this->escapeHtml(var_export($item[1], true)));            }            $result[] = \is_int($key) ? $formattedValue : sprintf(""'%s' => %s"", $this->escapeHtml($key), $formattedValue);        }        return implode(', ', $result);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_2253, Sets the format for links to source files.\\n\\n @param string|FileLinkFormatter $fileLinkFormat The format for links to source files\\n\\n @return string The previous file link format\\n, Sets the format for links to source files.,    public function setFileLinkFormat($fileLinkFormat)    {        $old = $this->fileLinkFormat;        $this->fileLinkFormat = $fileLinkFormat;        return $old;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_2254," Sends a response for the given Exception.\n\n To be as fail-safe as possible, the exception is first handled\n by our simple exception handler, then by the user exception handler.\n The latter takes precedence and any output from the former is cancelled,\n if and only if nothing bad happens in this handling path.\n", Sends a response for the given Exception.,"    public function handle(\Exception $exception)    {        if (null === $this->handler || $exception instanceof OutOfMemoryException) {            $this->sendPhpResponse($exception);            return;        }        $caughtLength = $this->caughtLength = 0;        ob_start(function ($buffer) {            $this->caughtBuffer = $buffer;            return '';        });        $this->sendPhpResponse($exception);        while (null === $this->caughtBuffer && ob_end_flush()) {            // Empty loop, everything is in the condition        }        if (isset($this->caughtBuffer[0])) {            ob_start(function ($buffer) {                if ($this->caughtLength) {                    // use substr_replace() instead of substr() for mbstring overloading resistance                    $cleanBuffer = substr_replace($buffer, '', 0, $this->caughtLength);                    if (isset($cleanBuffer[0])) {                        $buffer = $cleanBuffer;                    }                }                return $buffer;            });            echo $this->caughtBuffer;            $caughtLength = ob_get_length();        }        $this->caughtBuffer = null;        try {            ($this->handler)($exception);            $this->caughtLength = $caughtLength;        } catch (\Exception $e) {            if (!$caughtLength) {                // All handlers failed. Let PHP handle that now.                throw $exception;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_2257, Gets the HTML content associated with the given exception.\n\n @return string The content as a string\n, Gets the HTML content associated with the given exception.,"    public function getContent(FlattenException $exception)    {        switch ($exception->getStatusCode()) {            case 404:                $title = 'Sorry, the page you are looking for could not be found.';                break;            default:                $title = $this->debug ? $this->escapeHtml($exception->getMessage()) : 'Whoops, looks like something went wrong.';        }        if (!$this->debug) {            return <<<EOF                <div class=""container"">                    <h1>$title</h1>                </div>EOF;        }        $content = '';        try {            $count = \count($exception->getAllPrevious());            $total = $count + 1;            foreach ($exception->toArray() as $position => $e) {                $ind = $count - $position + 1;                $class = $this->formatClass($e['class']);                $message = nl2br($this->escapeHtml($e['message']));                $content .= sprintf(<<<'EOF'                    <div class=""trace trace-as-html"">                        <table class=""trace-details"">                            <thead class=""trace-head""><tr><th>                                <h3 class=""trace-class"">                                    <span class=""text-muted"">(%d/%d)</span>                                    <span class=""exception_title"">%s</span>                                </h3>                                <p class=""break-long-words trace-message"">%s</p>                            </th></tr></thead>                            <tbody>EOF                    , $ind, $total, $class, $message);                foreach ($e['trace'] as $trace) {                    $content .= '<tr><td>';                    if ($trace['function']) {                        $content .= sprintf('at <span class=""trace-class"">%s</span><span class=""trace-type"">%s</span><span class=""trace-method"">%s</span>', $this->formatClass($trace['class']), $trace['type'], $trace['function']);                        if (isset($trace['args'])) {                            $content .= sprintf('(<span class=""trace-arguments"">%s</span>)', $this->formatArgs($trace['args']));                        }                    }                    if (isset($trace['file']) && isset($trace['line'])) {                        $content .= $this->formatPath($trace['file'], $trace['line']);                    }                    $content .= ""</td></tr>\n"";                }                $content .= ""</tbody>\n</table>\n</div>\n"";            }        } catch (\Exception $e) {            // something nasty happened and we cannot throw an exception anymore            if ($this->debug) {                $e = FlattenException::create($e);                $title = sprintf('Exception thrown when handling an exception (%s: %s)', $e->getClass(), $this->escapeHtml($e->getMessage()));            } else {                $title = 'Whoops, looks like something went wrong.';            }        }        $symfonyGhostImageContents = $this->getSymfonyGhostAsSvg();        return <<<EOF            <div class=""exception-summary"">                <div class=""container"">                    <div class=""exception-message-wrapper"">                        <h1 class=""break-long-words exception-message"">$title</h1>                        <div class=""exception-illustration hidden-xs-down"">$symfonyGhostImageContents</div>                    </div>                </div>            </div>            <div class=""container"">                $content            </div>EOF;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_2260, HTML-encodes a string.\\n, HTML-encodes a string.,"    private function escapeHtml(string $str): string    {        return htmlspecialchars($str, \ENT_COMPAT | \ENT_SUBSTITUTE, $this->charset);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_FatalErrorException_1752," Fatal Error Exception.\\n\\n @author Konstanton Myakshin <koc-dp@yandex.ru>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\Error\\\\FatalError instead.\\n", Fatal Error Exception.,"class FatalErrorException extends \ErrorException{    public function __construct(string $message, int $code, int $severity, string $filename, int $lineno, int $traceOffset = null, bool $traceArgs = true, array $trace = null, \Throwable $previous = null)    {        parent::__construct($message, $code, $severity, $filename, $lineno, $previous);        if (null !== $trace) {            if (!$traceArgs) {                foreach ($trace as &$frame) {                    unset($frame['args'], $frame['this'], $frame);                }            }            $this->setTrace($trace);        } elseif (null !== $traceOffset) {            if (\function_exists('xdebug_get_function_stack') && $trace = @xdebug_get_function_stack()) {                if (0 < $traceOffset) {                    array_splice($trace, -$traceOffset);                }                foreach ($trace as &$frame) {                    if (!isset($frame['type'])) {                        // XDebug pre 2.1.1 doesn't currently set the call type key http://bugs.xdebug.org/view.php?id=695                        if (isset($frame['class'])) {                            $frame['type'] = '::';                        }                    } elseif ('dynamic' === $frame['type']) {                        $frame['type'] = '->';                    } elseif ('static' === $frame['type']) {                        $frame['type'] = '::';                    }                    // XDebug also has a different name for the parameters array                    if (!$traceArgs) {                        unset($frame['params'], $frame['args']);                    } elseif (isset($frame['params']) && !isset($frame['args'])) {                        $frame['args'] = $frame['params'];                        unset($frame['params']);                    }                }                unset($frame);                $trace = array_reverse($trace);            } else {                $trace = [];            }            $this->setTrace($trace);        }    }    protected function setTrace($trace)    {        $traceReflector = new \ReflectionProperty(\Exception::class, 'trace');        $traceReflector->setAccessible(true);        $traceReflector->setValue($this, $trace);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_FatalThrowableError_1753, Fatal Throwable Error.\n\n @author Nicolas Grekas <p@tchwork.com>\n\n @deprecated since Symfony 4.4\n, Fatal Throwable Error.,"class FatalThrowableError extends FatalErrorException{    private $originalClassName;    public function __construct(\Throwable $e)    {        $this->originalClassName = get_debug_type($e);        if ($e instanceof \ParseError) {            $severity = \E_PARSE;        } elseif ($e instanceof \TypeError) {            $severity = \E_RECOVERABLE_ERROR;        } else {            $severity = \E_ERROR;        }        \ErrorException::__construct(            $e->getMessage(),            $e->getCode(),            $severity,            $e->getFile(),            $e->getLine(),            $e->getPrevious()        );        $this->setTrace($e->getTrace());    }    public function getOriginalClassName(): string    {        return $this->originalClassName;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_FlattenException_1754," FlattenException wraps a PHP Error or Exception to be able to serialize it.\n\n Basically, this class removes all objects from the trace.\n\n @author Fabien Potencier <fabien@symfony.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\Exception\\FlattenException instead.\n", FlattenException wraps a PHP Error or Exception to be able to serialize it.,"class FlattenException{    private $message;    private $code;    private $previous;    private $trace;    private $traceAsString;    private $class;    private $statusCode;    private $headers;    private $file;    private $line;    /**     * @return static     */    public static function create(\Exception $exception, $statusCode = null, array $headers = [])    {        return static::createFromThrowable($exception, $statusCode, $headers);    }    /**     * @return static     */    public static function createFromThrowable(\Throwable $exception, int $statusCode = null, array $headers = [])    {        $e = new static();        $e->setMessage($exception->getMessage());        $e->setCode($exception->getCode());        if ($exception instanceof HttpExceptionInterface) {            $statusCode = $exception->getStatusCode();            $headers = array_merge($headers, $exception->getHeaders());        } elseif ($exception instanceof RequestExceptionInterface) {            $statusCode = 400;        }        if (null === $statusCode) {            $statusCode = 500;        }        $e->setStatusCode($statusCode);        $e->setHeaders($headers);        $e->setTraceFromThrowable($exception);        $e->setClass($exception instanceof FatalThrowableError ? $exception->getOriginalClassName() : get_debug_type($exception));        $e->setFile($exception->getFile());        $e->setLine($exception->getLine());        $previous = $exception->getPrevious();        if ($previous instanceof \Throwable) {            $e->setPrevious(static::createFromThrowable($previous));        }        return $e;    }    public function toArray()    {        $exceptions = [];        foreach (array_merge([$this], $this->getAllPrevious()) as $exception) {            $exceptions[] = [                'message' => $exception->getMessage(),                'class' => $exception->getClass(),                'trace' => $exception->getTrace(),            ];        }        return $exceptions;    }    public function getStatusCode()    {        return $this->statusCode;    }    /**     * @return $this     */    public function setStatusCode($code)    {        $this->statusCode = $code;        return $this;    }    public function getHeaders()    {        return $this->headers;    }    /**     * @return $this     */    public function setHeaders(array $headers)    {        $this->headers = $headers;        return $this;    }    public function getClass()    {        return $this->class;    }    /**     * @return $this     */    public function setClass($class)    {        $this->class = false !== strpos($class, ""@anonymous\0"") ? (get_parent_class($class) ?: key(class_implements($class)) ?: 'class').'@anonymous' : $class;        return $this;    }    public function getFile()    {        return $this->file;    }    /**     * @return $this     */    public function setFile($file)    {        $this->file = $file;        return $this;    }    public function getLine()    {        return $this->line;    }    /**     * @return $this     */    public function setLine($line)    {        $this->line = $line;        return $this;    }    public function getMessage()    {        return $this->message;    }    /**     * @return $this     */    public function setMessage($message)    {        if (false !== strpos($message, ""@anonymous\0"")) {            $message = preg_replace_callback('/[a-zA-Z_\x7f-\xff][\\\\a-zA-Z0-9_\x7f-\xff]*+@anonymous\x00.*?\.php(?:0x?|:[0-9]++\$)[0-9a-fA-F]++/', function ($m) {                return class_exists($m[0], false) ? (get_parent_class($m[0]) ?: key(class_implements($m[0])) ?: 'class').'@anonymous' : $m[0];            }, $message);        }        $this->message = $message;        return $this;    }    public function getCode()    {        return $this->code;    }    /**     * @return $this     */    public function setCode($code)    {        $this->code = $code;        return $this;    }    public function getPrevious()    {        return $this->previous;    }    /**     * @return $this     */    public function setPrevious(self $previous)    {        $this->previous = $previous;        return $this;    }    public function getAllPrevious()    {        $exceptions = [];        $e = $this;        while ($e = $e->getPrevious()) {            $exceptions[] = $e;        }        return $exceptions;    }    public function getTrace()    {        return $this->trace;    }    /**     * @deprecated since 4.1, use {@see setTraceFromThrowable()} instead.     */    public function setTraceFromException(\Exception $exception)    {        @trigger_error(sprintf('The ""%s()"" method is deprecated since Symfony 4.1, use ""setTraceFromThrowable()"" instead.', __METHOD__), \E_USER_DEPRECATED);        $this->setTraceFromThrowable($exception);    }    public function setTraceFromThrowable(\Throwable $throwable)    {        $this->traceAsString = $throwable->getTraceAsString();        return $this->setTrace($throwable->getTrace(), $throwable->getFile(), $throwable->getLine());    }    /**     * @return $this     */    public function setTrace($trace, $file, $line)    {        $this->trace = [];        $this->trace[] = [            'namespace' => '',            'short_class' => '',            'class' => '',            'type' => '',            'function' => '',            'file' => $file,            'line' => $line,            'args' => [],        ];        foreach ($trace as $entry) {            $class = '';            $namespace = '';            if (isset($entry['class'])) {                $parts = explode('\\', $entry['class']);                $class = array_pop($parts);                $namespace = implode('\\', $parts);            }            $this->trace[] = [                'namespace' => $namespace,                'short_class' => $class,                'class' => $entry['class'] ?? '',                'type' => $entry['type'] ?? '',                'function' => $entry['function'] ?? null,                'file' => $entry['file'] ?? null,                'line' => $entry['line'] ?? null,                'args' => isset($entry['args']) ? $this->flattenArgs($entry['args']) : [],            ];        }        return $this;    }    private function flattenArgs(array $args, int $level = 0, int &$count = 0): array    {        $result = [];        foreach ($args as $key => $value) {            if (++$count > 1e4) {                return ['array', '*SKIPPED over 10000 entries*'];            }            if ($value instanceof \__PHP_Incomplete_Class) {                // is_object() returns false on PHP<=7.1                $result[$key] = ['incomplete-object', $this->getClassNameFromIncomplete($value)];            } elseif (\is_object($value)) {                $result[$key] = ['object', \get_class($value)];            } elseif (\is_array($value)) {                if ($level > 10) {                    $result[$key] = ['array', '*DEEP NESTED ARRAY*'];                } else {                    $result[$key] = ['array', $this->flattenArgs($value, $level + 1, $count)];                }            } elseif (null === $value) {                $result[$key] = ['null', null];            } elseif (\is_bool($value)) {                $result[$key] = ['boolean', $value];            } elseif (\is_int($value)) {                $result[$key] = ['integer', $value];            } elseif (\is_float($value)) {                $result[$key] = ['float', $value];            } elseif (\is_resource($value)) {                $result[$key] = ['resource', get_resource_type($value)];            } else {                $result[$key] = ['string', (string) $value];            }        }        return $result;    }    private function getClassNameFromIncomplete(\__PHP_Incomplete_Class $value): string    {        $array = new \ArrayObject($value);        return $array['__PHP_Incomplete_Class_Name'];    }    public function getTraceAsString()    {        return $this->traceAsString;    }    public function getAsString()    {        $message = '';        $next = false;        foreach (array_reverse(array_merge([$this], $this->getAllPrevious())) as $exception) {            if ($next) {                $message .= 'Next ';            } else {                $next = true;            }            $message .= $exception->getClass();            if ('' != $exception->getMessage()) {                $message .= ': '.$exception->getMessage();            }            $message .= ' in '.$exception->getFile().':'.$exception->getLine().                ""\nStack trace:\n"".$exception->getTraceAsString().""\n\n"";        }        return rtrim($message);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_SilencedErrorContext_2276," Data Object that represents a Silenced Error.\\n\\n @author Grégoire Pineau <lyrixx@lyrixx.info>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\Exception\\\\SilencedErrorContext instead.\\n", Data Object that represents a Silenced Error.,"class SilencedErrorContext implements \JsonSerializable{    public $count = 1;    private $severity;    private $file;    private $line;    private $trace;    public function __construct(int $severity, string $file, int $line, array $trace = [], int $count = 1)    {        $this->severity = $severity;        $this->file = $file;        $this->line = $line;        $this->trace = $trace;        $this->count = $count;    }    public function getSeverity()    {        return $this->severity;    }    public function getFile()    {        return $this->file;    }    public function getLine()    {        return $this->line;    }    public function getTrace()    {        return $this->trace;    }    public function jsonSerialize()    {        return [            'severity' => $this->severity,            'file' => $this->file,            'line' => $this->line,            'trace' => $this->trace,            'count' => $this->count,        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_UndefinedMethodException_1768," Undefined Method Exception.\\n\\n @author Grégoire Pineau <lyrixx@lyrixx.info>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\Error\\\\UndefinedMethodError instead.\\n", Undefined Method Exception.,"class UndefinedMethodException extends FatalErrorException{    public function __construct(string $message, \ErrorException $previous)    {        parent::__construct(            $message,            $previous->getCode(),            $previous->getSeverity(),            $previous->getFile(),            $previous->getLine(),            null,            true,            null,            $previous->getPrevious()        );        $this->setTrace($previous->getTrace());    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_UndefinedMethodFatalErrorHandler_1775," ErrorHandler for undefined methods.\n\n @author Grégoire Pineau <lyrixx@lyrixx.info>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\ErrorEnhancer\\UndefinedMethodErrorEnhancer instead.\n", ErrorHandler for undefined methods.,"class UndefinedMethodFatalErrorHandler implements FatalErrorHandlerInterface{    /**     * {@inheritdoc}     */    public function handleError(array $error, FatalErrorException $exception)    {        preg_match('/^Call to undefined method (.*)::(.*)\(\)$/', $error['message'], $matches);        if (!$matches) {            return null;        }        $className = $matches[1];        $methodName = $matches[2];        $message = sprintf('Attempted to call an undefined method named ""%s"" of class ""%s"".', $methodName, $className);        if ('' === $methodName || !class_exists($className) || null === $methods = get_class_methods($className)) {            // failed to get the class or its methods on which an unknown method was called (for example on an anonymous class)            return new UndefinedMethodException($message, $exception);        }        $candidates = [];        foreach ($methods as $definedMethodName) {            $lev = levenshtein($methodName, $definedMethodName);            if ($lev <= \strlen($methodName) / 3 || false !== strpos($definedMethodName, $methodName)) {                $candidates[] = $definedMethodName;            }        }        if ($candidates) {            sort($candidates);            $last = array_pop($candidates).'""?';            if ($candidates) {                $candidates = 'e.g. ""'.implode('"", ""', $candidates).'"" or ""'.$last;            } else {                $candidates = '""'.$last;            }            $message .= ""\nDid you mean to call "".$candidates;        }        return new UndefinedMethodException($message, $exception);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Comparator_1123, Sets the comparison operator.\n\n @throws \\InvalidArgumentException\n, Sets the comparison operator.,"    public function setOperator(string $operator)    {        if ('' === $operator) {            $operator = '==';        }        if (!\in_array($operator, ['>', '<', '>=', '<=', '==', '!='])) {            throw new \InvalidArgumentException(sprintf('Invalid operator ""%s"".', $operator));        }        $this->operator = $operator;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_CustomFilterIterator_1133," Filters the iterator values.\n\n @return bool true if the value should be kept, false otherwise\n", Filters the iterator values.,    public function accept()    {        $fileinfo = $this->current();        foreach ($this->filters as $filter) {            if (false === $filter($fileinfo)) {                return false;            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_CustomFilterIterator_396, CustomFilterIterator filters files by applying anonymous functions.\\n\\n The anonymous function receives a \\\\SplFileInfo and must return false\\n to remove files.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n, CustomFilterIterator filters files by applying anonymous functions.,"class CustomFilterIterator extends \FilterIterator{    private $filters = [];    /**     * @param \Iterator  $iterator The Iterator to filter     * @param callable[] $filters  An array of PHP callbacks     *     * @throws \InvalidArgumentException     */    public function __construct(\Iterator $iterator, array $filters)    {        foreach ($filters as $filter) {            if (!\is_callable($filter)) {                throw new \InvalidArgumentException('Invalid PHP callback.');            }        }        $this->filters = $filters;        parent::__construct($iterator);    }    /**     * Filters the iterator values.     *     * @return bool true if the value should be kept, false otherwise     */    public function accept()    {        $fileinfo = $this->current();        foreach ($this->filters as $filter) {            if (false === $filter($fileinfo)) {                return false;            }        }        return true;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_DateComparator_1125, DateCompare compiles date comparisons.\n\n @author Fabien Potencier <fabien@symfony.com>\n, DateCompare compiles date comparisons.,"class DateComparator extends Comparator{    /**     * @param string $test A comparison string     *     * @throws \InvalidArgumentException If the test is not understood     */    public function __construct(string $test)    {        if (!preg_match('#^\s*(==|!=|[<>]=?|after|since|before|until)?\s*(.+?)\s*$#i', $test, $matches)) {            throw new \InvalidArgumentException(sprintf('Don\'t understand ""%s"" as a date test.', $test));        }        try {            $date = new \DateTime($matches[2]);            $target = $date->format('U');        } catch (\Exception $e) {            throw new \InvalidArgumentException(sprintf('""%s"" is not a valid date.', $matches[2]));        }        $operator = $matches[1] ?? '==';        if ('since' === $operator || 'after' === $operator) {            $operator = '>';        }        if ('until' === $operator || 'before' === $operator) {            $operator = '<';        }        $this->setOperator($operator);        $this->setTarget($target);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_DateRangeFilterIterator_1136," Filters the iterator values.\n\n @return bool true if the value should be kept, false otherwise\n", Filters the iterator values.,    public function accept()    {        $fileinfo = $this->current();        if (!file_exists($fileinfo->getPathname())) {            return false;        }        $filedate = $fileinfo->getMTime();        foreach ($this->comparators as $compare) {            if (!$compare->test($filedate)) {                return false;            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_DepthRangeFilterIterator_1137, DepthRangeFilterIterator limits the directory depth.\n\n @author Fabien Potencier <fabien@symfony.com>\n, DepthRangeFilterIterator limits the directory depth.,"class DepthRangeFilterIterator extends \FilterIterator{    private $minDepth = 0;    /**     * @param \RecursiveIteratorIterator $iterator The Iterator to filter     * @param int                        $minDepth The min depth     * @param int                        $maxDepth The max depth     */    public function __construct(\RecursiveIteratorIterator $iterator, int $minDepth = 0, int $maxDepth = \PHP_INT_MAX)    {        $this->minDepth = $minDepth;        $iterator->setMaxDepth(\PHP_INT_MAX === $maxDepth ? -1 : $maxDepth);        parent::__construct($iterator);    }    /**     * Filters the iterator values.     *     * @return bool true if the value should be kept, false otherwise     */    public function accept()    {        return $this->getInnerIterator()->getDepth() >= $this->minDepth;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_ExcludeDirectoryFilterIterator_404, ExcludeDirectoryFilterIterator filters out directories.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n, ExcludeDirectoryFilterIterator filters out directories.,"class ExcludeDirectoryFilterIterator extends \FilterIterator implements \RecursiveIterator{    private $iterator;    private $isRecursive;    private $excludedDirs = [];    private $excludedPattern;    /**     * @param \Iterator $iterator    The Iterator to filter     * @param string[]  $directories An array of directories to exclude     */    public function __construct(\Iterator $iterator, array $directories)    {        $this->iterator = $iterator;        $this->isRecursive = $iterator instanceof \RecursiveIterator;        $patterns = [];        foreach ($directories as $directory) {            $directory = rtrim($directory, '/');            if (!$this->isRecursive || false !== strpos($directory, '/')) {                $patterns[] = preg_quote($directory, '#');            } else {                $this->excludedDirs[$directory] = true;            }        }        if ($patterns) {            $this->excludedPattern = '#(?:^|/)(?:'.implode('|', $patterns).')(?:/|$)#';        }        parent::__construct($iterator);    }    /**     * Filters the iterator values.     *     * @return bool True if the value should be kept, false otherwise     */    public function accept()    {        if ($this->isRecursive && isset($this->excludedDirs[$this->getFilename()]) && $this->isDir()) {            return false;        }        if ($this->excludedPattern) {            $path = $this->isDir() ? $this->current()->getRelativePathname() : $this->current()->getRelativePath();            $path = str_replace('\\', '/', $path);            return !preg_match($this->excludedPattern, $path);        }        return true;    }    /**     * @return bool     */    public function hasChildren()    {        return $this->isRecursive && $this->iterator->hasChildren();    }    public function getChildren()    {        $children = new self($this->iterator->getChildren(), []);        $children->excludedDirs = $this->excludedDirs;        $children->excludedPattern = $this->excludedPattern;        return $children;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_ExcludeDirectoryFilterIterator_406," Filters the iterator values.\\n\\n @return bool True if the value should be kept, false otherwise\\n", Filters the iterator values.,"    public function accept()    {        if ($this->isRecursive && isset($this->excludedDirs[$this->getFilename()]) && $this->isDir()) {            return false;        }        if ($this->excludedPattern) {            $path = $this->isDir() ? $this->current()->getRelativePathname() : $this->current()->getRelativePath();            $path = str_replace('\\', '/', $path);            return !preg_match($this->excludedPattern, $path);        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_FilecontentFilterIterator_1146, FilecontentFilterIterator filters files by their contents using patterns (regexps or strings).\n\n @author Fabien Potencier  <fabien@symfony.com>\n @author Włodzimierz Gajda <gajdaw@gajdaw.pl>\n, FilecontentFilterIterator filters files by their contents using patterns (regexps or strings).,"class FilecontentFilterIterator extends MultiplePcreFilterIterator{    /**     * Filters the iterator values.     *     * @return bool true if the value should be kept, false otherwise     */    public function accept()    {        if (!$this->matchRegexps && !$this->noMatchRegexps) {            return true;        }        $fileinfo = $this->current();        if ($fileinfo->isDir() || !$fileinfo->isReadable()) {            return false;        }        $content = $fileinfo->getContents();        if (!$content) {            return false;        }        return $this->isAccepted($content);    }    /**     * Converts string to regexp if necessary.     *     * @param string $str Pattern: string or regexp     *     * @return string regexp corresponding to a given string or regexp     */    protected function toRegex(string $str)    {        return $this->isRegex($str) ? $str : '/'.preg_quote($str, '/').'/';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_FilecontentFilterIterator_1147," Filters the iterator values.\n\n @return bool true if the value should be kept, false otherwise\n", Filters the iterator values.,    public function accept()    {        if (!$this->matchRegexps && !$this->noMatchRegexps) {            return true;        }        $fileinfo = $this->current();        if ($fileinfo->isDir() || !$fileinfo->isReadable()) {            return false;        }        $content = $fileinfo->getContents();        if (!$content) {            return false;        }        return $this->isAccepted($content);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_FilecontentFilterIterator_1148, Converts string to regexp if necessary.\n\n @param string $str Pattern: string or regexp\n\n @return string regexp corresponding to a given string or regexp\n, Converts string to regexp if necessary.,"    protected function toRegex(string $str)    {        return $this->isRegex($str) ? $str : '/'.preg_quote($str, '/').'/';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_FilecontentFilterIterator_412," Filters the iterator values.\\n\\n @return bool true if the value should be kept, false otherwise\\n", Filters the iterator values.,    public function accept()    {        if (!$this->matchRegexps && !$this->noMatchRegexps) {            return true;        }        $fileinfo = $this->current();        if ($fileinfo->isDir() || !$fileinfo->isReadable()) {            return false;        }        $content = $fileinfo->getContents();        if (!$content) {            return false;        }        return $this->isAccepted($content);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_FilenameFilterIterator_1150," Filters the iterator values.\n\n @return bool true if the value should be kept, false otherwise\n", Filters the iterator values.,    public function accept()    {        return $this->isAccepted($this->current()->getFilename());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_FinderTest_1163, Searching in multiple locations involves AppendIterator which does an unnecessary rewind which leaves FilterIterator\n with inner FilesystemIterator in an invalid state.\n\n @see https://bugs.php.net/68557\n, Searching in multiple locations involves AppendIterator which does an unnecessary rewind which leaves FilterIterator,"    public function testMultipleLocations()    {        $locations = [            self::$tmpDir.'/',            self::$tmpDir.'/toto/',        ];        // it is expected that there are test.py test.php in the tmpDir        $finder = new Finder();        $finder->in($locations)            // the default flag IGNORE_DOT_FILES fixes the problem indirectly            // so we set it to false for better isolation            ->ignoreDotFiles(false)            ->depth('< 1')->name('test.php');        $this->assertCount(1, $finder);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_FinderTest_1164, Searching in multiple locations with sub directories involves\n AppendIterator which does an unnecessary rewind which leaves\n FilterIterator with inner FilesystemIterator in an invalid state.\n\n @see https://bugs.php.net/68557\n, Searching in multiple locations with sub directories involves,"    public function testMultipleLocationsWithSubDirectories()    {        $locations = [            __DIR__.'/Fixtures/one',            self::$tmpDir.\DIRECTORY_SEPARATOR.'toto',        ];        $finder = $this->buildFinder();        $finder->in($locations)->depth('< 10')->name('*.neon');        $expected = [            __DIR__.'/Fixtures/one'.\DIRECTORY_SEPARATOR.'b'.\DIRECTORY_SEPARATOR.'c.neon',            __DIR__.'/Fixtures/one'.\DIRECTORY_SEPARATOR.'b'.\DIRECTORY_SEPARATOR.'d.neon',        ];        $this->assertIterator($expected, $finder);        $this->assertIteratorInForeach($expected, $finder);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1086," Adds rules that files must match.\n\n You can use patterns (delimited with / sign), globs or simple strings.\n\n     $finder->name('     $finder->name('/\\.php$/') // same as above\n     $finder->name('test.php')\n     $finder->name(['test.py', 'test.php'])\n\n @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns\n\n @return $this\n\n @see FilenameFilterIterator\n", Adds rules that files must match.,"    public function name($patterns)    {        $this->names = array_merge($this->names, (array) $patterns);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1090," Adds rules that filenames must match.\n\n You can use patterns (delimited with / sign) or simple strings.\n\n     $finder->path('some/special/dir')\n     $finder->path('/some\\/special\\/dir/') // same as above\n     $finder->path(['some dir', 'another/dir'])\n\n Use only / as dirname separator.\n\n @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns\n\n @return $this\n\n @see FilenameFilterIterator\n", Adds rules that filenames must match.,"    public function path($patterns)    {        $this->paths = array_merge($this->paths, (array) $patterns);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1095, Forces the finder to ignore version control directories.\n\n This option is enabled by default.\n\n @return $this\n\n @see ExcludeDirectoryFilterIterator\n, Forces the finder to ignore version control directories.,    public function ignoreVCS(bool $ignoreVCS)    {        if ($ignoreVCS) {            $this->ignore |= static::IGNORE_VCS_FILES;        } else {            $this->ignore &= ~static::IGNORE_VCS_FILES;        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1098, Sorts files and directories by an anonymous function.\n\n The anonymous function receives two \\SplFileInfo instances to compare.\n\n This can be slow as all the matching files and directories must be retrieved for comparison.\n\n @return $this\n\n @see SortableIterator\n, Sorts files and directories by an anonymous function.,    public function sort(\Closure $closure)    {        $this->sort = $closure;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1104, Filters the iterator with an anonymous function.\n\n The anonymous function receives a \\SplFileInfo and must return false\n to remove files.\n\n @return $this\n\n @see CustomFilterIterator\n, Filters the iterator with an anonymous function.,    public function filter(\Closure $closure)    {        $this->filters[] = $closure;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1108," Appends an existing set of files/directories to the finder.\n\n The set can be another Finder, an Iterator, an IteratorAggregate, or even a plain array.\n\n @return $this\n\n @throws \\InvalidArgumentException when the given argument is not iterable\n", Appends an existing set of files/directories to the finder.,    public function append(iterable $iterator)    {        if ($iterator instanceof \IteratorAggregate) {            $this->iterators[] = $iterator->getIterator();        } elseif ($iterator instanceof \Iterator) {            $this->iterators[] = $iterator;        } elseif ($iterator instanceof \Traversable || \is_array($iterator)) {            $it = new \ArrayIterator();            foreach ($iterator as $file) {                $file = $file instanceof \SplFileInfo ? $file : new \SplFileInfo($file);                $it[$file->getPathname()] = $file;            }            $this->iterators[] = $it;        } else {            throw new \InvalidArgumentException('Finder::append() method wrong argument type.');        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_352," Adds rules that files must not match.\\n\\n @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns\\n\\n @return $this\\n\\n @see FilenameFilterIterator\\n", Adds rules that files must not match.,"    public function notName($patterns)    {        $this->notNames = array_merge($this->notNames, (array) $patterns);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_353," Adds tests that file contents must match.\\n\\n Strings or PCRE patterns can be used:\\n\\n     $finder->contains('Lorem ipsum')\\n     $finder->contains('/Lorem ipsum/i')\\n     $finder->contains(['dolor', '/ipsum/i'])\\n\\n @param string|string[] $patterns A pattern (string or regexp) or an array of patterns\\n\\n @return $this\\n\\n @see FilecontentFilterIterator\\n", Adds tests that file contents must match.,"    public function contains($patterns)    {        $this->contains = array_merge($this->contains, (array) $patterns);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_356," Adds rules that filenames must not match.\\n\\n You can use patterns (delimited with / sign) or simple strings.\\n\\n     $finder->notPath('some/special/dir')\\n     $finder->notPath('/some\\\\/special\\\\/dir/') // same as above\\n     $finder->notPath(['some/file.txt', 'another/file.log'])\\n\\n Use only / as dirname separator.\\n\\n @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns\\n\\n @return $this\\n\\n @see FilenameFilterIterator\\n", Adds rules that filenames must not match.,"    public function notPath($patterns)    {        $this->notPaths = array_merge($this->notPaths, (array) $patterns);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_358, Excludes directories.\\n\\n Directories passed as argument must be relative to the ones defined with the `in()` method. For example:\\n\\n     $finder->in(__DIR__)->exclude('ruby');\\n\\n @param string|array $dirs A directory path or an array of directories\\n\\n @return $this\\n\\n @see ExcludeDirectoryFilterIterator\\n, Excludes directories.,"    public function exclude($dirs)    {        $this->exclude = array_merge($this->exclude, (array) $dirs);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_359," Excludes ""hidden"" directories and files (starting with a dot).\\n\\n This option is enabled by default.\\n\\n @return $this\\n\\n @see ExcludeDirectoryFilterIterator\\n"," Excludes ""hidden"" directories and files (starting with a dot).",    public function ignoreDotFiles(bool $ignoreDotFiles)    {        if ($ignoreDotFiles) {            $this->ignore |= static::IGNORE_DOT_FILES;        } else {            $this->ignore &= ~static::IGNORE_DOT_FILES;        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_364," Sorts files and directories by type (directories before files), then by name.\\n\\n This can be slow as all the matching files and directories must be retrieved for comparison.\\n\\n @return $this\\n\\n @see SortableIterator\\n"," Sorts files and directories by type (directories before files), then by name.",    public function sortByType()    {        $this->sort = Iterator\SortableIterator::SORT_BY_TYPE;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_368, Sorts files and directories by the last modified time.\\n\\n This is the last time the actual contents of the file were last modified.\\n\\n This can be slow as all the matching files and directories must be retrieved for comparison.\\n\\n @return $this\\n\\n @see SortableIterator\\n, Sorts files and directories by the last modified time.,    public function sortByModifiedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_MODIFIED_TIME;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_372, Returns an Iterator for the current Finder configuration.\\n\\n This method implements the IteratorAggregate interface.\\n\\n @return \\\\Iterator|SplFileInfo[] An iterator\\n\\n @throws \\\\LogicException if the in() method has not been called\\n, Returns an Iterator for the current Finder configuration.,"    public function getIterator()    {        if (0 === \count($this->dirs) && 0 === \count($this->iterators)) {            throw new \LogicException('You must call one of in() or append() methods before iterating over a Finder.');        }        if (1 === \count($this->dirs) && 0 === \count($this->iterators)) {            $iterator = $this->searchInDirectory($this->dirs[0]);            if ($this->sort || $this->reverseSorting) {                $iterator = (new Iterator\SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();            }            return $iterator;        }        $iterator = new \AppendIterator();        foreach ($this->dirs as $dir) {            $iterator->append(new \IteratorIterator(new LazyIterator(function () use ($dir) {                return $this->searchInDirectory($dir);            })));        }        foreach ($this->iterators as $it) {            $iterator->append($it);        }        if ($this->sort || $this->reverseSorting) {            $iterator = (new Iterator\SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();        }        return $iterator;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_374, Check if any results were found.\\n\\n @return bool\\n, Check if any results were found.,    public function hasResults()    {        foreach ($this->getIterator() as $_) {            return true;        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Gitignore_377, Gitignore matches against text.\\n\\n @author Michael Voříšek <vorismi3@fel.cvut.cz>\\n @author Ahmed Abdou <mail@ahmd.io>\\n, Gitignore matches against text.,"class Gitignore{    /**     * Returns a regexp which is the equivalent of the gitignore pattern.     *     * Format specification: https://git-scm.com/docs/gitignore#_pattern_format     */    public static function toRegex(string $gitignoreFileContent): string    {        $gitignoreFileContent = preg_replace('~(?<!\\\\)#[^\n\r]*~', '', $gitignoreFileContent);        $gitignoreLines = preg_split('~\r\n?|\n~', $gitignoreFileContent);        $res = self::lineToRegex('');        foreach ($gitignoreLines as $i => $line) {            $line = preg_replace('~(?<!\\\\)[ \t]+$~', '', $line);            if ('!' === substr($line, 0, 1)) {                $line = substr($line, 1);                $isNegative = true;            } else {                $isNegative = false;            }            if ('' !== $line) {                if ($isNegative) {                    $res = '(?!'.self::lineToRegex($line).'$)'.$res;                } else {                    $res = '(?:'.$res.'|'.self::lineToRegex($line).')';                }            }        }        return '~^(?:'.$res.')~s';    }    private static function lineToRegex(string $gitignoreLine): string    {        if ('' === $gitignoreLine) {            return '$f'; // always false        }        $slashPos = strpos($gitignoreLine, '/');        if (false !== $slashPos && \strlen($gitignoreLine) - 1 !== $slashPos) {            if (0 === $slashPos) {                $gitignoreLine = substr($gitignoreLine, 1);            }            $isAbsolute = true;        } else {            $isAbsolute = false;        }        $regex = preg_quote(str_replace('\\', '', $gitignoreLine), '~');        $regex = preg_replace_callback('~\\\\\[((?:\\\\!)?)([^\[\]]*)\\\\\]~', function (array $matches): string {            return '['.('' !== $matches[1] ? '^' : '').str_replace('\\-', '-', $matches[2]).']';        }, $regex);        $regex = preg_replace('~(?:(?:\\\\\*){2,}(/?))+~', '(?:(?:(?!//).(?<!//))+$1)?', $regex);        $regex = preg_replace('~\\\\\*~', '[^/]*', $regex);        $regex = preg_replace('~\\\\\?~', '[^/]', $regex);        return ($isAbsolute ? '' : '(?:[^/]+/)*')            .$regex            .('/' !== substr($gitignoreLine, -1) ? '(?:$|/)' : '');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Glob_1114," Glob matches globbing patterns against text.\n\n     if match_glob(""foo.\n     // prints foo.bar and foo.baz\n     $regex = glob_to_regex(""foo.     for ([\'foo.bar\', \'foo.baz\', \'foo\', \'bar\'] as $t)\n     {\n         if (/$regex/) echo ""matched: $car\\n"";\n     }\n\n Glob implements glob(3) style matching that can be used to match\n against text, rather than fetching names from a filesystem.\n\n Based on the Perl Text::Glob module.\n\n @author Fabien Potencier <fabien@symfony.com> PHP port\n @author     Richard Clamp <richardc@unixbeard.net> Perl version\n @copyright  2004-2005 Fabien Potencier <fabien@symfony.com>\n @copyright  2002 Richard Clamp <richardc@unixbeard.net>\n", Glob matches globbing patterns against text.,"class Glob{    /**     * Returns a regexp which is the equivalent of the glob pattern.     *     * @return string     */    public static function toRegex(string $glob, bool $strictLeadingDot = true, bool $strictWildcardSlash = true, string $delimiter = '#')    {        $firstByte = true;        $escaping = false;        $inCurlies = 0;        $regex = '';        $sizeGlob = \strlen($glob);        for ($i = 0; $i < $sizeGlob; ++$i) {            $car = $glob[$i];            if ($firstByte && $strictLeadingDot && '.' !== $car) {                $regex .= '(?=[^\.])';            }            $firstByte = '/' === $car;            if ($firstByte && $strictWildcardSlash && isset($glob[$i + 2]) && '**' === $glob[$i + 1].$glob[$i + 2] && (!isset($glob[$i + 3]) || '/' === $glob[$i + 3])) {                $car = '[^/]++/';                if (!isset($glob[$i + 3])) {                    $car .= '?';                }                if ($strictLeadingDot) {                    $car = '(?=[^\.])'.$car;                }                $car = '/(?:'.$car.')*';                $i += 2 + isset($glob[$i + 3]);                if ('/' === $delimiter) {                    $car = str_replace('/', '\\/', $car);                }            }            if ($delimiter === $car || '.' === $car || '(' === $car || ')' === $car || '|' === $car || '+' === $car || '^' === $car || '$' === $car) {                $regex .= ""\\$car"";            } elseif ('*' === $car) {                $regex .= $escaping ? '\\*' : ($strictWildcardSlash ? '[^/]*' : '.*');            } elseif ('?' === $car) {                $regex .= $escaping ? '\\?' : ($strictWildcardSlash ? '[^/]' : '.');            } elseif ('{' === $car) {                $regex .= $escaping ? '\\{' : '(';                if (!$escaping) {                    ++$inCurlies;                }            } elseif ('}' === $car && $inCurlies) {                $regex .= $escaping ? '}' : ')';                if (!$escaping) {                    --$inCurlies;                }            } elseif (',' === $car && $inCurlies) {                $regex .= $escaping ? ',' : '|';            } elseif ('\\' === $car) {                if ($escaping) {                    $regex .= '\\\\';                    $escaping = false;                } else {                    $escaping = true;                }                continue;            } else {                $regex .= $car;            }            $escaping = false;        }        return $delimiter.'^'.$regex.'$'.$delimiter;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_NumberComparator_392," NumberComparator compiles a simple comparison to an anonymous\\n subroutine, which you can call with a value to be tested again.\\n\\n Now this would be very pointless, if NumberCompare didn't understand\\n magnitudes.\\n\\n The target value may use magnitudes of kilobytes (k, ki),\\n megabytes (m, mi), or gigabytes (g, gi).  Those suffixed\\n with an i use the appropriate 2 IEC standard: http://physics.nist.gov/cuu/Units/binary.html\\n\\n Based on the Perl Number::Compare module.\\n\\n @author    Fabien Potencier <fabien@symfony.com> PHP port\\n @author    Richard Clamp <richardc@unixbeard.net> Perl version\\n @copyright 2004-2005 Fabien Potencier <fabien@symfony.com>\\n @copyright 2002 Richard Clamp <richardc@unixbeard.net>\\n\\n @see http://physics.nist.gov/cuu/Units/binary.html\\n", NumberComparator compiles a simple comparison to an anonymous,"class NumberComparator extends Comparator{    /**     * @param string|int $test A comparison string or an integer     *     * @throws \InvalidArgumentException If the test is not understood     */    public function __construct(?string $test)    {        if (null === $test || !preg_match('#^\s*(==|!=|[<>]=?)?\s*([0-9\.]+)\s*([kmg]i?)?\s*$#i', $test, $matches)) {            throw new \InvalidArgumentException(sprintf('Don\'t understand ""%s"" as a number test.', $test ?? 'null'));        }        $target = $matches[2];        if (!is_numeric($target)) {            throw new \InvalidArgumentException(sprintf('Invalid number ""%s"".', $target));        }        if (isset($matches[3])) {            // magnitude            switch (strtolower($matches[3])) {                case 'k':                    $target *= 1000;                    break;                case 'ki':                    $target *= 1024;                    break;                case 'm':                    $target *= 1000000;                    break;                case 'mi':                    $target *= 1024 * 1024;                    break;                case 'g':                    $target *= 1000000000;                    break;                case 'gi':                    $target *= 1024 * 1024 * 1024;                    break;            }        }        $this->setTarget($target);        $this->setOperator($matches[1] ?? '==');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeaderItem_7817, Represents an Accept-\n @author Jean-François Simon <contact@jfsimon.fr>\n, Represents an Accept-,"class AcceptHeaderItem{    private $value;    private $quality = 1.0;    private $index = 0;    private $attributes = [];    public function __construct(string $value, array $attributes = [])    {        $this->value = $value;        foreach ($attributes as $name => $value) {            $this->setAttribute($name, $value);        }    }    /**     * Builds an AcceptHeaderInstance instance from a string.     *     * @return self     */    public static function fromString(?string $itemValue)    {        $parts = HeaderUtils::split($itemValue ?? '', ';=');        $part = array_shift($parts);        $attributes = HeaderUtils::combine($parts);        return new self($part[0], $attributes);    }    /**     * Returns header value's string representation.     *     * @return string     */    public function __toString()    {        $string = $this->value.($this->quality < 1 ? ';q='.$this->quality : '');        if (\count($this->attributes) > 0) {            $string .= '; '.HeaderUtils::toString($this->attributes, ';');        }        return $string;    }    /**     * Set the item value.     *     * @return $this     */    public function setValue(string $value)    {        $this->value = $value;        return $this;    }    /**     * Returns the item value.     *     * @return string     */    public function getValue()    {        return $this->value;    }    /**     * Set the item quality.     *     * @return $this     */    public function setQuality(float $quality)    {        $this->quality = $quality;        return $this;    }    /**     * Returns the item quality.     *     * @return float     */    public function getQuality()    {        return $this->quality;    }    /**     * Set the item index.     *     * @return $this     */    public function setIndex(int $index)    {        $this->index = $index;        return $this;    }    /**     * Returns the item index.     *     * @return int     */    public function getIndex()    {        return $this->index;    }    /**     * Tests if an attribute exists.     *     * @return bool     */    public function hasAttribute(string $name)    {        return isset($this->attributes[$name]);    }    /**     * Returns an attribute by its name.     *     * @param mixed $default     *     * @return mixed     */    public function getAttribute(string $name, $default = null)    {        return $this->attributes[$name] ?? $default;    }    /**     * Returns all attributes.     *     * @return array     */    public function getAttributes()    {        return $this->attributes;    }    /**     * Set an attribute.     *     * @return $this     */    public function setAttribute(string $name, string $value)    {        if ('q' === $name) {            $this->quality = (float) $value;        } else {            $this->attributes[$name] = $value;        }        return $this;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeaderItem_7818, Builds an AcceptHeaderInstance instance from a string.\n\n @return self\n, Builds an AcceptHeaderInstance instance from a string.,"    public static function fromString(?string $itemValue)    {        $parts = HeaderUtils::split($itemValue ?? '', ';=');        $part = array_shift($parts);        $attributes = HeaderUtils::combine($parts);        return new self($part[0], $attributes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeaderItem_8738, Set the item value.\n\n @return $this\n, Set the item value.,    public function setValue(string $value)    {        $this->value = $value;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeaderItem_8742, Set the item index.\n\n @return $this\n, Set the item index.,    public function setIndex(int $index)    {        $this->index = $index;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_7808, Builds an AcceptHeader instance from a string.\n\n @return self\n, Builds an AcceptHeader instance from a string.,"    public static function fromString(?string $headerValue)    {        $index = 0;        $parts = HeaderUtils::split($headerValue ?? '', ',;=');        return new self(array_map(function ($subParts) use (&$index) {            $part = array_shift($subParts);            $attributes = HeaderUtils::combine($subParts);            $item = new AcceptHeaderItem($part[0], $attributes);            $item->setIndex($index++);            return $item;        }, $parts));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_7815, Returns first item.\n\n @return AcceptHeaderItem|null\n, Returns first item.,    public function first()    {        $this->sort();        return !empty($this->items) ? reset($this->items) : null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_8730, Adds an item.\n\n @return $this\n, Adds an item.,    public function add(AcceptHeaderItem $item)    {        $this->items[$item->getValue()] = $item;        $this->sorted = false;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_8734, Sorts items by descending quality.\n, Sorts items by descending quality.,"    private function sort(): void    {        if (!$this->sorted) {            uasort($this->items, function (AcceptHeaderItem $a, AcceptHeaderItem $b) {                $qA = $a->getQuality();                $qB = $b->getQuality();                if ($qA === $qB) {                    return $a->getIndex() > $b->getIndex() ? 1 : -1;                }                return $qA > $qB ? -1 : 1;            });            $this->sorted = true;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_9677, Returns header value's string representation.\n\n @return string\n, Returns header value's string representation.,"    public function __toString()    {        return implode(',', $this->items);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AttributeBag_8142, This class relates to session attribute storage.\n, This class relates to session attribute storage.,"class AttributeBag implements AttributeBagInterface, \IteratorAggregate, \Countable{    private $name = 'attributes';    private $storageKey;    protected $attributes = [];    /**     * @param string $storageKey The key used to store attributes in the session     */    public function __construct(string $storageKey = '_sf2_attributes')    {        $this->storageKey = $storageKey;    }    /**     * {@inheritdoc}     */    public function getName()    {        return $this->name;    }    public function setName(string $name)    {        $this->name = $name;    }    /**     * {@inheritdoc}     */    public function initialize(array &$attributes)    {        $this->attributes = &$attributes;    }    /**     * {@inheritdoc}     */    public function getStorageKey()    {        return $this->storageKey;    }    /**     * {@inheritdoc}     */    public function has(string $name)    {        return \array_key_exists($name, $this->attributes);    }    /**     * {@inheritdoc}     */    public function get(string $name, $default = null)    {        return \array_key_exists($name, $this->attributes) ? $this->attributes[$name] : $default;    }    /**     * {@inheritdoc}     */    public function set(string $name, $value)    {        $this->attributes[$name] = $value;    }    /**     * {@inheritdoc}     */    public function all()    {        return $this->attributes;    }    /**     * {@inheritdoc}     */    public function replace(array $attributes)    {        $this->attributes = [];        foreach ($attributes as $key => $value) {            $this->set($key, $value);        }    }    /**     * {@inheritdoc}     */    public function remove(string $name)    {        $retval = null;        if (\array_key_exists($name, $this->attributes)) {            $retval = $this->attributes[$name];            unset($this->attributes[$name]);        }        return $retval;    }    /**     * {@inheritdoc}     */    public function clear()    {        $return = $this->attributes;        $this->attributes = [];        return $return;    }    /**     * Returns an iterator for attributes.     *     * @return \ArrayIterator An \ArrayIterator instance     */    public function getIterator()    {        return new \ArrayIterator($this->attributes);    }    /**     * Returns the number of attributes.     *     * @return int The number of attributes     */    public function count()    {        return \count($this->attributes);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AttributeBag_8153, Returns the number of attributes.\n\n @return int The number of attributes\n, Returns the number of attributes.,    public function count()    {        return \count($this->attributes);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AttributeBag_9070, Returns an iterator for attributes.\n\n @return \\ArrayIterator An \\ArrayIterator instance\n, Returns an iterator for attributes.,    public function getIterator()    {        return new \ArrayIterator($this->attributes);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_BinaryFileResponse_7832, Automatically sets the ETag header according to the checksum of the file.\n, Automatically sets the ETag header according to the checksum of the file.,"    public function setAutoEtag()    {        $this->setEtag(base64_encode(hash_file('sha256', $this->file->getPathname(), true)));        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_BinaryFileResponse_7834, Sends the file.\n\n {@inheritdoc}\n, Sends the file.,"    public function sendContent()    {        if (!$this->isSuccessful()) {            return parent::sendContent();        }        if (0 === $this->maxlen) {            return $this;        }        $out = fopen('php://output', 'w');        $file = fopen($this->file->getPathname(), 'r');        stream_copy_to_stream($file, $out, $this->maxlen, $this->offset);        fclose($out);        fclose($file);        if ($this->deleteFileAfterSend && is_file($this->file->getPathname())) {            unlink($this->file->getPathname());        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_BinaryFileResponse_8749, Automatically sets the Last-Modified header according the file modification date.\n, Automatically sets the Last-Modified header according the file modification date.,"    public function setAutoLastModified()    {        $this->setLastModified(\DateTime::createFromFormat('U', $this->file->getMTime()));        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Cookie_7840, Creates a cookie copy with a new domain that the cookie is available to.\n\n @return static\n, Creates a cookie copy with a new domain that the cookie is available to.,    public function withDomain(?string $domain): self    {        $cookie = clone $this;        $cookie->domain = $domain;        return $cookie;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Cookie_7841, Creates a cookie copy with a new path on the server in which the cookie will be available on.\n\n @return static\n, Creates a cookie copy with a new path on the server in which the cookie will be available on.,    public function withPath(string $path): self    {        $cookie = clone $this;        $cookie->path = '' === $path ? '/' : $path;        return $cookie;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Cookie_8770, Whether this cookie is about to be cleared.\n\n @return bool\n, Whether this cookie is about to be cleared.,    public function isCleared()    {        return 0 !== $this->expire && $this->expire < time();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_FileBag_7859, Converts uploaded files to UploadedFile instances.\n\n @param array|UploadedFile $file A (multi-dimensional) array of uploaded file information\n\n @return UploadedFile[]|UploadedFile|null A (multi-dimensional) array of UploadedFile instances\n, Converts uploaded files to UploadedFile instances.,"    protected function convertFileInformation($file)    {        if ($file instanceof UploadedFile) {            return $file;        }        if (\is_array($file)) {            $file = $this->fixPhpFilesArray($file);            $keys = array_keys($file);            sort($keys);            if (self::FILE_KEYS == $keys) {                if (\UPLOAD_ERR_NO_FILE == $file['error']) {                    $file = null;                } else {                    $file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['error'], false);                }            } else {                $file = array_map([$this, 'convertFileInformation'], $file);                if (array_keys($keys) === $keys) {                    $file = array_filter($file);                }            }        }        return $file;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_File_8070, Returns locale independent base name of the given path.\n\n @return string\n, Returns locale independent base name of the given path.,"    protected function getName(string $name)    {        $originalName = str_replace('\\', '/', $name);        $pos = strrpos($originalName, '/');        $originalName = false === $pos ? $originalName : substr($originalName, $pos + 1);        return $originalName;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_File_8987," Returns the mime type of the file.\n\n The mime type is guessed using a MimeTypeGuesserInterface instance,\n which uses finfo_file() then the ""file"" system binary,\n depending on which of those are available.\n\n @return string|null The guessed mime type (e.g. ""application/pdf"")\n\n @see MimeTypes\n", Returns the mime type of the file.,"    public function getMimeType()    {        if (!class_exists(MimeTypes::class)) {            throw new \LogicException('You cannot guess the mime type as the Mime component is not installed. Try running ""composer require symfony/mime"".');        }        return MimeTypes::getDefault()->guessMimeType($this->getPathname());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_File_9935, A file in the file system.\n\n @author Bernhard Schussek <bschussek@gmail.com>\n, A file in the file system.,"class File extends \SplFileInfo{    /**     * Constructs a new file from the given path.     *     * @param string $path      The path to the file     * @param bool   $checkPath Whether to check the path or not     *     * @throws FileNotFoundException If the given path is not a file     */    public function __construct(string $path, bool $checkPath = true)    {        if ($checkPath && !is_file($path)) {            throw new FileNotFoundException($path);        }        parent::__construct($path);    }    /**     * Returns the extension based on the mime type.     *     * If the mime type is unknown, returns null.     *     * This method uses the mime type as guessed by getMimeType()     * to guess the file extension.     *     * @return string|null The guessed extension or null if it cannot be guessed     *     * @see MimeTypes     * @see getMimeType()     */    public function guessExtension()    {        if (!class_exists(MimeTypes::class)) {            throw new \LogicException('You cannot guess the extension as the Mime component is not installed. Try running ""composer require symfony/mime"".');        }        return MimeTypes::getDefault()->getExtensions($this->getMimeType())[0] ?? null;    }    /**     * Returns the mime type of the file.     *     * The mime type is guessed using a MimeTypeGuesserInterface instance,     * which uses finfo_file() then the ""file"" system binary,     * depending on which of those are available.     *     * @return string|null The guessed mime type (e.g. ""application/pdf"")     *     * @see MimeTypes     */    public function getMimeType()    {        if (!class_exists(MimeTypes::class)) {            throw new \LogicException('You cannot guess the mime type as the Mime component is not installed. Try running ""composer require symfony/mime"".');        }        return MimeTypes::getDefault()->guessMimeType($this->getPathname());    }    /**     * Moves the file to a new location.     *     * @return self A File object representing the new file     *     * @throws FileException if the target file could not be created     */    public function move(string $directory, string $name = null)    {        $target = $this->getTargetFile($directory, $name);        set_error_handler(function ($type, $msg) use (&$error) { $error = $msg; });        $renamed = rename($this->getPathname(), $target);        restore_error_handler();        if (!$renamed) {            throw new FileException(sprintf('Could not move the file ""%s"" to ""%s"" (%s).', $this->getPathname(), $target, strip_tags($error)));        }        @chmod($target, 0666 & ~umask());        return $target;    }    public function getContent(): string    {        $content = file_get_contents($this->getPathname());        if (false === $content) {            throw new FileException(sprintf('Could not get the content of the file ""%s"".', $this->getPathname()));        }        return $content;    }    /**     * @return self     */    protected function getTargetFile(string $directory, string $name = null)    {        if (!is_dir($directory)) {            if (false === @mkdir($directory, 0777, true) && !is_dir($directory)) {                throw new FileException(sprintf('Unable to create the ""%s"" directory.', $directory));            }        } elseif (!is_writable($directory)) {            throw new FileException(sprintf('Unable to write in the ""%s"" directory.', $directory));        }        $target = rtrim($directory, '/\\').\DIRECTORY_SEPARATOR.(null === $name ? $this->getBasename() : $this->getName($name));        return new self($target, false);    }    /**     * Returns locale independent base name of the given path.     *     * @return string     */    protected function getName(string $name)    {        $originalName = str_replace('\\', '/', $name);        $pos = strrpos($originalName, '/');        $originalName = false === $pos ? $originalName : substr($originalName, $pos + 1);        return $originalName;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderBag_7866," Returns true if the given HTTP header contains the given value.\n\n @return bool true if the value is contained in the header, false otherwise\n", Returns true if the given HTTP header contains the given value.,"    public function contains(string $key, string $value)    {        return \in_array($value, $this->all($key));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderBag_8779, HeaderBag is a container for HTTP headers.\n\n @author Fabien Potencier <fabien@symfony.com>\n, HeaderBag is a container for HTTP headers.,"class HeaderBag implements \IteratorAggregate, \Countable{    protected const UPPER = '_ABCDEFGHIJKLMNOPQRSTUVWXYZ';    protected const LOWER = '-abcdefghijklmnopqrstuvwxyz';    protected $headers = [];    protected $cacheControl = [];    public function __construct(array $headers = [])    {        foreach ($headers as $key => $values) {            $this->set($key, $values);        }    }    /**     * Returns the headers as a string.     *     * @return string The headers     */    public function __toString()    {        if (!$headers = $this->all()) {            return '';        }        ksort($headers);        $max = max(array_map('strlen', array_keys($headers))) + 1;        $content = '';        foreach ($headers as $name => $values) {            $name = ucwords($name, '-');            foreach ($values as $value) {                $content .= sprintf(""%-{$max}s %s\r\n"", $name.':', $value);            }        }        return $content;    }    /**     * Returns the headers.     *     * @param string|null $key The name of the headers to return or null to get them all     *     * @return array An array of headers     */    public function all(string $key = null)    {        if (null !== $key) {            return $this->headers[strtr($key, self::UPPER, self::LOWER)] ?? [];        }        return $this->headers;    }    /**     * Returns the parameter keys.     *     * @return array An array of parameter keys     */    public function keys()    {        return array_keys($this->all());    }    /**     * Replaces the current HTTP headers by a new set.     */    public function replace(array $headers = [])    {        $this->headers = [];        $this->add($headers);    }    /**     * Adds new headers the current HTTP headers set.     */    public function add(array $headers)    {        foreach ($headers as $key => $values) {            $this->set($key, $values);        }    }    /**     * Returns a header value by name.     *     * @return string|null The first header value or default value     */    public function get(string $key, string $default = null)    {        $headers = $this->all($key);        if (!$headers) {            return $default;        }        if (null === $headers[0]) {            return null;        }        return (string) $headers[0];    }    /**     * Sets a header by name.     *     * @param string|string[] $values  The value or an array of values     * @param bool            $replace Whether to replace the actual value or not (true by default)     */    public function set(string $key, $values, bool $replace = true)    {        $key = strtr($key, self::UPPER, self::LOWER);        if (\is_array($values)) {            $values = array_values($values);            if (true === $replace || !isset($this->headers[$key])) {                $this->headers[$key] = $values;            } else {                $this->headers[$key] = array_merge($this->headers[$key], $values);            }        } else {            if (true === $replace || !isset($this->headers[$key])) {                $this->headers[$key] = [$values];            } else {                $this->headers[$key][] = $values;            }        }        if ('cache-control' === $key) {            $this->cacheControl = $this->parseCacheControl(implode(', ', $this->headers[$key]));        }    }    /**     * Returns true if the HTTP header is defined.     *     * @return bool true if the parameter exists, false otherwise     */    public function has(string $key)    {        return \array_key_exists(strtr($key, self::UPPER, self::LOWER), $this->all());    }    /**     * Returns true if the given HTTP header contains the given value.     *     * @return bool true if the value is contained in the header, false otherwise     */    public function contains(string $key, string $value)    {        return \in_array($value, $this->all($key));    }    /**     * Removes a header.     */    public function remove(string $key)    {        $key = strtr($key, self::UPPER, self::LOWER);        unset($this->headers[$key]);        if ('cache-control' === $key) {            $this->cacheControl = [];        }    }    /**     * Returns the HTTP header value converted to a date.     *     * @return \DateTimeInterface|null The parsed DateTime or the default value if the header does not exist     *     * @throws \RuntimeException When the HTTP header is not parseable     */    public function getDate(string $key, \DateTime $default = null)    {        if (null === $value = $this->get($key)) {            return $default;        }        if (false === $date = \DateTime::createFromFormat(\DATE_RFC2822, $value)) {            throw new \RuntimeException(sprintf('The ""%s"" HTTP header is not parseable (%s).', $key, $value));        }        return $date;    }    /**     * Adds a custom Cache-Control directive.     *     * @param mixed $value The Cache-Control directive value     */    public function addCacheControlDirective(string $key, $value = true)    {        $this->cacheControl[$key] = $value;        $this->set('Cache-Control', $this->getCacheControlHeader());    }    /**     * Returns true if the Cache-Control directive is defined.     *     * @return bool true if the directive exists, false otherwise     */    public function hasCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->cacheControl);    }    /**     * Returns a Cache-Control directive value by name.     *     * @return mixed The directive value if defined, null otherwise     */    public function getCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->cacheControl) ? $this->cacheControl[$key] : null;    }    /**     * Removes a Cache-Control directive.     */    public function removeCacheControlDirective(string $key)    {        unset($this->cacheControl[$key]);        $this->set('Cache-Control', $this->getCacheControlHeader());    }    /**     * Returns an iterator for headers.     *     * @return \ArrayIterator An \ArrayIterator instance     */    public function getIterator()    {        return new \ArrayIterator($this->headers);    }    /**     * Returns the number of headers.     *     * @return int The number of headers     */    public function count()    {        return \count($this->headers);    }    protected function getCacheControlHeader()    {        ksort($this->cacheControl);        return HeaderUtils::toString($this->cacheControl, ',');    }    /**     * Parses a Cache-Control HTTP header.     *     * @return array An array representing the attribute values     */    protected function parseCacheControl(string $header)    {        $parts = HeaderUtils::split($header, ',=');        return HeaderUtils::combine($parts);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderBag_8782, Adds new headers the current HTTP headers set.\n, Adds new headers the current HTTP headers set.,"    public function add(array $headers)    {        foreach ($headers as $key => $values) {            $this->set($key, $values);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderBag_8786," Returns true if the Cache-Control directive is defined.\n\n @return bool true if the directive exists, false otherwise\n", Returns true if the Cache-Control directive is defined.,"    public function hasCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->cacheControl);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderBag_8787," Returns a Cache-Control directive value by name.\n\n @return mixed The directive value if defined, null otherwise\n", Returns a Cache-Control directive value by name.,"    public function getCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->cacheControl) ? $this->cacheControl[$key] : null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderBag_9733," Returns true if the HTTP header is defined.\n\n @return bool true if the parameter exists, false otherwise\n", Returns true if the HTTP header is defined.,"    public function has(string $key)    {        return \array_key_exists(strtr($key, self::UPPER, self::LOWER), $this->all());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderUtils_8797," Encodes a string as a quoted string, if necessary.\n\n If a string contains characters not allowed by the ""token"" construct in\n the HTTP specification, it is backslash-escaped and enclosed in quotes\n to match the ""quoted-string"" construct.\n"," Encodes a string as a quoted string, if necessary.","    public static function quote(string $s): string    {        if (preg_match('/^[a-z0-9!#$%&\'*.^_`|~-]+$/i', $s)) {            return $s;        }        return '""'.addcslashes($s, '""\\""').'""';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderUtils_8798," Decodes a quoted string.\n\n If passed an unquoted string that matches the ""token"" construct (as\n defined in the HTTP specification), it is passed through verbatimly.\n", Decodes a quoted string.,"    public static function unquote(string $s): string    {        return preg_replace('/\\\\(.)|""/', '$1', $s);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_IpUtils_7883, Http utility functions.\n\n @author Fabien Potencier <fabien@symfony.com>\n, Http utility functions.,"class IpUtils{    private static $checkedIps = [];    /**     * This class should not be instantiated.     */    private function __construct()    {    }    /**     * Checks if an IPv4 or IPv6 address is contained in the list of given IPs or subnets.     *     * @param string|array $ips List of IPs or subnets (can be a string if only a single one)     *     * @return bool Whether the IP is valid     */    public static function checkIp(?string $requestIp, $ips)    {        if (!\is_array($ips)) {            $ips = [$ips];        }        $method = substr_count($requestIp, ':') > 1 ? 'checkIp6' : 'checkIp4';        foreach ($ips as $ip) {            if (self::$method($requestIp, $ip)) {                return true;            }        }        return false;    }    /**     * Compares two IPv4 addresses.     * In case a subnet is given, it checks if it contains the request IP.     *     * @param string $ip IPv4 address or subnet in CIDR notation     *     * @return bool Whether the request IP matches the IP, or whether the request IP is within the CIDR subnet     */    public static function checkIp4(?string $requestIp, string $ip)    {        $cacheKey = $requestIp.'-'.$ip;        if (isset(self::$checkedIps[$cacheKey])) {            return self::$checkedIps[$cacheKey];        }        if (!filter_var($requestIp, \FILTER_VALIDATE_IP, \FILTER_FLAG_IPV4)) {            return self::$checkedIps[$cacheKey] = false;        }        if (false !== strpos($ip, '/')) {            [$address, $netmask] = explode('/', $ip, 2);            if ('0' === $netmask) {                return self::$checkedIps[$cacheKey] = filter_var($address, \FILTER_VALIDATE_IP, \FILTER_FLAG_IPV4);            }            if ($netmask < 0 || $netmask > 32) {                return self::$checkedIps[$cacheKey] = false;            }        } else {            $address = $ip;            $netmask = 32;        }        if (false === ip2long($address)) {            return self::$checkedIps[$cacheKey] = false;        }        return self::$checkedIps[$cacheKey] = 0 === substr_compare(sprintf('%032b', ip2long($requestIp)), sprintf('%032b', ip2long($address)), 0, $netmask);    }    /**     * Compares two IPv6 addresses.     * In case a subnet is given, it checks if it contains the request IP.     *     * @author David Soria Parra <dsp at php dot net>     *     * @see https://github.com/dsp/v6tools     *     * @param string $ip IPv6 address or subnet in CIDR notation     *     * @return bool Whether the IP is valid     *     * @throws \RuntimeException When IPV6 support is not enabled     */    public static function checkIp6(?string $requestIp, string $ip)    {        $cacheKey = $requestIp.'-'.$ip;        if (isset(self::$checkedIps[$cacheKey])) {            return self::$checkedIps[$cacheKey];        }        if (!((\extension_loaded('sockets') && \defined('AF_INET6')) || @inet_pton('::1'))) {            throw new \RuntimeException('Unable to check Ipv6. Check that PHP was not compiled with option ""disable-ipv6"".');        }        if (false !== strpos($ip, '/')) {            [$address, $netmask] = explode('/', $ip, 2);            if ('0' === $netmask) {                return (bool) unpack('n*', @inet_pton($address));            }            if ($netmask < 1 || $netmask > 128) {                return self::$checkedIps[$cacheKey] = false;            }        } else {            $address = $ip;            $netmask = 128;        }        $bytesAddr = unpack('n*', @inet_pton($address));        $bytesTest = unpack('n*', @inet_pton($requestIp));        if (!$bytesAddr || !$bytesTest) {            return self::$checkedIps[$cacheKey] = false;        }        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {            $left = $netmask - 16 * ($i - 1);            $left = ($left <= 16) ? $left : 16;            $mask = ~(0xffff >> $left) & 0xffff;            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {                return self::$checkedIps[$cacheKey] = false;            }        }        return self::$checkedIps[$cacheKey] = true;    }    /**     * Anonymizes an IP/IPv6.     *     * Removes the last byte for v4 and the last 8 bytes for v6 IPs     */    public static function anonymize(string $ip): string    {        $wrappedIPv6 = false;        if ('[' === substr($ip, 0, 1) && ']' === substr($ip, -1, 1)) {            $wrappedIPv6 = true;            $ip = substr($ip, 1, -1);        }        $packedAddress = inet_pton($ip);        if (4 === \strlen($packedAddress)) {            $mask = '255.255.255.0';        } elseif ($ip === inet_ntop($packedAddress & inet_pton('::ffff:ffff:ffff'))) {            $mask = '::ffff:ffff:ff00';        } elseif ($ip === inet_ntop($packedAddress & inet_pton('::ffff:ffff'))) {            $mask = '::ffff:ff00';        } else {            $mask = 'ffff:ffff:ffff:ffff:0000:0000:0000:0000';        }        $ip = inet_ntop($packedAddress & inet_pton($mask));        if ($wrappedIPv6) {            $ip = '['.$ip.']';        }        return $ip;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_IpUtils_7885, Checks if an IPv4 or IPv6 address is contained in the list of given IPs or subnets.\n\n @param string|array $ips List of IPs or subnets (can be a string if only a single one)\n\n @return bool Whether the IP is valid\n, Checks if an IPv4 or IPv6 address is contained in the list of given IPs or subnets.,"    public static function checkIp(?string $requestIp, $ips)    {        if (!\is_array($ips)) {            $ips = [$ips];        }        $method = substr_count($requestIp, ':') > 1 ? 'checkIp6' : 'checkIp4';        foreach ($ips as $ip) {            if (self::$method($requestIp, $ip)) {                return true;            }        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_IpUtils_8804," Compares two IPv4 addresses.\n In case a subnet is given, it checks if it contains the request IP.\n\n @param string $ip IPv4 address or subnet in CIDR notation\n\n @return bool Whether the request IP matches the IP, or whether the request IP is within the CIDR subnet\n", Compares two IPv4 addresses.,"    public static function checkIp4(?string $requestIp, string $ip)    {        $cacheKey = $requestIp.'-'.$ip;        if (isset(self::$checkedIps[$cacheKey])) {            return self::$checkedIps[$cacheKey];        }        if (!filter_var($requestIp, \FILTER_VALIDATE_IP, \FILTER_FLAG_IPV4)) {            return self::$checkedIps[$cacheKey] = false;        }        if (false !== strpos($ip, '/')) {            [$address, $netmask] = explode('/', $ip, 2);            if ('0' === $netmask) {                return self::$checkedIps[$cacheKey] = filter_var($address, \FILTER_VALIDATE_IP, \FILTER_FLAG_IPV4);            }            if ($netmask < 0 || $netmask > 32) {                return self::$checkedIps[$cacheKey] = false;            }        } else {            $address = $ip;            $netmask = 32;        }        if (false === ip2long($address)) {            return self::$checkedIps[$cacheKey] = false;        }        return self::$checkedIps[$cacheKey] = 0 === substr_compare(sprintf('%032b', ip2long($requestIp)), sprintf('%032b', ip2long($address)), 0, $netmask);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_JsonException_8064, Thrown by Request::toArray() when the content cannot be JSON-decoded.\n\n @author Tobias Nyholm <tobias.nyholm@gmail.com>\n, Thrown by Request::toArray() when the content cannot be JSON-decoded.,final class JsonException extends \UnexpectedValueException implements RequestExceptionInterface{},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_JsonResponse_7889, Response represents an HTTP response in JSON format.\n\n Note that this class does not force the returned JSON content to be an\n object. It is however recommended that you do return an object as it\n protects yourself against XSSI and JSON-JavaScript Hijacking.\n\n @see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside\n\n @author Igor Wiedler <igor@wiedler.ch>\n, Response represents an HTTP response in JSON format.,"class JsonResponse extends Response{    protected $data;    protected $callback;    // Encode <, >, ', &, and "" characters in the JSON, making it also safe to be embedded into HTML.    // 15 === JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT    public const DEFAULT_ENCODING_OPTIONS = 15;    protected $encodingOptions = self::DEFAULT_ENCODING_OPTIONS;    /**     * @param mixed $data    The response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     * @param bool  $json    If the data is already a JSON string     */    public function __construct($data = null, int $status = 200, array $headers = [], bool $json = false)    {        parent::__construct('', $status, $headers);        if ($json && !\is_string($data) && !is_numeric($data) && !\is_callable([$data, '__toString'])) {            throw new \TypeError(sprintf('""%s"": If $json is set to true, argument $data must be a string or object implementing __toString(), ""%s"" given.', __METHOD__, get_debug_type($data)));        }        if (null === $data) {            $data = new \ArrayObject();        }        $json ? $this->setJson($data) : $this->setData($data);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::create(['key' => 'value'])     *         ->setSharedMaxAge(300);     *     * @param mixed $data    The JSON response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     *     * @return static     *     * @deprecated since Symfony 5.1, use __construct() instead.     */    public static function create($data = null, int $status = 200, array $headers = [])    {        trigger_deprecation('symfony/http-foundation', '5.1', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($data, $status, $headers);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::fromJsonString('{""key"": ""value""}')     *         ->setSharedMaxAge(300);     *     * @param string $data    The JSON response string     * @param int    $status  The response status code     * @param array  $headers An array of response headers     *     * @return static     */    public static function fromJsonString(string $data, int $status = 200, array $headers = [])    {        return new static($data, $status, $headers, true);    }    /**     * Sets the JSONP callback.     *     * @param string|null $callback The JSONP callback or null to use none     *     * @return $this     *     * @throws \InvalidArgumentException When the callback name is not valid     */    public function setCallback(string $callback = null)    {        if (null !== $callback) {            // partially taken from https://geekality.net/2011/08/03/valid-javascript-identifier/            // partially taken from https://github.com/willdurand/JsonpCallbackValidator            //      JsonpCallbackValidator is released under the MIT License. See https://github.com/willdurand/JsonpCallbackValidator/blob/v1.1.0/LICENSE for details.            //      (c) William Durand <william.durand1@gmail.com>            $pattern = '/^[$_\p{L}][$_\p{L}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\x{200C}\x{200D}]*(?:\[(?:""(?:\\\.|[^""\\\])*""|\'(?:\\\.|[^\'\\\])*\'|\d+)\])*?$/u';            $reserved = [                'break', 'do', 'instanceof', 'typeof', 'case', 'else', 'new', 'var', 'catch', 'finally', 'return', 'void', 'continue', 'for', 'switch', 'while',                'debugger', 'function', 'this', 'with', 'default', 'if', 'throw', 'delete', 'in', 'try', 'class', 'enum', 'extends', 'super',  'const', 'export',                'import', 'implements', 'let', 'private', 'public', 'yield', 'interface', 'package', 'protected', 'static', 'null', 'true', 'false',            ];            $parts = explode('.', $callback);            foreach ($parts as $part) {                if (!preg_match($pattern, $part) || \in_array($part, $reserved, true)) {                    throw new \InvalidArgumentException('The callback name is not valid.');                }            }        }        $this->callback = $callback;        return $this->update();    }    /**     * Sets a raw string containing a JSON document to be sent.     *     * @return $this     */    public function setJson(string $json)    {        $this->data = $json;        return $this->update();    }    /**     * Sets the data to be sent as JSON.     *     * @param mixed $data     *     * @return $this     *     * @throws \InvalidArgumentException     */    public function setData($data = [])    {        try {            $data = json_encode($data, $this->encodingOptions);        } catch (\Exception $e) {            if ('Exception' === \get_class($e) && 0 === strpos($e->getMessage(), 'Failed calling ')) {                throw $e->getPrevious() ?: $e;            }            throw $e;        }        if (\PHP_VERSION_ID >= 70300 && (\JSON_THROW_ON_ERROR & $this->encodingOptions)) {            return $this->setJson($data);        }        if (\JSON_ERROR_NONE !== json_last_error()) {            throw new \InvalidArgumentException(json_last_error_msg());        }        return $this->setJson($data);    }    /**     * Returns options used while encoding data to JSON.     *     * @return int     */    public function getEncodingOptions()    {        return $this->encodingOptions;    }    /**     * Sets options used while encoding data to JSON.     *     * @return $this     */    public function setEncodingOptions(int $encodingOptions)    {        $this->encodingOptions = $encodingOptions;        return $this->setData(json_decode($this->data));    }    /**     * Updates the content and headers according to the JSON data and callback.     *     * @return $this     */    protected function update()    {        if (null !== $this->callback) {            // Not using application/javascript for compatibility reasons with older browsers.            $this->headers->set('Content-Type', 'text/javascript');            return $this->setContent(sprintf('/**/%s(%s);', $this->callback, $this->data));        }        // Only set the header when there is none or when it equals 'text/javascript' (from a previous update with callback)        // in order to not overwrite a custom definition.        if (!$this->headers->has('Content-Type') || 'text/javascript' === $this->headers->get('Content-Type')) {            $this->headers->set('Content-Type', 'application/json');        }        return $this->setContent($this->data);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_JsonResponse_7892, Sets options used while encoding data to JSON.\n\n @return $this\n, Sets options used while encoding data to JSON.,    public function setEncodingOptions(int $encodingOptions)    {        $this->encodingOptions = $encodingOptions;        return $this->setData(json_decode($this->data));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_NamespacedAttributeBag_10026, This class provides structured storage of session attributes using\n a name spacing character in the key.\n\n @author Drak <drak@zikula.org>\n\n @deprecated since Symfony 5.3\n, This class provides structured storage of session attributes using,"class NamespacedAttributeBag extends AttributeBag{    private $namespaceCharacter;    /**     * @param string $storageKey         Session storage key     * @param string $namespaceCharacter Namespace character to use in keys     */    public function __construct(string $storageKey = '_sf2_attributes', string $namespaceCharacter = '/')    {        $this->namespaceCharacter = $namespaceCharacter;        parent::__construct($storageKey);    }    /**     * {@inheritdoc}     */    public function has(string $name)    {        // reference mismatch: if fixed, re-introduced in array_key_exists; keep as it is        $attributes = $this->resolveAttributePath($name);        $name = $this->resolveKey($name);        if (null === $attributes) {            return false;        }        return \array_key_exists($name, $attributes);    }    /**     * {@inheritdoc}     */    public function get(string $name, $default = null)    {        // reference mismatch: if fixed, re-introduced in array_key_exists; keep as it is        $attributes = $this->resolveAttributePath($name);        $name = $this->resolveKey($name);        if (null === $attributes) {            return $default;        }        return \array_key_exists($name, $attributes) ? $attributes[$name] : $default;    }    /**     * {@inheritdoc}     */    public function set(string $name, $value)    {        $attributes = &$this->resolveAttributePath($name, true);        $name = $this->resolveKey($name);        $attributes[$name] = $value;    }    /**     * {@inheritdoc}     */    public function remove(string $name)    {        $retval = null;        $attributes = &$this->resolveAttributePath($name);        $name = $this->resolveKey($name);        if (null !== $attributes && \array_key_exists($name, $attributes)) {            $retval = $attributes[$name];            unset($attributes[$name]);        }        return $retval;    }    /**     * Resolves a path in attributes property and returns it as a reference.     *     * This method allows structured namespacing of session attributes.     *     * @param string $name         Key name     * @param bool   $writeContext Write context, default false     *     * @return array|null     */    protected function &resolveAttributePath(string $name, bool $writeContext = false)    {        $array = &$this->attributes;        $name = (0 === strpos($name, $this->namespaceCharacter)) ? substr($name, 1) : $name;        // Check if there is anything to do, else return        if (!$name) {            return $array;        }        $parts = explode($this->namespaceCharacter, $name);        if (\count($parts) < 2) {            if (!$writeContext) {                return $array;            }            $array[$parts[0]] = [];            return $array;        }        unset($parts[\count($parts) - 1]);        foreach ($parts as $part) {            if (null !== $array && !\array_key_exists($part, $array)) {                if (!$writeContext) {                    $null = null;                    return $null;                }                $array[$part] = [];            }            $array = &$array[$part];        }        return $array;    }    /**     * Resolves the key from the name.     *     * This is the last part in a dot separated string.     *     * @return string     */    protected function resolveKey(string $name)    {        if (false !== $pos = strrpos($name, $this->namespaceCharacter)) {            $name = substr($name, $pos + 1);        }        return $name;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_ParameterBag_7894, ParameterBag is a container for key/value pairs.\n\n @author Fabien Potencier <fabien@symfony.com>\n, ParameterBag is a container for key/value pairs.,"class ParameterBag implements \IteratorAggregate, \Countable{    /**     * Parameter storage.     */    protected $parameters;    public function __construct(array $parameters = [])    {        $this->parameters = $parameters;    }    /**     * Returns the parameters.     *     * @param string|null $key The name of the parameter to return or null to get them all     *     * @return array An array of parameters     */    public function all(/*string $key = null*/)    {        $key = \func_num_args() > 0 ? func_get_arg(0) : null;        if (null === $key) {            return $this->parameters;        }        if (!\is_array($value = $this->parameters[$key] ?? [])) {            throw new BadRequestException(sprintf('Unexpected value for parameter ""%s"": expecting ""array"", got ""%s"".', $key, get_debug_type($value)));        }        return $value;    }    /**     * Returns the parameter keys.     *     * @return array An array of parameter keys     */    public function keys()    {        return array_keys($this->parameters);    }    /**     * Replaces the current parameters by a new set.     */    public function replace(array $parameters = [])    {        $this->parameters = $parameters;    }    /**     * Adds parameters.     */    public function add(array $parameters = [])    {        $this->parameters = array_replace($this->parameters, $parameters);    }    /**     * Returns a parameter by name.     *     * @param mixed $default The default value if the parameter key does not exist     *     * @return mixed     */    public function get(string $key, $default = null)    {        return \array_key_exists($key, $this->parameters) ? $this->parameters[$key] : $default;    }    /**     * Sets a parameter by name.     *     * @param mixed $value The value     */    public function set(string $key, $value)    {        $this->parameters[$key] = $value;    }    /**     * Returns true if the parameter is defined.     *     * @return bool true if the parameter exists, false otherwise     */    public function has(string $key)    {        return \array_key_exists($key, $this->parameters);    }    /**     * Removes a parameter.     */    public function remove(string $key)    {        unset($this->parameters[$key]);    }    /**     * Returns the alphabetic characters of the parameter value.     *     * @return string The filtered value     */    public function getAlpha(string $key, string $default = '')    {        return preg_replace('/[^[:alpha:]]/', '', $this->get($key, $default));    }    /**     * Returns the alphabetic characters and digits of the parameter value.     *     * @return string The filtered value     */    public function getAlnum(string $key, string $default = '')    {        return preg_replace('/[^[:alnum:]]/', '', $this->get($key, $default));    }    /**     * Returns the digits of the parameter value.     *     * @return string The filtered value     */    public function getDigits(string $key, string $default = '')    {        // we need to remove - and + because they're allowed in the filter        return str_replace(['-', '+'], '', $this->filter($key, $default, \FILTER_SANITIZE_NUMBER_INT));    }    /**     * Returns the parameter value converted to integer.     *     * @return int The filtered value     */    public function getInt(string $key, int $default = 0)    {        return (int) $this->get($key, $default);    }    /**     * Returns the parameter value converted to boolean.     *     * @return bool The filtered value     */    public function getBoolean(string $key, bool $default = false)    {        return $this->filter($key, $default, \FILTER_VALIDATE_BOOLEAN);    }    /**     * Filter key.     *     * @param mixed $default Default = null     * @param int   $filter  FILTER_* constant     * @param mixed $options Filter options     *     * @see https://php.net/filter-var     *     * @return mixed     */    public function filter(string $key, $default = null, int $filter = \FILTER_DEFAULT, $options = [])    {        $value = $this->get($key, $default);        // Always turn $options into an array - this allows filter_var option shortcuts.        if (!\is_array($options) && $options) {            $options = ['flags' => $options];        }        // Add a convenience check for arrays.        if (\is_array($value) && !isset($options['flags'])) {            $options['flags'] = \FILTER_REQUIRE_ARRAY;        }        if ((\FILTER_CALLBACK & $filter) && !(($options['options'] ?? null) instanceof \Closure)) {            trigger_deprecation('symfony/http-foundation', '5.2', 'Not passing a Closure together with FILTER_CALLBACK to ""%s()"" is deprecated. Wrap your filter in a closure instead.', __METHOD__);            // throw new \InvalidArgumentException(sprintf('A Closure must be passed to ""%s()"" when FILTER_CALLBACK is used, ""%s"" given.', __METHOD__, get_debug_type($options['options'] ?? null)));        }        return filter_var($value, $filter, $options);    }    /**     * Returns an iterator for parameters.     *     * @return \ArrayIterator An \ArrayIterator instance     */    public function getIterator()    {        return new \ArrayIterator($this->parameters);    }    /**     * Returns the number of parameters.     *     * @return int The number of parameters     */    public function count()    {        return \count($this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_RedirectResponse_8819, RedirectResponse represents an HTTP response doing a redirect.\n\n @author Fabien Potencier <fabien@symfony.com>\n, RedirectResponse represents an HTTP response doing a redirect.,"class RedirectResponse extends Response{    protected $targetUrl;    /**     * Creates a redirect response so that it conforms to the rules defined for a redirect status code.     *     * @param string $url     The URL to redirect to. The URL should be a full URL, with schema etc.,     *                        but practically every browser redirects on paths only as well     * @param int    $status  The status code (302 by default)     * @param array  $headers The headers (Location is always set to the given URL)     *     * @throws \InvalidArgumentException     *     * @see https://tools.ietf.org/html/rfc2616#section-10.3     */    public function __construct(string $url, int $status = 302, array $headers = [])    {        parent::__construct('', $status, $headers);        $this->setTargetUrl($url);        if (!$this->isRedirect()) {            throw new \InvalidArgumentException(sprintf('The HTTP status code is not a redirect (""%s"" given).', $status));        }        if (301 == $status && !\array_key_exists('cache-control', array_change_key_case($headers, \CASE_LOWER))) {            $this->headers->remove('cache-control');        }    }    /**     * Factory method for chainability.     *     * @param string $url The URL to redirect to     *     * @return static     *     * @deprecated since Symfony 5.1, use __construct() instead.     */    public static function create($url = '', int $status = 302, array $headers = [])    {        trigger_deprecation('symfony/http-foundation', '5.1', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($url, $status, $headers);    }    /**     * Returns the target URL.     *     * @return string target URL     */    public function getTargetUrl()    {        return $this->targetUrl;    }    /**     * Sets the redirect target of this response.     *     * @return $this     *     * @throws \InvalidArgumentException     */    public function setTargetUrl(string $url)    {        if ('' === $url) {            throw new \InvalidArgumentException('Cannot redirect to an empty URL.');        }        $this->targetUrl = $url;        $this->setContent(            sprintf('<!DOCTYPE html><html>    <head>        <meta charset=""UTF-8"" />        <meta http-equiv=""refresh"" content=""0;url=\'%1$s\'"" />        <title>Redirecting to %1$s</title>    </head>    <body>        Redirecting to <a href=""%1$s"">%1$s</a>.    </body></html>', htmlspecialchars($url, \ENT_QUOTES, 'UTF-8')));        $this->headers->set('Location', $url);        return $this;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_RequestMatcher_8895, RequestMatcher compares a pre-defined set of checks against a Request instance.\n\n @author Fabien Potencier <fabien@symfony.com>\n, RequestMatcher compares a pre-defined set of checks against a Request instance.,"class RequestMatcher implements RequestMatcherInterface{    /**     * @var string|null     */    private $path;    /**     * @var string|null     */    private $host;    /**     * @var int|null     */    private $port;    /**     * @var string[]     */    private $methods = [];    /**     * @var string[]     */    private $ips = [];    /**     * @var array     */    private $attributes = [];    /**     * @var string[]     */    private $schemes = [];    /**     * @param string|string[]|null $methods     * @param string|string[]|null $ips     * @param string|string[]|null $schemes     */    public function __construct(string $path = null, string $host = null, $methods = null, $ips = null, array $attributes = [], $schemes = null, int $port = null)    {        $this->matchPath($path);        $this->matchHost($host);        $this->matchMethod($methods);        $this->matchIps($ips);        $this->matchScheme($schemes);        $this->matchPort($port);        foreach ($attributes as $k => $v) {            $this->matchAttribute($k, $v);        }    }    /**     * Adds a check for the HTTP scheme.     *     * @param string|string[]|null $scheme An HTTP scheme or an array of HTTP schemes     */    public function matchScheme($scheme)    {        $this->schemes = null !== $scheme ? array_map('strtolower', (array) $scheme) : [];    }    /**     * Adds a check for the URL host name.     */    public function matchHost(?string $regexp)    {        $this->host = $regexp;    }    /**     * Adds a check for the the URL port.     *     * @param int|null $port The port number to connect to     */    public function matchPort(?int $port)    {        $this->port = $port;    }    /**     * Adds a check for the URL path info.     */    public function matchPath(?string $regexp)    {        $this->path = $regexp;    }    /**     * Adds a check for the client IP.     *     * @param string $ip A specific IP address or a range specified using IP/netmask like 192.168.1.0/24     */    public function matchIp(string $ip)    {        $this->matchIps($ip);    }    /**     * Adds a check for the client IP.     *     * @param string|string[]|null $ips A specific IP address or a range specified using IP/netmask like 192.168.1.0/24     */    public function matchIps($ips)    {        $ips = null !== $ips ? (array) $ips : [];        $this->ips = array_reduce($ips, static function (array $ips, string $ip) {            return array_merge($ips, preg_split('/\s*,\s*/', $ip));        }, []);    }    /**     * Adds a check for the HTTP method.     *     * @param string|string[]|null $method An HTTP method or an array of HTTP methods     */    public function matchMethod($method)    {        $this->methods = null !== $method ? array_map('strtoupper', (array) $method) : [];    }    /**     * Adds a check for request attribute.     */    public function matchAttribute(string $key, string $regexp)    {        $this->attributes[$key] = $regexp;    }    /**     * {@inheritdoc}     */    public function matches(Request $request)    {        if ($this->schemes && !\in_array($request->getScheme(), $this->schemes, true)) {            return false;        }        if ($this->methods && !\in_array($request->getMethod(), $this->methods, true)) {            return false;        }        foreach ($this->attributes as $key => $pattern) {            $requestAttribute = $request->attributes->get($key);            if (!\is_string($requestAttribute)) {                return false;            }            if (!preg_match('{'.$pattern.'}', $requestAttribute)) {                return false;            }        }        if (null !== $this->path && !preg_match('{'.$this->path.'}', rawurldecode($request->getPathInfo()))) {            return false;        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_RequestMatcher_8898, Adds a check for the the URL port.\n\n @param int|null $port The port number to connect to\n, Adds a check for the the URL port.,    public function matchPort(?int $port)    {        $this->port = $port;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_RequestMatcher_8902, Adds a check for the HTTP method.\n\n @param string|string[]|null $method An HTTP method or an array of HTTP methods\n, Adds a check for the HTTP method.,"    public function matchMethod($method)    {        $this->methods = null !== $method ? array_map('strtoupper', (array) $method) : [];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_RequestMatcher_9851, Adds a check for the client IP.\n\n @param string|string[]|null $ips A specific IP address or a range specified using IP/netmask like 192.168.1.0/24\n, Adds a check for the client IP.,"    public function matchIps($ips)    {        $ips = null !== $ips ? (array) $ips : [];        $this->ips = array_reduce($ips, static function (array $ips, string $ip) {            return array_merge($ips, preg_split('/\s*,\s*/', $ip));        }, []);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_RequestStack_7988, Request stack that controls the lifecycle of requests.\n\n @author Benjamin Eberlei <kontakt@beberlei.de>\n, Request stack that controls the lifecycle of requests.,"class RequestStack{    /**     * @var Request[]     */    private $requests = [];    /**     * Pushes a Request on the stack.     *     * This method should generally not be called directly as the stack     * management should be taken care of by the application itself.     */    public function push(Request $request)    {        $this->requests[] = $request;    }    /**     * Pops the current request from the stack.     *     * This operation lets the current request go out of scope.     *     * This method should generally not be called directly as the stack     * management should be taken care of by the application itself.     *     * @return Request|null     */    public function pop()    {        if (!$this->requests) {            return null;        }        return array_pop($this->requests);    }    /**     * @return Request|null     */    public function getCurrentRequest()    {        return end($this->requests) ?: null;    }    /**     * Gets the main request.     *     * Be warned that making your code aware of the main request     * might make it un-compatible with other features of your framework     * like ESI support.     */    public function getMainRequest(): ?Request    {        if (!$this->requests) {            return null;        }        return $this->requests[0];    }    /**     * Gets the master request.     *     * @return Request|null     *     * @deprecated since symfony/http-foundation 5.3, use getMainRequest() instead     */    public function getMasterRequest()    {        trigger_deprecation('symfony/http-foundation', '5.3', '""%s()"" is deprecated, use ""getMainRequest()"" instead.', __METHOD__);        return $this->getMainRequest();    }    /**     * Returns the parent request of the current.     *     * Be warned that making your code aware of the parent request     * might make it un-compatible with other features of your framework     * like ESI support.     *     * If current Request is the main request, it returns null.     *     * @return Request|null     */    public function getParentRequest()    {        $pos = \count($this->requests) - 2;        if (!isset($this->requests[$pos])) {            return null;        }        return $this->requests[$pos];    }    /**     * Gets the current session.     *     * @throws SessionNotFoundException     */    public function getSession(): SessionInterface    {        if ((null !== $request = end($this->requests) ?: null) && $request->hasSession()) {            return $request->getSession();        }        throw new SessionNotFoundException();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_RequestStack_8910, Gets the main request.\n\n Be warned that making your code aware of the main request\n might make it un-compatible with other features of your framework\n like ESI support.\n, Gets the main request.,    public function getMainRequest(): ?Request    {        if (!$this->requests) {            return null;        }        return $this->requests[0];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7912, Gets the set of trusted headers from trusted proxies.\n\n @return int A bit field of Request::HEADER_, Gets the set of trusted headers from trusted proxies.,    public static function getTrustedHeaderSet()    {        return self::$trustedHeaderSet;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7914, Gets the list of trusted host patterns.\n\n @return array An array of trusted host patterns\n, Gets the list of trusted host patterns.,    public static function getTrustedHosts()    {        return self::$trustedHostPatterns;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7923," Returns the client IP address.\n\n This method can read the client IP address from the ""X-Forwarded-For"" header\n when trusted proxies were set via ""setTrustedProxies()"". The ""X-Forwarded-For""\n header value is a comma+space separated list of IP addresses, the left-most\n being the original client, and each successive proxy that passed the request\n adding the IP address where it received the request from.\n\n If your reverse proxy uses a different header name than ""X-Forwarded-For"",\n (""Client-Ip"" for instance), configure it via the $trustedHeaderSet\n argument of the Request::setTrustedProxies() method instead.\n\n @return string|null The client IP address\n\n @see getClientIps()\n @see https://wikipedia.org/wiki/X-Forwarded-For\n", Returns the client IP address.,    public function getClientIp()    {        $ipAddresses = $this->getClientIps();        return $ipAddresses[0];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7924, Returns current script name.\n\n @return string\n, Returns current script name.,"    public function getScriptName()    {        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7925, Returns the path being requested relative to the executed script.\n\n The path info always starts with a /.\n\n Suppose this request is instantiated from /mysite on localhost:\n\n        \n @return string The raw path (i.e. not urldecoded)\n, Returns the path being requested relative to the executed script.,    public function getPathInfo()    {        if (null === $this->pathInfo) {            $this->pathInfo = $this->preparePathInfo();        }        return $this->pathInfo;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7928, Returns the real base URL received by the webserver from which this request is executed.\n The URL does not include trusted reverse proxy prefix.\n\n @return string The raw URL (i.e. not urldecoded)\n, Returns the real base URL received by the webserver from which this request is executed.,    private function getBaseUrlReal()    {        if (null === $this->baseUrl) {            $this->baseUrl = $this->prepareBaseUrl();        }        return $this->baseUrl;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7939," Returns the path as relative reference from the current Request path.\n\n Only the URIs path component (no schema, host etc.) is relevant and must be given.\n Both paths must be absolute and not contain relative parts.\n Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n Furthermore, they can be used to reduce the link size in documents.\n\n Example target paths, given a base path of ""/a/b/c/d"":\n - ""/a/b/c/d""     -> """"\n - ""/a/b/c/""      -> ""./""\n - ""/a/b/""        -> ""../""\n - ""/a/b/c/other"" -> ""other""\n - ""/a/x/y""       -> ""../../x/y""\n\n @return string The relative target path\n", Returns the path as relative reference from the current Request path.,"    public function getRelativeUriForPath(string $path)    {        // be sure that we are dealing with an absolute path        if (!isset($path[0]) || '/' !== $path[0]) {            return $path;        }        if ($path === $basePath = $this->getPathInfo()) {            return '';        }        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);        $targetDirs = explode('/', substr($path, 1));        array_pop($sourceDirs);        $targetFile = array_pop($targetDirs);        foreach ($sourceDirs as $i => $dir) {            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {                unset($sourceDirs[$i], $targetDirs[$i]);            } else {                break;            }        }        $targetDirs[] = $targetFile;        $path = str_repeat('../', \count($sourceDirs)).implode('/', $targetDirs);        // A reference to the same base directory or an empty subdirectory must be prefixed with ""./"".        // This also applies to a segment with a colon character (e.g., ""file:colon"") that cannot be used        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name        // (see https://tools.ietf.org/html/rfc3986#section-4.2).        return !isset($path[0]) || '/' === $path[0]            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)            ? ""./$path"" : $path;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7953, Get the default locale.\n\n @return string\n, Get the default locale.,    public function getDefaultLocale()    {        return $this->defaultLocale;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7961," Gets the request body decoded as array, typically from a JSON payload.\n\n @throws JsonException When the body cannot be decoded to an array\n\n @return array\n"," Gets the request body decoded as array, typically from a JSON payload.","    public function toArray()    {        if ('' === $content = $this->getContent()) {            throw new JsonException('Request body is empty.');        }        try {            $content = json_decode($content, true, 512, \JSON_BIGINT_AS_STRING | (\PHP_VERSION_ID >= 70300 ? \JSON_THROW_ON_ERROR : 0));        } catch (\JsonException $e) {            throw new JsonException('Could not decode request body.', $e->getCode(), $e);        }        if (\PHP_VERSION_ID < 70300 && \JSON_ERROR_NONE !== json_last_error()) {            throw new JsonException('Could not decode request body: '.json_last_error_msg(), json_last_error());        }        if (!\is_array($content)) {            throw new JsonException(sprintf('JSON content was expected to decode to an array, ""%s"" returned.', get_debug_type($content)));        }        return $content;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7965, Gets a list of charsets acceptable by the client browser.\n\n @return array List of charsets in preferable order\n, Gets a list of charsets acceptable by the client browser.,    public function getCharsets()    {        if (null !== $this->charsets) {            return $this->charsets;        }        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7976," Indicates whether this request originated from a trusted proxy.\n\n This can be useful to determine whether or not to trust the\n contents of a proxy-specific header.\n\n @return bool true if the request came from a trusted proxy, false otherwise\n", Indicates whether this request originated from a trusted proxy.,"    public function isFromTrustedProxy()    {        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR', ''), self::$trustedProxies);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8825, Clones the current request.\n\n Note that the session is not cloned as duplicated requests\n are most of the time sub-requests of the main one.\n, Clones the current request.,    public function __clone()    {        $this->query = clone $this->query;        $this->request = clone $this->request;        $this->attributes = clone $this->attributes;        $this->cookies = clone $this->cookies;        $this->files = clone $this->files;        $this->server = clone $this->server;        $this->headers = clone $this->headers;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8827," Overrides the PHP global variables according to this request instance.\n\n It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n $_FILES is never overridden, see rfc1867\n", Overrides the PHP global variables according to this request instance.,"    public function overrideGlobals()    {        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));        $_GET = $this->query->all();        $_POST = $this->request->all();        $_SERVER = $this->server->all();        $_COOKIE = $this->cookies->all();        foreach ($this->headers->all() as $key => $value) {            $key = strtoupper(str_replace('-', '_', $key));            if (\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {                $_SERVER[$key] = implode(', ', $value);            } else {                $_SERVER['HTTP_'.$key] = implode(', ', $value);            }        }        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];        $requestOrder = ini_get('request_order') ?: ini_get('variables_order');        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';        $_REQUEST = [[]];        foreach (str_split($requestOrder) as $order) {            $_REQUEST[] = $request[$order];        }        $_REQUEST = array_merge(...$_REQUEST);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8834," Enables support for the _method request parameter to determine the intended HTTP method.\n\n Be warned that enabling this feature might lead to CSRF issues in your code.\n Check that you are using CSRF tokens when required.\n If the HTTP method parameter override is enabled, an html-form with method ""POST"" can be altered\n and used to send a ""PUT"" or ""DELETE"" request via the _method request parameter.\n If these methods are not protected against CSRF, this presents a possible vulnerability.\n\n The HTTP method can only be overridden when the real HTTP method is POST.\n", Enables support for the _method request parameter to determine the intended HTTP method.,    public static function enableHttpMethodParameterOverride()    {        self::$httpMethodParameterOverride = true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8835," Checks whether support for the _method request parameter is enabled.\n\n @return bool True when the _method request parameter is enabled, false otherwise\n", Checks whether support for the _method request parameter is enabled.,    public static function getHttpMethodParameterOverride()    {        return self::$httpMethodParameterOverride;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8837, Whether the request contains a Session which was started in one of the\n previous requests.\n\n @return bool\n, Whether the request contains a Session which was started in one of the,    public function hasPreviousSession()    {        // the check for $this->session avoids malicious users trying to fake a session cookie with proper name        return $this->hasSession() && $this->cookies->has($this->getSession()->getName());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8849, Returns the user.\n\n @return string|null\n, Returns the user.,    public function getUser()    {        return $this->headers->get('PHP_AUTH_USER');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8855, Generates a normalized URI (URL) for the Request.\n\n @return string A normalized URI (URL) for the Request\n\n @see getQueryString()\n, Generates a normalized URI (URL) for the Request.,    public function getUri()    {        if (null !== $qs = $this->getQueryString()) {            $qs = '?'.$qs;        }        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8864, Gets the mime type associated with the format.\n\n @return string|null The associated mime type (null if not found)\n, Gets the mime type associated with the format.,    public function getMimeType(string $format)    {        if (null === static::$formats) {            static::initializeFormats();        }        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8873, Get the locale.\n\n @return string\n, Get the locale.,    public function getLocale()    {        return null === $this->locale ? $this->defaultLocale : $this->locale;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8874," Checks if the request method is of specified type.\n\n @param string $method Uppercase request method (GET, POST etc)\n\n @return bool\n", Checks if the request method is of specified type.,    public function isMethod(string $method)    {        return $this->getMethod() === strtoupper($method);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8876, Checks whether or not the method is idempotent.\n\n @return bool\n, Checks whether or not the method is idempotent.,"    public function isMethodIdempotent()    {        return \in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8884, Gets a list of encodings acceptable by the client browser.\n\n @return array List of encodings in preferable order\n, Gets a list of encodings acceptable by the client browser.,    public function getEncodings()    {        if (null !== $this->encodings) {            return $this->encodings;        }        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8886," Returns true if the request is an XMLHttpRequest.\n\n It works if your JavaScript library sets an X-Requested-With HTTP header.\n It is known to work with common JavaScript frameworks:\n\n @see https://wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n\n @return bool true if the request is an XMLHttpRequest, false otherwise\n", Returns true if the request is an XMLHttpRequest.,    public function isXmlHttpRequest()    {        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8887, Checks whether the client browser prefers safe content or not according to RFC8674.\n\n @see https://tools.ietf.org/html/rfc8674\n, Checks whether the client browser prefers safe content or not according to RFC8674.,    public function preferSafeContent(): bool    {        if (null !== $this->isSafeContentPreferred) {            return $this->isSafeContentPreferred;        }        if (!$this->isSecure()) {            // see https://tools.ietf.org/html/rfc8674#section-3            $this->isSafeContentPreferred = false;            return $this->isSafeContentPreferred;        }        $this->isSafeContentPreferred = AcceptHeader::fromString($this->headers->get('Prefer'))->has('safe');        return $this->isSafeContentPreferred;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9774, Sets a callable able to create a Request instance.\n\n This is mainly useful when you need to override the Request class\n to keep BC with an existing system. It should not be used for any\n other purpose.\n, Sets a callable able to create a Request instance.,    public static function setFactory(?callable $callable)    {        self::$requestFactory = $callable;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9778," Sets a list of trusted proxies.\n\n You should only list the reverse proxies that you manage directly.\n\n @param array $proxies          A list of trusted proxies, the string 'REMOTE_ADDR' will be replaced with $_SERVER['REMOTE_ADDR']\n @param int   $trustedHeaderSet A bit field of Request::HEADER_", Sets a list of trusted proxies.,"    public static function setTrustedProxies(array $proxies, int $trustedHeaderSet)    {        if (self::HEADER_X_FORWARDED_ALL === $trustedHeaderSet) {            trigger_deprecation('symfony/http-foundation', '5.2', 'The ""HEADER_X_FORWARDED_ALL"" constant is deprecated, use either ""HEADER_X_FORWARDED_FOR | HEADER_X_FORWARDED_HOST | HEADER_X_FORWARDED_PORT | HEADER_X_FORWARDED_PROTO"" or ""HEADER_X_FORWARDED_AWS_ELB"" or ""HEADER_X_FORWARDED_TRAEFIK"" constants instead.');        }        self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {            if ('REMOTE_ADDR' !== $proxy) {                $proxies[] = $proxy;            } elseif (isset($_SERVER['REMOTE_ADDR'])) {                $proxies[] = $_SERVER['REMOTE_ADDR'];            }            return $proxies;        }, []);        self::$trustedHeaderSet = $trustedHeaderSet;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9786, Gets the Session.\n\n @return SessionInterface The session\n, Gets the Session.,    public function getSession()    {        $session = $this->session;        if (!$session instanceof SessionInterface && null !== $session) {            $this->setSession($session = $session());        }        if (null === $session) {            throw new SessionNotFoundException('Session has not been set.');        }        return $session;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9794, Returns the root path from which this request is executed.\n\n Suppose that an index.php file instantiates this request object:\n\n        \n @return string The raw path (i.e. not urldecoded)\n, Returns the root path from which this request is executed.,    public function getBasePath()    {        if (null === $this->basePath) {            $this->basePath = $this->prepareBasePath();        }        return $this->basePath;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9795," Returns the root URL from which this request is executed.\n\n The base URL never ends with a /.\n\n This is similar to getBasePath(), except that it also includes the\n script filename (e.g. index.php) if one exists.\n\n @return string The raw URL (i.e. not urldecoded)\n", Returns the root URL from which this request is executed.,"    public function getBaseUrl()    {        $trustedPrefix = '';        // the proxy prefix must be prepended to any prefix being needed at the webserver level        if ($this->isFromTrustedProxy() && $trustedPrefixValues = $this->getTrustedValues(self::HEADER_X_FORWARDED_PREFIX)) {            $trustedPrefix = rtrim($trustedPrefixValues[0], '/');        }        return $trustedPrefix.$this->getBaseUrlReal();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9798," Returns the port on which the request is made.\n\n This method can read the client port from the ""X-Forwarded-Port"" header\n when trusted proxies were set via ""setTrustedProxies()"".\n\n The ""X-Forwarded-Port"" header must contain the client port.\n\n @return int|string can be a string if fetched from the server bag\n", Returns the port on which the request is made.,"    public function getPort()    {        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {            $host = $host[0];        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {            $host = $host[0];        } elseif (!$host = $this->headers->get('HOST')) {            return $this->server->get('SERVER_PORT');        }        if ('[' === $host[0]) {            $pos = strpos($host, ':', strrpos($host, ']'));        } else {            $pos = strrpos($host, ':');        }        if (false !== $pos && $port = substr($host, $pos + 1)) {            return (int) $port;        }        return 'https' === $this->getScheme() ? 443 : 80;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9810," Returns the host name.\n\n This method can read the client host name from the ""X-Forwarded-Host"" header\n when trusted proxies were set via ""setTrustedProxies()"".\n\n The ""X-Forwarded-Host"" header must contain the client host name.\n\n @return string\n\n @throws SuspiciousOperationException when the host name is invalid or not trusted\n", Returns the host name.,"    public function getHost()    {        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {            $host = $host[0];        } elseif (!$host = $this->headers->get('HOST')) {            if (!$host = $this->server->get('SERVER_NAME')) {                $host = $this->server->get('SERVER_ADDR', '');            }        }        // trim and remove port number from host        // host is lowercase as per RFC 952/2181        $host = strtolower(preg_replace('/:\d+$/', '', trim($host)));        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names        if ($host && '' !== preg_replace('/(?:^\[)?[a-zA-Z0-9-:\]_]+\.?/', '', $host)) {            if (!$this->isHostValid) {                return '';            }            $this->isHostValid = false;            throw new SuspiciousOperationException(sprintf('Invalid Host ""%s"".', $host));        }        if (\count(self::$trustedHostPatterns) > 0) {            // to avoid host header injection attacks, you should provide a list of trusted host patterns            if (\in_array($host, self::$trustedHosts)) {                return $host;            }            foreach (self::$trustedHostPatterns as $pattern) {                if (preg_match($pattern, $host)) {                    self::$trustedHosts[] = $host;                    return $host;                }            }            if (!$this->isHostValid) {                return '';            }            $this->isHostValid = false;            throw new SuspiciousOperationException(sprintf('Untrusted Host ""%s"".', $host));        }        return $host;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9813," Gets the ""real"" request method.\n\n @return string The request method\n\n @see getMethod()\n"," Gets the ""real"" request method.","    public function getRealMethod()    {        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9818, Sets the request format.\n, Sets the request format.,    public function setRequestFormat(?string $format)    {        $this->format = $format;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9819, Gets the format associated with the request.\n\n @return string|null The format (null if no content type is present)\n, Gets the format associated with the request.,"    public function getContentType()    {        return $this->getFormat($this->headers->get('CONTENT_TYPE', ''));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9838, The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24)\n\n Code subject to the new BSD license (https://framework.zend.com/license).\n\n Copyright (c) 2005-2010 Zend Technologies USA Inc. (https://www.zend.com/)\n, The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24),"    protected function prepareRequestUri()    {        $requestUri = '';        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)            $requestUri = $this->server->get('UNENCODED_URL');            $this->server->remove('UNENCODED_URL');            $this->server->remove('IIS_WasUrlRewritten');        } elseif ($this->server->has('REQUEST_URI')) {            $requestUri = $this->server->get('REQUEST_URI');            if ('' !== $requestUri && '/' === $requestUri[0]) {                // To only use path and query remove the fragment.                if (false !== $pos = strpos($requestUri, '#')) {                    $requestUri = substr($requestUri, 0, $pos);                }            } else {                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,                // only use URL path.                $uriComponents = parse_url($requestUri);                if (isset($uriComponents['path'])) {                    $requestUri = $uriComponents['path'];                }                if (isset($uriComponents['query'])) {                    $requestUri .= '?'.$uriComponents['query'];                }            }        } elseif ($this->server->has('ORIG_PATH_INFO')) {            // IIS 5.0, PHP as CGI            $requestUri = $this->server->get('ORIG_PATH_INFO');            if ('' != $this->server->get('QUERY_STRING')) {                $requestUri .= '?'.$this->server->get('QUERY_STRING');            }            $this->server->remove('ORIG_PATH_INFO');        }        // normalize the request URI to ease creating sub-requests from this request        $this->server->set('REQUEST_URI', $requestUri);        return $requestUri;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9839, Prepares the base URL.\n\n @return string\n, Prepares the base URL.,"    protected function prepareBaseUrl()    {        $filename = basename($this->server->get('SCRIPT_FILENAME', ''));        if (basename($this->server->get('SCRIPT_NAME', '')) === $filename) {            $baseUrl = $this->server->get('SCRIPT_NAME');        } elseif (basename($this->server->get('PHP_SELF', '')) === $filename) {            $baseUrl = $this->server->get('PHP_SELF');        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME', '')) === $filename) {            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility        } else {            // Backtrack up the script_filename to find the portion matching            // php_self            $path = $this->server->get('PHP_SELF', '');            $file = $this->server->get('SCRIPT_FILENAME', '');            $segs = explode('/', trim($file, '/'));            $segs = array_reverse($segs);            $index = 0;            $last = \count($segs);            $baseUrl = '';            do {                $seg = $segs[$index];                $baseUrl = '/'.$seg.$baseUrl;                ++$index;            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);        }        // Does the baseUrl have anything in common with the request_uri?        $requestUri = $this->getRequestUri();        if ('' !== $requestUri && '/' !== $requestUri[0]) {            $requestUri = '/'.$requestUri;        }        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {            // full $baseUrl matches            return $prefix;        }        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\dirname($baseUrl), '/'.\DIRECTORY_SEPARATOR).'/')) {            // directory portion of $baseUrl matches            return rtrim($prefix, '/'.\DIRECTORY_SEPARATOR);        }        $truncatedRequestUri = $requestUri;        if (false !== $pos = strpos($requestUri, '?')) {            $truncatedRequestUri = substr($requestUri, 0, $pos);        }        $basename = basename($baseUrl ?? '');        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {            // no match whatsoever; set it blank            return '';        }        // If using mod_rewrite or ISAPI_Rewrite strip the script filename        // out of baseUrl. $pos !== 0 makes sure it is not matching a value        // from PATH_INFO or QUERY_STRING        if (\strlen($requestUri) >= \strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {            $baseUrl = substr($requestUri, 0, $pos + \strlen($baseUrl));        }        return rtrim($baseUrl, '/'.\DIRECTORY_SEPARATOR);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9840, Prepares the base path.\n\n @return string base path\n, Prepares the base path.,"    protected function prepareBasePath()    {        $baseUrl = $this->getBaseUrl();        if (empty($baseUrl)) {            return '';        }        $filename = basename($this->server->get('SCRIPT_FILENAME'));        if (basename($baseUrl) === $filename) {            $basePath = \dirname($baseUrl);        } else {            $basePath = $baseUrl;        }        if ('\\' === \DIRECTORY_SEPARATOR) {            $basePath = str_replace('\\', '/', $basePath);        }        return rtrim($basePath, '/');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9841, Prepares the path info.\n\n @return string path info\n, Prepares the path info.,"    protected function preparePathInfo()    {        if (null === ($requestUri = $this->getRequestUri())) {            return '/';        }        // Remove the query string from REQUEST_URI        if (false !== $pos = strpos($requestUri, '?')) {            $requestUri = substr($requestUri, 0, $pos);        }        if ('' !== $requestUri && '/' !== $requestUri[0]) {            $requestUri = '/'.$requestUri;        }        if (null === ($baseUrl = $this->getBaseUrlReal())) {            return $requestUri;        }        $pathInfo = substr($requestUri, \strlen($baseUrl));        if (false === $pathInfo || '' === $pathInfo) {            // If substr() returns false then PATH_INFO is set to an empty string            return '/';        }        return (string) $pathInfo;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_ResponseHeaderBag_8966," Returns the headers, with original capitalizations.\n\n @return array An array of headers\n"," Returns the headers, with original capitalizations.",    public function allPreserveCase()    {        $headers = [];        foreach ($this->all() as $name => $value) {            $headers[$this->headerNames[$name] ?? $name] = $value;        }        return $headers;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_ResponseHeaderBag_8970," Returns the calculated value of the cache-control header.\n\n This considers several other headers and calculates or modifies the\n cache-control header to a sensible, conservative value.\n\n @return string\n", Returns the calculated value of the cache-control header.,"    protected function computeCacheControlValue()    {        if (!$this->cacheControl) {            if ($this->has('Last-Modified') || $this->has('Expires')) {                return 'private, must-revalidate'; // allows for heuristic expiration (RFC 7234 Section 4.2.2) in the case of ""Last-Modified""            }            // conservative by default            return 'no-cache, private';        }        $header = $this->getCacheControlHeader();        if (isset($this->cacheControl['public']) || isset($this->cacheControl['private'])) {            return $header;        }        // public if s-maxage is defined, private otherwise        if (!isset($this->cacheControl['s-maxage'])) {            return $header.', private';        }        return $header;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_7996, Response represents an HTTP response.\n\n @author Fabien Potencier <fabien@symfony.com>\n, Response represents an HTTP response.,"class Response{    public const HTTP_CONTINUE = 100;    public const HTTP_SWITCHING_PROTOCOLS = 101;    public const HTTP_PROCESSING = 102;            // RFC2518    public const HTTP_EARLY_HINTS = 103;           // RFC8297    public const HTTP_OK = 200;    public const HTTP_CREATED = 201;    public const HTTP_ACCEPTED = 202;    public const HTTP_NON_AUTHORITATIVE_INFORMATION = 203;    public const HTTP_NO_CONTENT = 204;    public const HTTP_RESET_CONTENT = 205;    public const HTTP_PARTIAL_CONTENT = 206;    public const HTTP_MULTI_STATUS = 207;          // RFC4918    public const HTTP_ALREADY_REPORTED = 208;      // RFC5842    public const HTTP_IM_USED = 226;               // RFC3229    public const HTTP_MULTIPLE_CHOICES = 300;    public const HTTP_MOVED_PERMANENTLY = 301;    public const HTTP_FOUND = 302;    public const HTTP_SEE_OTHER = 303;    public const HTTP_NOT_MODIFIED = 304;    public const HTTP_USE_PROXY = 305;    public const HTTP_RESERVED = 306;    public const HTTP_TEMPORARY_REDIRECT = 307;    public const HTTP_PERMANENTLY_REDIRECT = 308;  // RFC7238    public const HTTP_BAD_REQUEST = 400;    public const HTTP_UNAUTHORIZED = 401;    public const HTTP_PAYMENT_REQUIRED = 402;    public const HTTP_FORBIDDEN = 403;    public const HTTP_NOT_FOUND = 404;    public const HTTP_METHOD_NOT_ALLOWED = 405;    public const HTTP_NOT_ACCEPTABLE = 406;    public const HTTP_PROXY_AUTHENTICATION_REQUIRED = 407;    public const HTTP_REQUEST_TIMEOUT = 408;    public const HTTP_CONFLICT = 409;    public const HTTP_GONE = 410;    public const HTTP_LENGTH_REQUIRED = 411;    public const HTTP_PRECONDITION_FAILED = 412;    public const HTTP_REQUEST_ENTITY_TOO_LARGE = 413;    public const HTTP_REQUEST_URI_TOO_LONG = 414;    public const HTTP_UNSUPPORTED_MEDIA_TYPE = 415;    public const HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;    public const HTTP_EXPECTATION_FAILED = 417;    public const HTTP_I_AM_A_TEAPOT = 418;                                               // RFC2324    public const HTTP_MISDIRECTED_REQUEST = 421;                                         // RFC7540    public const HTTP_UNPROCESSABLE_ENTITY = 422;                                        // RFC4918    public const HTTP_LOCKED = 423;                                                      // RFC4918    public const HTTP_FAILED_DEPENDENCY = 424;                                           // RFC4918    public const HTTP_TOO_EARLY = 425;                                                   // RFC-ietf-httpbis-replay-04    public const HTTP_UPGRADE_REQUIRED = 426;                                            // RFC2817    public const HTTP_PRECONDITION_REQUIRED = 428;                                       // RFC6585    public const HTTP_TOO_MANY_REQUESTS = 429;                                           // RFC6585    public const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;                             // RFC6585    public const HTTP_UNAVAILABLE_FOR_LEGAL_REASONS = 451;    public const HTTP_INTERNAL_SERVER_ERROR = 500;    public const HTTP_NOT_IMPLEMENTED = 501;    public const HTTP_BAD_GATEWAY = 502;    public const HTTP_SERVICE_UNAVAILABLE = 503;    public const HTTP_GATEWAY_TIMEOUT = 504;    public const HTTP_VERSION_NOT_SUPPORTED = 505;    public const HTTP_VARIANT_ALSO_NEGOTIATES_EXPERIMENTAL = 506;                        // RFC2295    public const HTTP_INSUFFICIENT_STORAGE = 507;                                        // RFC4918    public const HTTP_LOOP_DETECTED = 508;                                               // RFC5842    public const HTTP_NOT_EXTENDED = 510;                                                // RFC2774    public const HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511;                             // RFC6585    /**     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control     */    private const HTTP_RESPONSE_CACHE_CONTROL_DIRECTIVES = [        'must_revalidate' => false,        'no_cache' => false,        'no_store' => false,        'no_transform' => false,        'public' => false,        'private' => false,        'proxy_revalidate' => false,        'max_age' => true,        's_maxage' => true,        'immutable' => false,        'last_modified' => true,        'etag' => true,    ];    /**     * @var ResponseHeaderBag     */    public $headers;    /**     * @var string     */    protected $content;    /**     * @var string     */    protected $version;    /**     * @var int     */    protected $statusCode;    /**     * @var string     */    protected $statusText;    /**     * @var string     */    protected $charset;    /**     * Status codes translation table.     *     * The list of codes is complete according to the     * {@link https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml Hypertext Transfer Protocol (HTTP) Status Code Registry}     * (last updated 2016-03-01).     *     * Unless otherwise noted, the status code is defined in RFC2616.     *     * @var array     */    public static $statusTexts = [        100 => 'Continue',        101 => 'Switching Protocols',        102 => 'Processing',            // RFC2518        103 => 'Early Hints',        200 => 'OK',        201 => 'Created',        202 => 'Accepted',        203 => 'Non-Authoritative Information',        204 => 'No Content',        205 => 'Reset Content',        206 => 'Partial Content',        207 => 'Multi-Status',          // RFC4918        208 => 'Already Reported',      // RFC5842        226 => 'IM Used',               // RFC3229        300 => 'Multiple Choices',        301 => 'Moved Permanently',        302 => 'Found',        303 => 'See Other',        304 => 'Not Modified',        305 => 'Use Proxy',        307 => 'Temporary Redirect',        308 => 'Permanent Redirect',    // RFC7238        400 => 'Bad Request',        401 => 'Unauthorized',        402 => 'Payment Required',        403 => 'Forbidden',        404 => 'Not Found',        405 => 'Method Not Allowed',        406 => 'Not Acceptable',        407 => 'Proxy Authentication Required',        408 => 'Request Timeout',        409 => 'Conflict',        410 => 'Gone',        411 => 'Length Required',        412 => 'Precondition Failed',        413 => 'Payload Too Large',        414 => 'URI Too Long',        415 => 'Unsupported Media Type',        416 => 'Range Not Satisfiable',        417 => 'Expectation Failed',        418 => 'I\'m a teapot',                                               // RFC2324        421 => 'Misdirected Request',                                         // RFC7540        422 => 'Unprocessable Entity',                                        // RFC4918        423 => 'Locked',                                                      // RFC4918        424 => 'Failed Dependency',                                           // RFC4918        425 => 'Too Early',                                                   // RFC-ietf-httpbis-replay-04        426 => 'Upgrade Required',                                            // RFC2817        428 => 'Precondition Required',                                       // RFC6585        429 => 'Too Many Requests',                                           // RFC6585        431 => 'Request Header Fields Too Large',                             // RFC6585        451 => 'Unavailable For Legal Reasons',                               // RFC7725        500 => 'Internal Server Error',        501 => 'Not Implemented',        502 => 'Bad Gateway',        503 => 'Service Unavailable',        504 => 'Gateway Timeout',        505 => 'HTTP Version Not Supported',        506 => 'Variant Also Negotiates',                                     // RFC2295        507 => 'Insufficient Storage',                                        // RFC4918        508 => 'Loop Detected',                                               // RFC5842        510 => 'Not Extended',                                                // RFC2774        511 => 'Network Authentication Required',                             // RFC6585    ];    /**     * @throws \InvalidArgumentException When the HTTP status code is not valid     */    public function __construct(?string $content = '', int $status = 200, array $headers = [])    {        $this->headers = new ResponseHeaderBag($headers);        $this->setContent($content);        $this->setStatusCode($status);        $this->setProtocolVersion('1.0');    }    /**     * Factory method for chainability.     *     * Example:     *     *     return Response::create($body, 200)     *         ->setSharedMaxAge(300);     *     * @return static     *     * @deprecated since Symfony 5.1, use __construct() instead.     */    public static function create(?string $content = '', int $status = 200, array $headers = [])    {        trigger_deprecation('symfony/http-foundation', '5.1', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($content, $status, $headers);    }    /**     * Returns the Response as an HTTP string.     *     * The string representation of the Response is the same as the     * one that will be sent to the client only if the prepare() method     * has been called before.     *     * @return string The Response as an HTTP string     *     * @see prepare()     */    public function __toString()    {        return            sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText).""\r\n"".            $this->headers.""\r\n"".            $this->getContent();    }    /**     * Clones the current Response instance.     */    public function __clone()    {        $this->headers = clone $this->headers;    }    /**     * Prepares the Response before it is sent to the client.     *     * This method tweaks the Response to ensure that it is     * compliant with RFC 2616. Most of the changes are based on     * the Request that is ""associated"" with this Response.     *     * @return $this     */    public function prepare(Request $request)    {        $headers = $this->headers;        if ($this->isInformational() || $this->isEmpty()) {            $this->setContent(null);            $headers->remove('Content-Type');            $headers->remove('Content-Length');            // prevent PHP from sending the Content-Type header based on default_mimetype            ini_set('default_mimetype', '');        } else {            // Content-type based on the Request            if (!$headers->has('Content-Type')) {                $format = $request->getRequestFormat(null);                if (null !== $format && $mimeType = $request->getMimeType($format)) {                    $headers->set('Content-Type', $mimeType);                }            }            // Fix Content-Type            $charset = $this->charset ?: 'UTF-8';            if (!$headers->has('Content-Type')) {                $headers->set('Content-Type', 'text/html; charset='.$charset);            } elseif (0 === stripos($headers->get('Content-Type'), 'text/') && false === stripos($headers->get('Content-Type'), 'charset')) {                // add the charset                $headers->set('Content-Type', $headers->get('Content-Type').'; charset='.$charset);            }            // Fix Content-Length            if ($headers->has('Transfer-Encoding')) {                $headers->remove('Content-Length');            }            if ($request->isMethod('HEAD')) {                // cf. RFC2616 14.13                $length = $headers->get('Content-Length');                $this->setContent(null);                if ($length) {                    $headers->set('Content-Length', $length);                }            }        }        // Fix protocol        if ('HTTP/1.0' != $request->server->get('SERVER_PROTOCOL')) {            $this->setProtocolVersion('1.1');        }        // Check if we need to send extra expire info headers        if ('1.0' == $this->getProtocolVersion() && false !== strpos($headers->get('Cache-Control'), 'no-cache')) {            $headers->set('pragma', 'no-cache');            $headers->set('expires', -1);        }        $this->ensureIEOverSSLCompatibility($request);        if ($request->isSecure()) {            foreach ($headers->getCookies() as $cookie) {                $cookie->setSecureDefault(true);            }        }        return $this;    }    /**     * Sends HTTP headers.     *     * @return $this     */    public function sendHeaders()    {        // headers have already been sent by the developer        if (headers_sent()) {            return $this;        }        // headers        foreach ($this->headers->allPreserveCaseWithoutCookies() as $name => $values) {            $replace = 0 === strcasecmp($name, 'Content-Type');            foreach ($values as $value) {                header($name.': '.$value, $replace, $this->statusCode);            }        }        // cookies        foreach ($this->headers->getCookies() as $cookie) {            header('Set-Cookie: '.$cookie, false, $this->statusCode);        }        // status        header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText), true, $this->statusCode);        return $this;    }    /**     * Sends content for the current web response.     *     * @return $this     */    public function sendContent()    {        echo $this->content;        return $this;    }    /**     * Sends HTTP headers and content.     *     * @return $this     */    public function send()    {        $this->sendHeaders();        $this->sendContent();        if (\function_exists('fastcgi_finish_request')) {            fastcgi_finish_request();        } elseif (!\in_array(\PHP_SAPI, ['cli', 'phpdbg'], true)) {            static::closeOutputBuffers(0, true);        }        return $this;    }    /**     * Sets the response content.     *     * @return $this     *     * @throws \UnexpectedValueException     */    public function setContent(?string $content)    {        $this->content = $content ?? '';        return $this;    }    /**     * Gets the current response content.     *     * @return string|false     */    public function getContent()    {        return $this->content;    }    /**     * Sets the HTTP protocol version (1.0 or 1.1).     *     * @return $this     *     * @final     */    public function setProtocolVersion(string $version): object    {        $this->version = $version;        return $this;    }    /**     * Gets the HTTP protocol version.     *     * @final     */    public function getProtocolVersion(): string    {        return $this->version;    }    /**     * Sets the response status code.     *     * If the status text is null it will be automatically populated for the known     * status codes and left empty otherwise.     *     * @return $this     *     * @throws \InvalidArgumentException When the HTTP status code is not valid     *     * @final     */    public function setStatusCode(int $code, $text = null): object    {        $this->statusCode = $code;        if ($this->isInvalid()) {            throw new \InvalidArgumentException(sprintf('The HTTP status code ""%s"" is not valid.', $code));        }        if (null === $text) {            $this->statusText = self::$statusTexts[$code] ?? 'unknown status';            return $this;        }        if (false === $text) {            $this->statusText = '';            return $this;        }        $this->statusText = $text;        return $this;    }    /**     * Retrieves the status code for the current web response.     *     * @final     */    public function getStatusCode(): int    {        return $this->statusCode;    }    /**     * Sets the response charset.     *     * @return $this     *     * @final     */    public function setCharset(string $charset): object    {        $this->charset = $charset;        return $this;    }    /**     * Retrieves the response charset.     *     * @final     */    public function getCharset(): ?string    {        return $this->charset;    }    /**     * Returns true if the response may safely be kept in a shared (surrogate) cache.     *     * Responses marked ""private"" with an explicit Cache-Control directive are     * considered uncacheable.     *     * Responses with neither a freshness lifetime (Expires, max-age) nor cache     * validator (Last-Modified, ETag) are considered uncacheable because there is     * no way to tell when or how to remove them from the cache.     *     * Note that RFC 7231 and RFC 7234 possibly allow for a more permissive implementation,     * for example ""status codes that are defined as cacheable by default [...]     * can be reused by a cache with heuristic expiration unless otherwise indicated""     * (https://tools.ietf.org/html/rfc7231#section-6.1)     *     * @final     */    public function isCacheable(): bool    {        if (!\in_array($this->statusCode, [200, 203, 300, 301, 302, 404, 410])) {            return false;        }        if ($this->headers->hasCacheControlDirective('no-store') || $this->headers->getCacheControlDirective('private')) {            return false;        }        return $this->isValidateable() || $this->isFresh();    }    /**     * Returns true if the response is ""fresh"".     *     * Fresh responses may be served from cache without any interaction with the     * origin. A response is considered fresh when it includes a Cache-Control/max-age     * indicator or Expires header and the calculated age is less than the freshness lifetime.     *     * @final     */    public function isFresh(): bool    {        return $this->getTtl() > 0;    }    /**     * Returns true if the response includes headers that can be used to validate     * the response with the origin server using a conditional GET request.     *     * @final     */    public function isValidateable(): bool    {        return $this->headers->has('Last-Modified') || $this->headers->has('ETag');    }    /**     * Marks the response as ""private"".     *     * It makes the response ineligible for serving other clients.     *     * @return $this     *     * @final     */    public function setPrivate(): object    {        $this->headers->removeCacheControlDirective('public');        $this->headers->addCacheControlDirective('private');        return $this;    }    /**     * Marks the response as ""public"".     *     * It makes the response eligible for serving other clients.     *     * @return $this     *     * @final     */    public function setPublic(): object    {        $this->headers->addCacheControlDirective('public');        $this->headers->removeCacheControlDirective('private');        return $this;    }    /**     * Marks the response as ""immutable"".     *     * @return $this     *     * @final     */    public function setImmutable(bool $immutable = true): object    {        if ($immutable) {            $this->headers->addCacheControlDirective('immutable');        } else {            $this->headers->removeCacheControlDirective('immutable');        }        return $this;    }    /**     * Returns true if the response is marked as ""immutable"".     *     * @final     */    public function isImmutable(): bool    {        return $this->headers->hasCacheControlDirective('immutable');    }    /**     * Returns true if the response must be revalidated by shared caches once it has become stale.     *     * This method indicates that the response must not be served stale by a     * cache in any circumstance without first revalidating with the origin.     * When present, the TTL of the response should not be overridden to be     * greater than the value provided by the origin.     *     * @final     */    public function mustRevalidate(): bool    {        return $this->headers->hasCacheControlDirective('must-revalidate') || $this->headers->hasCacheControlDirective('proxy-revalidate');    }    /**     * Returns the Date header as a DateTime instance.     *     * @throws \RuntimeException When the header is not parseable     *     * @final     */    public function getDate(): ?\DateTimeInterface    {        return $this->headers->getDate('Date');    }    /**     * Sets the Date header.     *     * @return $this     *     * @final     */    public function setDate(\DateTimeInterface $date): object    {        if ($date instanceof \DateTime) {            $date = \DateTimeImmutable::createFromMutable($date);        }        $date = $date->setTimezone(new \DateTimeZone('UTC'));        $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT');        return $this;    }    /**     * Returns the age of the response in seconds.     *     * @final     */    public function getAge(): int    {        if (null !== $age = $this->headers->get('Age')) {            return (int) $age;        }        return max(time() - (int) $this->getDate()->format('U'), 0);    }    /**     * Marks the response stale by setting the Age header to be equal to the maximum age of the response.     *     * @return $this     */    public function expire()    {        if ($this->isFresh()) {            $this->headers->set('Age', $this->getMaxAge());            $this->headers->remove('Expires');        }        return $this;    }    /**     * Returns the value of the Expires header as a DateTime instance.     *     * @final     */    public function getExpires(): ?\DateTimeInterface    {        try {            return $this->headers->getDate('Expires');        } catch (\RuntimeException $e) {            // according to RFC 2616 invalid date formats (e.g. ""0"" and ""-1"") must be treated as in the past            return \DateTime::createFromFormat('U', time() - 172800);        }    }    /**     * Sets the Expires HTTP header with a DateTime instance.     *     * Passing null as value will remove the header.     *     * @return $this     *     * @final     */    public function setExpires(\DateTimeInterface $date = null): object    {        if (null === $date) {            $this->headers->remove('Expires');            return $this;        }        if ($date instanceof \DateTime) {            $date = \DateTimeImmutable::createFromMutable($date);        }        $date = $date->setTimezone(new \DateTimeZone('UTC'));        $this->headers->set('Expires', $date->format('D, d M Y H:i:s').' GMT');        return $this;    }    /**     * Returns the number of seconds after the time specified in the response's Date     * header when the response should no longer be considered fresh.     *     * First, it checks for a s-maxage directive, then a max-age directive, and then it falls     * back on an expires header. It returns null when no maximum age can be established.     *     * @final     */    public function getMaxAge(): ?int    {        if ($this->headers->hasCacheControlDirective('s-maxage')) {            return (int) $this->headers->getCacheControlDirective('s-maxage');        }        if ($this->headers->hasCacheControlDirective('max-age')) {            return (int) $this->headers->getCacheControlDirective('max-age');        }        if (null !== $this->getExpires()) {            return (int) $this->getExpires()->format('U') - (int) $this->getDate()->format('U');        }        return null;    }    /**     * Sets the number of seconds after which the response should no longer be considered fresh.     *     * This methods sets the Cache-Control max-age directive.     *     * @return $this     *     * @final     */    public function setMaxAge(int $value): object    {        $this->headers->addCacheControlDirective('max-age', $value);        return $this;    }    /**     * Sets the number of seconds after which the response should no longer be considered fresh by shared caches.     *     * This methods sets the Cache-Control s-maxage directive.     *     * @return $this     *     * @final     */    public function setSharedMaxAge(int $value): object    {        $this->setPublic();        $this->headers->addCacheControlDirective('s-maxage', $value);        return $this;    }    /**     * Returns the response's time-to-live in seconds.     *     * It returns null when no freshness information is present in the response.     *     * When the responses TTL is <= 0, the response may not be served from cache without first     * revalidating with the origin.     *     * @final     */    public function getTtl(): ?int    {        $maxAge = $this->getMaxAge();        return null !== $maxAge ? $maxAge - $this->getAge() : null;    }    /**     * Sets the response's time-to-live for shared caches in seconds.     *     * This method adjusts the Cache-Control/s-maxage directive.     *     * @return $this     *     * @final     */    public function setTtl(int $seconds): object    {        $this->setSharedMaxAge($this->getAge() + $seconds);        return $this;    }    /**     * Sets the response's time-to-live for private/client caches in seconds.     *     * This method adjusts the Cache-Control/max-age directive.     *     * @return $this     *     * @final     */    public function setClientTtl(int $seconds): object    {        $this->setMaxAge($this->getAge() + $seconds);        return $this;    }    /**     * Returns the Last-Modified HTTP header as a DateTime instance.     *     * @throws \RuntimeException When the HTTP header is not parseable     *     * @final     */    public function getLastModified(): ?\DateTimeInterface    {        return $this->headers->getDate('Last-Modified');    }    /**     * Sets the Last-Modified HTTP header with a DateTime instance.     *     * Passing null as value will remove the header.     *     * @return $this     *     * @final     */    public function setLastModified(\DateTimeInterface $date = null): object    {        if (null === $date) {            $this->headers->remove('Last-Modified');            return $this;        }        if ($date instanceof \DateTime) {            $date = \DateTimeImmutable::createFromMutable($date);        }        $date = $date->setTimezone(new \DateTimeZone('UTC'));        $this->headers->set('Last-Modified', $date->format('D, d M Y H:i:s').' GMT');        return $this;    }    /**     * Returns the literal value of the ETag HTTP header.     *     * @final     */    public function getEtag(): ?string    {        return $this->headers->get('ETag');    }    /**     * Sets the ETag value.     *     * @param string|null $etag The ETag unique identifier or null to remove the header     * @param bool        $weak Whether you want a weak ETag or not     *     * @return $this     *     * @final     */    public function setEtag(string $etag = null, bool $weak = false): object    {        if (null === $etag) {            $this->headers->remove('Etag');        } else {            if (0 !== strpos($etag, '""')) {                $etag = '""'.$etag.'""';            }            $this->headers->set('ETag', (true === $weak ? 'W/' : '').$etag);        }        return $this;    }    /**     * Sets the response's cache headers (validation and/or expiration).     *     * Available options are: must_revalidate, no_cache, no_store, no_transform, public, private, proxy_revalidate, max_age, s_maxage, immutable, last_modified and etag.     *     * @return $this     *     * @throws \InvalidArgumentException     *     * @final     */    public function setCache(array $options): object    {        if ($diff = array_diff(array_keys($options), array_keys(self::HTTP_RESPONSE_CACHE_CONTROL_DIRECTIVES))) {            throw new \InvalidArgumentException(sprintf('Response does not support the following options: ""%s"".', implode('"", ""', $diff)));        }        if (isset($options['etag'])) {            $this->setEtag($options['etag']);        }        if (isset($options['last_modified'])) {            $this->setLastModified($options['last_modified']);        }        if (isset($options['max_age'])) {            $this->setMaxAge($options['max_age']);        }        if (isset($options['s_maxage'])) {            $this->setSharedMaxAge($options['s_maxage']);        }        foreach (self::HTTP_RESPONSE_CACHE_CONTROL_DIRECTIVES as $directive => $hasValue) {            if (!$hasValue && isset($options[$directive])) {                if ($options[$directive]) {                    $this->headers->addCacheControlDirective(str_replace('_', '-', $directive));                } else {                    $this->headers->removeCacheControlDirective(str_replace('_', '-', $directive));                }            }        }        if (isset($options['public'])) {            if ($options['public']) {                $this->setPublic();            } else {                $this->setPrivate();            }        }        if (isset($options['private'])) {            if ($options['private']) {                $this->setPrivate();            } else {                $this->setPublic();            }        }        return $this;    }    /**     * Modifies the response so that it conforms to the rules defined for a 304 status code.     *     * This sets the status, removes the body, and discards any headers     * that MUST NOT be included in 304 responses.     *     * @return $this     *     * @see https://tools.ietf.org/html/rfc2616#section-10.3.5     *     * @final     */    public function setNotModified(): object    {        $this->setStatusCode(304);        $this->setContent(null);        // remove headers that MUST NOT be included with 304 Not Modified responses        foreach (['Allow', 'Content-Encoding', 'Content-Language', 'Content-Length', 'Content-MD5', 'Content-Type', 'Last-Modified'] as $header) {            $this->headers->remove($header);        }        return $this;    }    /**     * Returns true if the response includes a Vary header.     *     * @final     */    public function hasVary(): bool    {        return null !== $this->headers->get('Vary');    }    /**     * Returns an array of header names given in the Vary header.     *     * @final     */    public function getVary(): array    {        if (!$vary = $this->headers->all('Vary')) {            return [];        }        $ret = [];        foreach ($vary as $item) {            $ret = array_merge($ret, preg_split('/[\s,]+/', $item));        }        return $ret;    }    /**     * Sets the Vary header.     *     * @param string|array $headers     * @param bool         $replace Whether to replace the actual value or not (true by default)     *     * @return $this     *     * @final     */    public function setVary($headers, bool $replace = true): object    {        $this->headers->set('Vary', $headers, $replace);        return $this;    }    /**     * Determines if the Response validators (ETag, Last-Modified) match     * a conditional value specified in the Request.     *     * If the Response is not modified, it sets the status code to 304 and     * removes the actual content by calling the setNotModified() method.     *     * @return bool true if the Response validators match the Request, false otherwise     *     * @final     */    public function isNotModified(Request $request): bool    {        if (!$request->isMethodCacheable()) {            return false;        }        $notModified = false;        $lastModified = $this->headers->get('Last-Modified');        $modifiedSince = $request->headers->get('If-Modified-Since');        if ($etags = $request->getETags()) {            $notModified = \in_array($this->getEtag(), $etags) || \in_array('*', $etags);        }        if ($modifiedSince && $lastModified) {            $notModified = strtotime($modifiedSince) >= strtotime($lastModified) && (!$etags || $notModified);        }        if ($notModified) {            $this->setNotModified();        }        return $notModified;    }    /**     * Is response invalid?     *     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html     *     * @final     */    public function isInvalid(): bool    {        return $this->statusCode < 100 || $this->statusCode >= 600;    }    /**     * Is response informative?     *     * @final     */    public function isInformational(): bool    {        return $this->statusCode >= 100 && $this->statusCode < 200;    }    /**     * Is response successful?     *     * @final     */    public function isSuccessful(): bool    {        return $this->statusCode >= 200 && $this->statusCode < 300;    }    /**     * Is the response a redirect?     *     * @final     */    public function isRedirection(): bool    {        return $this->statusCode >= 300 && $this->statusCode < 400;    }    /**     * Is there a client error?     *     * @final     */    public function isClientError(): bool    {        return $this->statusCode >= 400 && $this->statusCode < 500;    }    /**     * Was there a server side error?     *     * @final     */    public function isServerError(): bool    {        return $this->statusCode >= 500 && $this->statusCode < 600;    }    /**     * Is the respo",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
symfony_http-foundation_Response_8005, Sets the HTTP protocol version (1.0 or 1.1).\n\n @return $this\n\n @final\n, Sets the HTTP protocol version (1.0 or 1.1).,    public function setProtocolVersion(string $version): object    {        $this->version = $version;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8014," Marks the response as ""public"".\n\n It makes the response eligible for serving other clients.\n\n @return $this\n\n @final\n"," Marks the response as ""public"".",    public function setPublic(): object    {        $this->headers->addCacheControlDirective('public');        $this->headers->removeCacheControlDirective('private');        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8019, Returns the age of the response in seconds.\n\n @final\n, Returns the age of the response in seconds.,"    public function getAge(): int    {        if (null !== $age = $this->headers->get('Age')) {            return (int) $age;        }        return max(time() - (int) $this->getDate()->format('U'), 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8023, Sets the number of seconds after which the response should no longer be considered fresh.\n\n This methods sets the Cache-Control max-age directive.\n\n @return $this\n\n @final\n, Sets the number of seconds after which the response should no longer be considered fresh.,"    public function setMaxAge(int $value): object    {        $this->headers->addCacheControlDirective('max-age', $value);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8031," Modifies the response so that it conforms to the rules defined for a 304 status code.\n\n This sets the status, removes the body, and discards any headers\n that MUST NOT be included in 304 responses.\n\n @return $this\n\n @see https://tools.ietf.org/html/rfc2616#section-10.3.5\n\n @final\n", Modifies the response so that it conforms to the rules defined for a 304 status code.,"    public function setNotModified(): object    {        $this->setStatusCode(304);        $this->setContent(null);        // remove headers that MUST NOT be included with 304 Not Modified responses        foreach (['Allow', 'Content-Encoding', 'Content-Language', 'Content-Length', 'Content-MD5', 'Content-Type', 'Last-Modified'] as $header) {            $this->headers->remove($header);        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8035, Is response invalid?\n\n @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n\n @final\n, Is response invalid?,    public function isInvalid(): bool    {        return $this->statusCode < 100 || $this->statusCode >= 600;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8040, Was there a server side error?\n\n @final\n, Was there a server side error?,    public function isServerError(): bool    {        return $this->statusCode >= 500 && $this->statusCode < 600;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8043, Is the response a not found error?\n\n @final\n, Is the response a not found error?,    public function isNotFound(): bool    {        return 404 === $this->statusCode;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8921, Sets the response content.\n\n @return $this\n\n @throws \\UnexpectedValueException\n, Sets the response content.,    public function setContent(?string $content)    {        $this->content = $content ?? '';        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8929," Returns true if the response is ""fresh"".\n\n Fresh responses may be served from cache without any interaction with the\n origin. A response is considered fresh when it includes a Cache-Control/max-age\n indicator or Expires header and the calculated age is less than the freshness lifetime.\n\n @final\n"," Returns true if the response is ""fresh"".",    public function isFresh(): bool    {        return $this->getTtl() > 0;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8930, Returns true if the response includes headers that can be used to validate\n the response with the origin server using a conditional GET request.\n\n @final\n, Returns true if the response includes headers that can be used to validate,    public function isValidateable(): bool    {        return $this->headers->has('Last-Modified') || $this->headers->has('ETag');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8934," Returns true if the response must be revalidated by shared caches once it has become stale.\n\n This method indicates that the response must not be served stale by a\n cache in any circumstance without first revalidating with the origin.\n When present, the TTL of the response should not be overridden to be\n greater than the value provided by the origin.\n\n @final\n", Returns true if the response must be revalidated by shared caches once it has become stale.,    public function mustRevalidate(): bool    {        return $this->headers->hasCacheControlDirective('must-revalidate') || $this->headers->hasCacheControlDirective('proxy-revalidate');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8935, Returns the Date header as a DateTime instance.\n\n @throws \\RuntimeException When the header is not parseable\n\n @final\n, Returns the Date header as a DateTime instance.,    public function getDate(): ?\DateTimeInterface    {        return $this->headers->getDate('Date');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8938, Marks the response stale by setting the Age header to be equal to the maximum age of the response.\n\n @return $this\n, Marks the response stale by setting the Age header to be equal to the maximum age of the response.,"    public function expire()    {        if ($this->isFresh()) {            $this->headers->set('Age', $this->getMaxAge());            $this->headers->remove('Expires');        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8952," Determines if the Response validators (ETag, Last-Modified) match\n a conditional value specified in the Request.\n\n If the Response is not modified, it sets the status code to 304 and\n removes the actual content by calling the setNotModified() method.\n\n @return bool true if the Response validators match the Request, false otherwise\n\n @final\n"," Determines if the Response validators (ETag, Last-Modified) match","    public function isNotModified(Request $request): bool    {        if (!$request->isMethodCacheable()) {            return false;        }        $notModified = false;        $lastModified = $this->headers->get('Last-Modified');        $modifiedSince = $request->headers->get('If-Modified-Since');        if ($etags = $request->getETags()) {            $notModified = \in_array($this->getEtag(), $etags) || \in_array('*', $etags);        }        if ($modifiedSince && $lastModified) {            $notModified = strtotime($modifiedSince) >= strtotime($lastModified) && (!$etags || $notModified);        }        if ($notModified) {            $this->setNotModified();        }        return $notModified;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8957, Is there a client error?\n\n @final\n, Is there a client error?,    public function isClientError(): bool    {        return $this->statusCode >= 400 && $this->statusCode < 500;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8960, Is the response forbidden?\n\n @final\n, Is the response forbidden?,    public function isForbidden(): bool    {        return 403 === $this->statusCode;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8962, Is the response empty?\n\n @final\n, Is the response empty?,"    public function isEmpty(): bool    {        return \in_array($this->statusCode, [204, 304]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9865, Returns the Response as an HTTP string.\n\n The string representation of the Response is the same as the\n one that will be sent to the client only if the prepare() method\n has been called before.\n\n @return string The Response as an HTTP string\n\n @see prepare()\n, Returns the Response as an HTTP string.,"    public function __toString()    {        return            sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText).""\r\n"".            $this->headers.""\r\n"".            $this->getContent();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9866, Clones the current Response instance.\n, Clones the current Response instance.,    public function __clone()    {        $this->headers = clone $this->headers;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9869, Sends content for the current web response.\n\n @return $this\n, Sends content for the current web response.,    public function sendContent()    {        echo $this->content;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9870, Sends HTTP headers and content.\n\n @return $this\n, Sends HTTP headers and content.,"    public function send()    {        $this->sendHeaders();        $this->sendContent();        if (\function_exists('fastcgi_finish_request')) {            fastcgi_finish_request();        } elseif (!\in_array(\PHP_SAPI, ['cli', 'phpdbg'], true)) {            static::closeOutputBuffers(0, true);        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9876, Sets the response charset.\n\n @return $this\n\n @final\n, Sets the response charset.,    public function setCharset(string $charset): object    {        $this->charset = $charset;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9895, Sets the response's time-to-live for private/client caches in seconds.\n\n This method adjusts the Cache-Control/max-age directive.\n\n @return $this\n\n @final\n, Sets the response's time-to-live for private/client caches in seconds.,    public function setClientTtl(int $seconds): object    {        $this->setMaxAge($this->getAge() + $seconds);        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9900, Returns true if the response includes a Vary header.\n\n @final\n, Returns true if the response includes a Vary header.,    public function hasVary(): bool    {        return null !== $this->headers->get('Vary');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9904, Is response informative?\n\n @final\n, Is response informative?,    public function isInformational(): bool    {        return $this->statusCode >= 100 && $this->statusCode < 200;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9914, Checks if we need to remove Cache-Control for SSL encrypted downloads when using IE < 9.\n\n @see http://support.microsoft.com/kb/323308\n\n @final\n, Checks if we need to remove Cache-Control for SSL encrypted downloads when using IE < 9.,"    protected function ensureIEOverSSLCompatibility(Request $request): void    {        if (false !== stripos($this->headers->get('Content-Disposition') ?? '', 'attachment') && 1 == preg_match('/MSIE (.*?);/i', $request->server->get('HTTP_USER_AGENT') ?? '', $match) && true === $request->isSecure()) {            if ((int) preg_replace('/(MSIE )(.*?);/', '$2', $match[0]) < 9) {                $this->headers->remove('Cache-Control');            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_ServerBag_8054, Gets the HTTP headers.\n\n @return array\n, Gets the HTTP headers.,"    public function getHeaders()    {        $headers = [];        foreach ($this->parameters as $key => $value) {            if (0 === strpos($key, 'HTTP_')) {                $headers[substr($key, 5)] = $value;            } elseif (\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {                $headers[$key] = $value;            }        }        if (isset($this->parameters['PHP_AUTH_USER'])) {            $headers['PHP_AUTH_USER'] = $this->parameters['PHP_AUTH_USER'];            $headers['PHP_AUTH_PW'] = $this->parameters['PHP_AUTH_PW'] ?? '';        } else {            /*             * php-cgi under Apache does not pass HTTP Basic user/pass to PHP by default             * For this workaround to work, add these lines to your .htaccess file:             * RewriteCond %{HTTP:Authorization} .+             * RewriteRule ^ - [E=HTTP_AUTHORIZATION:%0]             *             * A sample .htaccess file:             * RewriteEngine On             * RewriteCond %{HTTP:Authorization} .+             * RewriteRule ^ - [E=HTTP_AUTHORIZATION:%0]             * RewriteCond %{REQUEST_FILENAME} !-f             * RewriteRule ^(.*)$ app.php [QSA,L]             */            $authorizationHeader = null;            if (isset($this->parameters['HTTP_AUTHORIZATION'])) {                $authorizationHeader = $this->parameters['HTTP_AUTHORIZATION'];            } elseif (isset($this->parameters['REDIRECT_HTTP_AUTHORIZATION'])) {                $authorizationHeader = $this->parameters['REDIRECT_HTTP_AUTHORIZATION'];            }            if (null !== $authorizationHeader) {                if (0 === stripos($authorizationHeader, 'basic ')) {                    // Decode AUTHORIZATION header into PHP_AUTH_USER and PHP_AUTH_PW when authorization header is basic                    $exploded = explode(':', base64_decode(substr($authorizationHeader, 6)), 2);                    if (2 == \count($exploded)) {                        [$headers['PHP_AUTH_USER'], $headers['PHP_AUTH_PW']] = $exploded;                    }                } elseif (empty($this->parameters['PHP_AUTH_DIGEST']) && (0 === stripos($authorizationHeader, 'digest '))) {                    // In some circumstances PHP_AUTH_DIGEST needs to be set                    $headers['PHP_AUTH_DIGEST'] = $authorizationHeader;                    $this->parameters['PHP_AUTH_DIGEST'] = $authorizationHeader;                } elseif (0 === stripos($authorizationHeader, 'bearer ')) {                    /*                     * XXX: Since there is no PHP_AUTH_BEARER in PHP predefined variables,                     *      I'll just set $headers['AUTHORIZATION'] here.                     *      https://php.net/reserved.variables.server                     */                    $headers['AUTHORIZATION'] = $authorizationHeader;                }            }        }        if (isset($headers['AUTHORIZATION'])) {            return $headers;        }        // PHP_AUTH_USER/PHP_AUTH_PW        if (isset($headers['PHP_AUTH_USER'])) {            $headers['AUTHORIZATION'] = 'Basic '.base64_encode($headers['PHP_AUTH_USER'].':'.$headers['PHP_AUTH_PW']);        } elseif (isset($headers['PHP_AUTH_DIGEST'])) {            $headers['AUTHORIZATION'] = $headers['PHP_AUTH_DIGEST'];        }        return $headers;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_ServerBag_9921, ServerBag is a container for HTTP headers from the $_SERVER variable.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Bulat Shakirzyanov <mallluhuct@gmail.com>\n @author Robert Kiss <kepten@gmail.com>\n, ServerBag is a container for HTTP headers from the $_SERVER variable.,"class ServerBag extends ParameterBag{    /**     * Gets the HTTP headers.     *     * @return array     */    public function getHeaders()    {        $headers = [];        foreach ($this->parameters as $key => $value) {            if (0 === strpos($key, 'HTTP_')) {                $headers[substr($key, 5)] = $value;            } elseif (\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {                $headers[$key] = $value;            }        }        if (isset($this->parameters['PHP_AUTH_USER'])) {            $headers['PHP_AUTH_USER'] = $this->parameters['PHP_AUTH_USER'];            $headers['PHP_AUTH_PW'] = $this->parameters['PHP_AUTH_PW'] ?? '';        } else {            /*             * php-cgi under Apache does not pass HTTP Basic user/pass to PHP by default             * For this workaround to work, add these lines to your .htaccess file:             * RewriteCond %{HTTP:Authorization} .+             * RewriteRule ^ - [E=HTTP_AUTHORIZATION:%0]             *             * A sample .htaccess file:             * RewriteEngine On             * RewriteCond %{HTTP:Authorization} .+             * RewriteRule ^ - [E=HTTP_AUTHORIZATION:%0]             * RewriteCond %{REQUEST_FILENAME} !-f             * RewriteRule ^(.*)$ app.php [QSA,L]             */            $authorizationHeader = null;            if (isset($this->parameters['HTTP_AUTHORIZATION'])) {                $authorizationHeader = $this->parameters['HTTP_AUTHORIZATION'];            } elseif (isset($this->parameters['REDIRECT_HTTP_AUTHORIZATION'])) {                $authorizationHeader = $this->parameters['REDIRECT_HTTP_AUTHORIZATION'];            }            if (null !== $authorizationHeader) {                if (0 === stripos($authorizationHeader, 'basic ')) {                    // Decode AUTHORIZATION header into PHP_AUTH_USER and PHP_AUTH_PW when authorization header is basic                    $exploded = explode(':', base64_decode(substr($authorizationHeader, 6)), 2);                    if (2 == \count($exploded)) {                        [$headers['PHP_AUTH_USER'], $headers['PHP_AUTH_PW']] = $exploded;                    }                } elseif (empty($this->parameters['PHP_AUTH_DIGEST']) && (0 === stripos($authorizationHeader, 'digest '))) {                    // In some circumstances PHP_AUTH_DIGEST needs to be set                    $headers['PHP_AUTH_DIGEST'] = $authorizationHeader;                    $this->parameters['PHP_AUTH_DIGEST'] = $authorizationHeader;                } elseif (0 === stripos($authorizationHeader, 'bearer ')) {                    /*                     * XXX: Since there is no PHP_AUTH_BEARER in PHP predefined variables,                     *      I'll just set $headers['AUTHORIZATION'] here.                     *      https://php.net/reserved.variables.server                     */                    $headers['AUTHORIZATION'] = $authorizationHeader;                }            }        }        if (isset($headers['AUTHORIZATION'])) {            return $headers;        }        // PHP_AUTH_USER/PHP_AUTH_PW        if (isset($headers['PHP_AUTH_USER'])) {            $headers['AUTHORIZATION'] = 'Basic '.base64_encode($headers['PHP_AUTH_USER'].':'.$headers['PHP_AUTH_PW']);        } elseif (isset($headers['PHP_AUTH_DIGEST'])) {            $headers['AUTHORIZATION'] = $headers['PHP_AUTH_DIGEST'];        }        return $headers;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_SessionNotFoundException_8065, Raised when a session does not exists. This happens in the following cases:\n - the session is not enabled\n - attempt to read a session outside a request context (ie. cli script).\n\n @author Jérémy Derussé <jeremy@derusse.com>\n, Raised when a session does not exists. This happens in the following cases:,"class SessionNotFoundException extends \LogicException implements RequestExceptionInterface{    public function __construct($message = 'There is currently no session available.', $code = 0, \Throwable $previous = null)    {        parent::__construct($message, $code, $previous);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_SessionUtils_10008, Session utility functions.\n\n @author Nicolas Grekas <p@tchwork.com>\n @author Rémon van de Kamp <rpkamp@gmail.com>\n\n @internal\n, Session utility functions.,"final class SessionUtils{    /**     * Finds the session header amongst the headers that are to be sent, removes it, and returns     * it so the caller can process it further.     */    public static function popSessionCookie(string $sessionName, string $sessionId): ?string    {        $sessionCookie = null;        $sessionCookiePrefix = sprintf(' %s=', urlencode($sessionName));        $sessionCookieWithId = sprintf('%s%s;', $sessionCookiePrefix, urlencode($sessionId));        $otherCookies = [];        foreach (headers_list() as $h) {            if (0 !== stripos($h, 'Set-Cookie:')) {                continue;            }            if (11 === strpos($h, $sessionCookiePrefix, 11)) {                $sessionCookie = $h;                if (11 !== strpos($h, $sessionCookieWithId, 11)) {                    $otherCookies[] = $h;                }            } else {                $otherCookies[] = $h;            }        }        if (null === $sessionCookie) {            return null;        }        header_remove('Set-Cookie');        foreach ($otherCookies as $h) {            header($h, false);        }        return $sessionCookie;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Session_9030, Gets the flashbag interface.\n\n @return FlashBagInterface\n, Gets the flashbag interface.,    public function getFlashBag()    {        return $this->getBag($this->flashName);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Session_9031, Gets the attributebag interface.\n\n Note that this method was added to help with IDE autocompletion.\n, Gets the attributebag interface.,    private function getAttributeBag(): AttributeBagInterface    {        return $this->getBag($this->attributeName);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_StreamedResponse_9923, StreamedResponse represents a streamed HTTP response.\n\n A StreamedResponse uses a callback for its content.\n\n The callback should use the standard PHP functions like echo\n to stream the response back to the client. The flush() function\n can also be used if needed.\n\n @see flush()\n\n @author Fabien Potencier <fabien@symfony.com>\n, StreamedResponse represents a streamed HTTP response.,"class StreamedResponse extends Response{    protected $callback;    protected $streamed;    private $headersSent;    public function __construct(callable $callback = null, int $status = 200, array $headers = [])    {        parent::__construct(null, $status, $headers);        if (null !== $callback) {            $this->setCallback($callback);        }        $this->streamed = false;        $this->headersSent = false;    }    /**     * Factory method for chainability.     *     * @param callable|null $callback A valid PHP callback or null to set it later     *     * @return static     *     * @deprecated since Symfony 5.1, use __construct() instead.     */    public static function create($callback = null, int $status = 200, array $headers = [])    {        trigger_deprecation('symfony/http-foundation', '5.1', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($callback, $status, $headers);    }    /**     * Sets the PHP callback associated with this Response.     *     * @return $this     */    public function setCallback(callable $callback)    {        $this->callback = $callback;        return $this;    }    /**     * {@inheritdoc}     *     * This method only sends the headers once.     *     * @return $this     */    public function sendHeaders()    {        if ($this->headersSent) {            return $this;        }        $this->headersSent = true;        return parent::sendHeaders();    }    /**     * {@inheritdoc}     *     * This method only sends the content once.     *     * @return $this     */    public function sendContent()    {        if ($this->streamed) {            return $this;        }        $this->streamed = true;        if (null === $this->callback) {            throw new \LogicException('The Response callback must not be null.');        }        ($this->callback)();        return $this;    }    /**     * {@inheritdoc}     *     * @throws \LogicException when the content is not null     *     * @return $this     */    public function setContent(?string $content)    {        if (null !== $content) {            throw new \LogicException('The content cannot be set on a StreamedResponse instance.');        }        $this->streamed = true;        return $this;    }    /**     * {@inheritdoc}     */    public function getContent()    {        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_UploadedFile_8082, Returns an informative upload error message.\n\n @return string The error message regarding the specified error code\n, Returns an informative upload error message.,"    public function getErrorMessage()    {        static $errors = [            \UPLOAD_ERR_INI_SIZE => 'The file ""%s"" exceeds your upload_max_filesize ini directive (limit is %d KiB).',            \UPLOAD_ERR_FORM_SIZE => 'The file ""%s"" exceeds the upload limit defined in your form.',            \UPLOAD_ERR_PARTIAL => 'The file ""%s"" was only partially uploaded.',            \UPLOAD_ERR_NO_FILE => 'No file was uploaded.',            \UPLOAD_ERR_CANT_WRITE => 'The file ""%s"" could not be written on disk.',            \UPLOAD_ERR_NO_TMP_DIR => 'File could not be uploaded: missing temporary directory.',            \UPLOAD_ERR_EXTENSION => 'File upload was stopped by a PHP extension.',        ];        $errorCode = $this->error;        $maxFilesize = \UPLOAD_ERR_INI_SIZE === $errorCode ? self::getMaxFilesize() / 1024 : 0;        $message = $errors[$errorCode] ?? 'The file ""%s"" was not uploaded due to an unknown error.';        return sprintf($message, $this->getClientOriginalName(), $maxFilesize);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_UploadedFile_8999, Returns the given size from an ini value in bytes.\n\n @return int|float Returns float if size > PHP_INT_MAX\n, Returns the given size from an ini value in bytes.,"    private static function parseFilesize($size)    {        if ('' === $size) {            return 0;        }        $size = strtolower($size);        $max = ltrim($size, '+');        if (0 === strpos($max, '0x')) {            $max = \intval($max, 16);        } elseif (0 === strpos($max, '0')) {            $max = \intval($max, 8);        } else {            $max = (int) $max;        }        switch (substr($size, -1)) {            case 't': $max *= 1024;            // no break            case 'g': $max *= 1024;            // no break            case 'm': $max *= 1024;            // no break            case 'k': $max *= 1024;        }        return $max;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_UrlHelper_9929, A helper service for manipulating URLs within and outside the request scope.\n\n @author Valentin Udaltsov <udaltsov.valentin@gmail.com>\n, A helper service for manipulating URLs within and outside the request scope.,"final class UrlHelper{    private $requestStack;    private $requestContext;    public function __construct(RequestStack $requestStack, RequestContext $requestContext = null)    {        $this->requestStack = $requestStack;        $this->requestContext = $requestContext;    }    public function getAbsoluteUrl(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $this->getAbsoluteUrlFromContext($path);        }        if ('#' === $path[0]) {            $path = $request->getRequestUri().$path;        } elseif ('?' === $path[0]) {            $path = $request->getPathInfo().$path;        }        if (!$path || '/' !== $path[0]) {            $prefix = $request->getPathInfo();            $last = \strlen($prefix) - 1;            if ($last !== $pos = strrpos($prefix, '/')) {                $prefix = substr($prefix, 0, $pos).'/';            }            return $request->getUriForPath($prefix.$path);        }        return $request->getSchemeAndHttpHost().$path;    }    public function getRelativePath(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $path;        }        return $request->getRelativeUriForPath($path);    }    private function getAbsoluteUrlFromContext(string $path): string    {        if (null === $this->requestContext || '' === $host = $this->requestContext->getHost()) {            return $path;        }        $scheme = $this->requestContext->getScheme();        $port = '';        if ('http' === $scheme && 80 !== $this->requestContext->getHttpPort()) {            $port = ':'.$this->requestContext->getHttpPort();        } elseif ('https' === $scheme && 443 !== $this->requestContext->getHttpsPort()) {            $port = ':'.$this->requestContext->getHttpsPort();        }        if ('#' === $path[0]) {            $queryString = $this->requestContext->getQueryString();            $path = $this->requestContext->getPathInfo().($queryString ? '?'.$queryString : '').$path;        } elseif ('?' === $path[0]) {            $path = $this->requestContext->getPathInfo().$path;        }        if ('/' !== $path[0]) {            $path = rtrim($this->requestContext->getBaseUrl(), '/').'/'.$path;        }        return $scheme.'://'.$host.$port.$path;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_AddAnnotatedClassesToCachePass_3215, Sets the classes to compile in the cache for the container.\n\n @author Fabien Potencier <fabien@symfony.com>\n, Sets the classes to compile in the cache for the container.,"class AddAnnotatedClassesToCachePass implements CompilerPassInterface{    private $kernel;    public function __construct(Kernel $kernel)    {        $this->kernel = $kernel;    }    /**     * {@inheritdoc}     */    public function process(ContainerBuilder $container)    {        $annotatedClasses = $this->kernel->getAnnotatedClassesToCompile();        foreach ($container->getExtensions() as $extension) {            if ($extension instanceof Extension) {                $annotatedClasses = array_merge($annotatedClasses, $extension->getAnnotatedClassesToCompile());            }        }        $existingClasses = $this->getClassesInComposerClassMaps();        $annotatedClasses = $container->getParameterBag()->resolveValue($annotatedClasses);        $this->kernel->setAnnotatedClassCache($this->expandClasses($annotatedClasses, $existingClasses));    }    /**     * Expands the given class patterns using a list of existing classes.     *     * @param array $patterns The class patterns to expand     * @param array $classes  The existing classes to match against the patterns     */    private function expandClasses(array $patterns, array $classes): array    {        $expanded = [];        // Explicit classes declared in the patterns are returned directly        foreach ($patterns as $key => $pattern) {            if ('\\' !== substr($pattern, -1) && false === strpos($pattern, '*')) {                unset($patterns[$key]);                $expanded[] = ltrim($pattern, '\\');            }        }        // Match patterns with the classes list        $regexps = $this->patternsToRegexps($patterns);        foreach ($classes as $class) {            $class = ltrim($class, '\\');            if ($this->matchAnyRegexps($class, $regexps)) {                $expanded[] = $class;            }        }        return array_unique($expanded);    }    private function getClassesInComposerClassMaps(): array    {        $classes = [];        foreach (spl_autoload_functions() as $function) {            if (!\is_array($function)) {                continue;            }            if ($function[0] instanceof DebugClassLoader || $function[0] instanceof LegacyDebugClassLoader) {                $function = $function[0]->getClassLoader();            }            if (\is_array($function) && $function[0] instanceof ClassLoader) {                $classes += array_filter($function[0]->getClassMap());            }        }        return array_keys($classes);    }    private function patternsToRegexps(array $patterns): array    {        $regexps = [];        foreach ($patterns as $pattern) {            // Escape user input            $regex = preg_quote(ltrim($pattern, '\\'));            // Wildcards * and **            $regex = strtr($regex, ['\\*\\*' => '.*?', '\\*' => '[^\\\\]*?']);            // If this class does not end by a slash, anchor the end            if ('\\' !== substr($regex, -1)) {                $regex .= '$';            }            $regexps[] = '{^\\\\'.$regex.'}';        }        return $regexps;    }    private function matchAnyRegexps(string $class, array $regexps): bool    {        $isTest = false !== strpos($class, 'Test');        foreach ($regexps as $regex) {            if ($isTest && false === strpos($regex, 'Test')) {                continue;            }            if (preg_match($regex, '\\'.$class)) {                return true;            }        }        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ArgumentMetadataFactory_3144, Returns an associated type to the given parameter if available.\n, Returns an associated type to the given parameter if available.,"    private function getType(\ReflectionParameter $parameter, \ReflectionFunctionAbstract $function): ?string    {        if (!$type = $parameter->getType()) {            return null;        }        $name = $type instanceof \ReflectionNamedType ? $type->getName() : (string) $type;        if ($function instanceof \ReflectionMethod) {            $lcName = strtolower($name);            switch ($lcName) {                case 'self':                    return $function->getDeclaringClass()->name;                case 'parent':                    return ($parent = $function->getDeclaringClass()->getParentClass()) ? $parent->name : null;            }        }        return $name;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ArgumentValueResolverInterface_3119, Whether this resolver can resolve the value for the given ArgumentMetadata.\n\n @return bool\n, Whether this resolver can resolve the value for the given ArgumentMetadata.,"    public function supports(Request $request, ArgumentMetadata $argument);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_Bundle_3091, Returns the bundle's container extension.\n\n @return ExtensionInterface|null The container extension\n\n @throws \\LogicException\n, Returns the bundle's container extension.,"    public function getContainerExtension()    {        if (null === $this->extension) {            $extension = $this->createContainerExtension();            if (null !== $extension) {                if (!$extension instanceof ExtensionInterface) {                    throw new \LogicException(sprintf('Extension ""%s"" must implement Symfony\Component\DependencyInjection\Extension\ExtensionInterface.', get_debug_type($extension)));                }                // check naming convention                $basename = preg_replace('/Bundle$/', '', $this->getName());                $expectedAlias = Container::underscore($basename);                if ($expectedAlias != $extension->getAlias()) {                    throw new \LogicException(sprintf('Users will expect the alias of the default extension of a bundle to be the underscored version of the bundle name (""%s""). You can override ""Bundle::getContainerExtension()"" if you want to use ""%s"" or another alias.', $expectedAlias, $extension->getAlias()));                }                $this->extension = $extension;            } else {                $this->extension = false;            }        }        return $this->extension ?: null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ConfigDataCollector_3157, Gets the PHP version extra part.\n\n @return string|null The extra part\n, Gets the PHP version extra part.,    public function getPhpVersionExtra()    {        return $this->data['php_version_extra'] ?? null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ConfigDataCollector_3162," Returns true if the debug is enabled.\n\n @return bool|string true if debug is enabled, false otherwise or a string if no kernel was set\n", Returns true if the debug is enabled.,    public function isDebug()    {        return $this->data['debug'];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ControllerArgumentValueResolverPass_3221, Gathers and configures the argument value resolvers.\n\n @author Iltar van der Berg <kjarli@gmail.com>\n, Gathers and configures the argument value resolvers.,"class ControllerArgumentValueResolverPass implements CompilerPassInterface{    use PriorityTaggedServiceTrait;    private $argumentResolverService;    private $argumentValueResolverTag;    private $traceableResolverStopwatch;    public function __construct(string $argumentResolverService = 'argument_resolver', string $argumentValueResolverTag = 'controller.argument_value_resolver', string $traceableResolverStopwatch = 'debug.stopwatch')    {        if (0 < \func_num_args()) {            trigger_deprecation('symfony/http-kernel', '5.3', 'Configuring ""%s"" is deprecated.', __CLASS__);        }        $this->argumentResolverService = $argumentResolverService;        $this->argumentValueResolverTag = $argumentValueResolverTag;        $this->traceableResolverStopwatch = $traceableResolverStopwatch;    }    public function process(ContainerBuilder $container)    {        if (!$container->hasDefinition($this->argumentResolverService)) {            return;        }        $resolvers = $this->findAndSortTaggedServices($this->argumentValueResolverTag, $container);        if ($container->getParameter('kernel.debug') && class_exists(Stopwatch::class) && $container->has($this->traceableResolverStopwatch)) {            foreach ($resolvers as $resolverReference) {                $id = (string) $resolverReference;                $container->register(""debug.$id"", TraceableValueResolver::class)                    ->setDecoratedService($id)                    ->setArguments([new Reference(""debug.$id.inner""), new Reference($this->traceableResolverStopwatch)]);            }        }        $container            ->getDefinition($this->argumentResolverService)            ->replaceArgument(1, new IteratorArgument($resolvers))        ;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ControllerArgumentsEvent_3232, Allows filtering of controller arguments.\n\n You can call getController() to retrieve the controller and getArguments\n to retrieve the current arguments. With setArguments() you can replace\n arguments that are used to call the controller.\n\n Arguments set in the event must be compatible with the signature of the\n controller.\n\n @author Christophe Coevoet <stof@notk.org>\n, Allows filtering of controller arguments.,"final class ControllerArgumentsEvent extends KernelEvent{    private $controller;    private $arguments;    public function __construct(HttpKernelInterface $kernel, callable $controller, array $arguments, Request $request, ?int $requestType)    {        parent::__construct($kernel, $request, $requestType);        $this->controller = $controller;        $this->arguments = $arguments;    }    public function getController(): callable    {        return $this->controller;    }    public function setController(callable $controller)    {        $this->controller = $controller;    }    public function getArguments(): array    {        return $this->arguments;    }    public function setArguments(array $arguments)    {        $this->arguments = $arguments;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ControllerReference_3123," Acts as a marker and a data holder for a Controller.\n\n Some methods in Symfony accept both a URI (as a string) or a controller as\n an argument. In the latter case, instead of passing an array representing\n the controller, you can use an instance of this class.\n\n @author Fabien Potencier <fabien@symfony.com>\n\n @see FragmentRendererInterface\n", Acts as a marker and a data holder for a Controller.,"class ControllerReference{    public $controller;    public $attributes = [];    public $query = [];    /**     * @param string $controller The controller name     * @param array  $attributes An array of parameters to add to the Request attributes     * @param array  $query      An array of parameters to add to the Request query string     */    public function __construct(string $controller, array $attributes = [], array $query = [])    {        $this->controller = $controller;        $this->attributes = $attributes;        $this->query = $query;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ExceptionDataCollector_3191, Gets the exception message.\n\n @return string The exception message\n, Gets the exception message.,    public function getMessage()    {        return $this->data['exception']->getMessage();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ExceptionEvent_3234, Allows to create a response for a thrown exception.\n\n Call setResponse() to set the response that will be returned for the\n current request. The propagation of this event is stopped as soon as a\n response is set.\n\n You can also call setThrowable() to replace the thrown exception. This\n exception will be thrown if no response is set during processing of this\n event.\n\n @author Bernhard Schussek <bschussek@gmail.com>\n, Allows to create a response for a thrown exception.,"final class ExceptionEvent extends RequestEvent{    private $throwable;    /**     * @var bool     */    private $allowCustomResponseCode = false;    public function __construct(HttpKernelInterface $kernel, Request $request, int $requestType, \Throwable $e)    {        parent::__construct($kernel, $request, $requestType);        $this->setThrowable($e);    }    public function getThrowable(): \Throwable    {        return $this->throwable;    }    /**     * Replaces the thrown exception.     *     * This exception will be thrown if no response is set in the event.     */    public function setThrowable(\Throwable $exception): void    {        $this->throwable = $exception;    }    /**     * Mark the event as allowing a custom response code.     */    public function allowCustomResponseCode(): void    {        $this->allowCustomResponseCode = true;    }    /**     * Returns true if the event allows a custom response code.     */    public function isAllowingCustomResponseCode(): bool    {        return $this->allowCustomResponseCode;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ExceptionEvent_3236, Mark the event as allowing a custom response code.\n, Mark the event as allowing a custom response code.,    public function allowCustomResponseCode(): void    {        $this->allowCustomResponseCode = true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_HttpKernelBrowser_3026, Sets whether to catch exceptions when the kernel is handling a request.\n, Sets whether to catch exceptions when the kernel is handling a request.,    public function catchExceptions(bool $catchExceptions)    {        $this->catchExceptions = $catchExceptions;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_HttpKernelBrowser_3028, Returns the script to execute when the request must be insulated.\n\n @return string\n, Returns the script to execute when the request must be insulated.,"    protected function getScript($request)    {        $kernel = var_export(serialize($this->kernel), true);        $request = var_export(serialize($request), true);        $errorReporting = error_reporting();        $requires = '';        foreach (get_declared_classes() as $class) {            if (0 === strpos($class, 'ComposerAutoloaderInit')) {                $r = new \ReflectionClass($class);                $file = \dirname($r->getFileName(), 2).'/autoload.php';                if (file_exists($file)) {                    $requires .= 'require_once '.var_export($file, true)."";\n"";                }            }        }        if (!$requires) {            throw new \RuntimeException('Composer autoloader not found.');        }        $code = <<<EOF<?phperror_reporting($errorReporting);$requires\$kernel = unserialize($kernel);\$request = unserialize($request);EOF;        return $code.$this->getHandleScript();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_HttpKernelBrowser_3029, Converts the BrowserKit request to a HttpKernel request.\n\n @return Request A Request instance\n, Converts the BrowserKit request to a HttpKernel request.,"    protected function filterRequest(DomRequest $request)    {        $httpRequest = Request::create($request->getUri(), $request->getMethod(), $request->getParameters(), $request->getCookies(), $request->getFiles(), $server = $request->getServer(), $request->getContent());        if (!isset($server['HTTP_ACCEPT'])) {            $httpRequest->headers->remove('Accept');        }        foreach ($this->filterFiles($httpRequest->files->all()) as $key => $value) {            $httpRequest->files->set($key, $value);        }        return $httpRequest;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_HttpKernelBrowser_3030, Filters an array of files.\n\n This method created test instances of UploadedFile so that the move()\n method can be called on those instances.\n\n If the size of a file is greater than the allowed size (from php.ini) then\n an invalid UploadedFile is returned with an error set to UPLOAD_ERR_INI_SIZE.\n\n @see UploadedFile\n\n @return array An array with all uploaded files marked as already moved\n, Filters an array of files.,"    protected function filterFiles(array $files)    {        $filtered = [];        foreach ($files as $key => $value) {            if (\is_array($value)) {                $filtered[$key] = $this->filterFiles($value);            } elseif ($value instanceof UploadedFile) {                if ($value->isValid() && $value->getSize() > UploadedFile::getMaxFilesize()) {                    $filtered[$key] = new UploadedFile(                        '',                        $value->getClientOriginalName(),                        $value->getClientMimeType(),                        \UPLOAD_ERR_INI_SIZE,                        true                    );                } else {                    $filtered[$key] = new UploadedFile(                        $value->getPathname(),                        $value->getClientOriginalName(),                        $value->getClientMimeType(),                        $value->getError(),                        true                    );                }            }        }        return $filtered;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_HttpKernel_3022," Publishes the finish request event, then pop the request from the stack.\n\n Note that the order of the operations is important here, otherwise\n operations such as {@link RequestStack::getParentRequest()} can lead to\n weird results.\n"," Publishes the finish request event, then pop the request from the stack.","    private function finishRequest(Request $request, int $type)    {        $this->dispatcher->dispatch(new FinishRequestEvent($this, $request, $type), KernelEvents::FINISH_REQUEST);        $this->requestStack->pop();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_HttpKernel_3023, Handles a throwable by trying to convert it to a Response.\n\n @throws \\Exception\n, Handles a throwable by trying to convert it to a Response.,"    private function handleThrowable(\Throwable $e, Request $request, int $type): Response    {        $event = new ExceptionEvent($this, $request, $type, $e);        $this->dispatcher->dispatch($event, KernelEvents::EXCEPTION);        // a listener might have replaced the exception        $e = $event->getThrowable();        if (!$event->hasResponse()) {            $this->finishRequest($request, $type);            throw $e;        }        $response = $event->getResponse();        // the developer asked for a specific status code        if (!$event->isAllowingCustomResponseCode() && !$response->isClientError() && !$response->isServerError() && !$response->isRedirect()) {            // ensure that we actually have an error response            if ($e instanceof HttpExceptionInterface) {                // keep the HTTP status code and headers                $response->setStatusCode($e->getStatusCode());                $response->headers->add($e->getHeaders());            } else {                $response->setStatusCode(500);            }        }        try {            return $this->filterResponse($response, $request, $type);        } catch (\Exception $e) {            return $response;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_HttpKernel_3024, Returns a human-readable string for the specified variable.\n, Returns a human-readable string for the specified variable.,"    private function varToString($var): string    {        if (\is_object($var)) {            return sprintf('an object of type %s', \get_class($var));        }        if (\is_array($var)) {            $a = [];            foreach ($var as $k => $v) {                $a[] = sprintf('%s => ...', $k);            }            return sprintf('an array ([%s])', mb_substr(implode(', ', $a), 0, 255));        }        if (\is_resource($var)) {            return sprintf('a resource (%s)', get_resource_type($var));        }        if (null === $var) {            return 'null';        }        if (false === $var) {            return 'a boolean value (false)';        }        if (true === $var) {            return 'a boolean value (true)';        }        if (\is_string($var)) {            return sprintf('a string (""%s%s"")', mb_substr($var, 0, 255), mb_strlen($var) > 255 ? '...' : '');        }        if (is_numeric($var)) {            return sprintf('a number (%s)', (string) $var);        }        return (string) $var;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_Kernel_3062, Returns a loader for the container.\n\n @return DelegatingLoader The loader\n, Returns a loader for the container.,"    protected function getContainerLoader(ContainerInterface $container)    {        $env = $this->getEnvironment();        $locator = new FileLocator($this);        $resolver = new LoaderResolver([            new XmlFileLoader($container, $locator, $env),            new YamlFileLoader($container, $locator, $env),            new IniFileLoader($container, $locator, $env),            new PhpFileLoader($container, $locator, $env, class_exists(ConfigBuilderGenerator::class) ? new ConfigBuilderGenerator($this->getBuildDir()) : null),            new GlobFileLoader($container, $locator, $env),            new DirectoryLoader($container, $locator, $env),            new ClosureLoader($container, $env),        ]);        return new DelegatingLoader($resolver);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_Kernel_3063, Removes comments from a PHP source string.\n\n We don't use the PHP php_strip_whitespace() function\n as we want the content to be readable and well-formatted.\n\n @return string The PHP string with the comments removed\n, Removes comments from a PHP source string.,"    public static function stripComments(string $source)    {        if (!\function_exists('token_get_all')) {            return $source;        }        $rawChunk = '';        $output = '';        $tokens = token_get_all($source);        $ignoreSpace = false;        for ($i = 0; isset($tokens[$i]); ++$i) {            $token = $tokens[$i];            if (!isset($token[1]) || 'b""' === $token) {                $rawChunk .= $token;            } elseif (\T_START_HEREDOC === $token[0]) {                $output .= $rawChunk.$token[1];                do {                    $token = $tokens[++$i];                    $output .= isset($token[1]) && 'b""' !== $token ? $token[1] : $token;                } while (\T_END_HEREDOC !== $token[0]);                $rawChunk = '';            } elseif (\T_WHITESPACE === $token[0]) {                if ($ignoreSpace) {                    $ignoreSpace = false;                    continue;                }                // replace multiple new lines with a single newline                $rawChunk .= preg_replace(['/\n{2,}/S'], ""\n"", $token[1]);            } elseif (\in_array($token[0], [\T_COMMENT, \T_DOC_COMMENT])) {                if (!\in_array($rawChunk[\strlen($rawChunk) - 1], [' ', ""\n"", ""\r"", ""\t""], true)) {                    $rawChunk .= ' ';                }                $ignoreSpace = true;            } else {                $rawChunk .= $token[1];                // The PHP-open tag already has a new-line                if (\T_OPEN_TAG === $token[0]) {                    $ignoreSpace = true;                } else {                    $ignoreSpace = false;                }            }        }        $output .= $rawChunk;        unset($tokens, $rawChunk);        gc_mem_caches();        return $output;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_MemoryDataCollector_3206, Updates the memory usage data.\n, Updates the memory usage data.,    public function updateMemoryUsage()    {        $this->data['memory'] = memory_get_peak_usage(true);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_RegisterControllerArgumentLocatorsPass_3230, Creates the service-locators required by ServiceValueResolver.\n\n @author Nicolas Grekas <p@tchwork.com>\n, Creates the service-locators required by ServiceValueResolver.,"class RegisterControllerArgumentLocatorsPass implements CompilerPassInterface{    private $resolverServiceId;    private $controllerTag;    private $controllerLocator;    private $notTaggedControllerResolverServiceId;    public function __construct(string $resolverServiceId = 'argument_resolver.service', string $controllerTag = 'controller.service_arguments', string $controllerLocator = 'argument_resolver.controller_locator', string $notTaggedControllerResolverServiceId = 'argument_resolver.not_tagged_controller')    {        if (0 < \func_num_args()) {            trigger_deprecation('symfony/http-kernel', '5.3', 'Configuring ""%s"" is deprecated.', __CLASS__);        }        $this->resolverServiceId = $resolverServiceId;        $this->controllerTag = $controllerTag;        $this->controllerLocator = $controllerLocator;        $this->notTaggedControllerResolverServiceId = $notTaggedControllerResolverServiceId;    }    public function process(ContainerBuilder $container)    {        if (false === $container->hasDefinition($this->resolverServiceId) && false === $container->hasDefinition($this->notTaggedControllerResolverServiceId)) {            return;        }        $parameterBag = $container->getParameterBag();        $controllers = [];        $publicAliases = [];        foreach ($container->getAliases() as $id => $alias) {            if ($alias->isPublic() && !$alias->isPrivate()) {                $publicAliases[(string) $alias][] = $id;            }        }        foreach ($container->findTaggedServiceIds($this->controllerTag, true) as $id => $tags) {            $def = $container->getDefinition($id);            $def->setPublic(true);            $class = $def->getClass();            $autowire = $def->isAutowired();            $bindings = $def->getBindings();            // resolve service class, taking parent definitions into account            while ($def instanceof ChildDefinition) {                $def = $container->findDefinition($def->getParent());                $class = $class ?: $def->getClass();                $bindings += $def->getBindings();            }            $class = $parameterBag->resolveValue($class);            if (!$r = $container->getReflectionClass($class)) {                throw new InvalidArgumentException(sprintf('Class ""%s"" used for service ""%s"" cannot be found.', $class, $id));            }            $isContainerAware = $r->implementsInterface(ContainerAwareInterface::class) || is_subclass_of($class, AbstractController::class);            // get regular public methods            $methods = [];            $arguments = [];            foreach ($r->getMethods(\ReflectionMethod::IS_PUBLIC) as $r) {                if ('setContainer' === $r->name && $isContainerAware) {                    continue;                }                if (!$r->isConstructor() && !$r->isDestructor() && !$r->isAbstract()) {                    $methods[strtolower($r->name)] = [$r, $r->getParameters()];                }            }            // validate and collect explicit per-actions and per-arguments service references            foreach ($tags as $attributes) {                if (!isset($attributes['action']) && !isset($attributes['argument']) && !isset($attributes['id'])) {                    $autowire = true;                    continue;                }                foreach (['action', 'argument', 'id'] as $k) {                    if (!isset($attributes[$k][0])) {                        throw new InvalidArgumentException(sprintf('Missing ""%s"" attribute on tag ""%s"" %s for service ""%s"".', $k, $this->controllerTag, json_encode($attributes, \JSON_UNESCAPED_UNICODE), $id));                    }                }                if (!isset($methods[$action = strtolower($attributes['action'])])) {                    throw new InvalidArgumentException(sprintf('Invalid ""action"" attribute on tag ""%s"" for service ""%s"": no public ""%s()"" method found on class ""%s"".', $this->controllerTag, $id, $attributes['action'], $class));                }                [$r, $parameters] = $methods[$action];                $found = false;                foreach ($parameters as $p) {                    if ($attributes['argument'] === $p->name) {                        if (!isset($arguments[$r->name][$p->name])) {                            $arguments[$r->name][$p->name] = $attributes['id'];                        }                        $found = true;                        break;                    }                }                if (!$found) {                    throw new InvalidArgumentException(sprintf('Invalid ""%s"" tag for service ""%s"": method ""%s()"" has no ""%s"" argument on class ""%s"".', $this->controllerTag, $id, $r->name, $attributes['argument'], $class));                }            }            foreach ($methods as [$r, $parameters]) {                /** @var \ReflectionMethod $r */                // create a per-method map of argument-names to service/type-references                $args = [];                foreach ($parameters as $p) {                    /** @var \ReflectionParameter $p */                    $type = ltrim($target = (string) ProxyHelper::getTypeHint($r, $p), '\\');                    $invalidBehavior = ContainerInterface::IGNORE_ON_INVALID_REFERENCE;                    if (isset($arguments[$r->name][$p->name])) {                        $target = $arguments[$r->name][$p->name];                        if ('?' !== $target[0]) {                            $invalidBehavior = ContainerInterface::RUNTIME_EXCEPTION_ON_INVALID_REFERENCE;                        } elseif ('' === $target = (string) substr($target, 1)) {                            throw new InvalidArgumentException(sprintf('A ""%s"" tag must have non-empty ""id"" attributes for service ""%s"".', $this->controllerTag, $id));                        } elseif ($p->allowsNull() && !$p->isOptional()) {                            $invalidBehavior = ContainerInterface::NULL_ON_INVALID_REFERENCE;                        }                    } elseif (isset($bindings[$bindingName = $type.' $'.$name = Target::parseName($p)]) || isset($bindings[$bindingName = '$'.$name]) || isset($bindings[$bindingName = $type])) {                        $binding = $bindings[$bindingName];                        [$bindingValue, $bindingId, , $bindingType, $bindingFile] = $binding->getValues();                        $binding->setValues([$bindingValue, $bindingId, true, $bindingType, $bindingFile]);                        if (!$bindingValue instanceof Reference) {                            $args[$p->name] = new Reference('.value.'.$container->hash($bindingValue));                            $container->register((string) $args[$p->name], 'mixed')                                ->setFactory('current')                                ->addArgument([$bindingValue]);                        } else {                            $args[$p->name] = $bindingValue;                        }                        continue;                    } elseif (!$type || !$autowire || '\\' !== $target[0]) {                        continue;                    } elseif (!$p->allowsNull()) {                        $invalidBehavior = ContainerInterface::RUNTIME_EXCEPTION_ON_INVALID_REFERENCE;                    }                    if (Request::class === $type || SessionInterface::class === $type) {                        continue;                    }                    if ($type && !$p->isOptional() && !$p->allowsNull() && !class_exists($type) && !interface_exists($type, false)) {                        $message = sprintf('Cannot determine controller argument for ""%s::%s()"": the $%s argument is type-hinted with the non-existent class or interface: ""%s"".', $class, $r->name, $p->name, $type);                        // see if the type-hint lives in the same namespace as the controller                        if (0 === strncmp($type, $class, strrpos($class, '\\'))) {                            $message .= ' Did you forget to add a use statement?';                        }                        $container->register($erroredId = '.errored.'.$container->hash($message), $type)                            ->addError($message);                        $args[$p->name] = new Reference($erroredId, ContainerInterface::RUNTIME_EXCEPTION_ON_INVALID_REFERENCE);                    } else {                        $target = ltrim($target, '\\');                        $args[$p->name] = $type ? new TypedReference($target, $type, $invalidBehavior, $p->name) : new Reference($target, $invalidBehavior);                    }                }                // register the maps as a per-method service-locators                if ($args) {                    $controllers[$id.'::'.$r->name] = ServiceLocatorTagPass::register($container, $args);                    foreach ($publicAliases[$id] ?? [] as $alias) {                        $controllers[$alias.'::'.$r->name] = clone $controllers[$id.'::'.$r->name];                    }                }            }        }        $controllerLocatorRef = ServiceLocatorTagPass::register($container, $controllers);        if ($container->hasDefinition($this->resolverServiceId)) {            $container->getDefinition($this->resolverServiceId)                ->replaceArgument(0, $controllerLocatorRef);        }        if ($container->hasDefinition($this->notTaggedControllerResolverServiceId)) {            $container->getDefinition($this->notTaggedControllerResolverServiceId)                ->replaceArgument(0, $controllerLocatorRef);        }        $container->setAlias($this->controllerLocator, (string) $controllerLocatorRef);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_AbstractPipes_1526, Unblocks streams.\\n, Unblocks streams.,"    protected function unblock()    {        if (!$this->blocked) {            return;        }        foreach ($this->pipes as $pipe) {            stream_set_blocking($pipe, 0);        }        if (\is_resource($this->input)) {            stream_set_blocking($this->input, 0);        }        $this->blocked = false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_AbstractPipes_1527, Writes input to stdin.\n\n @throws InvalidArgumentException When an input iterator yields a non supported value\n, Writes input to stdin.,"    protected function write(): ?array    {        if (!isset($this->pipes[0])) {            return null;        }        $input = $this->input;        if ($input instanceof \Iterator) {            if (!$input->valid()) {                $input = null;            } elseif (\is_resource($input = $input->current())) {                stream_set_blocking($input, 0);            } elseif (!isset($this->inputBuffer[0])) {                if (!\is_string($input)) {                    if (!is_scalar($input)) {                        throw new InvalidArgumentException(sprintf('""%s"" yielded a value of type ""%s"", but only scalars and stream resources are supported.', get_debug_type($this->input), get_debug_type($input)));                    }                    $input = (string) $input;                }                $this->inputBuffer = $input;                $this->input->next();                $input = null;            } else {                $input = null;            }        }        $r = $e = [];        $w = [$this->pipes[0]];        // let's have a look if something changed in streams        if (false === @stream_select($r, $w, $e, 0, 0)) {            return null;        }        foreach ($w as $stdin) {            if (isset($this->inputBuffer[0])) {                $written = fwrite($stdin, $this->inputBuffer);                $this->inputBuffer = substr($this->inputBuffer, $written);                if (isset($this->inputBuffer[0])) {                    return [$this->pipes[0]];                }            }            if ($input) {                for (;;) {                    $data = fread($input, self::CHUNK_SIZE);                    if (!isset($data[0])) {                        break;                    }                    $written = fwrite($stdin, $data);                    $data = substr($data, $written);                    if (isset($data[0])) {                        $this->inputBuffer = $data;                        return [$this->pipes[0]];                    }                }                if (feof($input)) {                    if ($this->input instanceof \Iterator) {                        $this->input->next();                    } else {                        $this->input = null;                    }                }            }        }        // no input to read on resource, buffer is empty        if (!isset($this->inputBuffer[0]) && !($this->input instanceof \Iterator ? $this->input->valid() : $this->input)) {            $this->input = null;            fclose($this->pipes[0]);            unset($this->pipes[0]);        } elseif (!$w) {            return [$this->pipes[0]];        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_ExecutableFinder_1445, Replaces default suffixes of executable.\\n, Replaces default suffixes of executable.,    public function setSuffixes(array $suffixes)    {        $this->suffixes = $suffixes;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_ExecutableFinder_1446, Adds new possible suffix to check for executable.\\\\n, Adds new possible suffix to check for executable.,    public function addSuffix(string $suffix)    {        $this->suffixes[] = $suffix;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_InputStream_1449, Closes the write buffer.\\n, Closes the write buffer.,    public function close()    {        $this->open = false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_InvalidArgumentException_1516, InvalidArgumentException for the Process Component.\n\n @author Romain Neutron <imprec@gmail.com>\n, InvalidArgumentException for the Process Component.,class InvalidArgumentException extends \InvalidArgumentException implements ExceptionInterface{},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_LogicException_1517, LogicException for the Process Component.\\\\n\\\\n @author Romain Neutron <imprec@gmail.com>\\\\n, LogicException for the Process Component.,class LogicException extends \LogicException implements ExceptionInterface{},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_NonStopableProcess_1547, Runs a PHP script that can be stopped only with a SIGKILL (9) signal for 3 seconds.\n\n @args duration Run this script with a custom duration\n\n @example `php NonStopableProcess.php 42` will run the script for 42 seconds\n, Runs a PHP script that can be stopped only with a SIGKILL (9) signal for 3 seconds.,"function handleSignal($signal){    switch ($signal) {        case \SIGTERM:            $name = 'SIGTERM';            break;        case \SIGINT:            $name = 'SIGINT';            break;        default:            $name = $signal.' (unknown)';            break;    }    echo ""signal $name\n"";}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_PhpExecutableFinderTest_1549, tests find() with the constant PHP_BINARY.\\\\n, tests find() with the constant PHP_BINARY.,"    public function testFind()    {        $f = new PhpExecutableFinder();        $current = \PHP_BINARY;        $args = 'phpdbg' === \PHP_SAPI ? ' -qrr' : '';        $this->assertEquals($current.$args, $f->find(), '::find() returns the executable PHP');        $this->assertEquals($current, $f->find(false), '::find() returns the executable PHP');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_PhpExecutableFinder_1453, Finds the PHP executable arguments.\\\\n\\\\n @return array The PHP executable arguments\\\\n, Finds the PHP executable arguments.,    public function findArguments()    {        $arguments = [];        if ('phpdbg' === \PHP_SAPI) {            $arguments[] = '-qrr';        }        return $arguments;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_PhpProcess_1454," PhpProcess runs a PHP script in an independent process.\\\\n\\\\n     $p = new PhpProcess(\\\\\\\'<?php echo ""foo""; ?>\\\\\\\');\\\\n     $p->run();\\\\n     print $p->getOutput().""\\\\\\\\n"";\\\\n\\\\n @author Fabien Potencier <fabien@symfony.com>\\\\n", PhpProcess runs a PHP script in an independent process.,"class PhpProcess extends Process{    /**     * @param string      $script  The PHP script to run (as a string)     * @param string|null $cwd     The working directory or null to use the working dir of the current PHP process     * @param array|null  $env     The environment variables or null to use the same environment as the current PHP process     * @param int         $timeout The timeout in seconds     * @param array|null  $php     Path to the PHP binary to use with any additional arguments     */    public function __construct(string $script, string $cwd = null, array $env = null, int $timeout = 60, array $php = null)    {        if (null === $php) {            $executableFinder = new PhpExecutableFinder();            $php = $executableFinder->find(false);            $php = false === $php ? null : array_merge([$php], $executableFinder->findArguments());        }        if ('phpdbg' === \PHP_SAPI) {            $file = tempnam(sys_get_temp_dir(), 'dbg');            file_put_contents($file, $script);            register_shutdown_function('unlink', $file);            $php[] = $file;            $script = null;        }        parent::__construct($php, $cwd, $env, $script, $timeout);    }    /**     * {@inheritdoc}     */    public static function fromShellCommandline(string $command, string $cwd = null, array $env = null, $input = null, ?float $timeout = 60)    {        throw new LogicException(sprintf('The ""%s()"" method cannot be called when using ""%s"".', __METHOD__, self::class));    }    /**     * {@inheritdoc}     */    public function start(callable $callback = null, array $env = [])    {        if (null === $this->getCommandLine()) {            throw new RuntimeException('Unable to find the PHP executable.');        }        parent::start($callback, $env);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_ProcessFailedExceptionTest_1552, tests ProcessFailedException throws exception if the process was successful.\n, tests ProcessFailedException throws exception if the process was successful.,"    public function testProcessFailedExceptionThrowsException()    {        $process = $this->getMockBuilder(Process::class)->setMethods(['isSuccessful'])->setConstructorArgs([['php']])->getMock();        $process->expects($this->once())            ->method('isSuccessful')            ->willReturn(true);        $this->expectException(\InvalidArgumentException::class);        $this->expectExceptionMessage('Expected a failed process, but the given process was successful.');        new ProcessFailedException($process);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_ProcessFailedExceptionTest_1553, tests ProcessFailedException uses information from process output\\\\n to generate exception message.\\\\n, tests ProcessFailedException uses information from process output,"    public function testProcessFailedExceptionPopulatesInformationFromProcessOutput()    {        $cmd = 'php';        $exitCode = 1;        $exitText = 'General error';        $output = 'Command output';        $errorOutput = 'FATAL: Unexpected error';        $workingDirectory = getcwd();        $process = $this->getMockBuilder(Process::class)->setMethods(['isSuccessful', 'getOutput', 'getErrorOutput', 'getExitCode', 'getExitCodeText', 'isOutputDisabled', 'getWorkingDirectory'])->setConstructorArgs([[$cmd]])->getMock();        $process->expects($this->once())            ->method('isSuccessful')            ->willReturn(false);        $process->expects($this->once())            ->method('getOutput')            ->willReturn($output);        $process->expects($this->once())            ->method('getErrorOutput')            ->willReturn($errorOutput);        $process->expects($this->once())            ->method('getExitCode')            ->willReturn($exitCode);        $process->expects($this->once())            ->method('getExitCodeText')            ->willReturn($exitText);        $process->expects($this->once())            ->method('isOutputDisabled')            ->willReturn(false);        $process->expects($this->once())            ->method('getWorkingDirectory')            ->willReturn($workingDirectory);        $exception = new ProcessFailedException($process);        $this->assertEquals(            ""The command \""$cmd\"" failed.\n\nExit Code: $exitCode($exitText)\n\nWorking directory: {$workingDirectory}\n\nOutput:\n================\n{$output}\n\nError Output:\n================\n{$errorOutput}"",            str_replace(""'php'"", 'php', $exception->getMessage())        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_ProcessTest_1557, tests results from sub processes.\n\n @dataProvider responsesCodeProvider\n, tests results from sub processes.,"    public function testProcessResponses($expected, $getter, $code)    {        $p = $this->getProcessForCode($code);        $p->run();        $this->assertSame($expected, $p->$getter());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1455, Process is a thin wrapper around proc_ start independent PHP processes.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Romain Neutron <imprec@gmail.com>\n, Process is a thin wrapper around proc_ start independent PHP processes.,"class Process implements \IteratorAggregate{    public const ERR = 'err';    public const OUT = 'out';    public const STATUS_READY = 'ready';    public const STATUS_STARTED = 'started';    public const STATUS_TERMINATED = 'terminated';    public const STDIN = 0;    public const STDOUT = 1;    public const STDERR = 2;    // Timeout Precision in seconds.    public const TIMEOUT_PRECISION = 0.2;    public const ITER_NON_BLOCKING = 1; // By default, iterating over outputs is a blocking call, use this flag to make it non-blocking    public const ITER_KEEP_OUTPUT = 2;  // By default, outputs are cleared while iterating, use this flag to keep them in memory    public const ITER_SKIP_OUT = 4;     // Use this flag to skip STDOUT while iterating    public const ITER_SKIP_ERR = 8;     // Use this flag to skip STDERR while iterating    private $callback;    private $hasCallback = false;    private $commandline;    private $cwd;    private $env;    private $input;    private $starttime;    private $lastOutputTime;    private $timeout;    private $idleTimeout;    private $exitcode;    private $fallbackStatus = [];    private $processInformation;    private $outputDisabled = false;    private $stdout;    private $stderr;    private $process;    private $status = self::STATUS_READY;    private $incrementalOutputOffset = 0;    private $incrementalErrorOutputOffset = 0;    private $tty = false;    private $pty;    private $options = ['suppress_errors' => true, 'bypass_shell' => true];    private $useFileHandles = false;    /** @var PipesInterface */    private $processPipes;    private $latestSignal;    private static $sigchild;    /**     * Exit codes translation table.     *     * User-defined errors must use exit codes in the 64-113 range.     */    public static $exitCodes = [        0 => 'OK',        1 => 'General error',        2 => 'Misuse of shell builtins',        126 => 'Invoked command cannot execute',        127 => 'Command not found',        128 => 'Invalid exit argument',        // signals        129 => 'Hangup',        130 => 'Interrupt',        131 => 'Quit and dump core',        132 => 'Illegal instruction',        133 => 'Trace/breakpoint trap',        134 => 'Process aborted',        135 => 'Bus error: ""access to undefined portion of memory object""',        136 => 'Floating point exception: ""erroneous arithmetic operation""',        137 => 'Kill (terminate immediately)',        138 => 'User-defined 1',        139 => 'Segmentation violation',        140 => 'User-defined 2',        141 => 'Write to pipe with no one reading',        142 => 'Signal raised by alarm',        143 => 'Termination (request to terminate)',        // 144 - not defined        145 => 'Child process terminated, stopped (or continued*)',        146 => 'Continue if stopped',        147 => 'Stop executing temporarily',        148 => 'Terminal stop signal',        149 => 'Background process attempting to read from tty (""in"")',        150 => 'Background process attempting to write to tty (""out"")',        151 => 'Urgent data available on socket',        152 => 'CPU time limit exceeded',        153 => 'File size limit exceeded',        154 => 'Signal raised by timer counting virtual time: ""virtual timer expired""',        155 => 'Profiling timer expired',        // 156 - not defined        157 => 'Pollable event',        // 158 - not defined        159 => 'Bad syscall',    ];    /**     * @param array          $command The command to run and its arguments listed as separate entries     * @param string|null    $cwd     The working directory or null to use the working dir of the current PHP process     * @param array|null     $env     The environment variables or null to use the same environment as the current PHP process     * @param mixed          $input   The input as stream resource, scalar or \Traversable, or null for no input     * @param int|float|null $timeout The timeout in seconds or null to disable     *     * @throws LogicException When proc_open is not installed     */    public function __construct(array $command, string $cwd = null, array $env = null, $input = null, ?float $timeout = 60)    {        if (!\function_exists('proc_open')) {            throw new LogicException('The Process class relies on proc_open, which is not available on your PHP installation.');        }        $this->commandline = $command;        $this->cwd = $cwd;        // on Windows, if the cwd changed via chdir(), proc_open defaults to the dir where PHP was started        // on Gnu/Linux, PHP builds with --enable-maintainer-zts are also affected        // @see : https://bugs.php.net/51800        // @see : https://bugs.php.net/50524        if (null === $this->cwd && (\defined('ZEND_THREAD_SAFE') || '\\' === \DIRECTORY_SEPARATOR)) {            $this->cwd = getcwd();        }        if (null !== $env) {            $this->setEnv($env);        }        $this->setInput($input);        $this->setTimeout($timeout);        $this->useFileHandles = '\\' === \DIRECTORY_SEPARATOR;        $this->pty = false;    }    /**     * Creates a Process instance as a command-line to be run in a shell wrapper.     *     * Command-lines are parsed by the shell of your OS (/bin/sh on Unix-like, cmd.exe on Windows.)     * This allows using e.g. pipes or conditional execution. In this mode, signals are sent to the     * shell wrapper and not to your commands.     *     * In order to inject dynamic values into command-lines, we strongly recommend using placeholders.     * This will save escaping values, which is not portable nor secure anyway:     *     *   $process = Process::fromShellCommandline('my_command ""$MY_VAR""');     *   $process->run(null, ['MY_VAR' => $theValue]);     *     * @param string         $command The command line to pass to the shell of the OS     * @param string|null    $cwd     The working directory or null to use the working dir of the current PHP process     * @param array|null     $env     The environment variables or null to use the same environment as the current PHP process     * @param mixed          $input   The input as stream resource, scalar or \Traversable, or null for no input     * @param int|float|null $timeout The timeout in seconds or null to disable     *     * @return static     *     * @throws LogicException When proc_open is not installed     */    public static function fromShellCommandline(string $command, string $cwd = null, array $env = null, $input = null, ?float $timeout = 60)    {        $process = new static([], $cwd, $env, $input, $timeout);        $process->commandline = $command;        return $process;    }    public function __sleep()    {        throw new \BadMethodCallException('Cannot serialize '.__CLASS__);    }    public function __wakeup()    {        throw new \BadMethodCallException('Cannot unserialize '.__CLASS__);    }    public function __destruct()    {        if ($this->options['create_new_console'] ?? false) {            $this->processPipes->close();        } else {            $this->stop(0);        }    }    public function __clone()    {        $this->resetProcessData();    }    /**     * Runs the process.     *     * The callback receives the type of output (out or err) and     * some bytes from the output in real-time. It allows to have feedback     * from the independent process during execution.     *     * The STDOUT and STDERR are also available after the process is finished     * via the getOutput() and getErrorOutput() methods.     *     * @param callable|null $callback A PHP callback to run whenever there is some     *                                output available on STDOUT or STDERR     *     * @return int The exit status code     *     * @throws RuntimeException         When process can't be launched     * @throws RuntimeException         When process is already running     * @throws ProcessTimedOutException When process timed out     * @throws ProcessSignaledException When process stopped after receiving signal     * @throws LogicException           In case a callback is provided and output has been disabled     *     * @final     */    public function run(callable $callback = null, array $env = []): int    {        $this->start($callback, $env);        return $this->wait();    }    /**     * Runs the process.     *     * This is identical to run() except that an exception is thrown if the process     * exits with a non-zero exit code.     *     * @return $this     *     * @throws ProcessFailedException if the process didn't terminate successfully     *     * @final     */    public function mustRun(callable $callback = null, array $env = []): self    {        if (0 !== $this->run($callback, $env)) {            throw new ProcessFailedException($this);        }        return $this;    }    /**     * Starts the process and returns after writing the input to STDIN.     *     * This method blocks until all STDIN data is sent to the process then it     * returns while the process runs in the background.     *     * The termination of the process can be awaited with wait().     *     * The callback receives the type of output (out or err) and some bytes from     * the output in real-time while writing the standard input to the process.     * It allows to have feedback from the independent process during execution.     *     * @param callable|null $callback A PHP callback to run whenever there is some     *                                output available on STDOUT or STDERR     *     * @throws RuntimeException When process can't be launched     * @throws RuntimeException When process is already running     * @throws LogicException   In case a callback is provided and output has been disabled     */    public function start(callable $callback = null, array $env = [])    {        if ($this->isRunning()) {            throw new RuntimeException('Process is already running.');        }        $this->resetProcessData();        $this->starttime = $this->lastOutputTime = microtime(true);        $this->callback = $this->buildCallback($callback);        $this->hasCallback = null !== $callback;        $descriptors = $this->getDescriptors();        if ($this->env) {            $env += $this->env;        }        $env += $this->getDefaultEnv();        if (\is_array($commandline = $this->commandline)) {            $commandline = implode(' ', array_map([$this, 'escapeArgument'], $commandline));            if ('\\' !== \DIRECTORY_SEPARATOR) {                // exec is mandatory to deal with sending a signal to the process                $commandline = 'exec '.$commandline;            }        } else {            $commandline = $this->replacePlaceholders($commandline, $env);        }        if ('\\' === \DIRECTORY_SEPARATOR) {            $commandline = $this->prepareWindowsCommandLine($commandline, $env);        } elseif (!$this->useFileHandles && $this->isSigchildEnabled()) {            // last exit code is output on the fourth pipe and caught to work around --enable-sigchild            $descriptors[3] = ['pipe', 'w'];            // See https://unix.stackexchange.com/questions/71205/background-process-pipe-input            $commandline = '{ ('.$commandline.') <&3 3<&- 3>/dev/null & } 3<&0;';            $commandline .= 'pid=$!; echo $pid >&3; wait $pid; code=$?; echo $code >&3; exit $code';            // Workaround for the bug, when PTS functionality is enabled.            // @see : https://bugs.php.net/69442            $ptsWorkaround = fopen(__FILE__, 'r');        }        $envPairs = [];        foreach ($env as $k => $v) {            if (false !== $v) {                $envPairs[] = $k.'='.$v;            }        }        if (!is_dir($this->cwd)) {            throw new RuntimeException(sprintf('The provided cwd ""%s"" does not exist.', $this->cwd));        }        $this->process = @proc_open($commandline, $descriptors, $this->processPipes->pipes, $this->cwd, $envPairs, $this->options);        if (!\is_resource($this->process)) {            throw new RuntimeException('Unable to launch a new process.');        }        $this->status = self::STATUS_STARTED;        if (isset($descriptors[3])) {            $this->fallbackStatus['pid'] = (int) fgets($this->processPipes->pipes[3]);        }        if ($this->tty) {            return;        }        $this->updateStatus(false);        $this->checkTimeout();    }    /**     * Restarts the process.     *     * Be warned that the process is cloned before being started.     *     * @param callable|null $callback A PHP callback to run whenever there is some     *                                output available on STDOUT or STDERR     *     * @return static     *     * @throws RuntimeException When process can't be launched     * @throws RuntimeException When process is already running     *     * @see start()     *     * @final     */    public function restart(callable $callback = null, array $env = []): self    {        if ($this->isRunning()) {            throw new RuntimeException('Process is already running.');        }        $process = clone $this;        $process->start($callback, $env);        return $process;    }    /**     * Waits for the process to terminate.     *     * The callback receives the type of output (out or err) and some bytes     * from the output in real-time while writing the standard input to the process.     * It allows to have feedback from the independent process during execution.     *     * @param callable|null $callback A valid PHP callback     *     * @return int The exitcode of the process     *     * @throws ProcessTimedOutException When process timed out     * @throws ProcessSignaledException When process stopped after receiving signal     * @throws LogicException           When process is not yet started     */    public function wait(callable $callback = null)    {        $this->requireProcessIsStarted(__FUNCTION__);        $this->updateStatus(false);        if (null !== $callback) {            if (!$this->processPipes->haveReadSupport()) {                $this->stop(0);                throw new LogicException('Pass the callback to the ""Process::start"" method or call enableOutput to use a callback with ""Process::wait"".');            }            $this->callback = $this->buildCallback($callback);        }        do {            $this->checkTimeout();            $running = '\\' === \DIRECTORY_SEPARATOR ? $this->isRunning() : $this->processPipes->areOpen();            $this->readPipes($running, '\\' !== \DIRECTORY_SEPARATOR || !$running);        } while ($running);        while ($this->isRunning()) {            $this->checkTimeout();            usleep(1000);        }        if ($this->processInformation['signaled'] && $this->processInformation['termsig'] !== $this->latestSignal) {            throw new ProcessSignaledException($this);        }        return $this->exitcode;    }    /**     * Waits until the callback returns true.     *     * The callback receives the type of output (out or err) and some bytes     * from the output in real-time while writing the standard input to the process.     * It allows to have feedback from the independent process during execution.     *     * @throws RuntimeException         When process timed out     * @throws LogicException           When process is not yet started     * @throws ProcessTimedOutException In case the timeout was reached     */    public function waitUntil(callable $callback): bool    {        $this->requireProcessIsStarted(__FUNCTION__);        $this->updateStatus(false);        if (!$this->processPipes->haveReadSupport()) {            $this->stop(0);            throw new LogicException('Pass the callback to the ""Process::start"" method or call enableOutput to use a callback with ""Process::waitUntil"".');        }        $callback = $this->buildCallback($callback);        $ready = false;        while (true) {            $this->checkTimeout();            $running = '\\' === \DIRECTORY_SEPARATOR ? $this->isRunning() : $this->processPipes->areOpen();            $output = $this->processPipes->readAndWrite($running, '\\' !== \DIRECTORY_SEPARATOR || !$running);            foreach ($output as $type => $data) {                if (3 !== $type) {                    $ready = $callback(self::STDOUT === $type ? self::OUT : self::ERR, $data) || $ready;                } elseif (!isset($this->fallbackStatus['signaled'])) {                    $this->fallbackStatus['exitcode'] = (int) $data;                }            }            if ($ready) {                return true;            }            if (!$running) {                return false;            }            usleep(1000);        }    }    /**     * Returns the Pid (process identifier), if applicable.     *     * @return int|null The process id if running, null otherwise     */    public function getPid()    {        return $this->isRunning() ? $this->processInformation['pid'] : null;    }    /**     * Sends a POSIX signal to the process.     *     * @param int $signal A valid POSIX signal (see https://php.net/pcntl.constants)     *     * @return $this     *     * @throws LogicException   In case the process is not running     * @throws RuntimeException In case --enable-sigchild is activated and the process can't be killed     * @throws RuntimeException In case of failure     */    public function signal(int $signal)    {        $this->doSignal($signal, true);        return $this;    }    /**     * Disables fetching output and error output from the underlying process.     *     * @return $this     *     * @throws RuntimeException In case the process is already running     * @throws LogicException   if an idle timeout is set     */    public function disableOutput()    {        if ($this->isRunning()) {            throw new RuntimeException('Disabling output while the process is running is not possible.');        }        if (null !== $this->idleTimeout) {            throw new LogicException('Output can not be disabled while an idle timeout is set.');        }        $this->outputDisabled = true;        return $this;    }    /**     * Enables fetching output and error output from the underlying process.     *     * @return $this     *     * @throws RuntimeException In case the process is already running     */    public function enableOutput()    {        if ($this->isRunning()) {            throw new RuntimeException('Enabling output while the process is running is not possible.');        }        $this->outputDisabled = false;        return $this;    }    /**     * Returns true in case the output is disabled, false otherwise.     *     * @return bool     */    public function isOutputDisabled()    {        return $this->outputDisabled;    }    /**     * Returns the current output of the process (STDOUT).     *     * @return string The process output     *     * @throws LogicException in case the output has been disabled     * @throws LogicException In case the process is not started     */    public function getOutput()    {        $this->readPipesForOutput(__FUNCTION__);        if (false === $ret = stream_get_contents($this->stdout, -1, 0)) {            return '';        }        return $ret;    }    /**     * Returns the output incrementally.     *     * In comparison with the getOutput method which always return the whole     * output, this one returns the new output since the last call.     *     * @return string The process output since the last call     *     * @throws LogicException in case the output has been disabled     * @throws LogicException In case the process is not started     */    public function getIncrementalOutput()    {        $this->readPipesForOutput(__FUNCTION__);        $latest = stream_get_contents($this->stdout, -1, $this->incrementalOutputOffset);        $this->incrementalOutputOffset = ftell($this->stdout);        if (false === $latest) {            return '';        }        return $latest;    }    /**     * Returns an iterator to the output of the process, with the output type as keys (Process::OUT/ERR).     *     * @param int $flags A bit field of Process::ITER_* flags     *     * @throws LogicException in case the output has been disabled     * @throws LogicException In case the process is not started     *     * @return \Generator     */    public function getIterator(int $flags = 0)    {        $this->readPipesForOutput(__FUNCTION__, false);        $clearOutput = !(self::ITER_KEEP_OUTPUT & $flags);        $blocking = !(self::ITER_NON_BLOCKING & $flags);        $yieldOut = !(self::ITER_SKIP_OUT & $flags);        $yieldErr = !(self::ITER_SKIP_ERR & $flags);        while (null !== $this->callback || ($yieldOut && !feof($this->stdout)) || ($yieldErr && !feof($this->stderr))) {            if ($yieldOut) {                $out = stream_get_contents($this->stdout, -1, $this->incrementalOutputOffset);                if (isset($out[0])) {                    if ($clearOutput) {                        $this->clearOutput();                    } else {                        $this->incrementalOutputOffset = ftell($this->stdout);                    }                    yield self::OUT => $out;                }            }            if ($yieldErr) {                $err = stream_get_contents($this->stderr, -1, $this->incrementalErrorOutputOffset);                if (isset($err[0])) {                    if ($clearOutput) {                        $this->clearErrorOutput();                    } else {                        $this->incrementalErrorOutputOffset = ftell($this->stderr);                    }                    yield self::ERR => $err;                }            }            if (!$blocking && !isset($out[0]) && !isset($err[0])) {                yield self::OUT => '';            }            $this->checkTimeout();            $this->readPipesForOutput(__FUNCTION__, $blocking);        }    }    /**     * Clears the process output.     *     * @return $this     */    public function clearOutput()    {        ftruncate($this->stdout, 0);        fseek($this->stdout, 0);        $this->incrementalOutputOffset = 0;        return $this;    }    /**     * Returns the current error output of the process (STDERR).     *     * @return string The process error output     *     * @throws LogicException in case the output has been disabled     * @throws LogicException In case the process is not started     */    public function getErrorOutput()    {        $this->readPipesForOutput(__FUNCTION__);        if (false === $ret = stream_get_contents($this->stderr, -1, 0)) {            return '';        }        return $ret;    }    /**     * Returns the errorOutput incrementally.     *     * In comparison with the getErrorOutput method which always return the     * whole error output, this one returns the new error output since the last     * call.     *     * @return string The process error output since the last call     *     * @throws LogicException in case the output has been disabled     * @throws LogicException In case the process is not started     */    public function getIncrementalErrorOutput()    {        $this->readPipesForOutput(__FUNCTION__);        $latest = stream_get_contents($this->stderr, -1, $this->incrementalErrorOutputOffset);        $this->incrementalErrorOutputOffset = ftell($this->stderr);        if (false === $latest) {            return '';        }        return $latest;    }    /**     * Clears the process output.     *     * @return $this     */    public function clearErrorOutput()    {        ftruncate($this->stderr, 0);        fseek($this->stderr, 0);        $this->incrementalErrorOutputOffset = 0;        return $this;    }    /**     * Returns the exit code returned by the process.     *     * @return int|null The exit status code, null if the Process is not terminated     */    public function getExitCode()    {        $this->updateStatus(false);        return $this->exitcode;    }    /**     * Returns a string representation for the exit code returned by the process.     *     * This method relies on the Unix exit code status standardization     * and might not be relevant for other operating systems.     *     * @return string|null A string representation for the exit status code, null if the Process is not terminated     *     * @see http://tldp.org/LDP/abs/html/exitcodes.html     * @see http://en.wikipedia.org/wiki/Unix_signal     */    public function getExitCodeText()    {        if (null === $exitcode = $this->getExitCode()) {            return null;        }        return self::$exitCodes[$exitcode] ?? 'Unknown error';    }    /**     * Checks if the process ended successfully.     *     * @return bool true if the process ended successfully, false otherwise     */    public function isSuccessful()    {        return 0 === $this->getExitCode();    }    /**     * Returns true if the child process has been terminated by an uncaught signal.     *     * It always returns false on Windows.     *     * @return bool     *     * @throws LogicException In case the process is not terminated     */    public function hasBeenSignaled()    {        $this->requireProcessIsTerminated(__FUNCTION__);        return $this->processInformation['signaled'];    }    /**     * Returns the number of the signal that caused the child process to terminate its execution.     *     * It is only meaningful if hasBeenSignaled() returns true.     *     * @return int     *     * @throws RuntimeException In case --enable-sigchild is activated     * @throws LogicException   In case the process is not terminated     */    public function getTermSignal()    {        $this->requireProcessIsTerminated(__FUNCTION__);        if ($this->isSigchildEnabled() && -1 === $this->processInformation['termsig']) {            throw new RuntimeException('This PHP has been compiled with --enable-sigchild. Term signal can not be retrieved.');        }        return $this->processInformation['termsig'];    }    /**     * Returns true if the child process has been stopped by a signal.     *     * It always returns false on Windows.     *     * @return bool     *     * @throws LogicException In case the process is not terminated     */    public function hasBeenStopped()    {        $this->requireProcessIsTerminated(__FUNCTION__);        return $this->processInformation['stopped'];    }    /**     * Returns the number of the signal that caused the child process to stop its execution.     *     * It is only meaningful if hasBeenStopped() returns true.     *     * @return int     *     * @throws LogicException In case the process is not terminated     */    public function getStopSignal()    {        $this->requireProcessIsTerminated(__FUNCTION__);        return $this->processInformation['stopsig'];    }    /**     * Checks if the process is currently running.     *     * @return bool true if the process is currently running, false otherwise     */    public function isRunning()    {        if (self::STATUS_STARTED !== $this->status) {            return false;        }        $this->updateStatus(false);        return $this->processInformation['running'];    }    /**     * Checks if the process has been started with no regard to the current state.     *     * @return bool true if status is ready, false otherwise     */    public function isStarted()    {        return self::STATUS_READY != $this->status;    }    /**     * Checks if the process is terminated.     *     * @return bool true if process is terminated, false otherwise     */    public function isTerminated()    {        $this->updateStatus(false);        return self::STATUS_TERMINATED == $this->status;    }    /**     * Gets the process status.     *     * The status is one of: ready, started, terminated.     *     * @return string The current process status     */    public function getStatus()    {        $this->updateStatus(false);        return $this->status;    }    /**     * Stops the process.     *     * @param int|float $timeout The timeout in seconds     * @param int       $signal  A POSIX signal to send in case the process has not stop at timeout, default is SIGKILL (9)     *     * @return int|null The exit-code of the process or null if it's not running     */    public function stop(float $timeout = 10, int $signal = null)    {        $timeoutMicro = microtime(true) + $timeout;        if ($this->isRunning()) {            // given SIGTERM may not be defined and that ""proc_terminate"" uses the constant value and not the constant itself, we use the same here            $this->doSignal(15, false);            do {                usleep(1000);            } while ($this->isRunning() && microtime(true) < $timeoutMicro);            if ($this->isRunning()) {                // Avoid exception here: process is supposed to be running, but it might have stopped just                // after this line. In any case, let's silently discard the error, we cannot do anything.                $this->doSignal($signal ?: 9, false);            }        }        if ($this->isRunning()) {            if (isset($this->fallbackStatus['pid'])) {                unset($this->fallbackStatus['pid']);                return $this->stop(0, $signal);            }            $this->close();        }        return $this->exitcode;    }    /**     * Adds a line to the STDOUT stream.     *     * @internal     */    public function addOutput(string $line)    {        $this->lastOutputTime = microtime(true);        fseek($this->stdout, 0, \SEEK_END);        fwrite($this->stdout, $line);        fseek($this->stdout, $this->incrementalOutputOffset);    }    /**     * Adds a line to the STDERR stream.     *     * @internal     */    public function addErrorOutput(string $line)    {        $this->lastOutputTime = microtime(true);        fseek($this->stderr, 0, \SEEK_END);        fwrite($this->stderr, $line);        fseek($this->stderr, $this->incrementalErrorOutputOffset);    }    /**     * Gets the last output time in seconds.     *     * @return float|null The last output time in seconds or null if it isn't started     */    public function getLastOutputTime(): ?float    {        return $this->lastOutputTime;    }    /**     * Gets the command line to be executed.     *     * @return string The command to execute     */    public function getCommandLine()    {        return \is_array($this->commandline) ? implode(' ', array_map([$this, 'escapeArgument'], $this->commandline)) : $this->commandline;    }    /**     * Gets the process timeout (max. runtime).     *     * @return float|null The timeout in seconds or null if it's disabled     */    public function getTimeout()    {        return $this->timeout;    }    /**     * Gets the process idle timeout (max. time since last output).     *     * @return float|null The timeout in seconds or null if it's disabled     */    public function getIdleTimeout()    {        return $this->idleTimeout;    }    /**     * Sets the process timeout (max. runtime) in seconds.     *     * To disable the timeout, set this value to null.     *     * @return $this     *     * @throws InvalidArgumentException if the timeout is negative     */    public function setTimeout(?float $timeout)    {        $this->timeout = $this->validateTimeout($timeout);        return $this;    }    /**     * Sets the process idle timeout (max. time since last output) in seconds.     *     * To disable the timeout, set this value to null.     *     * @return $this     *     * @throws LogicException           if the output is disabled     * @throws InvalidArgumentException if the timeout is negative     */    public function setIdleTimeout(?float $timeout)    {        if (null !== $timeout && $this->outputDisabled) {            throw new LogicException('Idle timeout can not be set while the output is disabled.');        }        $this->idleTimeout = $this->validateTimeout($timeout);        return $this;    }    /**     * Enables or disables the TTY mode.     *     * @return $this     *     * @throws RuntimeException In case the TTY mode is not supported     */    public function setTty(bool $tty)    {        if ('\\' === \DIRECTORY_SEPARATOR && $tty) {            throw new RuntimeException('TTY mode is not supported on Windows platform.');        }        if ($tty && !self::isTtySupported()) {            throw new RuntimeException('TTY mode requires /dev/tty to be read/writable.');        }        $this->tty = $tty;        return $this;    }    /**     * Checks if the TTY mode is enabled.     *     * @return bool true if the TTY mode is enabled, false otherwise     */    public function isTty()    {        return $this->tty;    }    /**     * Sets PTY mode.     *     * @return $this     */    public function setPty(bool $bool)    {        $this->pty = $bool;        return $this;    }    /**     * Returns PTY state.     *     * @return bool     */    public ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
symfony_process_Process_1456, Waits until the callback returns true.\\n\\n The callback receives the type of output (out or err) and some bytes\\n from the output in real-time while writing the standard input to the process.\\n It allows to have feedback from the independent process during execution.\\n\\n @throws RuntimeException         When process timed out\\n @throws LogicException           When process is not yet started\\n @throws ProcessTimedOutException In case the timeout was reached\\n, Waits until the callback returns true.,"    public function waitUntil(callable $callback): bool    {        $this->requireProcessIsStarted(__FUNCTION__);        $this->updateStatus(false);        if (!$this->processPipes->haveReadSupport()) {            $this->stop(0);            throw new LogicException('Pass the callback to the ""Process::start"" method or call enableOutput to use a callback with ""Process::waitUntil"".');        }        $callback = $this->buildCallback($callback);        $ready = false;        while (true) {            $this->checkTimeout();            $running = '\\' === \DIRECTORY_SEPARATOR ? $this->isRunning() : $this->processPipes->areOpen();            $output = $this->processPipes->readAndWrite($running, '\\' !== \DIRECTORY_SEPARATOR || !$running);            foreach ($output as $type => $data) {                if (3 !== $type) {                    $ready = $callback(self::STDOUT === $type ? self::OUT : self::ERR, $data) || $ready;                } elseif (!isset($this->fallbackStatus['signaled'])) {                    $this->fallbackStatus['exitcode'] = (int) $data;                }            }            if ($ready) {                return true;            }            if (!$running) {                return false;            }            usleep(1000);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1457," Returns the Pid (process identifier), if applicable.\\\\n\\\\n @return int|null The process id if running, null otherwise\\\\n"," Returns the Pid (process identifier), if applicable.",    public function getPid()    {        return $this->isRunning() ? $this->processInformation['pid'] : null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1459, Disables fetching output and error output from the underlying process.\\n\\n @return $this\\n\\n @throws RuntimeException In case the process is already running\\n @throws LogicException   if an idle timeout is set\\n, Disables fetching output and error output from the underlying process.,    public function disableOutput()    {        if ($this->isRunning()) {            throw new RuntimeException('Disabling output while the process is running is not possible.');        }        if (null !== $this->idleTimeout) {            throw new LogicException('Output can not be disabled while an idle timeout is set.');        }        $this->outputDisabled = true;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1461," Returns true in case the output is disabled, false otherwise.\n\n @return bool\n"," Returns true in case the output is disabled, false otherwise.",    public function isOutputDisabled()    {        return $this->outputDisabled;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1462, Returns the current output of the process (STDOUT).\n\n @return string The process output\n\n @throws LogicException in case the output has been disabled\n @throws LogicException In case the process is not started\n, Returns the current output of the process (STDOUT).,"    public function getOutput()    {        $this->readPipesForOutput(__FUNCTION__);        if (false === $ret = stream_get_contents($this->stdout, -1, 0)) {            return '';        }        return $ret;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1463," Returns the output incrementally.\\\\n\\\\n In comparison with the getOutput method which always return the whole\\\\n output, this one returns the new output since the last call.\\\\n\\\\n @return string The process output since the last call\\\\n\\\\n @throws LogicException in case the output has been disabled\\\\n @throws LogicException In case the process is not started\\\\n", Returns the output incrementally.,"    public function getIncrementalOutput()    {        $this->readPipesForOutput(__FUNCTION__);        $latest = stream_get_contents($this->stdout, -1, $this->incrementalOutputOffset);        $this->incrementalOutputOffset = ftell($this->stdout);        if (false === $latest) {            return '';        }        return $latest;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1464, Clears the process output.\n\n @return $this\n, Clears the process output.,"    public function clearOutput()    {        ftruncate($this->stdout, 0);        fseek($this->stdout, 0);        $this->incrementalOutputOffset = 0;        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1465, Returns the current error output of the process (STDERR).\n\n @return string The process error output\n\n @throws LogicException in case the output has been disabled\n @throws LogicException In case the process is not started\n, Returns the current error output of the process (STDERR).,"    public function getErrorOutput()    {        $this->readPipesForOutput(__FUNCTION__);        if (false === $ret = stream_get_contents($this->stderr, -1, 0)) {            return '';        }        return $ret;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1468," Returns the exit code returned by the process.\\n\\n @return int|null The exit status code, null if the Process is not terminated\\n", Returns the exit code returned by the process.,    public function getExitCode()    {        $this->updateStatus(false);        return $this->exitcode;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1469," Returns a string representation for the exit code returned by the process.\n\n This method relies on the Unix exit code status standardization\n and might not be relevant for other operating systems.\n\n @return string|null A string representation for the exit status code, null if the Process is not terminated\n\n @see http://tldp.org/LDP/abs/html/exitcodes.html\n @see http://en.wikipedia.org/wiki/Unix_signal\n", Returns a string representation for the exit code returned by the process.,    public function getExitCodeText()    {        if (null === $exitcode = $this->getExitCode()) {            return null;        }        return self::$exitCodes[$exitcode] ?? 'Unknown error';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1471, Returns true if the child process has been terminated by an uncaught signal.\\\\n\\\\n It always returns false on Windows.\\\\n\\\\n @return bool\\\\n\\\\n @throws LogicException In case the process is not terminated\\\\n, Returns true if the child process has been terminated by an uncaught signal.,    public function hasBeenSignaled()    {        $this->requireProcessIsTerminated(__FUNCTION__);        return $this->processInformation['signaled'];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1472, Returns the number of the signal that caused the child process to terminate its execution.\\n\\n It is only meaningful if hasBeenSignaled() returns true.\\n\\n @return int\\n\\n @throws RuntimeException In case --enable-sigchild is activated\\n @throws LogicException   In case the process is not terminated\\n, Returns the number of the signal that caused the child process to terminate its execution.,    public function getTermSignal()    {        $this->requireProcessIsTerminated(__FUNCTION__);        if ($this->isSigchildEnabled() && -1 === $this->processInformation['termsig']) {            throw new RuntimeException('This PHP has been compiled with --enable-sigchild. Term signal can not be retrieved.');        }        return $this->processInformation['termsig'];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1473, Returns true if the child process has been stopped by a signal.\n\n It always returns false on Windows.\n\n @return bool\n\n @throws LogicException In case the process is not terminated\n, Returns true if the child process has been stopped by a signal.,    public function hasBeenStopped()    {        $this->requireProcessIsTerminated(__FUNCTION__);        return $this->processInformation['stopped'];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1474, Returns the number of the signal that caused the child process to stop its execution.\\\\n\\\\n It is only meaningful if hasBeenStopped() returns true.\\\\n\\\\n @return int\\\\n\\\\n @throws LogicException In case the process is not terminated\\\\n, Returns the number of the signal that caused the child process to stop its execution.,    public function getStopSignal()    {        $this->requireProcessIsTerminated(__FUNCTION__);        return $this->processInformation['stopsig'];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1477," Checks if the process is terminated.\\n\\n @return bool true if process is terminated, false otherwise\\n", Checks if the process is terminated.,    public function isTerminated()    {        $this->updateStatus(false);        return self::STATUS_TERMINATED == $this->status;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1478," Gets the process status.\\n\\n The status is one of: ready, started, terminated.\\n\\n @return string The current process status\\n", Gets the process status.,    public function getStatus()    {        $this->updateStatus(false);        return $this->status;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1480, Adds a line to the STDERR stream.\\n\\n @internal\\n, Adds a line to the STDERR stream.,"    public function addErrorOutput(string $line)    {        $this->lastOutputTime = microtime(true);        fseek($this->stderr, 0, \SEEK_END);        fwrite($this->stderr, $line);        fseek($this->stderr, $this->incrementalErrorOutputOffset);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1482, Gets the command line to be executed.\n\n @return string The command to execute\n, Gets the command line to be executed.,"    public function getCommandLine()    {        return \is_array($this->commandline) ? implode(' ', array_map([$this, 'escapeArgument'], $this->commandline)) : $this->commandline;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1491, Gets the working directory.\n\n @return string|null The current working directory or null on failure\n, Gets the working directory.,"    public function getWorkingDirectory()    {        if (null === $this->cwd) {            // getcwd() will return false if any one of the parent directories does not have            // the readable or search mode set, even if the current directory does            return getcwd() ?: null;        }        return $this->cwd;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1492, Sets the current working directory.\\\\n\\\\n @return $this\\\\n, Sets the current working directory.,    public function setWorkingDirectory(string $cwd)    {        $this->cwd = $cwd;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1494," Sets the environment variables.\n\n Each environment variable value should be a string.\n If it is an array, the variable is ignored.\n If it is false or null, it will be removed when\n env vars are otherwise inherited.\n\n That happens in PHP when 'argv' is registered into\n the $_ENV array for instance.\n\n @param array $env The new environment variables\n\n @return $this\n", Sets the environment variables.,"    public function setEnv(array $env)    {        // Process can not handle env values that are arrays        $env = array_filter($env, function ($value) {            return !\is_array($value);        });        $this->env = $env;        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1496, Sets the input.\\\\n\\\\n This content will be passed to the underlying process standard input.\\\\n\\\\n @param string|int|float|bool|resource|\\\\\\\\Traversable|null $input The content\\\\n\\\\n @return $this\\\\n\\\\n @throws LogicException In case the process is running\\\\n, Sets the input.,"    public function setInput($input)    {        if ($this->isRunning()) {            throw new LogicException('Input can not be set while the process is running.');        }        $this->input = ProcessUtils::validateInput(__METHOD__, $input);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1497," Performs a check between the timeout definition and the time the process started.\n\n In case you run a background process (with the start method), you should\n trigger this method regularly to ensure the process timeout\n\n @throws ProcessTimedOutException In case the timeout was reached\n", Performs a check between the timeout definition and the time the process started.,"    public function checkTimeout()    {        if (self::STATUS_STARTED !== $this->status) {            return;        }        if (null !== $this->timeout && $this->timeout < microtime(true) - $this->starttime) {            $this->stop(0);            throw new ProcessTimedOutException($this, ProcessTimedOutException::TYPE_GENERAL);        }        if (null !== $this->idleTimeout && $this->idleTimeout < microtime(true) - $this->lastOutputTime) {            $this->stop(0);            throw new ProcessTimedOutException($this, ProcessTimedOutException::TYPE_IDLE);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1499," Defines options to pass to the underlying proc_open().\n\n @see https://php.net/proc_open for the options supported by PHP.\n\n Enabling the ""create_new_console"" option allows a subprocess to continue\n to run after the main process exited, on both Windows and ", Defines options to pass to the underlying proc_open().,"    public function setOptions(array $options)    {        if ($this->isRunning()) {            throw new RuntimeException('Setting options while the process is running is not possible.');        }        $defaultOptions = $this->options;        $existingOptions = ['blocking_pipes', 'create_process_group', 'create_new_console'];        foreach ($options as $key => $value) {            if (!\in_array($key, $existingOptions)) {                $this->options = $defaultOptions;                throw new LogicException(sprintf('Invalid option ""%s"" passed to ""%s()"". Supported options are ""%s"".', $key, __METHOD__, implode('"", ""', $existingOptions)));            }            $this->options[$key] = $value;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1500, Returns whether TTY is supported on the current operating system.\n, Returns whether TTY is supported on the current operating system.,"    public static function isTtySupported(): bool    {        static $isTtySupported;        if (null === $isTtySupported) {            $isTtySupported = (bool) @proc_open('echo 1 >/dev/null', [['file', '/dev/tty', 'r'], ['file', '/dev/tty', 'w'], ['file', '/dev/tty', 'w']], $pipes);        }        return $isTtySupported;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1501, Returns whether PTY is supported on the current operating system.\\n\\n @return bool\\n, Returns whether PTY is supported on the current operating system.,"    public static function isPtySupported()    {        static $result;        if (null !== $result) {            return $result;        }        if ('\\' === \DIRECTORY_SEPARATOR) {            return $result = false;        }        return $result = (bool) @proc_open('echo 1 >/dev/null', [['pty'], ['pty'], ['pty']], $pipes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1503," Updates the status of the process, reads pipes.\\\\n\\\\n @param bool $blocking Whether to use a blocking read call\\\\n"," Updates the status of the process, reads pipes.","    protected function updateStatus(bool $blocking)    {        if (self::STATUS_STARTED !== $this->status) {            return;        }        $this->processInformation = proc_get_status($this->process);        $running = $this->processInformation['running'];        $this->readPipes($running && $blocking, '\\' !== \DIRECTORY_SEPARATOR || !$running);        if ($this->fallbackStatus && $this->isSigchildEnabled()) {            $this->processInformation = $this->fallbackStatus + $this->processInformation;        }        if (!$running) {            $this->close();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1504, Returns whether PHP has been compiled with the '--enable-sigchild' option or not.\\n\\n @return bool\\n, Returns whether PHP has been compiled with the '--enable-sigchild' option or not.,"    protected function isSigchildEnabled()    {        if (null !== self::$sigchild) {            return self::$sigchild;        }        if (!\function_exists('phpinfo')) {            return self::$sigchild = false;        }        ob_start();        phpinfo(\INFO_GENERAL);        return self::$sigchild = false !== strpos(ob_get_clean(), '--enable-sigchild');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1505, Validates and returns the filtered timeout.\\n\\n @throws InvalidArgumentException if the given timeout is a negative number\\n, Validates and returns the filtered timeout.,    private function validateTimeout(?float $timeout): ?float    {        $timeout = (float) $timeout;        if (0.0 === $timeout) {            $timeout = null;        } elseif ($timeout < 0) {            throw new InvalidArgumentException('The timeout value must be a valid positive integer or float number.');        }        return $timeout;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1507," Closes process resource, closes file handles, sets the exitcode.\n\n @return int The exitcode\n"," Closes process resource, closes file handles, sets the exitcode.","    private function close(): int    {        $this->processPipes->close();        if (\is_resource($this->process)) {            proc_close($this->process);        }        $this->exitcode = $this->processInformation['exitcode'];        $this->status = self::STATUS_TERMINATED;        if (-1 === $this->exitcode) {            if ($this->processInformation['signaled'] && 0 < $this->processInformation['termsig']) {                // if process has been signaled, no exitcode but a valid termsig, apply Unix convention                $this->exitcode = 128 + $this->processInformation['termsig'];            } elseif ($this->isSigchildEnabled()) {                $this->processInformation['signaled'] = true;                $this->processInformation['termsig'] = -1;            }        }        // Free memory from self-reference callback created by buildCallback        // Doing so in other contexts like __destruct or by garbage collector is ineffective        // Now pipes are closed, so the callback is no longer necessary        $this->callback = null;        return $this->exitcode;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1510," Ensures the process is running or terminated, throws a LogicException if the process has a not started.\\n\\n @throws LogicException if the process has not run\\n"," Ensures the process is running or terminated, throws a LogicException if the process has a not started.","    private function requireProcessIsStarted(string $functionName)    {        if (!$this->isStarted()) {            throw new LogicException(sprintf('Process must be started before calling ""%s()"".', $functionName));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1511," Ensures the process is terminated, throws a LogicException if the process has a status different than ""terminated"".\n\n @throws LogicException if the process is not yet terminated\n"," Ensures the process is terminated, throws a LogicException if the process has a status different than ""terminated"".","    private function requireProcessIsTerminated(string $functionName)    {        if (!$this->isTerminated()) {            throw new LogicException(sprintf('Process must be terminated before calling ""%s()"".', $functionName));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_UnixPipes_1534, UnixPipes implementation uses unix pipes as handles.\\n\\n @author Romain Neutron <imprec@gmail.com>\\n\\n @internal\\n, UnixPipes implementation uses unix pipes as handles.,"class UnixPipes extends AbstractPipes{    private $ttyMode;    private $ptyMode;    private $haveReadSupport;    public function __construct(?bool $ttyMode, bool $ptyMode, $input, bool $haveReadSupport)    {        $this->ttyMode = $ttyMode;        $this->ptyMode = $ptyMode;        $this->haveReadSupport = $haveReadSupport;        parent::__construct($input);    }    public function __sleep()    {        throw new \BadMethodCallException('Cannot serialize '.__CLASS__);    }    public function __wakeup()    {        throw new \BadMethodCallException('Cannot unserialize '.__CLASS__);    }    public function __destruct()    {        $this->close();    }    /**     * {@inheritdoc}     */    public function getDescriptors(): array    {        if (!$this->haveReadSupport) {            $nullstream = fopen('/dev/null', 'c');            return [                ['pipe', 'r'],                $nullstream,                $nullstream,            ];        }        if ($this->ttyMode) {            return [                ['file', '/dev/tty', 'r'],                ['file', '/dev/tty', 'w'],                ['file', '/dev/tty', 'w'],            ];        }        if ($this->ptyMode && Process::isPtySupported()) {            return [                ['pty'],                ['pty'],                ['pty'],            ];        }        return [            ['pipe', 'r'],            ['pipe', 'w'], // stdout            ['pipe', 'w'], // stderr        ];    }    /**     * {@inheritdoc}     */    public function getFiles(): array    {        return [];    }    /**     * {@inheritdoc}     */    public function readAndWrite(bool $blocking, bool $close = false): array    {        $this->unblock();        $w = $this->write();        $read = $e = [];        $r = $this->pipes;        unset($r[0]);        // let's have a look if something changed in streams        set_error_handler([$this, 'handleError']);        if (($r || $w) && false === stream_select($r, $w, $e, 0, $blocking ? Process::TIMEOUT_PRECISION * 1E6 : 0)) {            restore_error_handler();            // if a system call has been interrupted, forget about it, let's try again            // otherwise, an error occurred, let's reset pipes            if (!$this->hasSystemCallBeenInterrupted()) {                $this->pipes = [];            }            return $read;        }        restore_error_handler();        foreach ($r as $pipe) {            // prior PHP 5.4 the array passed to stream_select is modified and            // lose key association, we have to find back the key            $read[$type = array_search($pipe, $this->pipes, true)] = '';            do {                $data = @fread($pipe, self::CHUNK_SIZE);                $read[$type] .= $data;            } while (isset($data[0]) && ($close || isset($data[self::CHUNK_SIZE - 1])));            if (!isset($read[$type][0])) {                unset($read[$type]);            }            if ($close && feof($pipe)) {                fclose($pipe);                unset($this->pipes[$type]);            }        }        return $read;    }    /**     * {@inheritdoc}     */    public function haveReadSupport(): bool    {        return $this->haveReadSupport;    }    /**     * {@inheritdoc}     */    public function areOpen(): bool    {        return (bool) $this->pipes;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_WindowsPipes_1539, WindowsPipes implementation uses temporary files as handles.\\\\n\\\\n @see https://bugs.php.net/51800\\\\n @see https://bugs.php.net/65650\\\\n\\\\n @author Romain Neutron <imprec@gmail.com>\\\\n\\\\n @internal\\\\n, WindowsPipes implementation uses temporary files as handles.,"class WindowsPipes extends AbstractPipes{    private $files = [];    private $fileHandles = [];    private $lockHandles = [];    private $readBytes = [        Process::STDOUT => 0,        Process::STDERR => 0,    ];    private $haveReadSupport;    public function __construct($input, bool $haveReadSupport)    {        $this->haveReadSupport = $haveReadSupport;        if ($this->haveReadSupport) {            // Fix for PHP bug #51800: reading from STDOUT pipe hangs forever on Windows if the output is too big.            // Workaround for this problem is to use temporary files instead of pipes on Windows platform.            //            // @see https://bugs.php.net/51800            $pipes = [                Process::STDOUT => Process::OUT,                Process::STDERR => Process::ERR,            ];            $tmpDir = sys_get_temp_dir();            $lastError = 'unknown reason';            set_error_handler(function ($type, $msg) use (&$lastError) { $lastError = $msg; });            for ($i = 0;; ++$i) {                foreach ($pipes as $pipe => $name) {                    $file = sprintf('%s\\sf_proc_%02X.%s', $tmpDir, $i, $name);                    if (!$h = fopen($file.'.lock', 'w')) {                        if (file_exists($file.'.lock')) {                            continue 2;                        }                        restore_error_handler();                        throw new RuntimeException('A temporary file could not be opened to write the process output: '.$lastError);                    }                    if (!flock($h, \LOCK_EX | \LOCK_NB)) {                        continue 2;                    }                    if (isset($this->lockHandles[$pipe])) {                        flock($this->lockHandles[$pipe], \LOCK_UN);                        fclose($this->lockHandles[$pipe]);                    }                    $this->lockHandles[$pipe] = $h;                    if (!($h = fopen($file, 'w')) || !fclose($h) || !$h = fopen($file, 'r')) {                        flock($this->lockHandles[$pipe], \LOCK_UN);                        fclose($this->lockHandles[$pipe]);                        unset($this->lockHandles[$pipe]);                        continue 2;                    }                    $this->fileHandles[$pipe] = $h;                    $this->files[$pipe] = $file;                }                break;            }            restore_error_handler();        }        parent::__construct($input);    }    public function __sleep()    {        throw new \BadMethodCallException('Cannot serialize '.__CLASS__);    }    public function __wakeup()    {        throw new \BadMethodCallException('Cannot unserialize '.__CLASS__);    }    public function __destruct()    {        $this->close();    }    /**     * {@inheritdoc}     */    public function getDescriptors(): array    {        if (!$this->haveReadSupport) {            $nullstream = fopen('NUL', 'c');            return [                ['pipe', 'r'],                $nullstream,                $nullstream,            ];        }        // We're not using pipe on Windows platform as it hangs (https://bugs.php.net/51800)        // We're not using file handles as it can produce corrupted output https://bugs.php.net/65650        // So we redirect output within the commandline and pass the nul device to the process        return [            ['pipe', 'r'],            ['file', 'NUL', 'w'],            ['file', 'NUL', 'w'],        ];    }    /**     * {@inheritdoc}     */    public function getFiles(): array    {        return $this->files;    }    /**     * {@inheritdoc}     */    public function readAndWrite(bool $blocking, bool $close = false): array    {        $this->unblock();        $w = $this->write();        $read = $r = $e = [];        if ($blocking) {            if ($w) {                @stream_select($r, $w, $e, 0, Process::TIMEOUT_PRECISION * 1E6);            } elseif ($this->fileHandles) {                usleep(Process::TIMEOUT_PRECISION * 1E6);            }        }        foreach ($this->fileHandles as $type => $fileHandle) {            $data = stream_get_contents($fileHandle, -1, $this->readBytes[$type]);            if (isset($data[0])) {                $this->readBytes[$type] += \strlen($data);                $read[$type] = $data;            }            if ($close) {                ftruncate($fileHandle, 0);                fclose($fileHandle);                flock($this->lockHandles[$type], \LOCK_UN);                fclose($this->lockHandles[$type]);                unset($this->fileHandles[$type], $this->lockHandles[$type]);            }        }        return $read;    }    /**     * {@inheritdoc}     */    public function haveReadSupport(): bool    {        return $this->haveReadSupport;    }    /**     * {@inheritdoc}     */    public function areOpen(): bool    {        return $this->pipes && $this->fileHandles;    }    /**     * {@inheritdoc}     */    public function close()    {        parent::close();        foreach ($this->fileHandles as $type => $handle) {            ftruncate($handle, 0);            fclose($handle);            flock($this->lockHandles[$type], \LOCK_UN);            fclose($this->lockHandles[$type]);        }        $this->fileHandles = $this->lockHandles = [];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_AbstractDoctrineExtension_1828, Register the mapping driver configuration for later use with the object managers metadata driver chain.\n\n @throws \\InvalidArgumentException\n, Register the mapping driver configuration for later use with the object managers metadata driver chain.,"    protected function setMappingDriverConfig(array $mappingConfig, string $mappingName)    {        $mappingDirectory = $mappingConfig['dir'];        if (!is_dir($mappingDirectory)) {            throw new \InvalidArgumentException(sprintf('Invalid Doctrine mapping path given. Cannot load Doctrine mapping/bundle named ""%s"".', $mappingName));        }        $this->drivers[$mappingConfig['type']][$mappingConfig['prefix']] = realpath($mappingDirectory) ?: $mappingDirectory;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_AbstractDoctrineExtension_1831, Assertion if the specified mapping information is valid.\\n\\n @throws \\\\InvalidArgumentException\\n, Assertion if the specified mapping information is valid.,"    protected function assertValidMappingConfiguration(array $mappingConfig, string $objectManagerName)    {        if (!$mappingConfig['type'] || !$mappingConfig['dir'] || !$mappingConfig['prefix']) {            throw new \InvalidArgumentException(sprintf('Mapping definitions for Doctrine manager ""%s"" require at least the ""type"", ""dir"" and ""prefix"" options.', $objectManagerName));        }        if (!is_dir($mappingConfig['dir'])) {            throw new \InvalidArgumentException(sprintf('Specified non-existing directory ""%s"" as Doctrine mapping source.', $mappingConfig['dir']));        }        if (!\in_array($mappingConfig['type'], ['xml', 'yml', 'annotation', 'php', 'staticphp', 'attribute'])) {            throw new \InvalidArgumentException(sprintf('Can only configure ""xml"", ""yml"", ""annotation"", ""php"", ""staticphp"" or ""attribute"" through the DoctrineBundle. Use your own bundle to configure other metadata drivers. You can register them by adding a new driver to the ""%s"" service definition.', $this->getObjectManagerElementName($objectManagerName.'_metadata_driver')));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_AbstractDoctrineExtension_1832," Detects what metadata driver to use for the supplied directory.\\n\\n @return string|null A metadata driver short name, if one can be detected\\n", Detects what metadata driver to use for the supplied directory.,"    protected function detectMetadataDriver(string $dir, ContainerBuilder $container)    {        $configPath = $this->getMappingResourceConfigDirectory();        $extension = $this->getMappingResourceExtension();        if (glob($dir.'/'.$configPath.'/*.'.$extension.'.xml', \GLOB_NOSORT)) {            $driver = 'xml';        } elseif (glob($dir.'/'.$configPath.'/*.'.$extension.'.yml', \GLOB_NOSORT)) {            $driver = 'yml';        } elseif (glob($dir.'/'.$configPath.'/*.'.$extension.'.php', \GLOB_NOSORT)) {            $driver = 'php';        } else {            // add the closest existing directory as a resource            $resource = $dir.'/'.$configPath;            while (!is_dir($resource)) {                $resource = \dirname($resource);            }            $container->fileExists($resource, false);            return $container->fileExists($dir.'/'.$this->getMappingObjectDefaultName(), false) ? 'annotation' : null;        }        $container->fileExists($dir.'/'.$configPath, false);        return $driver;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_AbstractDoctrineExtension_1841, Search for a manager that is declared as 'auto_mapping' = true.\\n\\n @throws \\\\LogicException\\n, Search for a manager that is declared as 'auto_mapping' = true.,"    private function validateAutoMapping(array $managerConfigs): ?string    {        $autoMappedManager = null;        foreach ($managerConfigs as $name => $manager) {            if (!$manager['auto_mapping']) {                continue;            }            if (null !== $autoMappedManager) {                throw new \LogicException(sprintf('You cannot enable ""auto_mapping"" on more than one manager at the same time (found in ""%s"" and ""%s"""").', $autoMappedManager, $name));            }            $autoMappedManager = $name;        }        return $autoMappedManager;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_ContainerAwareLoader_1823," Doctrine data fixtures loader that injects the service container into\n fixture objects that implement ContainerAwareInterface.\n\n Note: Use of this class requires the Doctrine data fixtures extension, which\n is a suggested dependency for Symfony.\n", Doctrine data fixtures loader that injects the service container into,class ContainerAwareLoader extends Loader{    private $container;    public function __construct(ContainerInterface $container)    {        $this->container = $container;    }    /**     * {@inheritdoc}     */    public function addFixture(FixtureInterface $fixture)    {        if ($fixture instanceof ContainerAwareInterface) {            $fixture->setContainer($this->container);        }        parent::addFixture($fixture);    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_DoctrineDataCollector_1816, DoctrineDataCollector.\n\n @author Fabien Potencier <fabien@symfony.com>\n, DoctrineDataCollector.,"class DoctrineDataCollector extends DataCollector{    private $registry;    private $connections;    private $managers;    /**     * @var DebugStack[]     */    private $loggers = [];    public function __construct(ManagerRegistry $registry)    {        $this->registry = $registry;        $this->connections = $registry->getConnectionNames();        $this->managers = $registry->getManagerNames();    }    /**     * Adds the stack logger for a connection.     */    public function addLogger(string $name, DebugStack $logger)    {        $this->loggers[$name] = $logger;    }    /**     * {@inheritdoc}     */    public function collect(Request $request, Response $response, \Throwable $exception = null)    {        $queries = [];        foreach ($this->loggers as $name => $logger) {            $queries[$name] = $this->sanitizeQueries($name, $logger->queries);        }        $this->data = [            'queries' => $queries,            'connections' => $this->connections,            'managers' => $this->managers,        ];    }    public function reset()    {        $this->data = [];        foreach ($this->loggers as $logger) {            $logger->queries = [];            $logger->currentQuery = 0;        }    }    public function getManagers()    {        return $this->data['managers'];    }    public function getConnections()    {        return $this->data['connections'];    }    public function getQueryCount()    {        return array_sum(array_map('count', $this->data['queries']));    }    public function getQueries()    {        return $this->data['queries'];    }    public function getTime()    {        $time = 0;        foreach ($this->data['queries'] as $queries) {            foreach ($queries as $query) {                $time += $query['executionMS'];            }        }        return $time;    }    /**     * {@inheritdoc}     */    public function getName()    {        return 'db';    }    /**     * {@inheritdoc}     */    protected function getCasters()    {        return parent::getCasters() + [            ObjectParameter::class => static function (ObjectParameter $o, array $a, Stub $s): array {                $s->class = $o->getClass();                $s->value = $o->getObject();                $r = new \ReflectionClass($o->getClass());                if ($f = $r->getFileName()) {                    $s->attr['file'] = $f;                    $s->attr['line'] = $r->getStartLine();                } else {                    unset($s->attr['file']);                    unset($s->attr['line']);                }                if ($error = $o->getError()) {                    return [Caster::PREFIX_VIRTUAL.'⚠' => $error->getMessage()];                }                if ($o->isStringable()) {                    return [Caster::PREFIX_VIRTUAL.'__toString()' => (string) $o->getObject()];                }                return [Caster::PREFIX_VIRTUAL.'⚠' => sprintf('Object of class ""%s"" could not be converted to string.', $o->getClass())];            },        ];    }    private function sanitizeQueries(string $connectionName, array $queries): array    {        foreach ($queries as $i => $query) {            $queries[$i] = $this->sanitizeQuery($connectionName, $query);        }        return $queries;    }    private function sanitizeQuery(string $connectionName, array $query): array    {        $query['explainable'] = true;        $query['runnable'] = true;        if (null === $query['params']) {            $query['params'] = [];        }        if (!\is_array($query['params'])) {            $query['params'] = [$query['params']];        }        if (!\is_array($query['types'])) {            $query['types'] = [];        }        foreach ($query['params'] as $j => $param) {            $e = null;            if (isset($query['types'][$j])) {                // Transform the param according to the type                $type = $query['types'][$j];                if (\is_string($type)) {                    $type = Type::getType($type);                }                if ($type instanceof Type) {                    $query['types'][$j] = $type->getBindingType();                    try {                        $param = $type->convertToDatabaseValue($param, $this->registry->getConnection($connectionName)->getDatabasePlatform());                    } catch (\TypeError $e) {                    } catch (ConversionException $e) {                    }                }            }            [$query['params'][$j], $explainable, $runnable] = $this->sanitizeParam($param, $e);            if (!$explainable) {                $query['explainable'] = false;            }            if (!$runnable) {                $query['runnable'] = false;            }        }        $query['params'] = $this->cloneVar($query['params']);        return $query;    }    /**     * Sanitizes a param.     *     * The return value is an array with the sanitized value and a boolean     * indicating if the original value was kept (allowing to use the sanitized     * value to explain the query).     */    private function sanitizeParam($var, ?\Throwable $error): array    {        if (\is_object($var)) {            return [$o = new ObjectParameter($var, $error), false, $o->isStringable() && !$error];        }        if ($error) {            return ['⚠ '.$error->getMessage(), false, false];        }        if (\is_array($var)) {            $a = [];            $explainable = $runnable = true;            foreach ($var as $k => $v) {                [$value, $e, $r] = $this->sanitizeParam($v, null);                $explainable = $explainable && $e;                $runnable = $runnable && $r;                $a[$k] = $value;            }            return [$a, $explainable, $runnable];        }        if (\is_resource($var)) {            return [sprintf('/* Resource(%s) */', get_resource_type($var)), false, false];        }        return [$var, true, true];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_DoctrineValidationPass_1844, Gets the validation mapping files for the format and extends them with\n files matching a doctrine search pattern (Resources/config/validation.orm.xml).\n, Gets the validation mapping files for the format and extends them with,"    private function updateValidatorMappingFiles(ContainerBuilder $container, string $mapping, string $extension)    {        if (!$container->hasParameter('validator.mapping.loader.'.$mapping.'_files_loader.mapping_files')) {            return;        }        $files = $container->getParameter('validator.mapping.loader.'.$mapping.'_files_loader.mapping_files');        $validationPath = '/config/validation.'.$this->managerType.'.'.$extension;        foreach ($container->getParameter('kernel.bundles_metadata') as $bundle) {            if ($container->fileExists($file = $bundle['path'].'/Resources'.$validationPath) || $container->fileExists($file = $bundle['path'].$validationPath)) {                $files[] = $file;            }        }        $container->setParameter('validator.mapping.loader.'.$mapping.'_files_loader.mapping_files', $files);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_ProxyCacheWarmer_1813," The proxy generator cache warmer generates all entity proxies.\\n\\n In the process of generating proxies the cache for all the metadata is primed also,\\n since this information is necessary to build the proxies in the first place.\\n\\n @author Benjamin Eberlei <kontakt@beberlei.de>\\n", The proxy generator cache warmer generates all entity proxies.,"class ProxyCacheWarmer implements CacheWarmerInterface{    private $registry;    public function __construct(ManagerRegistry $registry)    {        $this->registry = $registry;    }    /**     * This cache warmer is not optional, without proxies fatal error occurs!     *     * @return false     */    public function isOptional()    {        return false;    }    /**     * {@inheritdoc}     *     * @return string[] A list of files to preload on PHP 7.4+     */    public function warmUp(string $cacheDir)    {        $files = [];        foreach ($this->registry->getManagers() as $em) {            // we need the directory no matter the proxy cache generation strategy            if (!is_dir($proxyCacheDir = $em->getConfiguration()->getProxyDir())) {                if (false === @mkdir($proxyCacheDir, 0777, true)) {                    throw new \RuntimeException(sprintf('Unable to create the Doctrine Proxy directory ""%s"".', $proxyCacheDir));                }            } elseif (!is_writable($proxyCacheDir)) {                throw new \RuntimeException(sprintf('The Doctrine Proxy directory ""%s"" is not writeable for the current system user.', $proxyCacheDir));            }            // if proxies are autogenerated we don't need to generate them in the cache warmer            if ($em->getConfiguration()->getAutoGenerateProxyClasses()) {                continue;            }            $classes = $em->getMetadataFactory()->getAllMetadata();            $em->getProxyFactory()->generateProxyClasses($classes);            foreach (scandir($proxyCacheDir) as $file) {                if (!is_dir($file = $proxyCacheDir.'/'.$file)) {                    $files[] = $file;                }            }        }        return $files;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_RegisterEventListenersAndSubscribersPass_1845, Registers event listeners and subscribers to the available doctrine connections.\\n\\n @author Jeremy Mikola <jmikola@gmail.com>\\n @author Alexander <iam.asm89@gmail.com>\\n @author David Maicher <mail@dmaicher.de>\\n, Registers event listeners and subscribers to the available doctrine connections.,"class RegisterEventListenersAndSubscribersPass implements CompilerPassInterface{    private $connections;    private $eventManagers;    private $managerTemplate;    private $tagPrefix;    /**     * @param string $connections     Parameter ID for connections     * @param string $managerTemplate sprintf() template for generating the event     *                                manager's service ID for a connection name     * @param string $tagPrefix       Tag prefix for listeners and subscribers     */    public function __construct(string $connections, string $managerTemplate, string $tagPrefix)    {        $this->connections = $connections;        $this->managerTemplate = $managerTemplate;        $this->tagPrefix = $tagPrefix;    }    /**     * {@inheritdoc}     */    public function process(ContainerBuilder $container)    {        if (!$container->hasParameter($this->connections)) {            return;        }        $this->connections = $container->getParameter($this->connections);        $listenerRefs = $this->addTaggedServices($container);        // replace service container argument of event managers with smaller service locator        // so services can even remain private        foreach ($listenerRefs as $connection => $refs) {            $this->getEventManagerDef($container, $connection)                ->replaceArgument(0, ServiceLocatorTagPass::register($container, $refs));        }    }    private function addTaggedServices(ContainerBuilder $container): array    {        $listenerTag = $this->tagPrefix.'.event_listener';        $subscriberTag = $this->tagPrefix.'.event_subscriber';        $listenerRefs = [];        $taggedServices = $this->findAndSortTags([$subscriberTag, $listenerTag], $container);        $managerDefs = [];        foreach ($taggedServices as $taggedSubscriber) {            [$tagName, $id, $tag] = $taggedSubscriber;            $connections = isset($tag['connection']) ? [$tag['connection']] : array_keys($this->connections);            if ($listenerTag === $tagName && !isset($tag['event'])) {                throw new InvalidArgumentException(sprintf('Doctrine event listener ""%s"" must specify the ""event"" attribute.', $id));            }            foreach ($connections as $con) {                if (!isset($this->connections[$con])) {                    throw new RuntimeException(sprintf('The Doctrine connection ""%s"" referenced in service ""%s"" does not exist. Available connections names: ""%s"".', $con, $id, implode('"", ""', array_keys($this->connections))));                }                if (!isset($managerDefs[$con])) {                    $managerDef = $parentDef = $this->getEventManagerDef($container, $con);                    while (!$parentDef->getClass() && $parentDef instanceof ChildDefinition) {                        $parentDef = $container->findDefinition($parentDef->getParent());                    }                    $managerClass = $container->getParameterBag()->resolveValue($parentDef->getClass());                    $managerDefs[$con] = [$managerDef, $managerClass];                } else {                    [$managerDef, $managerClass] = $managerDefs[$con];                }                if (ContainerAwareEventManager::class === $managerClass) {                    $refs = $managerDef->getArguments()[1] ?? [];                    $listenerRefs[$con][$id] = new Reference($id);                    if ($subscriberTag === $tagName) {                        $refs[] = $id;                    } else {                        $refs[] = [[$tag['event']], $id];                    }                    $managerDef->setArgument(1, $refs);                } else {                    if ($subscriberTag === $tagName) {                        $managerDef->addMethodCall('addEventSubscriber', [new Reference($id)]);                    } else {                        $managerDef->addMethodCall('addEventListener', [[$tag['event']], new Reference($id)]);                    }                }            }        }        return $listenerRefs;    }    private function getEventManagerDef(ContainerBuilder $container, string $name)    {        if (!isset($this->eventManagers[$name])) {            $this->eventManagers[$name] = $container->getDefinition(sprintf($this->managerTemplate, $name));        }        return $this->eventManagers[$name];    }    /**     * Finds and orders all service tags with the given name by their priority.     *     * The order of additions must be respected for services having the same priority,     * and knowing that the \SplPriorityQueue class does not respect the FIFO method,     * we should not use this class.     *     * @see https://bugs.php.net/53710     * @see https://bugs.php.net/60926     */    private function findAndSortTags(array $tagNames, ContainerBuilder $container): array    {        $sortedTags = [];        foreach ($tagNames as $tagName) {            foreach ($container->findTaggedServiceIds($tagName, true) as $serviceId => $tags) {                foreach ($tags as $attributes) {                    $priority = $attributes['priority'] ?? 0;                    $sortedTags[$priority][] = [$tagName, $serviceId, $attributes];                }            }        }        if ($sortedTags) {            krsort($sortedTags);            $sortedTags = array_merge(...$sortedTags);        }        return $sortedTags;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_RegisterEventListenersAndSubscribersPass_1848," Finds and orders all service tags with the given name by their priority.\\n\\n The order of additions must be respected for services having the same priority,\\n and knowing that the \\\\SplPriorityQueue class does not respect the FIFO method,\\n we should not use this class.\\n\\n @see https://bugs.php.net/53710\\n @see https://bugs.php.net/60926\\n", Finds and orders all service tags with the given name by their priority.,"    private function findAndSortTags(array $tagNames, ContainerBuilder $container): array    {        $sortedTags = [];        foreach ($tagNames as $tagName) {            foreach ($container->findTaggedServiceIds($tagName, true) as $serviceId => $tags) {                foreach ($tags as $attributes) {                    $priority = $attributes['priority'] ?? 0;                    $sortedTags[$priority][] = [$tagName, $serviceId, $attributes];                }            }        }        if ($sortedTags) {            krsort($sortedTags);            $sortedTags = array_merge(...$sortedTags);        }        return $sortedTags;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_RegisterMappingsPass_1854, Determine the manager name.\n\n The default implementation loops over the managerParameters and returns\n the first non-empty parameter.\n\n @throws InvalidArgumentException if none of the managerParameters is found in the container\n, Determine the manager name.,"    private function getManagerName(ContainerBuilder $container): string    {        foreach ($this->managerParameters as $param) {            if ($container->hasParameter($param)) {                $name = $container->getParameter($param);                if ($name) {                    return $name;                }            }        }        throw new InvalidArgumentException(sprintf('Could not find the manager name parameter in the container. Tried the following parameter names: ""%s"".', implode('"", ""', $this->managerParameters)));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_RegisterMappingsPass_1855, Determine whether this mapping should be activated or not. This allows\n to take this decision with the container builder available.\n\n This default implementation checks if the class has the enabledParameter\n configured and if so if that parameter is present in the container.\n\n @return bool whether this compiler pass really should register the mappings\n, Determine whether this mapping should be activated or not. This allows,    protected function enabled(ContainerBuilder $container)    {        return !$this->enabledParameter || $container->hasParameter($this->enabledParameter);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractCloner_10166, Sets the maximum number of items to clone past the minimum depth in nested structures.\n, Sets the maximum number of items to clone past the minimum depth in nested structures.,    public function setMaxItems(int $maxItems)    {        $this->maxItems = $maxItems;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractCloner_10168," Sets the minimum tree depth where we are guaranteed to clone all the items.  After this\n depth is reached, only setMaxItems items will be cloned.\n", Sets the minimum tree depth where we are guaranteed to clone all the items.  After this,    public function setMinDepth(int $minDepth)    {        $this->minDepth = $minDepth;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractCloner_10171, Casts a resource to an array representation.\n\n @param bool $isNested True if the object is nested in the dumped structure\n\n @return array The resource casted as array\n, Casts a resource to an array representation.,"    protected function castResource(Stub $stub, bool $isNested)    {        $a = [];        $res = $stub->value;        $type = $stub->class;        try {            if (!empty($this->casters[':'.$type])) {                foreach ($this->casters[':'.$type] as $callback) {                    $a = $callback($res, $a, $stub, $isNested, $this->filter);                }            }        } catch (\Exception $e) {            $a = [(Stub::TYPE_OBJECT === $stub->type ? Caster::PREFIX_VIRTUAL : '').'⚠' => new ThrowingCasterException($e)] + $a;        }        return $a;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractCloner_8297," Adds casters for resources and objects.\n\n Maps resources or objects types to a callback.\n Types are in the key, with a callable caster for value.\n Resource types are to be prefixed with a `:`,\n see e.g. static::$defaultCasters.\n\n @param callable[] $casters A map of casters\n", Adds casters for resources and objects.,    public function addCasters(array $casters)    {        foreach ($casters as $type => $callback) {            $this->casters[$type][] = $callback;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractDumper_10202," Sets the output destination of the dumps.\n\n @param callable|resource|string $output A line dumper callable, an opened stream or an output path\n\n @return callable|resource|string The previous output destination\n", Sets the output destination of the dumps.,"    public function setOutput($output)    {        $prev = null !== $this->outputStream ? $this->outputStream : $this->lineDumper;        if (\is_callable($output)) {            $this->outputStream = null;            $this->lineDumper = $output;        } else {            if (\is_string($output)) {                $output = fopen($output, 'w');            }            $this->outputStream = $output;            $this->lineDumper = [$this, 'echoLine'];        }        return $prev;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractDumper_8338, Generic line dumper callback.\n, Generic line dumper callback.,"    protected function echoLine(string $line, int $depth, string $indentPad)    {        if (-1 !== $depth) {            fwrite($this->outputStream, str_repeat($indentPad, $depth).$line.""\n"");        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractDumper_9254," Sets the indentation pad string.\n\n @param string $pad A string that will be prepended to dumped lines, repeated by nesting level\n\n @return string The previous indent pad\n", Sets the indentation pad string.,    public function setIndentPad(string $pad)    {        $prev = $this->indentPad;        $this->indentPad = $pad;        return $prev;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AmqpCaster_8285, Casts Amqp related classes to array representation.\n\n @author Grégoire Pineau <lyrixx@lyrixx.info>\n\n @final\n, Casts Amqp related classes to array representation.,"class AmqpCaster{    private const FLAGS = [        \AMQP_DURABLE => 'AMQP_DURABLE',        \AMQP_PASSIVE => 'AMQP_PASSIVE',        \AMQP_EXCLUSIVE => 'AMQP_EXCLUSIVE',        \AMQP_AUTODELETE => 'AMQP_AUTODELETE',        \AMQP_INTERNAL => 'AMQP_INTERNAL',        \AMQP_NOLOCAL => 'AMQP_NOLOCAL',        \AMQP_AUTOACK => 'AMQP_AUTOACK',        \AMQP_IFEMPTY => 'AMQP_IFEMPTY',        \AMQP_IFUNUSED => 'AMQP_IFUNUSED',        \AMQP_MANDATORY => 'AMQP_MANDATORY',        \AMQP_IMMEDIATE => 'AMQP_IMMEDIATE',        \AMQP_MULTIPLE => 'AMQP_MULTIPLE',        \AMQP_NOWAIT => 'AMQP_NOWAIT',        \AMQP_REQUEUE => 'AMQP_REQUEUE',    ];    private const EXCHANGE_TYPES = [        \AMQP_EX_TYPE_DIRECT => 'AMQP_EX_TYPE_DIRECT',        \AMQP_EX_TYPE_FANOUT => 'AMQP_EX_TYPE_FANOUT',        \AMQP_EX_TYPE_TOPIC => 'AMQP_EX_TYPE_TOPIC',        \AMQP_EX_TYPE_HEADERS => 'AMQP_EX_TYPE_HEADERS',    ];    public static function castConnection(\AMQPConnection $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'is_connected' => $c->isConnected(),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPConnection\x00login""])) {            return $a;        }        // BC layer in the amqp lib        if (method_exists($c, 'getReadTimeout')) {            $timeout = $c->getReadTimeout();        } else {            $timeout = $c->getTimeout();        }        $a += [            $prefix.'is_connected' => $c->isConnected(),            $prefix.'login' => $c->getLogin(),            $prefix.'password' => $c->getPassword(),            $prefix.'host' => $c->getHost(),            $prefix.'vhost' => $c->getVhost(),            $prefix.'port' => $c->getPort(),            $prefix.'read_timeout' => $timeout,        ];        return $a;    }    public static function castChannel(\AMQPChannel $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'is_connected' => $c->isConnected(),            $prefix.'channel_id' => $c->getChannelId(),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPChannel\x00connection""])) {            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'prefetch_size' => $c->getPrefetchSize(),            $prefix.'prefetch_count' => $c->getPrefetchCount(),        ];        return $a;    }    public static function castQueue(\AMQPQueue $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'flags' => self::extractFlags($c->getFlags()),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPQueue\x00name""])) {            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'channel' => $c->getChannel(),            $prefix.'name' => $c->getName(),            $prefix.'arguments' => $c->getArguments(),        ];        return $a;    }    public static function castExchange(\AMQPExchange $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'flags' => self::extractFlags($c->getFlags()),        ];        $type = isset(self::EXCHANGE_TYPES[$c->getType()]) ? new ConstStub(self::EXCHANGE_TYPES[$c->getType()], $c->getType()) : $c->getType();        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPExchange\x00name""])) {            $a[""\x00AMQPExchange\x00type""] = $type;            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'channel' => $c->getChannel(),            $prefix.'name' => $c->getName(),            $prefix.'type' => $type,            $prefix.'arguments' => $c->getArguments(),        ];        return $a;    }    public static function castEnvelope(\AMQPEnvelope $c, array $a, Stub $stub, bool $isNested, int $filter = 0)    {        $prefix = Caster::PREFIX_VIRTUAL;        $deliveryMode = new ConstStub($c->getDeliveryMode().(2 === $c->getDeliveryMode() ? ' (persistent)' : ' (non-persistent)'), $c->getDeliveryMode());        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPEnvelope\x00body""])) {            $a[""\0AMQPEnvelope\0delivery_mode""] = $deliveryMode;            return $a;        }        if (!($filter & Caster::EXCLUDE_VERBOSE)) {            $a += [$prefix.'body' => $c->getBody()];        }        $a += [            $prefix.'delivery_tag' => $c->getDeliveryTag(),            $prefix.'is_redelivery' => $c->isRedelivery(),            $prefix.'exchange_name' => $c->getExchangeName(),            $prefix.'routing_key' => $c->getRoutingKey(),            $prefix.'content_type' => $c->getContentType(),            $prefix.'content_encoding' => $c->getContentEncoding(),            $prefix.'headers' => $c->getHeaders(),            $prefix.'delivery_mode' => $deliveryMode,            $prefix.'priority' => $c->getPriority(),            $prefix.'correlation_id' => $c->getCorrelationId(),            $prefix.'reply_to' => $c->getReplyTo(),            $prefix.'expiration' => $c->getExpiration(),            $prefix.'message_id' => $c->getMessageId(),            $prefix.'timestamp' => $c->getTimeStamp(),            $prefix.'type' => $c->getType(),            $prefix.'user_id' => $c->getUserId(),            $prefix.'app_id' => $c->getAppId(),        ];        return $a;    }    private static function extractFlags(int $flags): ConstStub    {        $flagsArray = [];        foreach (self::FLAGS as $value => $name) {            if ($flags & $value) {                $flagsArray[] = $name;            }        }        if (!$flagsArray) {            $flagsArray = ['AMQP_NOPARAM'];        }        return new ConstStub(implode('|', $flagsArray), $flags);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_ArgsStub_8286, Represents a list of function arguments.\n\n @author Nicolas Grekas <p@tchwork.com>\n, Represents a list of function arguments.,"class ArgsStub extends EnumStub{    private static $parameters = [];    public function __construct(array $args, string $function, ?string $class)    {        [$variadic, $params] = self::getParameters($function, $class);        $values = [];        foreach ($args as $k => $v) {            $values[$k] = !is_scalar($v) && !$v instanceof Stub ? new CutStub($v) : $v;        }        if (null === $params) {            parent::__construct($values, false);            return;        }        if (\count($values) < \count($params)) {            $params = \array_slice($params, 0, \count($values));        } elseif (\count($values) > \count($params)) {            $values[] = new EnumStub(array_splice($values, \count($params)), false);            $params[] = $variadic;        }        if (['...'] === $params) {            $this->dumpKeys = false;            $this->value = $values[0]->value;        } else {            $this->value = array_combine($params, $values);        }    }    private static function getParameters(string $function, ?string $class): array    {        if (isset(self::$parameters[$k = $class.'::'.$function])) {            return self::$parameters[$k];        }        try {            $r = null !== $class ? new \ReflectionMethod($class, $function) : new \ReflectionFunction($function);        } catch (\ReflectionException $e) {            return [null, null];        }        $variadic = '...';        $params = [];        foreach ($r->getParameters() as $v) {            $k = '$'.$v->name;            if ($v->isPassedByReference()) {                $k = '&'.$k;            }            if ($v->isVariadic()) {                $variadic .= $k;            } else {                $params[] = $k;            }        }        return self::$parameters[$k] = [$variadic, $params];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_Caster_9205, Helper for filtering out properties in casters.\n\n @author Nicolas Grekas <p@tchwork.com>\n\n @final\n, Helper for filtering out properties in casters.,"class Caster{    public const EXCLUDE_VERBOSE = 1;    public const EXCLUDE_VIRTUAL = 2;    public const EXCLUDE_DYNAMIC = 4;    public const EXCLUDE_PUBLIC = 8;    public const EXCLUDE_PROTECTED = 16;    public const EXCLUDE_PRIVATE = 32;    public const EXCLUDE_NULL = 64;    public const EXCLUDE_EMPTY = 128;    public const EXCLUDE_NOT_IMPORTANT = 256;    public const EXCLUDE_STRICT = 512;    public const PREFIX_VIRTUAL = ""\0~\0"";    public const PREFIX_DYNAMIC = ""\0+\0"";    public const PREFIX_PROTECTED = ""\0*\0"";    /**     * Casts objects to arrays and adds the dynamic property prefix.     *     * @param bool $hasDebugInfo Whether the __debugInfo method exists on $obj or not     *     * @return array The array-cast of the object, with prefixed dynamic properties     */    public static function castObject(object $obj, string $class, bool $hasDebugInfo = false, string $debugClass = null): array    {        if ($hasDebugInfo) {            try {                $debugInfo = $obj->__debugInfo();            } catch (\Exception $e) {                // ignore failing __debugInfo()                $hasDebugInfo = false;            }        }        $a = $obj instanceof \Closure ? [] : (array) $obj;        if ($obj instanceof \__PHP_Incomplete_Class) {            return $a;        }        if ($a) {            static $publicProperties = [];            $debugClass = $debugClass ?? get_debug_type($obj);            $i = 0;            $prefixedKeys = [];            foreach ($a as $k => $v) {                if (""\0"" !== ($k[0] ?? '')) {                    if (!isset($publicProperties[$class])) {                        foreach ((new \ReflectionClass($class))->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {                            $publicProperties[$class][$prop->name] = true;                        }                    }                    if (!isset($publicProperties[$class][$k])) {                        $prefixedKeys[$i] = self::PREFIX_DYNAMIC.$k;                    }                } elseif ($debugClass !== $class && 1 === strpos($k, $class)) {                    $prefixedKeys[$i] = ""\0"".$debugClass.strrchr($k, ""\0"");                }                ++$i;            }            if ($prefixedKeys) {                $keys = array_keys($a);                foreach ($prefixedKeys as $i => $k) {                    $keys[$i] = $k;                }                $a = array_combine($keys, $a);            }        }        if ($hasDebugInfo && \is_array($debugInfo)) {            foreach ($debugInfo as $k => $v) {                if (!isset($k[0]) || ""\0"" !== $k[0]) {                    if (\array_key_exists(self::PREFIX_DYNAMIC.$k, $a)) {                        continue;                    }                    $k = self::PREFIX_VIRTUAL.$k;                }                unset($a[$k]);                $a[$k] = $v;            }        }        return $a;    }    /**     * Filters out the specified properties.     *     * By default, a single match in the $filter bit field filters properties out, following an ""or"" logic.     * When EXCLUDE_STRICT is set, an ""and"" logic is applied: all bits must match for a property to be removed.     *     * @param array    $a                The array containing the properties to filter     * @param int      $filter           A bit field of Caster::EXCLUDE_* constants specifying which properties to filter out     * @param string[] $listedProperties List of properties to exclude when Caster::EXCLUDE_VERBOSE is set, and to preserve when Caster::EXCLUDE_NOT_IMPORTANT is set     * @param int      &$count           Set to the number of removed properties     *     * @return array The filtered array     */    public static function filter(array $a, int $filter, array $listedProperties = [], ?int &$count = 0): array    {        $count = 0;        foreach ($a as $k => $v) {            $type = self::EXCLUDE_STRICT & $filter;            if (null === $v) {                $type |= self::EXCLUDE_NULL & $filter;                $type |= self::EXCLUDE_EMPTY & $filter;            } elseif (false === $v || '' === $v || '0' === $v || 0 === $v || 0.0 === $v || [] === $v) {                $type |= self::EXCLUDE_EMPTY & $filter;            }            if ((self::EXCLUDE_NOT_IMPORTANT & $filter) && !\in_array($k, $listedProperties, true)) {                $type |= self::EXCLUDE_NOT_IMPORTANT;            }            if ((self::EXCLUDE_VERBOSE & $filter) && \in_array($k, $listedProperties, true)) {                $type |= self::EXCLUDE_VERBOSE;            }            if (!isset($k[1]) || ""\0"" !== $k[0]) {                $type |= self::EXCLUDE_PUBLIC & $filter;            } elseif ('~' === $k[1]) {                $type |= self::EXCLUDE_VIRTUAL & $filter;            } elseif ('+' === $k[1]) {                $type |= self::EXCLUDE_DYNAMIC & $filter;            } elseif ('*' === $k[1]) {                $type |= self::EXCLUDE_PROTECTED & $filter;            } else {                $type |= self::EXCLUDE_PRIVATE & $filter;            }            if ((self::EXCLUDE_STRICT & $filter) ? $type === $filter : $type) {                unset($a[$k]);                ++$count;            }        }        return $a;    }    public static function castPhpIncompleteClass(\__PHP_Incomplete_Class $c, array $a, Stub $stub, bool $isNested): array    {        if (isset($a['__PHP_Incomplete_Class_Name'])) {            $stub->class .= '('.$a['__PHP_Incomplete_Class_Name'].')';            unset($a['__PHP_Incomplete_Class_Name']);        }        return $a;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_Cursor_8305, Represents the current state of a dumper while dumping.\n\n @author Nicolas Grekas <p@tchwork.com>\n, Represents the current state of a dumper while dumping.,class Cursor{    public const HASH_INDEXED = Stub::ARRAY_INDEXED;    public const HASH_ASSOC = Stub::ARRAY_ASSOC;    public const HASH_OBJECT = Stub::TYPE_OBJECT;    public const HASH_RESOURCE = Stub::TYPE_RESOURCE;    public $depth = 0;    public $refIndex = 0;    public $softRefTo = 0;    public $softRefCount = 0;    public $softRefHandle = 0;    public $hardRefTo = 0;    public $hardRefCount = 0;    public $hardRefHandle = 0;    public $hashType;    public $hashKey;    public $hashKeyIsBinary;    public $hashIndex = 0;    public $hashLength = 0;    public $hashCut = 0;    public $stop = false;    public $attr = [];    public $skipChildren = false;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_CutStub_9210," Represents the main properties of a PHP variable, pre-casted by a caster.\n\n @author Nicolas Grekas <p@tchwork.com>\n"," Represents the main properties of a PHP variable, pre-casted by a caster.","class CutStub extends Stub{    public function __construct($value)    {        $this->value = $value;        switch (\gettype($value)) {            case 'object':                $this->type = self::TYPE_OBJECT;                $this->class = \get_class($value);                if ($value instanceof \Closure) {                    ReflectionCaster::castClosure($value, [], $this, true, Caster::EXCLUDE_VERBOSE);                }                $this->cut = -1;                break;            case 'array':                $this->type = self::TYPE_ARRAY;                $this->class = self::ARRAY_ASSOC;                $this->cut = $this->value = \count($value);                break;            case 'resource':            case 'unknown type':            case 'resource (closed)':                $this->type = self::TYPE_RESOURCE;                $this->handle = (int) $value;                if ('Unknown' === $this->class = @get_resource_type($value)) {                    $this->class = 'Closed';                }                $this->cut = -1;                break;            case 'string':                $this->type = self::TYPE_STRING;                $this->class = preg_match('//u', $value) ? self::STRING_UTF8 : self::STRING_BINARY;                $this->cut = self::STRING_BINARY === $this->class ? \strlen($value) : mb_strlen($value, 'UTF-8');                $this->value = '';                break;        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_Data_8316, Enables/disables objects' identifiers tracking.\n\n @param bool $useRefHandles False to hide global ref. handles\n\n @return static\n, Enables/disables objects' identifiers tracking.,    public function withRefHandles(bool $useRefHandles)    {        $data = clone $this;        $data->useRefHandles = $useRefHandles ? -1 : 0;        return $data;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_Data_8318, Seeks to a specific key in nested data structures.\n\n @param string|int $key The key to seek to\n\n @return static|null Null if the key is not set\n, Seeks to a specific key in nested data structures.,"    public function seek($key)    {        $item = $this->data[$this->position][$this->key];        if ($item instanceof Stub && Stub::TYPE_REF === $item->type && !$item->position) {            $item = $item->value;        }        if (!($item = $this->getStub($item)) instanceof Stub || !$item->position) {            return null;        }        $keys = [$key];        switch ($item->type) {            case Stub::TYPE_OBJECT:                $keys[] = Caster::PREFIX_DYNAMIC.$key;                $keys[] = Caster::PREFIX_PROTECTED.$key;                $keys[] = Caster::PREFIX_VIRTUAL.$key;                $keys[] = ""\0$item->class\0$key"";                // no break            case Stub::TYPE_ARRAY:            case Stub::TYPE_RESOURCE:                break;            default:                return null;        }        $data = null;        $children = $this->data[$item->position];        foreach ($keys as $key) {            if (isset($children[$key]) || \array_key_exists($key, $children)) {                $data = clone $this;                $data->key = $key;                $data->position = $item->position;                break;            }        }        return $data;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_Data_8319, Dumps data with a DumperInterface dumper.\n, Dumps data with a DumperInterface dumper.,"    public function dump(DumperInterface $dumper)    {        $refs = [0];        $cursor = new Cursor();        if ($cursor->attr = $this->context[SourceContextProvider::class] ?? []) {            $cursor->attr['if_links'] = true;            $cursor->hashType = -1;            $dumper->dumpScalar($cursor, 'default', '^');            $cursor->attr = ['if_links' => true];            $dumper->dumpScalar($cursor, 'default', ' ');            $cursor->hashType = 0;        }        $this->dumpItem($dumper, $cursor, $refs, $this->data[$this->position][$this->key]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_Data_8320, Depth-first dumping of items.\n\n @param mixed $item A Stub object or the original value being dumped\n, Depth-first dumping of items.,"    private function dumpItem(DumperInterface $dumper, Cursor $cursor, array &$refs, $item)    {        $cursor->refIndex = 0;        $cursor->softRefTo = $cursor->softRefHandle = $cursor->softRefCount = 0;        $cursor->hardRefTo = $cursor->hardRefHandle = $cursor->hardRefCount = 0;        $firstSeen = true;        if (!$item instanceof Stub) {            $cursor->attr = [];            $type = \gettype($item);            if ($item && 'array' === $type) {                $item = $this->getStub($item);            }        } elseif (Stub::TYPE_REF === $item->type) {            if ($item->handle) {                if (!isset($refs[$r = $item->handle - (\PHP_INT_MAX >> 1)])) {                    $cursor->refIndex = $refs[$r] = $cursor->refIndex ?: ++$refs[0];                } else {                    $firstSeen = false;                }                $cursor->hardRefTo = $refs[$r];                $cursor->hardRefHandle = $this->useRefHandles & $item->handle;                $cursor->hardRefCount = 0 < $item->handle ? $item->refCount : 0;            }            $cursor->attr = $item->attr;            $type = $item->class ?: \gettype($item->value);            $item = $this->getStub($item->value);        }        if ($item instanceof Stub) {            if ($item->refCount) {                if (!isset($refs[$r = $item->handle])) {                    $cursor->refIndex = $refs[$r] = $cursor->refIndex ?: ++$refs[0];                } else {                    $firstSeen = false;                }                $cursor->softRefTo = $refs[$r];            }            $cursor->softRefHandle = $this->useRefHandles & $item->handle;            $cursor->softRefCount = $item->refCount;            $cursor->attr = $item->attr;            $cut = $item->cut;            if ($item->position && $firstSeen) {                $children = $this->data[$item->position];                if ($cursor->stop) {                    if ($cut >= 0) {                        $cut += \count($children);                    }                    $children = [];                }            } else {                $children = [];            }            switch ($item->type) {                case Stub::TYPE_STRING:                    $dumper->dumpString($cursor, $item->value, Stub::STRING_BINARY === $item->class, $cut);                    break;                case Stub::TYPE_ARRAY:                    $item = clone $item;                    $item->type = $item->class;                    $item->class = $item->value;                    // no break                case Stub::TYPE_OBJECT:                case Stub::TYPE_RESOURCE:                    $withChildren = $children && $cursor->depth !== $this->maxDepth && $this->maxItemsPerDepth;                    $dumper->enterHash($cursor, $item->type, $item->class, $withChildren);                    if ($withChildren) {                        if ($cursor->skipChildren) {                            $withChildren = false;                            $cut = -1;                        } else {                            $cut = $this->dumpChildren($dumper, $cursor, $refs, $children, $cut, $item->type, null !== $item->class);                        }                    } elseif ($children && 0 <= $cut) {                        $cut += \count($children);                    }                    $cursor->skipChildren = false;                    $dumper->leaveHash($cursor, $item->type, $item->class, $withChildren, $cut);                    break;                default:                    throw new \RuntimeException(sprintf('Unexpected Stub type: ""%s"".', $item->type));            }        } elseif ('array' === $type) {            $dumper->enterHash($cursor, Cursor::HASH_INDEXED, 0, false);            $dumper->leaveHash($cursor, Cursor::HASH_INDEXED, 0, false, 0);        } elseif ('string' === $type) {            $dumper->dumpString($cursor, $item, false, 0);        } else {            $dumper->dumpScalar($cursor, $type, $item);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_DumperInterface_8323, Dumps a string.\n\n @param string $str The string being dumped\n @param bool   $bin Whether $str is UTF-8 or binary encoded\n @param int    $cut The number of characters $str has been cut by\n, Dumps a string.,"    public function dumpString(Cursor $cursor, string $str, bool $bin, int $cut);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_DumperInterface_9243," Dumps while leaving an hash.\n\n @param int        $type     A Cursor::HASH_ @param string|int $class    The object class, resource type or array count\n @param bool       $hasChild When the dump of the hash has child item\n @param int        $cut      The number of items the hash has been cut by\n", Dumps while leaving an hash.,"    public function leaveHash(Cursor $cursor, int $type, $class, bool $hasChild, int $cut);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_HtmlDescriptor_8332, Describe collected data clones for html output.\n\n @author Maxime Steinhausser <maxime.steinhausser@gmail.com>\n\n @final\n, Describe collected data clones for html output.,"class HtmlDescriptor implements DumpDescriptorInterface{    private $dumper;    private $initialized = false;    public function __construct(HtmlDumper $dumper)    {        $this->dumper = $dumper;    }    public function describe(OutputInterface $output, Data $data, array $context, int $clientId): void    {        if (!$this->initialized) {            $styles = file_get_contents(__DIR__.'/../../Resources/css/htmlDescriptor.css');            $scripts = file_get_contents(__DIR__.'/../../Resources/js/htmlDescriptor.js');            $output->writeln(""<style>$styles</style><script>$scripts</script>"");            $this->initialized = true;        }        $title = '-';        if (isset($context['request'])) {            $request = $context['request'];            $controller = ""<span class='dumped-tag'>{$this->dumper->dump($request['controller'], true, ['maxDepth' => 0])}</span>"";            $title = sprintf('<code>%s</code> <a href=""%s"">%s</a>', $request['method'], $uri = $request['uri'], $uri);            $dedupIdentifier = $request['identifier'];        } elseif (isset($context['cli'])) {            $title = '<code>$ </code>'.$context['cli']['command_line'];            $dedupIdentifier = $context['cli']['identifier'];        } else {            $dedupIdentifier = uniqid('', true);        }        $sourceDescription = '';        if (isset($context['source'])) {            $source = $context['source'];            $projectDir = $source['project_dir'] ?? null;            $sourceDescription = sprintf('%s on line %d', $source['name'], $source['line']);            if (isset($source['file_link'])) {                $sourceDescription = sprintf('<a href=""%s"">%s</a>', $source['file_link'], $sourceDescription);            }        }        $isoDate = $this->extractDate($context, 'c');        $tags = array_filter([            'controller' => $controller ?? null,            'project dir' => $projectDir ?? null,        ]);        $output->writeln(<<<HTML<article data-dedup-id=""$dedupIdentifier"">    <header>        <div class=""row"">            <h2 class=""col"">$title</h2>            <time class=""col text-small"" title=""$isoDate"" datetime=""$isoDate"">                {$this->extractDate($context)}            </time>        </div>        {$this->renderTags($tags)}    </header>    <section class=""body"">        <p class=""text-small"">            $sourceDescription        </p>        {$this->dumper->dump($data, true)}    </section></article>HTML        );    }    private function extractDate(array $context, string $format = 'r'): string    {        return date($format, (int) $context['timestamp']);    }    private function renderTags(array $tags): string    {        if (!$tags) {            return '';        }        $renderedTags = '';        foreach ($tags as $key => $value) {            $renderedTags .= sprintf('<li><span class=""badge"">%s</span>%s</li>', $key, $value);        }        return <<<HTML<div class=""row"">    <ul class=""tags"">        $renderedTags    </ul></div>HTML;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_oauth2-server_CryptTrait_3463, Encrypt data with encryptionKey.\n\n @param string $unencryptedData\n\n @throws LogicException\n\n @return string\n, Encrypt data with encryptionKey.,"    protected function encrypt($unencryptedData)    {        try {            if ($this->encryptionKey instanceof Key) {                return Crypto::encrypt($unencryptedData, $this->encryptionKey);            }            if (\is_string($this->encryptionKey)) {                return Crypto::encryptWithPassword($unencryptedData, $this->encryptionKey);            }            throw new LogicException('Encryption key not set when attempting to encrypt');        } catch (Exception $e) {            throw new LogicException($e->getMessage(), 0, $e);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_oauth2-server_CryptTrait_3464, Decrypt data with encryptionKey.\n\n @param string $encryptedData\n\n @throws LogicException\n\n @return string\n, Decrypt data with encryptionKey.,"    protected function decrypt($encryptedData)    {        try {            if ($this->encryptionKey instanceof Key) {                return Crypto::decrypt($encryptedData, $this->encryptionKey);            }            if (\is_string($this->encryptionKey)) {                return Crypto::decryptWithPassword($encryptedData, $this->encryptionKey);            }            throw new LogicException('Encryption key not set when attempting to decrypt');        } catch (Exception $e) {            throw new LogicException($e->getMessage(), 0, $e);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_oauth2-server_OAuthServerExceptionTest_3483, Issue an invalid client exception\n\n @throws OAuthServerException\n, Issue an invalid client exception,"    private function issueInvalidClientException($serverRequest)    {        $clientRepositoryMock = $this->getMockBuilder(ClientRepositoryInterface::class)->getMock();        $clientRepositoryMock->method('validateClient')->willReturn(false);        $grantMock = $this->getMockForAbstractClass(AbstractGrant::class);        $grantMock->setClientRepository($clientRepositoryMock);        $abstractGrantReflection = new \ReflectionClass($grantMock);        $validateClientMethod = $abstractGrantReflection->getMethod('validateClient');        $validateClientMethod->setAccessible(true);        $validateClientMethod->invoke($grantMock, $serverRequest);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_oauth2-server_middleware_use_3451, Secured API\n, Secured API,"$app->group('/api', function () {    $this->get('/user', function (ServerRequestInterface $request, ResponseInterface $response) {        $params = [];        if (\in_array('basic', $request->getAttribute('oauth_scopes', []))) {            $params = [                'id'   => 1,                'name' => 'Alex',                'city' => 'London',            ];        }        if (\in_array('email', $request->getAttribute('oauth_scopes', []))) {            $params['email'] = 'alex@example.com';        }        $body = new Stream('php://temp', 'r+');        $body->write(\json_encode($params));        return $response->withBody($body);    });",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Compiler_10078, Adds a raw string to the compiled code.\n\n @return $this\n, Adds a raw string to the compiled code.,    public function raw(string $string)    {        $this->source .= $string;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Compiler_10080, Adds a quoted string to the compiled code.\n\n @return $this\n, Adds a quoted string to the compiled code.,"    public function string(string $value)    {        $this->source .= sprintf('""%s""', addcslashes($value, ""\0\t\""\$\\""));        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Compiler_8211, Writes a string to the compiled code by adding indentation.\n\n @return $this\n, Writes a string to the compiled code by adding indentation.,"    public function write(...$strings)    {        foreach ($strings as $string) {            $this->source .= str_repeat(' ', $this->indentation * 4).$string;        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Compiler_9131, Returns a PHP representation of a given value.\n\n @return $this\n, Returns a PHP representation of a given value.,"    public function repr($value)    {        if (\is_int($value) || \is_float($value)) {            if (false !== $locale = setlocale(\LC_NUMERIC, '0')) {                setlocale(\LC_NUMERIC, 'C');            }            $this->raw(var_export($value, true));            if (false !== $locale) {                setlocale(\LC_NUMERIC, $locale);            }        } elseif (null === $value) {            $this->raw('null');        } elseif (\is_bool($value)) {            $this->raw($value ? 'true' : 'false');        } elseif (\is_array($value)) {            $this->raw('array(');            $first = true;            foreach ($value as $key => $v) {                if (!$first) {                    $this->raw(', ');                }                $first = false;                $this->repr($key);                $this->raw(' => ');                $this->repr($v);            }            $this->raw(')');        } else {            $this->string($value);        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_10084, Enables debugging mode.\n, Enables debugging mode.,    public function enableDebug()    {        $this->debug = true;        $this->updateOptionsHash();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_10085, Disables debugging mode.\n, Disables debugging mode.,    public function disableDebug()    {        $this->debug = false;        $this->updateOptionsHash();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_10090, Enables the strict_variables option.\n, Enables the strict_variables option.,    public function enableStrictVariables()    {        $this->strictVariables = true;        $this->updateOptionsHash();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_10096," Tries to load a template consecutively from an array.\n\n Similar to load() but it also accepts instances of \\Twig\\Template and\n \\Twig\\TemplateWrapper, and an array of templates where each is tried to be loaded.\n\n @param string|TemplateWrapper|array $names A template or an array of templates to try consecutively\n\n @throws LoaderError When none of the templates can be found\n @throws SyntaxError When an error occurred during compilation\n", Tries to load a template consecutively from an array.,"    public function resolveTemplate($names): TemplateWrapper    {        if (!\is_array($names)) {            return $this->load($names);        }        foreach ($names as $name) {            try {                return $this->load($name);            } catch (LoaderError $e) {            }        }        throw new LoaderError(sprintf('Unable to find one of the following templates: ""%s"".', implode('"", ""', $names)));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_10108, Gets the registered Filters.\n\n Be warned that this method cannot return filters defined with registerUndefinedFilterCallback.\n\n @return TwigFilter[]\n\n @see registerUndefinedFilterCallback\n\n @internal\n, Gets the registered Filters.,    public function getFilters(): array    {        return $this->extensionSet->getFilters();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_8226, Loads a template.\n\n @param string|TemplateWrapper $name The template name\n\n @throws LoaderError  When the template cannot be found\n @throws RuntimeError When a previously generated cache is corrupted\n @throws SyntaxError  When an error occurred during compilation\n, Loads a template.,"    public function load($name): TemplateWrapper    {        if ($name instanceof TemplateWrapper) {            return $name;        }        return new TemplateWrapper($this, $this->loadTemplate($this->getTemplateClass($name), $name));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_8227," Returns true if the template is still fresh.\n\n Besides checking the loader for freshness information,\n this method also checks if the enabled extensions have\n not changed.\n\n @param int $time The last modification time of the cached template\n", Returns true if the template is still fresh.,"    public function isTemplateFresh(string $name, int $time): bool    {        return $this->extensionSet->getLastModified() <= $time && $this->getLoader()->isFresh($name, $time);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_8232," Compiles a template source code.\n\n @throws SyntaxError When there was an error during tokenizing, parsing or compiling\n", Compiles a template source code.,"    public function compileSource(Source $source): string    {        try {            return $this->compile($this->parse($this->tokenize($source)));        } catch (Error $e) {            $e->setSourceContext($source);            throw $e;        } catch (\Exception $e) {            throw new SyntaxError(sprintf('An exception has been thrown during the compilation of a template (""%s"").', $e->getMessage()), -1, $source, $e);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_9133, Stores the Twig configuration and renders templates.\n\n @author Fabien Potencier <fabien@symfony.com>\n, Stores the Twig configuration and renders templates.,"class Environment{    public const VERSION = '3.3.3-DEV';    public const VERSION_ID = 30303;    public const MAJOR_VERSION = 3;    public const MINOR_VERSION = 3;    public const RELEASE_VERSION = 3;    public const EXTRA_VERSION = 'DEV';    private $charset;    private $loader;    private $debug;    private $autoReload;    private $cache;    private $lexer;    private $parser;    private $compiler;    private $globals = [];    private $resolvedGlobals;    private $loadedTemplates;    private $strictVariables;    private $templateClassPrefix = '__TwigTemplate_';    private $originalCache;    private $extensionSet;    private $runtimeLoaders = [];    private $runtimes = [];    private $optionsHash;    /**     * Constructor.     *     * Available options:     *     *  * debug: When set to true, it automatically set ""auto_reload"" to true as     *           well (default to false).     *     *  * charset: The charset used by the templates (default to UTF-8).     *     *  * cache: An absolute path where to store the compiled templates,     *           a \Twig\Cache\CacheInterface implementation,     *           or false to disable compilation cache (default).     *     *  * auto_reload: Whether to reload the template if the original source changed.     *                 If you don't provide the auto_reload option, it will be     *                 determined automatically based on the debug value.     *     *  * strict_variables: Whether to ignore invalid variables in templates     *                      (default to false).     *     *  * autoescape: Whether to enable auto-escaping (default to html):     *                  * false: disable auto-escaping     *                  * html, js: set the autoescaping to one of the supported strategies     *                  * name: set the autoescaping strategy based on the template name extension     *                  * PHP callback: a PHP callback that returns an escaping strategy based on the template ""name""     *     *  * optimizations: A flag that indicates which optimizations to apply     *                   (default to -1 which means that all optimizations are enabled;     *                   set it to 0 to disable).     */    public function __construct(LoaderInterface $loader, $options = [])    {        $this->setLoader($loader);        $options = array_merge([            'debug' => false,            'charset' => 'UTF-8',            'strict_variables' => false,            'autoescape' => 'html',            'cache' => false,            'auto_reload' => null,            'optimizations' => -1,        ], $options);        $this->debug = (bool) $options['debug'];        $this->setCharset($options['charset'] ?? 'UTF-8');        $this->autoReload = null === $options['auto_reload'] ? $this->debug : (bool) $options['auto_reload'];        $this->strictVariables = (bool) $options['strict_variables'];        $this->setCache($options['cache']);        $this->extensionSet = new ExtensionSet();        $this->addExtension(new CoreExtension());        $this->addExtension(new EscaperExtension($options['autoescape']));        $this->addExtension(new OptimizerExtension($options['optimizations']));    }    /**     * Enables debugging mode.     */    public function enableDebug()    {        $this->debug = true;        $this->updateOptionsHash();    }    /**     * Disables debugging mode.     */    public function disableDebug()    {        $this->debug = false;        $this->updateOptionsHash();    }    /**     * Checks if debug mode is enabled.     *     * @return bool true if debug mode is enabled, false otherwise     */    public function isDebug()    {        return $this->debug;    }    /**     * Enables the auto_reload option.     */    public function enableAutoReload()    {        $this->autoReload = true;    }    /**     * Disables the auto_reload option.     */    public function disableAutoReload()    {        $this->autoReload = false;    }    /**     * Checks if the auto_reload option is enabled.     *     * @return bool true if auto_reload is enabled, false otherwise     */    public function isAutoReload()    {        return $this->autoReload;    }    /**     * Enables the strict_variables option.     */    public function enableStrictVariables()    {        $this->strictVariables = true;        $this->updateOptionsHash();    }    /**     * Disables the strict_variables option.     */    public function disableStrictVariables()    {        $this->strictVariables = false;        $this->updateOptionsHash();    }    /**     * Checks if the strict_variables option is enabled.     *     * @return bool true if strict_variables is enabled, false otherwise     */    public function isStrictVariables()    {        return $this->strictVariables;    }    /**     * Gets the current cache implementation.     *     * @param bool $original Whether to return the original cache option or the real cache instance     *     * @return CacheInterface|string|false A Twig\Cache\CacheInterface implementation,     *                                     an absolute path to the compiled templates,     *                                     or false to disable cache     */    public function getCache($original = true)    {        return $original ? $this->originalCache : $this->cache;    }    /**     * Sets the current cache implementation.     *     * @param CacheInterface|string|false $cache A Twig\Cache\CacheInterface implementation,     *                                           an absolute path to the compiled templates,     *                                           or false to disable cache     */    public function setCache($cache)    {        if (\is_string($cache)) {            $this->originalCache = $cache;            $this->cache = new FilesystemCache($cache);        } elseif (false === $cache) {            $this->originalCache = $cache;            $this->cache = new NullCache();        } elseif ($cache instanceof CacheInterface) {            $this->originalCache = $this->cache = $cache;        } else {            throw new \LogicException('Cache can only be a string, false, or a \Twig\Cache\CacheInterface implementation.');        }    }    /**     * Gets the template class associated with the given string.     *     * The generated template class is based on the following parameters:     *     *  * The cache key for the given template;     *  * The currently enabled extensions;     *  * Whether the Twig C extension is available or not;     *  * PHP version;     *  * Twig version;     *  * Options with what environment was created.     *     * @param string   $name  The name for which to calculate the template class name     * @param int|null $index The index if it is an embedded template     *     * @internal     */    public function getTemplateClass(string $name, int $index = null): string    {        $key = $this->getLoader()->getCacheKey($name).$this->optionsHash;        return $this->templateClassPrefix.hash('sha256', $key).(null === $index ? '' : '___'.$index);    }    /**     * Renders a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws SyntaxError  When an error occurred during compilation     * @throws RuntimeError When an error occurred during rendering     */    public function render($name, array $context = []): string    {        return $this->load($name)->render($context);    }    /**     * Displays a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws SyntaxError  When an error occurred during compilation     * @throws RuntimeError When an error occurred during rendering     */    public function display($name, array $context = []): void    {        $this->load($name)->display($context);    }    /**     * Loads a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws RuntimeError When a previously generated cache is corrupted     * @throws SyntaxError  When an error occurred during compilation     */    public function load($name): TemplateWrapper    {        if ($name instanceof TemplateWrapper) {            return $name;        }        return new TemplateWrapper($this, $this->loadTemplate($this->getTemplateClass($name), $name));    }    /**     * Loads a template internal representation.     *     * This method is for internal use only and should never be called     * directly.     *     * @param string $name  The template name     * @param int    $index The index if it is an embedded template     *     * @throws LoaderError  When the template cannot be found     * @throws RuntimeError When a previously generated cache is corrupted     * @throws SyntaxError  When an error occurred during compilation     *     * @internal     */    public function loadTemplate(string $cls, string $name, int $index = null): Template    {        $mainCls = $cls;        if (null !== $index) {            $cls .= '___'.$index;        }        if (isset($this->loadedTemplates[$cls])) {            return $this->loadedTemplates[$cls];        }        if (!class_exists($cls, false)) {            $key = $this->cache->generateKey($name, $mainCls);            if (!$this->isAutoReload() || $this->isTemplateFresh($name, $this->cache->getTimestamp($key))) {                $this->cache->load($key);            }            $source = null;            if (!class_exists($cls, false)) {                $source = $this->getLoader()->getSourceContext($name);                $content = $this->compileSource($source);                $this->cache->write($key, $content);                $this->cache->load($key);                if (!class_exists($mainCls, false)) {                    /* Last line of defense if either $this->bcWriteCacheFile was used,                     * $this->cache is implemented as a no-op or we have a race condition                     * where the cache was cleared between the above calls to write to and load from                     * the cache.                     */                    eval('?>'.$content);                }                if (!class_exists($cls, false)) {                    throw new RuntimeError(sprintf('Failed to load Twig template ""%s"", index ""%s"": cache might be corrupted.', $name, $index), -1, $source);                }            }        }        $this->extensionSet->initRuntime();        return $this->loadedTemplates[$cls] = new $cls($this);    }    /**     * Creates a template from source.     *     * This method should not be used as a generic way to load templates.     *     * @param string $template The template source     * @param string $name     An optional name of the template to be used in error messages     *     * @throws LoaderError When the template cannot be found     * @throws SyntaxError When an error occurred during compilation     */    public function createTemplate(string $template, string $name = null): TemplateWrapper    {        $hash = hash('sha256', $template, false);        if (null !== $name) {            $name = sprintf('%s (string template %s)', $name, $hash);        } else {            $name = sprintf('__string_template__%s', $hash);        }        $loader = new ChainLoader([            new ArrayLoader([$name => $template]),            $current = $this->getLoader(),        ]);        $this->setLoader($loader);        try {            return new TemplateWrapper($this, $this->loadTemplate($this->getTemplateClass($name), $name));        } finally {            $this->setLoader($current);        }    }    /**     * Returns true if the template is still fresh.     *     * Besides checking the loader for freshness information,     * this method also checks if the enabled extensions have     * not changed.     *     * @param int $time The last modification time of the cached template     */    public function isTemplateFresh(string $name, int $time): bool    {        return $this->extensionSet->getLastModified() <= $time && $this->getLoader()->isFresh($name, $time);    }    /**     * Tries to load a template consecutively from an array.     *     * Similar to load() but it also accepts instances of \Twig\Template and     * \Twig\TemplateWrapper, and an array of templates where each is tried to be loaded.     *     * @param string|TemplateWrapper|array $names A template or an array of templates to try consecutively     *     * @throws LoaderError When none of the templates can be found     * @throws SyntaxError When an error occurred during compilation     */    public function resolveTemplate($names): TemplateWrapper    {        if (!\is_array($names)) {            return $this->load($names);        }        foreach ($names as $name) {            try {                return $this->load($name);            } catch (LoaderError $e) {            }        }        throw new LoaderError(sprintf('Unable to find one of the following templates: ""%s"".', implode('"", ""', $names)));    }    public function setLexer(Lexer $lexer)    {        $this->lexer = $lexer;    }    /**     * @throws SyntaxError When the code is syntactically wrong     */    public function tokenize(Source $source): TokenStream    {        if (null === $this->lexer) {            $this->lexer = new Lexer($this);        }        return $this->lexer->tokenize($source);    }    public function setParser(Parser $parser)    {        $this->parser = $parser;    }    /**     * Converts a token stream to a node tree.     *     * @throws SyntaxError When the token stream is syntactically or semantically wrong     */    public function parse(TokenStream $stream): ModuleNode    {        if (null === $this->parser) {            $this->parser = new Parser($this);        }        return $this->parser->parse($stream);    }    public function setCompiler(Compiler $compiler)    {        $this->compiler = $compiler;    }    /**     * Compiles a node and returns the PHP code.     */    public function compile(Node $node): string    {        if (null === $this->compiler) {            $this->compiler = new Compiler($this);        }        return $this->compiler->compile($node)->getSource();    }    /**     * Compiles a template source code.     *     * @throws SyntaxError When there was an error during tokenizing, parsing or compiling     */    public function compileSource(Source $source): string    {        try {            return $this->compile($this->parse($this->tokenize($source)));        } catch (Error $e) {            $e->setSourceContext($source);            throw $e;        } catch (\Exception $e) {            throw new SyntaxError(sprintf('An exception has been thrown during the compilation of a template (""%s"").', $e->getMessage()), -1, $source, $e);        }    }    public function setLoader(LoaderInterface $loader)    {        $this->loader = $loader;    }    public function getLoader(): LoaderInterface    {        return $this->loader;    }    public function setCharset(string $charset)    {        if ('UTF8' === $charset = null === $charset ? null : strtoupper($charset)) {            // iconv on Windows requires ""UTF-8"" instead of ""UTF8""            $charset = 'UTF-8';        }        $this->charset = $charset;    }    public function getCharset(): string    {        return $this->charset;    }    public function hasExtension(string $class): bool    {        return $this->extensionSet->hasExtension($class);    }    public function addRuntimeLoader(RuntimeLoaderInterface $loader)    {        $this->runtimeLoaders[] = $loader;    }    public function getExtension(string $class): ExtensionInterface    {        return $this->extensionSet->getExtension($class);    }    /**     * Returns the runtime implementation of a Twig element (filter/function/tag/test).     *     * @param string $class A runtime class name     *     * @return object The runtime implementation     *     * @throws RuntimeError When the template cannot be found     */    public function getRuntime(string $class)    {        if (isset($this->runtimes[$class])) {            return $this->runtimes[$class];        }        foreach ($this->runtimeLoaders as $loader) {            if (null !== $runtime = $loader->load($class)) {                return $this->runtimes[$class] = $runtime;            }        }        throw new RuntimeError(sprintf('Unable to load the ""%s"" runtime.', $class));    }    public function addExtension(ExtensionInterface $extension)    {        $this->extensionSet->addExtension($extension);        $this->updateOptionsHash();    }    /**     * @param ExtensionInterface[] $extensions An array of extensions     */    public function setExtensions(array $extensions)    {        $this->extensionSet->setExtensions($extensions);        $this->updateOptionsHash();    }    /**     * @return ExtensionInterface[] An array of extensions (keys are for internal usage only and should not be relied on)     */    public function getExtensions(): array    {        return $this->extensionSet->getExtensions();    }    public function addTokenParser(TokenParserInterface $parser)    {        $this->extensionSet->addTokenParser($parser);    }    /**     * @return TokenParserInterface[]     *     * @internal     */    public function getTokenParsers(): array    {        return $this->extensionSet->getTokenParsers();    }    /**     * @internal     */    public function getTokenParser(string $name): ?TokenParserInterface    {        return $this->extensionSet->getTokenParser($name);    }    public function registerUndefinedTokenParserCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedTokenParserCallback($callable);    }    public function addNodeVisitor(NodeVisitorInterface $visitor)    {        $this->extensionSet->addNodeVisitor($visitor);    }    /**     * @return NodeVisitorInterface[]     *     * @internal     */    public function getNodeVisitors(): array    {        return $this->extensionSet->getNodeVisitors();    }    public function addFilter(TwigFilter $filter)    {        $this->extensionSet->addFilter($filter);    }    /**     * @internal     */    public function getFilter(string $name): ?TwigFilter    {        return $this->extensionSet->getFilter($name);    }    public function registerUndefinedFilterCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedFilterCallback($callable);    }    /**     * Gets the registered Filters.     *     * Be warned that this method cannot return filters defined with registerUndefinedFilterCallback.     *     * @return TwigFilter[]     *     * @see registerUndefinedFilterCallback     *     * @internal     */    public function getFilters(): array    {        return $this->extensionSet->getFilters();    }    public function addTest(TwigTest $test)    {        $this->extensionSet->addTest($test);    }    /**     * @return TwigTest[]     *     * @internal     */    public function getTests(): array    {        return $this->extensionSet->getTests();    }    /**     * @internal     */    public function getTest(string $name): ?TwigTest    {        return $this->extensionSet->getTest($name);    }    public function addFunction(TwigFunction $function)    {        $this->extensionSet->addFunction($function);    }    /**     * @internal     */    public function getFunction(string $name): ?TwigFunction    {        return $this->extensionSet->getFunction($name);    }    public function registerUndefinedFunctionCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedFunctionCallback($callable);    }    /**     * Gets registered functions.     *     * Be warned that this method cannot return functions defined with registerUndefinedFunctionCallback.     *     * @return TwigFunction[]     *     * @see registerUndefinedFunctionCallback     *     * @internal     */    public function getFunctions(): array    {        return $this->extensionSet->getFunctions();    }    /**     * Registers a Global.     *     * New globals can be added before compiling or rendering a template;     * but after, you can only update existing globals.     *     * @param mixed $value The global value     */    public function addGlobal(string $name, $value)    {        if ($this->extensionSet->isInitialized() && !\array_key_exists($name, $this->getGlobals())) {            throw new \LogicException(sprintf('Unable to add global ""%s"" as the runtime or the extensions have already been initialized.', $name));        }        if (null !== $this->resolvedGlobals) {            $this->resolvedGlobals[$name] = $value;        } else {            $this->globals[$name] = $value;        }    }    /**     * @internal     */    public function getGlobals(): array    {        if ($this->extensionSet->isInitialized()) {            if (null === $this->resolvedGlobals) {                $this->resolvedGlobals = array_merge($this->extensionSet->getGlobals(), $this->globals);            }            return $this->resolvedGlobals;        }        return array_merge($this->extensionSet->getGlobals(), $this->globals);    }    public function mergeGlobals(array $context): array    {        // we don't use array_merge as the context being generally        // bigger than globals, this code is faster.        foreach ($this->getGlobals() as $key => $value) {            if (!\array_key_exists($key, $context)) {                $context[$key] = $value;            }        }        return $context;    }    /**     * @internal     */    public function getUnaryOperators(): array    {        return $this->extensionSet->getUnaryOperators();    }    /**     * @internal     */    public function getBinaryOperators(): array    {        return $this->extensionSet->getBinaryOperators();    }    private function updateOptionsHash(): void    {        $this->optionsHash = implode(':', [            $this->extensionSet->getSignature(),            \PHP_MAJOR_VERSION,            \PHP_MINOR_VERSION,            self::VERSION,            (int) $this->debug,            (int) $this->strictVariables,        ]);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Environment_9163," Registers a Global.\n\n New globals can be added before compiling or rendering a template;\n but after, you can only update existing globals.\n\n @param mixed $value The global value\n", Registers a Global.,"    public function addGlobal(string $name, $value)    {        if ($this->extensionSet->isInitialized() && !\array_key_exists($name, $this->getGlobals())) {            throw new \LogicException(sprintf('Unable to add global ""%s"" as the runtime or the extensions have already been initialized.', $name));        }        if (null !== $this->resolvedGlobals) {            $this->resolvedGlobals[$name] = $value;        } else {            $this->globals[$name] = $value;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_ExpressionParser_10117," Parses expressions.\n\n This parser implements a ""Precedence climbing"" algorithm.\n\n @see https://www.engr.mun.ca/~theo/Misc/exp_parsing.htm\n @see https://en.wikipedia.org/wiki/Operator-precedence_parser\n\n @author Fabien Potencier <fabien@symfony.com>\n\n @internal\n", Parses expressions.,"class ExpressionParser{    public const OPERATOR_LEFT = 1;    public const OPERATOR_RIGHT = 2;    private $parser;    private $env;    private $unaryOperators;    private $binaryOperators;    public function __construct(Parser $parser, Environment $env)    {        $this->parser = $parser;        $this->env = $env;        $this->unaryOperators = $env->getUnaryOperators();        $this->binaryOperators = $env->getBinaryOperators();    }    public function parseExpression($precedence = 0, $allowArrow = false)    {        if ($allowArrow && $arrow = $this->parseArrow()) {            return $arrow;        }        $expr = $this->getPrimary();        $token = $this->parser->getCurrentToken();        while ($this->isBinary($token) && $this->binaryOperators[$token->getValue()]['precedence'] >= $precedence) {            $op = $this->binaryOperators[$token->getValue()];            $this->parser->getStream()->next();            if ('is not' === $token->getValue()) {                $expr = $this->parseNotTestExpression($expr);            } elseif ('is' === $token->getValue()) {                $expr = $this->parseTestExpression($expr);            } elseif (isset($op['callable'])) {                $expr = $op['callable']($this->parser, $expr);            } else {                $expr1 = $this->parseExpression(self::OPERATOR_LEFT === $op['associativity'] ? $op['precedence'] + 1 : $op['precedence']);                $class = $op['class'];                $expr = new $class($expr, $expr1, $token->getLine());            }            $token = $this->parser->getCurrentToken();        }        if (0 === $precedence) {            return $this->parseConditionalExpression($expr);        }        return $expr;    }    /**     * @return ArrowFunctionExpression|null     */    private function parseArrow()    {        $stream = $this->parser->getStream();        // short array syntax (one argument, no parentheses)?        if ($stream->look(1)->test(/* Token::ARROW_TYPE */ 12)) {            $line = $stream->getCurrent()->getLine();            $token = $stream->expect(/* Token::NAME_TYPE */ 5);            $names = [new AssignNameExpression($token->getValue(), $token->getLine())];            $stream->expect(/* Token::ARROW_TYPE */ 12);            return new ArrowFunctionExpression($this->parseExpression(0), new Node($names), $line);        }        // first, determine if we are parsing an arrow function by finding => (long form)        $i = 0;        if (!$stream->look($i)->test(/* Token::PUNCTUATION_TYPE */ 9, '(')) {            return null;        }        ++$i;        while (true) {            // variable name            ++$i;            if (!$stream->look($i)->test(/* Token::PUNCTUATION_TYPE */ 9, ',')) {                break;            }            ++$i;        }        if (!$stream->look($i)->test(/* Token::PUNCTUATION_TYPE */ 9, ')')) {            return null;        }        ++$i;        if (!$stream->look($i)->test(/* Token::ARROW_TYPE */ 12)) {            return null;        }        // yes, let's parse it properly        $token = $stream->expect(/* Token::PUNCTUATION_TYPE */ 9, '(');        $line = $token->getLine();        $names = [];        while (true) {            $token = $stream->expect(/* Token::NAME_TYPE */ 5);            $names[] = new AssignNameExpression($token->getValue(), $token->getLine());            if (!$stream->nextIf(/* Token::PUNCTUATION_TYPE */ 9, ',')) {                break;            }        }        $stream->expect(/* Token::PUNCTUATION_TYPE */ 9, ')');        $stream->expect(/* Token::ARROW_TYPE */ 12);        return new ArrowFunctionExpression($this->parseExpression(0), new Node($names), $line);    }    private function getPrimary(): AbstractExpression    {        $token = $this->parser->getCurrentToken();        if ($this->isUnary($token)) {            $operator = $this->unaryOperators[$token->getValue()];            $this->parser->getStream()->next();            $expr = $this->parseExpression($operator['precedence']);            $class = $operator['class'];            return $this->parsePostfixExpression(new $class($expr, $token->getLine()));        } elseif ($token->test(/* Token::PUNCTUATION_TYPE */ 9, '(')) {            $this->parser->getStream()->next();            $expr = $this->parseExpression();            $this->parser->getStream()->expect(/* Token::PUNCTUATION_TYPE */ 9, ')', 'An opened parenthesis is not properly closed');            return $this->parsePostfixExpression($expr);        }        return $this->parsePrimaryExpression();    }    private function parseConditionalExpression($expr): AbstractExpression    {        while ($this->parser->getStream()->nextIf(/* Token::PUNCTUATION_TYPE */ 9, '?')) {            if (!$this->parser->getStream()->nextIf(/* Token::PUNCTUATION_TYPE */ 9, ':')) {                $expr2 = $this->parseExpression();                if ($this->parser->getStream()->nextIf(/* Token::PUNCTUATION_TYPE */ 9, ':')) {                    $expr3 = $this->parseExpression();                } else {                    $expr3 = new ConstantExpression('', $this->parser->getCurrentToken()->getLine());                }            } else {                $expr2 = $expr;                $expr3 = $this->parseExpression();            }            $expr = new ConditionalExpression($expr, $expr2, $expr3, $this->parser->getCurrentToken()->getLine());        }        return $expr;    }    private function isUnary(Token $token): bool    {        return $token->test(/* Token::OPERATOR_TYPE */ 8) && isset($this->unaryOperators[$token->getValue()]);    }    private function isBinary(Token $token): bool    {        return $token->test(/* Token::OPERATOR_TYPE */ 8) && isset($this->binaryOperators[$token->getValue()]);    }    public function parsePrimaryExpression()    {        $token = $this->parser->getCurrentToken();        switch ($token->getType()) {            case /* Token::NAME_TYPE */ 5:                $this->parser->getStream()->next();                switch ($token->getValue()) {                    case 'true':                    case 'TRUE':                        $node = new ConstantExpression(true, $token->getLine());                        break;                    case 'false':                    case 'FALSE':                        $node = new ConstantExpression(false, $token->getLine());                        break;                    case 'none':                    case 'NONE':                    case 'null':                    case 'NULL':                        $node = new ConstantExpression(null, $token->getLine());                        break;                    default:                        if ('(' === $this->parser->getCurrentToken()->getValue()) {                            $node = $this->getFunctionNode($token->getValue(), $token->getLine());                        } else {                            $node = new NameExpression($token->getValue(), $token->getLine());                        }                }                break;            case /* Token::NUMBER_TYPE */ 6:                $this->parser->getStream()->next();                $node = new ConstantExpression($token->getValue(), $token->getLine());                break;            case /* Token::STRING_TYPE */ 7:            case /* Token::INTERPOLATION_START_TYPE */ 10:                $node = $this->parseStringExpression();                break;            case /* Token::OPERATOR_TYPE */ 8:                if (preg_match(Lexer::REGEX_NAME, $token->getValue(), $matches) && $matches[0] == $token->getValue()) {                    // in this context, string operators are variable names                    $this->parser->getStream()->next();                    $node = new NameExpression($token->getValue(), $token->getLine());                    break;                }                if (isset($this->unaryOperators[$token->getValue()])) {                    $class = $this->unaryOperators[$token->getValue()]['class'];                    if (!\in_array($class, [NegUnary::class, PosUnary::class])) {                        throw new SyntaxError(sprintf('Unexpected unary operator ""%s"".', $token->getValue()), $token->getLine(), $this->parser->getStream()->getSourceContext());                    }                    $this->parser->getStream()->next();                    $expr = $this->parsePrimaryExpression();                    $node = new $class($expr, $token->getLine());                    break;                }                // no break            default:                if ($token->test(/* Token::PUNCTUATION_TYPE */ 9, '[')) {                    $node = $this->parseArrayExpression();                } elseif ($token->test(/* Token::PUNCTUATION_TYPE */ 9, '{')) {                    $node = $this->parseHashExpression();                } elseif ($token->test(/* Token::OPERATOR_TYPE */ 8, '=') && ('==' === $this->parser->getStream()->look(-1)->getValue() || '!=' === $this->parser->getStream()->look(-1)->getValue())) {                    throw new SyntaxError(sprintf('Unexpected operator of value ""%s"". Did you try to use ""==="" or ""!=="" for strict comparison? Use ""is same as(value)"" instead.', $token->getValue()), $token->getLine(), $this->parser->getStream()->getSourceContext());                } else {                    throw new SyntaxError(sprintf('Unexpected token ""%s"" of value ""%s"".', Token::typeToEnglish($token->getType()), $token->getValue()), $token->getLine(), $this->parser->getStream()->getSourceContext());                }        }        return $this->parsePostfixExpression($node);    }    public function parseStringExpression()    {        $stream = $this->parser->getStream();        $nodes = [];        // a string cannot be followed by another string in a single expression        $nextCanBeString = true;        while (true) {            if ($nextCanBeString && $token = $stream->nextIf(/* Token::STRING_TYPE */ 7)) {                $nodes[] = new ConstantExpression($token->getValue(), $token->getLine());                $nextCanBeString = false;            } elseif ($stream->nextIf(/* Token::INTERPOLATION_START_TYPE */ 10)) {                $nodes[] = $this->parseExpression();                $stream->expect(/* Token::INTERPOLATION_END_TYPE */ 11);                $nextCanBeString = true;            } else {                break;            }        }        $expr = array_shift($nodes);        foreach ($nodes as $node) {            $expr = new ConcatBinary($expr, $node, $node->getTemplateLine());        }        return $expr;    }    public function parseArrayExpression()    {        $stream = $this->parser->getStream();        $stream->expect(/* Token::PUNCTUATION_TYPE */ 9, '[', 'An array element was expected');        $node = new ArrayExpression([], $stream->getCurrent()->getLine());        $first = true;        while (!$stream->test(/* Token::PUNCTUATION_TYPE */ 9, ']')) {            if (!$first) {                $stream->expect(/* Token::PUNCTUATION_TYPE */ 9, ',', 'An array element must be followed by a comma');                // trailing ,?                if ($stream->test(/* Token::PUNCTUATION_TYPE */ 9, ']')) {                    break;                }            }            $first = false;            $node->addElement($this->parseExpression());        }        $stream->expect(/* Token::PUNCTUATION_TYPE */ 9, ']', 'An opened array is not properly closed');        return $node;    }    public function parseHashExpression()    {        $stream = $this->parser->getStream();        $stream->expect(/* Token::PUNCTUATION_TYPE */ 9, '{', 'A hash element was expected');        $node = new ArrayExpression([], $stream->getCurrent()->getLine());        $first = true;        while (!$stream->test(/* Token::PUNCTUATION_TYPE */ 9, '}')) {            if (!$first) {                $stream->expect(/* Token::PUNCTUATION_TYPE */ 9, ',', 'A hash value must be followed by a comma');                // trailing ,?                if ($stream->test(/* Token::PUNCTUATION_TYPE */ 9, '}')) {                    break;                }            }            $first = false;            // a hash key can be:            //            //  * a number -- 12            //  * a string -- 'a'            //  * a name, which is equivalent to a string -- a            //  * an expression, which must be enclosed in parentheses -- (1 + 2)            if ($token = $stream->nextIf(/* Token::NAME_TYPE */ 5)) {                $key = new ConstantExpression($token->getValue(), $token->getLine());                // {a} is a shortcut for {a:a}                if ($stream->test(Token::PUNCTUATION_TYPE, [',', '}'])) {                    $value = new NameExpression($key->getAttribute('value'), $key->getTemplateLine());                    $node->addElement($value, $key);                    continue;                }            } elseif (($token = $stream->nextIf(/* Token::STRING_TYPE */ 7)) || $token = $stream->nextIf(/* Token::NUMBER_TYPE */ 6)) {                $key = new ConstantExpression($token->getValue(), $token->getLine());            } elseif ($stream->test(/* Token::PUNCTUATION_TYPE */ 9, '(')) {                $key = $this->parseExpression();            } else {                $current = $stream->getCurrent();                throw new SyntaxError(sprintf('A hash key must be a quoted string, a number, a name, or an expression enclosed in parentheses (unexpected token ""%s"" of value ""%s"".', Token::typeToEnglish($current->getType()), $current->getValue()), $current->getLine(), $stream->getSourceContext());            }            $stream->expect(/* Token::PUNCTUATION_TYPE */ 9, ':', 'A hash key must be followed by a colon (:)');            $value = $this->parseExpression();            $node->addElement($value, $key);        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_ExpressionParser_10119," checks that the node only contains ""constant"" elements\n"," checks that the node only contains ""constant"" elements",    private function checkConstantExpression(Node $node): bool    {        if (!($node instanceof ConstantExpression || $node instanceof ArrayExpression            || $node instanceof NegUnary || $node instanceof PosUnary        )) {            return false;        }        foreach ($node as $n) {            if (!$this->checkConstantExpression($n)) {                return false;            }        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_FileExtensionEscapingStrategy_8260," Default autoescaping strategy based on file names.\n\n This strategy sets the HTML as the default autoescaping strategy,\n but changes it based on the template name.\n\n Note that there is no runtime performance impact as the\n default autoescaping strategy is set at compilation time.\n\n @author Fabien Potencier <fabien@symfony.com>\n", Default autoescaping strategy based on file names.,"class FileExtensionEscapingStrategy{    /**     * Guesses the best autoescaping strategy based on the file name.     *     * @param string $name The template name     *     * @return string|false The escaping strategy name to use or false to disable     */    public static function guess(string $name)    {        if (\in_array(substr($name, -1), ['/', '\\'])) {            return 'html'; // return html for directories        }        if ('.twig' === substr($name, -5)) {            $name = substr($name, 0, -5);        }        $extension = pathinfo($name, \PATHINFO_EXTENSION);        switch ($extension) {            case 'js':                return 'js';            case 'css':                return 'css';            case 'txt':                return false;            default:                return 'html';        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_FilesystemHelper_8279," This file is part of Twig.\n\n (c) Fabien Potencier\n\n For the full copyright and license information, please view the LICENSE\n file that was distributed with this source code.\n", This file is part of Twig.,"class FilesystemHelper{    public static function removeDir($dir)    {        $iterator = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($dir, \FilesystemIterator::SKIP_DOTS), \RecursiveIteratorIterator::CHILD_FIRST);        foreach ($iterator as $filename => $fileInfo) {            if ($fileInfo->isDir()) {                rmdir($filename);            } else {                unlink($filename);            }        }        rmdir($dir);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_IntegrationTest_10149," This class is used in tests for the ""length"" filter and ""empty"" test. It asserts that __call is not\n used to convert such objects to strings.\n"," This class is used in tests for the ""length"" filter and ""empty"" test. It asserts that __call is not","class MagicCallStub{    public function __call($name, $args)    {        throw new \Exception('__call shall not be called');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_IntegrationTest_8282," This class is used in tests for the length filter and empty test to show\n that when \\Countable is implemented, it is preferred over the __toString()\n method.\n", This class is used in tests for the length filter and empty test to show,class CountableStub implements \Countable{    private $count;    public function __construct($count)    {        $this->count = $count;    }    public function count()    {        return $this->count;    }    public function __toString()    {        throw new \Exception('__toString shall not be called on \Countables');    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_IntegrationTest_8283, This class is used in tests for the length filter.\n, This class is used in tests for the length filter.,class IteratorAggregateStub implements \IteratorAggregate{    private $data;    public function __construct(array $data)    {        $this->data = $data;    }    public function getIterator()    {        return new \ArrayIterator($this->data);    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Markup_8263, Marks a content as safe.\n\n @author Fabien Potencier <fabien@symfony.com>\n, Marks a content as safe.,"class Markup implements \Countable, \JsonSerializable{    private $content;    private $charset;    public function __construct($content, $charset)    {        $this->content = (string) $content;        $this->charset = $charset;    }    public function __toString()    {        return $this->content;    }    /**     * @return int     */    public function count()    {        return mb_strlen($this->content, $this->charset);    }    #[\ReturnTypeWillChange]    public function jsonSerialize()    {        return $this->content;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_NodeTraverser_9184, A node traverser.\n\n It visits all nodes and their children and calls the given visitor for each.\n\n @author Fabien Potencier <fabien@symfony.com>\n, A node traverser.,"final class NodeTraverser{    private $env;    private $visitors = [];    /**     * @param NodeVisitorInterface[] $visitors     */    public function __construct(Environment $env, array $visitors = [])    {        $this->env = $env;        foreach ($visitors as $visitor) {            $this->addVisitor($visitor);        }    }    public function addVisitor(NodeVisitorInterface $visitor): void    {        $this->visitors[$visitor->getPriority()][] = $visitor;    }    /**     * Traverses a node and calls the registered visitors.     */    public function traverse(Node $node): Node    {        ksort($this->visitors);        foreach ($this->visitors as $visitors) {            foreach ($visitors as $visitor) {                $node = $this->traverseForVisitor($visitor, $node);            }        }        return $node;    }    private function traverseForVisitor(NodeVisitorInterface $visitor, Node $node): ?Node    {        $node = $visitor->enterNode($node, $this->env);        foreach ($node as $k => $n) {            if (null !== $m = $this->traverseForVisitor($visitor, $n)) {                if ($m !== $n) {                    $node->setNode($k, $m);                }            } else {                $node->removeNode($k);            }        }        return $visitor->leaveNode($node, $this->env);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_NodeTraverser_9185, Traverses a node and calls the registered visitors.\n, Traverses a node and calls the registered visitors.,"    public function traverse(Node $node): Node    {        ksort($this->visitors);        foreach ($this->visitors as $visitors) {            foreach ($visitors as $visitor) {                $node = $this->traverseForVisitor($visitor, $node);            }        }        return $node;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_Factory_1236, Add a claim to the Payload.\n\n @param  string  $name\n @param  mixed  $value\n\n @return $this\n, Add a claim to the Payload.,"    protected function addClaim($name, $value)    {        $this->claims->put($name, $value);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_Factory_1240, Get a Payload instance with a claims collection.\n\n @param  \\Tymon\\JWTAuth\\Claims\\Collection  $claims\n\n @return \\Tymon\\JWTAuth\\Payload\n, Get a Payload instance with a claims collection.,"    public function withClaims(Collection $claims)    {        return new Payload($claims, $this->validator, $this->refreshFlow);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_Factory_1243, Helper to get the ttl.\n\n @return int\n, Helper to get the ttl.,    public function getTTL()    {        return $this->claimFactory->getTTL();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWTGuard_1280, Create a token for a user.\n\n @param  \\Tymon\\JWTAuth\\Contracts\\JWTSubject  $user\n\n @return string\n, Create a token for a user.,    public function login(JWTSubject $user)    {        $token = $this->jwt->fromUser($user);        $this->setToken($token)->setUser($user);        return $token;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWTGuard_1283, Alias for onceUsingId.\n\n @param  mixed  $id\n\n @return bool\n, Alias for onceUsingId.,    public function byId($id)    {        return $this->onceUsingId($id);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWTGuard_1287, Set the token.\n\n @param  \\Tymon\\JWTAuth\\Token|string  $token\n\n @return $this\n, Set the token.,    public function setToken($token)    {        $this->jwt->setToken($token);        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWTGuard_1290, Set the user provider used by the guard.\n\n @param  \\Illuminate\\Contracts\\Auth\\UserProvider  $provider\n\n @return $this\n, Set the user provider used by the guard.,    public function setProvider(UserProvider $provider)    {        $this->provider = $provider;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWT_1252, Parse the token from the request.\n\n @throws \\Tymon\\JWTAuth\\Exceptions\\JWTException\n\n @return $this\n, Parse the token from the request.,    public function parseToken()    {        if (! $token = $this->parser->parseToken()) {            throw new JWTException('The token could not be parsed from the request');        }        return $this->setToken($token);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWT_1253, Get the raw Payload instance.\n\n @return \\Tymon\\JWTAuth\\Payload\n, Get the raw Payload instance.,    public function getPayload()    {        $this->requireToken();        return $this->manager->decode($this->token);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWT_1254, Alias for getPayload().\n\n @return \\Tymon\\JWTAuth\\Payload\n, Alias for getPayload().,    public function payload()    {        return $this->getPayload();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWT_1263, Ensure that a token is available.\n\n @throws \\Tymon\\JWTAuth\\Exceptions\\JWTException\n\n @return void\n, Ensure that a token is available.,    protected function requireToken()    {        if (! $this->token) {            throw new JWTException('A token is required');        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWT_1265," Set whether the subject should be ""locked"".\n\n @param  bool  $lock\n\n @return $this\n"," Set whether the subject should be ""locked"".",    public function lockSubject($lock)    {        $this->lockSubject = $lock;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_JWT_1269, Get the Blacklist.\n\n @return \\Tymon\\JWTAuth\\Blacklist\n, Get the Blacklist.,    public function blacklist()    {        return $this->manager->getBlacklist();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_Manager_1304, Get the Blacklist instance.\n\n @return \\Tymon\\JWTAuth\\Blacklist\n, Get the Blacklist instance.,    public function getBlacklist()    {        return $this->blacklist;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_Payload_1313, Convert the object into something JSON serializable.\n\n @return array\n, Convert the object into something JSON serializable.,    public function jsonSerialize()    {        return $this->toArray();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_Payload_1316, Get an item at a given offset.\n\n @param  mixed  $key\n\n @return mixed\n, Get an item at a given offset.,"    public function offsetGet($key)    {        return Arr::get($this->toArray(), $key);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tymondesigns_jwt-auth_Payload_1318, Don't allow changing the payload as it should be immutable.\n\n @param  string  $key\n\n @throws \\Tymon\\JWTAuth\\Exceptions\\PayloadException\n\n @return void\n, Don't allow changing the payload as it should be immutable.,    public function offsetUnset($key)    {        throw new PayloadException('The payload is immutable');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
typecho_typecho_HyperDown_1341, Parser\\n\\n @copyright Copyright (c) 2012 SegmentFault Team. (http://segmentfault.com)\\n @author Joyqi <joyqi@segmentfault.com>\\n @license BSD License\\n, Parser,"class HyperDown{    /**     * _whiteList     *     * @var string     */    public $_commonWhiteList = 'kbd|b|i|strong|em|sup|sub|br|code|del|a|hr|small';    /**     * html tags     *     * @var string     */    public $_blockHtmlTags = 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|address|form|fieldset|iframe|hr|legend|article|section|nav|aside|hgroup|header|footer|figcaption|svg|script|noscript';    /**     * _specialWhiteList     *     * @var mixed     * @access private     */    public $_specialWhiteList = array(        'table'  =>  'table|tbody|thead|tfoot|tr|td|th'    );    /**     * _footnotes     *     * @var array     */    public $_footnotes;    /**     * @var bool     */    public $_html = false;    /**     * @var bool     */    public $_line = false;    /**     * @var array     */    public $blockParsers = array(        array('code', 10),        array('shtml', 20),        array('pre', 30),        array('ahtml', 40),        array('shr', 50),        array('list', 60),        array('math', 70),        array('html', 80),        array('footnote', 90),        array('definition', 100),        array('quote', 110),        array('table', 120),        array('sh', 130),        array('mh', 140),        array('dhr', 150),        array('default', 9999)    );    /**     * _blocks     *     * @var array     */    private $_blocks;    /**     * _current     *     * @var string     */    private $_current;    /**     * _pos     *     * @var int     */    private $_pos;    /**     * _definitions     *     * @var array     */    public $_definitions;    /**     * @var array     */    private $_hooks = array();    /**     * @var array     */    private $_holders;    /**     * @var string     */    private $_uniqid;    /**     * @var int     */    private $_id;    /**     * @var array     */    private $_parsers = array();    /**     * makeHtml     *     * @param mixed $text     * @return string     */    public function makeHtml($text)    {        $this->_footnotes = array();        $this->_definitions = array();        $this->_holders = array();        $this->_uniqid = md5(uniqid());        $this->_id = 0;        usort($this->blockParsers, function ($a, $b) {            return $a[1] < $b[1] ? -1 : 1;        });        foreach ($this->blockParsers as $parser) {            list($name) = $parser;            if (isset($parser[2])) {                $this->_parsers[$name] = $parser[2];            } else {                $this->_parsers[$name] = array($this, 'parseBlock' . ucfirst($name));            }        }        $text = $this->initText($text);        $html = $this->parse($text);        $html = $this->makeFootnotes($html);        $html = $this->optimizeLines($html);        return $this->call('makeHtml', $html);    }    /**     * @param $html     */    public function enableHtml($html = true)    {        $this->_html = $html;    }    /**     * @param bool $line     */    public function enableLine($line = true)    {        $this->_line = $line;    }    /**     * @param $type     * @param $callback     */    public function hook($type, $callback)    {        $this->_hooks[$type][] = $callback;    }    /**     * @param $str     * @return string     */    public function makeHolder($str)    {        $key = ""\r"" . $this->_uniqid . $this->_id . ""\r"";        $this->_id ++;        $this->_holders[$key] = $str;        return $key;    }    /**     * @param $text     * @return mixed     */    private function initText($text)    {        $text = str_replace(array(""\t"", ""\r""),  array('    ', ''),  $text);        return $text;    }    /**     * @param $html     * @return string     */    private function makeFootnotes($html)    {        if (count($this->_footnotes) > 0) {            $html .= '<div class=""footnotes""><hr><ol>';            $index = 1;            while ($val = array_shift($this->_footnotes)) {                if (is_string($val)) {                    $val .= "" <a href=\""#fnref-{$index}\"" class=\""footnote-backref\"">&#8617;</a>"";                } else {                    $val[count($val) - 1] .= "" <a href=\""#fnref-{$index}\"" class=\""footnote-backref\"">&#8617;</a>"";                    $val = count($val) > 1 ? $this->parse(implode(""\n"", $val)) : $this->parseInline($val[0]);                }                $html .= ""<li id=\""fn-{$index}\"">{$val}</li>"";                $index ++;            }            $html .= '</ol></div>';        }        return $html;    }    /**     * parse     *     * @param string $text     * @param bool $inline     * @param int $offset     * @return string     */    private function parse($text, $inline = false, $offset = 0)    {        $blocks = $this->parseBlock($text, $lines);        $html = '';        // inline mode for single normal block        if ($inline && count($blocks) == 1 && $blocks[0][0] == 'normal') {            $blocks[0][3] = true;        }        foreach ($blocks as $block) {            list($type, $start, $end, $value) = $block;            $extract = array_slice($lines, $start, $end - $start + 1);            $method = 'parse' . ucfirst($type);            $extract = $this->call('before' . ucfirst($method), $extract, $value);            $result = $this->{$method}($extract, $value, $start + $offset, $end + $offset);            $result = $this->call('after' . ucfirst($method), $result, $value);            $html .= $result;        }        return $html;    }    /**     * @param $text     * @param $clearHolders     * @return string     */    private function releaseHolder($text, $clearHolders = true)    {        $deep = 0;        while (strpos($text, ""\r"") !== false && $deep < 10) {            $text = str_replace(array_keys($this->_holders), array_values($this->_holders), $text);            $deep ++;        }        if ($clearHolders) {            $this->_holders = array();        }        return $text;    }    /**     * @param $start     * @param int $end     * @return string     */    public function markLine($start, $end = -1)    {        if ($this->_line) {            $end = $end < 0 ? $start : $end;            return '<span class=""line"" data-start=""' . $start                . '"" data-end=""' . $end . '"" data-id=""' . $this->_uniqid . '""></span>';        }        return '';    }    /**     * @param array $lines     * @param $start     * @return string[]     */    public function markLines(array $lines, $start)    {        $i = -1;        $self = $this;        return $this->_line ? array_map(function ($line) use ($self, $start, &$i) {            $i ++;            return $self->markLine($start + $i) . $line;        }, $lines) : $lines;    }    /**     * @param $html     * @return string     */    public function optimizeLines($html)    {        $last = 0;        return $this->_line ?            preg_replace_callback(""/class=\""line\"" data\-start=\""([0-9]+)\"" data\-end=\""([0-9]+)\"" (data\-id=\""{$this->_uniqid}\"")/"",                function ($matches) use (&$last) {                    if ($matches[1] != $last) {                        $replace = 'class=""line"" data-start=""' . $last . '"" data-start-original=""' . $matches[1] . '"" data-end=""' . $matches[2] . '"" ' . $matches[3];                    } else {                        $replace = $matches[0];                    }                    $last = $matches[2] + 1;                    return $replace;                }, $html) : $html;    }    /**     * @param $type     * @param $value     * @return mixed     */    public function call($type, $value)    {        if (empty($this->_hooks[$type])) {            return $value;        }        $args = func_get_args();        $args = array_slice($args, 1);        foreach ($this->_hooks[$type] as $callback) {            $value = call_user_func_array($callback, $args);            $args[0] = $value;        }        return $value;    }    /**     * parseInline     *     * @param string $text     * @param string $whiteList     * @param bool $clearHolders     * @param bool $enableAutoLink     * @return string     */    public function parseInline($text, $whiteList = '', $clearHolders = true, $enableAutoLink = true)    {        $self = $this;        $text = $this->call('beforeParseInline', $text);        // code        $text = preg_replace_callback(            ""/(^|[^\\\])(`+)(.+?)\\2/"",            function ($matches) use ($self) {                return  $matches[1] . $self->makeHolder(                        '<code>' . htmlspecialchars($matches[3]) . '</code>'                    );            },            $text        );        // mathjax        $text = preg_replace_callback(            ""/(^|[^\\\])(\\$+)(.+?)\\2/"",            function ($matches) use ($self) {                return  $matches[1] . $self->makeHolder(                        $matches[2] . htmlspecialchars($matches[3]) . $matches[2]                    );            },            $text        );        // escape        $text = preg_replace_callback(            ""/\\\(.)/u"",            function ($matches) use ($self) {                $prefix = preg_match(""/^[-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]$/"", $matches[1]) ? '' : '\\';                $escaped = htmlspecialchars($matches[1]);                $escaped = str_replace('$', '&dollar;', $escaped);                return  $self->makeHolder($prefix . $escaped);            },            $text        );        // link        $text = preg_replace_callback(            ""/<(https?:\/\/.+)>/i"",            function ($matches) use ($self) {                $url = $self->cleanUrl($matches[1]);                $link = $self->call('parseLink', $matches[1]);                return $self->makeHolder(                    ""<a href=\""{$url}\"">{$link}</a>""                );            },            $text        );        // encode unsafe tags        $text = preg_replace_callback(            ""/<(\/?)([a-z0-9-]+)(\s+[^>]*)?>/i"",            function ($matches) use ($self, $whiteList) {                if ($self->_html || false !== stripos(                        '|' . $self->_commonWhiteList . '|' . $whiteList . '|', '|' . $matches[2] . '|'                    )) {                    return $self->makeHolder($matches[0]);                } else {                    return $self->makeHolder(htmlspecialchars($matches[0]));                }            },            $text        );        if ($this->_html) {            $text = preg_replace_callback(""/<!\-\-(.*?)\-\->/"", function ($matches) use ($self) {                return $self->makeHolder($matches[0]);            }, $text);        }        $text = str_replace(array('<', '>'),  array('&lt;', '&gt;'),  $text);        // footnote        $text = preg_replace_callback(            ""/\[\^((?:[^\]]|\\\\\]|\\\\\[)+?)\]/"",            function ($matches) use ($self) {                $id = array_search($matches[1], $self->_footnotes);                if (false === $id) {                    $id = count($self->_footnotes) + 1;                    $self->_footnotes[$id] = $self->parseInline($matches[1], '', false);                }                return $self->makeHolder(                    ""<sup id=\""fnref-{$id}\""><a href=\""#fn-{$id}\"" class=\""footnote-ref\"">{$id}</a></sup>""                );            },            $text        );        // image        $text = preg_replace_callback(            ""/!\[((?:[^\]]|\\\\\]|\\\\\[)*?)\]\(((?:[^\)]|\\\\\)|\\\\\()+?)\)/"",            function ($matches) use ($self) {                $escaped = htmlspecialchars($self->escapeBracket($matches[1]));                $url = $self->escapeBracket($matches[2]);                $url = $self->cleanUrl($url);                return $self->makeHolder(                    ""<img src=\""{$url}\"" alt=\""{$escaped}\"" title=\""{$escaped}\"">""                );            },            $text        );        $text = preg_replace_callback(            ""/!\[((?:[^\]]|\\\\\]|\\\\\[)*?)\]\[((?:[^\]]|\\\\\]|\\\\\[)+?)\]/"",            function ($matches) use ($self) {                $escaped = htmlspecialchars($self->escapeBracket($matches[1]));                $result = isset( $self->_definitions[$matches[2]] ) ?                    ""<img src=\""{$self->_definitions[$matches[2]]}\"" alt=\""{$escaped}\"" title=\""{$escaped}\"">""                    : $escaped;                return $self->makeHolder($result);            },            $text        );        // link        $text = preg_replace_callback(            ""/\[((?:[^\]]|\\\\\]|\\\\\[)+?)\]\(((?:[^\)]|\\\\\)|\\\\\()+?)\)/"",            function ($matches) use ($self) {                $escaped = $self->parseInline(                    $self->escapeBracket($matches[1]),  '',  false, false                );                $url = $self->escapeBracket($matches[2]);                $url = $self->cleanUrl($url);                return $self->makeHolder(""<a href=\""{$url}\"">{$escaped}</a>"");            },            $text        );        $text = preg_replace_callback(            ""/\[((?:[^\]]|\\\\\]|\\\\\[)+?)\]\[((?:[^\]]|\\\\\]|\\\\\[)+?)\]/"",            function ($matches) use ($self) {                $escaped = $self->parseInline(                    $self->escapeBracket($matches[1]),  '',  false                );                $result = isset( $self->_definitions[$matches[2]] ) ?                    ""<a href=\""{$self->_definitions[$matches[2]]}\"">{$escaped}</a>""                    : $escaped;                return $self->makeHolder($result);            },            $text        );        // strong and em and some fuck        $text = $this->parseInlineCallback($text);        $text = preg_replace(            ""/<([_a-z0-9-\.\+]+@[^@]+\.[a-z]{2,})>/i"",            ""<a href=\""mailto:\\1\"">\\1</a>"",            $text        );        // autolink url        if ($enableAutoLink) {            $text = preg_replace_callback(                ""/(^|[^\""])((https?):\S+)($|[^\""])/i"",                function ($matches) use ($self) {                    $link = $self->call('parseLink', $matches[2]);                    return ""{$matches[1]}<a href=\""{$matches[2]}\"">{$link}</a>{$matches[4]}"";                },                $text            );        }        $text = $this->call('afterParseInlineBeforeRelease', $text);        $text = $this->releaseHolder($text, $clearHolders);        $text = $this->call('afterParseInline', $text);        return $text;    }    /**     * @param $text     * @return mixed     */    public function parseInlineCallback($text)    {        $self = $this;        $text = preg_replace_callback(            ""/(\*{3})(.+?)\\1/"",            function ($matches) use ($self) {                return  '<strong><em>' .                    $self->parseInlineCallback($matches[2]) .                    '</em></strong>';            },            $text        );        $text = preg_replace_callback(            ""/(\*{2})(.+?)\\1/"",            function ($matches) use ($self) {                return  '<strong>' .                    $self->parseInlineCallback($matches[2]) .                    '</strong>';            },            $text        );        $text = preg_replace_callback(            ""/(\*)(.+?)\\1/"",            function ($matches) use ($self) {                return  '<em>' .                    $self->parseInlineCallback($matches[2]) .                    '</em>';            },            $text        );        $text = preg_replace_callback(            ""/(\s+|^)(_{3})(.+?)\\2(\s+|$)/"",            function ($matches) use ($self) {                return  $matches[1] . '<strong><em>' .                    $self->parseInlineCallback($matches[3]) .                    '</em></strong>' . $matches[4];            },            $text        );        $text = preg_replace_callback(            ""/(\s+|^)(_{2})(.+?)\\2(\s+|$)/"",            function ($matches) use ($self) {                return  $matches[1] . '<strong>' .                    $self->parseInlineCallback($matches[3]) .                    '</strong>' . $matches[4];            },            $text        );        $text = preg_replace_callback(            ""/(\s+|^)(_)(.+?)\\2(\s+|$)/"",            function ($matches) use ($self) {                return  $matches[1] . '<em>' .                    $self->parseInlineCallback($matches[3]) .                    '</em>' . $matches[4];            },            $text        );        $text = preg_replace_callback(            ""/(~{2})(.+?)\\1/"",            function ($matches) use ($self) {                return  '<del>' .                    $self->parseInlineCallback($matches[2]) .                    '</del>';            },            $text        );        return $text;    }    /**     * parseBlock     *     * @param string $text     * @param array $lines     * @return array     */    private function parseBlock($text, &$lines)    {        $lines = explode(""\n"", $text);        $this->_blocks = array();        $this->_current = 'normal';        $this->_pos = -1;        $state = array(            'special'   =>  implode(""|"", array_keys($this->_specialWhiteList)),            'empty'     =>  0,            'html'      =>  false        );        // analyze by line        foreach ($lines as $key => $line) {            $block = $this->getBlock();            $args = array($block, $key, $line, &$state, $lines);            if ($this->_current != 'normal') {                $pass = call_user_func_array($this->_parsers[$this->_current], $args);                if (!$pass) {                    continue;                }            }            foreach ($this->_parsers as $name => $parser) {                if ($name != $this->_current) {                    $pass = call_user_func_array($parser, $args);                    if (!$pass) {                        break;                    }                }            }        }        return $this->optimizeBlocks($this->_blocks, $lines);    }    /**     * @param $block     * @param $key     * @param $line     * @param $state     * @return bool     */    private function parseBlockList($block, $key, $line, &$state)    {        if ($this->isBlock('list') && !preg_match(""/^\s*\[((?:[^\]]|\\]|\\[)+?)\]:\s*(.+)$/"", $line)) {            if (preg_match(""/^(\s*)(~{3,}|`{3,})([^`~]*)$/i"", $line)) {                // ignore code                return true;            } elseif ($state['empty'] <= 1                && preg_match(""/^(\s*)\S+/"", $line, $matches)                && strlen($matches[1]) >= ($block[3][0] + $state['empty'])) {                $state['empty'] = 0;                $this->setBlock($key);                return false;            } elseif (preg_match(""/^(\s*)$/"", $line) && $state['empty'] == 0) {                $state['empty'] ++;                $this->setBlock($key);                return false;            }        }        if (preg_match(""/^(\s*)((?:[0-9]+\.)|\-|\+|\*)\s+/i"", $line, $matches)) {            $space = strlen($matches[1]);            $tab = strlen($matches[0]) - $space;            $state['empty'] = 0;            $type = false !== strpos('+-*', $matches[2]) ? 'ul' : 'ol';            // opened            if ($this->isBlock('list')) {                if ($space < $block[3][0] || ($space == $block[3][0] && $type != $block[3][1])) {                    $this->startBlock('list', $key, [$space, $type, $tab]);                } else {                    $this->setBlock($key);                }            } else {                $this->startBlock('list', $key, [$space, $type, $tab]);            }            return false;        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
typecho_typecho_build_pot_1638, get msgid\\n \\n @param string $value\\n @return string\\n, get msgid,"function get_msgid($value) {    if ($value[0] == '""') {        return $value;    } else {        $value = trim($value, ""'"");        return '""' . str_replace('""', '\""', $value) . '""';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Dotenv_1073," Parse the given content and resolve nested variables.\\\\n\\\\n This method behaves just like load(), only without mutating your actual\\\\n environment. We do this by using an array backed repository.\\\\n\\\\n @param string $content\\\\n\\\\n @throws \\\\\\\\Dotenv\\\\\\\\Exception\\\\\\\\InvalidFileException\\\\n\\\\n @return array<string,string|null>\\\\n", Parse the given content and resolve nested variables.,"    public static function parse(string $content)    {        $repository = RepositoryBuilder::createWithNoAdapters()->addAdapter(ArrayAdapter::class)->make();        $phpdotenv = new self(new StringStore($content), new Parser(), new Loader(), $repository);        return $phpdotenv->load();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Dotenv_1075," Read and load environment file(s), silently failing if no files can be read.\\n\\n @throws \\\\Dotenv\\\\Exception\\\\InvalidEncodingException|\\\\Dotenv\\\\Exception\\\\InvalidFileException\\n\\n @return array<string,string|null>\\n"," Read and load environment file(s), silently failing if no files can be read.",    public function safeLoad()    {        try {            return $this->load();        } catch (InvalidPathException $e) {            // suppressing exception            return [];        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Dotenv_1076," Required ensures that the specified variables exist, and returns a new validator object.\\n\\n @param string|string[] $variables\\n\\n @return \\\\Dotenv\\\\Validator\\n"," Required ensures that the specified variables exist, and returns a new validator object.","    public function required($variables)    {        return (new Validator($this->repository, (array) $variables))->required();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Dotenv_1077, Returns a new validator object that won't check if the specified variables exist.\n\n @param string|string[] $variables\n\n @return \\Dotenv\\Validator\n, Returns a new validator object that won't check if the specified variables exist.,"    public function ifPresent($variables)    {        return new Validator($this->repository, (array) $variables);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Loader_1087," Load the given entries into the repository.\n\n We'll substitute any nested variables, and send each variable to the\n repository, with the effect of actually mutating the environment.\n\n @param \\Dotenv\\Repository\\RepositoryInterface $repository\n @param \\Dotenv\\Parser\\Entry[]                 $entries\n\n @return array<string,string|null>\n", Load the given entries into the repository.,"    public function load(RepositoryInterface $repository, array $entries)    {        return \array_reduce($entries, static function (array $vars, Entry $entry) use ($repository) {            $name = $entry->getName();            $value = $entry->getValue()->map(static function (Value $value) use ($repository) {                return Resolver::resolve($repository, $value);            });            if ($value->isDefined()) {                $inner = $value->get();                if ($repository->set($name, $inner)) {                    return \array_merge($vars, [$name => $inner]);                }            } else {                if ($repository->clear($name)) {                    return \array_merge($vars, [$name => null]);                }            }            return $vars;        }, []);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_RepositoryTest_1127," Returns the value from keyVal(), without reset.\\\\n\\\\n @return string\\\\n"," Returns the value from keyVal(), without reset.",    private function value()    {        $keyVal = $this->keyVal();        /** @var string */        return \reset($keyVal);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Resolver_1090, Resolve the nested variables in the given value.\\\\n\\\\n Replaces ${varname} patterns in the allowed positions in the variable\\\\n value by an existing environment variable.\\\\n\\\\n @param \\\\\\\\Dotenv\\\\\\\\Repository\\\\\\\\RepositoryInterface $repository\\\\n @param \\\\\\\\Dotenv\\\\\\\\Parser\\\\\\\\Value                   $value\\\\n\\\\n @return string\\\\n, Resolve the nested variables in the given value.,"    public static function resolve(RepositoryInterface $repository, Value $value)    {        return \array_reduce($value->getVars(), static function (string $s, int $i) use ($repository) {            return Str::substr($s, 0, $i).self::resolveVariable($repository, Str::substr($s, $i));        }, $value->getChars());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Resolver_1091, Resolve a single nested variable.\\n\\n @param \\\\Dotenv\\\\Repository\\\\RepositoryInterface $repository\\n @param string                                 $str\\n\\n @return string\\n, Resolve a single nested variable.,"    private static function resolveVariable(RepositoryInterface $repository, string $str)    {        return Regex::replaceCallback(            '/\A\${([a-zA-Z0-9_.]+)}/',            static function (array $matches) use ($repository) {                return Option::fromValue($repository->get($matches[1]))                    ->getOrElse($matches[0]);            },            $str,            1        )->success()->getOrElse($str);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_ValidatorTest_1101, List of valid boolean values in fixtures/env/booleans.env.\n\n @return string[][]\n, List of valid boolean values in fixtures/env/booleans.env.,"    public function validBooleanValuesDataProvider()    {        return [            ['VALID_EXPLICIT_LOWERCASE_TRUE'],            ['VALID_EXPLICIT_LOWERCASE_FALSE'],            ['VALID_EXPLICIT_UPPERCASE_TRUE'],            ['VALID_EXPLICIT_UPPERCASE_FALSE'],            ['VALID_EXPLICIT_MIXEDCASE_TRUE'],            ['VALID_EXPLICIT_MIXEDCASE_FALSE'],            ['VALID_NUMBER_TRUE'],            ['VALID_NUMBER_FALSE'],            ['VALID_ONOFF_LOWERCASE_TRUE'],            ['VALID_ONOFF_LOWERCASE_FALSE'],            ['VALID_ONOFF_UPPERCASE_TRUE'],            ['VALID_ONOFF_UPPERCASE_FALSE'],            ['VALID_ONOFF_MIXEDCASE_TRUE'],            ['VALID_ONOFF_MIXEDCASE_FALSE'],            ['VALID_YESNO_LOWERCASE_TRUE'],            ['VALID_YESNO_LOWERCASE_FALSE'],            ['VALID_YESNO_UPPERCASE_TRUE'],            ['VALID_YESNO_UPPERCASE_FALSE'],            ['VALID_YESNO_MIXEDCASE_TRUE'],            ['VALID_YESNO_MIXEDCASE_FALSE'],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_ValidatorTest_1108, List of valid integer values in fixtures/env/integers.env.\n\n @return string[][]\n, List of valid integer values in fixtures/env/integers.env.,"    public function validIntegerValuesDataProvider()    {        return [            ['VALID_ZERO'],            ['VALID_ONE'],            ['VALID_TWO'],            ['VALID_LARGE'],            ['VALID_HUGE'],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_ValidatorTest_1111, List of non-integer values in fixtures/env/integers.env.\\n\\n @return string[][]\\n, List of non-integer values in fixtures/env/integers.env.,"    public function invalidIntegerValuesDataProvider()    {        return [            ['INVALID_SOMETHING'],            ['INVALID_EMPTY'],            ['INVALID_EMPTY_STRING'],            ['INVALID_NULL'],            ['INVALID_NEGATIVE'],            ['INVALID_MINUS'],            ['INVALID_TILDA'],            ['INVALID_EXCLAMATION'],            ['INVALID_SPACES'],            ['INVALID_COMMAS'],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Validator_1078, Create a new validator instance.\\n\\n @param \\\\Dotenv\\\\Repository\\\\RepositoryInterface $repository\\n @param string[]                               $variables\\n\\n @throws \\\\Dotenv\\\\Exception\\\\ValidationException\\n\\n @return void\\n, Create a new validator instance.,"    public function __construct(RepositoryInterface $repository, array $variables)    {        $this->repository = $repository;        $this->variables = $variables;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Validator_1080, Assert that each variable is not empty.\\n\\n @throws \\\\Dotenv\\\\Exception\\\\ValidationException\\n\\n @return \\\\Dotenv\\\\Validator\\n, Assert that each variable is not empty.,"    public function notEmpty()    {        return $this->assertNullable(            static function (string $value) {                return Str::len(\trim($value)) > 0;            },            'is empty'        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Validator_1082, Assert that each specified variable is a boolean.\\\\n\\\\n @throws \\\\\\\\Dotenv\\\\\\\\Exception\\\\\\\\ValidationException\\\\n\\\\n @return \\\\\\\\Dotenv\\\\\\\\Validator\\\\n, Assert that each specified variable is a boolean.,"    public function isBoolean()    {        return $this->assertNullable(            static function (string $value) {                if ($value === '') {                    return false;                }                return \filter_var($value, \FILTER_VALIDATE_BOOLEAN, \FILTER_NULL_ON_FAILURE) !== null;            },            'is not a boolean'        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Validator_1083, Assert that each variable is amongst the given choices.\\n\\n @param string[] $choices\\n\\n @throws \\\\Dotenv\\\\Exception\\\\ValidationException\\n\\n @return \\\\Dotenv\\\\Validator\\n, Assert that each variable is amongst the given choices.,"    public function allowedValues(array $choices)    {        return $this->assertNullable(            static function (string $value) use ($choices) {                return \in_array($value, $choices, true);            },            \sprintf('is not one of [%s]', \implode(', ', $choices))        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
vlucas_phpdotenv_Validator_1084, Assert that each variable matches the given regular expression.\n\n @param string $regex\n\n @throws \\Dotenv\\Exception\\ValidationException\n\n @return \\Dotenv\\Validator\n, Assert that each variable matches the given regular expression.,"    public function allowedRegexValues(string $regex)    {        return $this->assertNullable(            static function (string $value) use ($regex) {                return Regex::matches($regex, $value)->success()->getOrElse(false);            },            \sprintf('does not match ""%s""', $regex)        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2077, Image security check.\\n\\n @param string $path\\n\\n @return array|\\\\EasyWeChat\\\\Kernel\\\\Support\\\\Collection|object|\\\\Psr\\\\Http\\\\Message\\\\ResponseInterface|string\\n\\n @throws \\\\EasyWeChat\\\\Kernel\\\\Exceptions\\\\InvalidConfigException\\n @throws \\\\GuzzleHttp\\\\Exception\\\\GuzzleException\\n, Image security check.,"    public function checkImage(string $path)    {        return $this->httpUpload('img_sec_check', ['media' => $path]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2094, Upload video.\n\n @param string $path\n\n @return \\Psr\\Http\\Message\\ResponseInterface|\\EasyWeChat\\Kernel\\Support\\Collection|array|object|string\n\n @throws \\EasyWeChat\\Kernel\\Exceptions\\InvalidArgumentException\n @throws \\EasyWeChat\\Kernel\\Exceptions\\InvalidConfigException\n @throws \\GuzzleHttp\\Exception\\GuzzleException\n, Upload video.,"    public function uploadVideo($path)    {        return $this->upload('video', $path);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2100, Fetch item from WeChat server.\n\n @param string $mediaId\n\n @return \\EasyWeChat\\Kernel\\Http\\StreamResponse|\\Psr\\Http\\Message\\ResponseInterface|\\EasyWeChat\\Kernel\\Support\\Collection|array|object|string\n\n @throws \\EasyWeChat\\Kernel\\Exceptions\\InvalidConfigException\n @throws \\GuzzleHttp\\Exception\\GuzzleException\n, Fetch item from WeChat server.,"    public function get(string $mediaId)    {        $response = $this->requestRaw('media/get', 'GET', [            'query' => [                'media_id' => $mediaId,            ],        ]);        if (false !== stripos($response->getHeaderLine('Content-disposition'), 'attachment')) {            return StreamResponse::buildFromPsrResponse($response);        }        return $this->castResponseToType($response, $this->app['config']->get('response_type'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2105, Create forever QR code.\\n\\n @param string|int $sceneValue\\n\\n @return \\\\Psr\\\\Http\\\\Message\\\\ResponseInterface|\\\\EasyWeChat\\\\Kernel\\\\Support\\\\Collection|array|object|string\\n, Create forever QR code.,"    public function forever($sceneValue)    {        if (is_int($sceneValue) && $sceneValue > 0 && $sceneValue < self::SCENE_MAX_VALUE) {            $type = self::SCENE_QR_FOREVER;            $sceneKey = 'scene_id';        } else {            $type = self::SCENE_QR_FOREVER_STR;            $sceneKey = 'scene_str';        }        $scene = [$sceneKey => $sceneValue];        return $this->create($type, $scene, false);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_TestCase_2110, Tear down the test case.\\n, Tear down the test case.,    public function tearDown(): void    {        $this->finish();        parent::tearDown();        if ($container = \Mockery::getContainer()) {            $this->addToAssertionCount($container->Mockery_getExpectationCount());        }        \Mockery::close();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_7020, CancelReconnect.\n, CancelReconnect.,    public function cancelReconnect()    {        if ($this->_reconnectTimer) {            Timer::del($this->_reconnectTimer);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_7024, Check connection is successfully established or faild.\n\n @param resource $socket\n @return void\n, Check connection is successfully established or faild.,"    public function checkConnection()    {        // Remove EV_EXPECT for windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->del($this->_socket, EventInterface::EV_EXCEPT);        }        // Remove write listener.        Worker::$globalEvent->del($this->_socket, EventInterface::EV_WRITE);        if ($this->_status !== self::STATUS_CONNECTING) {            return;        }        // Check socket state.        if ($address = \stream_socket_get_name($this->_socket, true)) {            // Nonblocking.            \stream_set_blocking($this->_socket, false);            // Compatible with hhvm            if (\function_exists('stream_set_read_buffer')) {                \stream_set_read_buffer($this->_socket, 0);            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && $this->transport === 'tcp') {                $raw_socket = \socket_import_stream($this->_socket);                \socket_set_option($raw_socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($raw_socket, \SOL_TCP, \TCP_NODELAY, 1);            }            // SSL handshake.            if ($this->transport === 'ssl') {                $this->_sslHandshakeCompleted = $this->doSslHandshake($this->_socket);                if ($this->_sslHandshakeCompleted === false) {                    return;                }            } else {                // There are some data waiting to send.                if ($this->_sendBuffer) {                    Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'baseWrite'));                }            }            // Register a listener waiting read event.            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));            $this->_status                = self::STATUS_ESTABLISHED;            $this->_remoteAddress         = $address;            // Try to emit onConnect callback.            if ($this->onConnect) {                try {                    \call_user_func($this->onConnect, $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }            // Try to emit protocol::onConnect            if ($this->protocol && \method_exists($this->protocol, 'onConnect')) {                try {                    \call_user_func(array($this->protocol, 'onConnect'), $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }        } else {            // Connection failed.            $this->emitError(\WORKERMAN_CONNECT_FAIL, 'connect ' . $this->_remoteAddress . ' fail after ' . round(\microtime(true) - $this->_connectStartTime, 4) . ' seconds');            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_7395, Get remote URI.\n\n @return string\n, Get remote URI.,    public function getRemoteURI()    {        return $this->_remoteURI;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_7776, Do connect.\n\n @return void\n, Do connect.,"    public function connect()    {        if ($this->_status !== self::STATUS_INITIAL && $this->_status !== self::STATUS_CLOSING &&            $this->_status !== self::STATUS_CLOSED) {            return;        }        $this->_status           = self::STATUS_CONNECTING;        $this->_connectStartTime = \microtime(true);        if ($this->transport !== 'unix') {            if (!$this->_remotePort) {                $this->_remotePort = $this->transport === 'ssl' ? 443 : 80;                $this->_remoteAddress = $this->_remoteHost.':'.$this->_remotePort;            }            // Open socket connection asynchronously.            if ($this->_contextOption) {                $context = \stream_context_create($this->_contextOption);                $this->_socket = \stream_socket_client(""tcp://{$this->_remoteHost}:{$this->_remotePort}"",                    $errno, $errstr, 0, \STREAM_CLIENT_ASYNC_CONNECT, $context);            } else {                $this->_socket = \stream_socket_client(""tcp://{$this->_remoteHost}:{$this->_remotePort}"",                    $errno, $errstr, 0, \STREAM_CLIENT_ASYNC_CONNECT);            }        } else {            $this->_socket = \stream_socket_client(""{$this->transport}://{$this->_remoteAddress}"", $errno, $errstr, 0,                \STREAM_CLIENT_ASYNC_CONNECT);        }        // If failed attempt to emit onError callback.        if (!$this->_socket || !\is_resource($this->_socket)) {            $this->emitError(\WORKERMAN_CONNECT_FAIL, $errstr);            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }            return;        }        // Add socket to global event loop waiting connection is successfully established or faild.        Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'checkConnection'));        // For windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_EXCEPT, array($this, 'checkConnection'));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_8696, Get remote address.\n\n @return string\n, Get remote address.,    public function getRemoteHost()    {        return $this->_remoteHost;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncUdpConnection_8701, For udp package.\n\n @param resource $socket\n @return bool\n, For udp package.,"    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Autoloader_7707, Set autoload root path.\n\n @param string $root_path\n @return void\n, Set autoload root path.,    public static function setRootPath($root_path)    {        self::$_autoloadRootPath = $root_path;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Autoloader_7708, Load files by namespace.\n\n @param string $name\n @return boolean\n, Load files by namespace.,"    public static function loadByNamespace($name)    {        $class_path = \str_replace('\\', \DIRECTORY_SEPARATOR, $name);        if (\strpos($name, 'Workerman\\') === 0) {            $class_file = __DIR__ . \substr($class_path, \strlen('Workerman')) . '.php';        } else {            if (self::$_autoloadRootPath) {                $class_file = self::$_autoloadRootPath . \DIRECTORY_SEPARATOR . $class_path . '.php';            }            if (empty($class_file) || !\is_file($class_file)) {                $class_file = __DIR__ . \DIRECTORY_SEPARATOR . '..' . \DIRECTORY_SEPARATOR . ""$class_path.php"";            }        }        if (\is_file($class_file)) {            require_once($class_file);            if (\class_exists($name, false)) {                return true;            }        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Event_7407, Destroy loop.\n\n @return void\n, Destroy loop.,    public function destroy()    {        $this->_eventBase->exit();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Event_9656, Timer callback.\n @param int|null $fd\n @param int $what\n @param int $timer_id\n, Timer callback.,"    public function timerCallback($fd, $what, $param)    {        $timer_id = $param[4];                if ($param[2] === self::EV_TIMER_ONCE) {            $this->_eventTimer[$timer_id]->del();            unset($this->_eventTimer[$timer_id]);        }        try {            \call_user_func_array($param[0], $param[1]);        } catch (\Exception $e) {            Worker::log($e);            exit(250);        } catch (\Error $e) {            Worker::log($e);            exit(250);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Timer_7325," Timer.\n\n example:\n Workerman\\Timer::add($time_interval, callback, array($arg1, $arg2..));\n", Timer.,"class Timer{    /**     * Tasks that based on ALARM signal.     * [     *   run_time => [[$func, $args, $persistent, time_interval],[$func, $args, $persistent, time_interval],..]],     *   run_time => [[$func, $args, $persistent, time_interval],[$func, $args, $persistent, time_interval],..]],     *   ..     * ]     *     * @var array     */    protected static $_tasks = array();    /**     * event     *     * @var EventInterface     */    protected static $_event = null;    /**     * timer id     *     * @var int     */    protected static $_timerId = 0;    /**     * timer status     * [     *   timer_id1 => bool,     *   timer_id2 => bool,     *   ....................,     * ]     *     * @var array     */    protected static $_status = array();    /**     * Init.     *     * @param EventInterface $event     * @return void     */    public static function init($event = null)    {        if ($event) {            self::$_event = $event;            return;        }        if (\function_exists('pcntl_signal')) {            \pcntl_signal(\SIGALRM, array('\Workerman\Lib\Timer', 'signalHandle'), false);        }    }    /**     * ALARM signal handler.     *     * @return void     */    public static function signalHandle()    {        if (!self::$_event) {            \pcntl_alarm(1);            self::tick();        }    }    /**     * Add a timer.     *     * @param float    $time_interval     * @param callable $func     * @param mixed    $args     * @param bool     $persistent     * @return int|bool     */    public static function add($time_interval, $func, $args = array(), $persistent = true)    {        if ($time_interval <= 0) {            Worker::safeEcho(new Exception(""bad time_interval""));            return false;        }        if ($args === null) {            $args = array();        }        if (self::$_event) {            return self::$_event->add($time_interval,                $persistent ? EventInterface::EV_TIMER : EventInterface::EV_TIMER_ONCE, $func, $args);        }        if (!\is_callable($func)) {            Worker::safeEcho(new Exception(""not callable""));            return false;        }        if (empty(self::$_tasks)) {            \pcntl_alarm(1);        }        $run_time = \time() + $time_interval;        if (!isset(self::$_tasks[$run_time])) {            self::$_tasks[$run_time] = array();        }        self::$_timerId = self::$_timerId == \PHP_INT_MAX ? 1 : ++self::$_timerId;        self::$_status[self::$_timerId] = true;        self::$_tasks[$run_time][self::$_timerId] = array($func, (array)$args, $persistent, $time_interval);        return self::$_timerId;    }    /**     * Tick.     *     * @return void     */    public static function tick()    {        if (empty(self::$_tasks)) {            \pcntl_alarm(0);            return;        }        $time_now = \time();        foreach (self::$_tasks as $run_time => $task_data) {            if ($time_now >= $run_time) {                foreach ($task_data as $index => $one_task) {                    $task_func     = $one_task[0];                    $task_args     = $one_task[1];                    $persistent    = $one_task[2];                    $time_interval = $one_task[3];                    try {                        \call_user_func_array($task_func, $task_args);                    } catch (\Exception $e) {                        Worker::safeEcho($e);                    }                    if($persistent && !empty(self::$_status[$index])) {                        $new_run_time = \time() + $time_interval;                        if(!isset(self::$_tasks[$new_run_time])) self::$_tasks[$new_run_time] = array();                        self::$_tasks[$new_run_time][$index] = array($task_func, (array)$task_args, $persistent, $time_interval);                    }                }                unset(self::$_tasks[$run_time]);            }        }    }    /**     * Remove a timer.     *     * @param mixed $timer_id     * @return bool     */    public static function del($timer_id)    {        if (self::$_event) {            return self::$_event->del($timer_id, EventInterface::EV_TIMER);        }        foreach(self::$_tasks as $run_time => $task_data)         {            if(array_key_exists($timer_id, $task_data)) unset(self::$_tasks[$run_time][$timer_id]);        }        if(array_key_exists($timer_id, self::$_status)) unset(self::$_status[$timer_id]);        return true;    }    /**     * Remove all timers.     *     * @return void     */    public static function delAll()    {        self::$_tasks = self::$_status = array();        \pcntl_alarm(0);        if (self::$_event) {            self::$_event->clearAllTimer();        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Timer_7328, Remove a timer.\n\n @param mixed $timer_id\n @return bool\n, Remove a timer.,"    public static function del($timer_id)    {        if (self::$_event) {            return self::$_event->del($timer_id, EventInterface::EV_TIMER);        }        foreach(self::$_tasks as $run_time => $task_data)         {            if(array_key_exists($timer_id, $task_data)) unset(self::$_tasks[$run_time][$timer_id]);        }        if(array_key_exists($timer_id, self::$_status)) unset(self::$_status[$timer_id]);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Timer_7711, Tick.\n\n @return void\n, Tick.,"    public static function tick()    {        if (empty(self::$_tasks)) {            \pcntl_alarm(0);            return;        }        $time_now = \time();        foreach (self::$_tasks as $run_time => $task_data) {            if ($time_now >= $run_time) {                foreach ($task_data as $index => $one_task) {                    $task_func     = $one_task[0];                    $task_args     = $one_task[1];                    $persistent    = $one_task[2];                    $time_interval = $one_task[3];                    try {                        \call_user_func_array($task_func, $task_args);                    } catch (\Exception $e) {                        Worker::safeEcho($e);                    }                    if($persistent && !empty(self::$_status[$index])) {                        $new_run_time = \time() + $time_interval;                        if(!isset(self::$_tasks[$new_run_time])) self::$_tasks[$new_run_time] = array();                        self::$_tasks[$new_run_time][$index] = array($task_func, (array)$task_args, $persistent, $time_interval);                    }                }                unset(self::$_tasks[$run_time]);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Timer_7713, Remove all timers.\n\n @return void\n, Remove all timers.,    public static function delAll()    {        self::$_tasks = self::$_status = array();        \pcntl_alarm(0);        if (self::$_event) {            self::$_event->clearAllTimer();        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6961, Lock.\n\n @return void\n, Lock.,"    protected static function lock()    {        $fd = \fopen(static::$_startFile, 'r');        if ($fd && !flock($fd, LOCK_EX)) {            static::log('Workerman['.static::$_startFile.'] already running.');            exit;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6963, Init All worker instances.\n\n @return void\n, Init All worker instances.,"    protected static function initWorkers()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        static::$_statisticsFile = __DIR__ . '/../workerman-' .posix_getpid().'.status';        foreach (static::$_workers as $worker) {            // Worker name.            if (empty($worker->name)) {                $worker->name = 'none';            }            // Get unix user of the worker process.            if (empty($worker->user)) {                $worker->user = static::getCurrentUser();            } else {                if (\posix_getuid() !== 0 && $worker->user !== static::getCurrentUser()) {                    static::log('Warning: You must have the root privileges to change uid and gid.');                }            }            // Socket name.            $worker->socket = $worker->getSocketName();            // Status name.            $worker->status = '<g> [OK] </g>';            // Get column mapping for UI            foreach(static::getUiColumns() as $column_name => $prop){                !isset($worker->{$prop}) && $worker->{$prop} = 'NNNN';                $prop_length = \strlen($worker->{$prop});                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                static::$$key = \max(static::$$key, $prop_length);            }            // Listen.            if (!$worker->reusePort) {                $worker->listen();            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6967, Get main socket resource\n @return resource\n, Get main socket resource,    public function getMainSocket(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6968, Init idMap.\n return void\n, Init idMap.,    protected static function initId()    {        foreach (static::$_workers as $worker_id => $worker) {            $new_id_map = array();            $worker->count = $worker->count < 1 ? 1 : $worker->count;            for($key = 0; $key < $worker->count; $key++) {                $new_id_map[$key] = isset(static::$_idMap[$worker_id][$key]) ? static::$_idMap[$worker_id][$key] : 0;            }            static::$_idMap[$worker_id] = $new_id_map;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6969, Get unix user of current porcess.\n\n @return string\n, Get unix user of current porcess.,    protected static function getCurrentUser()    {        $user_info = \posix_getpwuid(\posix_getuid());        return $user_info['name'];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6970, Display staring UI.\n\n @return void\n, Display staring UI.,"    protected static function displayUI()    {        global $argv;        if (\in_array('-q', $argv)) {            return;        }        if (static::$_OS !== \OS_TYPE_LINUX) {            static::safeEcho(""----------------------- WORKERMAN -----------------------------\r\n"");            static::safeEcho('Workerman version:'. static::VERSION. '          PHP version:'. \PHP_VERSION. ""\r\n"");            static::safeEcho(""------------------------ WORKERS -------------------------------\r\n"");            static::safeEcho(""worker               listen                              processes status\r\n"");            return;        }        //show version        $line_version = 'Workerman version:' . static::VERSION . \str_pad('PHP version:', 22, ' ', \STR_PAD_LEFT) . \PHP_VERSION . \PHP_EOL;        !\defined('LINE_VERSIOIN_LENGTH') && \define('LINE_VERSIOIN_LENGTH', \strlen($line_version));        $total_length = static::getSingleLineTotalLength();        $line_one = '<n>' . \str_pad('<w> WORKERMAN </w>', $total_length + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . '</n>'. \PHP_EOL;        $line_two = \str_pad('<w> WORKERS </w>' , $total_length  + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . \PHP_EOL;        static::safeEcho($line_one . $line_version . $line_two);        //Show title        $title = '';        foreach(static::getUiColumns() as $column_name => $prop){            $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';            //just keep compatible with listen name            $column_name === 'socket' && $column_name = 'listen';            $title.= ""<w>{$column_name}</w>""  .  \str_pad('', static::$$key + static::UI_SAFE_LENGTH - \strlen($column_name));        }        $title && static::safeEcho($title . \PHP_EOL);        //Show content        foreach (static::$_workers as $worker) {            $content = '';            foreach(static::getUiColumns() as $column_name => $prop){                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                \preg_match_all(""/(<n>|<\/n>|<w>|<\/w>|<g>|<\/g>)/is"", $worker->{$prop}, $matches);                $place_holder_length = !empty($matches) ? \strlen(\implode('', $matches[0])) : 0;                $content .= \str_pad($worker->{$prop}, static::$$key + static::UI_SAFE_LENGTH + $place_holder_length);            }            $content && static::safeEcho($content . \PHP_EOL);        }        //Show last line        $line_last = \str_pad('', static::getSingleLineTotalLength(), '-') . \PHP_EOL;        !empty($content) && static::safeEcho($line_last);        if (static::$daemonize) {            foreach ($argv as $index => $value) {                if ($value == '-d') {                    unset($argv[$index]);                } elseif ($value == 'start' || $value == 'restart') {                    $argv[$index] = 'stop';                }            }            static::safeEcho(""Input \""php "".implode(' ', $argv).""\"" to stop. Start success.\n\n"");        } else {            static::safeEcho(""Press Ctrl+C to stop. Start success.\n"");        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6978, Run as deamon mode.\n\n @throws Exception\n, Run as deamon mode.,"    protected static function daemonize()    {        if (!static::$daemonize || static::$_OS !== \OS_TYPE_LINUX) {            return;        }        \umask(0);        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception('Fork fail');        } elseif ($pid > 0) {            exit(0);        }        if (-1 === \posix_setsid()) {            throw new Exception(""Setsid fail"");        }        // Fork again avoid SVR4 system regain the control of terminal.        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception(""Fork fail"");        } elseif (0 !== $pid) {            exit(0);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6988, check worker status for windows.\n @return void\n, check worker status for windows.,"    public static function checkWorkerStatusForWindows()    {        foreach(static::$_processForWindows as $process_data)        {            $process = $process_data[0];            $start_file = $process_data[1];            $timer_id = $process_data[2];            $status = \proc_get_status($process);            if(isset($status['running']))            {                if(!$status['running'])                {                    static::safeEcho(""process $start_file terminated and try to restart\n"");                    Timer::del($timer_id);                    \proc_close($process);                    static::forkOneWorkerForWindows($start_file);                }            }            else            {                static::safeEcho(""proc_get_status fail\n"");            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6990, Get worker id.\n\n @param int $worker_id\n @param int $pid\n\n @return integer\n, Get worker id.,"    protected static function getId($worker_id, $pid)    {        return \array_search($pid, static::$_idMap[$worker_id]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6991, Set unix user and group for current process.\n\n @return void\n, Set unix user and group for current process.,"    public function setUserAndGroup()    {        // Get uid.        $user_info = \posix_getpwnam($this->user);        if (!$user_info) {            static::log(""Warning: User {$this->user} not exsits"");            return;        }        $uid = $user_info['uid'];        // Get gid.        if ($this->group) {            $group_info = \posix_getgrnam($this->group);            if (!$group_info) {                static::log(""Warning: Group {$this->group} not exsits"");                return;            }            $gid = $group_info['gid'];        } else {            $gid = $user_info['gid'];        }        // Set uid and gid.        if ($uid !== \posix_getuid() || $gid !== \posix_getgid()) {            if (!\posix_setgid($gid) || !\posix_initgroups($user_info['name'], $gid) || !\posix_setuid($uid)) {                static::log(""Warning: change gid or uid fail."");            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7000, Get process status.\n\n @return number\n, Get process status.,    public static function getStatus()    {        return static::$_status;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7005, Get error message by error code.\n\n @param integer $type\n @return string\n, Get error message by error code.,    protected static function getErrorType($type)    {        if(isset(self::$_errorType[$type])) {            return self::$_errorType[$type];        }        return '';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7011, Resume accept new connections.\n\n @return void\n, Resume accept new connections.,"    public function resumeAccept()    {        // Register a listener to be notified when server socket is ready to read.        if (static::$globalEvent && true === $this->_pauseAccept && $this->_mainSocket) {            if ($this->transport !== 'udp') {                static::$globalEvent->add($this->_mainSocket, EventInterface::EV_READ, array($this, 'acceptConnection'));            } else {                static::$globalEvent->add($this->_mainSocket, EventInterface::EV_READ, array($this, 'acceptUdpConnection'));            }            $this->_pauseAccept = false;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7330, Worker class\n A container for listening ports\n, Worker class,"class Worker{    /**     * Version.     *     * @var string     */    const VERSION = '4.0.19';    /**     * Status starting.     *     * @var int     */    const STATUS_STARTING = 1;    /**     * Status running.     *     * @var int     */    const STATUS_RUNNING = 2;    /**     * Status shutdown.     *     * @var int     */    const STATUS_SHUTDOWN = 4;    /**     * Status reloading.     *     * @var int     */    const STATUS_RELOADING = 8;    /**     * After sending the restart command to the child process KILL_WORKER_TIMER_TIME seconds,     * if the process is still living then forced to kill.     *     * @var int     */    const KILL_WORKER_TIMER_TIME = 2;    /**     * Default backlog. Backlog is the maximum length of the queue of pending connections.     *     * @var int     */    const DEFAULT_BACKLOG = 102400;    /**     * Max udp package size.     *     * @var int     */    const MAX_UDP_PACKAGE_SIZE = 65535;    /**     * The safe distance for columns adjacent     *     * @var int     */    const UI_SAFE_LENGTH = 4;    /**     * Worker id.     *     * @var int     */    public $id = 0;    /**     * Name of the worker processes.     *     * @var string     */    public $name = 'none';    /**     * Number of worker processes.     *     * @var int     */    public $count = 1;    /**     * Unix user of processes, needs appropriate privileges (usually root).     *     * @var string     */    public $user = '';    /**     * Unix group of processes, needs appropriate privileges (usually root).     *     * @var string     */    public $group = '';    /**     * reloadable.     *     * @var bool     */    public $reloadable = true;    /**     * reuse port.     *     * @var bool     */    public $reusePort = false;    /**     * Emitted when worker processes start.     *     * @var callable     */    public $onWorkerStart = null;    /**     * Emitted when a socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when data is received.     *     * @var callable     */    public $onMessage = null;    /**     * Emitted when the other end of the socket sends a FIN packet.     *     * @var callable     */    public $onClose = null;    /**     * Emitted when an error occurs with connection.     *     * @var callable     */    public $onError = null;    /**     * Emitted when the send buffer becomes full.     *     * @var callable     */    public $onBufferFull = null;    /**     * Emitted when the send buffer becomes empty.     *     * @var callable     */    public $onBufferDrain = null;    /**     * Emitted when worker processes stoped.     *     * @var callable     */    public $onWorkerStop = null;    /**     * Emitted when worker processes get reload signal.     *     * @var callable     */    public $onWorkerReload = null;    /**     * Transport layer protocol.     *     * @var string     */    public $transport = 'tcp';    /**     * Store all connections of clients.     *     * @var array     */    public $connections = array();    /**     * Application layer protocol.     *     * @var string     */    public $protocol = null;    /**     * Root path for autoload.     *     * @var string     */    protected $_autoloadRootPath = '';    /**     * Pause accept new connections or not.     *     * @var bool     */    protected $_pauseAccept = true;    /**     * Is worker stopping ?     * @var bool     */    public $stopping = false;    /**     * Daemonize.     *     * @var bool     */    public static $daemonize = false;    /**     * Stdout file.     *     * @var string     */    public static $stdoutFile = '/dev/null';    /**     * The file to store master process PID.     *     * @var string     */    public static $pidFile = '';    /**     * Log file.     *     * @var mixed     */    public static $logFile = '';    /**     * Global event loop.     *     * @var EventInterface     */    public static $globalEvent = null;    /**     * Emitted when the master process get reload signal.     *     * @var callable     */    public static $onMasterReload = null;    /**     * Emitted when the master process terminated.     *     * @var callable     */    public static $onMasterStop = null;    /**     * EventLoopClass     *     * @var string     */    public static $eventLoopClass = '';    /**     * Process title     *     * @var string     */    public static $processTitle = 'WorkerMan';    /**     * The PID of master process.     *     * @var int     */    protected static $_masterPid = 0;    /**     * Listening socket.     *     * @var resource     */    protected $_mainSocket = null;    /**     * Socket name. The format is like this http://0.0.0.0:80 .     *     * @var string     */    protected $_socketName = '';    /** parse from _socketName avoid parse again in master or worker     * LocalSocket The format is like tcp://0.0.0.0:8080     * @var string     */    protected $_localSocket=null;    /**     * Context of socket.     *     * @var resource     */    protected $_context = null;    /**     * All worker instances.     *     * @var Worker[]     */    protected static $_workers = array();    /**     * All worker processes pid.     * The format is like this [worker_id=>[pid=>pid, pid=>pid, ..], ..]     *     * @var array     */    protected static $_pidMap = array();    /**     * All worker processes waiting for restart.     * The format is like this [pid=>pid, pid=>pid].     *     * @var array     */    protected static $_pidsToRestart = array();    /**     * Mapping from PID to worker process ID.     * The format is like this [worker_id=>[0=>$pid, 1=>$pid, ..], ..].     *     * @var array     */    protected static $_idMap = array();    /**     * Current status.     *     * @var int     */    protected static $_status = self::STATUS_STARTING;    /**     * Maximum length of the worker names.     *     * @var int     */    protected static $_maxWorkerNameLength = 12;    /**     * Maximum length of the socket names.     *     * @var int     */    protected static $_maxSocketNameLength = 12;    /**     * Maximum length of the process user names.     *     * @var int     */    protected static $_maxUserNameLength = 12;    /**     * Maximum length of the Proto names.     *     * @var int     */    protected static $_maxProtoNameLength = 4;    /**     * Maximum length of the Processes names.     *     * @var int     */    protected static $_maxProcessesNameLength = 9;    /**     * Maximum length of the Status names.     *     * @var int     */    protected static $_maxStatusNameLength = 1;    /**     * The file to store status info of current worker process.     *     * @var string     */    protected static $_statisticsFile = '';    /**     * Start file.     *     * @var string     */    protected static $_startFile = '';    /**     * OS.     *     * @var string     */    protected static $_OS = \OS_TYPE_LINUX;    /**     * Processes for windows.     *     * @var array     */    protected static $_processForWindows = array();    /**     * Status info of current worker process.     *     * @var array     */    protected static $_globalStatistics = array(        'start_timestamp'  => 0,        'worker_exit_info' => array()    );    /**     * Available event loops.     *     * @var array     */    protected static $_availableEventLoops = array(        'event'    => '\Workerman\Events\Event',        'libevent' => '\Workerman\Events\Libevent'    );    /**     * PHP built-in protocols.     *     * @var array     */    protected static $_builtinTransports = array(        'tcp'   => 'tcp',        'udp'   => 'udp',        'unix'  => 'unix',        'ssl'   => 'tcp'    );    /**     * PHP built-in error types.     *     * @var array     */    protected static $_errorType = array(        \E_ERROR             => 'E_ERROR',             // 1        \E_WARNING           => 'E_WARNING',           // 2        \E_PARSE             => 'E_PARSE',             // 4        \E_NOTICE            => 'E_NOTICE',            // 8        \E_CORE_ERROR        => 'E_CORE_ERROR',        // 16        \E_CORE_WARNING      => 'E_CORE_WARNING',      // 32        \E_COMPILE_ERROR     => 'E_COMPILE_ERROR',     // 64        \E_COMPILE_WARNING   => 'E_COMPILE_WARNING',   // 128        \E_USER_ERROR        => 'E_USER_ERROR',        // 256        \E_USER_WARNING      => 'E_USER_WARNING',      // 512        \E_USER_NOTICE       => 'E_USER_NOTICE',       // 1024        \E_STRICT            => 'E_STRICT',            // 2048        \E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR', // 4096        \E_DEPRECATED        => 'E_DEPRECATED',        // 8192        \E_USER_DEPRECATED   => 'E_USER_DEPRECATED'   // 16384    );    /**     * Graceful stop or not.     *     * @var bool     */    protected static $_gracefulStop = false;    /**     * Standard output stream     * @var resource     */    protected static $_outputStream = null;    /**     * If $outputStream support decorated     * @var bool     */    protected static $_outputDecorated = null;    /**     * Run all worker instances.     *     * @return void     */    public static function runAll()    {        static::checkSapiEnv();        static::init();        static::parseCommand();        static::daemonize();        static::initWorkers();        static::installSignal();        static::saveMasterPid();        static::displayUI();        static::forkWorkers();        static::resetStd();        static::monitorWorkers();    }    /**     * Check sapi.     *     * @return void     */    protected static function checkSapiEnv()    {        // Only for cli.        if (\PHP_SAPI !== 'cli') {            exit(""Only run in command line mode \n"");        }        if (\DIRECTORY_SEPARATOR === '\\') {            self::$_OS = \OS_TYPE_WINDOWS;        }    }    /**     * Init.     *     * @return void     */    protected static function init()    {        \set_error_handler(function($code, $msg, $file, $line){            Worker::safeEcho(""$msg in file $file on line $line\n"");        });        // Start file.        $backtrace        = \debug_backtrace();        static::$_startFile = $backtrace[\count($backtrace) - 1]['file'];        $unique_prefix = \str_replace('/', '_', static::$_startFile);        // Pid file.        if (empty(static::$pidFile)) {            static::$pidFile = __DIR__ . ""/../$unique_prefix.pid"";        }        // Log file.        if (empty(static::$logFile)) {            static::$logFile = __DIR__ . '/../workerman.log';        }        $log_file = (string)static::$logFile;        if (!\is_file($log_file)) {            \touch($log_file);            \chmod($log_file, 0622);        }        // State.        static::$_status = static::STATUS_STARTING;        // For statistics.        static::$_globalStatistics['start_timestamp'] = \time();        // Process title.        static::setProcessTitle(static::$processTitle . ': master process  start_file=' . static::$_startFile);        // Init data for worker id.        static::initId();        // Timer init.        Timer::init();    }    /**     * Lock.     *     * @return void     */    protected static function lock()    {        $fd = \fopen(static::$_startFile, 'r');        if ($fd && !flock($fd, LOCK_EX)) {            static::log('Workerman['.static::$_startFile.'] already running.');            exit;        }    }    /**     * Unlock.     *     * @return void     */    protected static function unlock()    {        $fd = \fopen(static::$_startFile, 'r');        $fd && flock($fd, \LOCK_UN);    }    /**     * Init All worker instances.     *     * @return void     */    protected static function initWorkers()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        static::$_statisticsFile = __DIR__ . '/../workerman-' .posix_getpid().'.status';        foreach (static::$_workers as $worker) {            // Worker name.            if (empty($worker->name)) {                $worker->name = 'none';            }            // Get unix user of the worker process.            if (empty($worker->user)) {                $worker->user = static::getCurrentUser();            } else {                if (\posix_getuid() !== 0 && $worker->user !== static::getCurrentUser()) {                    static::log('Warning: You must have the root privileges to change uid and gid.');                }            }            // Socket name.            $worker->socket = $worker->getSocketName();            // Status name.            $worker->status = '<g> [OK] </g>';            // Get column mapping for UI            foreach(static::getUiColumns() as $column_name => $prop){                !isset($worker->{$prop}) && $worker->{$prop} = 'NNNN';                $prop_length = \strlen($worker->{$prop});                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                static::$$key = \max(static::$$key, $prop_length);            }            // Listen.            if (!$worker->reusePort) {                $worker->listen();            }        }    }    /**     * Reload all worker instances.     *     * @return void     */    public static function reloadAllWorkers()    {        static::init();        static::initWorkers();        static::displayUI();        static::$_status = static::STATUS_RELOADING;    }    /**     * Get all worker instances.     *     * @return array     */    public static function getAllWorkers()    {        return static::$_workers;    }    /**     * Get global event-loop instance.     *     * @return EventInterface     */    public static function getEventLoop()    {        return static::$globalEvent;    }    /**     * Get main socket resource     * @return resource     */    public function getMainSocket(){        return $this->_mainSocket;    }    /**     * Init idMap.     * return void     */    protected static function initId()    {        foreach (static::$_workers as $worker_id => $worker) {            $new_id_map = array();            $worker->count = $worker->count < 1 ? 1 : $worker->count;            for($key = 0; $key < $worker->count; $key++) {                $new_id_map[$key] = isset(static::$_idMap[$worker_id][$key]) ? static::$_idMap[$worker_id][$key] : 0;            }            static::$_idMap[$worker_id] = $new_id_map;        }    }    /**     * Get unix user of current porcess.     *     * @return string     */    protected static function getCurrentUser()    {        $user_info = \posix_getpwuid(\posix_getuid());        return $user_info['name'];    }    /**     * Display staring UI.     *     * @return void     */    protected static function displayUI()    {        global $argv;        if (\in_array('-q', $argv)) {            return;        }        if (static::$_OS !== \OS_TYPE_LINUX) {            static::safeEcho(""----------------------- WORKERMAN -----------------------------\r\n"");            static::safeEcho('Workerman version:'. static::VERSION. '          PHP version:'. \PHP_VERSION. ""\r\n"");            static::safeEcho(""------------------------ WORKERS -------------------------------\r\n"");            static::safeEcho(""worker               listen                              processes status\r\n"");            return;        }        //show version        $line_version = 'Workerman version:' . static::VERSION . \str_pad('PHP version:', 22, ' ', \STR_PAD_LEFT) . \PHP_VERSION . \PHP_EOL;        !\defined('LINE_VERSIOIN_LENGTH') && \define('LINE_VERSIOIN_LENGTH', \strlen($line_version));        $total_length = static::getSingleLineTotalLength();        $line_one = '<n>' . \str_pad('<w> WORKERMAN </w>', $total_length + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . '</n>'. \PHP_EOL;        $line_two = \str_pad('<w> WORKERS </w>' , $total_length  + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . \PHP_EOL;        static::safeEcho($line_one . $line_version . $line_two);        //Show title        $title = '';        foreach(static::getUiColumns() as $column_name => $prop){            $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';            //just keep compatible with listen name            $column_name === 'socket' && $column_name = 'listen';            $title.= ""<w>{$column_name}</w>""  .  \str_pad('', static::$$key + static::UI_SAFE_LENGTH - \strlen($column_name));        }        $title && static::safeEcho($title . \PHP_EOL);        //Show content        foreach (static::$_workers as $worker) {            $content = '';            foreach(static::getUiColumns() as $column_name => $prop){                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                \preg_match_all(""/(<n>|<\/n>|<w>|<\/w>|<g>|<\/g>)/is"", $worker->{$prop}, $matches);                $place_holder_length = !empty($matches) ? \strlen(\implode('', $matches[0])) : 0;                $content .= \str_pad($worker->{$prop}, static::$$key + static::UI_SAFE_LENGTH + $place_holder_length);            }            $content && static::safeEcho($content . \PHP_EOL);        }        //Show last line        $line_last = \str_pad('', static::getSingleLineTotalLength(), '-') . \PHP_EOL;        !empty($content) && static::safeEcho($line_last);        if (static::$daemonize) {            foreach ($argv as $index => $value) {                if ($value == '-d') {                    unset($argv[$index]);                } elseif ($value == 'start' || $value == 'restart') {                    $argv[$index] = 'stop';                }            }            static::safeEcho(""Input \""php "".implode(' ', $argv).""\"" to stop. Start success.\n\n"");        } else {            static::safeEcho(""Press Ctrl+C to stop. Start success.\n"");        }    }    /**     * Get UI columns to be shown in terminal     *     * 1. $column_map: array('ui_column_name' => 'clas_property_name')     * 2. Consider move into configuration in future     *     * @return array     */    public static function getUiColumns()    {        return array(            'proto'     =>  'transport',            'user'      =>  'user',            'worker'    =>  'name',            'socket'    =>  'socket',            'processes' =>  'count',            'status'    =>  'status',        );    }    /**     * Get single line total length for ui     *     * @return int     */    public static function getSingleLineTotalLength()    {        $total_length = 0;        foreach(static::getUiColumns() as $column_name => $prop){            $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';            $total_length += static::$$key + static::UI_SAFE_LENGTH;        }        //keep beauty when show less colums        !\defined('LINE_VERSIOIN_LENGTH') && \define('LINE_VERSIOIN_LENGTH', 0);        $total_length <= LINE_VERSIOIN_LENGTH && $total_length = LINE_VERSIOIN_LENGTH;        return $total_length;    }    /**     * Parse command.     *     * @return void     */    protected static function parseCommand()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        global $argv;        // Check argv;        $start_file = $argv[0];        $usage = ""Usage: php yourfile <command> [mode]\nCommands: \nstart\t\tStart worker in DEBUG mode.\n\t\tUse mode -d to start in DAEMON mode.\nstop\t\tStop worker.\n\t\tUse mode -g to stop gracefully.\nrestart\t\tRestart workers.\n\t\tUse mode -d to start in DAEMON mode.\n\t\tUse mode -g to stop gracefully.\nreload\t\tReload codes.\n\t\tUse mode -g to reload gracefully.\nstatus\t\tGet worker status.\n\t\tUse mode -d to show live status.\nconnections\tGet worker connections.\n"";        $available_commands = array(            'start',            'stop',            'restart',            'reload',            'status',            'connections',        );        $available_mode = array(            '-d',            '-g'        );        $command = $mode = '';        foreach ($argv as $value) {            if (\in_array($value, $available_commands)) {                $command = $value;            } elseif (\in_array($value, $available_mode)) {                $mode = $value;            }        }        if (!$command) {            exit($usage);        }        // Start command.        $mode_str = '';        if ($command === 'start') {            if ($mode === '-d' || static::$daemonize) {                $mode_str = 'in DAEMON mode';            } else {                $mode_str = 'in DEBUG mode';            }        }        static::log(""Workerman[$start_file] $command $mode_str"");        // Get master process PID.        $master_pid      = \is_file(static::$pidFile) ? (int)\file_get_contents(static::$pidFile) : 0;        // Master is still alive?        if (static::checkMasterIsAlive($master_pid)) {            if ($command === 'start') {                static::log(""Workerman[$start_file] already running"");                exit;            }        } elseif ($command !== 'start' && $command !== 'restart') {            static::log(""Workerman[$start_file] not run"");            exit;        }        $statistics_file =  __DIR__ . ""/../workerman-$master_pid.status"";        // execute command.        switch ($command) {            case 'start':                if ($mode === '-d') {                    static::$daemonize = true;                }                break;            case 'status':                while (1) {                    if (\is_file($statistics_file)) {                        @\unlink($statistics_file);                    }                    // Master process will send SIGUSR2 signal to all child processes.                    \posix_kill($master_pid, SIGUSR2);                    // Sleep 1 second.                    \sleep(1);                    // Clear terminal.                    if ($mode === '-d') {                        static::safeEcho(""\33[H\33[2J\33(B\33[m"", true);                    }                    // Echo status data.                    static::safeEcho(static::formatStatusData($statistics_file));                    if ($mode !== '-d') {                        exit(0);                    }                    static::safeEcho(""\nPress Ctrl+C to quit.\n\n"");                }                exit(0);            case 'connections':                if (\is_file($statistics_file) && \is_writable($statistics_file)) {                    \unlink($statistics_file);                }                // Master process will send SIGIO signal to all child processes.                \posix_kill($master_pid, SIGIO);                // Waiting amoment.                \usleep(500000);                // Display statisitcs data from a disk file.                if(\is_readable($statistics_file)) {                    \readfile($statistics_file);                }                exit(0);            case 'restart':            case 'stop':                if ($mode === '-g') {                    static::$_gracefulStop = true;                    $sig = \SIGHUP;                    static::log(""Workerman[$start_file] is gracefully stopping ..."");                } else {                    static::$_gracefulStop = false;                    $sig = \SIGINT;                    static::log(""Workerman[$start_file] is stopping ..."");                }                // Send stop signal to master process.                $master_pid && \posix_kill($master_pid, $sig);                // Timeout.                $timeout    = 5;                $start_time = \time();                // Check master process is still alive?                while (1) {                    $master_is_alive = $master_pid && \posix_kill((int) $master_pid, 0);                    if ($master_is_alive) {                        // Timeout?                        if (!static::$_gracefulStop && \time() - $start_time >= $timeout) {                            static::log(""Workerman[$start_file] stop fail"");                            exit;                        }                        // Waiting amoment.                        \usleep(10000);                        continue;                    }                    // Stop success.                    static::log(""Workerman[$start_file] stop success"");                    if ($command === 'stop') {                        exit(0);                    }                    if ($mode === '-d') {                        static::$daemonize = true;                    }                    break;                }                break;            case 'reload':                if($mode === '-g'){                    $sig = \SIGQUIT;                }else{                    $sig = \SIGUSR1;                }                \posix_kill($master_pid, $sig);                exit;            default :                if (isset($command)) {                    static::safeEcho('Unknown command: ' . $command . ""\n"");                }                exit($usage);        }    }    /**     * Format status data.     *     * @param $statistics_file     * @return string     */    protected static function formatStatusData($statistics_file)    {        static $total_request_cache = array();        if (!\is_readable($statistics_file)) {            return '';        }        $info = \file($statistics_file, \FILE_IGNORE_NEW_LINES);        if (!$info) {            return '';        }        $status_str = '';        $current_total_request = array();        $worker_info = \unserialize($info[0]);        \ksort($worker_info, SORT_NUMERIC);        unset($info[0]);        $data_waiting_sort = array();        $read_process_status = false;        $total_requests = 0;        $total_qps = 0;        $total_connections = 0;        $total_fails = 0;        $total_memory = 0;        $total_timers = 0;        $maxLen1 = static::$_maxSocketNameLength;        $maxLen2 = static::$_maxWorkerNameLength;        foreach($info as $key => $value) {            if (!$read_process_status) {                $status_str .= $value . ""\n"";                if (\preg_match('/^pid.*?memory.*?listening/', $value)) {                    $read_process_status = true;                }                continue;            }            if(\preg_match('/^[0-9]+/', $value, $pid_math)) {                $pid = $pid_math[0];                $data_waiting_sort[$pid] = $value;                if(\preg_match('/^\S+?\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?/', $value, $match)) {                    $total_memory += \intval(\str_ireplace('M','',$match[1]));                    $maxLen1 = \max($maxLen1,\strlen($match[2]));                    $maxLen2 = \max($maxLen2,\strlen($match[3]));                    $total_connections += \intval($match[4]);                    $total_fails += \intval($match[5]);                    $total_timers += \intval($match[6]);                    $current_total_request[$pid] = $match[7];                    $total_requests += \intval($match[7]);                }            }        }        foreach($worker_info as $pid => $info) {            if (!isset($data_waiting_sort[$pid])) {                $status_str .= ""$pid\t"" . \str_pad('N/A', 7) . "" ""                    . \str_pad($info['listen'], static::$_maxSocketNameLength) . "" ""                    . \str_pad($info['name'], static::$_maxWorkerNameLength) . "" ""                    . \str_pad('N/A', 11) . "" "" . \str_pad('N/A', 9) . "" ""                    . \str_pad('N/A', 7) . "" "" . \str_pad('N/A', 13) . "" N/A    [busy] \n"";                continue;            }            //$qps = isset($total_request_cache[$pid]) ? $current_total_request[$pid]            if (!isset($total_request_cache[$pid]) || !isset($current_total_request[$pid])) {                $qps = 0;            } else {                $qps = $current_total_request[$pid] - $total_request_cache[$pid];                $total_qps += $qps;            }            $status_str .= $data_waiting_sort[$pid]. "" "" . \str_pad($qps, 6) ."" [idle]\n"";        }        $total_request_cache = $current_total_request;        $status_str .= ""----------------------------------------------PROCESS STATUS---------------------------------------------------\n"";        $status_str .= ""Summary\t"" . \str_pad($total_memory.'M', 7) . "" ""            . \str_pad('-', $maxLen1) . "" ""            . \str_pad('-', $maxLen2) . "" ""            . \str_pad($total_connections, 11) . "" "" . \str_pad($total_fails, 9) . "" ""            . \str_pad($total_timers, 7) . "" "" . \str_pad($total_requests, 13) . "" ""            . \str_pad($total_qps,6)."" [Summary] \n"";        return $status_str;    }    /**     * Install signal handler.     *     * @return void     */    protected static function installSignal()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        $signalHandler = '\Workerman\Worker::signalHandler';        // stop        \pcntl_signal(\SIGINT, $signalHandler, false);        // stop        \pcntl_signal(\SIGTERM, $signalHandler, false);        // graceful stop        \pcntl_signal(\SIGHUP, $signalHandler, false);        // reload        \pcntl_signal(\SIGUSR1, $signalHandler, false);        // graceful reload        \pcntl_signal(\SIGQUIT, $signalHandler, false);        // status        \pcntl_signal(\SIGUSR2, $signalHandler, false);        // connection status        \pcntl_signal(\SIGIO, $signalHandler, false);        // ignore        \pcntl_signal(\SIGPIPE, \SIG_IGN, false);    }    /**     * Reinstall signal handler.     *     * @return void     */    protected static function reinstallSignal()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        $signalHandler = '\Workerman\Worker::signalHandler';        // uninstall stop signal handler        \pcntl_signal(\SIGINT, \SIG_IGN, false);        // uninstall stop signal handler        \pcntl_signal(\SIGTERM, \SIG_IGN, false);        // uninstall graceful stop signal handler        \pcntl_signal(\SIGHUP, \SIG_IGN, false);        // uninstall reload signal handler        \pcntl_signal(\SIGUSR1, \SIG_IGN, false);        // uninstall graceful reload signal handler        \pcntl_signal(\SIGQUIT, \SIG_IGN, false);        // uninstall status signal handler        \pcntl_signal(\SIGUSR2, \SIG_IGN, false);        // uninstall connections status signal handler        \pcntl_signal(\SIGIO, \SIG_IGN, false);        // reinstall stop signal handler        static::$globalEvent->add(\SIGINT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful stop signal handler        static::$globalEvent->add(\SIGHUP, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall reload signal handler        static::$globalEvent->add(\SIGUSR1, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful reload signal handler        static::$globalEvent->add(\SIGQUIT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall status signal handler        static::$globalEvent->add(\SIGUSR2, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall connection status signal handler        static::$globalEvent->add(\SIGIO, EventInterface::EV_SIGNAL, $signalHandler);    }    /**     * Signal handler.     *     * @param int $signal     */    public static function signalHandler($signal)    {        switch ($signal) {            // Stop.            case \SIGINT:            case \SIGTERM:                static::$_gracefulStop = false;                static::stopAll();                break;            // Graceful stop.            case \SIGHUP:                static::$_gracefulStop = true;                static::stopAll();                break;            // Reload.            case \SIGQUIT:            case \SIGUSR1:                static::$_gracefulStop = $signal === \SIGQUIT;                static::$_pidsToRestart = static::getAllWorkerPids();                static::reload();                break;            // Show status.            case \SIGUSR2:                static::writeStatisticsToStatusFile();                break;            // Show connection status.            case \SIGIO:                static::writeConnectionsStatisticsToStatusFile();                break;        }    }    /**     * Run as deamon mode.     *     * @throws Exception     */    protected static function daemonize()    {        if (!static::$daemonize || static::$_OS !== \OS_TYPE_LINUX) {            return;        }        \umask(0);        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception('Fork fail');        } elseif ($pid > 0) {            exit(0);        }        if (-1 === \posix_setsid()) {            throw new Exception(""Setsid fail"");        }        // Fork again avoid SVR4 system regain the control of terminal.        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception(""Fork fail"");        } elseif (0 !== $pid) {            exit(0);        }    }    /**     * Redirect sta",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
walkor_Workerman_Worker_8641, Get global event-loop instance.\n\n @return EventInterface\n, Get global event-loop instance.,    public static function getEventLoop()    {        return static::$globalEvent;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_8674, check if child processes is really running\n, check if child processes is really running,"    public static function checkIfChildRunning()    {        foreach (static::$_pidMap as $worker_id => $worker_pid_array) {            foreach ($worker_pid_array as $pid => $worker_pid) {                if (!\posix_kill($pid, 0)) {                    unset(static::$_pidMap[$worker_id][$pid]);                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_8692, Check master process is alive\n\n @param int $master_pid\n @return bool\n, Check master process is alive,"    protected static function checkMasterIsAlive($master_pid)    {        if (empty($master_pid)) {            return false;        }        $master_is_alive = $master_pid && \posix_kill((int) $master_pid, 0) && \posix_getpid() !== $master_pid;        if (!$master_is_alive) {            return false;        }        $cmdline = ""/proc/{$master_pid}/cmdline"";        if (!is_readable($cmdline) || empty(static::$processTitle)) {            return true;        }        $content = file_get_contents($cmdline);        if (empty($content)) {            return true;        }        return stripos($content, static::$processTitle) !== false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_9598, Parse command.\n\n @return void\n, Parse command.,"    protected static function parseCommand()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        global $argv;        // Check argv;        $start_file = $argv[0];        $usage = ""Usage: php yourfile <command> [mode]\nCommands: \nstart\t\tStart worker in DEBUG mode.\n\t\tUse mode -d to start in DAEMON mode.\nstop\t\tStop worker.\n\t\tUse mode -g to stop gracefully.\nrestart\t\tRestart workers.\n\t\tUse mode -d to start in DAEMON mode.\n\t\tUse mode -g to stop gracefully.\nreload\t\tReload codes.\n\t\tUse mode -g to reload gracefully.\nstatus\t\tGet worker status.\n\t\tUse mode -d to show live status.\nconnections\tGet worker connections.\n"";        $available_commands = array(            'start',            'stop',            'restart',            'reload',            'status',            'connections',        );        $available_mode = array(            '-d',            '-g'        );        $command = $mode = '';        foreach ($argv as $value) {            if (\in_array($value, $available_commands)) {                $command = $value;            } elseif (\in_array($value, $available_mode)) {                $mode = $value;            }        }        if (!$command) {            exit($usage);        }        // Start command.        $mode_str = '';        if ($command === 'start') {            if ($mode === '-d' || static::$daemonize) {                $mode_str = 'in DAEMON mode';            } else {                $mode_str = 'in DEBUG mode';            }        }        static::log(""Workerman[$start_file] $command $mode_str"");        // Get master process PID.        $master_pid      = \is_file(static::$pidFile) ? (int)\file_get_contents(static::$pidFile) : 0;        // Master is still alive?        if (static::checkMasterIsAlive($master_pid)) {            if ($command === 'start') {                static::log(""Workerman[$start_file] already running"");                exit;            }        } elseif ($command !== 'start' && $command !== 'restart') {            static::log(""Workerman[$start_file] not run"");            exit;        }        $statistics_file =  __DIR__ . ""/../workerman-$master_pid.status"";        // execute command.        switch ($command) {            case 'start':                if ($mode === '-d') {                    static::$daemonize = true;                }                break;            case 'status':                while (1) {                    if (\is_file($statistics_file)) {                        @\unlink($statistics_file);                    }                    // Master process will send SIGUSR2 signal to all child processes.                    \posix_kill($master_pid, SIGUSR2);                    // Sleep 1 second.                    \sleep(1);                    // Clear terminal.                    if ($mode === '-d') {                        static::safeEcho(""\33[H\33[2J\33(B\33[m"", true);                    }                    // Echo status data.                    static::safeEcho(static::formatStatusData($statistics_file));                    if ($mode !== '-d') {                        exit(0);                    }                    static::safeEcho(""\nPress Ctrl+C to quit.\n\n"");                }                exit(0);            case 'connections':                if (\is_file($statistics_file) && \is_writable($statistics_file)) {                    \unlink($statistics_file);                }                // Master process will send SIGIO signal to all child processes.                \posix_kill($master_pid, SIGIO);                // Waiting amoment.                \usleep(500000);                // Display statisitcs data from a disk file.                if(\is_readable($statistics_file)) {                    \readfile($statistics_file);                }                exit(0);            case 'restart':            case 'stop':                if ($mode === '-g') {                    static::$_gracefulStop = true;                    $sig = \SIGHUP;                    static::log(""Workerman[$start_file] is gracefully stopping ..."");                } else {                    static::$_gracefulStop = false;                    $sig = \SIGINT;                    static::log(""Workerman[$start_file] is stopping ..."");                }                // Send stop signal to master process.                $master_pid && \posix_kill($master_pid, $sig);                // Timeout.                $timeout    = 5;                $start_time = \time();                // Check master process is still alive?                while (1) {                    $master_is_alive = $master_pid && \posix_kill((int) $master_pid, 0);                    if ($master_is_alive) {                        // Timeout?                        if (!static::$_gracefulStop && \time() - $start_time >= $timeout) {                            static::log(""Workerman[$start_file] stop fail"");                            exit;                        }                        // Waiting amoment.                        \usleep(10000);                        continue;                    }                    // Stop success.                    static::log(""Workerman[$start_file] stop success"");                    if ($command === 'stop') {                        exit(0);                    }                    if ($mode === '-d') {                        static::$daemonize = true;                    }                    break;                }                break;            case 'reload':                if($mode === '-g'){                    $sig = \SIGQUIT;                }else{                    $sig = \SIGUSR1;                }                \posix_kill($master_pid, $sig);                exit;            default :                if (isset($command)) {                    static::safeEcho('Unknown command: ' . $command . ""\n"");                }                exit($usage);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_9629, Check errors when current process exited.\n\n @return void\n, Check errors when current process exited.,"    public static function checkErrors()    {        if (static::STATUS_SHUTDOWN !== static::$_status) {            $error_msg = static::$_OS === \OS_TYPE_LINUX ? 'Worker['. \posix_getpid() .'] process terminated' : 'Worker process terminated';            $errors    = error_get_last();            if ($errors && ($errors['type'] === \E_ERROR ||                    $errors['type'] === \E_PARSE ||                    $errors['type'] === \E_CORE_ERROR ||                    $errors['type'] === \E_COMPILE_ERROR ||                    $errors['type'] === \E_RECOVERABLE_ERROR)            ) {                $error_msg .= ' with ERROR: ' . static::getErrorType($errors['type']) . "" \""{$errors['message']} in {$errors['file']} on line {$errors['line']}\"""";            }            static::log($error_msg);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_9638, Run worker instance.\n\n @return void\n, Run worker instance.,"    public function run()    {        //Update process state.        static::$_status = static::STATUS_RUNNING;        // Register shutdown function for checking errors.        \register_shutdown_function(array(""\\Workerman\\Worker"", 'checkErrors'));        // Set autoload root path.        Autoloader::setRootPath($this->_autoloadRootPath);        // Create a global event loop.        if (!static::$globalEvent) {            $event_loop_class = static::getEventLoopName();            static::$globalEvent = new $event_loop_class;            $this->resumeAccept();        }        // Reinstall signal.        static::reinstallSignal();        // Init Timer.        Timer::init(static::$globalEvent);        // Set an empty onMessage callback.        if (empty($this->onMessage)) {            $this->onMessage = function () {};        }        \restore_error_handler();        // Try to emit onWorkerStart callback.        if ($this->onWorkerStart) {            try {                \call_user_func($this->onWorkerStart, $this);            } catch (\Exception $e) {                static::log($e);                // Avoid rapid infinite loop exit.                sleep(1);                exit(250);            } catch (\Error $e) {                static::log($e);                // Avoid rapid infinite loop exit.                sleep(1);                exit(250);            }        }        // Main loop.        static::$globalEvent->loop();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationControllerTest_2427, Test creating an annotation for an entry.\n\n @dataProvider dataForEachAnnotations\n, Test creating an annotation for an entry.,"    public function testSetAnnotation($prefixUrl)    {        $em = $this->client->getContainer()->get('doctrine.orm.entity_manager');        if ('annotations' === $prefixUrl) {            $this->logInAs('admin');        }        /** @var Entry $entry */        $entry = $em            ->getRepository('WallabagCoreBundle:Entry')            ->findOneByUsernameAndNotArchived('admin');        $headers = ['CONTENT_TYPE' => 'application/json'];        $content = json_encode([            'text' => 'my annotation',            'quote' => 'my quote',            'ranges' => [                ['start' => '', 'startOffset' => 24, 'end' => '', 'endOffset' => 31],            ],        ]);        $this->client->request('POST', $prefixUrl . '/' . $entry->getId() . '.json', [], [], $headers, $content);        $this->assertSame(200, $this->client->getResponse()->getStatusCode());        $content = json_decode($this->client->getResponse()->getContent(), true);        $this->assertSame('Big boss', $content['user']);        $this->assertSame('v1.0', $content['annotator_schema_version']);        $this->assertSame('my annotation', $content['text']);        $this->assertSame('my quote', $content['quote']);        /** @var Annotation $annotation */        $annotation = $em            ->getRepository('WallabagAnnotationBundle:Annotation')            ->findLastAnnotationByPageId($entry->getId(), 1);        $this->assertSame('my annotation', $annotation->getText());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationControllerTest_2430, Test deleting an annotation.\\n\\n @dataProvider dataForEachAnnotations\\n, Test deleting an annotation.,"    public function testDeleteAnnotation($prefixUrl)    {        $em = $this->client->getContainer()->get('doctrine.orm.entity_manager');        $user = $em            ->getRepository('WallabagUserBundle:User')            ->findOneByUserName('admin');        $entry = $em            ->getRepository('WallabagCoreBundle:Entry')            ->findOneByUsernameAndNotArchived('admin');        $annotation = new Annotation($user);        $annotation->setEntry($entry);        $annotation->setText('This is my annotation /o/');        $annotation->setQuote('my quote');        $em->persist($annotation);        $em->flush();        if ('annotations' === $prefixUrl) {            $this->logInAs('admin');        }        $headers = ['CONTENT_TYPE' => 'application/json'];        $content = json_encode([            'text' => 'a modified annotation',        ]);        $this->client->request('DELETE', $prefixUrl . '/' . $annotation->getId() . '.json', [], [], $headers, $content);        $this->assertSame(200, $this->client->getResponse()->getStatusCode());        $content = json_decode($this->client->getResponse()->getContent(), true);        $this->assertSame('This is my annotation /o/', $content['text']);        $annotationDeleted = $em            ->getRepository('WallabagAnnotationBundle:Annotation')            ->findOneById($annotation->getId());        $this->assertNull($annotationDeleted);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2417, Get annotation for this id.\\n\\n @param int $annotationId\\n\\n @return array\\n, Get annotation for this id.,"    public function findAnnotationById($annotationId)    {        return $this->createQueryBuilder('a')            ->andWhere('a.id = :annotationId')->setParameter('annotationId', $annotationId)            ->getQuery()            ->getSingleResult()        ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2420, Used only in test case to get the right annotation associated to the right user.\\n\\n @param string $username\\n\\n @return Annotation\\n, Used only in test case to get the right annotation associated to the right user.,"    public function findOneByUsername($username)    {        return $this->createQueryBuilder('a')            ->leftJoin('a.user', 'u')            ->where('u.username = :username')->setParameter('username', $username)            ->orderBy('a.id', 'DESC')            ->setMaxResults(1)            ->getQuery()            ->getSingleResult();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2422, Find all annotations related to archived entries.\n\n @param $userId\n\n @return mixed\n, Find all annotations related to archived entries.,"    public function findAllArchivedEntriesByUser($userId)    {        return $this->createQueryBuilder('a')            ->leftJoin('a.entry', 'e')            ->where('a.user = :userid')->setParameter(':userid', $userId)            ->andWhere('e.isArchived = true')            ->getQuery()            ->getResult();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_Annotation_2398," Annotation.\\n\\n @ORM\\\\Table(name=""annotation"")\\n @ORM\\\\Entity(repositoryClass=""Wallabag\\\\AnnotationBundle\\\\Repository\\\\AnnotationRepository"")\\n @ORM\\\\HasLifecycleCallbacks()\\n @ExclusionPolicy(""none"")\\n", Annotation.,"class Annotation{    use EntityTimestampsTrait;    /**     * @var int     *     * @ORM\Column(name=""id"", type=""integer"")     * @ORM\Id     * @ORM\GeneratedValue(strategy=""AUTO"")     */    private $id;    /**     * @var string     *     * @ORM\Column(name=""text"", type=""text"")     *     * @Groups({""entries_for_user"", ""export_all""})     */    private $text;    /**     * @var \DateTime     *     * @ORM\Column(name=""created_at"", type=""datetime"")     */    private $createdAt;    /**     * @var \DateTime     *     * @ORM\Column(name=""updated_at"", type=""datetime"")     */    private $updatedAt;    /**     * @var string     *     * @Assert\Length(     *     max = 10000,     *     maxMessage = ""validator.quote_length_too_high""     * )     * @ORM\Column(name=""quote"", type=""text"")     *     * @Groups({""entries_for_user"", ""export_all""})     */    private $quote;    /**     * @var array     *     * @ORM\Column(name=""ranges"", type=""array"")     *     * @Groups({""entries_for_user"", ""export_all""})     */    private $ranges;    /**     * @Exclude     *     * @ORM\ManyToOne(targetEntity=""Wallabag\UserBundle\Entity\User"")     */    private $user;    /**     * @Exclude     *     * @ORM\ManyToOne(targetEntity=""Wallabag\CoreBundle\Entity\Entry"", inversedBy=""annotations"")     * @ORM\JoinColumn(name=""entry_id"", referencedColumnName=""id"", onDelete=""cascade"")     */    private $entry;    /*     * @param User     $user     */    public function __construct(User $user)    {        $this->user = $user;    }    /**     * Get id.     *     * @return int     */    public function getId()    {        return $this->id;    }    /**     * Set text.     *     * @param string $text     *     * @return Annotation     */    public function setText($text)    {        $this->text = $text;        return $this;    }    /**     * Get text.     *     * @return string     */    public function getText()    {        return $this->text;    }    /**     * Get created.     *     * @return \DateTime     */    public function getCreatedAt()    {        return $this->createdAt;    }    /**     * Get updated.     *     * @return \DateTime     */    public function getUpdatedAt()    {        return $this->updatedAt;    }    /**     * Get quote.     *     * @return string     */    public function getQuote()    {        return $this->quote;    }    /**     * Set quote.     *     * @param string $quote     *     * @return Annotation     */    public function setQuote($quote)    {        $this->quote = $quote;        return $this;    }    /**     * Get ranges.     *     * @return array     */    public function getRanges()    {        return $this->ranges;    }    /**     * Set ranges.     *     * @param array $ranges     *     * @return Annotation     */    public function setRanges($ranges)    {        $this->ranges = $ranges;        return $this;    }    /**     * Set user.     *     * @param User $user     *     * @return Annotation     */    public function setUser($user)    {        $this->user = $user;        return $this;    }    /**     * Get user.     *     * @return User     */    public function getUser()    {        return $this->user;    }    /**     * @VirtualProperty     * @SerializedName(""user"")     */    public function getUserName()    {        return $this->user->getName();    }    /**     * Set entry.     *     * @param Entry $entry     *     * @return Annotation     */    public function setEntry($entry)    {        $this->entry = $entry;        $entry->setAnnotation($this);        return $this;    }    /**     * Get entry.     *     * @return Entry     */    public function getEntry()    {        return $this->entry;    }    /**     * @VirtualProperty     * @SerializedName(""annotator_schema_version"")     */    public function getVersion()    {        return 'v1.0';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_SymfonyRequirements_2441, Represents a PHP requirement in form of a php.ini configuration.\\n\\n @author Tobias Schultze <http://tobion.de>\\n, Represents a PHP requirement in form of a php.ini configuration.,"class PhpIniRequirement extends Requirement{    /**     * Constructor that initializes the requirement.     *     * @param string        $cfgName           The configuration name used for ini_get()     * @param bool|callback $evaluation        Either a boolean indicating whether the configuration should evaluate to true or false,     *                                         or a callback function receiving the configuration value as parameter to determine the fulfillment of the requirement     * @param bool          $approveCfgAbsence If true the Requirement will be fulfilled even if the configuration option does not exist, i.e. ini_get() returns false.     *                                         This is helpful for abandoned configs in later PHP versions or configs of an optional extension, like Suhosin.     *                                         Example: You require a config to be true but PHP later removes this config and defaults it to true internally.     * @param string|null   $testMessage       The message for testing the requirement (when null and $evaluation is a boolean a default message is derived)     * @param string|null   $helpHtml          The help text formatted in HTML for resolving the problem (when null and $evaluation is a boolean a default help is derived)     * @param string|null   $helpText          The help text (when null, it will be inferred from $helpHtml, i.e. stripped from HTML tags)     * @param bool          $optional          Whether this is only an optional recommendation not a mandatory requirement     */    public function __construct($cfgName, $evaluation, $approveCfgAbsence = false, $testMessage = null, $helpHtml = null, $helpText = null, $optional = false)    {        $cfgValue = ini_get($cfgName);        if (is_callable($evaluation)) {            if (null === $testMessage || null === $helpHtml) {                throw new InvalidArgumentException('You must provide the parameters testMessage and helpHtml for a callback evaluation.');            }            $fulfilled = call_user_func($evaluation, $cfgValue);        } else {            if (null === $testMessage) {                $testMessage = sprintf('%s %s be %s in php.ini',                    $cfgName,                    $optional ? 'should' : 'must',                    $evaluation ? 'enabled' : 'disabled'                );            }            if (null === $helpHtml) {                $helpHtml = sprintf('Set <strong>%s</strong> to <strong>%s</strong> in php.ini<a href=""#phpini"">*</a>.',                    $cfgName,                    $evaluation ? 'on' : 'off'                );            }            $fulfilled = $evaluation == $cfgValue;        }        parent::__construct($fulfilled || ($approveCfgAbsence && false === $cfgValue), $testMessage, $helpHtml, $helpText, $optional);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_SymfonyRequirements_2448, Returns the mandatory requirements that were not met.\n\n @return Requirement[]\n, Returns the mandatory requirements that were not met.,    public function getFailedRequirements()    {        $array = array();        foreach ($this->requirements as $req) {            if (!$req->isFulfilled() && !$req->isOptional()) {                $array[] = $req;            }        }        return $array;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_SymfonyRequirements_2449, Returns all optional recommendations.\n\n @return Requirement[]\n, Returns all optional recommendations.,    public function getRecommendations()    {        $array = array();        foreach ($this->requirements as $req) {            if ($req->isOptional()) {                $array[] = $req;            }        }        return $array;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_SymfonyRequirements_2450, Returns the recommendations that were not met.\n\n @return Requirement[]\n, Returns the recommendations that were not met.,    public function getFailedRecommendations()    {        $array = array();        foreach ($this->requirements as $req) {            if (!$req->isFulfilled() && $req->isOptional()) {                $array[] = $req;            }        }        return $array;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_SymfonyRequirements_2455, Loads realpath_cache_size from php.ini and converts it to int.\n\n (e.g. 16k is converted to 16384 int)\n\n @return int\n, Loads realpath_cache_size from php.ini and converts it to int.,"    protected function getRealpathCacheSize()    {        $size = ini_get('realpath_cache_size');        $size = trim($size);        $unit = '';        if (!ctype_digit($size)) {            $unit = strtolower(substr($size, -1, 1));            $size = (int) substr($size, 0, -1);        }        switch ($unit) {            case 'g':                return $size * 1024 * 1024 * 1024;            case 'm':                return $size * 1024 * 1024;            case 'k':                return $size * 1024;            default:                return (int) $size;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_Version20161001072726_2387, Added pocket_consumer_key field on wallabag_config.\n, Added pocket_consumer_key field on wallabag_config.,"class Version20161001072726 extends WallabagMigration{    public function up(Schema $schema)    {        $this->skipIf('sqlite' === $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\' or \'postgresql\'.');        // remove all FK from entry_tag        switch ($this->connection->getDatabasePlatform()->getName()) {            case 'mysql':                $query = $this->connection->query(""                    SELECT CONSTRAINT_NAME                    FROM information_schema.key_column_usage                    WHERE TABLE_NAME = '"" . $this->getTable('entry_tag', WallabagMigration::UN_ESCAPED_TABLE) . ""' AND CONSTRAINT_NAME LIKE 'FK_%'                    AND TABLE_SCHEMA = '"" . $this->connection->getDatabase() . ""'""                );                $query->execute();                foreach ($query->fetchAll() as $fk) {                    $this->addSql('ALTER TABLE ' . $this->getTable('entry_tag') . ' DROP FOREIGN KEY ' . $fk['CONSTRAINT_NAME']);                }                break;            case 'postgresql':                // http://dba.stackexchange.com/questions/36979/retrieving-all-pk-and-fk                $query = $this->connection->query(""                    SELECT conrelid::regclass AS table_from                          ,conname                          ,pg_get_constraintdef(c.oid)                    FROM   pg_constraint c                    JOIN   pg_namespace n ON n.oid = c.connamespace                    WHERE  contype = 'f'                    AND    conrelid::regclass::text = '"" . $this->getTable('entry_tag', WallabagMigration::UN_ESCAPED_TABLE) . ""'                    AND    n.nspname = 'public';""                );                $query->execute();                foreach ($query->fetchAll() as $fk) {                    $this->addSql('ALTER TABLE ' . $this->getTable('entry_tag') . ' DROP CONSTRAINT ' . $fk['conname']);                }                break;        }        $this->addSql('ALTER TABLE ' . $this->getTable('entry_tag') . ' ADD CONSTRAINT FK_entry_tag_entry FOREIGN KEY (entry_id) REFERENCES ' . $this->getTable('entry') . ' (id) ON DELETE CASCADE');        $this->addSql('ALTER TABLE ' . $this->getTable('entry_tag') . ' ADD CONSTRAINT FK_entry_tag_tag FOREIGN KEY (tag_id) REFERENCES ' . $this->getTable('tag') . ' (id) ON DELETE CASCADE');        // remove entry FK from annotation        switch ($this->connection->getDatabasePlatform()->getName()) {            case 'mysql':                $query = $this->connection->query(""                    SELECT CONSTRAINT_NAME                    FROM information_schema.key_column_usage                    WHERE TABLE_NAME = '"" . $this->getTable('annotation', WallabagMigration::UN_ESCAPED_TABLE) . ""'                    AND CONSTRAINT_NAME LIKE 'FK_%'                    AND COLUMN_NAME = 'entry_id'                    AND TABLE_SCHEMA = '"" . $this->connection->getDatabase() . ""'""                );                $query->execute();                foreach ($query->fetchAll() as $fk) {                    $this->addSql('ALTER TABLE ' . $this->getTable('annotation') . ' DROP FOREIGN KEY ' . $fk['CONSTRAINT_NAME']);                }                break;            case 'postgresql':                // http://dba.stackexchange.com/questions/36979/retrieving-all-pk-and-fk                $query = $this->connection->query(""                    SELECT conrelid::regclass AS table_from                          ,conname                          ,pg_get_constraintdef(c.oid)                    FROM   pg_constraint c                    JOIN   pg_namespace n ON n.oid = c.connamespace                    WHERE  contype = 'f'                    AND    conrelid::regclass::text = '"" . $this->getTable('annotation', WallabagMigration::UN_ESCAPED_TABLE) . ""'                    AND    n.nspname = 'public'                    AND    pg_get_constraintdef(c.oid) LIKE '%entry_id%';""                );                $query->execute();                foreach ($query->fetchAll() as $fk) {                    $this->addSql('ALTER TABLE ' . $this->getTable('annotation') . ' DROP CONSTRAINT ' . $fk['conname']);                }                break;        }        $this->addSql('ALTER TABLE ' . $this->getTable('annotation') . ' ADD CONSTRAINT FK_annotation_entry FOREIGN KEY (entry_id) REFERENCES ' . $this->getTable('entry') . ' (id) ON DELETE CASCADE');    }    public function down(Schema $schema)    {        throw new SkipMigrationException('Too complex ...');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_Version20161022134138_2388, Converted database to utf8mb4 encoding (for MySQL only).\\n, Converted database to utf8mb4 encoding (for MySQL only).,"class Version20161022134138 extends WallabagMigration{    public function up(Schema $schema)    {        $this->skipIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'This migration only apply to MySQL');        $this->addSql('ALTER DATABASE `' . $this->connection->getParams()['dbname'] . '` CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;');        // convert field length for utf8mb4        // http://stackoverflow.com/a/31474509/569101        $this->addSql('ALTER TABLE ' . $this->getTable('user') . ' CHANGE confirmation_token confirmation_token VARCHAR(180) DEFAULT NULL;');        $this->addSql('ALTER TABLE ' . $this->getTable('user') . ' CHANGE salt salt VARCHAR(180) NOT NULL;');        $this->addSql('ALTER TABLE ' . $this->getTable('user') . ' CHANGE password password VARCHAR(180) NOT NULL;');        $this->addSql('ALTER TABLE ' . $this->getTable('annotation') . ' CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('entry') . ' CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('tag') . ' CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('user') . ' CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('annotation') . ' CHANGE `text` `text` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('annotation') . ' CHANGE `quote` `quote` VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('entry') . ' CHANGE `title` `title` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('entry') . ' CHANGE `content` `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('tag') . ' CHANGE `label` `label` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('user') . ' CHANGE `name` `name` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;');    }    public function down(Schema $schema)    {        $this->skipIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'This migration only apply to MySQL');        $this->addSql('ALTER DATABASE `' . $this->connection->getParams()['dbname'] . '` CHARACTER SET = utf8 COLLATE = utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('annotation') . ' CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('entry') . ' CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('tag') . ' CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('user') . ' CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('annotation') . ' CHANGE `text` `text` longtext CHARACTER SET utf8 COLLATE utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('annotation') . ' CHANGE `quote` `quote` VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('entry') . ' CHANGE `title` `title` longtext CHARACTER SET utf8 COLLATE utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('entry') . ' CHANGE `content` `content` longtext CHARACTER SET utf8 COLLATE utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('tag') . ' CHANGE `label` `label` longtext CHARACTER SET utf8 COLLATE utf8_unicode_ci;');        $this->addSql('ALTER TABLE ' . $this->getTable('user') . ' CHANGE `name` `name` longtext CHARACTER SET utf8 COLLATE utf8_unicode_ci;');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_Version20161024212538_2389, Added user_id column on oauth2_clients to prevent users to delete API clients from other users.\n, Added user_id column on oauth2_clients to prevent users to delete API clients from other users.,"class Version20161024212538 extends WallabagMigration{    private $constraintName = 'IDX_user_oauth_client';    public function up(Schema $schema)    {        $clientsTable = $schema->getTable($this->getTable('oauth2_clients'));        $this->skipIf($clientsTable->hasColumn('user_id'), 'It seems that you already played this migration.');        $clientsTable->addColumn('user_id', 'integer', ['notnull' => false]);        $clientsTable->addForeignKeyConstraint(            $this->getTable('user'),            ['user_id'],            ['id'],            ['onDelete' => 'CASCADE'],            $this->constraintName        );    }    public function down(Schema $schema)    {        $clientsTable = $schema->getTable($this->getTable('oauth2_clients'));        $this->skipIf(!$clientsTable->hasColumn('user_id'), 'It seems that you already played this migration.');        $clientsTable->dropColumn('user_id', 'integer');        if ('sqlite' !== $this->connection->getDatabasePlatform()->getName()) {            $clientsTable->removeForeignKey($this->constraintName);        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_ActionEvent_1006," ActionEvent represents the event parameter used for an action event.\\\\n\\\\n By setting the [[isValid]] property, one may control whether to continue running the action.\\\\n\\\\n @author Qiang Xue <qiang.xue@gmail.com>\\\\n @since 2.0\\\\n", ActionEvent represents the event parameter used for an action event.,"class ActionEvent extends Event{    /**     * @var Action the action currently being executed     */    public $action;    /**     * @var mixed the action result. Event handlers may modify this property to change the action result.     */    public $result;    /**     * @var bool whether to continue running the action. Event handlers of     * [[Controller::EVENT_BEFORE_ACTION]] may set this property to decide whether     * to continue running the current action.     */    public $isValid = true;    /**     * Constructor.     * @param Action $action the action associated with this action event.     * @param array $config name-value pairs that will be used to initialize the object properties     */    public function __construct($action, $config = [])    {        $this->action = $action;        parent::__construct($config);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_ActionFilter_1007," ActionFilter is the base class for action filters.\n\n An action filter will participate in the action execution workflow by responding to\n the `beforeAction` and `afterAction` events triggered by modules and controllers.\n\n Check implementation of [[\\yii\\filters\\AccessControl]], [[\\yii\\filters\\PageCache]] and [[\\yii\\filters\\HttpCache]] as examples on how to use it.\n\n For more details and usage information on ActionFilter, see the [guide article on filters](guide:structure-filters).\n\n @author Qiang Xue <qiang.xue@gmail.com>\n @since 2.0\n", ActionFilter is the base class for action filters.,"class ActionFilter extends Behavior{    /**     * @var array list of action IDs that this filter should apply to. If this property is not set,     * then the filter applies to all actions, unless they are listed in [[except]].     * If an action ID appears in both [[only]] and [[except]], this filter will NOT apply to it.     *     * Note that if the filter is attached to a module, the action IDs should also include child module IDs (if any)     * and controller IDs.     *     * Since version 2.0.9 action IDs can be specified as wildcards, e.g. `site/*`.     *     * @see except     */    public $only;    /**     * @var array list of action IDs that this filter should not apply to.     * @see only     */    public $except = [];    /**     * {@inheritdoc}     */    public function attach($owner)    {        $this->owner = $owner;        $owner->on(Controller::EVENT_BEFORE_ACTION, [$this, 'beforeFilter']);    }    /**     * {@inheritdoc}     */    public function detach()    {        if ($this->owner) {            $this->owner->off(Controller::EVENT_BEFORE_ACTION, [$this, 'beforeFilter']);            $this->owner->off(Controller::EVENT_AFTER_ACTION, [$this, 'afterFilter']);            $this->owner = null;        }    }    /**     * @param ActionEvent $event     */    public function beforeFilter($event)    {        if (!$this->isActive($event->action)) {            return;        }        $event->isValid = $this->beforeAction($event->action);        if ($event->isValid) {            // call afterFilter only if beforeFilter succeeds            // beforeFilter and afterFilter should be properly nested            $this->owner->on(Controller::EVENT_AFTER_ACTION, [$this, 'afterFilter'], null, false);        } else {            $event->handled = true;        }    }    /**     * @param ActionEvent $event     */    public function afterFilter($event)    {        $event->result = $this->afterAction($event->action, $event->result);        $this->owner->off(Controller::EVENT_AFTER_ACTION, [$this, 'afterFilter']);    }    /**     * This method is invoked right before an action is to be executed (after all possible filters.)     * You may override this method to do last-minute preparation for the action.     * @param Action $action the action to be executed.     * @return bool whether the action should continue to be executed.     */    public function beforeAction($action)    {        return true;    }    /**     * This method is invoked right after an action is executed.     * You may override this method to do some postprocessing for the action.     * @param Action $action the action just executed.     * @param mixed $result the action execution result     * @return mixed the processed action result.     */    public function afterAction($action, $result)    {        return $result;    }    /**     * Returns an action ID by converting [[Action::$uniqueId]] into an ID relative to the module.     * @param Action $action     * @return string     * @since 2.0.7     */    protected function getActionId($action)    {        if ($this->owner instanceof Module) {            $mid = $this->owner->getUniqueId();            $id = $action->getUniqueId();            if ($mid !== '' && strpos($id, $mid) === 0) {                $id = substr($id, strlen($mid) + 1);            }        } else {            $id = $action->id;        }        return $id;    }    /**     * Returns a value indicating whether the filter is active for the given action.     * @param Action $action the action being filtered     * @return bool whether the filter is active for the given action.     */    protected function isActive($action)    {        $id = $this->getActionId($action);        if (empty($this->only)) {            $onlyMatch = true;        } else {            $onlyMatch = false;            foreach ($this->only as $pattern) {                if (StringHelper::matchWildcard($pattern, $id)) {                    $onlyMatch = true;                    break;                }            }        }        $exceptMatch = false;        foreach ($this->except as $pattern) {            if (StringHelper::matchWildcard($pattern, $id)) {                $exceptMatch = true;                break;            }        }        return !$exceptMatch && $onlyMatch;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_ActionFilter_1014, Returns an action ID by converting [[Action::$uniqueId]] into an ID relative to the module.\\\\n @param Action $action\\\\n @return string\\\\n @since 2.0.7\\\\n, Returns an action ID by converting [[Action::$uniqueId]] into an ID relative to the module.,"    protected function getActionId($action)    {        if ($this->owner instanceof Module) {            $mid = $this->owner->getUniqueId();            $id = $action->getUniqueId();            if ($mid !== '' && strpos($id, $mid) === 0) {                $id = substr($id, strlen($mid) + 1);            }        } else {            $id = $action->id;        }        return $id;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Action_1001," Action is the base class for all controller action classes.\\\\n\\\\n Action provides a way to reuse action method code. An action method in an Action\\\\n class can be used in multiple controllers or in different projects.\\\\n\\\\n Derived classes must implement a method named `run()`. This method\\\\n will be invoked by the controller when the action is requested.\\\\n The `run()` method can have parameters which will be filled up\\\\n with user input values automatically according to their names.\\\\n For example, if the `run()` method is declared as follows:\\\\n\\\\n ```php\\\\n public function run($id, $type = 'book') { ... }\\\\n ```\\\\n\\\\n And the parameters provided for the action are: `['id' => 1]`.\\\\n Then the `run()` method will be invoked as `run(1)` automatically.\\\\n\\\\n For more details and usage information on Action, see the [guide article on actions](guide:structure-controllers).\\\\n\\\\n @property-read string $uniqueId The unique ID of this action among the whole application. This property is\\\\n read-only.\\\\n\\\\n @author Qiang Xue <qiang.xue@gmail.com>\\\\n @since 2.0\\\\n", Action is the base class for all controller action classes.,"class Action extends Component{    /**     * @var string ID of the action     */    public $id;    /**     * @var Controller|\yii\web\Controller|\yii\console\Controller the controller that owns this action     */    public $controller;    /**     * Constructor.     *     * @param string $id the ID of this action     * @param Controller $controller the controller that owns this action     * @param array $config name-value pairs that will be used to initialize the object properties     */    public function __construct($id, $controller, $config = [])    {        $this->id = $id;        $this->controller = $controller;        parent::__construct($config);    }    /**     * Returns the unique ID of this action among the whole application.     *     * @return string the unique ID of this action among the whole application.     */    public function getUniqueId()    {        return $this->controller->getUniqueId() . '/' . $this->id;    }    /**     * Runs this action with the specified parameters.     * This method is mainly invoked by the controller.     *     * @param array $params the parameters to be bound to the action's run() method.     * @return mixed the result of the action     * @throws InvalidConfigException if the action class does not have a run() method     */    public function runWithParams($params)    {        if (!method_exists($this, 'run')) {            throw new InvalidConfigException(get_class($this) . ' must define a ""run()"" method.');        }        $args = $this->controller->bindActionParams($this, $params);        Yii::debug('Running action: ' . get_class($this) . '::run(), invoked by '  . get_class($this->controller), __METHOD__);        if (Yii::$app->requestedParams === null) {            Yii::$app->requestedParams = $args;        }        if ($this->beforeRun()) {            $result = call_user_func_array([$this, 'run'], $args);            $this->afterRun();            return $result;        }        return null;    }    /**     * This method is called right before `run()` is executed.     * You may override this method to do preparation work for the action run.     * If the method returns false, it will cancel the action.     *     * @return bool whether to run the action.     */    protected function beforeRun()    {        return true;    }    /**     * This method is called right after `run()` is executed.     * You may override this method to do post-processing work for the action run.     */    protected function afterRun()    {    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Action_1002, Returns the unique ID of this action among the whole application.\n\n @return string the unique ID of this action among the whole application.\n, Returns the unique ID of this action among the whole application.,    public function getUniqueId()    {        return $this->controller->getUniqueId() . '/' . $this->id;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Action_1003, Runs this action with the specified parameters.\\n This method is mainly invoked by the controller.\\n\\n @param array $params the parameters to be bound to the action's run() method.\\n @return mixed the result of the action\\n @throws InvalidConfigException if the action class does not have a run() method\\n, Runs this action with the specified parameters.,"    public function runWithParams($params)    {        if (!method_exists($this, 'run')) {            throw new InvalidConfigException(get_class($this) . ' must define a ""run()"" method.');        }        $args = $this->controller->bindActionParams($this, $params);        Yii::debug('Running action: ' . get_class($this) . '::run(), invoked by '  . get_class($this->controller), __METHOD__);        if (Yii::$app->requestedParams === null) {            Yii::$app->requestedParams = $args;        }        if ($this->beforeRun()) {            $result = call_user_func_array([$this, 'run'], $args);            $this->afterRun();            return $result;        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Application_1017," Pre-initializes the application.\\\\n This method is called at the beginning of the application constructor.\\\\n It initializes several important application properties.\\\\n If you override this method, please make sure you call the parent implementation.\\\\n @param array $config the application configuration\\\\n @throws InvalidConfigException if either [[id]] or [[basePath]] configuration is missing.\\\\n", Pre-initializes the application.,"    public function preInit(&$config)    {        if (!isset($config['id'])) {            throw new InvalidConfigException('The ""id"" configuration for the Application is required.');        }        if (isset($config['basePath'])) {            $this->setBasePath($config['basePath']);            unset($config['basePath']);        } else {            throw new InvalidConfigException('The ""basePath"" configuration for the Application is required.');        }        if (isset($config['vendorPath'])) {            $this->setVendorPath($config['vendorPath']);            unset($config['vendorPath']);        } else {            // set ""@vendor""            $this->getVendorPath();        }        if (isset($config['runtimePath'])) {            $this->setRuntimePath($config['runtimePath']);            unset($config['runtimePath']);        } else {            // set ""@runtime""            $this->getRuntimePath();        }        if (isset($config['timeZone'])) {            $this->setTimeZone($config['timeZone']);            unset($config['timeZone']);        } elseif (!ini_get('date.timezone')) {            $this->setTimeZone('UTC');        }        if (isset($config['container'])) {            $this->setContainer($config['container']);            unset($config['container']);        }        // merge core components with custom components        foreach ($this->coreComponents() as $id => $component) {            if (!isset($config['components'][$id])) {                $config['components'][$id] = $component;            } elseif (is_array($config['components'][$id]) && !isset($config['components'][$id]['class'])) {                $config['components'][$id]['class'] = $component['class'];            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Application_1019," Initializes extensions and executes bootstrap components.\\\\n This method is called by [[init()]] after the application has been fully configured.\\\\n If you override this method, make sure you also call the parent implementation.\\\\n", Initializes extensions and executes bootstrap components.,"    protected function bootstrap()    {        if ($this->extensions === null) {            $file = Yii::getAlias('@vendor/yiisoft/extensions.php');            $this->extensions = is_file($file) ? include $file : [];        }        foreach ($this->extensions as $extension) {            if (!empty($extension['alias'])) {                foreach ($extension['alias'] as $name => $path) {                    Yii::setAlias($name, $path);                }            }            if (isset($extension['bootstrap'])) {                $component = Yii::createObject($extension['bootstrap']);                if ($component instanceof BootstrapInterface) {                    Yii::debug('Bootstrap with ' . get_class($component) . '::bootstrap()', __METHOD__);                    $component->bootstrap($this);                } else {                    Yii::debug('Bootstrap with ' . get_class($component), __METHOD__);                }            }        }        foreach ($this->bootstrap as $mixed) {            $component = null;            if ($mixed instanceof \Closure) {                Yii::debug('Bootstrap with Closure', __METHOD__);                if (!$component = call_user_func($mixed, $this)) {                    continue;                }            } elseif (is_string($mixed)) {                if ($this->has($mixed)) {                    $component = $this->get($mixed);                } elseif ($this->hasModule($mixed)) {                    $component = $this->getModule($mixed);                } elseif (strpos($mixed, '\\') === false) {                    throw new InvalidConfigException(""Unknown bootstrapping component ID: $mixed"");                }            }            if (!isset($component)) {                $component = Yii::createObject($mixed);            }            if ($component instanceof BootstrapInterface) {                Yii::debug('Bootstrap with ' . get_class($component) . '::bootstrap()', __METHOD__);                $component->bootstrap($this);            } else {                Yii::debug('Bootstrap with ' . get_class($component), __METHOD__);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Application_1020, Registers the errorHandler component as a PHP error handler.\\n @param array $config application config\\n, Registers the errorHandler component as a PHP error handler.,"    protected function registerErrorHandler(&$config)    {        if (YII_ENABLE_ERROR_HANDLER) {            if (!isset($config['components']['errorHandler']['class'])) {                echo ""Error: no errorHandler component is configured.\n"";                exit(1);            }            $this->set('errorHandler', $config['components']['errorHandler']);            unset($config['components']['errorHandler']);            $this->getErrorHandler()->register();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Application_1028, Sets the directory that stores vendor files.\n @param string $path the directory that stores vendor files.\n, Sets the directory that stores vendor files.,"    public function setVendorPath($path)    {        $this->_vendorPath = Yii::getAlias($path);        Yii::setAlias('@vendor', $this->_vendorPath);        Yii::setAlias('@bower', $this->_vendorPath . DIRECTORY_SEPARATOR . 'bower');        Yii::setAlias('@npm', $this->_vendorPath . DIRECTORY_SEPARATOR . 'npm');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Application_1045, Returns the configuration of core application components.\\\\n @see set()\\\\n, Returns the configuration of core application components.,"    public function coreComponents()    {        return [            'log' => ['class' => 'yii\log\Dispatcher'],            'view' => ['class' => 'yii\web\View'],            'formatter' => ['class' => 'yii\i18n\Formatter'],            'i18n' => ['class' => 'yii\i18n\I18N'],            'mailer' => ['class' => 'yii\swiftmailer\Mailer'],            'urlManager' => ['class' => 'yii\web\UrlManager'],            'assetManager' => ['class' => 'yii\web\AssetManager'],            'security' => ['class' => 'yii\base\Security'],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_BaseYii_992," Returns the root alias part of a given alias.\n A root alias is an alias that has been registered via [[setAlias()]] previously.\n If a given alias matches multiple root aliases, the longest one will be returned.\n @param string $alias the alias\n @return string|false the root alias, or false if no root alias is found\n", Returns the root alias part of a given alias.,"    public static function getRootAlias($alias)    {        $pos = strpos($alias, '/');        $root = $pos === false ? $alias : substr($alias, 0, $pos);        if (isset(static::$aliases[$root])) {            if (is_string(static::$aliases[$root])) {                return $root;            }            foreach (static::$aliases[$root] as $name => $path) {                if (strpos($alias . '/', $name . '/') === 0) {                    return $name;                }            }        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_BaseYii_997," Returns an HTML hyperlink that can be displayed on your Web page showing ""Powered by Yii Framework"" information.\\n @return string an HTML hyperlink that can be displayed on your Web page showing ""Powered by Yii Framework"" information\\n @deprecated since 2.0.14, this method will be removed in 2.1.0.\\n"," Returns an HTML hyperlink that can be displayed on your Web page showing ""Powered by Yii Framework"" information.","    public static function powered()    {        return \Yii::t('yii', 'Powered by {yii}', [            'yii' => '<a href=""http://www.yiiframework.com/"" rel=""external"">' . \Yii::t('yii',                    'Yii Framework') . '</a>',        ]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_BaseYii_998, Configures an object with the initial property values.\n @param object $object the object to be configured\n @param array $properties the property initial values given in terms of name-value pairs.\n @return object the object itself\n, Configures an object with the initial property values.,"    public static function configure($object, $properties)    {        foreach ($properties as $name => $value) {            $object->$name = $value;        }        return $object;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_DevController_951, Install all extensions and advanced + basic app.\n, Install all extensions and advanced + basic app.,    public function actionAll()    {        if (!$this->confirm('Install all applications and all extensions now?')) {            return 1;        }        foreach ($this->extensions as $ext => $repo) {            $ret = $this->actionExt($ext);            if ($ret !== 0) {                return $ret;            }        }        foreach ($this->apps as $app => $repo) {            $ret = $this->actionApp($app);            if ($ret !== 0) {                return $ret;            }        }        return 0;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_DevController_952, Runs a command in all extension and application directories.\n\n Can be used to run e.g. `git pull`.\n\n     ./build/build dev/run git pull\n\n @param string $command the command to run\n, Runs a command in all extension and application directories.,"    public function actionRun($command)    {        $command = implode(' ', \func_get_args());        // root of the dev repo        $base = \dirname(\dirname(__DIR__));        $dirs = $this->listSubDirs(""$base/extensions"");        $dirs = array_merge($dirs, $this->listSubDirs(""$base/apps""));        asort($dirs);        $oldcwd = getcwd();        foreach ($dirs as $dir) {            $displayDir = substr($dir, \strlen($base));            $this->stdout(""Running '$command' in $displayDir...\n"", Console::BOLD);            chdir($dir);            passthru($command);            $this->stdout(""done.\n"", Console::BOLD, Console::FG_GREEN);        }        chdir($oldcwd);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_DevController_954, Remove all symlinks in the vendor subdirectory of the directory specified.\\\\n @param string $dir base directory\\\\n, Remove all symlinks in the vendor subdirectory of the directory specified.,"    protected function cleanupVendorDir($dir)    {        if (is_link($link = ""$dir/vendor/yiisoft/yii2"")) {            $this->stdout(""Removing symlink $link.\n"");            FileHelper::unlink($link);        }        $extensions = $this->findDirs(""$dir/vendor/yiisoft"");        foreach ($extensions as $ext) {            if (is_link($link = ""$dir/vendor/yiisoft/yii2-$ext"")) {                $this->stdout(""Removing symlink $link.\n"");                FileHelper::unlink($link);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_DevController_955, Creates symlinks to framework and extension sources for the application.\\n @param string $dir application directory\\n @param string $base Yii sources base directory\\n\\n @return int\\n, Creates symlinks to framework and extension sources for the application.,"    protected function linkFrameworkAndExtensions($dir, $base)    {        if (is_dir($link = ""$dir/vendor/yiisoft/yii2"")) {            $this->stdout(""Removing dir $link.\n"");            FileHelper::removeDirectory($link);            $this->stdout(""Creating symlink for $link.\n"");            symlink(""$base/framework"", $link);        }        $extensions = $this->findDirs(""$dir/vendor/yiisoft"");        foreach ($extensions as $ext) {            if (is_dir($link = ""$dir/vendor/yiisoft/yii2-$ext"")) {                $this->stdout(""Removing dir $link.\n"");                FileHelper::removeDirectory($link);                $this->stdout(""Creating symlink for $link.\n"");                if (!file_exists(""$base/extensions/$ext"")) {                    $ret = $this->actionExt($ext);                    if ($ret !== 0) {                        return $ret;                    }                }                symlink(""$base/extensions/$ext"", $link);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_DevController_956, Get a list of subdirectories for directory specified.\\n @param string $dir directory to read\\n\\n @return array list of subdirectories\\n, Get a list of subdirectories for directory specified.,"    protected function listSubDirs($dir)    {        $list = [];        $handle = opendir($dir);        if ($handle === false) {            throw new InvalidParamException(""Unable to open directory: $dir"");        }        while (($file = readdir($handle)) !== false) {            if ($file === '.' || $file === '..') {                continue;            }            // ignore hidden directories            if (strpos($file, '.') === 0) {                continue;            }            if (is_dir(""$dir/$file"")) {                $list[] = ""$dir/$file"";            }        }        closedir($handle);        return $list;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_IsOneOfAssert_1055, IsOneOfAssert asserts that the value is one of the expected values.\n, IsOneOfAssert asserts that the value is one of the expected values.,"class IsOneOfAssert extends \PHPUnit\Framework\Constraint\Constraint{    private $allowedValues;    /**     * IsOneOfAssert constructor.     * @param array $allowedValues     */    public function __construct(array $allowedValues)    {        parent::__construct();        $this->allowedValues = $allowedValues;    }    /**     * Returns a string representation of the object.     *     * @return string     */    public function toString()    {        $allowedValues = array_map(function ($value) {            return VarDumper::dumpAsString($value);        }, $this->allowedValues);        $expectedAsString = implode(', ', $allowedValues);        return ""is one of $expectedAsString"";    }    /**     * {@inheritdoc}     */    protected function matches($other)    {        return in_array($other, $this->allowedValues, false);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_MimeTypeController_958," MimeTypeController generates a map of file extensions to MIME types.\\\\n\\\\n It uses `mime.types` file from apache http located under\\\\n http://svn.apache.org/viewvc/httpd/httpd/trunk/docs/conf/mime.types?view=markup\\\\n\\\\n This file has been placed in the public domain for unlimited redistribution,\\\\n so we can use it and ship it with Yii.\\\\n\\\\n @author Carsten Brandt <mail@cebe.cc>\\\\n @since 2.0\\\\n", MimeTypeController generates a map of file extensions to MIME types.,"class MimeTypeController extends Controller{    /**     * @var array MIME type aliases     */    private $aliases = [        'text/xml' => 'application/xml',        'image/svg' => 'image/svg+xml',        'image/x-bmp' => 'image/bmp',        'image/x-bitmap' => 'image/bmp',        'image/x-xbitmap' => 'image/bmp',        'image/x-win-bitmap' => 'image/bmp',        'image/x-windows-bmp' => 'image/bmp',        'image/ms-bmp' => 'image/bmp',        'image/x-ms-bmp' => 'image/bmp',        'application/bmp' => 'image/bmp',        'application/x-bmp' => 'image/bmp',        'application/x-win-bitmap' => 'image/bmp',    ];    /**     * @var array MIME types to add to the ones parsed from Apache files     */    private $additionalMimeTypes = [        'mjs' => 'text/javascript',    ];    /**     * @param string $outFile the mime file to update. Defaults to @yii/helpers/mimeTypes.php     * @param string $aliasesOutFile the aliases file to update. Defaults to @yii/helpers/mimeAliases.php     */    public function actionIndex($outFile = null, $aliasesOutFile = null)    {        if ($outFile === null) {            $outFile = Yii::getAlias('@yii/helpers/mimeTypes.php');        }        if ($aliasesOutFile === null) {            $aliasesOutFile = Yii::getAlias('@yii/helpers/mimeAliases.php');        }        $this->stdout('Downloading mime-type file from apache httpd repository...');        if ($apacheMimeTypesFileContent = file_get_contents('http://svn.apache.org/viewvc/httpd/httpd/trunk/docs/conf/mime.types?view=co')) {            $this->stdout(""Done.\n"", Console::FG_GREEN);            $this->generateMimeTypesFile($outFile, $apacheMimeTypesFileContent);            $this->generateMimeAliasesFile($aliasesOutFile);        } else {            $this->stderr(""Failed to download mime.types file from apache SVN.\n"");        }    }    /**     * @param string $outFile     * @param string $content     */    private function generateMimeTypesFile($outFile, $content)    {        $this->stdout(""Generating file $outFile..."");        $mimeMap = [];        foreach (explode(""\n"", $content) as $line) {            $line = trim($line);            if (empty($line) || strpos($line, '#') === 0) { // skip comments and empty lines                continue;            }            $parts = preg_split('/\s+/', $line);            $mime = array_shift($parts);            foreach ($parts as $ext) {                if (!empty($ext)) {                    $mimeMap[$ext] = $mime;                }            }        }        $mimeMap = array_merge($mimeMap, $this->additionalMimeTypes);        ksort($mimeMap);        $array = VarDumper::export($mimeMap);        $content = <<<EOD<?php/** * MIME types. * * This file contains most commonly used MIME types * according to file extension names. * Its content is generated from the apache http mime.types file. * http://svn.apache.org/viewvc/httpd/httpd/trunk/docs/conf/mime.types?view=markup * This file has been placed in the public domain for unlimited redistribution. */return $array;EOD;        file_put_contents($outFile, $content);        $this->stdout(""done.\n"", Console::FG_GREEN);    }    /**     * @param string $outFile     */    private function generateMimeAliasesFile($outFile)    {        $this->stdout(""generating file $outFile..."");        $array = VarDumper::export($this->aliases);        $content = <<<EOD<?php/** * MIME aliases. * * This file contains aliases for MIME types. */return $array;EOD;        file_put_contents($outFile, $content);        $this->stdout(""done.\n"", Console::FG_GREEN);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_PhpDocController_961, PhpDocController is there to help maintaining PHPDoc annotation in class files.\\\\n\\\\n @author Carsten Brandt <mail@cebe.cc>\\\\n @author Alexander Makarov <sam@rmcreative.ru>\\\\n @since 2.0\\\\n, PhpDocController is there to help maintaining PHPDoc annotation in class files.,"class PhpDocController extends Controller{    /**     * {@inheritdoc}     */    public $defaultAction = 'property';    /**     * @var bool whether to update class docs directly. Setting this to false will just output docs     * for copy and paste.     */    public $updateFiles = true;    /**     * @var bool whether to add copyright header to php files. This should be skipped in application code.     */    public $skipFrameworkRequirements = false;    /**     * Generates `@property` annotations in class files from getters and setters.     *     * Property description will be taken from getter or setter or from an `@property` annotation     * in the getters docblock if there is one defined.     *     * See https://github.com/yiisoft/yii2/wiki/Core-framework-code-style#documentation for details.     *     * @param string $root the directory to parse files from. Defaults to YII2_PATH.     */    public function actionProperty($root = null)    {        $files = $this->findFiles($root);        $nFilesTotal = 0;        $nFilesUpdated = 0;        foreach ($files as $file) {            $result = $this->generateClassPropertyDocs($file);            if ($result !== false) {                list($className, $phpdoc) = $result;                if ($this->updateFiles) {                    if ($this->updateClassPropertyDocs($file, $className, $phpdoc)) {                        $nFilesUpdated++;                    }                } elseif (!empty($phpdoc)) {                    $this->stdout(""\n[ "" . $file . "" ]\n\n"", Console::BOLD);                    $this->stdout($phpdoc);                }            }            $nFilesTotal++;        }        $this->stdout(""\nParsed $nFilesTotal files.\n"");        $this->stdout(""Updated $nFilesUpdated files.\n"");    }    /**     * Fix some issues with PHPDoc in files.     *     * @param string $root the directory to parse files from. Defaults to YII2_PATH.     */    public function actionFix($root = null)    {        $files = $this->findFiles($root, false);        $nFilesTotal = 0;        $nFilesUpdated = 0;        foreach ($files as $file) {            $contents = file_get_contents($file);            $hash = $this->hash($contents);            // fix line endings            $lines = preg_split('/(\r\n|\n|\r)/', $contents);            if (!$this->skipFrameworkRequirements) {                $this->fixFileDoc($lines);            }            $this->fixDocBlockIndentation($lines);            $lines = array_values($this->fixLineSpacing($lines));            $newContent = implode(""\n"", $lines);            if ($hash !== $this->hash($newContent)) {                file_put_contents($file, $newContent);                $nFilesUpdated++;            }            $nFilesTotal++;        }        $this->stdout(""\nParsed $nFilesTotal files.\n"");        $this->stdout(""Updated $nFilesUpdated files.\n"");    }    /**     * {@inheritdoc}     */    public function options($actionID)    {        return array_merge(parent::options($actionID), ['updateFiles', 'skipFrameworkRequirements']);    }    /**     * @param string $root     * @param bool $needsInclude     * @return array list of files.     */    protected function findFiles($root, $needsInclude = true)    {        $except = [];        if ($needsInclude) {            $extensionExcept = [                'apidoc' => [                    '/helpers/PrettyPrinter.php',                    '/extensions/apidoc/helpers/ApiIndexer.php',                    '/extensions/apidoc/helpers/ApiMarkdownLaTeX.php',                ],                'codeception' => [                    '/TestCase.php',                    '/DbTestCase.php',                ],                'gii' => [                    '/components/DiffRendererHtmlInline.php',                    '/generators/extension/default/AutoloadExample.php',                ],                'swiftmailer' => [                    'src/Logger.php',                ],                'twig' => [                    '/Extension.php',                    '/Optimizer.php',                    '/Template.php',                    '/TwigSimpleFileLoader.php',                    '/ViewRendererStaticClassProxy.php',                ],            ];        } else {            $extensionExcept = [];        }        if ($root === null) {            $root = \dirname(YII2_PATH);            $extensionPath = ""$root/extensions"";            $this->setUpExtensionAliases($extensionPath);            $except = [                '/apps/',                '/build/',                '/docs/',                '/extensions/composer/',                '/framework/BaseYii.php',                '/framework/Yii.php',                'assets/',                'tests/',                'vendor/',            ];            foreach ($extensionExcept as $ext => $paths) {                foreach ($paths as $path) {                    $except[] = ""/extensions/$ext$path"";                }            }        } elseif (preg_match('~extensions/([\w-]+)[\\\\/]?$~', $root, $matches)) {            $extensionPath = \dirname(rtrim($root, '\\/'));            $this->setUpExtensionAliases($extensionPath);            list(, $extension) = $matches;            Yii::setAlias(""@yii/$extension"", (string)$root);            if (is_file($autoloadFile = Yii::getAlias(""@yii/$extension/vendor/autoload.php""))) {                include $autoloadFile;            }            if (isset($extensionExcept[$extension])) {                foreach ($extensionExcept[$extension] as $path) {                    $except[] = $path;                }            }            $except[] = '/vendor/';            $except[] = '/tests/';            $except[] = '/docs/';//            // composer extension does not contain yii code//            if ($extension === 'composer') {//                return [];//            }        } elseif (preg_match('~apps/([\w-]+)[\\\\/]?$~', $root, $matches)) {            $extensionPath = \dirname(\dirname(rtrim($root, '\\/'))) . '/extensions';            $this->setUpExtensionAliases($extensionPath);            list(, $appName) = $matches;            Yii::setAlias(""@app-$appName"", (string)$root);            if (is_file($autoloadFile = Yii::getAlias(""@app-$appName/vendor/autoload.php""))) {                include $autoloadFile;            }            $except[] = '/runtime/';            $except[] = '/vendor/';            $except[] = '/tests/';            $except[] = '/docs/';        }        $root = FileHelper::normalizePath($root);        $options = [            'filter' => function ($path) {                if (is_file($path)) {                    $file = basename($path);                    if ($file[0] < 'A' || $file[0] > 'Z') {                        return false;                    }                }                return null;            },            'only' => ['*.php'],            'except' => array_merge($except, [                '.git/',                'views/',                'requirements/',                'gii/generators/',                'vendor/',            ]),        ];        return FileHelper::findFiles($root, $options);    }    /**     * @param string $extensionPath root path containing extension repositories.     */    private function setUpExtensionAliases($extensionPath)    {        foreach (scandir($extensionPath) as $extension) {            if (ctype_alpha($extension) && is_dir($extensionPath . '/' . $extension)) {                Yii::setAlias(""@yii/$extension"", ""$extensionPath/$extension"");                $composerConfigFile = $extensionPath . '/' . $extension . '/composer.json';                if (file_exists($composerConfigFile)) {                    $composerConfig = Json::decode(file_get_contents($composerConfigFile));                    if (isset($composerConfig['autoload']['psr-4'])) {                        foreach ($composerConfig['autoload']['psr-4'] as $namespace => $subPath) {                            $alias = '@' . str_replace('\\', '/', $namespace);                            $path = rtrim(""$extensionPath/$extension/$subPath"", '/');                            Yii::setAlias($alias, $path);                        }                    }                }            }        }    }    /**     * Fix file PHPDoc.     */    protected function fixFileDoc(&$lines)    {        // find namespace        $namespace = false;        $namespaceLine = '';        $contentAfterNamespace = false;        foreach ($lines as $i => $line) {            $line = trim($line);            if (!empty($line)) {                if (strncmp($line, 'namespace', 9) === 0) {                    $namespace = $i;                    $namespaceLine = $line;                } elseif ($namespace !== false) {                    $contentAfterNamespace = $i;                    break;                }            }        }        if ($namespace !== false && $contentAfterNamespace !== false) {            while ($contentAfterNamespace > 0) {                array_shift($lines);                $contentAfterNamespace--;            }            $lines = array_merge([                '<?php',                '/**',                ' * @link http://www.yiiframework.com/',                ' * @copyright Copyright (c) 2008 Yii Software LLC',                ' * @license http://www.yiiframework.com/license/',                ' */',                '',                $namespaceLine,                '',            ], $lines);        }    }    /**     * Markdown aware fix of whitespace issues in doc comments.     * @param array $lines     */    protected function fixDocBlockIndentation(&$lines)    {        $docBlock = false;        $codeBlock = false;        $listIndent = '';        $tag = false;        $indent = '';        foreach ($lines as $i => $line) {            if (preg_match('~^(\s*)/\*\*$~', $line, $matches)) {                $docBlock = true;                $indent = $matches[1];            } elseif (preg_match('~^(\s*)\*+/~', $line)) {                if ($docBlock) { // could be the end of normal comment                    $lines[$i] = $indent . ' */';                }                $docBlock = false;                $codeBlock = false;                $listIndent = '';                $tag = false;            } elseif ($docBlock) {                $line = ltrim($line);                if (strpos($line, '*') === 0) {                    $line = substr($line, 1);                }                if (strpos($line, ' ') === 0) {                    $line = substr($line, 1);                }                $docLine = str_replace(""\t"", '    ', rtrim($line));                if (empty($docLine)) {                    $listIndent = '';                } elseif (strpos($docLine, '@') === 0) {                    $listIndent = '';                    $codeBlock = false;                    $tag = true;                    $docLine = preg_replace('/\s+/', ' ', $docLine);                    $docLine = $this->fixParamTypes($docLine);                } elseif (preg_match('/^(~~~|```)/', $docLine)) {                    $codeBlock = !$codeBlock;                    $listIndent = '';                } elseif (preg_match('/^(\s*)([0-9]+\.|-|\*|\+) /', $docLine, $matches)) {                    $listIndent = str_repeat(' ', \strlen($matches[0]));                    $tag = false;                    $lines[$i] = $indent . ' * ' . $docLine;                    continue;                }                if ($codeBlock) {                    $lines[$i] = rtrim($indent . ' * ' . $docLine);                } else {                    $lines[$i] = rtrim($indent . ' * ' . (empty($listIndent) && !$tag ? $docLine : ($listIndent . ltrim($docLine))));                }            }        }    }    /**     * @param string $line     * @return string     */    protected function fixParamTypes($line)    {        return preg_replace_callback('~@(param|return) ([\w\\|]+)~i', function ($matches) {            $types = explode('|', $matches[2]);            foreach ($types as $i => $type) {                switch ($type) {                    case 'integer': $types[$i] = 'int'; break;                    case 'boolean': $types[$i] = 'bool'; break;                }            }            return '@' . $matches[1] . ' ' . implode('|', $types);        }, $line);    }    /**     * Fixes line spacing code style for properties and constants.     * @param string[] $lines     * @return string[]     */    protected function fixLineSpacing($lines)    {        $propertiesOnly = false;        // remove blank lines between properties        $skip = true;        $level = 0;        foreach ($lines as $i => $line) {            if (strpos($line, 'class ') !== false) {                $skip = false;            }            if ($skip) {                continue;            }            // keep spaces in multi line arrays            if (strpos($line, '*') === false && strncmp(trim($line), ""'SQLSTATE["", 10) !== 0) {                $level += substr_count($line, '[') - substr_count($line, ']');            }            if (trim($line) === '') {                if ($level == 0) {                    unset($lines[$i]);                }            } elseif (ltrim($line)[0] !== '*' && strpos($line, 'function ') !== false) {                break;            } elseif (trim($line) === '}') {                $propertiesOnly = true;                break;            }        }        $lines = array_values($lines);        // add back some        $endofUse = false;        $endofConst = false;        $endofPublic = false;        $endofProtected = false;        $endofPrivate = false;        $skip = true;        $level = 0; // track array properties        $property = '';        foreach ($lines as $i => $line) {            if (strpos($line, 'class ') !== false) {                $skip = false;            }            if ($skip) {                continue;            }            // check for multi line array            if ($level > 0) {                ${'endof' . $property} = $i;            }            $line = trim($line);            if (strncmp($line, 'public $', 8) === 0 || strncmp($line, 'public static $', 15) === 0) {                $endofPublic = $i;                $property = 'Public';                $level = 0;            } elseif (strncmp($line, 'protected $', 11) === 0 || strncmp($line, 'protected static $', 18) === 0) {                $endofProtected = $i;                $property = 'Protected';                $level = 0;            } elseif (strncmp($line, 'private $', 9) === 0 || strncmp($line, 'private static $', 16) === 0) {                $endofPrivate = $i;                $property = 'Private';                $level = 0;            } elseif (strpos($line, 'const ') === 0) {                $endofConst = $i;                $property = false;            } elseif (strpos($line, 'use ') === 0) {                $endofUse = $i;                $property = false;            } elseif (strpos($line, '*') === 0) {                $property = false;            } elseif (strpos($line, '*') !== 0 && strpos($line, 'function ') !== false || $line === '}') {                break;            }            // check for multi line array            if ($property !== false && strncmp($line, ""'SQLSTATE["", 10) !== 0) {                $level += substr_count($line, '[') - substr_count($line, ']');            }        }        $endofAll = false;        foreach (['Private', 'Protected', 'Public', 'Const', 'Use'] as $var) {            if (${'endof' . $var} !== false) {                $endofAll = ${'endof' . $var};                break;            }        }//        $this->checkPropertyOrder($lineInfo);        $result = [];        foreach ($lines as $i => $line) {            $result[] = $line;            if (!($propertiesOnly && $i === $endofAll)) {                if ($i === $endofUse || $i === $endofConst || $i === $endofPublic ||                    $i === $endofProtected || $i === $endofPrivate) {                    $result[] = '';                }                if ($i === $endofAll) {                    $result[] = '';                }            }        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_PhpDocController_965, Markdown aware fix of whitespace issues in doc comments.\\\\n @param array $lines\\\\n, Markdown aware fix of whitespace issues in doc comments.,"    protected function fixDocBlockIndentation(&$lines)    {        $docBlock = false;        $codeBlock = false;        $listIndent = '';        $tag = false;        $indent = '';        foreach ($lines as $i => $line) {            if (preg_match('~^(\s*)/\*\*$~', $line, $matches)) {                $docBlock = true;                $indent = $matches[1];            } elseif (preg_match('~^(\s*)\*+/~', $line)) {                if ($docBlock) { // could be the end of normal comment                    $lines[$i] = $indent . ' */';                }                $docBlock = false;                $codeBlock = false;                $listIndent = '';                $tag = false;            } elseif ($docBlock) {                $line = ltrim($line);                if (strpos($line, '*') === 0) {                    $line = substr($line, 1);                }                if (strpos($line, ' ') === 0) {                    $line = substr($line, 1);                }                $docLine = str_replace(""\t"", '    ', rtrim($line));                if (empty($docLine)) {                    $listIndent = '';                } elseif (strpos($docLine, '@') === 0) {                    $listIndent = '';                    $codeBlock = false;                    $tag = true;                    $docLine = preg_replace('/\s+/', ' ', $docLine);                    $docLine = $this->fixParamTypes($docLine);                } elseif (preg_match('/^(~~~|```)/', $docLine)) {                    $codeBlock = !$codeBlock;                    $listIndent = '';                } elseif (preg_match('/^(\s*)([0-9]+\.|-|\*|\+) /', $docLine, $matches)) {                    $listIndent = str_repeat(' ', \strlen($matches[0]));                    $tag = false;                    $lines[$i] = $indent . ' * ' . $docLine;                    continue;                }                if ($codeBlock) {                    $lines[$i] = rtrim($indent . ' * ' . $docLine);                } else {                    $lines[$i] = rtrim($indent . ' * ' . (empty($listIndent) && !$tag ? $docLine : ($listIndent . ltrim($docLine))));                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_PhpDocController_967, Fixes line spacing code style for properties and constants.\n @param string[] $lines\n @return string[]\n, Fixes line spacing code style for properties and constants.,"    protected function fixLineSpacing($lines)    {        $propertiesOnly = false;        // remove blank lines between properties        $skip = true;        $level = 0;        foreach ($lines as $i => $line) {            if (strpos($line, 'class ') !== false) {                $skip = false;            }            if ($skip) {                continue;            }            // keep spaces in multi line arrays            if (strpos($line, '*') === false && strncmp(trim($line), ""'SQLSTATE["", 10) !== 0) {                $level += substr_count($line, '[') - substr_count($line, ']');            }            if (trim($line) === '') {                if ($level == 0) {                    unset($lines[$i]);                }            } elseif (ltrim($line)[0] !== '*' && strpos($line, 'function ') !== false) {                break;            } elseif (trim($line) === '}') {                $propertiesOnly = true;                break;            }        }        $lines = array_values($lines);        // add back some        $endofUse = false;        $endofConst = false;        $endofPublic = false;        $endofProtected = false;        $endofPrivate = false;        $skip = true;        $level = 0; // track array properties        $property = '';        foreach ($lines as $i => $line) {            if (strpos($line, 'class ') !== false) {                $skip = false;            }            if ($skip) {                continue;            }            // check for multi line array            if ($level > 0) {                ${'endof' . $property} = $i;            }            $line = trim($line);            if (strncmp($line, 'public $', 8) === 0 || strncmp($line, 'public static $', 15) === 0) {                $endofPublic = $i;                $property = 'Public';                $level = 0;            } elseif (strncmp($line, 'protected $', 11) === 0 || strncmp($line, 'protected static $', 18) === 0) {                $endofProtected = $i;                $property = 'Protected';                $level = 0;            } elseif (strncmp($line, 'private $', 9) === 0 || strncmp($line, 'private static $', 16) === 0) {                $endofPrivate = $i;                $property = 'Private';                $level = 0;            } elseif (strpos($line, 'const ') === 0) {                $endofConst = $i;                $property = false;            } elseif (strpos($line, 'use ') === 0) {                $endofUse = $i;                $property = false;            } elseif (strpos($line, '*') === 0) {                $property = false;            } elseif (strpos($line, '*') !== 0 && strpos($line, 'function ') !== false || $line === '}') {                break;            }            // check for multi line array            if ($property !== false && strncmp($line, ""'SQLSTATE["", 10) !== 0) {                $level += substr_count($line, '[') - substr_count($line, ']');            }        }        $endofAll = false;        foreach (['Private', 'Protected', 'Public', 'Const', 'Use'] as $var) {            if (${'endof' . $var} !== false) {                $endofAll = ${'endof' . $var};                break;            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_PhpDocController_968, remove multi empty lines and trim trailing whitespace.\\n\\n @param $doc\\n @return string\\n, remove multi empty lines and trim trailing whitespace.,"    protected function cleanDocComment($doc)    {        $lines = explode(""\n"", $doc);        $n = \count($lines);        for ($i = 0; $i < $n; $i++) {            $lines[$i] = rtrim($lines[$i]);            if (trim($lines[$i]) == '*' && trim($lines[$i + 1]) == '*') {                unset($lines[$i]);            }        }        return implode(""\n"", $lines);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
