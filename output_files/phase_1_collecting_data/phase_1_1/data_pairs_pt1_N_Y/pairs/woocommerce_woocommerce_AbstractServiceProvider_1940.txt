	/**
	 * Check if a combination of class name and concrete is valid for registration.
	 * Also return the class injection method if the concrete is either a class name or null (then use the supplied class name).
	 *
	 * @param string $class_name The class name to check.
	 * @param mixed  $concrete   The concrete to check.
	 *
	 * @return \ReflectionFunctionAbstract|null A reflection instance for the $class_name injection method or $concrete injection method or callable; null otherwise.
	 * @throws ContainerException Class has a private injection method, can't reflect class, or the concrete is invalid.
	 */

	private function reflect_class_or_callable( string $class_name, $concrete ) {
		if ( ! isset( $concrete ) || is_string( $concrete ) && class_exists( $concrete ) ) {
			try {
				$class  = $concrete ?? $class_name;
				$method = new \ReflectionMethod( $class, Definition::INJECTION_METHOD );
				if ( ! isset( $method ) ) {
					return null;
				}

				$missing_modifiers = array();
				if ( ! $method->isFinal() ) {
					$missing_modifiers[] = 'final';
				}
				if ( ! $method->isPublic() ) {
					$missing_modifiers[] = 'public';
				}
				if ( ! empty( $missing_modifiers ) ) {
					throw new ContainerException( "Method '" . Definition::INJECTION_METHOD . "' of class '$class' isn't '" . implode( ' ', $missing_modifiers ) . "', instances can't be created." );
				}

				return $method;
			} catch ( \ReflectionException $ex ) {
				return null;
			}
		} elseif ( is_callable( $concrete ) ) {
			try {
				return new \ReflectionFunction( $concrete );
			} catch ( \ReflectionException $ex ) {
				throw new ContainerException( "Error when reflecting callable: {$ex->getMessage()}" );
			}
		}
