	/**
	 * Look through the patches and break up any which are longer than the maximum
	 * limit of the match algorithm.
	 * @param {Array.<patch_obj>} patches Array of patch objects.
	 */

	function patch_splitMax(&$patches) {
		for ($x = 0; $x < count($patches); $x++) {
			if ( $patches[$x]->length1 > Match_MaxBits) {
				$bigpatch = $patches[$x];
				// Remove the big old patch.
				array_splice($patches,$x--,1);
				$patch_size = Match_MaxBits;
				$start1 = $bigpatch->start1;
				$start2 = $bigpatch->start2;
				$precontext = '';
				while ( count($bigpatch->diffs) !== 0) {
					// Create one of several smaller patches.
					$patch = new patch_obj();
					$empty = true;
					$patch->start1 = $start1 - mb_strlen($precontext);
					$patch->start2 = $start2 - mb_strlen($precontext);
					if ($precontext !== '') {
						$patch->length1 = $patch->length2 = mb_strlen($precontext);
						array_push($patch->diffs, array(DIFF_EQUAL, $precontext) );
					}
					while ( count($bigpatch->diffs) !== 0 && $patch->length1 < $patch_size - $this->Patch_Margin) {
						$diff_type = $bigpatch->diffs[0][0];
						$diff_text = $bigpatch->diffs[0][1];
						if ($diff_type === DIFF_INSERT) {
							// Insertions are harmless.
							$patch->length2 += mb_strlen($diff_text);
							$start2 += mb_strlen($diff_text);
							array_push($patch->diffs, array_shift($bigpatch->diffs) );
							$empty = false;
						} else
							if ($diff_type === DIFF_DELETE && count($patch->diffs) == 1 && $patch->diffs[0][0] == DIFF_EQUAL && (mb_strlen($diff_text) > 2 * $patch_size) ) {
								// This is a large deletion.  Let it pass in one chunk.
								$patch->length1 += mb_strlen($diff_text);
								$start1 += mb_strlen($diff_text);
								$empty = false;
								array_push( $patch->diffs, array($diff_type, $diff_text) );
								array_shift($bigpatch->diffs);
							} else {
								// Deletion or equality.  Only take as much as we can stomach.
								$diff_text = mb_substr($diff_text, 0, $patch_size - $patch->length1 - $this->Patch_Margin);
								$patch->length1 += mb_strlen($diff_text);
								$start1 += mb_strlen($diff_text);
								if ($diff_type === DIFF_EQUAL) {
									$patch->length2 += mb_strlen($diff_text);
									$start2 += mb_strlen($diff_text);
								} else {
									$empty = false;
								}
								array_push($patch->diffs, array($diff_type, $diff_text) );
								if ($diff_text == $bigpatch->diffs[0][1]) {
									array_shift($bigpatch->diffs);
								} else {
									$bigpatch->diffs[0][1] = mb_substr( $bigpatch->diffs[0][1],mb_strlen($diff_text) );
								}
							}
					}
					// Compute the head context for the next patch.
					$precontext = $this->diff_text2($patch->diffs);
					$precontext = mb_substr($precontext, mb_strlen($precontext)-$this->Patch_Margin);
					// Append the end context for this patch.
					$postcontext = mb_substr( $this->diff_text1($bigpatch->diffs), 0, $this->Patch_Margin );
					if ($postcontext !== '') {
						$patch->length1 += mb_strlen($postcontext);
						$patch->length2 += mb_strlen($postcontext);
						if ( count($patch->diffs) !== 0 && $patch->diffs[ count($patch->diffs) - 1][0] === DIFF_EQUAL) {
							$patch->diffs[ count($patch->diffs) - 1][1] .= $postcontext;
						} else {
							array_push($patch->diffs, array(DIFF_EQUAL, $postcontext));
						}
					}
					if (!$empty) {
						array_splice($patches, ++$x, 0, array($patch));
					}
				}
			}
		}
