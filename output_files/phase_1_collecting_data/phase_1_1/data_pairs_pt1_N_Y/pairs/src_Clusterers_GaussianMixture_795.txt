    /**
     * Initialize the gaussian components by calculating the means and variances of k initial cluster centroids generated by the seeder.
     *
     * @param \Rubix\ML\Datasets\Dataset $dataset
     */

    protected function initialize(Dataset $dataset) : void
    {
        $this->logPriors = $this->means = $this->variances = [];

        $kernel = new Euclidean();

        $n = $dataset->numSamples();

        $maxVariance = 0.0;

        /** @var list<list<int|float>> $centroids */
        $centroids = $this->seeder->seed($dataset, $this->k);

        $clusters = array_fill(0, $this->k, []);

        foreach ($dataset->samples() as $sample) {
            $bestDistance = INF;
            $bestCluster = -1;

            foreach ($centroids as $cluster => $centroid) {
                $distance = $kernel->compute($sample, $centroid);

                if ($distance < $bestDistance) {
                    $bestDistance = $distance;
                    $bestCluster = $cluster;
                }
            }

            $clusters[$bestCluster][] = $sample;
        }

        foreach ($clusters as $cluster => $samples) {
            $means = $variances = [];

            $features = array_transpose($samples);

            foreach ($features as $values) {
                [$mean, $variance] = Stats::meanVar($values);

                $means[] = $mean;
                $variances[] = $variance;
            }

            $maxVariance = max($maxVariance, ...$variances);

            $logPrior = log(count($samples) / $n);

            $this->means[$cluster] = $means;
            $this->variances[$cluster] = $variances;
            $this->logPriors[$cluster] = $logPrior;
        }

        $epsilon = max($this->smoothing * $maxVariance, CPU::epsilon());

        foreach ($this->variances as &$variances) {
            foreach ($variances as &$variance) {
                $variance += $epsilon;
            }
        }
    }
