/**
 * ReleaseController is there to help preparing releases.
 *
 * Get a version overview:
 *
 *     ./build/build release/info
 *
 * run it with `--update` to fetch tags for all repos:
 *
 *     ./build release/info --update
 *
 * Make a framework release (apps are always in line with framework):
 *
 *     ./build/build release framework
 *     ./build/build release app-basic
 *     ./build/build release app-advanced
 *
 * Make an extension release (e.g. for redis):
 *
 *     ./build/build release redis
 *
 * Be sure to check the help info for individual sub-commands:
 *
 * @author Carsten Brandt <mail@cebe.cc>
 * @since 2.0
 */

class ReleaseController extends Controller
{
    public $defaultAction = 'release';

    /**
     * @var string base path to use for releases.
     */
    public $basePath;
    /**
     * @var bool whether to make actual changes. If true, it will run without changing or pushing anything.
     */
    public $dryRun = false;
    /**
     * @var bool whether to fetch latest tags.
     */
    public $update = false;
    /**
     * @var string override the default version. e.g. for major or patch releases.
     */
    public $version;


    public function options($actionID)
    {
        $options = ['basePath'];
        if ($actionID === 'release') {
            $options[] = 'dryRun';
            $options[] = 'version';
        } elseif ($actionID === 'sort-changelog') {
            $options[] = 'version';
        } elseif ($actionID === 'info') {
            $options[] = 'update';
        }

        return array_merge(parent::options($actionID), $options);
    }


    public function beforeAction($action)
    {
        if (!$this->interactive) {
            throw new Exception('Sorry, but releases should be run interactively to ensure you actually verify what you are doing ;)');
        }
        if ($this->basePath === null) {
            $this->basePath = \dirname(\dirname(__DIR__));
        }
        $this->basePath = rtrim($this->basePath, '\\/');
        return parent::beforeAction($action);
    }

    /**
     * Shows information about current framework and extension versions.
     */
    public function actionInfo()
    {
        $items = [
            'framework',
            'app-basic',
            'app-advanced',
        ];
        $extensionPath = "{$this->basePath}/extensions";
        foreach (scandir($extensionPath) as $extension) {
            if (ctype_alpha($extension) && is_dir($extensionPath . '/' . $extension)) {
                $items[] = $extension;
            }
        }

        if ($this->update) {
            foreach ($items as $item) {
                $this->stdout("fetching tags for $item...");
                if ($item === 'framework') {
                    $this->gitFetchTags((string)$this->basePath);
                } elseif (strncmp('app-', $item, 4) === 0) {
                    $this->gitFetchTags("{$this->basePath}/apps/" . substr($item, 4));
                } else {
                    $this->gitFetchTags("{$this->basePath}/extensions/$item");
                }
                $this->stdout("done.\n", Console::FG_GREEN, Console::BOLD);
            }
        } else {
            $this->stdout("\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n");
        }

        $versions = $this->getCurrentVersions($items);
        $nextVersions = $this->getNextVersions($versions, self::PATCH);

        // print version table
        $w = $this->minWidth(array_keys($versions));
        $this->stdout(str_repeat(' ', $w + 2) . "Current Version  Next Version\n", Console::BOLD);
        foreach ($versions as $ext => $version) {
            $this->stdout($ext . str_repeat(' ', $w + 3 - mb_strlen($ext)) . $version . '');
            $this->stdout(str_repeat(' ', 17 - mb_strlen($version)) . $nextVersions[$ext] . "\n");
        }
    }

    private function minWidth($a)
    {
        $w = 1;
        foreach ($a as $s) {
            if (($l = mb_strlen($s)) > $w) {
                $w = $l;
            }
        }

        return $w;
    }

    /**
     * Automation tool for making Yii framework and official extension releases.
     *
     * Usage:
     *
     * To make a release, make sure your git is clean (no uncommitted changes) and run the following command in
     * the yii dev repo root:
     *
     * ```
     * ./build/build release framework
     * ```
     *
     * or
     *
     * ```
     * ./build/build release redis,bootstrap,apidoc
     * ```
     *
     * You may use the `--dryRun` switch to test the command without changing or pushing anything:
     *
     * ```
     * ./build/build release redis --dryRun
     * ```
     *
     * The command will guide you through the complete release process including changing of files,
     * committing and pushing them. Each git command must be confirmed and can be skipped individually.
     * You may adjust changes in a separate shell or your IDE while the command is waiting for confirmation.
     *
     * @param array $what what do you want to release? this can either be:
     *
     * - an extension name such as `redis` or `bootstrap`,
     * - an application indicated by prefix `app-`, e.g. `app-basic`,
     * - or `framework` if you want to release a new version of the framework itself.
     *
     * @return int
     */
    public function actionRelease(array $what)
    {
        if (\count($what) > 1) {
            $this->stdout("Currently only one simultaneous release is supported.\n");
            return 1;
        }

        $this->stdout("This is the Yii release manager\n\n", Console::BOLD);

        if ($this->dryRun) {
            $this->stdout("Running in \"dry-run\" mode, nothing will actually be changed.\n\n", Console::BOLD, Console::FG_GREEN);
        }

        $this->validateWhat($what);
        $versions = $this->getCurrentVersions($what);

        if ($this->version !== null) {
            // if a version is explicitly given
            $newVersions = [];
            foreach ($versions as $k => $v) {
                $newVersions[$k] = $this->version;
            }
        } else {
            // otherwise get next patch or minor
            $newVersions = $this->getNextVersions($versions, self::PATCH);
        }

        $this->stdout("You are about to prepare a new release for the following things:\n\n");
        $this->printWhat($what, $newVersions, $versions);
        $this->stdout("\n");

        $this->stdout("Before you make a release briefly go over the changes and check if you spot obvious mistakes:\n\n", Console::BOLD);
        $gitDir = reset($what) === 'framework' ? 'framework/' : '';
        $gitVersion = $versions[reset($what)];
        if (strncmp('app-', reset($what), 4) !== 0) {
            $this->stdout("- no accidentally added CHANGELOG lines for other versions than this one?\n\n    git diff $gitVersion.. ${gitDir}CHANGELOG.md\n\n");
            $this->stdout("- are all new `@since` tags for this release version?\n");
        }
        $this->stdout("- other issues with code changes?\n\n    git diff -w $gitVersion.. ${gitDir}\n\n");
        $travisUrl = reset($what) === 'framework' ? '' : '-' . reset($what);
        $this->stdout("- are unit tests passing on travis? https://travis-ci.com/yiisoft/yii2$travisUrl/builds\n");
        $this->stdout("- also make sure the milestone on github is complete and no issues or PRs are left open.\n\n");
        $this->printWhatUrls($what, $versions);
        $this->stdout("\n");

        if (!$this->confirm('When you continue, this tool will run cleanup jobs and update the changelog as well as other files (locally). Continue?', false)) {
            $this->stdout("Canceled.\n");
            return 1;
        }

        foreach ($what as $ext) {
            if ($ext === 'framework') {
                $this->releaseFramework("{$this->basePath}/framework", $newVersions['framework']);
            } elseif (strncmp('app-', $ext, 4) === 0) {
                $this->releaseApplication(substr($ext, 4), "{$this->basePath}/apps/" . substr($ext, 4), $newVersions[$ext]);
            } else {
                $this->releaseExtension($ext, "{$this->basePath}/extensions/$ext", $newVersions[$ext]);
            }
        }

        return 0;
    }

    /**
     * This will generate application packages for download page.
     *
     * Usage:
     *
     * ```
     * ./build/build release/package app-basic
     * ```
     *
     * @param array $what what do you want to package? this can either be:
     *
     * - an application indicated by prefix `app-`, e.g. `app-basic`,
     *
     * @return int
     */
    public function actionPackage(array $what)
    {
        $this->validateWhat($what, ['app']);
        $versions = $this->getCurrentVersions($what);

        $this->stdout("You are about to generate packages for the following things:\n\n");
        foreach ($what as $ext) {
            if (strncmp('app-', $ext, 4) === 0) {
                $this->stdout(' - ');
                $this->stdout(substr($ext, 4), Console::FG_RED);
                $this->stdout(' application version ');
            } elseif ($ext === 'framework') {
                $this->stdout(' - Yii Framework version ');
            } else {
                $this->stdout(' - ');
                $this->stdout($ext, Console::FG_RED);
                $this->stdout(' extension version ');
            }
            $this->stdout($versions[$ext], Console::BOLD);
            $this->stdout("\n");
        }
        $this->stdout("\n");

        $packagePath = "{$this->basePath}/packages";
        $this->stdout("Packages will be stored in $packagePath\n\n");

        if (!$this->confirm('Continue?', false)) {
            $this->stdout("Canceled.\n");
            return 1;
        }

        foreach ($what as $ext) {
            if ($ext === 'framework') {
                throw new Exception('Can not package framework.');
            } elseif (strncmp('app-', $ext, 4) === 0) {
                $this->packageApplication(substr($ext, 4), $versions[$ext], $packagePath);
            } else {
                throw new Exception('Can not package extension.');
            }
        }

        $this->stdout("\ndone. verify the versions composer installed above and push it to github!\n\n");

        return 0;
    }

    /**
     * Sorts CHANGELOG for framework or extension.
     *
     * @param array $what what do you want to resort changelog for? this can either be:
     *
     * - an extension name such as `redis` or `bootstrap`,
     * - or `framework` if you want to release a new version of the framework itself.
     */
    public function actionSortChangelog(array $what)
    {
        if (\count($what) > 1) {
            $this->stdout("Currently only one simultaneous release is supported.\n");
            return 1;
        }
        $this->validateWhat($what, ['framework', 'ext'], false);

        $version = $this->version ?: array_values($this->getNextVersions($this->getCurrentVersions($what), self::PATCH))[0];
        $this->stdout('sorting CHANGELOG of ');
        $this->stdout(reset($what), Console::BOLD);
        $this->stdout(' for version ');
        $this->stdout($version, Console::BOLD);
        $this->stdout('...');

        $this->resortChangelogs($what, $version);

        $this->stdout("done.\n", Console::BOLD, Console::FG_GREEN);
    }

    protected function printWhat(array $what, $newVersions, $versions)
    {
        foreach ($what as $ext) {
            if (strncmp('app-', $ext, 4) === 0) {
                $this->stdout(' - ');
                $this->stdout(substr($ext, 4), Console::FG_RED);
                $this->stdout(' application version ');
            } elseif ($ext === 'framework') {
                $this->stdout(' - Yii Framework version ');
            } else {
                $this->stdout(' - ');
                $this->stdout($ext, Console::FG_RED);
                $this->stdout(' extension version ');
            }
            $this->stdout($newVersions[$ext], Console::BOLD);
            $this->stdout(", last release was {$versions[$ext]}\n");
        }
    }

    protected function printWhatUrls(array $what, $oldVersions)
    {
        foreach ($what as $ext) {
            if ($ext === 'framework') {
                $this->stdout("framework:    https://github.com/yiisoft/yii2-framework/compare/{$oldVersions[$ext]}...master\n");
                $this->stdout("app-basic:    https://github.com/yiisoft/yii2-app-basic/compare/{$oldVersions[$ext]}...master\n");
                $this->stdout("app-advanced: https://github.com/yiisoft/yii2-app-advanced/compare/{$oldVersions[$ext]}...master\n");
            } else {
                $this->stdout($ext, Console::FG_RED);
                $this->stdout(": https://github.com/yiisoft/yii2-$ext/compare/{$oldVersions[$ext]}...master\n");
            }
        }
    }

    /**
     * @param array $what list of items
     * @param array $limit list of things to allow, or empty to allow any, can be `app`, `framework`, `extension`
     * @param bool $ensureGitClean
     * @throws \yii\base\Exception
     */
    protected function validateWhat(array $what, $limit = [], $ensureGitClean = true)
    {
        foreach ($what as $w) {
            if (strncmp('app-', $w, 4) === 0) {
                if (!empty($limit) && !\in_array('app', $limit)) {
                    throw new Exception('Only the following types are allowed: ' . implode(', ', $limit) . "\n");
                }
                if (!is_dir($appPath = "{$this->basePath}/apps/" . substr($w, 4))) {
                    throw new Exception("Application path does not exist: \"{$appPath}\"\n");
                }
                if ($ensureGitClean) {
                    $this->ensureGitClean($appPath);
                }
            } elseif ($w === 'framework') {
                if (!empty($limit) && !\in_array('framework', $limit)) {
                    throw new Exception('Only the following types are allowed: ' . implode(', ', $limit) . "\n");
                }
                if (!is_dir($fwPath = "{$this->basePath}/framework")) {
                    throw new Exception("Framework path does not exist: \"{$this->basePath}/framework\"\n");
                }
                if ($ensureGitClean) {
                    $this->ensureGitClean($fwPath);
                }
            } else {
                if (!empty($limit) && !\in_array('ext', $limit)) {
                    throw new Exception('Only the following types are allowed: ' . implode(', ', $limit) . "\n");
                }
                if (!is_dir($extPath = "{$this->basePath}/extensions/$w")) {
                    throw new Exception("Extension path for \"$w\" does not exist: \"{$this->basePath}/extensions/$w\"\n");
                }
                if ($ensureGitClean) {
                    $this->ensureGitClean($extPath);
                }
            }
