    /**
     * @param int $fontObjId
     * @param array $object_info
     * @return array|false
     * @throws FontNotFoundException
     */

    private function processFont(int $fontObjId, array $object_info)
    {
        $fontFileName = $object_info['fontFileName'];
        if (!isset($this->fonts[$fontFileName])) {
            return false;
        }

        $font = &$this->fonts[$fontFileName];

        $fileSuffix = $font['fileSuffix'];
        $fileSuffixLower = strtolower($font['fileSuffix']);
        $fbfile = "$fontFileName.$fileSuffix";
        $isTtfFont = $fileSuffixLower === 'ttf';
        $isPfbFont = $fileSuffixLower === 'pfb';

        $this->addMessage('selectFont: checking for - ' . $fbfile);

        if (!$fileSuffix) {
            $this->addMessage(
                'selectFont: pfb or ttf file not found, ok if this is one of the 14 standard fonts'
            );

            return false;
        } else {
            $adobeFontName = isset($font['PostScriptName']) ? $font['PostScriptName'] : $font['FontName'];
            //        $fontObj = $this->numObj;
            $this->addMessage("selectFont: adding font file - $fbfile - $adobeFontName");

            // find the array of font widths, and put that into an object.
            $firstChar = -1;
            $lastChar = 0;
            $widths = [];
            $cid_widths = [];

            foreach ($font['C'] as $num => $d) {
                if (intval($num) > 0 || $num == '0') {
                    if (!$font['isUnicode']) {
                        // With Unicode, widths array isn't used
                        if ($lastChar > 0 && $num > $lastChar + 1) {
                            for ($i = $lastChar + 1; $i < $num; $i++) {
                                $widths[] = 0;
                            }
                        }
                    }

                    $widths[] = $d;

                    if ($font['isUnicode']) {
                        $cid_widths[$num] = $d;
                    }

                    if ($firstChar == -1) {
                        $firstChar = $num;
                    }

                    $lastChar = $num;
                }
            }

            // also need to adjust the widths for the differences array
            if (isset($object['differences'])) {
                foreach ($object['differences'] as $charNum => $charName) {
                    if ($charNum > $lastChar) {
                        if (!$object['isUnicode']) {
                            // With Unicode, widths array isn't used
                            for ($i = $lastChar + 1; $i <= $charNum; $i++) {
                                $widths[] = 0;
                            }
                        }

                        $lastChar = $charNum;
                    }

                    if (isset($font['C'][$charName])) {
                        $widths[$charNum - $firstChar] = $font['C'][$charName];
                        if ($font['isUnicode']) {
                            $cid_widths[$charName] = $font['C'][$charName];
                        }
                    }
                }
            }

            if ($font['isUnicode']) {
                $font['CIDWidths'] = $cid_widths;
            }

            $this->addMessage('selectFont: FirstChar = ' . $firstChar);
            $this->addMessage('selectFont: LastChar = ' . $lastChar);

            $widthid = -1;

            if (!$font['isUnicode']) {
                // With Unicode, widths array isn't used

                $this->numObj++;
                $this->o_contents($this->numObj, 'new', 'raw');
                $this->objects[$this->numObj]['c'] .= '[' . implode(' ', $widths) . ']';
                $widthid = $this->numObj;
            }

            $missing_width = 500;
            $stemV = 70;

            if (isset($font['MissingWidth'])) {
                $missing_width = $font['MissingWidth'];
            }
            if (isset($font['StdVW'])) {
                $stemV = $font['StdVW'];
            } else {
                if (isset($font['Weight']) && preg_match('!(bold|black)!i', $font['Weight'])) {
                    $stemV = 120;
                }
            }

            // load the pfb file, and put that into an object too.
            // note that pdf supports only binary format type 1 font files, though there is a
            // simple utility to convert them from pfa to pfb.
            if (!$font['isSubsetting']) {
                $data = file_get_contents($fbfile);
            } else {
                $adobeFontName = $this->getFontSubsettingTag($font) . '+' . $adobeFontName;
                $this->stringSubsets[$fontFileName][] = 32; // Force space if not in yet

                $subset = $this->stringSubsets[$fontFileName];
                sort($subset);

                // Load font
                $font_obj = Font::load($fbfile);
                $font_obj->parse();

                // Define subset
                $font_obj->setSubset($subset);
                $font_obj->reduce();

                // Write new font
                $tmp_name = $this->tmp . "/" . basename($fbfile) . ".tmp." . uniqid();
                touch($tmp_name);
                $font_obj->open($tmp_name, BinaryStream::modeReadWrite);
                $font_obj->encode(["OS/2"]);
                $font_obj->close();

                // Parse the new font to get cid2gid and widths
                $font_obj = Font::load($tmp_name);

                // Find Unicode char map table
                $subtable = null;
                foreach ($font_obj->getData("cmap", "subtables") as $_subtable) {
                    if ($_subtable["platformID"] == 0 || $_subtable["platformID"] == 3 && $_subtable["platformSpecificID"] == 1) {
                        $subtable = $_subtable;
                        break;
                    }
                }

                if ($subtable) {
                    $glyphIndexArray = $subtable["glyphIndexArray"];
                    $hmtx = $font_obj->getData("hmtx");

                    unset($glyphIndexArray[0xFFFF]);

                    $cidtogid = str_pad('', max(array_keys($glyphIndexArray)) * 2 + 1, "\x00");
                    $font['CIDWidths'] = [];
                    foreach ($glyphIndexArray as $cid => $gid) {
                        if ($cid >= 0 && $cid < 0xFFFF && $gid) {
                            $cidtogid[$cid * 2] = chr($gid >> 8);
                            $cidtogid[$cid * 2 + 1] = chr($gid & 0xFF);
                        }

                        $width = $font_obj->normalizeFUnit(isset($hmtx[$gid]) ? $hmtx[$gid][0] : $hmtx[0][0]);
                        $font['CIDWidths'][$cid] = $width;
                    }

                    $font['CIDtoGID'] = base64_encode(gzcompress($cidtogid));
                    $font['CIDtoGID_Compressed'] = true;

                    $data = file_get_contents($tmp_name);
                } else {
                    $data = file_get_contents($fbfile);
                }

                $font_obj->close();
                unlink($tmp_name);
            }

            // create the font descriptor
            $this->numObj++;
            $fontDescriptorId = $this->numObj;

            $this->numObj++;
            $pfbid = $this->numObj;

            // determine flags (more than a little flakey, hopefully will not matter much)
            $flags = 0;

            if ($font['ItalicAngle'] != 0) {
                $flags += pow(2, 6);
            }

            if ($font['IsFixedPitch'] === 'true') {
                $flags += 1;
            }

            $flags += pow(2, 5); // assume non-sybolic
            $list = [
                'Ascent'       => 'Ascender',
                'CapHeight'    => 'Ascender', //FIXME: php-font-lib is not grabbing this value, so we'll fake it and use the Ascender value // 'CapHeight'
                'MissingWidth' => 'MissingWidth',
                'Descent'      => 'Descender',
                'FontBBox'     => 'FontBBox',
                'ItalicAngle'  => 'ItalicAngle'
            ];
            $fdopt = [
                'Flags'    => $flags,
                'FontName' => $adobeFontName,
                'StemV'    => $stemV
            ];

            foreach ($list as $k => $v) {
                if (isset($font[$v])) {
                    $fdopt[$k] = $font[$v];
                }
            }

            if ($isPfbFont) {
                $fdopt['FontFile'] = $pfbid;
            } elseif ($isTtfFont) {
                $fdopt['FontFile2'] = $pfbid;
            }

            $this->o_fontDescriptor($fontDescriptorId, 'new', $fdopt);

            // embed the font program
            $this->o_contents($this->numObj, 'new');
            $this->objects[$pfbid]['c'] .= $data;

            // determine the cruicial lengths within this file
            if ($isPfbFont) {
                $l1 = strpos($data, 'eexec') + 6;
                $l2 = strpos($data, '00000000') - $l1;
                $l3 = mb_strlen($data, '8bit') - $l2 - $l1;
                $this->o_contents(
                    $this->numObj,
                    'add',
                    ['Length1' => $l1, 'Length2' => $l2, 'Length3' => $l3]
                );
            } elseif ($isTtfFont) {
                $l1 = mb_strlen($data, '8bit');
                $this->o_contents($this->numObj, 'add', ['Length1' => $l1]);
            }

            // tell the font object about all this new stuff
            $options = [
                'BaseFont'       => $adobeFontName,
                'MissingWidth'   => $missing_width,
                'Widths'         => $widthid,
                'FirstChar'      => $firstChar,
                'LastChar'       => $lastChar,
                'FontDescriptor' => $fontDescriptorId
            ];

            if ($isTtfFont) {
                $options['SubType'] = 'TrueType';
            }

            $this->addMessage("adding extra info to font.($fontObjId)");

            foreach ($options as $fk => $fv) {
                $this->addMessage("$fk : $fv");
            }
        }

        return $options;
    }
