    /**
     * Alternate IRR implementation.
     *
     * A more numerically stable implementation that converges to only one value.
     *
     * Based off of Better: https://github.com/better/irr
     *
     * @param  array $values
     *
     * @return float
     */

    private static function alternateIrr(array $values): float
    {
        $rate = 0.0;
        for ($iter = 0; $iter < 100; $iter++) {
            $m = -1000;
            for ($i = 0; $i < \count($values); $i++) {
                $m = \max($m, -$rate * $i);
            }
            $f = [];
            for ($i = 0; $i < \count($values); $i++) {
                $f[$i] = \exp(-$rate * $i - $m);
            }
            $t = 0;
            for ($i = 0; $i < \count($values); $i++) {
                $t += $f[$i] * $values[$i];
            }
            if (\abs($t) < (self::EPSILON * \exp($m))) {
                break;
            }
            $u = 0;
            for ($i = 0; $i < \count($values); $i++) {
                $u += $f[$i] * $i * $values[$i];
            }
            if ($u == 0) {
                return \NAN;
            }
            $rate += $t / $u;
        }
        return \exp($rate) - 1;
    }
