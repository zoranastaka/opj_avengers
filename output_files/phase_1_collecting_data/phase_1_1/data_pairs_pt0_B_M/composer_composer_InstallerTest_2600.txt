    /**
     * @dataProvider getIntegrationTests
     */

    public function testIntegration($file, $message, $condition, $composerConfig, $lock, $installed, $run, $expectLock, $expectInstalled, $expectOutput, $expect, $expectResult)
    {
        if ($condition) {
            eval('$res = '.$condition.';');
            if (!$res) {
                $this->markTestSkipped($condition);
            }
        }

        $io = new BufferIO('', OutputInterface::VERBOSITY_NORMAL, new OutputFormatter(false));

        // Prepare for exceptions
        if (!is_int($expectResult)) {
            $normalizedOutput = rtrim(str_replace("\n", PHP_EOL, $expect));
            $this->setExpectedException($expectResult, $normalizedOutput);
        }

        // Create Composer mock object according to configuration
        $composer = FactoryMock::create($io, $composerConfig);
        $this->tempComposerHome = $composer->getConfig()->get('home');

        $jsonMock = $this->getMockBuilder('Composer\Json\JsonFile')->disableOriginalConstructor()->getMock();
        $jsonMock->expects($this->any())
            ->method('read')
            ->will($this->returnValue($installed));
        $jsonMock->expects($this->any())
            ->method('exists')
            ->will($this->returnValue(true));

        $repositoryManager = $composer->getRepositoryManager();
        $repositoryManager->setLocalRepository(new InstalledFilesystemRepositoryMock($jsonMock));

        // emulate a writable lock file
        $lockData = $lock ? json_encode($lock, JsonFile::JSON_PRETTY_PRINT) : null;
        $lockJsonMock = $this->getMockBuilder('Composer\Json\JsonFile')->disableOriginalConstructor()->getMock();
        $lockJsonMock->expects($this->any())
            ->method('read')
            ->will($this->returnCallback(function () use (&$lockData) {
                return json_decode($lockData, true);
            }));
        $lockJsonMock->expects($this->any())
            ->method('exists')
            ->will($this->returnCallback(function () use (&$lockData) {
                return $lockData !== null;
            }));
        $lockJsonMock->expects($this->any())
            ->method('write')
            ->will($this->returnCallback(function ($value, $options = 0) use (&$lockData) {
                $lockData = json_encode($value, JsonFile::JSON_PRETTY_PRINT);
            }));

        if ($expectLock) {
            $actualLock = array();
            $lockJsonMock->expects($this->atLeastOnce())
                ->method('write')
                ->will($this->returnCallback(function ($hash, $options) use (&$actualLock) {
                    // need to do assertion outside of mock for nice phpunit output
                    // so store value temporarily in reference for later assetion
                    $actualLock = $hash;
                }));
        } elseif ($expectLock === false) {
            $lockJsonMock->expects($this->never())
                ->method('write');
        }

        $contents = json_encode($composerConfig);
        $locker = new Locker($io, $lockJsonMock, $composer->getInstallationManager(), $contents);
        $composer->setLocker($locker);

        $eventDispatcher = $this->getMockBuilder('Composer\EventDispatcher\EventDispatcher')->disableOriginalConstructor()->getMock();
        $autoloadGenerator = $this->getMockBuilder('Composer\Autoload\AutoloadGenerator')
            ->setConstructorArgs(array($eventDispatcher))
            ->getMock();
        $composer->setAutoloadGenerator($autoloadGenerator);
        $composer->setEventDispatcher($eventDispatcher);

        $installer = Installer::create($io, $composer);

        $application = new Application;
        $install = new Command('install');
        $install->addOption('ignore-platform-reqs', null, InputOption::VALUE_NONE);
        $install->addOption('ignore-platform-req', null, InputOption::VALUE_REQUIRED | InputOption::VALUE_IS_ARRAY);
        $install->addOption('no-dev', null, InputOption::VALUE_NONE);
        $install->addOption('dry-run', null, InputOption::VALUE_NONE);
        $install->setCode(function ($input, $output) use ($installer) {
            $ignorePlatformReqs = $input->getOption('ignore-platform-reqs') ?: ($input->getOption('ignore-platform-req') ?: false);

            $installer
                ->setDevMode(!$input->getOption('no-dev'))
                ->setDryRun($input->getOption('dry-run'))
                ->setIgnorePlatformRequirements($ignorePlatformReqs);

            return $installer->run();
        });
        $application->add($install);

        $update = new Command('update');
        $update->addOption('ignore-platform-reqs', null, InputOption::VALUE_NONE);
        $update->addOption('ignore-platform-req', null, InputOption::VALUE_REQUIRED | InputOption::VALUE_IS_ARRAY);
        $update->addOption('no-dev', null, InputOption::VALUE_NONE);
        $update->addOption('no-install', null, InputOption::VALUE_NONE);
        $update->addOption('dry-run', null, InputOption::VALUE_NONE);
        $update->addOption('lock', null, InputOption::VALUE_NONE);
        $update->addOption('with-all-dependencies', null, InputOption::VALUE_NONE);
        $update->addOption('with-dependencies', null, InputOption::VALUE_NONE);
        $update->addOption('prefer-stable', null, InputOption::VALUE_NONE);
        $update->addOption('prefer-lowest', null, InputOption::VALUE_NONE);
        $update->addArgument('packages', InputArgument::IS_ARRAY | InputArgument::OPTIONAL);
        $update->setCode(function ($input, $output) use ($installer) {
            $packages = $input->getArgument('packages');
            $filteredPackages = array_filter($packages, function ($package) {
                return !in_array($package, array('lock', 'nothing', 'mirrors'), true);
            });
            $updateMirrors = $input->getOption('lock') || count($filteredPackages) != count($packages);
            $packages = $filteredPackages;

            $updateAllowTransitiveDependencies = Request::UPDATE_ONLY_LISTED;
            if ($input->getOption('with-all-dependencies')) {
                $updateAllowTransitiveDependencies = Request::UPDATE_LISTED_WITH_TRANSITIVE_DEPS;
            } elseif ($input->getOption('with-dependencies')) {
                $updateAllowTransitiveDependencies = Request::UPDATE_LISTED_WITH_TRANSITIVE_DEPS_NO_ROOT_REQUIRE;
            }

            $ignorePlatformReqs = $input->getOption('ignore-platform-reqs') ?: ($input->getOption('ignore-platform-req') ?: false);

            $installer
                ->setDevMode(!$input->getOption('no-dev'))
                ->setUpdate(true)
                ->setInstall(!$input->getOption('no-install'))
                ->setDryRun($input->getOption('dry-run'))
                ->setUpdateMirrors($updateMirrors)
                ->setUpdateAllowList($packages)
                ->setUpdateAllowTransitiveDependencies($updateAllowTransitiveDependencies)
                ->setPreferStable($input->getOption('prefer-stable'))
                ->setPreferLowest($input->getOption('prefer-lowest'))
                ->setIgnorePlatformRequirements($ignorePlatformReqs);

            return $installer->run();
        });
        $application->add($update);

        if (!preg_match('{^(install|update)\b}', $run)) {
            throw new \UnexpectedValueException('The run command only supports install and update');
        }
