    /**
     * Gaussian elimination - row echelon form
     *
     * Algorithm
     *  for k = 1 ... min(m,n):
     *    Find the k-th pivot:
     *    i_max  := argmax (i = k ... m, abs(A[i, k]))
     *    if A[i_max, k] = 0
     *      error "Matrix is singular!"
     *    swap rows(k, i_max)
     *    Do for all rows below pivot:
     *    for i = k + 1 ... m:
     *      f := A[i, k] / A[k, k]
     *      Do for all remaining elements in current row:
     *      for j = k + 1 ... n:
     *        A[i, j]  := A[i, j] - A[k, j] * f
     *      Fill lower triangular matrix with zeros:
     *      A[i, k]  := 0
     *
     * https://en.wikipedia.org/wiki/Gaussian_elimination
     *
     * @param NumericMatrix $A
     *
     * @return array - matrix in row echelon form and number of row swaps
     *
     * @throws Exception\SingularMatrixException if the matrix is singular
     */

    public static function gaussianElimination(NumericMatrix $A): array
    {
        $m     = $A->getM();
        $n     = $A->getN();
        $size  = \min($m, $n);
        $R     = $A->getMatrix();
        $swaps = 0;
        $ε     = $A->getError();

        for ($k = 0; $k < $size; $k++) {
            // Find column max
            $i_max = $k;
            for ($i = $k; $i < $m; $i++) {
                if (\abs($R[$i][$k]) > \abs($R[$i_max][$k])) {
                    $i_max = $i;
                }
            }

            if (Support::isZero($R[$i_max][$k], $ε)) {
                throw new Exception\SingularMatrixException('Guassian elimination fails for singular matrices');
            }

            // Swap rows k and i_max (column max)
            if ($k != $i_max) {
                [$R[$k], $R[$i_max]] = [$R[$i_max], $R[$k]];
                $swaps++;
            }

            // Row operations
            for ($i = $k + 1; $i < $m; $i++) {
                $f = (Support::isNotZero($R[$k][$k], $ε)) ? $R[$i][$k] / $R[$k][$k] : 1;
                for ($j = $k + 1; $j < $n; $j++) {
                    $R[$i][$j] = $R[$i][$j] - ($R[$k][$j] * $f);
                    if (Support::isZero($R[$i][$j], $ε)) {
                        $R[$i][$j] = 0;
                    }
                }
                $R[$i][$k] = 0;
            }
        }

        return [$R, $swaps];
    }
