/**
 * Class Assets
 * @package Grav\Common
 */

class Assets extends PropertyObject
{
    use TestingAssetsTrait;
    use LegacyAssetsTrait;

    const CSS = 'css';
    const JS = 'js';
    const CSS_COLLECTION = 'assets_css';
    const JS_COLLECTION = 'assets_js';
    const CSS_TYPE = Assets\Css::class;
    const JS_TYPE = Assets\Js::class;
    const INLINE_CSS_TYPE = Assets\InlineCss::class;
    const INLINE_JS_TYPE = Assets\InlineJs::class;

    /** @const Regex to match CSS and JavaScript files */
    const DEFAULT_REGEX = '/.\.(css|js)$/i';

    /** @const Regex to match CSS files */
    const CSS_REGEX = '/.\.css$/i';

    /** @const Regex to match JavaScript files */
    const JS_REGEX = '/.\.js$/i';

    /** @var string */
    protected $assets_dir;
    /** @var string */
    protected $assets_url;

    /** @var array */
    protected $assets_css = [];
    /** @var array */
    protected $assets_js = [];

    // Following variables come from the configuration:
    /** @var bool */
    protected $css_pipeline;
    /** @var bool */
    protected $css_pipeline_include_externals;
    /** @var bool */
    protected $css_pipeline_before_excludes;
    /** @var bool */
    protected $inlinecss_pipeline_include_externals;
    /** @var bool */
    protected $inlinecss_pipeline_before_excludes;
    /** @var bool */
    protected $js_pipeline;
    /** @var bool */
    protected $js_pipeline_include_externals;
    /** @var bool */
    protected $js_pipeline_before_excludes;
    /** @var bool */
    protected $inlinejs_pipeline_include_externals;
    /** @var bool */
    protected $inlinejs_pipeline_before_excludes;
    /** @var array */
    protected $pipeline_options = [];

    /** @var Closure|string */
    protected $fetch_command;
    /** @var string */
    protected $autoload;
    /** @var bool */
    protected $enable_asset_timestamp;
    /** @var array|null */
    protected $collections;
    /** @var string */
    protected $timestamp;
    /** @var array Keeping track for order counts (for sorting) */
    protected $order = [];

    /**
     * Initialization called in the Grav lifecycle to initialize the Assets with appropriate configuration
     *
     * @return void
     */
    public function init()
    {
        $grav = Grav::instance();
        /** @var Config $config */
        $config = $grav['config'];

        $asset_config = (array)$config->get('system.assets');

        /** @var UniformResourceLocator $locator */
        $locator = $grav['locator'];
        $this->assets_dir = $locator->findResource('asset://');
        $this->assets_url = $locator->findResource('asset://', false);

        $this->config($asset_config);

        // Register any preconfigured collections
        foreach ((array) $this->collections as $name => $collection) {
            $this->registerCollection($name, (array)$collection);
        }
    }

    /**
     * Set up configuration options.
     *
     * All the class properties except 'js' and 'css' are accepted here.
     * Also, an extra option 'autoload' may be passed containing an array of
     * assets and/or collections that will be automatically added on startup.
     *
     * @param  array $config Configurable options.
     * @return $this
     */
    public function config(array $config)
    {
        foreach ($config as $key => $value) {
            if ($this->hasProperty($key)) {
                $this->setProperty($key, $value);
            } elseif (Utils::startsWith($key, 'css_') || Utils::startsWith($key, 'js_')) {
                $this->pipeline_options[$key] = $value;
            }
        }

        // Add timestamp if it's enabled
        if ($this->enable_asset_timestamp) {
            $this->timestamp = Grav::instance()['cache']->getKey();
        }

        return $this;
    }

    /**
     * Add an asset or a collection of assets.
     *
     * It automatically detects the asset type (JavaScript, CSS or collection).
     * You may add more than one asset passing an array as argument.
     *
     * @param string|string[] $asset
     * @return $this
     */
    public function add($asset)
    {
        $args = func_get_args();

        // More than one asset
        if (is_array($asset)) {
            foreach ($asset as $index => $location) {
                $params = array_slice($args, 1);
                if (is_array($location)) {
                    $params = array_shift($params);
                    if (is_numeric($params)) {
                        $params = [ 'priority' => $params ];
                    }
                    $params = [array_replace_recursive([], $location, $params)];
                    $location = $index;
                }

                $params = array_merge([$location], $params);
                call_user_func_array([$this, 'add'], $params);
            }
        } elseif (isset($this->collections[$asset])) {
            array_shift($args);
            $args = array_merge([$this->collections[$asset]], $args);
            call_user_func_array([$this, 'add'], $args);
        } else {
            // Get extension
            $extension = pathinfo(parse_url($asset, PHP_URL_PATH), PATHINFO_EXTENSION);

            // JavaScript or CSS
            if ($extension !== '') {
                $extension = strtolower($extension);
                if ($extension === 'css') {
                    call_user_func_array([$this, 'addCss'], $args);
                } elseif ($extension === 'js') {
                    call_user_func_array([$this, 'addJs'], $args);
                }
            }
        }

        return $this;
    }

    /**
     * @param string $collection
     * @param string $type
     * @param string|string[] $asset
     * @param array $options
     * @return $this
     */
    protected function addType($collection, $type, $asset, $options)
    {
        if (is_array($asset)) {
            foreach ($asset as $index => $location) {
                $assetOptions = $options;
                if (is_array($location)) {
                    $assetOptions = array_replace_recursive([], $options, $location);
                    $location = $index;
                }
                $this->addType($collection, $type, $location, $assetOptions);
            }

            return $this;
        }

        if (($type === $this::CSS_TYPE || $type === $this::JS_TYPE) && isset($this->collections[$asset])) {
            $this->addType($collection, $type, $this->collections[$asset], $options);
            return $this;
        }

        // If pipeline disabled, set to position if provided, else after
        if (isset($options['pipeline'])) {
            if ($options['pipeline'] === false) {
                $exclude_type = ($type === $this::JS_TYPE || $type === $this::INLINE_JS_TYPE) ? $this::JS : $this::CSS;
                $excludes = strtolower($exclude_type . '_pipeline_before_excludes');
                if ($this->{$excludes}) {
                    $default = 'after';
                } else {
                    $default = 'before';
                }

                $options['position'] = $options['position'] ?? $default;
            }

            unset($options['pipeline']);
        }

        // Add timestamp
        $options['timestamp'] = $this->timestamp;

        // Set order
        $group = $options['group'] ?? 'head';
        $position = $options['position'] ?? 'pipeline';

        $orderKey = "{$type}|{$group}|{$position}";
        if (!isset($this->order[$orderKey])) {
           $this->order[$orderKey] = 0;
        }

        $options['order'] = $this->order[$orderKey]++;

        // Create asset of correct type
        $asset_object = new $type();

        // If exists
        if ($asset_object->init($asset, $options)) {
            $this->$collection[md5($asset)] = $asset_object;
        }

        return $this;
    }
