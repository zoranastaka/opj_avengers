    /**
     * open the font file and return a php structure containing it.
     * first check if this one has been done before and saved in a form more suited to php
     * note that if a php serialized version does not exist it will try and make one, but will
     * require write access to the directory to do it... it is MUCH faster to have these serialized
     * files.
     *
     * @param $font
     */

    private function openFont($font)
    {
        // assume that $font contains the path and file but not the extension
        $name = basename($font);
        $dir = dirname($font) . '/';

        $fontcache = $this->fontcache;
        if ($fontcache == '') {
            $fontcache = rtrim($dir, DIRECTORY_SEPARATOR."/\\");
        }

        //$name       filename without folder and extension of font metrics
        //$dir      folder of font metrics
        //$fontcache  folder of runtime created php serialized version of font metrics.
        //            If this is not given, the same folder as the font metrics will be used.
        //            Storing and reusing serialized versions improves speed much

        $this->addMessage("openFont: $font - $name");

        if (!$this->isUnicode || in_array(mb_strtolower(basename($name)), self::$coreFonts)) {
            $metrics_name = "$name.afm";
        } else {
            $metrics_name = "$name.ufm";
        }

        $cache_name = "$metrics_name.php";
        $this->addMessage("metrics: $metrics_name, cache: $cache_name");

        if (file_exists($fontcache . '/' . $cache_name)) {
            $this->addMessage("openFont: php file exists $fontcache/$cache_name");
            $this->fonts[$font] = require($fontcache . '/' . $cache_name);

            if (!isset($this->fonts[$font]['_version_']) || $this->fonts[$font]['_version_'] != $this->fontcacheVersion) {
                // if the font file is old, then clear it out and prepare for re-creation
                $this->addMessage('openFont: clear out, make way for new version.');
                $this->fonts[$font] = null;
                unset($this->fonts[$font]);
            }
        } else {
            $old_cache_name = "php_$metrics_name";
            if (file_exists($fontcache . '/' . $old_cache_name)) {
                $this->addMessage(
                    "openFont: php file doesn't exist $fontcache/$cache_name, creating it from the old format"
                );
                $old_cache = file_get_contents($fontcache . '/' . $old_cache_name);
                file_put_contents($fontcache . '/' . $cache_name, '<?php return ' . $old_cache . ';');

                $this->openFont($font);
                return;
            }
        }

        if (!isset($this->fonts[$font]) && file_exists($dir . $metrics_name)) {
            // then rebuild the php_<font>.afm file from the <font>.afm file
            $this->addMessage("openFont: build php file from $dir$metrics_name");
            $data = [];

            // 20 => 'space'
            $data['codeToName'] = [];

            // Since we're not going to enable Unicode for the core fonts we need to use a font-based
            // setting for Unicode support rather than a global setting.
            $data['isUnicode'] = (strtolower(substr($metrics_name, -3)) !== 'afm');

            $cidtogid = '';
            if ($data['isUnicode']) {
                $cidtogid = str_pad('', 256 * 256 * 2, "\x00");
            }

            $file = file($dir . $metrics_name);

            foreach ($file as $rowA) {
                $row = trim($rowA);
                $pos = strpos($row, ' ');

                if ($pos) {
                    // then there must be some keyword
                    $key = substr($row, 0, $pos);
                    switch ($key) {
                        case 'FontName':
                        case 'FullName':
                        case 'FamilyName':
                        case 'PostScriptName':
                        case 'Weight':
                        case 'ItalicAngle':
                        case 'IsFixedPitch':
                        case 'CharacterSet':
                        case 'UnderlinePosition':
                        case 'UnderlineThickness':
                        case 'Version':
                        case 'EncodingScheme':
                        case 'CapHeight':
                        case 'XHeight':
                        case 'Ascender':
                        case 'Descender':
                        case 'StdHW':
                        case 'StdVW':
                        case 'StartCharMetrics':
                        case 'FontHeightOffset': // OAR - Added so we can offset the height calculation of a Windows font.  Otherwise it's too big.
                            $data[$key] = trim(substr($row, $pos));
                            break;

                        case 'FontBBox':
                            $data[$key] = explode(' ', trim(substr($row, $pos)));
                            break;

                        //C 39 ; WX 222 ; N quoteright ; B 53 463 157 718 ;
                        case 'C': // Found in AFM files
                            $bits = explode(';', trim($row));
                            $dtmp = ['C' => null, 'N' => null, 'WX' => null, 'B' => []];

                            foreach ($bits as $bit) {
                                $bits2 = explode(' ', trim($bit));
                                if (mb_strlen($bits2[0], '8bit') == 0) {
                                    continue;
                                }

                                if (count($bits2) > 2) {
                                    $dtmp[$bits2[0]] = [];
                                    for ($i = 1; $i < count($bits2); $i++) {
                                        $dtmp[$bits2[0]][] = $bits2[$i];
                                    }
                                } else {
                                    if (count($bits2) == 2) {
                                        $dtmp[$bits2[0]] = $bits2[1];
                                    }
                                }
                            }

                            $c = (int)$dtmp['C'];
                            $n = $dtmp['N'];
                            $width = floatval($dtmp['WX']);

                            if ($c >= 0) {
                                if (!ctype_xdigit($n) || $c != hexdec($n)) {
                                    $data['codeToName'][$c] = $n;
                                }
                                $data['C'][$c] = $width;
                            } elseif (isset($n)) {
                                $data['C'][$n] = $width;
                            }

                            if (!isset($data['MissingWidth']) && $c === -1 && $n === '.notdef') {
                                $data['MissingWidth'] = $width;
                            }

                            break;

                        // U 827 ; WX 0 ; N squaresubnosp ; G 675 ;
                        case 'U': // Found in UFM files
                            if (!$data['isUnicode']) {
                                break;
                            }

                            $bits = explode(';', trim($row));
                            $dtmp = ['G' => null, 'N' => null, 'U' => null, 'WX' => null];

                            foreach ($bits as $bit) {
                                $bits2 = explode(' ', trim($bit));
                                if (mb_strlen($bits2[0], '8bit') === 0) {
                                    continue;
                                }

                                if (count($bits2) > 2) {
                                    $dtmp[$bits2[0]] = [];
                                    for ($i = 1; $i < count($bits2); $i++) {
                                        $dtmp[$bits2[0]][] = $bits2[$i];
                                    }
                                } else {
                                    if (count($bits2) == 2) {
                                        $dtmp[$bits2[0]] = $bits2[1];
                                    }
                                }
                            }

                            $c = (int)$dtmp['U'];
                            $n = $dtmp['N'];
                            $glyph = $dtmp['G'];
                            $width = floatval($dtmp['WX']);

                            if ($c >= 0) {
                                // Set values in CID to GID map
                                if ($c >= 0 && $c < 0xFFFF && $glyph) {
                                    $cidtogid[$c * 2] = chr($glyph >> 8);
                                    $cidtogid[$c * 2 + 1] = chr($glyph & 0xFF);
                                }

                                if (!ctype_xdigit($n) || $c != hexdec($n)) {
                                    $data['codeToName'][$c] = $n;
                                }
                                $data['C'][$c] = $width;
                            } elseif (isset($n)) {
                                $data['C'][$n] = $width;
                            }

                            if (!isset($data['MissingWidth']) && $c === -1 && $n === '.notdef') {
                                $data['MissingWidth'] = $width;
                            }

                            break;

                        case 'KPX':
                            break; // don't include them as they are not used yet
                            //KPX Adieresis yacute -40
                            /*$bits = explode(' ', trim($row));
                            $data['KPX'][$bits[1]][$bits[2]] = $bits[3];
                            break;*/
                    }
                }
            }

            if ($this->compressionReady && $this->options['compression']) {
                // then implement ZLIB based compression on CIDtoGID string
                $data['CIDtoGID_Compressed'] = true;
                $cidtogid = gzcompress($cidtogid, 6);
            }
            $data['CIDtoGID'] = base64_encode($cidtogid);
            $data['_version_'] = $this->fontcacheVersion;
            $this->fonts[$font] = $data;

            //Because of potential trouble with php safe mode, expect that the folder already exists.
            //If not existing, this will hit performance because of missing cached results.
            if (is_dir($fontcache) && is_writable($fontcache)) {
                file_put_contents($fontcache . '/' . $cache_name, '<?php return ' . var_export($data, true) . ';');
            }
            $data = null;
        }

        if (!isset($this->fonts[$font])) {
            $this->addMessage("openFont: no font file found for $font. Do you need to run load_font.php?");
        }

        //pre_r($this->messages);
    }
