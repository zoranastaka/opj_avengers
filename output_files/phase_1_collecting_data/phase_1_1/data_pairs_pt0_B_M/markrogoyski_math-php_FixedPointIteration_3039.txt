    /**
     * Verify the input arguments are valid for correct use of fixed point
     * iteration. If the tolerance is less than zero, an Exception will be thrown.
     * If $a = $b, then clearly we cannot run our loop as [$a, $b] will not be
     * an interval, so we throw an Exception. If $a > $b, we simply reverse them
     * as if the user input $b = $a and $a = $b so the new $a < $b.
     *
     * @param number   $a        The start of the interval which contains a root
     * @param number   $b        The end of the interval which contains a root
     * @param number   $p        The initial guess of our root
     * @param number   $tol      Tolerance; How close to the actual solution we would like.
     *
     * @throws Exception\OutOfBoundsException if $tol (the tolerance) is negative
     * @throws Exception\BadDataException if $a = $b
     * @throws Exception\OutOfBoundsException if either $p > $a or $p < $b return false
     */

    private static function validate($a, $b, $p, $tol)
    {
        Validation::tolerance($tol);
        Validation::interval($a, $b);

        if ($a > $b) {
            [$a, $b] = [$b, $a];
        }

        if ($p < $a || $p > $b) {
            throw new Exception\OutOfBoundsException("Initial guess $p must be in [$a, $b].");
        }
    }
