    /**
     * return array containing codepoints (UTF-8 character values) for the
     * string passed in.
     *
     * based on the excellent TCPDF code by Nicola Asuni and the
     * RFC for UTF-8 at http://www.faqs.org/rfcs/rfc3629.html
     *
     * @access private
     * @author Orion Richardson
     * @since  January 5, 2008
     *
     * @param string $text UTF-8 string to process
     *
     * @return array UTF-8 codepoints array for the string
     */

    function utf8toCodePointsArray(&$text)
    {
        $length = mb_strlen($text, '8bit'); // http://www.php.net/manual/en/function.mb-strlen.php#77040
        $unicode = []; // array containing unicode values
        $bytes = []; // array containing single character byte sequences
        $numbytes = 1; // number of octets needed to represent the UTF-8 character

        for ($i = 0; $i < $length; $i++) {
            $c = ord($text[$i]); // get one string character at time
            if (count($bytes) === 0) { // get starting octect
                if ($c <= 0x7F) {
                    $unicode[] = $c; // use the character "as is" because is ASCII
                    $numbytes = 1;
                } elseif (($c >> 0x05) === 0x06) { // 2 bytes character (0x06 = 110 BIN)
                    $bytes[] = ($c - 0xC0) << 0x06;
                    $numbytes = 2;
                } elseif (($c >> 0x04) === 0x0E) { // 3 bytes character (0x0E = 1110 BIN)
                    $bytes[] = ($c - 0xE0) << 0x0C;
                    $numbytes = 3;
                } elseif (($c >> 0x03) === 0x1E) { // 4 bytes character (0x1E = 11110 BIN)
                    $bytes[] = ($c - 0xF0) << 0x12;
                    $numbytes = 4;
                } else {
                    // use replacement character for other invalid sequences
                    $unicode[] = 0xFFFD;
                    $bytes = [];
                    $numbytes = 1;
                }
            } elseif (($c >> 0x06) === 0x02) { // bytes 2, 3 and 4 must start with 0x02 = 10 BIN
                $bytes[] = $c - 0x80;
                if (count($bytes) === $numbytes) {
                    // compose UTF-8 bytes to a single unicode value
                    $c = $bytes[0];
                    for ($j = 1; $j < $numbytes; $j++) {
                        $c += ($bytes[$j] << (($numbytes - $j - 1) * 0x06));
                    }
                    if ((($c >= 0xD800) and ($c <= 0xDFFF)) or ($c >= 0x10FFFF)) {
                        // The definition of UTF-8 prohibits encoding character numbers between
                        // U+D800 and U+DFFF, which are reserved for use with the UTF-16
                        // encoding form (as surrogate pairs) and do not directly represent
                        // characters.
                        $unicode[] = 0xFFFD; // use replacement character
                    } else {
                        $unicode[] = $c; // add char to array
                    }
                    // reset data for next char
                    $bytes = [];
                    $numbytes = 1;
                }
            } else {
                // use replacement character for other invalid sequences
                $unicode[] = 0xFFFD;
                $bytes = [];
                $numbytes = 1;
            }
        }

        return $unicode;
    }
