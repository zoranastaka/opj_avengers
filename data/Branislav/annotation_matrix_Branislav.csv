pair_id,comment,Komentar,code,"upit
","pretvaranje int u string
","red sa prioritetom
","pretvaranje string u datum
","sortiranje string liste
","čuvanje liste u datoteku
","postgresql konekcija
","konfuziona matrica
","postavljanje radnog direktorijuma
","grupisanje po izbrojanim podacima
","binomna raspodela
","aes šifrovanje
","linearna regresija
","vreme tolerisanja za prijem na soketu
","upisivanje u csv datoteku
","pretvaranje decimalnog u heksadecimalni broj
","izvoz podataka u excel
","dijagram rasejanja
","pretvaranje json u csv
","lepo ispiši json
","zamena delova datoteke
","klasterizacija metodom k-srednjih vrednosti
","povezivanje na sql server
","html šifrovan string
","određivanje proteklog vremena korišćenjem časovnika
","parsiranje binarne datoteke u prilagođenu klasu
","dohvatanje trenutne ip adrese
","pretvaranje int u bool
","isčitavanje tekstualne datoteke liniju po liniju
","dohvatanje putanje izvršavanja
","odprema json datoteke pomoću HttpClient POST zahteva
","dohvatanje unutrašnjeg svojstva html taga
","pretvaranje string u broj
","formatiranje datuma
","nepromenjivi (readonly) niz
","filtriranje niza
","mapa u json
","parsiranje json datoteke
","dohvati trenutnu vrednost posmatrača
","dohvati naziv za vrednost enumerisanog tipa podatka
","šifriraj url
","kreiraj kolačić
","kako isprazniti niz
","kako dohvatiti današnji datum
","kako štiklirati checkbox
","inicijalizacija niza
","kako obrnuti string
","pročitaj svojstva datoteke
","prekopiraj u klibord
","pretvaranje html stranice u pdf
","konverzija json u xml datoteku
","kako nasumično izabrati broj
","normalna raspodela
","Nelder-Mead optimizacija
","hashset za određivanje broja različitih elemenata
","kako dohvatiti naziv tabele iz baze
","deserializacija json-a
","pronađi int unutar stringa
","dohvatanje jedinstvenog identifikatora trenutnog procesa
","regex ne razlikuje velika i mala slova
","prilagođeni http odgovor greške
","kako odrediti da li je string valida reč
","zamena http entiteta
","sakrij atribute datoteke
","sortiraj više nizova na osnovu redosleda drugih sortiranih nizova
","levenshteinova slicnost stringova
","kako dohvatiti html kod sa veb sajta
","baferisano čitanje teksta čitačem fajlova
","aes šifrovanje u ctr načinu rada
","matrica množenja
","štampanje rezimea modela
","jedinstveni elementi
","izvlačenje podataka iz sadržaja html koda
","toplotna mapa iz 3d koordinata
","dohvatanje svih roditelja xml čvora
","kako rekurzivno raspakovati zip datoteku
","podvuci tekst u label vidžetu
","raspakivanje velikih datoteka
","kopiranje putanje fajla
","dohvati opis http statusnog koda
","nasumično izvuci x stavki iz liste
","konvertuj string datum u yyyymmdd format
","pretvoriti utc vreme u epohu
","sve permutacije liste
","izvuci geografsku širinu i dužinu iz datog unosa
","kako proveriti da je checkbox štikliran
","pretvoriti uint8 niz u sliku
","memoizacija na disk - persistentna memoizacija
","parsiranje argumenata komandne linije
","kako pročitati sadržaj iz .gz zapakovanog fajla
","slanje binarnih podataka preko seriske veze
","otpakovanje podataka iz tekstualne datoteke
","pozicije podstingova u stringu
","čitanje elemenata iz html-a - <td>
","oduzimanje medijana iz svake kolone
","uklanjanja zaglavlja prilikom spajanja nekoliko datoteka
","parsiranje query stringa u url-u
","rangiranje fazi članova na osnovu stepena podudaranja
","izlaz u html datoteku
",kako efikasno pročitati .csv datoteku
PrestaShop_PrestaShop_Alias_808, Class AliasCore.\\\\n,Glavna klasa za pseudonim.,"class AliasCore extends ObjectModel{    public $alias;    public $search;    public $active = true;    /**     * @see ObjectModel::$definition     */    public static $definition = [        'table' => 'alias',        'primary' => 'id_alias',        'fields' => [            'search' => ['type' => self::TYPE_STRING, 'validate' => 'isValidSearch', 'required' => true, 'size' => 255],            'alias' => ['type' => self::TYPE_STRING, 'validate' => 'isValidSearch', 'required' => true, 'size' => 255],            'active' => ['type' => self::TYPE_BOOL, 'validate' => 'isBool'],        ],    ];    /**     * AliasCore constructor.     *     * @param int|null $id Alias ID     * @param string|null $alias Alias     * @param string|null $search Search string     * @param int|null $idLang Language ID     */    public function __construct($id = null, $alias = null, $search = null, $idLang = null)    {        $this->def = Alias::getDefinition($this);        $this->setDefinitionRetrocompatibility();        if ($id) {            parent::__construct($id);        } elseif ($alias && Validate::isValidSearch($alias)) {            if (!Alias::isFeatureActive()) {                $this->alias = trim($alias);                $this->search = trim($search);            } else {                $row = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT a.id_alias, a.search, a.aliasFROM `' . _DB_PREFIX_ . 'alias` aWHERE `alias` = \'' . pSQL($alias) . '\' AND `active` = 1');                if ($row) {                    $this->id = (int) $row['id_alias'];                    $this->search = $search ? trim($search) : $row['search'];                    $this->alias = $row['alias'];                } else {                    $this->alias = trim($alias);                    $this->search = trim($search);                }            }        }    }    /**     * @see ObjectModel::add();     */    public function add($autoDate = true, $nullValues = false)    {        $this->alias = Tools::replaceAccentedChars($this->alias);        $this->search = Tools::replaceAccentedChars($this->search);        if (parent::add($autoDate, $nullValues)) {            // Set cache of feature detachable to true            Configuration::updateGlobalValue('PS_ALIAS_FEATURE_ACTIVE', '1');            return true;        }        return false;    }    /**     * @see ObjectModel::delete();     */    public function delete()    {        if (parent::delete()) {            // Refresh cache of feature detachable            Configuration::updateGlobalValue('PS_ALIAS_FEATURE_ACTIVE', Alias::isCurrentlyUsed($this->def['table'], true));            return true;        }        return false;    }    /**     * Get all found aliases from DB with search query.     *     * @return string Comma separated aliases     */    public function getAliases()    {        if (!Alias::isFeatureActive()) {            return '';        }        $aliases = Db::getInstance()->executeS('SELECT a.aliasFROM `' . _DB_PREFIX_ . 'alias` aWHERE `search` = \'' . pSQL($this->search) . '\'');        $aliases = array_map('implode', $aliases);        return implode(', ', $aliases);    }    /**     * This method is allow to know if a feature is used or active.     *     * @since 1.5.0.1     *     * @return bool     */    public static function isFeatureActive()    {        return Configuration::get('PS_ALIAS_FEATURE_ACTIVE');    }    /**     * This method is allow to know if a alias exist for AdminImportController.     *     * @param int $idAlias Alias ID     *     * @return bool     *     * @since 1.5.6.0     */    public static function aliasExists($idAlias)    {        $sql = new DbQuery();        $sql->select('a.`id_alias`');        $sql->from('alias', 'a');        $sql->where('a.`id_alias` = ' . (int) $idAlias);        $row = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow($sql, false);        return isset($row['id_alias']);    }}",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attachment_813, Class AttachmentCore.\n,Glavna klasa za priložene fajlove.,"class AttachmentCore extends ObjectModel{    public $file;    public $file_name;    public $file_size;    public $name;    public $mime;    public $description;    /** @var int position Position */    public $position;    /**     * @see ObjectModel::$definition     */    public static $definition = [        'table' => 'attachment',        'primary' => 'id_attachment',        'multilang' => true,        'fields' => [            'file' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName', 'required' => true, 'size' => 40],            'mime' => ['type' => self::TYPE_STRING, 'validate' => 'isCleanHtml', 'required' => true, 'size' => 128],            'file_name' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName', 'size' => 128],            'file_size' => ['type' => self::TYPE_INT, 'validate' => 'isUnsignedId'],            /* Lang fields */            'name' => ['type' => self::TYPE_STRING, 'lang' => true, 'validate' => 'isGenericName', 'required' => true, 'size' => 32],            'description' => ['type' => self::TYPE_STRING, 'lang' => true, 'validate' => 'isCleanHtml'],        ],        'associations' => [            'products' => ['type' => self::HAS_MANY, 'field' => 'id_product', 'object' => 'Product', 'association' => 'product_attachment'],        ],    ];    protected $webserviceParameters = [        'objectNodeNames' => 'attachments',        'hidden_fields' => [],        'fields' => [            'file' => [],            'file_name' => [],            'file_size' => [],            'mime' => [],        ],        'associations' => [            'products' => [                'resource' => 'product',                'api' => 'products',                'fields' => [                    'id' => ['required' => true],                ],            ],        ],    ];    /**     * @see ObjectModel::add()     */    public function add($autoDate = true, $nullValues = false)    {        if (file_exists(_PS_DOWNLOAD_DIR_ . $this->file)) {            $this->file_size = filesize(_PS_DOWNLOAD_DIR_ . $this->file);        }        return parent::add($autoDate, $nullValues);    }    /**     * @see ObjectModel::update()     */    public function update($nullValues = false)    {        if (file_exists(_PS_DOWNLOAD_DIR_ . $this->file)) {            $this->file_size = filesize(_PS_DOWNLOAD_DIR_ . $this->file);        }        return parent::update($nullValues);    }    /**     * @see ObjectModel::delete()     */    public function delete()    {        if (file_exists(_PS_DOWNLOAD_DIR_ . $this->file)) {            @unlink(_PS_DOWNLOAD_DIR_ . $this->file);        }        $sql = new DbQuery();        $sql->select('pa.`id_product`');        $sql->from('product_attachment', 'pa');        $sql->where('pa.`id_attachment` = ' . (int) $this->id);        $products = Db::getInstance()->executeS($sql);        Db::getInstance()->delete(            'product_attachment',            '`id_attachment` = ' . (int) $this->id        );        foreach ($products as $product) {            Product::updateCacheAttachment((int) $product['id_product']);        }        return parent::delete();    }    /**     * Delete selection of attachments.     *     * @param array $attachments Attachments     *     * @return bool|int Whether the selection has been successfully deleted     * @todo: Find out if $return can be initialized with true. (breaking change)     */    public function deleteSelection($attachments)    {        $return = 1;        foreach ($attachments as $idAttachment) {            $attachment = new Attachment((int) $idAttachment);            $return &= $attachment->delete();        }        return $return;    }    /**     * Get attachments.     *     * @param int $idLang Language ID     * @param int $idProduct Product ID     * @param bool $include Whether the attachments are included or excluded from the Product ID     *     * @return array|false|mysqli_result|PDOStatement|resource|null Database query result     */    public static function getAttachments($idLang, $idProduct, $include = true)    {        return Db::getInstance()->executeS(            'SELECT *FROM ' . _DB_PREFIX_ . 'attachment aLEFT JOIN ' . _DB_PREFIX_ . 'attachment_lang alON (a.id_attachment = al.id_attachment AND al.id_lang = ' . (int) $idLang . ')WHERE a.id_attachment ' . ($include ? 'IN' : 'NOT IN') . ' (SELECT pa.id_attachmentFROM ' . _DB_PREFIX_ . 'product_attachment paWHERE id_product = ' . (int) $idProduct . ')'        );    }    /**     * Unassociate all products from the current object     *     * @param bool $updateAttachmentCache [default=true] If set to false attachment cache will not be updated     *     * @return bool Deletion result     */    public function deleteAttachments(bool $updateAttachmentCache = true): bool    {        if (0 >= (int) $this->id) {            // Can not delete attachement without id            return false;        }        $res = Db::getInstance()->execute(            'DELETE FROM `' . _DB_PREFIX_ . 'product_attachment` ' .            'WHERE `id_attachment` = ' . (int) $this->id        );        if ($updateAttachmentCache === true) {            $productIds = Db::getInstance()->executeS(                'SELECT `id_product` FROM `' . _DB_PREFIX_ . 'product_attachment` ' .                'WHERE `id_attachment` = ' . (int) $this->id            );            foreach ($productIds as $productId) {                Product::updateCacheAttachment((int) $productId);            }        }        return $res;    }    /**     * Delete Product attachments for the given Product ID.     *     * @param int $idProduct Product ID     *     * @return bool     */    public static function deleteProductAttachments($idProduct)    {        $res = Db::getInstance()->execute('DELETE FROM ' . _DB_PREFIX_ . 'product_attachmentWHERE id_product = ' . (int) $idProduct);        Product::updateCacheAttachment((int) $idProduct);        return $res;    }    /**     * Associate $id_product to the current object.     *     * @param int $idProduct id of the product to associate     *     * @return bool true if success     */    public function attachProduct($idProduct)    {        return static::associateProductAttachment((int) $idProduct, (int) $this->id);    }    /**     * @param int $productId     * @param int $attachmentId     *     * @return bool true if success     */    public static function associateProductAttachment(int $productId, int $attachmentId): bool    {        $res = Db::getInstance()->execute('INSERT INTO ' . _DB_PREFIX_ . 'product_attachment(id_attachment, id_product) VALUES(' . $attachmentId . ', ' . $productId . ')');        Product::updateCacheAttachment($productId);        return $res;    }    /**     * Associate an array of id_attachment $array to the product $id_product     * and remove eventual previous association.     *     * @param int $idProduct Product ID     * @param array $array Attachment IDs     *     * @return bool Whether the attachments have been successfully associated with the Product     */    public static function attachToProduct($idProduct, $array)    {        $result1 = Attachment::deleteProductAttachments($idProduct);        if (is_array($array)) {            $ids = [];            foreach ($array as $idAttachment) {                if ((int) $idAttachment > 0) {                    $ids[] = ['id_product' => (int) $idProduct, 'id_attachment' => (int) $idAttachment];                }            }            if (!empty($ids)) {                $result2 = Db::getInstance()->insert('product_attachment', $ids);            }        }        Product::updateCacheAttachment((int) $idProduct);        if (is_array($array)) {            return $result1 && (!isset($result2) || $result2);        }        return $result1;    }    /**     * Get Attachment IDs for the given Product within the given range of attachment IDs.     *     * @param int $idLang Language ID     * @param array $list List of attachment IDs in which to search     *     * @return array|bool List of attachment IDs found. False if nothing found.     */    public static function getProductAttached($idLang, $list)    {        if (!is_array($list)) {            return false;        }        $idsAttachments = array_column($list, 'id_attachment');        $sql = 'SELECT * FROM `' . _DB_PREFIX_ . 'product_attachment` pa ' .             'LEFT JOIN `' . _DB_PREFIX_ . 'product_lang` pl ON (pa.`id_product` = pl.`id_product`' . Shop::addSqlRestrictionOnLang('pl') . ') ' .             'WHERE `id_attachment` IN (' . implode(',', array_map('intval', $idsAttachments)) . ') ' .             'AND pl.`id_lang` = ' . (int) $idLang;        $tmp = Db::getInstance()->executeS($sql);        $productAttachments = [];        foreach ($tmp as $t) {            $productAttachments[$t['id_attachment']][] = $t['name'];        }        return $productAttachments;    }    /**     * Get attachment products ids of current attachment for association.     *     * @return array<int, array{ id: string }> An array of product ids     */    public function getWsProducts(): array    {        return Db::getInstance()->executeS(            'SELECT p.`id_product` AS id ' .            'FROM `' . _DB_PREFIX_ . 'product_attachment` pa ' .            'INNER JOIN `' . _DB_PREFIX_ . 'product` p ON (p.id_product = pa.id_product) ' .            '' . Shop::addSqlAssociation('product', 'p') . ' ' .            'WHERE pa.`id_attachment` = ' . (int) $this->id        );    }    /**     * Set products ids of current attachment for association.     *     * @param array<int, array{id: int|string }> $products Products ids     *     * @return bool     */    public function setWsProducts(array $products): bool    {        $this->deleteAttachments(true);        foreach ($products as $product) {            Db::getInstance()->execute('INSERT INTO `' . _DB_PREFIX_ . 'product_attachment` (`id_product`, `id_attachment`) VALUES (' . (int) $product['id'] . ', ' . (int) $this->id . ')');            Product::updateCacheAttachment((int) $product['id']);        }        return true;    }}",2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_806, Get Address format from DB.\\n\\n @param int $idCountry Country ID\\n\\n @return false|string|null Address format\\n\\n @since 1.7.0\\n,Dohvati format adrese iz baze podataka.,"    protected function getFormatDB($idCountry)    {        if (!Cache::isStored('AddressFormat::getFormatDB' . $idCountry)) {            $format = Db::getInstance()->getValue('SELECT formatFROM `' . _DB_PREFIX_ . $this->def['table'] . '`WHERE `id_country` = ' . (int) $idCountry);            $format = trim($format);            Cache::store('AddressFormat::getFormatDB' . $idCountry, $format);            return $format;        }        return Cache::retrieve('AddressFormat::getFormatDB' . $idCountry);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_779, Get Zone ID for a given address.\\\\n\\\\n @param int $id_address Address ID for which we want to get the Zone ID\\\\n\\\\n @return int Zone ID\\\\n,Dohvati identifikator zone na osnovu adrese.,"    public static function getZoneById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        if (isset(self::$_idZones[$id_address])) {            return self::$_idZones[$id_address];        }        $id_zone = Hook::exec('actionGetIDZoneByAddressID', ['id_address' => $id_address]);        if (is_numeric($id_zone)) {            self::$_idZones[$id_address] = (int) $id_zone;            return self::$_idZones[$id_address];        }        $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT s.`id_zone` AS id_zone_state, c.`id_zone`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`LEFT JOIN `' . _DB_PREFIX_ . 'state` s ON s.`id_state` = a.`id_state`WHERE a.`id_address` = ' . (int) $id_address);        if (empty($result['id_zone_state']) && empty($result['id_zone'])) {            return false;        }        self::$_idZones[$id_address] = !empty($result['id_zone_state'])            ? (int) $result['id_zone_state']            : (int) $result['id_zone'];        return self::$_idZones[$id_address];    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_781, Request to check if DNI field is required\\\\\\\\n depending on the current selected country.\\\\\\\\n\\\\\\\\n @param int $idCountry\\\\\\\\n\\\\\\\\n @return bool\\\\\\\\n,Pošalji zahtev za proveru da li je potreno polje za DNS u zavisnosti od trenutno izabrane države.,    public static function dniRequired($idCountry)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT c.`need_identification_number` ' .            'FROM `' . _DB_PREFIX_ . 'country` c ' .            'WHERE c.`id_country` = ' . (int) $idCountry        );    },3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonTimeZone_361, Convert a total minutes offset into a standardized timezone offset string.\\\\n\\\\n @param float $minutes number of total minutes of the timezone shift.\\\\n\\\\n @return string\\\\n,Konvertuj ukupan broj minuta u string pomeraj vremenske zone.,"    public static function getOffsetNameFromMinuteOffset(float $minutes): string    {        $minutes = round($minutes);        $unsignedMinutes = abs($minutes);        return ($minutes < 0 ? '-' : '+').            str_pad((string) floor($unsignedMinutes / 60), 2, '0', STR_PAD_LEFT).            ':'.            str_pad((string) ($unsignedMinutes % 60), 2, '0', STR_PAD_LEFT);    }",0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Helpers_613, Converts decimal numbers to roman numerals\n\n @param int $num\n\n @throws Exception\n @return string\n,Pretvori decimalane u rimske brojeve.,"    public static function dec2roman($num)    {        static $ones = ["""", ""i"", ""ii"", ""iii"", ""iv"", ""v"", ""vi"", ""vii"", ""viii"", ""ix""];        static $tens = ["""", ""x"", ""xx"", ""xxx"", ""xl"", ""l"", ""lx"", ""lxx"", ""lxxx"", ""xc""];        static $hund = ["""", ""c"", ""cc"", ""ccc"", ""cd"", ""d"", ""dc"", ""dcc"", ""dccc"", ""cm""];        static $thou = ["""", ""m"", ""mm"", ""mmm""];        if (!is_numeric($num)) {            throw new Exception(""dec2roman() requires a numeric argument."");        }        if ($num > 4000 || $num < 0) {            return ""(out of range)"";        }        $num = strrev((string)$num);        $ret = """";        switch (mb_strlen($num)) {            /** @noinspection PhpMissingBreakStatementInspection */            case 4:                $ret .= $thou[$num[3]];            /** @noinspection PhpMissingBreakStatementInspection */            case 3:                $ret .= $hund[$num[2]];            /** @noinspection PhpMissingBreakStatementInspection */            case 2:                $ret .= $tens[$num[1]];            /** @noinspection PhpMissingBreakStatementInspection */            case 1:                $ret .= $ones[$num[0]];            default:                break;        }        return $ret;    }",0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
firefly-iii_firefly-iii_AccountController_772, Class AccountController\n,Klasa za upravljanje nalogom.,"class AccountController extends Controller{    use AccountFilter;    private array                      $balanceTypes;    private AccountRepositoryInterface $repository;    /**     * AccountController constructor.     */    public function __construct()    {        parent::__construct();        $this->middleware(            function ($request, $next) {                /** @var User $user */                $user             = auth()->user();                $this->repository = app(AccountRepositoryInterface::class);                $this->repository->setUser($user);                return $next($request);            }        );        $this->balanceTypes = [AccountType::ASSET, AccountType::LOAN, AccountType::DEBT, AccountType::MORTGAGE,];    }    /**     * @param AutocompleteRequest $request     *     * @return JsonResponse     */    public function accounts(AutocompleteRequest $request): JsonResponse    {        $data  = $request->getData();        $types = $data['types'];        $query = $data['query'];        $date  = $data['date'] ?? today(config('app.timezone'));        $return          = [];        $result          = $this->repository->searchAccount((string)$query, $types, $data['limit']);        $defaultCurrency = app('amount')->getDefaultCurrency();        /** @var Account $account */        foreach ($result as $account) {            $nameWithBalance = $account->name;            $currency        = $this->repository->getAccountCurrency($account) ?? $defaultCurrency;            if (in_array($account->accountType->type, $this->balanceTypes, true)) {                $balance         = app('steam')->balance($account, $date);                $nameWithBalance = sprintf('%s (%s)', $account->name, app('amount')->formatAnything($currency, $balance, false));            }            $return[] = [                'id'                      => (string)$account->id,                'name'                    => $account->name,                'name_with_balance'       => $nameWithBalance,                'type'                    => $account->accountType->type,                'currency_id'             => $currency->id,                'currency_name'           => $currency->name,                'currency_code'           => $currency->code,                'currency_symbol'         => $currency->symbol,                'currency_decimal_places' => $currency->decimal_places,            ];        }        // custom order.        $order = [AccountType::ASSET, AccountType::REVENUE, AccountType::EXPENSE];        usort(            $return, function ($a, $b) use ($order) {            $pos_a = array_search($a['type'], $order);            $pos_b = array_search($b['type'], $order);            return $pos_a - $pos_b;        }        );        return response()->json($return);    }}",0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
paragonie_random_compat_random_bytes_com_dotnet_724," Windows with PHP < 5.3.0 will not have the function\n openssl_random_pseudo_bytes() available, so let's use\n CAPICOM to work around this deficiency.\n\n @param int $bytes\n\n @throws Exception\n\n @return string\n",Funkcija koja ispravlja nedostatak nepodržavanja funkcionalnosti za generisanje openssl slučajnog pseudo bajta na Windows PHP verziji manjoj od 5.3.0,"    function random_bytes($bytes)    {        try {            /** @var int $bytes */            $bytes = RandomCompat_intval($bytes);        } catch (TypeError $ex) {            throw new TypeError(                'random_bytes(): $bytes must be an integer'            );        }        if ($bytes < 1) {            throw new Error(                'Length must be greater than 0'            );        }        /** @var string $buf */        $buf = '';        if (!class_exists('COM')) {            throw new Error(                'COM does not exist'            );        }        /** @var COM $util */        $util = new COM('CAPICOM.Utilities.1');        $execCount = 0;        /**         * Let's not let it loop forever. If we run N times and fail to         * get N bytes of random data, then CAPICOM has failed us.         */        do {            $buf .= base64_decode((string) $util->GetRandom($bytes, 0));            if (RandomCompat_strlen($buf) >= $bytes) {                /**                 * Return our random entropy buffer here:                 */                return (string) RandomCompat_substr($buf, 0, $bytes);            }            ++$execCount;        } while ($execCount < $bytes);        /**         * If we reach here, PHP has failed us.         */        throw new Exception(            'Could not gather sufficient random data'        );    }",0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_Inn_930, Generates INN Checksum\\n\\n https://ru.wikipedia.org/wiki/%D0%98%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BD%D0%BE%D0%BC%D0%B5%D1%80_%D0%BD%D0%B0%D0%BB%D0%BE%D0%B3%D0%BE%D0%BF%D0%BB%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%89%D0%B8%D0%BA%D0%B0\\n\\n @param string $inn\\n @return string Checksum (one digit)\\n,Generiši GNI kontrolnu sumu.,"    public static function checksum($inn)    {        $multipliers = array(1 => 2, 2 => 4, 3 => 10, 4 => 3, 5 => 5, 6 => 9, 7 => 4, 8 => 6, 9 => 8);        $sum = 0;        for ($i = 1; $i <= 9; $i++) {            $sum += intval(substr($inn, $i-1, 1)) * $multipliers[$i];        }        return strval(($sum % 11) % 10);    }",0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_FactoryParameter_2309, Compute the declaration code.\n\n @return string\n,Izvuci kod deklaracije,"    public function getDeclaration()    {        $code = $this->getTypeCode() . $this->getInvocation();        if ($this->reflector->isOptional()) {            $default = $this->reflector->getDefaultValue();            if (is_null($default)) {                $default = 'null';            } elseif (is_bool($default)) {                $default = $default ? 'true' : 'false';            } elseif (is_string($default)) {                $default = ""'"" . $default . ""'"";            } elseif (is_numeric($default)) {                $default = strval($default);            } elseif (is_array($default)) {                $default = 'array()';            } else {                echo 'Warning: unknown default type for ' . $this->getMethod()->getFullName() . ""\n"";                var_dump($default);                $default = 'null';            }            $code .= ' = ' . $default;        }        return $code;    }",0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distribution_3514," Assign an ordinal ranking to data - (""1234"" ranking)\\n https://en.wikipedia.org/wiki/Ranking\\n\\n Similar to R: rank(values, ties.method=\\\'first\\\')\\n\\n @param array $values to be ranked\\n\\n @return array Rankings of the data in the same order the values were input\\n",Dodeli redni broj podacima,    public static function ordinalRanking(array $values): array    {        $Xs = $values;        \sort($Xs);        $rankingâŸ®XâŸ¯ = [];        foreach ($Xs as $i => $x) {            $rankingâŸ®XâŸ¯[\strval($x)][] = $i + 1;        }        // Map ranks to values in order they were originally input        $rankedValues = [];        foreach ($values as $value) {            $rankedValues[] = \array_shift($rankingâŸ®XâŸ¯[\strval($value)]);        }        return $rankedValues;    },0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_452," Remove an item from the queue\\n\\n This is different than {@link extract()}; its purpose is to dequeue an\\n item.\\n\\n This operation is potentially expensive, as it requires\\n re-initialization and re-population of the inner queue.\\n\\n Note: this removes the first item matching the provided item found. If\\n the same item has been added multiple times, it will not remove other\\n instances.\\n\\n @param  mixed $datum\\n @return bool False if the item was not found, true otherwise.\\n\\n @psalm-param T $datum\\n",Ukloni stavku iz reda. Operacija je potencijalno spora jer zahteva ponovnu inicijalizaciju i popunjavanje reda. Napomena: Ovo uklanja prvu pronađenu stavku koja se podudara sa datom stavkom. ,"    public function remove($datum)    {        $found = false;        foreach ($this->items as $key => $item) {            if ($item['data'] === $datum) {                $found = true;                break;            }        }        if ($found) {            unset($this->items[$key]);            $this->queue = null;            if (! $this->isEmpty()) {                $queue = $this->getQueue();                foreach ($this->items as $item) {                    $queue->insert($item['data'], $item['priority']);                }            }            return true;        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1190," Peek at the top node in the queue, based on priority.\n\n @return mixed\n",Zaviri u vrh reda u zavisnosti od prioriteta.,    public function top()    {        return $this->getIterator()->top();    },0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_453, Is the queue empty?\\n\\n @return bool\\n,Proveri da li je red prazan.,    public function isEmpty()    {        return (0 === $this->count());    },0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_454, How many items are in the queue?\\n\\n @return int\\n,Dohvati broj elemenata u redu.,    public function count()    {        return count($this->items);    },0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_456, Extract a node from the inner queue and sift up\\n\\n @return mixed\\n,Izdvoji čvor iz unutrašnjeg reda i prosej ga.,    public function extract()    {        $value = $this->getQueue()->extract();        $keyToRemove = null;        $highestPriority = null;        foreach ($this->items as $key => $item) {            if ($item['data'] !== $value) {                continue;            }            if (null === $highestPriority) {                $highestPriority = $item['priority'];                $keyToRemove = $key;                continue;            }            if ($highestPriority >= $item['priority']) {                continue;            }            $highestPriority = $item['priority'];            $keyToRemove = $key;        }        if ($keyToRemove !== null) {            unset($this->items[$keyToRemove]);        }        return $value;    },0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_459, Unserialize a string into a PriorityQueue object\\n\\n Serialization format is compatible with {@link Laminas\\\\Stdlib\\\\SplPriorityQueue}\\n\\n @param  string $data\\n @return void\\n,Deserializuj string u objekat prioritetnog reda.,"    public function unserialize($data)    {        foreach (unserialize($data) as $item) {            $this->insert($item['data'], $item['priority']);        }    }",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_RegisterEventListenersAndSubscribersPass_1848," Finds and orders all service tags with the given name by their priority.\n\n The order of additions must be respected for services having the same priority,\n and knowing that the \\SplPriorityQueue class does not respect the FIFO method,\n we should not use this class.\n\n @see https://bugs.php.net/53710\n @see https://bugs.php.net/60926\n",Pronađi i uredi sve servisne oznake sa datim imenom prema prioritetu. Redosled dodavanja mora se poštovati za usluge koje imaju isti prioritet.,"    private function findAndSortTags(array $tagNames, ContainerBuilder $container): array    {        $sortedTags = [];        foreach ($tagNames as $tagName) {            foreach ($container->findTaggedServiceIds($tagName, true) as $serviceId => $tags) {                foreach ($tags as $attributes) {                    $priority = $attributes['priority'] ?? 0;                    $sortedTags[$priority][] = [$tagName, $serviceId, $attributes];                }            }        }        if ($sortedTags) {            krsort($sortedTags);            $sortedTags = array_merge(...$sortedTags);        }        return $sortedTags;    }",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonPeriod_314, Return the current date.\\\\n\\\\n @return CarbonInterface|null\\\\n,Dohvati trenutni datum,    public function current()    {        return $this->valid()            ? $this->prepareForReturn($this->current)            : null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonPeriod_354, Keep incrementing the current date until a valid date is found or the iteration is ended.\\n\\n @throws RuntimeException\\n\\n @return void\\n,Nastavi da uvećavaš trenutni datum dok se ne pronađe važeći datum ili se iteracija ne završi.,    protected function incrementCurrentDateUntilValid()    {        $attempts = 0;        do {            $this->current = $this->current->add($this->dateInterval);            $this->validationResult = null;            if (++$attempts > static::NEXT_MAX_ATTEMPTS) {                throw new UnreachableException('Could not find next valid date.');            }        } while ($this->validateCurrentDate() === false);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonPeriod_316, Rewind to the start date.\n\n Iterating over a date in the UTC timezone avoids bug during backward DST change.\n\n @see https://bugs.php.net/bug.php?id=72255\n @see https://bugs.php.net/bug.php?id=74274\n @see https://wiki.php.net/rfc/datetime_and_daylight_saving_time\n\n @throws RuntimeException\n\n @return void\n,"Pozicioniraj se nazad na početni datum. Korišćenjem datuma sa vremenskom zonom UTC, iteracija unazad prolazi bez greške koja bi inače nastala zbog promene u letnjem ralunanju vremena. ","    public function rewind()    {        $this->key = 0;        $this->current = ([$this->dateClass, 'make'])($this->startDate);        $settings = $this->getSettings();        if ($this->hasLocalTranslator()) {            $settings['locale'] = $this->getTranslatorLocale();        }        $this->current->settings($settings);        $this->timezone = static::intervalHasTime($this->dateInterval) ? $this->current->getTimezone() : null;        if ($this->timezone) {            $this->current = $this->current->utc();        }        $this->validationResult = null;        if ($this->isStartExcluded() || $this->validateCurrentDate() === false) {            $this->incrementCurrentDateUntilValid();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_CodeIgniterCache_571, Store an item in the cache.\\n\\n @param  string $key\\n @param  mixed $value\\n @param  \\\\DateTime|int $minutes\\n @return void\\n,Sačuvaj podatak u keš memoriji.,"    public function put($key, $value, $minutes)    {        if ($minutes instanceof \Datetime) {            $seconds = $minutes->getTimestamp() - time();        } else {            $seconds = $minutes * 60;        }        $this->cache->save($key, $value, $seconds);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonImmutable_5, Create a very far date representing end of time.\\n\\n @return static\\n,Kreiraj jako udaljen datum koji će da predstavlja kraj vremena.,    public static function endOfTime(): self    {        $date = static::parse('9999-12-31 23:59:59.999999')->years(self::getEndOfTimeYear());        $date->endOfTime = true;        return $date;    },0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1967, The GravCache object is used throughout Grav to store and retrieve cached data.\n It uses DoctrineCache library and supports a variety of caching mechanisms. Those include:\n\n APCu\n RedisCache\n MemCache\n MemCacheD\n FileSystem\n,Klasa GravCache se širom Grav-a za čuvanje i preuzimanje predmemoiranih podataka.Koristi biblioteku DoctrineCache i podržava razne vrste kašnjenja.,"class Cache extends Getters{    /** @var string Cache key. */    protected $key;    /** @var int */    protected $lifetime;    /** @var int */    protected $now;    /** @var Config $config */    protected $config;    /** @var DoctrineCache\CacheProvider */    protected $driver;    /** @var CacheInterface */    protected $simpleCache;    /** @var string */    protected $driver_name;    /** @var string */    protected $driver_setting;    /** @var bool */    protected $enabled;    /** @var string */    protected $cache_dir;    protected static $standard_remove = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'cache://images',        'asset://',    ];    protected static $standard_remove_no_images = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'asset://',    ];    protected static $all_remove = [        'cache://',        'cache://images',        'asset://',        'tmp://'    ];    protected static $assets_remove = [        'asset://'    ];    protected static $images_remove = [        'cache://images'    ];    protected static $cache_remove = [        'cache://'    ];    protected static $tmp_remove = [        'tmp://'    ];    /**     * Constructor     *     * @param Grav $grav     */    public function __construct(Grav $grav)    {        $this->init($grav);    }    /**     * Initialization that sets a base key and the driver based on configuration settings     *     * @param  Grav $grav     * @return void     */    public function init(Grav $grav)    {        $this->config = $grav['config'];        $this->now = time();        if (null === $this->enabled) {            $this->enabled = (bool)$this->config->get('system.cache.enabled');        }        /** @var Uri $uri */        $uri = $grav['uri'];        $prefix = $this->config->get('system.cache.prefix');        $uniqueness = substr(md5($uri->rootUrl(true) . $this->config->key() . GRAV_VERSION), 2, 8);        // Cache key allows us to invalidate all cache on configuration changes.        $this->key = ($prefix ? $prefix : 'g') . '-' . $uniqueness;        $this->cache_dir = $grav['locator']->findResource('cache://doctrine/' . $uniqueness, true, true);        $this->driver_setting = $this->config->get('system.cache.driver');        $this->driver = $this->getCacheDriver();        $this->driver->setNamespace($this->key);        /** @var EventDispatcher $dispatcher */        $dispatcher = Grav::instance()['events'];        $dispatcher->addListener('onSchedulerInitialized', [$this, 'onSchedulerInitialized']);    }    /**     * @return CacheInterface     */    public function getSimpleCache()    {        if (null === $this->simpleCache) {            $cache = new \Grav\Framework\Cache\Adapter\DoctrineCache($this->driver, '', $this->getLifetime());            // Disable cache key validation.            $cache->setValidation(false);            $this->simpleCache = $cache;        }        return $this->simpleCache;    }    /**     * Deletes the old out of date file-based caches     *     * @return int     */    public function purgeOldCache()    {        $cache_dir = dirname($this->cache_dir);        $current = basename($this->cache_dir);        $count = 0;        foreach (new DirectoryIterator($cache_dir) as $file) {            $dir = $file->getBasename();            if ($dir === $current || $file->isDot() || $file->isFile()) {                continue;            }            Folder::delete($file->getPathname());            $count++;        }        return $count;    }    /**     * Public accessor to set the enabled state of the cache     *     * @param bool|int $enabled     * @return void     */    public function setEnabled($enabled)    {        $this->enabled = (bool)$enabled;    }    /**     * Returns the current enabled state     *     * @return bool     */    public function getEnabled()    {        return $this->enabled;    }    /**     * Get cache state     *     * @return string     */    public function getCacheStatus()    {        return 'Cache: [' . ($this->enabled ? 'true' : 'false') . '] Setting: [' . $this->driver_setting . '] Driver: [' . $this->driver_name . ']';    }    /**     * Automatically picks the cache mechanism to use.  If you pick one manually it will use that     * If there is no config option for $driver in the config, or it's set to 'auto', it will     * pick the best option based on which cache extensions are installed.     *     * @return DoctrineCache\CacheProvider  The cache driver to use     */    public function getCacheDriver()    {        $setting = $this->driver_setting;        $driver_name = 'file';        // CLI compatibility requires a non-volatile cache driver        if ($this->config->get('system.cache.cli_compatibility') && (            $setting === 'auto' || $this->isVolatileDriver($setting))) {            $setting = $driver_name;        }        if (!$setting || $setting === 'auto') {            if (extension_loaded('apcu')) {                $driver_name = 'apcu';            } elseif (extension_loaded('wincache')) {                $driver_name = 'wincache';            }        } else {            $driver_name = $setting;        }        $this->driver_name = $driver_name;        switch ($driver_name) {            case 'apc':            case 'apcu':                $driver = new DoctrineCache\ApcuCache();                break;            case 'wincache':                $driver = new DoctrineCache\WinCacheCache();                break;            case 'memcache':                if (extension_loaded('memcache')) {                    $memcache = new \Memcache();                    $memcache->connect(                        $this->config->get('system.cache.memcache.server', 'localhost'),                        $this->config->get('system.cache.memcache.port', 11211)                    );                    $driver = new DoctrineCache\MemcacheCache();                    $driver->setMemcache($memcache);                } else {                    throw new LogicException('Memcache PHP extension has not been installed');                }                break;            case 'memcached':                if (extension_loaded('memcached')) {                    $memcached = new \Memcached();                    $memcached->addServer(                        $this->config->get('system.cache.memcached.server', 'localhost'),                        $this->config->get('system.cache.memcached.port', 11211)                    );                    $driver = new DoctrineCache\MemcachedCache();                    $driver->setMemcached($memcached);                } else {                    throw new LogicException('Memcached PHP extension has not been installed');                }                break;            case 'redis':                if (extension_loaded('redis')) {                    $redis = new \Redis();                    $socket = $this->config->get('system.cache.redis.socket', false);                    $password = $this->config->get('system.cache.redis.password', false);                    $databaseId = $this->config->get('system.cache.redis.database', 0);                    if ($socket) {                        $redis->connect($socket);                    } else {                        $redis->connect(                            $this->config->get('system.cache.redis.server', 'localhost'),                            $this->config->get('system.cache.redis.port', 6379)                        );                    }                    // Authenticate with password if set                    if ($password && !$redis->auth($password)) {                        throw new \RedisException('Redis authentication failed');                    }                    // Select alternate ( !=0 ) database ID if set                    if ($databaseId && !$redis->select($databaseId)) {                        throw new \RedisException('Could not select alternate Redis database ID');                    }                    $driver = new DoctrineCache\RedisCache();                    $driver->setRedis($redis);                } else {                    throw new LogicException('Redis PHP extension has not been installed');                }                break;            default:                $driver = new DoctrineCache\FilesystemCache($this->cache_dir);                break;        }        return $driver;    }    /**     * Gets a cached entry if it exists based on an id. If it does not exist, it returns false     *     * @param  string $id the id of the cached entry     * @return mixed|bool     returns the cached entry, can be any type, or false if doesn't exist     */    public function fetch($id)    {        if ($this->enabled) {            return $this->driver->fetch($id);        }        return false;    }    /**     * Stores a new cached entry.     *     * @param  string       $id       the id of the cached entry     * @param  array|object|int $data     the data for the cached entry to store     * @param  int|null     $lifetime the lifetime to store the entry in seconds     */    public function save($id, $data, $lifetime = null)    {        if ($this->enabled) {            if ($lifetime === null) {                $lifetime = $this->getLifetime();            }            $this->driver->save($id, $data, $lifetime);        }    }    /**     * Deletes an item in the cache based on the id     *     * @param string $id    the id of the cached data entry     * @return bool         true if the item was deleted successfully     */    public function delete($id)    {        if ($this->enabled) {            return $this->driver->delete($id);        }        return false;    }    /**     * Deletes all cache     *     * @return bool     */    public function deleteAll()    {        if ($this->enabled) {            return $this->driver->deleteAll();        }        return false;    }    /**     * Returns a boolean state of whether or not the item exists in the cache based on id key     *     * @param string $id    the id of the cached data entry     * @return bool         true if the cached items exists     */    public function contains($id)    {        if ($this->enabled) {            return $this->driver->contains(($id));        }        return false;    }    /**     * Getter method to get the cache key     *     * @return string     */    public function getKey()    {        return $this->key;    }    /**     * Setter method to set key (Advanced)     *     * @param string $key     * @return void     */    public function setKey($key)    {        $this->key = $key;        $this->driver->setNamespace($this->key);    }    /**     * Helper method to clear all Grav caches     *     * @param string $remove standard|all|assets-only|images-only|cache-only     * @return array     */    public static function clearCache($remove = 'standard')    {        $locator = Grav::instance()['locator'];        $output = [];        $user_config = USER_DIR . 'config/system.yaml';        switch ($remove) {            case 'all':                $remove_paths = self::$all_remove;                break;            case 'assets-only':                $remove_paths = self::$assets_remove;                break;            case 'images-only':                $remove_paths = self::$images_remove;                break;            case 'cache-only':                $remove_paths = self::$cache_remove;                break;            case 'tmp-only':                $remove_paths = self::$tmp_remove;                break;            case 'invalidate':                $remove_paths = [];                break;            default:                if (Grav::instance()['config']->get('system.cache.clear_images_by_default')) {                    $remove_paths = self::$standard_remove;                } else {                    $remove_paths = self::$standard_remove_no_images;                }        }        // Delete entries in the doctrine cache if required        if (in_array($remove, ['all', 'standard'])) {            $cache = Grav::instance()['cache'];            $cache->driver->deleteAll();        }        // Clearing cache event to add paths to clear        Grav::instance()->fireEvent('onBeforeCacheClear', new Event(['remove' => $remove, 'paths' => &$remove_paths]));        foreach ($remove_paths as $stream) {            // Convert stream to a real path            try {                $path = $locator->findResource($stream, true, true);                if ($path === false) {                    continue;                }                $anything = false;                $files = glob($path . '/*');                if (is_array($files)) {                    foreach ($files as $file) {                        if (is_link($file)) {                            $output[] = '<yellow>Skipping symlink:  </yellow>' . $file;                        } elseif (is_file($file)) {                            if (@unlink($file)) {                                $anything = true;                            }                        } elseif (is_dir($file)) {                            if (Folder::delete($file, false)) {                                $anything = true;                            }                        }                    }                }                if ($anything) {                    $output[] = '<red>Cleared:  </red>' . $path . '/*';                }            } catch (Exception $e) {                // stream not found or another error while deleting files.                $output[] = '<red>ERROR: </red>' . $e->getMessage();            }        }        $output[] = '';        if (($remove === 'all' || $remove === 'standard') && file_exists($user_config)) {            touch($user_config);            $output[] = '<red>Touched: </red>' . $user_config;            $output[] = '';        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }        Grav::instance()->fireEvent('onAfterCacheClear', new Event(['remove' => $remove, 'output' => &$output]));        return $output;    }    /**     * @return void     */    public static function invalidateCache()    {        $user_config = USER_DIR . 'config/system.yaml';        if (file_exists($user_config)) {            touch($user_config);        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }    }    /**     * Set the cache lifetime programmatically     *     * @param int $future timestamp     * @return void     */    public function setLifetime($future)    {        if (!$future) {            return;        }        $interval = (int)($future - $this->now);        if ($interval > 0 && $interval < $this->getLifetime()) {            $this->lifetime = $interval;        }    }    /**     * Retrieve the cache lifetime (in seconds)     *     * @return int     */    public function getLifetime()    {        if ($this->lifetime === null) {            $this->lifetime = (int)($this->config->get('system.cache.lifetime') ?: 604800); // 1 week default        }        return $this->lifetime;    }    /**     * Returns the current driver name     *     * @return string     */    public function getDriverName()    {        return $this->driver_name;    }    /**     * Returns the current driver setting     *     * @return string     */    public function getDriverSetting()    {        return $this->driver_setting;    }    /**     * is this driver a volatile driver in that it resides in PHP process memory     *     * @param string $setting     * @return bool     */    public function isVolatileDriver($setting)    {        if (in_array($setting, ['apc', 'apcu', 'xcache', 'wincache'])) {            return true;        }        return false;    }    /**     * Static function to call as a scheduled Job to purge old Doctrine files     *     * @param bool $echo     *     * @return string|void     */    public static function purgeJob($echo = false)    {        /** @var Cache $cache */        $cache = Grav::instance()['cache'];        $deleted_folders = $cache->purgeOldCache();        $msg = 'Purged ' . $deleted_folders . ' old cache folders...';        if ($echo) {            echo $msg;        } else {            return $msg;        }    }    /**     * Static function to call as a scheduled Job to clear Grav cache     *     * @param string $type     * @return void     */    public static function clearJob($type)    {        $result = static::clearCache($type);        static::invalidateCache();        echo strip_tags(implode(""\n"", $result));    }    /**     * @param Event $event     * @return void     */    public function onSchedulerInitialized(Event $event)    {        /** @var Scheduler $scheduler */        $scheduler = $event['scheduler'];        $config = Grav::instance()['config'];        // File Cache Purge        $at = $config->get('system.cache.purge_at');        $name = 'cache-purge';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::purgeJob', [true], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');        // Cache Clear        $at = $config->get('system.cache.clear_at');        $clear_type = $config->get('system.cache.clear_job_type');        $name = 'cache-clear';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::clearJob', [$clear_type], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');    }}",0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_607, Attempt to exchange a code for an valid authentication token.\\\\n Helper wrapped around the OAuth 2.0 implementation.\\\\n\\\\n @param $code string code from accounts.google.com\\\\n @return array access token\\\\n,Pokušaj razmeniti kod za važeći autentikacioni token. Omotačka pomoćna metoda implementacije OAuth2.0.,"  public function fetchAccessTokenWithAuthCode($code)  {    if (strlen($code) == 0) {      throw new InvalidArgumentException(""Invalid code"");    }    $auth = $this->getOAuth2Service();    $auth->setCode($code);    $auth->setRedirectUri($this->getRedirectUri());    $httpHandler = HttpHandlerFactory::build($this->getHttpClient());    $creds = $auth->fetchAuthToken($httpHandler);    if ($creds && isset($creds['access_token'])) {      $creds['created'] = time();      $this->setAccessToken($creds);    }    return $creds;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_BinaryFileResponse_7831, Automatically sets the Last-Modified header according the file modification date.\n,Automatski postavi datumom prilikom poslednje promene u heder poslednje-modifikovano.,"    public function setAutoLastModified()    {        $this->setLastModified(\DateTime::createFromFormat('U', $this->file->getMTime()));        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ConfigDataCollector_3168," Tries to retrieve information about the current Symfony version.\n\n @return string One of: dev, stable, eom, eol\n",Pokušaj dohvatiti informacije trenutne verzije Symphony,"    private function determineSymfonyState(): string    {        $now = new \DateTime();        $eom = \DateTime::createFromFormat('d/m/Y', '01/'.Kernel::END_OF_MAINTENANCE)->modify('last day of this month');        $eol = \DateTime::createFromFormat('d/m/Y', '01/'.Kernel::END_OF_LIFE)->modify('last day of this month');        if ($now > $eol) {            $versionState = 'eol';        } elseif ($now > $eom) {            $versionState = 'eom';        } elseif ('' !== Kernel::EXTRA_VERSION) {            $versionState = 'dev';        } else {            $versionState = 'stable';        }        return $versionState;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8034," Determines if the Response validators (ETag, Last-Modified) match\n a conditional value specified in the Request.\n\n If the Response is not modified, it sets the status code to 304 and\n removes the actual content by calling the setNotModified() method.\n\n @return bool true if the Response validators match the Request, false otherwise\n\n @final\n","Utvrdi da li se validatori odgovora(ETag, last-modified) podudaraju sa uslovnom vrednošću navedenom u zahtevu. Ako odgovor nije modifikovan postavi statusni kod na 304 i ukloni stvarni sadržaj pozivanjem metode setNotModified().","    public function isNotModified(Request $request): bool    {        if (!$request->isMethodCacheable()) {            return false;        }        $notModified = false;        $lastModified = $this->headers->get('Last-Modified');        $modifiedSince = $request->headers->get('If-Modified-Since');        if ($etags = $request->getETags()) {            $notModified = \in_array($this->getEtag(), $etags) || \in_array('*', $etags);        }        if ($modifiedSince && $lastModified) {            $notModified = strtotime($modifiedSince) >= strtotime($lastModified) && (!$etags || $notModified);        }        if ($notModified) {            $this->setNotModified();        }        return $notModified;    }",0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_LaravelDebugbar_111, Collects the data from the collectors\n\n @return array\n,Sakupi podatke iz kolekcije.,"    public function collect()    {        /** @var Request $request */        $request = $this->app['request'];        $this->data = [            '__meta' => [                'id' => $this->getCurrentRequestId(),                'datetime' => date('Y-m-d H:i:s'),                'utime' => microtime(true),                'method' => $request->getMethod(),                'uri' => $request->getRequestUri(),                'ip' => $request->getClientIp()            ]        ];        foreach ($this->collectors as $name => $collector) {            $this->data[$name] = $collector->collect();        }        // Remove all invalid (non UTF-8) characters        array_walk_recursive(            $this->data,            function (&$item) {                if (is_string($item) && !mb_check_encoding($item, 'UTF-8')) {                    $item = mb_convert_encoding($item, 'UTF-8', 'UTF-8');                }            }        );        if ($this->storage !== null) {            $this->storage->save($this->getCurrentRequestId(), $this->data);        }        return $this->data;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_MessageFormatter_20," Formats log messages using variable substitutions for requests, responses,\\n and other transactional data.\\n\\n The following variable substitutions are supported:\\n\\n - {request}:        Full HTTP request message\\n - {response}:       Full HTTP response message\\n - {ts}:             ISO 8601 date in GMT\\n - {date_iso_8601}   ISO 8601 date in GMT\\n - {date_common_log} Apache common log date using the configured timezone.\\n - {host}:           Host of the request\\n - {method}:         Method of the request\\n - {uri}:            URI of the request\\n - {version}:        Protocol version\\n - {target}:         Request target of the request (path + query + fragment)\\n - {hostname}:       Hostname of the machine that sent the request\\n - {code}:           Status code of the response (if available)\\n - {phrase}:         Reason phrase of the response  (if available)\\n - {error}:          Any error messages (if available)\\n - {req_header_ - {res_header_ - {req_headers}:    Request headers\\n - {res_headers}:    Response headers\\n - {req_body}:       Request body\\n - {res_body}:       Response body\\n\\n @final\\n","Formatiraj poruke dnevnika koristeći promeljive zamene u zahtevima, odgovorima i druge podatke transakcije.","class MessageFormatter implements MessageFormatterInterface{    /**     * Apache Common Log Format.     *     * @link https://httpd.apache.org/docs/2.4/logs.html#common     *     * @var string     */    public const CLF = ""{hostname} {req_header_User-Agent} - [{date_common_log}] \""{method} {target} HTTP/{version}\"" {code} {res_header_Content-Length}"";    public const DEBUG = "">>>>>>>>\n{request}\n<<<<<<<<\n{response}\n--------\n{error}"";    public const SHORT = '[{ts}] ""{method} {target} HTTP/{version}"" {code}';    /**     * @var string Template used to format log messages     */    private $template;    /**     * @param string $template Log message template     */    public function __construct(?string $template = self::CLF)    {        $this->template = $template ?: self::CLF;    }    /**     * Returns a formatted message string.     *     * @param RequestInterface       $request  Request that was sent     * @param ResponseInterface|null $response Response that was received     * @param \Throwable|null        $error    Exception that was received     */    public function format(RequestInterface $request, ?ResponseInterface $response = null, ?\Throwable $error = null): string    {        $cache = [];        /** @var string */        return \preg_replace_callback(            '/{\s*([A-Za-z_\-\.0-9]+)\s*}/',            function (array $matches) use ($request, $response, $error, &$cache) {                if (isset($cache[$matches[1]])) {                    return $cache[$matches[1]];                }                $result = '';                switch ($matches[1]) {                    case 'request':                        $result = Psr7\Message::toString($request);                        break;                    case 'response':                        $result = $response ? Psr7\Message::toString($response) : '';                        break;                    case 'req_headers':                        $result = \trim($request->getMethod()                                . ' ' . $request->getRequestTarget())                            . ' HTTP/' . $request->getProtocolVersion() . ""\r\n""                            . $this->headers($request);                        break;                    case 'res_headers':                        $result = $response ?                            \sprintf(                                'HTTP/%s %d %s',                                $response->getProtocolVersion(),                                $response->getStatusCode(),                                $response->getReasonPhrase()                            ) . ""\r\n"" . $this->headers($response)                            : 'NULL';                        break;                    case 'req_body':                        $result = $request->getBody()->__toString();                        break;                    case 'res_body':                        if (!$response instanceof ResponseInterface) {                            $result = 'NULL';                            break;                        }                        $body = $response->getBody();                        if (!$body->isSeekable()) {                            $result = 'RESPONSE_NOT_LOGGEABLE';                            break;                        }                        $result = $response->getBody()->__toString();                        break;                    case 'ts':                    case 'date_iso_8601':                        $result = \gmdate('c');                        break;                    case 'date_common_log':                        $result = \date('d/M/Y:H:i:s O');                        break;                    case 'method':                        $result = $request->getMethod();                        break;                    case 'version':                        $result = $request->getProtocolVersion();                        break;                    case 'uri':                    case 'url':                        $result = $request->getUri();                        break;                    case 'target':                        $result = $request->getRequestTarget();                        break;                    case 'req_version':                        $result = $request->getProtocolVersion();                        break;                    case 'res_version':                        $result = $response                            ? $response->getProtocolVersion()                            : 'NULL';                        break;                    case 'host':                        $result = $request->getHeaderLine('Host');                        break;                    case 'hostname':                        $result = \gethostname();                        break;                    case 'code':                        $result = $response ? $response->getStatusCode() : 'NULL';                        break;                    case 'phrase':                        $result = $response ? $response->getReasonPhrase() : 'NULL';                        break;                    case 'error':                        $result = $error ? $error->getMessage() : 'NULL';                        break;                    default:                        // handle prefixed dynamic headers                        if (\strpos($matches[1], 'req_header_') === 0) {                            $result = $request->getHeaderLine(\substr($matches[1], 11));                        } elseif (\strpos($matches[1], 'res_header_') === 0) {                            $result = $response                                ? $response->getHeaderLine(\substr($matches[1], 11))                                : 'NULL';                        }                }                $cache[$matches[1]] = $result;                return $result;            },            $this->template        );    }    /**     * Get headers from message as string     */    private function headers(MessageInterface $message): string    {        $result = '';        foreach ($message->getHeaders() as $name => $values) {            $result .= $name . ': ' . \implode(', ', $values) . ""\r\n"";        }        return \trim($result);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0
getgrav_grav_Debugger_1159, Initialize the debugger\n\n @return $this\n @throws DebugBarException\n,Inicijalizuj objekat klase debager.,"    public function init()    {        if ($this->initialized) {            return $this;        }        $this->grav = Grav::instance();        $this->config = $this->grav['config'];        // Enable/disable debugger based on configuration.        $this->enabled = (bool)$this->config->get('system.debugger.enabled');        $this->censored = (bool)$this->config->get('system.debugger.censored', false);        if ($this->enabled) {            $this->initialized = true;            $clockwork = $debugbar = null;            switch ($this->config->get('system.debugger.provider', 'debugbar')) {                case 'clockwork':                    $this->clockwork = $clockwork = new Clockwork();                    break;                default:                    $this->debugbar = $debugbar = new DebugBar();            }            $plugins_config = (array)$this->config->get('plugins');            ksort($plugins_config);            if ($clockwork) {                $log = $this->grav['log'];                $clockwork->setStorage(new FileStorage('cache://clockwork'));                if (extension_loaded('xdebug')) {                    $clockwork->addDataSource(new XdebugDataSource());                }                if ($log instanceof Logger) {                    $clockwork->addDataSource(new MonologDataSource($log));                }                $timeline = $clockwork->timeline();                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Server');                    $event->finalize($this->requestTime, GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Loading');                    $event->finalize(GRAV_REQUEST_TIME, $this->currentTime);                }                $event = $timeline->event('Site Setup');                $event->finalize($this->currentTime, microtime(true));            }            if ($this->censored) {                $censored = ['CENSORED' => true];            }            if ($debugbar) {                $debugbar->addCollector(new PhpInfoCollector());                $debugbar->addCollector(new MessagesCollector());                if (!$this->censored) {                    $debugbar->addCollector(new RequestDataCollector());                }                $debugbar->addCollector(new TimeDataCollector($this->requestTime));                $debugbar->addCollector(new MemoryCollector());                $debugbar->addCollector(new ExceptionsCollector());                $debugbar->addCollector(new ConfigCollector($censored ?? (array)$this->config->get('system'), 'Config'));                $debugbar->addCollector(new ConfigCollector($censored ?? $plugins_config, 'Plugins'));                $debugbar->addCollector(new ConfigCollector($this->config->get('streams.schemes'), 'Streams'));                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Server', $debugbar['time']->getRequestStartTime(), GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Loading', GRAV_REQUEST_TIME, $this->currentTime);                }                $debugbar['time']->addMeasure('Site Setup', $this->currentTime, microtime(true));            }            $this->addMessage('Grav v' . GRAV_VERSION . ' - PHP ' . PHP_VERSION);            $this->config->debug();            if ($clockwork) {                $clockwork->info('System Configuration', $censored ?? $this->config->get('system'));                $clockwork->info('Plugins Configuration', $censored ?? $plugins_config);                $clockwork->info('Streams', $this->config->get('streams.schemes'));            }        }        return $this;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_1156, Class Debugger\\n @package Grav\\\\Common\\n,Klasa debager,"class Debugger{    /** @var static */    protected static $instance;    /** @var Grav|null */    protected $grav;    /** @var Config|null */    protected $config;    /** @var JavascriptRenderer|null */    protected $renderer;    /** @var DebugBar|null */    protected $debugbar;    /** @var Clockwork|null */    protected $clockwork;    /** @var bool */    protected $enabled = false;    /** @var bool */    protected $initialized = false;    /** @var array */    protected $timers = [];    /** @var array */    protected $deprecations = [];    /** @var callable|null */    protected $errorHandler;    /** @var float */    protected $requestTime;    /** @var float */    protected $currentTime;    /** @var int */    protected $profiling = 0;    /** @var bool */    protected $censored = false;    /**     * Debugger constructor.     */    public function __construct()    {        static::$instance = $this;        $this->currentTime = microtime(true);        if (!defined('GRAV_REQUEST_TIME')) {            define('GRAV_REQUEST_TIME', $this->currentTime);        }        $this->requestTime = $_SERVER['REQUEST_TIME_FLOAT'] ?? GRAV_REQUEST_TIME;        // Set deprecation collector.        $this->setErrorHandler();    }    /**     * @return Clockwork|null     */    public function getClockwork(): ?Clockwork    {        return $this->enabled ? $this->clockwork : null;    }    /**     * Initialize the debugger     *     * @return $this     * @throws DebugBarException     */    public function init()    {        if ($this->initialized) {            return $this;        }        $this->grav = Grav::instance();        $this->config = $this->grav['config'];        // Enable/disable debugger based on configuration.        $this->enabled = (bool)$this->config->get('system.debugger.enabled');        $this->censored = (bool)$this->config->get('system.debugger.censored', false);        if ($this->enabled) {            $this->initialized = true;            $clockwork = $debugbar = null;            switch ($this->config->get('system.debugger.provider', 'debugbar')) {                case 'clockwork':                    $this->clockwork = $clockwork = new Clockwork();                    break;                default:                    $this->debugbar = $debugbar = new DebugBar();            }            $plugins_config = (array)$this->config->get('plugins');            ksort($plugins_config);            if ($clockwork) {                $log = $this->grav['log'];                $clockwork->setStorage(new FileStorage('cache://clockwork'));                if (extension_loaded('xdebug')) {                    $clockwork->addDataSource(new XdebugDataSource());                }                if ($log instanceof Logger) {                    $clockwork->addDataSource(new MonologDataSource($log));                }                $timeline = $clockwork->timeline();                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Server');                    $event->finalize($this->requestTime, GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Loading');                    $event->finalize(GRAV_REQUEST_TIME, $this->currentTime);                }                $event = $timeline->event('Site Setup');                $event->finalize($this->currentTime, microtime(true));            }            if ($this->censored) {                $censored = ['CENSORED' => true];            }            if ($debugbar) {                $debugbar->addCollector(new PhpInfoCollector());                $debugbar->addCollector(new MessagesCollector());                if (!$this->censored) {                    $debugbar->addCollector(new RequestDataCollector());                }                $debugbar->addCollector(new TimeDataCollector($this->requestTime));                $debugbar->addCollector(new MemoryCollector());                $debugbar->addCollector(new ExceptionsCollector());                $debugbar->addCollector(new ConfigCollector($censored ?? (array)$this->config->get('system'), 'Config'));                $debugbar->addCollector(new ConfigCollector($censored ?? $plugins_config, 'Plugins'));                $debugbar->addCollector(new ConfigCollector($this->config->get('streams.schemes'), 'Streams'));                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Server', $debugbar['time']->getRequestStartTime(), GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Loading', GRAV_REQUEST_TIME, $this->currentTime);                }                $debugbar['time']->addMeasure('Site Setup', $this->currentTime, microtime(true));            }            $this->addMessage('Grav v' . GRAV_VERSION . ' - PHP ' . PHP_VERSION);            $this->config->debug();            if ($clockwork) {                $clockwork->info('System Configuration', $censored ?? $this->config->get('system'));                $clockwork->info('Plugins Configuration', $censored ?? $plugins_config);                $clockwork->info('Streams', $this->config->get('streams.schemes'));            }        }        return $this;    }    public function finalize(): void    {        if ($this->clockwork && $this->enabled) {            $this->stopProfiling('Profiler Analysis');            $this->addMeasures();            $deprecations = $this->getDeprecations();            $count = count($deprecations);            if (!$count) {                return;            }            /** @var UserData $userData */            $userData = $this->clockwork->userData('Deprecated');            $userData->counters([                'Deprecated' => count($deprecations)            ]);            /*            foreach ($deprecations as &$deprecation) {                $d = $deprecation;                unset($d['message']);                $this->clockwork->log('deprecated', $deprecation['message'], $d);            }            unset($deprecation);             */            $userData->table('Your site is using following deprecated features', $deprecations);        }    }    public function logRequest(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface    {        if (!$this->enabled || !$this->clockwork) {            return $response;        }        $clockwork = $this->clockwork;        $this->finalize();        $clockwork->timeline()->finalize($request->getAttribute('request_time'));        if ($this->censored) {            $censored = 'CENSORED';            $request = $request                ->withCookieParams([$censored => ''])                ->withUploadedFiles([])                ->withHeader('cookie', $censored);            $request = $request->withParsedBody([$censored => '']);        }        $clockwork->addDataSource(new PsrMessageDataSource($request, $response));        $clockwork->resolveRequest();        $clockwork->storeRequest();        $clockworkRequest = $clockwork->getRequest();        $response = $response            ->withHeader('X-Clockwork-Id', $clockworkRequest->id)            ->withHeader('X-Clockwork-Version', $clockwork::VERSION);        $grav = Grav::instance();        $basePath = $this->grav['base_url_relative'] . $grav['pages']->base();        if ($basePath) {            $response = $response->withHeader('X-Clockwork-Path', $basePath . '/__clockwork/');        }        return $response->withHeader('Server-Timing', ServerTiming::fromRequest($clockworkRequest)->value());    }    public function debuggerRequest(RequestInterface $request): Response    {        $clockwork = $this->clockwork;        $headers = [            'Content-Type' => 'application/json',            'Grav-Internal-SkipShutdown' => 1        ];        $path = $request->getUri()->getPath();        $clockworkDataUri = '#/__clockwork(?:/(?<id>[0-9-]+))?(?:/(?<direction>(?:previous|next)))?(?:/(?<count>\d+))?#';        if (preg_match($clockworkDataUri, $path, $matches) === false) {            $response = ['message' => 'Bad Input'];            return new Response(400, $headers, json_encode($response));        }        $id = $matches['id'] ?? null;        $direction = $matches['direction'] ?? null;        $count = $matches['count'] ?? null;        $storage = $clockwork->getStorage();        if ($direction === 'previous') {            $data = $storage->previous($id, $count);        } elseif ($direction === 'next') {            $data = $storage->next($id, $count);        } elseif ($id === 'latest') {            $data = $storage->latest();        } else {            $data = $storage->find($id);        }        if (preg_match('#(?<id>[0-9-]+|latest)/extended#', $path)) {            $clockwork->extendRequest($data);        }        if (!$data) {            $response = ['message' => 'Not Found'];            return new Response(404, $headers, json_encode($response));        }        $data = is_array($data) ? array_map(function ($item) {            return $item->toArray();        }, $data) : $data->toArray();        return new Response(200, $headers, json_encode($data));    }    /**     * @return void     */    protected function addMeasures(): void    {        if (!$this->enabled) {            return;        }        $nowTime = microtime(true);        $clkTimeLine = $this->clockwork ? $this->clockwork->timeline() : null;        $debTimeLine = $this->debugbar ? $this->debugbar['time'] : null;        foreach ($this->timers as $name => $data) {            $description = $data[0];            $startTime = $data[1] ?? null;            $endTime = $data[2] ?? $nowTime;            if ($clkTimeLine) {                $event = $clkTimeLine->event($description);                $event->finalize($startTime, $endTime);            } elseif ($debTimeLine) {                if ($endTime - $startTime < 0.001) {                    continue;                }                $debTimeLine->addMeasure($description ?? $name, $startTime, $endTime);            }        }        $this->timers = [];    }    /**     * Set/get the enabled state of the debugger     *     * @param bool|null $state If null, the method returns the enabled value. If set, the method sets the enabled state     * @return bool     */    public function enabled($state = null)    {        if ($state !== null) {            $this->enabled = (bool)$state;        }        return $this->enabled;    }    /**     * Add the debugger assets to the Grav Assets     *     * @return $this     */    public function addAssets()    {        if ($this->enabled) {            // Only add assets if Page is HTML            $page = $this->grav['page'];            if ($page->templateFormat() !== 'html') {                return $this;            }            /** @var Assets $assets */            $assets = $this->grav['assets'];            // Clockwork specific assets            if ($this->clockwork) {                $assets->addCss('/system/assets/debugger/clockwork.css', ['loading' => 'inline']);                $assets->addJs('/system/assets/debugger/clockwork.js', ['loading' => 'inline']);            }            // Debugbar specific assets            if ($this->debugbar) {                // Add jquery library                $assets->add('jquery', 101);                $this->renderer = $this->debugbar->getJavascriptRenderer();                $this->renderer->setIncludeVendors(false);                [$css_files, $js_files] = $this->renderer->getAssets(null, JavascriptRenderer::RELATIVE_URL);                foreach ((array)$css_files as $css) {                    $assets->addCss($css);                }                $assets->addCss('/system/assets/debugger/phpdebugbar.css', ['loading' => 'inline']);                foreach ((array)$js_files as $js) {                    $assets->addJs($js);                }            }        }        return $this;    }    /**     * @param int $limit     * @return array     */    public function getCaller($limit = 2)    {        $trace = debug_backtrace(false, $limit);        return array_pop($trace);    }    /**     * Adds a data collector     *     * @param DataCollectorInterface $collector     * @return $this     * @throws DebugBarException     */    public function addCollector($collector)    {        if ($this->debugbar && !$this->debugbar->hasCollector($collector->getName())) {            $this->debugbar->addCollector($collector);        }        return $this;    }    /**     * Returns a data collector     *     * @param string $name     * @return DataCollectorInterface|null     * @throws DebugBarException     */    public function getCollector($name)    {        if ($this->debugbar && $this->debugbar->hasCollector($name)) {            return $this->debugbar->getCollector($name);        }        return null;    }    /**     * Displays the debug bar     *     * @return $this     */    public function render()    {        if ($this->enabled && $this->debugbar) {            // Only add assets if Page is HTML            $page = $this->grav['page'];            if (!$this->renderer || $page->templateFormat() !== 'html') {                return $this;            }            $this->addMeasures();            $this->addDeprecations();            echo $this->renderer->render();        }        return $this;    }    /**     * Sends the data through the HTTP headers     *     * @return $this     */    public function sendDataInHeaders()    {        if ($this->enabled && $this->debugbar) {            $this->addMeasures();            $this->addDeprecations();            $this->debugbar->sendDataInHeaders();        }        return $this;    }    /**     * Returns collected debugger data.     *     * @return array|null     */    public function getData()    {        if (!$this->enabled || !$this->debugbar) {            return null;        }        $this->addMeasures();        $this->addDeprecations();        $this->timers = [];        return $this->debugbar->getData();    }    /**     * Hierarchical Profiler support.     *     * @param callable $callable     * @param string|null $message     * @return mixed     */    public function profile(callable $callable, string $message = null)    {        $this->startProfiling();        $response = $callable();        $this->stopProfiling($message);        return $response;    }    public function addTwigProfiler(Environment $twig): void    {        $clockwork = $this->getClockwork();        if ($clockwork) {            $source = new TwigClockworkDataSource($twig);            $source->listenToEvents();            $clockwork->addDataSource($source);        }    }    /**     * Start profiling code.     *     * @return void     */    public function startProfiling(): void    {        if ($this->enabled && extension_loaded('tideways_xhprof')) {            $this->profiling++;            if ($this->profiling === 1) {                // @phpstan-ignore-next-line                \tideways_xhprof_enable(TIDEWAYS_XHPROF_FLAGS_NO_BUILTINS);            }        }    }    /**     * Stop profiling code. Returns profiling array or null if profiling couldn't be done.     *     * @param string|null $message     * @return array|null     */    public function stopProfiling(string $message = null): ?array    {        $timings = null;        if ($this->enabled && extension_loaded('tideways_xhprof')) {            $profiling = $this->profiling - 1;            if ($profiling === 0) {                // @phpstan-ignore-next-line                $timings = \tideways_xhprof_disable();                $timings = $this->buildProfilerTimings($timings);                if ($this->clockwork) {                    /** @var UserData $userData */                    $userData = $this->clockwork->userData('Profiler');                    $userData->counters([                        'Calls' => count($timings)                    ]);                    $userData->table('Profiler', $timings);                } else {                    $this->addMessage($message ?? 'Profiler Analysis', 'debug', $timings);                }            }            $this->profiling = max(0, $profiling);        }        return $timings;    }    /**     * @param array $timings     * @return array     */    protected function buildProfilerTimings(array $timings): array    {        // Filter method calls which take almost no time.        $timings = array_filter($timings, function ($value) {            return $value['wt'] > 50;        });        uasort($timings, function (array $a, array $b) {            return $b['wt'] <=> $a['wt'];        });        $table = [];        foreach ($timings as $key => $timing) {            $parts = explode('==>', $key);            $method = $this->parseProfilerCall(array_pop($parts));            $context = $this->parseProfilerCall(array_pop($parts));            // Skip redundant method calls.            if ($context === 'Grav\Framework\RequestHandler\RequestHandler::handle()') {                continue;            }            // Do not profile library calls.            if (strpos($context, 'Grav\\') !== 0) {                continue;            }            $table[] = [                'Context' => $context,                'Method' => $method,                'Calls' => $timing['ct'],                'Time (ms)' => $timing['wt'] / 1000,            ];        }        return $table;    }    /**     * @param string|null $call     * @return mixed|string|null     */    protected function parseProfilerCall(?string $call)    {        if (null === $call) {            return '';        }        if (strpos($call, '@')) {            [$call,] = explode('@', $call);        }        if (strpos($call, '::')) {            [$class, $call] = explode('::', $call);        }        if (!isset($class)) {            return $call;        }        // It is also possible to display twig files, but they are being logged in views.        /*        if (strpos($class, '__TwigTemplate_') === 0 && class_exists($class)) {            $env = new Environment();            / ** @var Template $template * /            $template = new $class($env);            return $template->getTemplateName();        }        */        return ""{$class}::{$call}()"";    }    /**     * Start a timer with an associated name and description     *     * @param string      $name     * @param string|null $description     * @return $this     */    public function startTimer($name, $description = null)    {        $this->timers[$name] = [$description, microtime(true)];        return $this;    }    /**     * Stop the named timer     *     * @param string $name     * @return $this     */    public function stopTimer($name)    {        if (isset($this->timers[$name])) {            $endTime = microtime(true);            $this->timers[$name][] = $endTime;        }        return $this;    }    /**     * Dump variables into the Messages tab of the Debug Bar     *     * @param mixed  $message     * @param string $label     * @param mixed|bool $isString     * @return $this     */    public function addMessage($message, $label = 'info', $isString = true)    {        if ($this->enabled) {            if ($this->censored) {                if (!is_scalar($message)) {                    $message = 'CENSORED';                }                if (!is_scalar($isString)) {                    $isString = ['CENSORED'];                }            }            if ($this->debugbar) {                if (is_array($isString)) {                    $message = $isString;                    $isString = false;                } elseif (is_string($isString)) {                    $message = $isString;                    $isString = true;                }                $this->debugbar['messages']->addMessage($message, $label, $isString);            }            if ($this->clockwork) {                $context = $isString;                if (!is_scalar($message)) {                    $context = $message;                    $message = gettype($context);                }                if (is_bool($context)) {                    $context = [];                } elseif (!is_array($context)) {                    $type = gettype($context);                    $context = [$type => $context];                }                $this->clockwork->log($label, $message, $context);            }        }        return $this;    }    /**     * @param string $name     * @param object $event     * @param EventDispatcherInterface $dispatcher     * @param float|null $time     * @return $this     */    public function addEvent(string $name, $event, EventDispatcherInterface $dispatcher, float $time = null)    {        if ($this->enabled && $this->clockwork) {            $time = $time ?? microtime(true);            $duration = (microtime(true) - $time) * 1000;            $data = null;            if ($event && method_exists($event, '__debugInfo')) {                $data = $event;            }            $listeners = [];            foreach ($dispatcher->getListeners($name) as $listener) {                $listeners[] = $this->resolveCallable($listener);            }            $this->clockwork->addEvent($name, $data, $time, ['listeners' => $listeners, 'duration' => $duration]);        }        return $this;    }    /**     * Dump exception into the Messages tab of the Debug Bar     *     * @param Throwable $e     * @return Debugger     */    public function addException(Throwable $e)    {        if ($this->initialized && $this->enabled) {            if ($this->debugbar) {                $this->debugbar['exceptions']->addThrowable($e);            }            if ($this->clockwork) {                /** @var UserData $exceptions */                $exceptions = $this->clockwork->userData('Exceptions');                $exceptions->data(['message' => $e->getMessage()]);                $this->clockwork->alert($e->getMessage(), ['exception' => $e]);            }        }        return $this;    }    /**     * @return void     */    public function setErrorHandler()    {        $this->errorHandler = set_error_handler(            [$this, 'deprecatedErrorHandler']        );    }    /**     * @param int $errno     * @param string $errstr     * @param string $errfile     * @param int $errline     * @return bool     */    public function deprecatedErrorHandler($errno, $errstr, $errfile, $errline)    {        if ($errno !== E_USER_DEPRECATED && $errno !== E_DEPRECATED) {            if ($this->errorHandler) {                return call_user_func($this->errorHandler, $errno, $errstr, $errfile, $errline);            }            return true;        }        if (!$this->enabled) {            return true;        }        // Figure out error scope from the error.        $scope = 'unknown';        if (stripos($errstr, 'grav') !== false) {            $scope = 'grav';        } elseif (strpos($errfile, '/twig/') !== false) {            $scope = 'twig';        } elseif (stripos($errfile, '/yaml/') !== false) {            $scope = 'yaml';        } elseif (strpos($errfile, '/vendor/') !== false) {            $scope = 'vendor';        }        // Clean up backtrace to make it more useful.        $backtrace = debug_backtrace(DEBUG_BACKTRACE_PROVIDE_OBJECT);        // Skip current call.        array_shift($backtrace);        // Find yaml file where the error happened.        if ($scope === 'yaml') {            foreach ($backtrace as $current) {                if (isset($current['args'])) {                    foreach ($current['args'] as $arg) {                        if ($arg instanceof SplFileInfo) {                            $arg = $arg->getPathname();                        }                        if (is_string($arg) && preg_match('/.+\.(yaml|md)$/i', $arg)) {                            $errfile = $arg;                            $errline = 0;                            break 2;                        }                    }                }            }        }        // Filter arguments.        $cut = 0;        $previous = null;        foreach ($backtrace as $i => &$current) {            if (isset($current['args'])) {                $args = [];                foreach ($current['args'] as $arg) {                    if (is_string($arg)) {                        $arg = ""'"" . $arg . ""'"";                        if (mb_strlen($arg) > 100) {                            $arg = 'string';                        }                    } elseif (is_bool($arg)) {                        $arg = $arg ? 'true' : 'false';                    } elseif (is_scalar($arg)) {                        $arg = $arg;                    } elseif (is_object($arg)) {                        $arg = get_class($arg) . ' $object';                    } elseif (is_array($arg)) {                        $arg = '$array';                    } else {                        $arg = '$object';                    }                    $args[] = $arg;                }                $current['args'] = $args;            }            $object = $current['object'] ?? null;            unset($current['object']);            $reflection = null;            if ($object instanceof TemplateWrapper) {                $reflection = new ReflectionObject($object);                $property = $reflection->getProperty('template');                $property->setAccessible(true);                $object = $property->getValue($object);            }            if ($object instanceof Template) {                $file = $current['file'] ?? null;                if (preg_match('`(Template.php|TemplateWrapper.php)$`', $file)) {                    $current = null;                    continue;                }                $debugInfo = $object->getDebugInfo();                $line = 1;                if (!$reflection) {                    foreach ($debugInfo as $codeLine => $templateLine) {                        if ($codeLine <= $current['line']) {                            $line = $templateLine;                            break;                        }                    }                }                $src = $object->getSourceContext();                //$code = preg_split('/\r\n|\r|\n/', $src->getCode());                //$current['twig']['twig'] = trim($code[$line - 1]);                $current['twig']['file'] = $src->getPath();                $current['twig']['line'] = $line;                $prevFile = $previous['file'] ?? null;                if ($prevFile && $file === $prevFile) {                    $prevLine = $previous['line'];                    $line = 1;                    foreach ($debugInfo as $codeLine => $templateLine) {                        if ($codeLine <= $prevLine) {                            $line = $templateLine;                            break;                        }                    }                    //$previous['twig']['twig'] = trim($code[$line - 1]);                    $previous['twig']['file'] = $src->getPath();                    $previous['twig']['line'] = $line;                }                $cut = $i;            } elseif ($object instanceof ProcessorInterface) {                $cut = $cut ?: $i;                break;            }            $previous = &$backtrace[$i];        }        unset($current);        if ($cut) {            $backtrace = array_slice($backtrace, 0, $cut + 1);        }        $backtrace = array_values(array_filter($backtrace));        // Skip vendor libraries and the method where error was triggered.        foreach ($backtrace as $i => $current) {            if (!isset($current['file'])) {                continue;            }            if (strpos($current['file'], '/vendor/') !== false) {                $cut = $i + 1;                continue;            }            if (isset($current['function']) && ($current['function'] === 'user_error' || $current['function'] === 'trigger_error')) {                $cut = $i + 1;                continue;            }            break;        }        if ($cut) {            $backtrace = array_slice($backtrace, $cut);        }        $backtrace = array_values(array_filter($backtrace));        $current = reset($backtrace);        // If the issue happened inside twig file, change the file and line to match that file.        $file = $current['twig']['file'] ?? '';        if ($file) {            $errfile = $file;            $errline = $current['twig']['line'] ?? 0;        }        $deprecation = [            'scope' => $scope,            'message' => $errstr,            'file' => $errfile,            'line' => $errline,            'trace' => $backtrace,            'count' => 1        ];        $this->deprecations[] = $deprecation;        // Do not pass forward.        return true;    }    /**     * @return array     */    protected function getDeprecations(): array    {        if (!$this->deprecations) {            return [];        }        $list = [];        /** @var array $deprecated */        foreach ($this->deprecations as $deprecated) {            $list[] = $this->getDepracatedMessage($deprecated)[0];        }        return $list;    }    /**     * @return void     * @throws DebugBarException     */    protected function addDeprecations()    {        if (!$this->deprecations) {            return;        }        $collector = new MessagesCollector('deprecated');        $this->addCollector($collector);        $collector->addMessage('Your site is using following deprecated features:');        /** @var array $deprecated */        foreach ($this->deprecations as $deprecated) {            list($message, $scope) = $this->getDepracatedMessage($deprecated);            $collector->addMessage($message, $scope);        }    }    /**     * @param array $deprecated     * @return array     */    protected function getDepracatedMessage($deprecated)    {        $scope = $deprecated['scope'];        $trace = [];        if (isset($deprecated['trace'])) {            foreach ($deprecated['trace'] as $current) {                $class = $current['class'] ?? '';                $type = $current['type'] ?? '';                $function = $this->getFunction($current);                if (isset($current['file'])) {                    $current['file'] = str_replace(GRAV_ROOT . '/', '', $current['file']);                }                unset($current['class'], $current['type'], $current['function'], $current['args']);                if (isset($current['twig'])) {                    $trace[] = $current['twig'];                } else {                    $trace[] = ['call' => $class . $type . $function] + $current;                }            }        }        $array = [            'message' => $deprecated['message'],            'file' => $deprecated['file'],            'line' => $deprecated['line'],            'trace' => $trace        ];        return [            array_filter($array),            $scope        ];    }    /**     * @param array $trace     * @return string     */    protected function getFunction($trace)    {        if (!isset($trace['function'])) {            return '';        }        return $trace['function'] . '(' . implode(', ', $trace['args'] ?? []) . ')';    }    /**     * @param callable $callable     * @return string     */    protected function resolveCallable(callable $callable)    {        if (is_array($callable)) {            return get_class($callable[0]) . '->' . $callable[1] . '()';        }        return 'unknown';    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,2,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
hamcrest_hamcrest-php_FactoryGenerator_1797, Controls the process of extracting @factory doctags\\n and generating factory method files.\\n\\n Uses File_Iterator to scan for PHP files.\\n,Klasa koja kontroliše postupak izdvajanja i generisanja datoteka fabričkih metoda.,"class FactoryGenerator{    /**     * Path to the Hamcrest PHP files to process.     *     * @var string     */    private $path;    /**     * @var array of FactoryFile     */    private $factoryFiles;    public function __construct($path)    {        $this->path = $path;        $this->factoryFiles = array();    }    public function addFactoryFile(FactoryFile $factoryFile)    {        $this->factoryFiles[] = $factoryFile;    }    public function generate()    {        $classes = $this->getClassesWithFactoryMethods();        foreach ($classes as $class) {            foreach ($class->getMethods() as $method) {                foreach ($method->getCalls() as $call) {                    foreach ($this->factoryFiles as $file) {                        $file->addCall($call);                    }                }            }        }    }    public function write()    {        foreach ($this->factoryFiles as $file) {            $file->build();            $file->write();        }    }    public function getClassesWithFactoryMethods()    {        $classes = array();        $files = $this->getSortedFiles();        foreach ($files as $file) {            $class = $this->getFactoryClass($file);            if ($class !== null) {                $classes[] = $class;            }        }        return $classes;    }    public function getSortedFiles()    {        $iter = $this->getFileIterator();        $files = array();        foreach ($iter as $file) {            $files[] = $file;        }        sort($files, SORT_STRING);        return $files;    }    private function getFileIterator()    {        $factoryClass = class_exists('File_Iterator_Factory') ? 'File_Iterator_Factory' : 'SebastianBergmann\FileIterator\Factory';        $factory = new $factoryClass();        return $factory->getFileIterator($this->path, '.php');    }    public function getFactoryClass($file)    {        $name = $this->getFactoryClassName($file);        if ($name !== null) {            require_once $file;            if (class_exists($name)) {                $class = new FactoryClass(substr($file, strpos($file, 'Hamcrest/')), new ReflectionClass($name));                if ($class->isFactory()) {                    return $class;                }            }        }        return null;    }    public function getFactoryClassName($file)    {        $content = file_get_contents($file);        if (preg_match('/namespace\s+(.+);/', $content, $namespace)            && preg_match('/\n\s*class\s+(\w+)\s+extends\b/', $content, $className)            && preg_match('/@factory\b/', $content)        ) {            return $namespace[1] . '\\' . $className[1];        }        return null;    }}",0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_DecisionTree_822," Returns available features/columns to the tree for the decision making\n process. <br>\n\n If a number is given with setNumFeatures() method, then a random selection\n of features up to this number is returned. <br>\n\n If some features are manually selected by use of setSelectedFeatures(),\n then only these features are returned <br>\n\n If any of above methods were not called beforehand, then all features\n are returned by default.\n",Vraća dostupne funkcije/kolone u stablo za proces donešenja odluka. Ako je broj dobijen metodom setNumFeatures vraća se slučajan izbor odlike do tog broja.  Ako su neke odlike ručno izabrane sa metodom setSelectedFeature onda se vraćaju ove odlike. Ako bilo koja metoda od gore navedenih metoda nije predhodno pozvana tada se podrazumevano vraćaju sve odlike.,"    protected function getSelectedFeatures(): array    {        $allFeatures = range(0, $this->featureCount - 1);        if ($this->numUsableFeatures === 0 && count($this->selectedFeatures) === 0) {            return $allFeatures;        }        if (count($this->selectedFeatures) > 0) {            return $this->selectedFeatures;        }        $numFeatures = $this->numUsableFeatures;        if ($numFeatures > $this->featureCount) {            $numFeatures = $this->featureCount;        }        shuffle($allFeatures);        $selectedFeatures = array_slice($allFeatures, 0, $numFeatures);        sort($selectedFeatures);        return $selectedFeatures;    }",0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3440," Return the kth smallest value in an array\\n Uses a linear-time algorithm: O(n) time in worst case.\\n\\n if $a = [1,2,3,4,6,7]\\n\\n kthSmallest($a, 4) = 6\\n\\n Algorithm:\\n  1) If n is small, just sort and return\\n  2) Otherwise, group into 5-element subsets and mind the median\\n  3) Find the median of the medians\\n  4) Find L and U sets\\n     - L is numbers lower than the median of medians\\n     - U is numbers higher than the median of medians\\n  5) Recursive step\\n     - if k is the median of medians, return that\\n     - Otherwise, recursively search in smaller group.\\n\\n @param float[] $numbers\\n @param int    $k zero indexed - must be less than n (count of $numbers)\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if k â‰¥ n\\n","Vrati k-ti najmanju vrednost iz niza. Algoritam je linearne slozenosti O(n) u najgorem slučaju. Ukoliko je $a = [1,2,3,4,6,7] kthSmallest($a, 4) = 6.\n    1) Ako je n malo, sortiraj niz i vrati broj.\n    2) U suprotnom grupiši elemente niza u podgrupu od pet elemenata i pronadji medijan.\n    3) Pronađi median mediana.\n    4) Pronađi L i U skupove, gde je L broj manji od vrednosti srednjeg člana mediana.\n    5) Rekurzivni korak. Ukoliko je k srednji član mediana vrati ga, u suprotnom rekurzivno pretraži menje grupe.","    public static function kthSmallest(array $numbers, int $k): float    {        $n = \count($numbers);        if ($n === 0) {            throw new Exception\BadDataException('Cannot find the k-th smallest of an empty list of numbers');        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException('k cannot be greater than or equal to the count of numbers');        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // If the array is 5 elements or smaller, use quicksort and return the element of interest.        if ($n <= 5) {            \sort($numbers);            return $numbers[$k];        }        // Otherwise, we are going to slice $numbers into 5-element slices and find the median of each.        $num_slices = \ceil($n / 5);        $median_array = [];        for ($i = 0; $i < $num_slices; $i++) {            $median_array[] = self::median(\array_slice($numbers, 5 * $i, 5));        }        // Then we find the median of the medians.        $median_of_medians = self::median($median_array);        // Next we walk the array and separate it into values that are greater than or less than this ""median of medians"".        $lower_upper   = self::splitAtValue($numbers, $median_of_medians);        $lower_number = \count($lower_upper['lower']);        $equal_number = $lower_upper['equal'];        // Lastly, we find which group of values our value of interest is in, and find it in the smaller array.        if ($k < $lower_number) {            return self::kthSmallest($lower_upper['lower'], $k);        } elseif ($k < ($lower_number + $equal_number)) {            return $median_of_medians;        } else {            return self::kthSmallest($lower_upper['upper'], $k - $lower_number - $equal_number);        }    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_FontMetrics_553, Saves the stored font family cache\n\n The name and location of the cache file are determined by {@link\n FontMetrics::CACHE_FILE}. This file should be writable by the\n webserver process.\n\n @see FontMetrics::loadFontFamilies()\n,Sačuvaj keširanu familiju fontova u fajl. Ime i lokacija fajla je određena parametrom FontMetrics::CACHE_FILE. Upisivanje u fajl bi trebalo da bude u webserver procesu.,"    public function saveFontFamilies()    {        // replace the path to the DOMPDF font directories with the corresponding constants (allows for more portability)        $cacheData = sprintf(""<?php return array (%s"", PHP_EOL);        foreach ($this->fontLookup as $family => $variants) {            $cacheData .= sprintf(""  '%s' => array(%s"", addslashes($family), PHP_EOL);            foreach ($variants as $variant => $path) {                $path = sprintf(""'%s'"", $path);                $path = str_replace('\'' . $this->getOptions()->getFontDir() , '$fontDir . \'' , $path);                $path = str_replace('\'' . $this->getOptions()->getRootDir() , '$rootDir . \'' , $path);                $cacheData .= sprintf(""    '%s' => %s,%s"", $variant, $path, PHP_EOL);            }            $cacheData .= sprintf(""  ),%s"", PHP_EOL);        }        $cacheData .= "") ?>"";        file_put_contents($this->getCacheFile(), $cacheData);    }",0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1228, Uses previously generated safe universal build and generates optimized build for a specific platform\n,Klasa koja koristi predhodno generisan siguran bild i koristi ga za generisanje optimizovan bild za ciljnu platformu.,"class Generator_Optimized{    /**     * Directory, where safe universal build files are generated     *     * @var string     */    protected string $sourceBuildDir;    /**     * Platform settings for supported optimized builds     *     * @var array     */    protected array $settings;    /**     * Filters for processing (optimizing) lines from safe universal phalcon.c     *     * @var array     */    protected array $filters;    /**     * @param string $sourceBuildDir     * @param string $output32Dir     * @param string $output64Dir     */    public function __construct(string $sourceBuildDir, string $output32Dir, string $output64Dir)    {        $this->sourceBuildDir = $sourceBuildDir;        $this->settings = $this->getPlatformsSettings($output32Dir, $output64Dir);        $this->filters = $this->getFilters();    }    /**     * Return array of supported platform settings for optimized builds     *     * @param string $output32Dir     * @param string $output64Dir     * @return array     */    protected function getPlatformsSettings(string $output32Dir, string $output64Dir)    {        return array(            '32bit' => array(                'dir' => $output32Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey32($string) . 'UL';                }            ),            '64bit' => array(                'dir' => $output64Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey64($string) . 'UL';                }            ),        );    }    /**     * Return filters for processing lines from safe universal phalcon.c     *     * @return array     */    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }    /**     * Run generation process     */    public function run()    {        echo 'Generating builds, optimized for 32-bit and 64-bit platforms... ';        $this->cleanBuildDirectories();        $this->copyFilesFromSourceBuildDir();        $this->copyAndOptimizePhalconC();        echo ""OK\n"";    }    /**     * Delete all files in target directories     */    public function cleanBuildDirectories()    {        foreach ($this->settings as $setting) {            Util::cleanDirectory($setting['dir']);        }    }    /**     * Copy all files from the original safe universal build directory     */    protected function copyFilesFromSourceBuildDir()    {        $files = glob($this->sourceBuildDir . '/*.*');        foreach ($files as $file) {            // phalcon.c is processed in a separate optimization func            if (basename($file) == 'phalcon.zep.c') {                continue;            }            foreach ($this->settings as $setting) {                copy($file, $setting['dir'] . '/' . basename($file));            }        }    }    /**     * Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.     * Precalculation is, actually, the optimization being performed.     */    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }    /**     * Pass line through filters and add the processed result to platform builds     *     * @param string $line     * @param array $result     */    protected function filterLine($line, &$result)    {        /** @var callable|null $func */        $func = null;        foreach ($this->filters as $filter) {            if (!preg_match($filter['regexp'], $line, $matches)) {                continue;            }            $func = $filter['func'];            break; // We don't expect more than one replacement to be made on the same line        }        foreach ($this->settings as $platform => $setting) {            $result[$platform] .= $func ? $func($line, $matches, $setting['hashFunc']) : $line;        }    }}",0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_2072," Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.\n Precalculation is, actually, the optimization being performed.\n",Prekopiraj phalcon.c i optimizuj ga zamenivši stringove sa prekalkulisanim heš vrednostima. Prekalkulacija je zapravo optimizacija koja se primenjuje.,"    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }",0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_CacheWarmerAggregate_3111, Warms up the cache.\n\n @return string[] A list of classes or files to preload on PHP 7.4+\n,Ažuriraj keš.,"    public function warmUp(string $cacheDir)    {        if ($collectDeprecations = $this->debug && !\defined('PHPUNIT_COMPOSER_INSTALL')) {            $collectedLogs = [];            $previousHandler = set_error_handler(function ($type, $message, $file, $line) use (&$collectedLogs, &$previousHandler) {                if (\E_USER_DEPRECATED !== $type && \E_DEPRECATED !== $type) {                    return $previousHandler ? $previousHandler($type, $message, $file, $line) : false;                }                if (isset($collectedLogs[$message])) {                    ++$collectedLogs[$message]['count'];                    return null;                }                $backtrace = debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS, 3);                // Clean the trace by removing first frames added by the error handler itself.                for ($i = 0; isset($backtrace[$i]); ++$i) {                    if (isset($backtrace[$i]['file'], $backtrace[$i]['line']) && $backtrace[$i]['line'] === $line && $backtrace[$i]['file'] === $file) {                        $backtrace = \array_slice($backtrace, 1 + $i);                        break;                    }                }                $collectedLogs[$message] = [                    'type' => $type,                    'message' => $message,                    'file' => $file,                    'line' => $line,                    'trace' => $backtrace,                    'count' => 1,                ];                return null;            });        }        $preload = [];        try {            foreach ($this->warmers as $warmer) {                if (!$this->optionalsEnabled && $warmer->isOptional()) {                    continue;                }                if ($this->onlyOptionalsEnabled && !$warmer->isOptional()) {                    continue;                }                $preload[] = array_values((array) $warmer->warmUp($cacheDir));            }        } finally {            if ($collectDeprecations) {                restore_error_handler();                if (is_file($this->deprecationLogsFilepath)) {                    $previousLogs = unserialize(file_get_contents($this->deprecationLogsFilepath));                    $collectedLogs = array_merge($previousLogs, $collectedLogs);                }                file_put_contents($this->deprecationLogsFilepath, serialize(array_values($collectedLogs)));            }        }        return array_values(array_unique(array_merge([], ...$preload)));    }",0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Safe_1241, Resolves headers in the php_phalcon.h file\\n,Razreši hedere u php_phalcon.h fajlu.,"    protected function processKernelGlobals()    {        $lines = [];        foreach (file($this->outputDir . '/php_phalcon.h') as $line) {            if (preg_match('@^#include ""(kernel/.+)""@', $line, $matches)) {                $content = file_get_contents($this->sourceDir . DIRECTORY_SEPARATOR . $matches[1]);                $lines[] = $content . PHP_EOL;            } else {                $lines[] = $line;            }        }        file_put_contents($this->outputDir . '/php_phalcon.h', join('', $lines));    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_Version20160401000000_2382, Initial database structure.\n,Inicijalna struktura baze podataka.,"class Version20160401000000 extends WallabagMigration{    public function up(Schema $schema)    {        $this->skipIf($schema->hasTable($this->getTable('entry')), 'Database already initialized');        switch ($this->connection->getDatabasePlatform()->getName()) {            case 'sqlite':                $sql = <<<SQLCREATE TABLE {$this->getTable('craue_config_setting')} (name VARCHAR(255) NOT NULL, value VARCHAR(255) DEFAULT NULL, section VARCHAR(255) DEFAULT NULL, PRIMARY KEY(name));CREATE UNIQUE INDEX UNIQ_5D9649505E237E06 ON {$this->getTable('craue_config_setting')} (name);CREATE TABLE {$this->getTable('tagging_rule')} (id INTEGER NOT NULL, config_id INTEGER DEFAULT NULL, rule VARCHAR(255) NOT NULL, tags CLOB NOT NULL, PRIMARY KEY(id), CONSTRAINT FK_2D9B3C5424DB0683 FOREIGN KEY (config_id) REFERENCES {$this->getTable('config')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE INDEX IDX_2D9B3C5424DB0683 ON {$this->getTable('tagging_rule')} (config_id);CREATE TABLE {$this->getTable('tag')} (id INTEGER NOT NULL, label CLOB NOT NULL, slug VARCHAR(128) NOT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_4CA58A8C989D9B62 ON {$this->getTable('tag')} (slug);CREATE TABLE {$this->getTable('entry')} (id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, title CLOB DEFAULT NULL, url CLOB DEFAULT NULL, is_archived BOOLEAN NOT NULL, is_starred BOOLEAN NOT NULL, content CLOB DEFAULT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, mimetype CLOB DEFAULT NULL, language CLOB DEFAULT NULL, reading_time INTEGER DEFAULT NULL, domain_name CLOB DEFAULT NULL, preview_picture CLOB DEFAULT NULL, is_public BOOLEAN DEFAULT '0', PRIMARY KEY(id), CONSTRAINT FK_F4D18282A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE INDEX IDX_F4D18282A76ED395 ON {$this->getTable('entry')} (user_id);CREATE TABLE {$this->getTable('entry_tag')} (entry_id INTEGER NOT NULL, tag_id INTEGER NOT NULL, PRIMARY KEY(entry_id, tag_id), CONSTRAINT FK_C9F0DD7CBA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_C9F0DD7CBAD26311 FOREIGN KEY (tag_id) REFERENCES {$this->getTable('tag')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE INDEX IDX_C9F0DD7CBA364942 ON {$this->getTable('entry_tag')} (entry_id);CREATE INDEX IDX_C9F0DD7CBAD26311 ON {$this->getTable('entry_tag')} (tag_id);CREATE TABLE {$this->getTable('config')} (id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, theme VARCHAR(255) NOT NULL, items_per_page INTEGER NOT NULL, language VARCHAR(255) NOT NULL, rss_token VARCHAR(255) DEFAULT NULL, rss_limit INTEGER DEFAULT NULL, reading_speed DOUBLE PRECISION DEFAULT NULL, PRIMARY KEY(id), CONSTRAINT FK_87E64C53A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE UNIQUE INDEX UNIQ_87E64C53A76ED395 ON {$this->getTable('config')} (user_id);CREATE TABLE {$this->getTable('oauth2_refresh_tokens')} (id INTEGER NOT NULL, client_id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INTEGER DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id), CONSTRAINT FK_20C9FB2419EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_20C9FB24A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE UNIQUE INDEX UNIQ_20C9FB245F37A13B ON {$this->getTable('oauth2_refresh_tokens')} (token);CREATE INDEX IDX_20C9FB2419EB6921 ON {$this->getTable('oauth2_refresh_tokens')} (client_id);CREATE INDEX IDX_20C9FB24A76ED395 ON {$this->getTable('oauth2_refresh_tokens')} (user_id);CREATE TABLE {$this->getTable('oauth2_access_tokens')} (id INTEGER NOT NULL, client_id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INTEGER DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id), CONSTRAINT FK_368A420919EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_368A4209A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE UNIQUE INDEX UNIQ_368A42095F37A13B ON {$this->getTable('oauth2_access_tokens')} (token);CREATE INDEX IDX_368A420919EB6921 ON {$this->getTable('oauth2_access_tokens')} (client_id);CREATE INDEX IDX_368A4209A76ED395 ON {$this->getTable('oauth2_access_tokens')} (user_id);CREATE TABLE {$this->getTable('oauth2_auth_codes')} (id INTEGER NOT NULL, client_id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, token VARCHAR(255) NOT NULL, redirect_uri CLOB NOT NULL, expires_at INTEGER DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id), CONSTRAINT FK_EE52E3FA19EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_EE52E3FAA76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE UNIQUE INDEX UNIQ_EE52E3FA5F37A13B ON {$this->getTable('oauth2_auth_codes')} (token);CREATE INDEX IDX_EE52E3FA19EB6921 ON {$this->getTable('oauth2_auth_codes')} (client_id);CREATE INDEX IDX_EE52E3FAA76ED395 ON {$this->getTable('oauth2_auth_codes')} (user_id);CREATE TABLE {$this->getTable('oauth2_clients')} (id INTEGER NOT NULL, random_id VARCHAR(255) NOT NULL, redirect_uris CLOB NOT NULL, secret VARCHAR(255) NOT NULL, allowed_grant_types CLOB NOT NULL, PRIMARY KEY(id));CREATE TABLE {$this->getTable('user')} (id INTEGER NOT NULL, username VARCHAR(180) NOT NULL, username_canonical VARCHAR(180) NOT NULL, email VARCHAR(180) NOT NULL, email_canonical VARCHAR(180) NOT NULL, enabled BOOLEAN NOT NULL, salt VARCHAR(255) NOT NULL, password VARCHAR(255) NOT NULL, last_login DATETIME DEFAULT NULL, locked BOOLEAN NOT NULL, expired BOOLEAN NOT NULL, expires_at DATETIME DEFAULT NULL, confirmation_token VARCHAR(255) DEFAULT NULL, password_requested_at DATETIME DEFAULT NULL, roles CLOB NOT NULL, credentials_expired BOOLEAN NOT NULL, credentials_expire_at DATETIME DEFAULT NULL, name CLOB DEFAULT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, authCode INTEGER DEFAULT NULL, twoFactorAuthentication BOOLEAN NOT NULL, trusted CLOB DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_1D63E7E592FC23A8 ON {$this->getTable('user')} (username_canonical);CREATE UNIQUE INDEX UNIQ_1D63E7E5A0D96FBF ON {$this->getTable('user')} (email_canonical);CREATE UNIQUE INDEX UNIQ_1D63E7E5C05FB297 ON {$this->getTable('user')} (confirmation_token);CREATE TABLE {$this->getTable('annotation')} (id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, entry_id INTEGER DEFAULT NULL, text CLOB NOT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, quote VARCHAR(255) NOT NULL, ranges CLOB NOT NULL, PRIMARY KEY(id), CONSTRAINT FK_A7AED006A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_A7AED006BA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE INDEX IDX_A7AED006A76ED395 ON {$this->getTable('annotation')} (user_id);CREATE INDEX IDX_A7AED006BA364942 ON {$this->getTable('annotation')} (entry_id);SQL                ;                foreach (explode(""\n"", $sql) as $query) {                    $this->addSql($query);                }                break;            case 'mysql':                $sql = <<<SQLCREATE TABLE {$this->getTable('craue_config_setting')} (name VARCHAR(255) NOT NULL, value VARCHAR(255) DEFAULT NULL, section VARCHAR(255) DEFAULT NULL, UNIQUE INDEX UNIQ_5D9649505E237E06 (name), PRIMARY KEY(name)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('entry')} (id INT AUTO_INCREMENT NOT NULL, user_id INT DEFAULT NULL, title LONGTEXT DEFAULT NULL, url LONGTEXT DEFAULT NULL, is_archived TINYINT(1) NOT NULL, is_starred TINYINT(1) NOT NULL, content LONGTEXT DEFAULT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, mimetype LONGTEXT DEFAULT NULL, language LONGTEXT DEFAULT NULL, reading_time INT DEFAULT NULL, domain_name LONGTEXT DEFAULT NULL, preview_picture LONGTEXT DEFAULT NULL, is_public TINYINT(1) DEFAULT '0', INDEX IDX_F4D18282A76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('entry_tag')} (entry_id INT NOT NULL, tag_id INT NOT NULL, INDEX IDX_C9F0DD7CBA364942 (entry_id), INDEX IDX_C9F0DD7CBAD26311 (tag_id), PRIMARY KEY(entry_id, tag_id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('config')} (id INT AUTO_INCREMENT NOT NULL, user_id INT DEFAULT NULL, theme VARCHAR(255) NOT NULL, items_per_page INT NOT NULL, language VARCHAR(255) NOT NULL, rss_token VARCHAR(255) DEFAULT NULL, rss_limit INT DEFAULT NULL, reading_speed DOUBLE PRECISION DEFAULT NULL, UNIQUE INDEX UNIQ_87E64C53A76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('tagging_rule')} (id INT AUTO_INCREMENT NOT NULL, config_id INT DEFAULT NULL, rule VARCHAR(255) NOT NULL, tags LONGTEXT NOT NULL COMMENT '(DC2Type:simple_array)', INDEX IDX_2D9B3C5424DB0683 (config_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('tag')} (id INT AUTO_INCREMENT NOT NULL, `label` LONGTEXT NOT NULL, slug VARCHAR(128) NOT NULL, UNIQUE INDEX UNIQ_4CA58A8C989D9B62 (slug), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('oauth2_clients')} (id INT AUTO_INCREMENT NOT NULL, random_id VARCHAR(255) NOT NULL, redirect_uris LONGTEXT NOT NULL COMMENT '(DC2Type:array)', secret VARCHAR(255) NOT NULL, allowed_grant_types LONGTEXT NOT NULL COMMENT '(DC2Type:array)', PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('oauth2_access_tokens')} (id INT AUTO_INCREMENT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, UNIQUE INDEX UNIQ_368A42095F37A13B (token), INDEX IDX_368A420919EB6921 (client_id), INDEX IDX_368A4209A76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('oauth2_refresh_tokens')} (id INT AUTO_INCREMENT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, UNIQUE INDEX UNIQ_20C9FB245F37A13B (token), INDEX IDX_20C9FB2419EB6921 (client_id), INDEX IDX_20C9FB24A76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('oauth2_auth_codes')} (id INT AUTO_INCREMENT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, redirect_uri LONGTEXT NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, UNIQUE INDEX UNIQ_EE52E3FA5F37A13B (token), INDEX IDX_EE52E3FA19EB6921 (client_id), INDEX IDX_EE52E3FAA76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('user')} (id INT AUTO_INCREMENT NOT NULL, username VARCHAR(180) NOT NULL, username_canonical VARCHAR(180) NOT NULL, email VARCHAR(180) NOT NULL, email_canonical VARCHAR(180) NOT NULL, enabled TINYINT(1) NOT NULL, salt VARCHAR(255) NOT NULL, password VARCHAR(255) NOT NULL, last_login DATETIME DEFAULT NULL, locked TINYINT(1) NOT NULL, expired TINYINT(1) NOT NULL, expires_at DATETIME DEFAULT NULL, confirmation_token VARCHAR(255) DEFAULT NULL, password_requested_at DATETIME DEFAULT NULL, roles LONGTEXT NOT NULL COMMENT '(DC2Type:array)', credentials_expired TINYINT(1) NOT NULL, credentials_expire_at DATETIME DEFAULT NULL, name LONGTEXT DEFAULT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, authCode INT DEFAULT NULL, twoFactorAuthentication TINYINT(1) NOT NULL, trusted LONGTEXT DEFAULT NULL COMMENT '(DC2Type:json_array)', UNIQUE INDEX UNIQ_1D63E7E592FC23A8 (username_canonical), UNIQUE INDEX UNIQ_1D63E7E5A0D96FBF (email_canonical), UNIQUE INDEX UNIQ_1D63E7E5C05FB297 (confirmation_token), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('annotation')} (id INT AUTO_INCREMENT NOT NULL, user_id INT DEFAULT NULL, entry_id INT DEFAULT NULL, text LONGTEXT NOT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, quote VARCHAR(255) NOT NULL, ranges LONGTEXT NOT NULL COMMENT '(DC2Type:array)', INDEX IDX_A7AED006A76ED395 (user_id), INDEX IDX_A7AED006BA364942 (entry_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;ALTER TABLE {$this->getTable('entry')} ADD CONSTRAINT FK_F4D18282A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('entry_tag')} ADD CONSTRAINT FK_C9F0DD7CBA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id);ALTER TABLE {$this->getTable('entry_tag')} ADD CONSTRAINT FK_C9F0DD7CBAD26311 FOREIGN KEY (tag_id) REFERENCES {$this->getTable('tag')} (id);ALTER TABLE {$this->getTable('config')} ADD CONSTRAINT FK_87E64C53A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('tagging_rule')} ADD CONSTRAINT FK_2D9B3C5424DB0683 FOREIGN KEY (config_id) REFERENCES {$this->getTable('config')} (id);ALTER TABLE {$this->getTable('oauth2_access_tokens')} ADD CONSTRAINT FK_368A420919EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id);ALTER TABLE {$this->getTable('oauth2_access_tokens')} ADD CONSTRAINT FK_368A4209A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('oauth2_refresh_tokens')} ADD CONSTRAINT FK_20C9FB2419EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id);ALTER TABLE {$this->getTable('oauth2_refresh_tokens')} ADD CONSTRAINT FK_20C9FB24A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('oauth2_auth_codes')} ADD CONSTRAINT FK_EE52E3FA19EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id);ALTER TABLE {$this->getTable('oauth2_auth_codes')} ADD CONSTRAINT FK_EE52E3FAA76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('annotation')} ADD CONSTRAINT FK_A7AED006A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('annotation')} ADD CONSTRAINT FK_A7AED006BA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id);SQL                ;                foreach (explode(""\n"", $sql) as $query) {                    $this->addSql($query);                }                break;            case 'postgresql':                $sql = <<<SQLCREATE TABLE {$this->getTable('craue_config_setting')} (name VARCHAR(255) NOT NULL, value VARCHAR(255) DEFAULT NULL, section VARCHAR(255) DEFAULT NULL, PRIMARY KEY(name));CREATE UNIQUE INDEX UNIQ_5D9649505E237E06 ON {$this->getTable('craue_config_setting')} (name);CREATE TABLE {$this->getTable('entry')} (id INT NOT NULL, user_id INT DEFAULT NULL, title TEXT DEFAULT NULL, url TEXT DEFAULT NULL, is_archived BOOLEAN NOT NULL, is_starred BOOLEAN NOT NULL, content TEXT DEFAULT NULL, created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, updated_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, mimetype TEXT DEFAULT NULL, language TEXT DEFAULT NULL, reading_time INT DEFAULT NULL, domain_name TEXT DEFAULT NULL, preview_picture TEXT DEFAULT NULL, is_public BOOLEAN DEFAULT 'false', PRIMARY KEY(id));CREATE INDEX IDX_F4D18282A76ED395 ON {$this->getTable('entry')} (user_id);CREATE TABLE {$this->getTable('entry_tag')} (entry_id INT NOT NULL, tag_id INT NOT NULL, PRIMARY KEY(entry_id, tag_id));CREATE INDEX IDX_C9F0DD7CBA364942 ON {$this->getTable('entry_tag')} (entry_id);CREATE INDEX IDX_C9F0DD7CBAD26311 ON {$this->getTable('entry_tag')} (tag_id);CREATE TABLE {$this->getTable('config')} (id INT NOT NULL, user_id INT DEFAULT NULL, theme VARCHAR(255) NOT NULL, items_per_page INT NOT NULL, language VARCHAR(255) NOT NULL, rss_token VARCHAR(255) DEFAULT NULL, rss_limit INT DEFAULT NULL, reading_speed DOUBLE PRECISION DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_87E64C53A76ED395 ON {$this->getTable('config')} (user_id);CREATE TABLE {$this->getTable('tagging_rule')} (id INT NOT NULL, config_id INT DEFAULT NULL, rule VARCHAR(255) NOT NULL, tags TEXT NOT NULL, PRIMARY KEY(id));CREATE INDEX IDX_2D9B3C5424DB0683 ON {$this->getTable('tagging_rule')} (config_id);COMMENT ON COLUMN {$this->getTable('tagging_rule')}.tags IS '(DC2Type:simple_array)';CREATE TABLE {$this->getTable('tag')} (id INT NOT NULL, label TEXT NOT NULL, slug VARCHAR(128) NOT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_4CA58A8C989D9B62 ON {$this->getTable('tag')} (slug);CREATE TABLE {$this->getTable('oauth2_clients')} (id INT NOT NULL, random_id VARCHAR(255) NOT NULL, redirect_uris TEXT NOT NULL, secret VARCHAR(255) NOT NULL, allowed_grant_types TEXT NOT NULL, PRIMARY KEY(id));COMMENT ON COLUMN {$this->getTable('oauth2_clients')}.redirect_uris IS '(DC2Type:array)';COMMENT ON COLUMN {$this->getTable('oauth2_clients')}.allowed_grant_types IS '(DC2Type:array)';CREATE TABLE {$this->getTable('oauth2_access_tokens')} (id INT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_368A42095F37A13B ON {$this->getTable('oauth2_access_tokens')} (token);CREATE INDEX IDX_368A420919EB6921 ON {$this->getTable('oauth2_access_tokens')} (client_id);CREATE INDEX IDX_368A4209A76ED395 ON {$this->getTable('oauth2_access_tokens')} (user_id);CREATE TABLE {$this->getTable('oauth2_refresh_tokens')} (id INT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_20C9FB245F37A13B ON {$this->getTable('oauth2_refresh_tokens')} (token);CREATE INDEX IDX_20C9FB2419EB6921 ON {$this->getTable('oauth2_refresh_tokens')} (client_id);CREATE INDEX IDX_20C9FB24A76ED395 ON {$this->getTable('oauth2_refresh_tokens')} (user_id);CREATE TABLE {$this->getTable('oauth2_auth_codes')} (id INT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, redirect_uri TEXT NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_EE52E3FA5F37A13B ON {$this->getTable('oauth2_auth_codes')} (token);CREATE INDEX IDX_EE52E3FA19EB6921 ON {$this->getTable('oauth2_auth_codes')} (client_id);CREATE INDEX IDX_EE52E3FAA76ED395 ON {$this->getTable('oauth2_auth_codes')} (user_id);CREATE TABLE {$this->getTable('user')} (id INT NOT NULL, username VARCHAR(180) NOT NULL, username_canonical VARCHAR(180) NOT NULL, email VARCHAR(180) NOT NULL, email_canonical VARCHAR(180) NOT NULL, enabled BOOLEAN NOT NULL, salt VARCHAR(255) NOT NULL, password VARCHAR(255) NOT NULL, last_login TIMESTAMP(0) WITHOUT TIME ZONE DEFAULT NULL, locked BOOLEAN NOT NULL, expired BOOLEAN NOT NULL, expires_at TIMESTAMP(0) WITHOUT TIME ZONE DEFAULT NULL, confirmation_token VARCHAR(255) DEFAULT NULL, password_requested_at TIMESTAMP(0) WITHOUT TIME ZONE DEFAULT NULL, roles TEXT NOT NULL, credentials_expired BOOLEAN NOT NULL, credentials_expire_at TIMESTAMP(0) WITHOUT TIME ZONE DEFAULT NULL, name TEXT DEFAULT NULL, created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, updated_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, authCode INT DEFAULT NULL, twoFactorAuthentication BOOLEAN NOT NULL, trusted TEXT DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_1D63E7E592FC23A8 ON {$this->getTable('user')} (username_canonical);CREATE UNIQUE INDEX UNIQ_1D63E7E5A0D96FBF ON {$this->getTable('user')} (email_canonical);CREATE UNIQUE INDEX UNIQ_1D63E7E5C05FB297 ON {$this->getTable('user')} (confirmation_token);COMMENT ON COLUMN {$this->getTable('user')}.roles IS '(DC2Type:array)';COMMENT ON COLUMN {$this->getTable('user')}.trusted IS '(DC2Type:json_array)';CREATE TABLE {$this->getTable('annotation')} (id INT NOT NULL, user_id INT DEFAULT NULL, entry_id INT DEFAULT NULL, text TEXT NOT NULL, created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, updated_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, quote VARCHAR(255) NOT NULL, ranges TEXT NOT NULL, PRIMARY KEY(id));CREATE INDEX IDX_A7AED006A76ED395 ON {$this->getTable('annotation')} (user_id);CREATE INDEX IDX_A7AED006BA364942 ON {$this->getTable('annotation')} (entry_id);COMMENT ON COLUMN {$this->getTable('annotation')}.ranges IS '(DC2Type:array)';CREATE SEQUENCE ""entry_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE ""config_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE ""tagging_rule_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE ""tag_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE oauth2_clients_id_seq INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE oauth2_access_tokens_id_seq INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE oauth2_refresh_tokens_id_seq INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE oauth2_auth_codes_id_seq INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE ""user_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE annotation_id_seq INCREMENT BY 1 MINVALUE 1 START 1;ALTER TABLE {$this->getTable('entry')} ADD CONSTRAINT FK_F4D18282A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('entry_tag')} ADD CONSTRAINT FK_C9F0DD7CBA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('entry_tag')} ADD CONSTRAINT FK_C9F0DD7CBAD26311 FOREIGN KEY (tag_id) REFERENCES {$this->getTable('tag')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('config')} ADD CONSTRAINT FK_87E64C53A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('tagging_rule')} ADD CONSTRAINT FK_2D9B3C5424DB0683 FOREIGN KEY (config_id) REFERENCES {$this->getTable('config')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_access_tokens')} ADD CONSTRAINT FK_368A420919EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_access_tokens')} ADD CONSTRAINT FK_368A4209A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_refresh_tokens')} ADD CONSTRAINT FK_20C9FB2419EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_refresh_tokens')} ADD CONSTRAINT FK_20C9FB24A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_auth_codes')} ADD CONSTRAINT FK_EE52E3FA19EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_auth_codes')} ADD CONSTRAINT FK_EE52E3FAA76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('annotation')} ADD CONSTRAINT FK_A7AED006A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('annotation')} ADD CONSTRAINT FK_A7AED006BA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;SQL                ;                foreach (explode(""\n"", $sql) as $query) {                    $this->addSql($query);                }                break;        }    }    public function down(Schema $schema)    {        $this->addSql(""DROP TABLE {$this->getTable('craue_config_setting')}"");        $this->addSql(""DROP TABLE {$this->getTable('tagging_rule')}"");        $this->addSql(""DROP TABLE {$this->getTable('config')}"");        $this->addSql(""DROP TABLE {$this->getTable('entry')}"");        $this->addSql(""DROP TABLE {$this->getTable('entry_tag')}"");        $this->addSql(""DROP TABLE {$this->getTable('tag')}"");        $this->addSql(""DROP TABLE {$this->getTable('oauth2_refresh_tokens')}"");        $this->addSql(""DROP TABLE {$this->getTable('oauth2_access_tokens')}"");        $this->addSql(""DROP TABLE {$this->getTable('oauth2_clients')}"");        $this->addSql(""DROP TABLE {$this->getTable('oauth2_auth_codes')}"");        $this->addSql(""DROP TABLE {$this->getTable('user')}"");        $this->addSql(""DROP TABLE {$this->getTable('annotation')}"");    }}",1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_1259, Get postgresql db options\\n,Dohvati opcije za postgresql.,"    function getOptionsPostgresql(): array    {        return [            'host'     => env('DATA_POSTGRES_HOST'),            'username' => env('DATA_POSTGRES_USER'),            'password' => env('DATA_POSTGRES_PASS'),            'port'     => env('DATA_POSTGRES_PORT'),            'dbname'   => env('DATA_POSTGRES_NAME'),            'schema'   => env('DATA_POSTGRES_SCHEMA'),        ];    }",0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2623, m x n Matrix\\n,Klasa m x n matrice.,"abstract class Matrix implements \ArrayAccess, \JsonSerializable{    /** @var int Number of rows */    protected $m;    /** @var int Number of columns */    protected $n;    /** @var array[] Matrix array of arrays */    protected $A;    /** @var MatrixCatalog */    protected $catalog;    /** @var float|null Error/zero tolerance */    protected $Îµ;    /**************************************************************************     * ABSTRACT METHODS     *  - getObjectType     **************************************************************************/    /**     * What type of data does the matrix contain     *     * @return string the type of data in the Matrix     */    abstract public function getObjectType(): string;    /**************************************************************************     * BASIC MATRIX GETTERS     *  - getMatrix     *  - getM     *  - getN     *  - getRow     *  - getColumn     *  - get     *  - getDiagonalElements     *  - getSuperdiagonalElements     *  - getSubdiagonalElements     *  - asVectors     **************************************************************************/    /**     * Get matrix     * @return array[] of arrays     */    public function getMatrix(): array    {        return $this->A;    }    /**     * Get row count (m)     * @return int number of rows     */    public function getM(): int    {        return $this->m;    }    /**     * Get column count (n)     * @return int number of columns     */    public function getN(): int    {        return $this->n;    }    /**     * Get single row from the matrix     *     * @param  int    $i row index (from 0 to m - 1)     * @return array     *     * @throws Exception\MatrixException if row i does not exist     */    public function getRow(int $i): array    {        if ($i >= $this->m) {            throw new Exception\MatrixException(""Row $i does not exist"");        }        return $this->A[$i];    }    /**     * Get single column from the matrix     *     * @param  int   $j column index (from 0 to n - 1)     * @return array     *     * @throws Exception\MatrixException if column j does not exist     */    public function getColumn(int $j): array    {        if ($j >= $this->n) {            throw new Exception\MatrixException(""Column $j does not exist"");        }        return \array_column($this->A, $j);    }    /**     * Get a specific value at row i, column j     *     * @param  int    $i row index     * @param  int    $j column index     * @return number     *     * @throws Exception\MatrixException if row i or column j does not exist     */    public function get(int $i, int $j)    {        if ($i >= $this->m) {            throw new Exception\MatrixException(""Row $i does not exist"");        }        if ($j >= $this->n) {            throw new Exception\MatrixException(""Column $j does not exist"");        }        return $this->A[$i][$j];    }    /**     * Returns the elements on the diagonal of a square matrix as an array     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     * getDiagonalElements($A) = [1, 5, 9]     *     * @return array     */    public function getDiagonalElements(): array    {        $diagonal = [];        for ($i = 0; $i < \min($this->m, $this->n); $i++) {            $diagonal[] = $this->A[$i][$i];        }        return $diagonal;    }    /**     * Returns the elements on the superdiagonal of a square matrix as an array     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     * getSuperdiagonalElements($A) = [2, 6]     *     * http://mathworld.wolfram.com/Superdiagonal.html     *     * @return array     */    public function getSuperdiagonalElements(): array    {        $superdiagonal = [];        if ($this->isSquare()) {            for ($i = 0; $i < $this->m - 1; $i++) {                $superdiagonal[] = $this->A[$i][$i + 1];            }        }        return $superdiagonal;    }    /**     * Returns the elements on the subdiagonal of a square matrix as an array     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     * getSubdiagonalElements($A) = [4, 8]     *     * http://mathworld.wolfram.com/Subdiagonal.html     *     * @return array     */    public function getSubdiagonalElements(): array    {        $subdiagonal = [];        if ($this->isSquare()) {            for ($i = 1; $i < $this->m; $i++) {                $subdiagonal[] = $this->A[$i][$i - 1];            }        }        return $subdiagonal;    }    /**     * Returns an array of vectors from the columns of the matrix.     * Each column of the matrix becomes a vector.     *     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     *           [1] [2] [3]     * Vectors = [4] [5] [6]     *           [7] [8] [9]     *     * @return Vector[]     */    public function asVectors(): array    {        $n       = $this->n;        $vectors = [];        for ($j = 0; $j < $n; $j++) {            $vectors[] = new Vector(\array_column($this->A, $j));        }        return $vectors;    }    /**     * Returns an array of vectors from the columns of the matrix.     * Each column of the matrix becomes a vector.     *     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     *           [1] [4] [7]     * Vectors = [2] [5] [8]     *           [3] [6] [9]     *     * @return Vector[]     */    public function asRowVectors(): array    {        return \array_map(            function (array $row) {                return new Vector($row);            },            $this->A        );    }    /***************************************************************************     * MATRIX COMPARISONS     *  - isEqualSizeAndType     ***************************************************************************/    /**     * Is this matrix the same size and type as some other matrix?     *     * @param Matrix $B     *     * @return bool     */    protected function isEqualSizeAndType(Matrix $B): bool    {        if ($this->getObjectType() !== $B->getObjectType()) {            return false;        }        $m = $this->m;        $n = $this->n;        // Same dimensions        if ($m != $B->m || $n != $B->n) {            return false;        }        return true;    }    /**************************************************************************     * MATRIX PROPERTIES     *  - isSquare     **************************************************************************/    /**     * Is the matrix a square matrix?     * Do rows m = columns n?     *     * @return bool true if square; false otherwise.     */    public function isSquare(): bool    {        return $this->m === $this->n;    }    /**************************************************************************     * MATRIX AUGMENTATION - Return a Matrix     *  - augment     *  - augmentBelow     *  - augmentAbove     *  - augmentLeft     **************************************************************************/    /**     * Augment a matrix     * An augmented matrix is a matrix obtained by appending the columns of two given matrices     *     *     [1, 2, 3]     * A = [2, 3, 4]     *     [3, 4, 5]     *     *     [4]     * B = [5]     *     [6]     *     *         [1, 2, 3 | 4]     * (A|B) = [2, 3, 4 | 5]     *         [3, 4, 5 | 6]     *     * @param  Matrix $B Matrix columns to add to matrix A     *     * @return Matrix     *     * @throws Exception\MatrixException if matrices do not have the same number of rows     * @throws Exception\IncorrectTypeException     */    public function augment(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of rows');        }        $m    = $this->m;        $A    = $this->A;        $B    = $B->getMatrix();        $âŸ®Aâˆ£BâŸ¯ = [];        for ($i = 0; $i < $m; $i++) {            $âŸ®Aâˆ£BâŸ¯[$i] = \array_merge($A[$i], $B[$i]);        }        return MatrixFactory::create($âŸ®Aâˆ£BâŸ¯, $this->Îµ);    }    /**     * Augment a matrix on the left     * An augmented matrix is a matrix obtained by preprending the columns of two given matrices     *     *     [1, 2, 3]     * A = [2, 3, 4]     *     [3, 4, 5]     *     *     [4]     * B = [5]     *     [6]     *     *         [4 | 1, 2, 3]     * (A|B) = [5 | 2, 3, 4]     *         [6 | 3, 4, 5]     *     * @param  Matrix $B Matrix columns to add to matrix A     *     * @return Matrix     *     * @throws Exception\MatrixException if matrices do not have the same number of rows     * @throws Exception\IncorrectTypeException     */    public function augmentLeft(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of rows');        }        $m    = $this->m;        $A    = $this->A;        $B    = $B->getMatrix();        $âŸ®Bâˆ£AâŸ¯ = [];        for ($i = 0; $i < $m; $i++) {            $âŸ®Bâˆ£AâŸ¯[$i] = \array_merge($B[$i], $A[$i]);        }        return MatrixFactory::create($âŸ®Bâˆ£AâŸ¯, $this->Îµ);    }    /**     * Augment a matrix from below     * An augmented matrix is a matrix obtained by appending the rows of two given matrices     *     *     [1, 2, 3]     * A = [2, 3, 4]     *     [3, 4, 5]     *     * B = [4, 5, 6]     *     *         [1, 2, 3]     * (A_B) = [2, 3, 4]     *         [3, 4, 5]     *         [4, 5, 6]     *     * @param  Matrix $B Matrix rows to add to matrix A     *     * @return Matrix     *     * @throws Exception\MatrixException if matrices do not have the same number of columns     * @throws Exception\IncorrectTypeException     */    public function augmentBelow(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of columns');        }        $âŸ®Aâˆ£BâŸ¯ = \array_merge($this->A, $B->getMatrix());        return MatrixFactory::create($âŸ®Aâˆ£BâŸ¯, $this->Îµ);    }    /**     * Augment a matrix from above     * An augmented matrix is a matrix obtained by prepending the rows of two given matrices     *     *     [1, 2, 3]     * A = [2, 3, 4]     *     [3, 4, 5]     *     * B = [4, 5, 6]     *     *         [4, 5, 6]     *         [1, 2, 3]     * (A_B) = [2, 3, 4]     *         [3, 4, 5]     *     * @param  Matrix $B Matrix rows to add to matrix A     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public function augmentAbove(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of columns');        }        $âŸ®Aâˆ£BâŸ¯ = \array_merge($B->getMatrix(), $this->A);        return MatrixFactory::create($âŸ®Aâˆ£BâŸ¯, $this->Îµ);    }    /**************************************************************************     * MATRIX OPERATIONS - Return a Matrix     *  - transpose     *  - submatrix     *  - insert     **************************************************************************/    /**     * Transpose matrix     *     * The transpose of a matrix A is another matrix Aáµ€:     *  - reflect A over its main diagonal (which runs from top-left to bottom-right) to obtain AT     *  - write the rows of A as the columns of AT     *  - write the columns of A as the rows of AT     * Formally, the i th row, j th column element of Aáµ€ is the j th row, i th column element of A.     * If A is an m Ã— n matrix then Aáµ€ is an n Ã— m matrix.     * https://en.wikipedia.org/wiki/Transpose     *     * @return Matrix     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     */    public function transpose(): Matrix    {        if ($this->catalog->hasTranspose()) {            return $this->catalog->getTranspose();        }        $Aáµ€ = [];        for ($i = 0; $i < $this->n; $i++) {            $Aáµ€[$i] = $this->getColumn($i);        }        $this->catalog->addTranspose(MatrixFactory::create($Aáµ€, $this->Îµ));        return $this->catalog->getTranspose();    }    /**     * Submatrix     *     * Return an arbitrary subset of a Matrix as a new Matrix.     *     * @param int $mâ‚ Starting row     * @param int $nâ‚ Starting column     * @param int $mâ‚‚ Ending row     * @param int $nâ‚‚ Ending column     *     * @return Matrix     *     * @throws Exception\MatrixException     */    public function submatrix(int $mâ‚, int $nâ‚, int $mâ‚‚, int $nâ‚‚): Matrix    {        if ($mâ‚ >= $this->m || $mâ‚ < 0 || $mâ‚‚ >= $this->m || $mâ‚‚ < 0) {            throw new Exception\MatrixException('Specified Matrix row does not exist');        }        if ($nâ‚ >= $this->n || $nâ‚ < 0 || $nâ‚‚ >= $this->n || $nâ‚‚ < 0) {            throw new Exception\MatrixException('Specified Matrix column does not exist');        }        if ($mâ‚‚ < $mâ‚) {            throw new Exception\MatrixException('Ending row must be greater than beginning row');        }        if ($nâ‚‚ < $nâ‚) {            throw new Exception\MatrixException('Ending column must be greater than the beginning column');        }        $A = [];        for ($i = 0; $i <= $mâ‚‚ - $mâ‚; $i++) {            for ($j = 0; $j <= $nâ‚‚ - $nâ‚; $j++) {                $A[$i][$j] = $this->A[$i + $mâ‚][$j + $nâ‚];            }        }        return MatrixFactory::create($A, $this->Îµ);    }    /**     * Insert     * Insert a smaller matrix within a larger matrix starting at a specified position     *     * @param Matrix $small the smaller matrix to embed     * @param int    $m     Starting row     * @param int    $n     Starting column     *     * @return Matrix     *     * @throws Exception\MatrixException     */    public function insert(Matrix $small, int $m, int $n): Matrix    {        if ($this->getObjectType() !== $small->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($small->getM() + $m > $this->m || $small->getN() + $n > $this->n) {            throw new Exception\MatrixException('Inner matrix exceeds the bounds of the outer matrix');        }        $new_array = $this->A;        for ($i = 0; $i < $small->getM(); $i++) {            for ($j = 0; $j < $small->getN(); $j++) {                $new_array[$i + $m][$j + $n] = $small[$i][$j];            }        }        return MatrixFactory::create($new_array, $this->Îµ);    }    /**************************************************************************     * MATRIX MAPPING     *  - map     *  - mapRows     **************************************************************************/    /**     * Map a function over all elements of the matrix     *     * @param  callable $func takes a matrix item as input     *     * @return Matrix     *     * @throws Exception\IncorrectTypeException     */    public function map(callable $func): Matrix    {        $m = $this->m;        $n = $this->n;        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $func($this->A[$i][$j]);            }        }        return MatrixFactory::create($R, $this->Îµ);    }    /**     * Map a function over the rows of the matrix     *     * @param callable $func     *     * @return array|array[] Depends on the function     */    public function mapRows(callable $func): array    {        return \array_map(            $func,            $this->A        );    }    /**     * Walk a function over all elements of the matrix     *     * @param callable $func     */    public function walk(callable $func): void    {        $m = $this->m;        $n = $this->n;        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $func($this->A[$i][$j]);            }        }    }    /**************************************************************************     * ROW OPERATIONS - Return a Matrix     *  - rowInterchange     *  - rowExclude     **************************************************************************/    /**     * Interchange two rows     *     * Row máµ¢ changes to position mâ±¼     * Row mâ±¼ changes to position máµ¢     *     * @param int $máµ¢ Row to swap into row position mâ±¼     * @param int $mâ±¼ Row to swap into row position máµ¢     *     * @return Matrix with rows máµ¢ and mâ±¼ interchanged     *     * @throws Exception\MatrixException if row to interchange does not exist     * @throws Exception\IncorrectTypeException     */    public function rowInterchange(int $máµ¢, int $mâ±¼): Matrix    {        if ($máµ¢ >= $this->m || $mâ±¼ >= $this->m) {            throw new Exception\MatrixException('Row to interchange does not exist');        }        $m = $this->m;        $R = [];        for ($i = 0; $i < $m; $i++) {            switch ($i) {                case $máµ¢:                    $R[$i] = $this->A[$mâ±¼];                    break;                case $mâ±¼:                    $R[$i] = $this->A[$máµ¢];                    break;                default:                    $R[$i] = $this->A[$i];            }        }        return MatrixFactory::create($R, $this->Îµ);    }    /**     * Exclude a row from the result matrix     *     * @param int $máµ¢ Row to exclude     *     * @return Matrix with row máµ¢ excluded     *     * @throws Exception\MatrixException if row to exclude does not exist     * @throws Exception\IncorrectTypeException     */    public function rowExclude(int $máµ¢): Matrix    {        if ($máµ¢ >= $this->m || $máµ¢ < 0) {            throw new Exception\MatrixException('Row to exclude does not exist');        }        $m = $this->m;        $R = [];        for ($i = 0; $i < $m; $i++) {            if ($i === $máµ¢) {                continue;            }            $R[$i] = $this->A[$i];        }        return MatrixFactory::create(\array_values($R), $this->Îµ);    }    /**************************************************************************     * COLUMN OPERATIONS - Return a Matrix     *  - columnInterchange     *  - columnExclude     **************************************************************************/    /**     * Interchange two columns     *     * Column náµ¢ changes to position nâ±¼     * Column nâ±¼ changes to position náµ¢     *     * @param int $náµ¢ Column to swap into column position nâ±¼     * @param int $nâ±¼ Column to swap into column position náµ¢     *     * @return Matrix with columns náµ¢ and nâ±¼ interchanged     *     * @throws Exception\MatrixException if column to interchange does not exist     * @throws Exception\IncorrectTypeException     */    public function columnInterchange(int $náµ¢, int $nâ±¼): Matrix    {        if ($náµ¢ >= $this->n || $nâ±¼ >= $this->n) {            throw new Exception\MatrixException('Column to interchange does not exist');        }        $m = $this->m;        $n = $this->n;        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                switch ($j) {                    case $náµ¢:                        $R[$i][$j] = $this->A[$i][$nâ±¼];                        break;                    case $nâ±¼:                        $R[$i][$j] = $this->A[$i][$náµ¢];                        break;                    default:                        $R[$i][$j] = $this->A[$i][$j];                }            }        }        return MatrixFactory::create($R, $this->Îµ);    }    /**     * Exclude a column from the result matrix     *     * @param int $náµ¢ Column to exclude     *     * @return Matrix with column náµ¢ excluded     *     * @throws Exception\MatrixException if column to exclude does not exist     * @throws Exception\IncorrectTypeException     */    public function columnExclude(int $náµ¢): Matrix    {        if ($náµ¢ >= $this->n || $náµ¢ < 0) {            throw new Exception\MatrixException('Column to exclude does not exist');        }        $m = $this->m;        $n = $this->n;        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if ($j === $náµ¢) {                    continue;                }                $R[$i][$j] = $this->A[$i][$j];            }        }        // Reset column indexes        for ($i = 0; $i < $m; $i++) {            $R[$i] = \array_values($R[$i]);        }        return MatrixFactory::create($R, $this->Îµ);    }    /**************************************************************************     * MATRIX OPERATIONS - Return a Matrix     *  - conjugateTranspose     *  - minorMatrix     *  - leadingPrincipalMinor     **************************************************************************/    /**     * Conjugate Transpose - Aá´´, also denoted as A*     *     * Returns the complex conjugate of the transpose. For a real matrix, this is the same as the transpose.     *     * https://en.wikipedia.org/wiki/Conjugate_transpose     *     * @return Matrix     */    public function conjugateTranspose(): Matrix    {        return $this->transpose();    }    /**     * Minor matrix     * Submatrix formed by deleting the iáµ—Ê° row and jáµ—Ê° column.     * Used in computing the minor Máµ¢â±¼.     *     * @param int $máµ¢ Row to exclude     * @param int $nâ±¼ Column to exclude     *     * @return Matrix with row máµ¢ and column nâ±¼ removed     *     * @throws Exception\MatrixException if matrix is not square     * @throws Exception\MatrixException if row to exclude for minor matrix does not exist     * @throws Exception\MatrixException if column to exclude for minor matrix does not exist     * @throws Exception\IncorrectTypeException     */    public function minorMatrix(int $máµ¢, int $nâ±¼): Matrix    {        if (!$this->isSquare()) {            throw new Exception\MatrixException('Matrix is not square; cannot get minor Matrix of a non-square matrix');        }        if ($máµ¢ >= $this->m || $máµ¢ < 0) {            throw new Exception\MatrixException('Row to exclude for minor Matrix does not exist');        }        if ($nâ±¼ >= $this->n || $nâ±¼ < 0) {            throw new Exception\MatrixException('Column to exclude for minor Matrix does not exist');        }        return $this->rowExclude($máµ¢)->columnExclude($nâ±¼);    }    /**     * Leading principal minor     * The leading principal minor of A of order k is the minor of order k     * obtained by deleting the last n âˆ’ k rows and columns.     *     * Example:     *     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     * 1st order (k = 1): [1]     *     *                    [1 2]     * 2nd order (k = 2): [4 5]     *     *                    [1 2 3]     * 3rd order (k = 3): [4 5 6]     *                    [7 8 9]     *     * @param  int $k Order of the leading principal minor     *     * @return Matrix     *     * @throws Exception\OutOfBoundsException if k â‰¤ 0     * @throws Exception\OutOfBoundsException if k > n     * @throws Exception\MatrixException if matrix is not square     * @throws Exception\IncorrectTypeException     */    public function leadingPrincipalMinor(int $k): Matrix    {        if ($k <= 0) {            throw new Exception\OutOfBoundsException(""k is â‰¤ 0: $k"");        }        if ($k > $this->n) {            throw new Exception\OutOfBoundsException(""k ($k) leading principal minor is larger than size of Matrix: "" . $this->n);        }        if (!$this->isSquare()) {            throw new Exception\MatrixException('Matrix is not square; cannot get leading principal minor Matrix of a non-square matrix');        }        $R = [];        for ($i = 0; $i < $k; $i++) {            for ($j = 0; $j < $k; $j++) {                $R[$i][$j] = $this->A[$i][$j];            }        }        return MatrixFactory::create($R, $this->Îµ);    }    /**************************************************************************     * MATRIX OPERATIONS - Return a value     *  - minor     **************************************************************************/    /**     * Minor (first minor)     * The determinant of some smaller square matrix, cut down from A by removing one of its rows and columns.     *     *        [1 4  7]     * If A = [3 0  5]     *        [1 9 11]     *     *                [1 4 -]       [1 4]     * Then Mâ‚â‚‚ = det [- - -] = det [1 9] = 13     *                [1 9 -]     *     * https://en.wikipedia.org/wiki/Minor_(linear_algebra)     *     * @param int $máµ¢ Row to exclude     * @param int $nâ±¼ Column to exclude     *     * @return number     *     * @throws Exception\MatrixException if matrix is not square     * @throws Exception\MatrixException if row to exclude for minor does not exist     * @throws Exception\MatrixException if column to exclude for minor does not exist     * @throws Exception\IncorrectTypeException     * @throws Exception\BadParameterException     */    public function minor(int $máµ¢, int $nâ±¼)    {        if (!$this->isSquare()) {            throw new Exception\MatrixException('Matrix is not square; cannot get minor of a non-square matrix');        }        if ($máµ¢ >= $this->m || $máµ¢ < 0) {            throw new Exception\MatrixException('Row to exclude for minor does not exist');        }        if ($nâ±¼ >= $this->n || $nâ±¼ < 0) {            throw new Exception\MatrixException('Column to exclude for minor does not exist');        }        return $this->minorMatrix($máµ¢, $nâ±¼)->det();    }    /**************************************************************************     * ArrayAccess INTERFACE     **************************************************************************/    /**     * @param mixed $i     * @return bool     */    public function offsetExists($i): bool    {        return isset($this->A[$i]);    }    /**     * @param mixed $i     * @return mixed     */    public function offsetGet($i)    {        return $this->A[$i];    }    /**     * @param  mixed $i     * @param  mixed $value     * @throws Exception\MatrixException     */    public function offsetSet($i, $value)    {        throw new Exception\MatrixException('Matrix class does not allow setting values');    }    /**     * @param  mixed $i     * @throws Exception\MatrixException     */    public function offsetUnset($i)    {        throw new Exception\MatrixException('Matrix class does not allow unsetting values');    }    /**************************************************************************     * JsonSerializable INTERFACE     **************************************************************************/    /**     * @return array     */    public function jsonSerialize()    {        return $this->A;    }}",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3220," PMF multiplication method\\n\\n Evaluate binomial probabilities using a method that avoids unnecessary overflow and underflow\\n Catherine Loader: http://octave.1599824.n4.nabble.com/attachment/3829107/0/loader2000Fast.pdf\\n\\n               x             x   n-x\\n              __  n - x + i __   __\\n p(x; n, p) = ||  --------- || p ||  (1 - p)\\n              â±â¼Â¹     i     â±â¼Â¹  â±â¼Â¹\\n\\n @param int   $r number of successful events\\n @param int   $n number of events\\n @param float $p probability of success\\n\\n @return float\\n",PMF multiplikaciona metoda. Procenite binomnu verovatnoću koristeći metodu koja izbegava nepotrebne preterane i nedovoljne prilagođenosti.,"private function multiplicationMethod(int $r, int $n, float $p): float	{	    if (2 * $r > $n) {	        return $this->multiplicationMethod($n - $r, $n, 1 - $p);	    }		    [$j₀, $j₁, $j₂] = [0, 0, 0];	    $f = 1;		    while (($j₀ < $r) | ($j₁ < $r) | ($j₂ < $n - $r)) {	        if (($j₀ < $r) && ($f < 1)) {	            $j₀++;	            $f *= ($n - $r + $j₀) / $j₀;	        } elseif ($j₁ < $r) {	            $j₁++;	            $f *= $p;	        } else {	            $j₂++;	            $f *= 1 - $p;	        }	    }		    return $f;	}",0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3221, Cumulative distribution function\\n Computes and sums the binomial distribution at each of the values in r.\\n\\n @param  int $r number of successful events\\n\\n @return float\\n,Funkcija kumulativne raspodele. Izračunava i sabira binomnu raspodelu pri svakoj vrednosti od 0 do r.,"    public function cdf(int $r): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['r' => $r]);        $cdf = 0;        for ($i = $r; $i >= 0; $i--) {            $cdf += $this->pmf($i);        }        return $cdf;    }",0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Pascal_3251, Pascal distribution (alias class for negative binomial distribution)\\n https://en.wikipedia.org/wiki/Negative_binomial_distribution\\n,Klasa Paskalne raspodela ( pseudonim klasa za negativnu binomnu raspodelu) https://en.wikipedia.org/wiki/Negative_binomial_distribution,class Pascal extends NegativeBinomial{},0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ANOVA_3433, ANOVA (Analysis of Variance)\n,Klasa za analizu varijansi ANOVA,"class ANOVA{    /**     * One-way ANOVA     * Technique used to compare means of three or more samples     * (using the F distribution).     * https://en.wikipedia.org/wiki/One-way_analysis_of_variance     *     * Produces the following analysis of the data:     *     * ANOVA hypothesis test summary data     *     *           | SS | df | MS | F | P |     * Treatment |    |    |    |   |   |     * Error     |    |    |    |     * Total     |    |    |     *     *  where:     *   Treament is between groups     *   Error is within groups     *   SS = Sum of squares     *   df = Degrees of freedom     *   MS = Mean squares     *   F  = F statistic     *   P  = P value     *     * Data summary table     *     *       | N | Sum | Mean | SS | Variance | SD | SEM |     * 0     |   |     |      |    |          |    |     |     * 1     |   |     |      |    |          |    |     |     * ...   |   |     |      |    |          |    |     |     * Total |   |     |      |    |          |    |     |     *     *  where:     *   Each row is the summary for a sample, numbered from 0 to m - 1     *   m   = Number of samples     *   N   = Sample size     *   SS  = Sum of squares     *   SD  = Standard deviation     *   SEM = Standard error of the mean     *     * Calculations     *     * Sum of Squares     * SST (sum of squares total)     * âˆ‘âŸ®xáµ¢Â âˆ’Â Î¼âŸ¯Â²     *  where:     *   xáµ¢ = each element of all samples     *   Î¼  = mean total of all elements of all samples     *     * SSB (sum of squares between - treatment)     * âˆ‘n(x - Î¼)Â²     *  where:     *   n = sample size     *   x = sample mean     *   Î¼  = mean total of all elements of all samples     *     * SSW (sum of squares within - error)     * âˆ‘âˆ‘âŸ®xáµ¢Â âˆ’Â Î¼âŸ¯Â²  Sum of sum of squared deviations of each sample     *  where:     *   xáµ¢ = each element of the sample     *   Î¼  = mean of the sample     *     * Degrees of Freedom     * dfT (degrees of freedom for the total)     * mn - 1     *     * dfB (degrees of freedom between - treatment)     * m - 1     *     * dfW (degrees of freedom within - error)     * m(n - 1)     *     *  where:     *   m = number of samples     *   n = number of elements in each sample     *     * Mean Squares     * MSB (Mean squares between - treatment)     * SSB / dfB     *     * MSW (Mean squares within - error)     * SSW / dfW     *     * Test Statistics     * F = MSB / MSW     * P = F distribution CDF above F with degrees of freedom dfB and dfW     *     * @param  array[] ...$samples Samples to analyze (at least 3 or more samples)     *     * @return array [     *                 ANOVA => [     *                   treatment => [SS, df, MS, F, P],     *                   error     => [SS, df, MS],     *                   total     => [SS, df],     *                 ],     *                 total_summary => [n, sum, mean, SS, variance, sd, sem],     *                 data_summary  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ]     *               ]     *     * @throws Exception\BadDataException if less than three samples, or if all samples don't have the same number of values     * @throws Exception\OutOfBoundsException     */    public static function oneWay(array ...$samples): array    {        // Must have at least three samples        $m = \count($samples);        if ($m < 3) {            throw new Exception\BadDataException('Must have at least three samples');        }        // All samples must have the same number of items        $n = \count($samples[0]);        for ($i = 1; $i < $m; $i++) {            if (\count($samples[$i]) !== $n) {                throw new Exception\BadDataException('All samples must have the same number of values');            }        }        // Summary data for each sample        $summary_data = [];        foreach ($samples as $i => $sample) {            $summary_data[$i]             = [];            $summary_data[$i]['n']        = $n;            $summary_data[$i]['sum']      = \array_sum($sample);            $summary_data[$i]['mean']     = Average::mean($sample);            $summary_data[$i]['SS']       = RandomVariable::sumOfSquares($sample);            $summary_data[$i]['variance'] = Descriptive::sampleVariance($sample);            $summary_data[$i]['sd']       = Descriptive::sd($sample);            $summary_data[$i]['sem']      = RandomVariable::standardErrorOfTheMean($sample);        }        // Totals summary        $all_elements = \array_reduce(            $samples,            function ($merged, $sample) {                return \array_merge($merged, $sample);            },            array()        );        $Î¼     = Average::mean($all_elements);        $total = [            'n'        => \count($all_elements),            'sum'      => \array_sum($all_elements),            'mean'     => $Î¼,            'SS'       => RandomVariable::sumOfSquares($all_elements),            'variance' => Descriptive::sampleVariance($all_elements),            'sd'       => Descriptive::sd($all_elements),            'sem'      => RandomVariable::standardErrorOfTheMean($all_elements),        ];        // ANOVA sum of squares        $SST = RandomVariable::sumOfSquaresDeviations($all_elements);        $SSB = \array_sum(\array_map(            function ($sample) use ($n, $Î¼) {                return $n * (Average::mean($sample) - $Î¼) ** 2;            },            $samples        ));        $SSW = \array_sum(\array_map(            'MathPHP\Statistics\RandomVariable::sumOfSquaresDeviations',            $samples        ));        // ANOVA degrees of freedom        $dfT = $m * $n - 1;        $dfB = $m - 1;        $dfW = $m * ($n - 1);        // ANOVA mean squares        $MSB = $SSB / $dfB;        $MSW = $SSW / $dfW;        // Test statistics        $F = $MSB / $MSW;        $fDist = new F($dfB, $dfW);        $P = $fDist->above($F);        // Return ANOVA report        return [            'ANOVA' => [                'treatment' => [                    'SS' => $SSB,                    'df' => $dfB,                    'MS' => $MSB,                    'F'  => $F,                    'P'  => $P,                ],                'error' => [                    'SS' => $SSW,                    'df' => $dfW,                    'MS' => $MSW,                ],                'total' => [                    'SS' => $SST,                    'df' => $dfT,                ],            ],            'total_summary' => $total,            'data_summary'  => $summary_data,        ];    }    /**     * Two-way ANOVA     * Examines the influence of two different categorical independent variables on     * one continuous dependent variable. The two-way ANOVA not only aims at assessing     * the main effect of each independent variable but also if there is any interaction     * between them (using the F distribution).     * https://en.wikipedia.org/wiki/Two-way_analysis_of_variance     *     * Produces the following analysis of the data:     *     * ANOVA hypothesis test summary data     *     *             | SS | df | MS | F | P |     * Factor A    |    |    |    |   |   |     * Factor B    |    |    |    |   |   |     * Interaction |    |    |    |   |   |     * Error       |    |    |    |     * Total       |    |    |     *     *  where:     *   Interaction = Factor A X Factor B working together     *   Error is within groups     *   SS = Sum of squares     *   df = Degrees of freedom     *   MS = Mean squares     *   F  = F statistic     *   P  = P value     *     * Data summary tables for:     *   Factor A     *   Factor B     *   Factor AB (Interaction)     *   Total     *     *       | N | Sum | Mean | SS | Variance | SD | SEM |     * 0     |   |     |      |    |          |    |     |     * 1     |   |     |      |    |          |    |     |     * ...   |   |     |      |    |          |    |     |     * Total |   |     |      |    |          |    |     |     *     *  where:     *   Each row is the summary for a sample, numbered from 0 to m - 1     *   m   = Number of samples     *   N   = Sample size     *   SS  = Sum of squares     *   SD  = Standard deviation     *   SEM = Standard error of the mean     *     * Calculations     *     * Sum of Squares     * SST (sum of squares total)     * âˆ‘âŸ®xáµ¢Â âˆ’Â Î¼âŸ¯Â²     *  where:     *   xáµ¢ = each element of all samples     *   Î¼  = mean total of all elements of all samples     *     * SSA, SSB (sum of squares for each factor A and B)     * âˆ‘n(x - Î¼)Â²     *  where:     *   n = sample size     *   x = sample mean     *   Î¼  = mean total of all elements of all samples     *     * SSW (sum of squares within - error)     * âˆ‘âˆ‘âŸ®xÂ âˆ’Â Î¼âŸ¯Â²  Sum of sum of squared deviations of each sample     *  where:     *   x = mean of each AB     *   Î¼ = mean of the sample     *     * SSAB (sum of squares AB - interaction)     * SSAB = SST - SSA - SSB - SSW;     *     * Degrees of Freedom     * dfT (degrees of freedom for the total)     * n - 1     *     * dfA (degrees of freedom factor A)     * r - 1     *     * dfB (degrees of freedom factor B)     * c - 1     *     * dfAB (degrees of freedom factor AB - interaction)     * (r - 1)(c - 1)     *     * dfW (degrees of freedom within - error)     * n - rc     *     *  where:     *   n = number of samples     *   r = number of rows (number of factor As)     *   c = number of columns (number of factor Bs)     *     * Mean Squares     * MSA (Mean squares factor A)     * SSA / dfA     *     * MSB (Mean squares factor B)     * SSB / dfB     *     * MSAB (Mean squares factor AB - interaction)     * SSAB / dfAB     *     * MSW (Mean squares within - error)     * SSW / dfW     *     * F Test Statistics     * FA  = MSA / MSW     * FB  = MSB / MSW     * FAB = MSAB / MSW     *     * P values     * PA  = F distribution CDF above FA with degrees of freedom dfA and dfW     * PB  = F distribution CDF above FB with degrees of freedom dfA and dfW     * PAB = F distribution CDF above FAB with degrees of freedom dfAB and dfW     *     * Example input data for ...$data parameter:     *             | Factor Bâ‚ | Factor Bâ‚‚ | â‹¯     *   Factor Aâ‚ |  4, 6, 8  |  6, 6, 9  | â‹¯     *   Factor Aâ‚‚ |  4, 8, 9  | 7, 10, 13 | â‹¯     *      â‹®           â‹®           â‹®         â‹®     * @param  array[] ...$data Samples to analyze [     *               // Factor Aâ‚     *               [     *                   [4, 6, 8] // Factor Bâ‚     *                   [6, 6, 9] // Factor Bâ‚‚     *                       â‹®     *               ],     *               // Factor Aâ‚‚     *               [     *                   [4, 8, 9]   // Factor Bâ‚     *                   [7, 10, 13] // Factor Bâ‚‚     *                       â‹®     *               ],     *               ...     *         ]     *     * @return array [     *                 ANOVA => [     *                   factorA  => [SS, df, MS, F, P],     *                   factorB  => [SS, df, MS, F, P],     *                   factorAB => [SS, df, MS, F, P],     *                   error    => [SS, df, MS],     *                   total    => [SS, df],     *                 ],     *                 total_summary => [n, sum, mean, SS, variance, sd, sem],     *                 summary_factorA  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ],     *                 summary_factorB  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ],     *                 summary_factorAB  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ]     *               ]     * @throws Exception\BadDataException if less than two A factors, or if B factors or values have different number elements     * @throws Exception\OutOfBoundsException     */    public static function twoWay(array ...$data): array    {        // Must have at least two rows (two types of factor A)        $r = \count($data);        if ($r < 2) {            throw new Exception\BadDataException('Must have at least two rows (two types of factor A)');        }        // All samples must have the same number the second factor B        $c = \count($data[0]);        for ($i = 1; $i < $r; $i++) {            if (\count($data[$i]) !== $c) {                throw new Exception\BadDataException('All samples must have the same number of the second factor B');            }        }        // Each AB factor interaction must have the same number of values        $v = \count($data[0][0]);        for ($i = 0; $i < $r; $i++) {            for ($j = 0; $j < $c; $j++) {                if (\count($data[$i][$j]) !== $v) {                    throw new Exception\BadDataException('Each AB factor interaction must have the same number of values');                }            }        }        // Aggregates for all elements, rows (factor A), and columns (factor B)        $all_elements = [];        $A_elements   = [];        $B_elements   = [];        // Summaries for factor A, factor B, and AB        $summary_A     = [];        $summary_B     = [];        $summary_AB    = [];        // Summary data for each AB        // And aggregate all elements and elements for factor A        foreach ($data as $A => $Bs) {            $A_elements[$A] = [];            foreach ($Bs as $B => $values) {                // Aggregates                $all_elements   = \array_merge($all_elements, $values);                $A_elements[$A] = \array_merge($A_elements[$A], $values);                // AB summary                $summary_AB[$A][$B]             = [];                $summary_AB[$A][$B]['n']        = $c;                $summary_AB[$A][$B]['sum']      = \array_sum($values);                $summary_AB[$A][$B]['mean']     = Average::mean($values);                $summary_AB[$A][$B]['SS']       = RandomVariable::sumOfSquares($values);                $summary_AB[$A][$B]['variance'] = Descriptive::sampleVariance($values);                $summary_AB[$A][$B]['sd']       = Descriptive::sd($values);                $summary_AB[$A][$B]['sem']      = RandomVariable::standardErrorOfTheMean($values);            }        }        // Aggregate elements for factor B        for ($B = 0; $B < $c; $B++) {            $B_elements[$B] = [];            foreach ($data as $factor1s) {                $B_elements[$B] = \array_merge($B_elements[$B], $factor1s[$B]);            }        }        // Factor A summary        foreach ($A_elements as $A => $elements) {            $summary_A[$A]             = [];            $summary_A[$A]['n']        = \count($elements);            $summary_A[$A]['sum']      = \array_sum($elements);            $summary_A[$A]['mean']     = Average::mean($elements);            $summary_A[$A]['SS']       = RandomVariable::sumOfSquares($elements);            $summary_A[$A]['variance'] = Descriptive::sampleVariance($elements);            $summary_A[$A]['sd']       = Descriptive::sd($elements);            $summary_A[$A]['sem']      = RandomVariable::standardErrorOfTheMean($elements);        }        // Factor B summary        foreach ($B_elements as $B => $elements) {            $summary_B[$B]             = [];            $summary_B[$B]['n']        = \count($elements);            $summary_B[$B]['sum']      = \array_sum($elements);            $summary_B[$B]['mean']     = Average::mean($elements);            $summary_B[$B]['SS']       = RandomVariable::sumOfSquares($elements);            $summary_B[$B]['variance'] = Descriptive::sampleVariance($elements);            $summary_B[$B]['sd']       = Descriptive::sd($elements);            $summary_B[$B]['sem']      = RandomVariable::standardErrorOfTheMean($elements);        }        // Totals summary        $Î¼             = Average::mean($all_elements);        $summary_total = [            'n'        => \count($all_elements),            'sum'      => \array_sum($all_elements),            'mean'     => $Î¼,            'SS'       => RandomVariable::sumOfSquares($all_elements),            'variance' => Descriptive::sampleVariance($all_elements),            'sd'       => Descriptive::sd($all_elements),            'sem'      => RandomVariable::standardErrorOfTheMean($all_elements),        ];        // Sum of squares factor A        $SSA = \array_sum(\array_map(            function ($f1) use ($Î¼) {                return $f1['n'] * ($f1['mean'] - $Î¼) ** 2;            },            $summary_A        ));        // Sum of squares factor B        $SSB = \array_sum(\array_map(            function ($B) use ($Î¼) {                return $B['n'] * ($B['mean'] - $Î¼) ** 2;            },            $summary_B        ));        // Sum of squares within (error)        $SSW = 0;        foreach ($data as $A => $Bs) {            foreach ($Bs as $B => $values) {                foreach ($values as $value) {                    $SSW += ($value - $summary_AB[$A][$B]['mean']) ** 2;                }            }        }        // Sum of squares total        $SST = 0;        foreach ($data as $A => $Bs) {            foreach ($Bs as $B => $values) {                foreach ($values as $value) {                    $SST += ($value - $Î¼) ** 2;                }            }        }        // Sum of squares AB interaction        $SSAB = $SST - $SSA - $SSB - $SSW;        // Degrees of freedom        $dfA  = $r - 1;        $dfB  = $c - 1;        $dfAB = ($r - 1) * ($c - 1);        $dfW  = $summary_total['n'] - ($r * $c);        $dfT  = $summary_total['n'] - 1;        // Mean squares        $MSA  = $SSA / $dfA;        $MSB  = $SSB / $dfB;        $MSAB = $SSAB / $dfAB;        $MSW  = $SSW / $dfW;        // F test statistics        $FA  = $MSA / $MSW;        $FB  = $MSB / $MSW;        $FAB = $MSAB / $MSW;        // P values        $fDist1 = new F($dfA, $dfW);        $fDist2 = new F($dfB, $dfW);        $fDist3 = new F($dfAB, $dfW);        $PA  = $fDist1->above($FA);        $PB  = $fDist2->above($FB);        $PAB = $fDist3->above($FAB);        // Return ANOVA report        return [            'ANOVA' => [                'factorA' => [                    'SS' => $SSA,                    'df' => $dfA,                    'MS' => $MSA,                    'F'  => $FA,                    'P'  => $PA,                ],                'factorB' => [                    'SS' => $SSB,                    'df' => $dfB,                    'MS' => $MSB,                    'F'  => $FB,                    'P'  => $PB,                ],                'interaction' => [                    'SS' => $SSAB,                    'df' => $dfAB,                    'MS' => $MSAB,                    'F'  => $FAB,                    'P'  => $PAB,                ],                'error' => [                    'SS' => $SSW,                    'df' => $dfW,                    'MS' => $MSW,                ],                'total' => [                    'SS' => $SST,                    'df' => $dfT,                ],            ],            'total_summary'       => $summary_total,            'summary_factorA'     => $summary_A,            'summary_factorB'     => $summary_B,            'summary_interaction' => $summary_AB,        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LinearThroughPoint_3579," Linear Regression Through a Fixed Point - least squares method\n\n A model with a single explanatory variable.\n Fits a straight line through the set of n points in such a way that makes\n the sum of squared residuals of the model (that is, vertical distances\n between the points of the data set and the fitted line) as small as possible.\n https://en.wikipedia.org/wiki/Simple_linear_regression\n\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\n Find the equation y = mx + b\n such that the line passes through the point (v,w)\n\n      âˆ‘((x-v)(y-w))\n m =  _____________\n\n         âˆ‘(x-v)Â²\n\n b = w - m ",Linearna regresija kroz fiksnu tačku - metoda najmanjih kvadrata. Model sa jednom promenljivom obješnjenje. Pronalazi linearnu funkciju koja prolazi kroz skup od n tačaka na takav način da je prosečna vrednost kvadrata odstupanja minimalna (odstupanje je razlika između stvarne izlazne vrednosti podataka za obučavanje i vrednosti koja predviđa linearna funkcija).,"class LinearThroughPoint extends ParametricRegression{    use Methods\LeastSquares;    use Models\LinearModel;    /** @var float */    private $v;    /** @var float */    private $w;    /**     * Given a set of data ($points) and a point($force), perform a least squares     * regression of the data, such that the regression is forced to pass through     * the specified point.     *     * This procedure is most frequently used with $force = [0,0], the origin.     *     * @param array $points     * @param array $force Point to force regression line through (default: origin)     */    public function __construct(array $points, array $force = [0,0])    {        $this->v = $force[0];        $this->w = $force[1];        parent::__construct($points);    }    /**     * Calculates the regression parameters.     *     * @throws \MathPHP\Exception\BadDataException     * @throws \MathPHP\Exception\IncorrectTypeException     * @throws \MathPHP\Exception\MatrixException     * @throws \MathPHP\Exception\MathException     */    public function calculate(): void    {        $v = $this->v;        $w = $this->w;        $xâ€™ = Single::subtract($this->xs, $v);        $yâ€™ = Single::subtract($this->ys, $w);        $parameters = $this->leastSquares($yâ€™, $xâ€™, 1, 0)->getColumn(0);        $m = $parameters[0];        $b = $this->w - $m * $this->v;        $this->parameters = [$b, $m];    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LinearThroughPoint_3580, Calculates the regression parameters.\\n\\n @throws \\\\MathPHP\\\\Exception\\\\BadDataException\\n @throws \\\\MathPHP\\\\Exception\\\\IncorrectTypeException\\n @throws \\\\MathPHP\\\\Exception\\\\MatrixException\\n @throws \\\\MathPHP\\\\Exception\\\\MathException\\n,Izračunaj parametre regresije.,"    public function calculate(): void    {        $v = $this->v;        $w = $this->w;        $xâ€™ = Single::subtract($this->xs, $v);        $yâ€™ = Single::subtract($this->ys, $w);        $parameters = $this->leastSquares($yâ€™, $xâ€™, 1, 0)->getColumn(0);        $m = $parameters[0];        $b = $this->w - $m * $this->v;        $this->parameters = [$b, $m];    }",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Linear_3577, Calculates the regression parameters.\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MatrixException\n @throws Exception\\MathException\n,Izračunaj parametre regresije.,"    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs)->getColumn(0);    }",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LineweaverBurk_3583, Calculate the regression parameters by least squares on linearized data\n yâ»Â¹ = K \n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MatrixException\n @throws Exception\\MathException\n,Izračunajte parametre regresije za najmanje kvadrate na linearizovanim podacima.,"public function calculate(): void	{	    // Linearize the relationship by taking the inverse of both x and y	    $x’ = Single::pow($this->xs, -1);	    $y’ = Single::pow($this->ys, -1);		    // Perform Least Squares Fit	    $linearized_parameters = $this->leastSquares($y’, $x’)->getColumn(0);		    // Translate the linearized parameters back.	    $V = 1 / $linearized_parameters[0];	    $K = $linearized_parameters[1] * $V;		    $this->parameters = [$V, $K];	}",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LineweaverBurk_3584, Evaluate the regression equation at x\\n Uses the instance model's evaluateModel method.\\n\\n @param  float $x\\n\\n @return float\\n,Procenite regresionu jednačinu u k. Koristi instancu metode modela evaulateMethod,"    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ParametricRegression_3585, Have the parent separate the points into xs and ys.\\n Calculate the regression parameters\\n\\n @param float[] $points\\n,Pokreni izračunavanje parametara regresije nakon sto nadklasa razdvoji izlazne i ulazne vrednosti skupa za treniranje. ,    public function __construct(array $points)    {        parent::__construct($points);        $this->calculate();    },0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_WeightedLinear_3603," Weighted linear regression - least squares method\\n\\n A model with a single explanatory variable.\\n Fits a straight line through the set of n points in such a way that makes\\n the sum of squared residuals of the model (that is, vertical distances\\n between the points of the data set and the fitted line) as small as possible.\\n https://en.wikipedia.org/wiki/Simple_linear_regression\\n\\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\\n Find the equation y = mx + b\\n\\n",Ponderisana linearna regresija - metoda njamanjih kvadrata. Model sa jednom promenljivom obješnjenje. Pronalazi linearnu funkciju koja prolazi kroz skup od n tačaka na takav način da je prosečna vrednost kvadrata odstupanja minimalna (odstupanje je razlika između stvarne izlazne vrednosti podataka za obučavanje i vrednosti koja predviđa linearna funkcija).,"class WeightedLinear extends ParametricRegression{    use Models\LinearModel;    use Methods\WeightedLeastSquares;    /**     * Array of weights     * @var array     */    private $ws;    /**     * @param array $points     * @param array $ws     Weights     */    public function __construct(array $points, array $ws)    {        $this->ws = $ws;        parent::__construct($points);    }    /**     * Calculates the regression parameters.     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     */    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs, $this->ws)->getColumn(0);    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_761, Class AccessCore.\\\\n,Klasa AccessCore.,"class AccessCore extends ObjectModel{    /** @var int Profile id which address belongs to */    public $id_profile = null;    /** @var int AuthorizationRole id which address belongs to */    public $id_authorization_role = null;    /**     * @see ObjectModel::$definition     */    public static $definition = [        'table' => 'access',        'primary' => 'id_profile',        'fields' => [            'id_profile' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_authorization_role' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],        ],    ];    /**     * Is access granted to this Role?     *     * @param string $role Role name (""Superadministrator"", ""sales"", ""translator"", etc.)     * @param int $idProfile Profile ID     *     * @return bool Whether access is granted     *     * @throws Exception     */    public static function isGranted($role, $idProfile)    {        foreach ((array) $role as $currentRole) {            preg_match(                '/ROLE_MOD_(?P<type>[A-Z]+)_(?P<name>[A-Z0-9_]+)_(?P<auth>[A-Z]+)/',                $currentRole,                $matches            );            if (isset($matches['type']) && $matches['type'] == 'TAB') {                $joinTable = _DB_PREFIX_ . 'access';            } elseif (isset($matches['type']) && $matches['type'] == 'MODULE') {                $joinTable = _DB_PREFIX_ . 'module_access';            } else {                throw new Exception('The slug ' . $currentRole . ' is invalid');            }            $currentRole = Db::getInstance()->escape($currentRole);            $isCurrentGranted = (bool) Db::getInstance()->getRow('                SELECT t.`id_authorization_role`                FROM `' . _DB_PREFIX_ . 'authorization_role` t                LEFT JOIN ' . $joinTable . ' j                ON j.`id_authorization_role` = t.`id_authorization_role`                WHERE `slug` = ""' . $currentRole . '""                AND j.`id_profile` = ""' . (int) $idProfile . '""            ');            if (!$isCurrentGranted) {                return false;            }        }        return true;    }    /**     * Get all roles for the Profile ID.     *     * @param int $idProfile Profile ID     *     * @return array Roles     */    public static function getRoles($idProfile)    {        $idProfile = (int) $idProfile;        $accesses = Db::getInstance()->executeS('            SELECT r.`slug`            FROM `' . _DB_PREFIX_ . 'authorization_role` r            INNER JOIN `' . _DB_PREFIX_ . 'access` a ON a.`id_authorization_role` = r.`id_authorization_role`            WHERE a.`id_profile` = ""' . $idProfile . '""        ');        $accessesFromModules = Db::getInstance()->executeS('            SELECT r.`slug`            FROM `' . _DB_PREFIX_ . 'authorization_role` r            INNER JOIN `' . _DB_PREFIX_ . 'module_access` ma ON ma.`id_authorization_role` = r.`id_authorization_role`            WHERE ma.`id_profile` = ""' . $idProfile . '""        ');        $roles = array_merge($accesses, $accessesFromModules);        foreach ($roles as $key => $role) {            $roles[$key] = $role['slug'];        }        return $roles;    }    /**     * Find Tab ID by slug.     *     * @param string $authSlug Slug     *     * @return string Tab ID     * @todo: Find out if we should return an int instead. (breaking change)     */    public static function findIdTabByAuthSlug($authSlug)    {        preg_match(            '/ROLE_MOD_[A-Z]+_(?P<classname>[A-Z]+)_(?P<auth>[A-Z]+)/',            $authSlug,            $matches        );        $result = Db::getInstance()->getRow('            SELECT `id_tab`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE UCASE(`class_name`) = ""' . $matches['classname'] . '""        ');        return $result['id_tab'];    }    /**     * Find slug by Tab ID.     *     * @param int $idTab Tab ID     *     * @return string Full module slug     */    public static function findSlugByIdTab($idTab)    {        $result = Db::getInstance()->getRow('            SELECT `class_name`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE `id_tab` = ""' . (int) $idTab . '""        ');        return self::sluggifyTab($result);    }    /**     * Find slug by Parent Tab ID.     *     * @param int $idParentTab Tab ID     *     * @return string Full module slug     */    public static function findSlugByIdParentTab($idParentTab)    {        return Db::getInstance()->executeS('            SELECT `class_name`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE `id_parent` = ""' . (int) $idParentTab . '""        ');    }    /**     * Find slug by Module ID.     *     * @param int $idModule Module ID     *     * @return string Full module slug     */    public static function findSlugByIdModule($idModule)    {        $result = Db::getInstance()->getRow('            SELECT `name`            FROM `' . _DB_PREFIX_ . 'module`            WHERE `id_module` = ""' . (int) $idModule . '""        ');        return self::sluggifyModule($result);    }    /**     * Sluggify tab.     *     * @param string $tab Tab class name     * @param string $authorization 'CREATE'|'READ'|'UPDATE'|'DELETE'     *     * @return string Full slug for tab     */    public static function sluggifyTab($tab, $authorization = '')    {        return sprintf('ROLE_MOD_TAB_%s_%s', strtoupper($tab['class_name']), $authorization);    }    /**     * Sluggify module.     *     * @param string $module Module name     * @param string $authorization 'CREATE'|'READ'|'UPDATE'|'DELETE'     *     * @return string Full slug for module     */    public static function sluggifyModule($module, $authorization = '')    {        return sprintf('ROLE_MOD_MODULE_%s_%s', strtoupper($module['name']), $authorization);    }    /**     * Get legacy authorization.     *     * @param string $legacyAuth Legacy authorization     *     * @return bool|string|array Authorization     */    public static function getAuthorizationFromLegacy($legacyAuth)    {        $auth = [            'add' => 'CREATE',            'view' => 'READ',            'edit' => 'UPDATE',            'configure' => 'UPDATE',            'delete' => 'DELETE',            'uninstall' => 'DELETE',            'duplicate' => ['CREATE', 'UPDATE'],            'all' => ['CREATE', 'READ', 'UPDATE', 'DELETE'],        ];        return isset($auth[$legacyAuth]) ? $auth[$legacyAuth] : false;    }    /**     * Add access.     *     * @param int $idProfile Profile ID     * @param int $idRole Role ID     *     * @return string Whether access has been successfully granted (""ok"", ""error"")     */    public function addAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }    /**     * Remove access.     *     * @param int $idProfile Profile ID     * @param int $idRole Role ID     *     * @return string Whether access has been successfully removed (""ok"", ""error"")     */    public function removeAccess($idProfile, $idRole)    {        $sql = '            DELETE FROM `' . _DB_PREFIX_ . 'access`            WHERE `id_profile` = ""' . (int) $idProfile . '""            AND `id_authorization_role` = ""' . (int) $idRole . '""        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }    /**     * Add module access.     *     * @param int $idProfile Profile ID     * @param int $idRole Role ID     *     * @return string Whether module access has been successfully granted (""ok"", ""error"")     */    public function addModuleAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'module_access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }    /**     * @param int $idProfile     * @param int $idRole     *     * @return string 'ok'|'error'     */    public function removeModuleAccess($idProfile, $idRole)    {        $sql = '            DELETE FROM `' . _DB_PREFIX_ . 'module_access`            WHERE `id_profile` = ""' . (int) $idProfile . '""            AND `id_authorization_role` = ""' . (int) $idRole . '""        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }    /**     * Update legacy access.     *     * @param int $idProfile Profile ID     * @param int $idTab Tab ID     * @param string $lgcAuth Legacy authorization     * @param int $enabled Whether access should be granted     * @param int $addFromParent Child from parents     *     * @return string Whether legacy access has been successfully updated (""ok"", ""error"")     *     * @throws Exception     */    public function updateLgcAccess($idProfile, $idTab, $lgcAuth, $enabled, $addFromParent = 0)    {        $idProfile = (int) $idProfile;        $idTab = (int) $idTab;        if ($idTab == -1) {            $slug = 'ROLE_MOD_TAB_%_';        } else {            $slug = self::findSlugByIdTab($idTab);        }        $whereClauses = [];        foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {            $slugLike = Db::getInstance()->escape($slug . $auth);            $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';        }        if ($addFromParent == 1) {            foreach (self::findSlugByIdParentTab($idTab) as $child) {                $child = self::sluggifyTab($child);                foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {                    $slugLike = Db::getInstance()->escape($child . $auth);                    $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';                }            }        }        $roles = Db::getInstance()->executeS('            SELECT `id_authorization_role`            FROM `' . _DB_PREFIX_ . 'authorization_role` t            WHERE ' . implode(' OR ', $whereClauses) . '        ');        if (empty($roles)) {            throw new \Exception('Cannot find role slug');        }        $res = [];        foreach ($roles as $role) {            if ($enabled) {                $res[] = $this->addAccess($idProfile, $role['id_authorization_role']);            } else {                $res[] = $this->removeAccess($idProfile, $role['id_authorization_role']);            }        }        return in_array('error', $res) ? 'error' : 'ok';    }    /**     * Update (legacy) Module access.     *     * @param int $idProfile Profile ID     * @param int $idModule Module ID     * @param string $lgcAuth Legacy authorization     * @param int $enabled Whether module access should be granted     *     * @return string Whether module access has been succesfully changed (""ok"", ""error"")     */    public function updateLgcModuleAccess($idProfile, $idModule, $lgcAuth, $enabled)    {        $idProfile = (int) $idProfile;        $idModule = (int) $idModule;        if ($idModule == -1) {            $slug = 'ROLE_MOD_MODULE_%_';        } else {            $slug = self::findSlugByIdModule($idModule);        }        $whereClauses = [];        foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {            $slugLike = Db::getInstance()->escape($slug . $auth);            $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';        }        $roles = Db::getInstance()->executeS('            SELECT `id_authorization_role`            FROM `' . _DB_PREFIX_ . 'authorization_role` t            WHERE ' . implode(' OR ', $whereClauses) . '        ');        $res = [];        foreach ($roles as $role) {            if ($enabled) {                $res[] = $this->addModuleAccess($idProfile, $role['id_authorization_role']);            } else {                $res[] = $this->removeModuleAccess($idProfile, $role['id_authorization_role']);            }        }        return in_array('error', $res) ? 'error' : 'ok';    }}",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_762," Is access granted to this Role?\\\\n\\\\n @param string $role Role name (""Superadministrator"", ""sales"", ""translator"", etc.)\\\\n @param int $idProfile Profile ID\\\\n\\\\n @return bool Whether access is granted\\\\n\\\\n @throws Exception\\\\n",Da li je pravo pristupa dodeljeno datom objektu uloge.,"    public static function isGranted($role, $idProfile)    {        foreach ((array) $role as $currentRole) {            preg_match(                '/ROLE_MOD_(?P<type>[A-Z]+)_(?P<name>[A-Z0-9_]+)_(?P<auth>[A-Z]+)/',                $currentRole,                $matches            );            if (isset($matches['type']) && $matches['type'] == 'TAB') {                $joinTable = _DB_PREFIX_ . 'access';            } elseif (isset($matches['type']) && $matches['type'] == 'MODULE') {                $joinTable = _DB_PREFIX_ . 'module_access';            } else {                throw new Exception('The slug ' . $currentRole . ' is invalid');            }            $currentRole = Db::getInstance()->escape($currentRole);            $isCurrentGranted = (bool) Db::getInstance()->getRow('                SELECT t.`id_authorization_role`                FROM `' . _DB_PREFIX_ . 'authorization_role` t                LEFT JOIN ' . $joinTable . ' j                ON j.`id_authorization_role` = t.`id_authorization_role`                WHERE `slug` = ""' . $currentRole . '""                AND j.`id_profile` = ""' . (int) $idProfile . '""            ');            if (!$isCurrentGranted) {                return false;            }        }        return true;    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_763, Get all roles for the Profile ID.\\\\n\\\\n @param int $idProfile Profile ID\\\\n\\\\n @return array Roles\\\\n,Dohvati sve uloge na osnovu jedinstvenog indentifikatora profila.,"    public static function getRoles($idProfile)    {        $idProfile = (int) $idProfile;        $accesses = Db::getInstance()->executeS('            SELECT r.`slug`            FROM `' . _DB_PREFIX_ . 'authorization_role` r            INNER JOIN `' . _DB_PREFIX_ . 'access` a ON a.`id_authorization_role` = r.`id_authorization_role`            WHERE a.`id_profile` = ""' . $idProfile . '""        ');        $accessesFromModules = Db::getInstance()->executeS('            SELECT r.`slug`            FROM `' . _DB_PREFIX_ . 'authorization_role` r            INNER JOIN `' . _DB_PREFIX_ . 'module_access` ma ON ma.`id_authorization_role` = r.`id_authorization_role`            WHERE ma.`id_profile` = ""' . $idProfile . '""        ');        $roles = array_merge($accesses, $accessesFromModules);        foreach ($roles as $key => $role) {            $roles[$key] = $role['slug'];        }        return $roles;    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_765, Find slug by Tab ID.\n\n @param int $idTab Tab ID\n\n @return string Full module slug\n,Pronađi deo url adrese na osnovu identifikatora tabulara.,"    public static function findSlugByIdTab($idTab)    {        $result = Db::getInstance()->getRow('            SELECT `class_name`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE `id_tab` = ""' . (int) $idTab . '""        ');        return self::sluggifyTab($result);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_766, Find slug by Parent Tab ID.\\\\n\\\\n @param int $idParentTab Tab ID\\\\n\\\\n @return string Full module slug\\\\n,Pronađi deo url adrese na osnovu identifikatora roditelj tabulara.,"    public static function findSlugByIdParentTab($idParentTab)    {        return Db::getInstance()->executeS('            SELECT `class_name`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE `id_parent` = ""' . (int) $idParentTab . '""        ');    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_767, Find slug by Module ID.\\\\\\\\n\\\\\\\\n @param int $idModule Module ID\\\\\\\\n\\\\\\\\n @return string Full module slug\\\\\\\\n,Pronađi deo adrese na osnovu identifikatora modula,"    public static function findSlugByIdModule($idModule)    {        $result = Db::getInstance()->getRow('            SELECT `name`            FROM `' . _DB_PREFIX_ . 'module`            WHERE `id_module` = ""' . (int) $idModule . '""        ');        return self::sluggifyModule($result);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_768, Get legacy authorization.\\\\\\\\n\\\\\\\\n @param string $legacyAuth Legacy authorization\\\\\\\\n\\\\\\\\n @return bool|string|array Authorization\\\\\\\\n,Dohvati nasleđeno ovlašćenje.,"    public static function getAuthorizationFromLegacy($legacyAuth)    {        $auth = [            'add' => 'CREATE',            'view' => 'READ',            'edit' => 'UPDATE',            'configure' => 'UPDATE',            'delete' => 'DELETE',            'uninstall' => 'DELETE',            'duplicate' => ['CREATE', 'UPDATE'],            'all' => ['CREATE', 'READ', 'UPDATE', 'DELETE'],        ];        return isset($auth[$legacyAuth]) ? $auth[$legacyAuth] : false;    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_MediaTest_988, Add section media element\\n,Dodaj element za medij odeljka. ,"    public function testAddSectionMediaElement()    {        $local = __DIR__ . '/_files/images/mars.jpg';        $object = __DIR__ . '/_files/documents/sheet.xls';        $remote = self::getRemoteImageUrl();        Media::addElement('section', 'image', $local, new Image($local));        Media::addElement('section', 'image', $local, new Image($local));        Media::addElement('section', 'image', $remote, new Image($local));        Media::addElement('section', 'object', $object);        Media::addElement('section', 'object', $object);        $this->assertCount(3, Media::getElements('section'));    }",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_774, Class AddressCore.\\\\n,Klasa AddressCore,"class AddressCore extends ObjectModel{    /** @var int Customer ID which address belongs to */    public $id_customer = null;    /** @var int Manufacturer ID which address belongs to */    public $id_manufacturer = null;    /** @var int Supplier ID which address belongs to */    public $id_supplier = null;    /**     * @since 1.5.0     *     * @var int Warehouse ID which address belongs to     */    public $id_warehouse = null;    /** @var int Country ID */    public $id_country;    /** @var int State ID */    public $id_state;    /** @var string Country name */    public $country;    /** @var string Alias (eg. Home, Work...) */    public $alias;    /** @var string Company (optional) */    public $company;    /** @var string Lastname */    public $lastname;    /** @var string Firstname */    public $firstname;    /** @var string Address first line */    public $address1;    /** @var string Address second line (optional) */    public $address2;    /** @var string Postal code */    public $postcode;    /** @var string City */    public $city;    /** @var string Any other useful information */    public $other;    /** @var string Phone number */    public $phone;    /** @var string Mobile phone number */    public $phone_mobile;    /** @var string VAT number */    public $vat_number;    /** @var string DNI number */    public $dni;    /** @var string Object creation date */    public $date_add;    /** @var string Object last modification date */    public $date_upd;    /** @var bool True if address has been deleted (staying in database as deleted) */    public $deleted = 0;    /** @var array Zone IDs cache */    protected static $_idZones = [];    /** @var array Country IDs cache */    protected static $_idCountries = [];    /**     * @see ObjectModel::$definition     */    // when you override this class, do not create a field with allow_null=>true    // because it will give you exception on checkout address step    public static $definition = [        'table' => 'address',        'primary' => 'id_address',        'fields' => [            'id_customer' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_manufacturer' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_supplier' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_warehouse' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_country' => ['type' => self::TYPE_INT, 'validate' => 'isUnsignedId', 'required' => true],            'id_state' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId'],            'alias' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName', 'required' => true, 'size' => 32],            'company' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName', 'size' => 255],            'lastname' => ['type' => self::TYPE_STRING, 'validate' => 'isName', 'required' => true, 'size' => 255],            'firstname' => ['type' => self::TYPE_STRING, 'validate' => 'isName', 'required' => true, 'size' => 255],            'vat_number' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName'],            'address1' => ['type' => self::TYPE_STRING, 'validate' => 'isAddress', 'required' => true, 'size' => 128],            'address2' => ['type' => self::TYPE_STRING, 'validate' => 'isAddress', 'size' => 128],            'postcode' => ['type' => self::TYPE_STRING, 'validate' => 'isPostCode', 'size' => 12],            'city' => ['type' => self::TYPE_STRING, 'validate' => 'isCityName', 'required' => true, 'size' => 64],            'other' => ['type' => self::TYPE_STRING, 'validate' => 'isMessage', 'size' => 300],            'phone' => ['type' => self::TYPE_STRING, 'validate' => 'isPhoneNumber', 'size' => 32],            'phone_mobile' => ['type' => self::TYPE_STRING, 'validate' => 'isPhoneNumber', 'size' => 32],            'dni' => ['type' => self::TYPE_STRING, 'validate' => 'isDniLite', 'size' => 16],            'deleted' => ['type' => self::TYPE_BOOL, 'validate' => 'isBool', 'copy_post' => false],            'date_add' => ['type' => self::TYPE_DATE, 'validate' => 'isDate', 'copy_post' => false],            'date_upd' => ['type' => self::TYPE_DATE, 'validate' => 'isDate', 'copy_post' => false],        ],    ];    /** @var array Web service parameters */    protected $webserviceParameters = [        'objectsNodeName' => 'addresses',        'fields' => [            'id_customer' => ['xlink_resource' => 'customers'],            'id_manufacturer' => ['xlink_resource' => 'manufacturers'],            'id_supplier' => ['xlink_resource' => 'suppliers'],            'id_warehouse' => ['xlink_resource' => 'warehouse'],            'id_country' => ['xlink_resource' => 'countries'],            'id_state' => ['xlink_resource' => 'states'],        ],    ];    /**     * Build an Address.     *     * @param int $id_address Existing Address ID in order to load object (optional)     */    public function __construct($id_address = null, $id_lang = null)    {        parent::__construct($id_address);        /* Get and cache address country name */        if ($this->id) {            $this->country = Country::getNameById($id_lang ? $id_lang : Configuration::get('PS_LANG_DEFAULT'), $this->id_country);        }    }    /**     * reset static cache (eg unit testing purpose).     */    public static function resetStaticCache()    {        static::$_idZones = [];        static::$_idCountries = [];    }    /**     * @see ObjectModel::add()     */    public function add($autodate = true, $null_values = false)    {        if (!parent::add($autodate, $null_values)) {            return false;        }        if (Validate::isUnsignedId($this->id_customer)) {            Customer::resetAddressCache($this->id_customer, $this->id);        }        return true;    }    /**     * @see ObjectModel::update()     */    public function update($null_values = false)    {        // Empty related caches        if (isset(self::$_idCountries[$this->id])) {            unset(self::$_idCountries[$this->id]);        }        if (isset(self::$_idZones[$this->id])) {            unset(self::$_idZones[$this->id]);        }        if (Validate::isUnsignedId($this->id_customer)) {            Customer::resetAddressCache($this->id_customer, $this->id);        }        /* Skip the required fields */        if ($this->isUsed()) {            self::$fieldsRequiredDatabase['Address'] = [];        }        return parent::update($null_values);    }    /**     * @see ObjectModel::delete()     */    public function delete()    {        if (Validate::isUnsignedId($this->id_customer)) {            Customer::resetAddressCache($this->id_customer, $this->id);        }        if (!$this->isUsed()) {            $this->deleteCartAddress();            return parent::delete();        } else {            $this->deleted = true;            return $this->update();        }    }    /**     * removes the address from carts using it, to avoid errors on not existing address     */    protected function deleteCartAddress()    {        // keep pending carts, but unlink it from current address        $sql = 'UPDATE ' . _DB_PREFIX_ . 'cart                    SET id_address_delivery = 0                    WHERE id_address_delivery = ' . $this->id;        Db::getInstance()->execute($sql);        $sql = 'UPDATE ' . _DB_PREFIX_ . 'cart                    SET id_address_invoice = 0                    WHERE id_address_invoice = ' . $this->id;        Db::getInstance()->execute($sql);    }    /**     * Returns fields required for an address in an array hash.     *     * @return array Hash values     */    public static function getFieldsValidate()    {        $tmp_addr = new Address();        $out = $tmp_addr->fieldsValidate;        unset($tmp_addr);        return $out;    }    /**     * Get Zone ID for a given address.     *     * @param int $id_address Address ID for which we want to get the Zone ID     *     * @return int Zone ID     */    public static function getZoneById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        if (isset(self::$_idZones[$id_address])) {            return self::$_idZones[$id_address];        }        $id_zone = Hook::exec('actionGetIDZoneByAddressID', ['id_address' => $id_address]);        if (is_numeric($id_zone)) {            self::$_idZones[$id_address] = (int) $id_zone;            return self::$_idZones[$id_address];        }        $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT s.`id_zone` AS id_zone_state, c.`id_zone`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`LEFT JOIN `' . _DB_PREFIX_ . 'state` s ON s.`id_state` = a.`id_state`WHERE a.`id_address` = ' . (int) $id_address);        if (empty($result['id_zone_state']) && empty($result['id_zone'])) {            return false;        }        self::$_idZones[$id_address] = !empty($result['id_zone_state'])            ? (int) $result['id_zone_state']            : (int) $result['id_zone'];        return self::$_idZones[$id_address];    }    /**     * Check if the Country is active for a given address.     *     * @param int $id_address Address ID for which we want to get the Country status     *     * @return int Country status     */    public static function isCountryActiveById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        $cache_id = 'Address::isCountryActiveById_' . (int) $id_address;        if (!Cache::isStored($cache_id)) {            $result = (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT c.`active`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`WHERE a.`id_address` = ' . (int) $id_address);            Cache::store($cache_id, $result);            return $result;        }        return Cache::retrieve($cache_id);    }    /**     * {@inheritdoc}     */    public function validateField($field, $value, $id_lang = null, $skip = [], $human_errors = false)    {        $error = parent::validateField($field, $value, $id_lang, $skip, $human_errors);        if (true !== $error || 'dni' !== $field) {            return $error;        }        // Special validation for dni, check if the country needs it        if (!$this->deleted && static::dniRequired((int) $this->id_country) && Tools::isEmpty($value)) {            if ($human_errors) {                return $this->trans(                    'The %s field is required.',                    [$this->displayFieldName($field, get_class($this))],                    'Admin.Notifications.Error'                );            }            return $this->trans(                'Property %s is empty.',                [get_class($this) . '->' . $field],                'Admin.Notifications.Error'            );        }        return true;    }    /**     * Request to check if DNI field is required     * depending on the current selected country.     *     * @param int $idCountry     *     * @return bool     */    public static function dniRequired($idCountry)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT c.`need_identification_number` ' .            'FROM `' . _DB_PREFIX_ . 'country` c ' .            'WHERE c.`id_country` = ' . (int) $idCountry        );    }    /**     * Check if Address is used (at least one order placed).     *     * @return int Order count for this Address     */    public function isUsed()    {        if ((int) $this->id <= 0) {            return false;        }        $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT COUNT(`id_order`) AS usedFROM `' . _DB_PREFIX_ . 'orders`WHERE `id_address_delivery` = ' . (int) $this->id . 'OR `id_address_invoice` = ' . (int) $this->id);        return $result > 0 ? (int) $result : false;    }    /**     * Get Country and State of this Address.     *     * @param int $id_address Address ID     *     * @return array     */    public static function getCountryAndState($id_address)    {        if (isset(self::$_idCountries[$id_address])) {            return self::$_idCountries[$id_address];        }        if ($id_address) {            $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT `id_country`, `id_state`, `vat_number`, `postcode` FROM `' . _DB_PREFIX_ . 'address`WHERE `id_address` = ' . (int) $id_address);        } else {            $result = false;        }        self::$_idCountries[$id_address] = $result;        return $result;    }    /**     * Specify if an address is already in base.     *     * @param int $id_address Address id     *     * @return bool The address exists     */    public static function addressExists($id_address)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT `id_address`             FROM ' . _DB_PREFIX_ . 'address a             WHERE a.`id_address` = ' . (int) $id_address,            false        );    }    /**     * Check if the address is valid.     *     * @param int $id_address Address id     *     * @return bool The address is valid     */    public static function isValid($id_address)    {        $id_address = (int) $id_address;        $isValid = Db::getInstance()->getValue('            SELECT `id_address` FROM ' . _DB_PREFIX_ . 'address a            WHERE a.`id_address` = ' . $id_address . ' AND a.`deleted` = 0 AND a.`active` = 1        ');        return (bool) $isValid;    }    /**     * Get the first address id of the customer.     *     * @param int $id_customer Customer id     * @param bool $active Active addresses only     *     * @return bool|int|null     */    public static function getFirstCustomerAddressId($id_customer, $active = true)    {        if (!$id_customer) {            return false;        }        $cache_id = 'Address::getFirstCustomerAddressId_' . (int) $id_customer . '-' . (bool) $active;        if (!Cache::isStored($cache_id)) {            $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(                'SELECT `id_address`FROM `' . _DB_PREFIX_ . 'address`WHERE `id_customer` = ' . (int) $id_customer . ' AND `deleted` = 0' . ($active ? ' AND `active` = 1' : '')            );            Cache::store($cache_id, $result);            return $result;        }        return Cache::retrieve($cache_id);    }    /**     * Initialize an address corresponding to the specified id address or if empty to the     * default shop configuration.     *     * @param int $id_address     * @param bool $with_geoloc     *     * @return Address address     *     * @throws PrestaShopException     */    public static function initialize($id_address = null, $with_geoloc = false)    {        $context = Context::getContext();        if ($id_address) {            $context_hash = (int) $id_address;        } elseif ($with_geoloc && isset($context->customer->geoloc_id_country)) {            $context_hash = md5((int) $context->customer->geoloc_id_country . '-' . (int) $context->customer->id_state . '-' .                                $context->customer->postcode);        } else {            $context_hash = md5((int) $context->country->id);        }        $cache_id = 'Address::initialize_' . $context_hash;        if (!Cache::isStored($cache_id)) {            // if an id_address has been specified retrieve the address            if ($id_address) {                $address = new Address((int) $id_address);                if (!Validate::isLoadedObject($address)) {                    throw new PrestaShopException('Invalid address #' . (int) $id_address);                }            } elseif ($with_geoloc && isset($context->customer->geoloc_id_country)) {                $address = new Address();                $address->id_country = (int) $context->customer->geoloc_id_country;                $address->id_state = (int) $context->customer->id_state;                $address->postcode = $context->customer->postcode;            } elseif ((int) $context->country->id && ((int) $context->country->id != Configuration::get('PS_SHOP_COUNTRY_ID'))) {                $address = new Address();                $address->id_country = (int) $context->country->id;                $address->id_state = 0;                $address->postcode = 0;            } elseif ((int) Configuration::get('PS_SHOP_COUNTRY_ID')) {                // set the default address                $address = new Address();                $address->id_country = Configuration::get('PS_SHOP_COUNTRY_ID');                $address->id_state = Configuration::get('PS_SHOP_STATE_ID');                $address->postcode = Configuration::get('PS_SHOP_CODE');            } else {                // set the default address                $address = new Address();                $address->id_country = Configuration::get('PS_COUNTRY_DEFAULT');                $address->id_state = 0;                $address->postcode = 0;            }            Cache::store($cache_id, $address);            return $address;        }        return Cache::retrieve($cache_id);    }    /**     * Returns Address ID for a given Supplier ID.     *     * @since 1.5.0     *     * @param int $id_supplier Supplier ID     *     * @return int $id_address Address ID     */    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    }    /**     * Check if the alias already exists.     *     * @param string $alias Alias of an address     * @param int $id_address Address id     * @param int $id_customer Customer id     *     * @return false|string|null Amount of aliases found     * @todo: Find out if we shouldn't be returning an int instead? (breaking change)     */    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }    /**     * @see ObjectModel::getFieldsRequiredDB();     */    public function getFieldsRequiredDB()    {        return parent::getCachedFieldsRequiredDatabase();    }}",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_786, Returns Address ID for a given Supplier ID.\\\\n\\\\n @since 1.5.0\\\\n\\\\n @param int $id_supplier Supplier ID\\\\n\\\\n @return int $id_address Address ID\\\\n,Vraća id adrese na osnovu id nabavljača,    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    },3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_787, Check if the alias already exists.\\\\\\\\n\\\\\\\\n @param string $alias Alias of an address\\\\\\\\n @param int $id_address Address id\\\\\\\\n @param int $id_customer Customer id\\\\\\\\n\\\\\\\\n @return false|string|null Amount of aliases found\\\\\\\\n @todo: Find out if we shouldn't be returning an int instead? (breaking change)\\\\\\\\n,Proveri da li pseudonim postoji.,"    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_170,    Get cell value with formatting\\n\\n    @return    string\\n,Dohvati formatiranu vrednost ćelije.,"    public function getFormattedValue()    {        return (string) PHPExcel_Style_NumberFormat::toFormattedString(            $this->getCalculatedValue(),            $this->getStyle()                ->getNumberFormat()->getFormatCode()        );    }",0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Maatwebsite_Laravel-Excel_QueuedViewExportTest_843, Setup the test environment.\\n,Podesi testno okruženje.,    protected function setUp(): void    {        parent::setUp();        $this->loadLaravelMigrations(['--database' => 'testing']);        $this->withFactories(__DIR__ . '/Data/Stubs/Database/Factories');    },0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLaravelRecent_519, Bootstrap imagecache\\n\\n @return void\\n,Pokreni imagecache.,"    protected function bootstrapImageCache()    {        $app = $this->app;        $config = __DIR__.'/../../../../imagecache/src/config/config.php';        $this->publishes([            $config => config_path('imagecache.php')        ]);        // merge default config        $this->mergeConfigFrom(            $config,            'imagecache'        );        // imagecache route        if (is_string(config('imagecache.route'))) {            $filename_pattern = '[ \w\\.\\/\\-\\@\(\)]+';            // route to access template applied image file            $app['router']->get(config('imagecache.route').'/{template}/{filename}', [                'uses' => 'Intervention\Image\ImageCacheController@getResponse',                'as' => 'imagecache'            ])->where(['filename' => $filename_pattern]);        }    }",0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_helpers_1161, Formats a date with the user timezone and the selected format.\n\n @param string $date\n\n @return \\Jenssegers\\Date\\Date\n,Formatiraj datum koristeći vremnsku zonu i izabrani format korisnika.,"    function formatted_date($date)    {        $dateFormat = Config::get('setting.date_format', 'jS F Y');        return (new Date($date))->format($dateFormat);    }",0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_UndefinedMethodFatalErrorHandler_2285," ErrorHandler for undefined methods.\\n\\n @author GrÃ©goire Pineau <lyrixx@lyrixx.info>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\ErrorEnhancer\\\\UndefinedMethodErrorEnhancer instead.\\n",Rukovodilac greškama za nedefinisane metode.,"class UndefinedMethodFatalErrorHandler implements FatalErrorHandlerInterface{    /**     * {@inheritdoc}     */    public function handleError(array $error, FatalErrorException $exception)    {        preg_match('/^Call to undefined method (.*)::(.*)\(\)$/', $error['message'], $matches);        if (!$matches) {            return null;        }        $className = $matches[1];        $methodName = $matches[2];        $message = sprintf('Attempted to call an undefined method named ""%s"" of class ""%s"".', $methodName, $className);        if ('' === $methodName || !class_exists($className) || null === $methods = get_class_methods($className)) {            // failed to get the class or its methods on which an unknown method was called (for example on an anonymous class)            return new UndefinedMethodException($message, $exception);        }        $candidates = [];        foreach ($methods as $definedMethodName) {            $lev = levenshtein($methodName, $definedMethodName);            if ($lev <= \strlen($methodName) / 3 || false !== strpos($definedMethodName, $methodName)) {                $candidates[] = $definedMethodName;            }        }        if ($candidates) {            sort($candidates);            $last = array_pop($candidates).'""?';            if ($candidates) {                $candidates = 'e.g. ""'.implode('"", ""', $candidates).'"" or ""'.$last;            } else {                $candidates = '""'.$last;            }            $message .= ""\nDid you mean to call "".$candidates;        }        return new UndefinedMethodException($message, $exception);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_ControllerResolver_3124, This implementation uses the '_controller' request attribute to determine\n the controller to execute.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Tobias Schultze <http://tobion.de>\n,Implementacija klase koristi '_controller' atribut zahteva da bi odredio kontroler koji će se koristiti za izvršavanje.,"class ControllerResolver implements ControllerResolverInterface{    private $logger;    public function __construct(LoggerInterface $logger = null)    {        $this->logger = $logger;    }    /**     * {@inheritdoc}     */    public function getController(Request $request)    {        if (!$controller = $request->attributes->get('_controller')) {            if (null !== $this->logger) {                $this->logger->warning('Unable to look for the controller as the ""_controller"" parameter is missing.');            }            return false;        }        if (\is_array($controller)) {            if (isset($controller[0]) && \is_string($controller[0]) && isset($controller[1])) {                try {                    $controller[0] = $this->instantiateController($controller[0]);                } catch (\Error | \LogicException $e) {                    try {                        // We cannot just check is_callable but have to use reflection because a non-static method                        // can still be called statically in PHP but we don't want that. This is deprecated in PHP 7, so we                        // could simplify this with PHP 8.                        if ((new \ReflectionMethod($controller[0], $controller[1]))->isStatic()) {                            return $controller;                        }                    } catch (\ReflectionException $reflectionException) {                        throw $e;                    }                    throw $e;                }            }            if (!\is_callable($controller)) {                throw new \InvalidArgumentException(sprintf('The controller for URI ""%s"" is not callable: ', $request->getPathInfo()).$this->getControllerError($controller));            }            return $controller;        }        if (\is_object($controller)) {            if (!\is_callable($controller)) {                throw new \InvalidArgumentException(sprintf('The controller for URI ""%s"" is not callable: ', $request->getPathInfo()).$this->getControllerError($controller));            }            return $controller;        }        if (\function_exists($controller)) {            return $controller;        }        try {            $callable = $this->createController($controller);        } catch (\InvalidArgumentException $e) {            throw new \InvalidArgumentException(sprintf('The controller for URI ""%s"" is not callable: ', $request->getPathInfo()).$e->getMessage(), 0, $e);        }        if (!\is_callable($callable)) {            throw new \InvalidArgumentException(sprintf('The controller for URI ""%s"" is not callable: ', $request->getPathInfo()).$this->getControllerError($callable));        }        return $callable;    }    /**     * Returns a callable for the given controller.     *     * @return callable A PHP callable     *     * @throws \InvalidArgumentException When the controller cannot be created     */    protected function createController(string $controller)    {        if (false === strpos($controller, '::')) {            $controller = $this->instantiateController($controller);            if (!\is_callable($controller)) {                throw new \InvalidArgumentException($this->getControllerError($controller));            }            return $controller;        }        [$class, $method] = explode('::', $controller, 2);        try {            $controller = [$this->instantiateController($class), $method];        } catch (\Error | \LogicException $e) {            try {                if ((new \ReflectionMethod($class, $method))->isStatic()) {                    return $class.'::'.$method;                }            } catch (\ReflectionException $reflectionException) {                throw $e;            }            throw $e;        }        if (!\is_callable($controller)) {            throw new \InvalidArgumentException($this->getControllerError($controller));        }        return $controller;    }    /**     * Returns an instantiated controller.     *     * @return object     */    protected function instantiateController(string $class)    {        return new $class();    }    private function getControllerError($callable): string    {        if (\is_string($callable)) {            if (false !== strpos($callable, '::')) {                $callable = explode('::', $callable, 2);            } else {                return sprintf('Function ""%s"" does not exist.', $callable);            }        }        if (\is_object($callable)) {            $availableMethods = $this->getClassMethodsWithoutMagicMethods($callable);            $alternativeMsg = $availableMethods ? sprintf(' or use one of the available methods: ""%s""', implode('"", ""', $availableMethods)) : '';            return sprintf('Controller class ""%s"" cannot be called without a method name. You need to implement ""__invoke""%s.', get_debug_type($callable), $alternativeMsg);        }        if (!\is_array($callable)) {            return sprintf('Invalid type for controller given, expected string, array or object, got ""%s"".', get_debug_type($callable));        }        if (!isset($callable[0]) || !isset($callable[1]) || 2 !== \count($callable)) {            return 'Invalid array callable, expected [controller, method].';        }        [$controller, $method] = $callable;        if (\is_string($controller) && !class_exists($controller)) {            return sprintf('Class ""%s"" does not exist.', $controller);        }        $className = \is_object($controller) ? get_debug_type($controller) : $controller;        if (method_exists($controller, $method)) {            return sprintf('Method ""%s"" on class ""%s"" should be public and non-abstract.', $method, $className);        }        $collection = $this->getClassMethodsWithoutMagicMethods($controller);        $alternatives = [];        foreach ($collection as $item) {            $lev = levenshtein($method, $item);            if ($lev <= \strlen($method) / 3 || false !== strpos($item, $method)) {                $alternatives[] = $item;            }        }        asort($alternatives);        $message = sprintf('Expected method ""%s"" on class ""%s""', $method, $className);        if (\count($alternatives) > 0) {            $message .= sprintf(', did you mean ""%s""?', implode('"", ""', $alternatives));        } else {            $message .= sprintf('. Available methods: ""%s"".', implode('"", ""', $collection));        }        return $message;    }    private function getClassMethodsWithoutMagicMethods($classOrObject): array    {        $methods = get_class_methods($classOrObject);        return array_filter($methods, function (string $method) {            return 0 !== strncmp($method, '__', 2);        });    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2897, Convert ArbitraryInteger to an int\n\n @return int\n,Konvertuj ArbitraryInteger u int,    public function toInt(): int    {        $number      = \str_split(\strrev($this->base256));        $place_value = 1;        $int         = \ord($number[0]);        unset($number[0]);        foreach ($number as $digit) {            $place_value *= 256;            $int         += \ord($digit) * $place_value;        }        return $int * ($this->isPositive ? 1 : -1);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_polyfill-mbstring_Mbstring_741," Partial mbstring implementation in PHP, iconv based, UTF-8 centric.\n\n Implemented:\n - mb_chr                  - Returns a specific character from its Unicode code point\n - mb_convert_encoding     - Convert character encoding\n - mb_convert_variables    - Convert character code in variable(s)\n - mb_decode_mimeheader    - Decode string in MIME header field\n - mb_encode_mimeheader    - Encode string for MIME header XXX NATIVE IMPLEMENTATION IS REALLY BUGGED\n - mb_decode_numericentity - Decode HTML numeric string reference to character\n - mb_encode_numericentity - Encode character to HTML numeric string reference\n - mb_convert_case         - Perform case folding on a string\n - mb_detect_encoding      - Detect character encoding\n - mb_get_info             - Get internal settings of mbstring\n - mb_http_input           - Detect HTTP input character encoding\n - mb_http_output          - Set/Get HTTP output character encoding\n - mb_internal_encoding    - Set/Get internal character encoding\n - mb_list_encodings       - Returns an array of all supported encodings\n - mb_ord                  - Returns the Unicode code point of a character\n - mb_output_handler       - Callback function converts character encoding in output buffer\n - mb_scrub                - Replaces ill-formed byte sequences with substitute characters\n - mb_strlen               - Get string length\n - mb_strpos               - Find position of first occurrence of string in a string\n - mb_strrpos              - Find position of last occurrence of a string in a string\n - mb_str_split            - Convert a string to an array\n - mb_strtolower           - Make a string lowercase\n - mb_strtoupper           - Make a string uppercase\n - mb_substitute_character - Set/Get substitution character\n - mb_substr               - Get part of string\n - mb_stripos              - Finds position of first occurrence of a string within another, case insensitive\n - mb_stristr              - Finds first occurrence of a string within another, case insensitive\n - mb_strrchr              - Finds the last occurrence of a character in a string within another\n - mb_strrichr             - Finds the last occurrence of a character in a string within another, case insensitive\n - mb_strripos             - Finds position of last occurrence of a string within another, case insensitive\n - mb_strstr               - Finds first occurrence of a string within another\n - mb_strwidth             - Return width of string\n - mb_substr_count         - Count the number of substring occurrences\n\n Not implemented:\n - mb_convert_kana         - Convert ""kana"" one from another (""zen-kaku"", ""han-kaku"" and more)\n - mb_ereg_ - mb_parse_str            - Parse GET/POST/COOKIE data and set global variable\n - mb_preferred_mime_name  - Get MIME charset string\n - mb_regex_encoding       - Returns current encoding for multibyte regex as string\n - mb_regex_set_options    - Set/Get the default options for mbregex functions\n - mb_send_mail            - Send encoded mail\n - mb_split                - Split multibyte string using regular expression\n - mb_strcut               - Get part of string\n - mb_strimwidth           - Get truncated string with specified width\n\n @author Nicolas Grekas <p@tchwork.com>\n\n @internal\n","Parcijalna implementacija mbstring-a u PHP-u, zasnovana na iconv a usredsređena na UTF-8. Implementirano je sledeće: mb_chr - vraća određen znak sa njegove Unicode kodne tačke. mb_convert_encoding - konvertuj šifrirane karaktere. mb_convert_variables    - Pretvori karaktere promenljivih u kodu. mb_decode_mimeheader    - Dekodiraj string u polju MIME zaglavlja. mb_encode_mimeheader    - Kodiraj string za MIME zaglavlje. mb_decode_numericentity - Dešifruj HTML numeričku string referencu u karakter.mb_encode_numericentity - Kodiraj znak u HTML numeričku string referencu. mb_convert_case - Pronađi preklapanja u stringu. mb_detect_encoding - Detektuj kodirane znakove. mb_get_info - Dohvati podešavanje za interval mbstringa. mb_http_input - Detektuj šifrovani ulazni http karakter. mb_http_output - Postavi / Dohvati šifrovan izlazni http karakter. mb_internal_encoding - Postavi / Dohvati šifrovan ulazni http karakter. mb_list_encodings - Vrati niz svih podržanih šifrovanja. mb_ord - Vrati Unicode kodnu tačku za karakter. mb_output_handler - Funkcija povratnog poziva koja pretvara kodirannje karaktera u izlazni bafer. mb_scrub - zamenjuje loše odlikovane sekvence bajtova zamenskim znakovima. mb_strlen - Dohvati dužinu niza. mb_strpos - Pronađite položaj prvog pojavljivanja reči u stringu. mb_strrpos - Pronađite položaj zadnjeg pojavljivanja reči u stringu. mb_str_split - Pretvori string u niz stringova. mb_strtolower - Smanji sva slova u stringu. mb_strtoupper - Uvećaj sva slova u stringu. mb_substitute_character - Postavi / Dohvati zamenske karaktere. mb_substr - Dohvati deo stringa. mb_stripos - Pronalazi položaj prvog pojavljivanja stringa u drugom, nerazlikujući velika i mala slova. mb_stristr - Pronalazi prvo pojavljivanje stringa u drugom, nerazlikujući velika i mala slova. mb_strrchr - Pronalazi poslednje pojavljivanje karaktera u stringu unutar drugog stringa. mb_strrichr - Pronalazi poslednju pojavu znaka pri traženju stringa u okviru stringa ne razlikujući velika i mala slova. mb_strripos - Pronalazi poslednju poziciju znaka pri traženju stringa u okviru stringa ne razlikujući velika i mala slova. mb_strstr - Pronalazi prvu pojavu stringa u okviru drugog. mb_strwidth - Vraća dužinu stringa. mb_substr_count - Prebroj broj pojavljivanja substringova. Nije implementirano:  mb_convert_kana - Konvertuj ""kana"" iz drugog (""zen-kaku"", ""han-kaku"" and drugih). mb_ereg_* - Regularna izraz sa podrškom više bajtova. mb_parse_str - Analizirati GET/POST/COOKIE podatke i postaviti globalne varijable. mb_preferred_mime_name - Dohvati MIME niz znakoga. mb_regex_encoding - Vrati sadašnje kodiranje za višebajtni regularni izraz u stringu. mb_regex_set_options    - Postavi / Dohvati podrazumevane opcije za mbregex funkcije. mb_send_mail - Pošalji šifrovan mail. mb_split - Podeli višebajtne stringove koristeći regulare izraze. mb_strcut - Dohvati deo stringa. mb_strimwidth - Dohvati skraćeni niz sa naznačenom širinom.","final class Mbstring{    public const MB_CASE_FOLD = \PHP_INT_MAX;    private const CASE_FOLD = [        ['Âµ', 'Å¿', ""\xCD\x85"", 'Ï‚', ""\xCF\x90"", ""\xCF\x91"", ""\xCF\x95"", ""\xCF\x96"", ""\xCF\xB0"", ""\xCF\xB1"", ""\xCF\xB5"", ""\xE1\xBA\x9B"", ""\xE1\xBE\xBE""],        ['Î¼', 's', 'Î¹',        'Ïƒ', 'Î²',        'Î¸',        'Ï†',        'Ï€',        'Îº',        'Ï',        'Îµ',        ""\xE1\xB9\xA1"", 'Î¹'],    ];    private static $encodingList = ['ASCII', 'UTF-8'];    private static $language = 'neutral';    private static $internalEncoding = 'UTF-8';    public static function mb_convert_encoding($s, $toEncoding, $fromEncoding = null)    {        if (\is_array($fromEncoding) || false !== strpos($fromEncoding, ',')) {            $fromEncoding = self::mb_detect_encoding($s, $fromEncoding);        } else {            $fromEncoding = self::getEncoding($fromEncoding);        }        $toEncoding = self::getEncoding($toEncoding);        if ('BASE64' === $fromEncoding) {            $s = base64_decode($s);            $fromEncoding = $toEncoding;        }        if ('BASE64' === $toEncoding) {            return base64_encode($s);        }        if ('HTML-ENTITIES' === $toEncoding || 'HTML' === $toEncoding) {            if ('HTML-ENTITIES' === $fromEncoding || 'HTML' === $fromEncoding) {                $fromEncoding = 'Windows-1252';            }            if ('UTF-8' !== $fromEncoding) {                $s = \iconv($fromEncoding, 'UTF-8//IGNORE', $s);            }            return preg_replace_callback('/[\x80-\xFF]+/', [__CLASS__, 'html_encoding_callback'], $s);        }        if ('HTML-ENTITIES' === $fromEncoding) {            $s = html_entity_decode($s, \ENT_COMPAT, 'UTF-8');            $fromEncoding = 'UTF-8';        }        return \iconv($fromEncoding, $toEncoding.'//IGNORE', $s);    }    public static function mb_convert_variables($toEncoding, $fromEncoding, &...$vars)    {        $ok = true;        array_walk_recursive($vars, function (&$v) use (&$ok, $toEncoding, $fromEncoding) {            if (false === $v = self::mb_convert_encoding($v, $toEncoding, $fromEncoding)) {                $ok = false;            }        });        return $ok ? $fromEncoding : false;    }    public static function mb_decode_mimeheader($s)    {        return \iconv_mime_decode($s, 2, self::$internalEncoding);    }    public static function mb_encode_mimeheader($s, $charset = null, $transferEncoding = null, $linefeed = null, $indent = null)    {        trigger_error('mb_encode_mimeheader() is bugged. Please use iconv_mime_encode() instead', \E_USER_WARNING);    }    public static function mb_decode_numericentity($s, $convmap, $encoding = null)    {        if (null !== $s && !is_scalar($s) && !(\is_object($s) && method_exists($s, '__toString'))) {            trigger_error('mb_decode_numericentity() expects parameter 1 to be string, '.\gettype($s).' given', \E_USER_WARNING);            return null;        }        if (!\is_array($convmap) || (80000 > \PHP_VERSION_ID && !$convmap)) {            return false;        }        if (null !== $encoding && !is_scalar($encoding)) {            trigger_error('mb_decode_numericentity() expects parameter 3 to be string, '.\gettype($s).' given', \E_USER_WARNING);            return '';  // Instead of null (cf. mb_encode_numericentity).        }        $s = (string) $s;        if ('' === $s) {            return '';        }        $encoding = self::getEncoding($encoding);        if ('UTF-8' === $encoding) {            $encoding = null;            if (!preg_match('//u', $s)) {                $s = @\iconv('UTF-8', 'UTF-8//IGNORE', $s);            }        } else {            $s = \iconv($encoding, 'UTF-8//IGNORE', $s);        }        $cnt = floor(\count($convmap) / 4) * 4;        for ($i = 0; $i < $cnt; $i += 4) {            // collector_decode_htmlnumericentity ignores $convmap[$i + 3]            $convmap[$i] += $convmap[$i + 2];            $convmap[$i + 1] += $convmap[$i + 2];        }        $s = preg_replace_callback('/&#(?:0*([0-9]+)|x0*([0-9a-fA-F]+))(?!&);?/', function (array $m) use ($cnt, $convmap) {            $c = isset($m[2]) ? (int) hexdec($m[2]) : $m[1];            for ($i = 0; $i < $cnt; $i += 4) {                if ($c >= $convmap[$i] && $c <= $convmap[$i + 1]) {                    return self::mb_chr($c - $convmap[$i + 2]);                }            }            return $m[0];        }, $s);        if (null === $encoding) {            return $s;        }        return \iconv('UTF-8', $encoding.'//IGNORE', $s);    }    public static function mb_encode_numericentity($s, $convmap, $encoding = null, $is_hex = false)    {        if (null !== $s && !is_scalar($s) && !(\is_object($s) && method_exists($s, '__toString'))) {            trigger_error('mb_encode_numericentity() expects parameter 1 to be string, '.\gettype($s).' given', \E_USER_WARNING);            return null;        }        if (!\is_array($convmap) || (80000 > \PHP_VERSION_ID && !$convmap)) {            return false;        }        if (null !== $encoding && !is_scalar($encoding)) {            trigger_error('mb_encode_numericentity() expects parameter 3 to be string, '.\gettype($s).' given', \E_USER_WARNING);            return null;  // Instead of '' (cf. mb_decode_numericentity).        }        if (null !== $is_hex && !is_scalar($is_hex)) {            trigger_error('mb_encode_numericentity() expects parameter 4 to be boolean, '.\gettype($s).' given', \E_USER_WARNING);            return null;        }        $s = (string) $s;        if ('' === $s) {            return '';        }        $encoding = self::getEncoding($encoding);        if ('UTF-8' === $encoding) {            $encoding = null;            if (!preg_match('//u', $s)) {                $s = @\iconv('UTF-8', 'UTF-8//IGNORE', $s);            }        } else {            $s = \iconv($encoding, 'UTF-8//IGNORE', $s);        }        static $ulenMask = [""\xC0"" => 2, ""\xD0"" => 2, ""\xE0"" => 3, ""\xF0"" => 4];        $cnt = floor(\count($convmap) / 4) * 4;        $i = 0;        $len = \strlen($s);        $result = '';        while ($i < $len) {            $ulen = $s[$i] < ""\x80"" ? 1 : $ulenMask[$s[$i] & ""\xF0""];            $uchr = substr($s, $i, $ulen);            $i += $ulen;            $c = self::mb_ord($uchr);            for ($j = 0; $j < $cnt; $j += 4) {                if ($c >= $convmap[$j] && $c <= $convmap[$j + 1]) {                    $cOffset = ($c + $convmap[$j + 2]) & $convmap[$j + 3];                    $result .= $is_hex ? sprintf('&#x%X;', $cOffset) : '&#'.$cOffset.';';                    continue 2;                }            }            $result .= $uchr;        }        if (null === $encoding) {            return $result;        }        return \iconv('UTF-8', $encoding.'//IGNORE', $result);    }    public static function mb_convert_case($s, $mode, $encoding = null)    {        $s = (string) $s;        if ('' === $s) {            return '';        }        $encoding = self::getEncoding($encoding);        if ('UTF-8' === $encoding) {            $encoding = null;            if (!preg_match('//u', $s)) {                $s = @\iconv('UTF-8', 'UTF-8//IGNORE', $s);            }        } else {            $s = \iconv($encoding, 'UTF-8//IGNORE', $s);        }        if (\MB_CASE_TITLE == $mode) {            static $titleRegexp = null;            if (null === $titleRegexp) {                $titleRegexp = self::getData('titleCaseRegexp');            }            $s = preg_replace_callback($titleRegexp, [__CLASS__, 'title_case'], $s);        } else {            if (\MB_CASE_UPPER == $mode) {                static $upper = null;                if (null === $upper) {                    $upper = self::getData('upperCase');                }                $map = $upper;            } else {                if (self::MB_CASE_FOLD === $mode) {                    $s = str_replace(self::CASE_FOLD[0], self::CASE_FOLD[1], $s);                }                static $lower = null;                if (null === $lower) {                    $lower = self::getData('lowerCase');                }                $map = $lower;            }            static $ulenMask = [""\xC0"" => 2, ""\xD0"" => 2, ""\xE0"" => 3, ""\xF0"" => 4];            $i = 0;            $len = \strlen($s);            while ($i < $len) {                $ulen = $s[$i] < ""\x80"" ? 1 : $ulenMask[$s[$i] & ""\xF0""];                $uchr = substr($s, $i, $ulen);                $i += $ulen;                if (isset($map[$uchr])) {                    $uchr = $map[$uchr];                    $nlen = \strlen($uchr);                    if ($nlen == $ulen) {                        $nlen = $i;                        do {                            $s[--$nlen] = $uchr[--$ulen];                        } while ($ulen);                    } else {                        $s = substr_replace($s, $uchr, $i - $ulen, $ulen);                        $len += $nlen - $ulen;                        $i += $nlen - $ulen;                    }                }            }        }        if (null === $encoding) {            return $s;        }        return \iconv('UTF-8', $encoding.'//IGNORE', $s);    }    public static function mb_internal_encoding($encoding = null)    {        if (null === $encoding) {            return self::$internalEncoding;        }        $normalizedEncoding = self::getEncoding($encoding);        if ('UTF-8' === $normalizedEncoding || false !== @\iconv($normalizedEncoding, $normalizedEncoding, ' ')) {            self::$internalEncoding = $normalizedEncoding;            return true;        }        if (80000 > \PHP_VERSION_ID) {            return false;        }        throw new \ValueError(sprintf('Argument #1 ($encoding) must be a valid encoding, ""%s"" given', $encoding));    }    public static function mb_language($lang = null)    {        if (null === $lang) {            return self::$language;        }        switch ($normalizedLang = strtolower($lang)) {            case 'uni':            case 'neutral':                self::$language = $normalizedLang;                return true;        }        if (80000 > \PHP_VERSION_ID) {            return false;        }        throw new \ValueError(sprintf('Argument #1 ($language) must be a valid language, ""%s"" given', $lang));    }    public static function mb_list_encodings()    {        return ['UTF-8'];    }    public static function mb_encoding_aliases($encoding)    {        switch (strtoupper($encoding)) {            case 'UTF8':            case 'UTF-8':                return ['utf8'];        }        return false;    }    public static function mb_check_encoding($var = null, $encoding = null)    {        if (null === $encoding) {            if (null === $var) {                return false;            }            $encoding = self::$internalEncoding;        }        return self::mb_detect_encoding($var, [$encoding]) || false !== @\iconv($encoding, $encoding, $var);    }    public static function mb_detect_encoding($str, $encodingList = null, $strict = false)    {        if (null === $encodingList) {            $encodingList = self::$encodingList;        } else {            if (!\is_array($encodingList)) {                $encodingList = array_map('trim', explode(',', $encodingList));            }            $encodingList = array_map('strtoupper', $encodingList);        }        foreach ($encodingList as $enc) {            switch ($enc) {                case 'ASCII':                    if (!preg_match('/[\x80-\xFF]/', $str)) {                        return $enc;                    }                    break;                case 'UTF8':                case 'UTF-8':                    if (preg_match('//u', $str)) {                        return 'UTF-8';                    }                    break;                default:                    if (0 === strncmp($enc, 'ISO-8859-', 9)) {                        return $enc;                    }            }        }        return false;    }    public static function mb_detect_order($encodingList = null)    {        if (null === $encodingList) {            return self::$encodingList;        }        if (!\is_array($encodingList)) {            $encodingList = array_map('trim', explode(',', $encodingList));        }        $encodingList = array_map('strtoupper', $encodingList);        foreach ($encodingList as $enc) {            switch ($enc) {                default:                    if (strncmp($enc, 'ISO-8859-', 9)) {                        return false;                    }                    // no break                case 'ASCII':                case 'UTF8':                case 'UTF-8':            }        }        self::$encodingList = $encodingList;        return true;    }    public static function mb_strlen($s, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            return \strlen($s);        }        return @\iconv_strlen($s, $encoding);    }    public static function mb_strpos($haystack, $needle, $offset = 0, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            return strpos($haystack, $needle, $offset);        }        $needle = (string) $needle;        if ('' === $needle) {            if (80000 > \PHP_VERSION_ID) {                trigger_error(__METHOD__.': Empty delimiter', \E_USER_WARNING);                return false;            }            return 0;        }        return \iconv_strpos($haystack, $needle, $offset, $encoding);    }    public static function mb_strrpos($haystack, $needle, $offset = 0, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            return strrpos($haystack, $needle, $offset);        }        if ($offset != (int) $offset) {            $offset = 0;        } elseif ($offset = (int) $offset) {            if ($offset < 0) {                if (0 > $offset += self::mb_strlen($needle)) {                    $haystack = self::mb_substr($haystack, 0, $offset, $encoding);                }                $offset = 0;            } else {                $haystack = self::mb_substr($haystack, $offset, 2147483647, $encoding);            }        }        $pos = '' !== $needle || 80000 > \PHP_VERSION_ID            ? \iconv_strrpos($haystack, $needle, $encoding)            : self::mb_strlen($haystack, $encoding);        return false !== $pos ? $offset + $pos : false;    }    public static function mb_str_split($string, $split_length = 1, $encoding = null)    {        if (null !== $string && !is_scalar($string) && !(\is_object($string) && method_exists($string, '__toString'))) {            trigger_error('mb_str_split() expects parameter 1 to be string, '.\gettype($string).' given', \E_USER_WARNING);            return null;        }        if (1 > $split_length = (int) $split_length) {            if (80000 > \PHP_VERSION_ID) {                trigger_error('The length of each segment must be greater than zero', \E_USER_WARNING);                return false;            }            throw new \ValueError('Argument #2 ($length) must be greater than 0');        }        if (null === $encoding) {            $encoding = mb_internal_encoding();        }        if ('UTF-8' === $encoding = self::getEncoding($encoding)) {            $rx = '/(';            while (65535 < $split_length) {                $rx .= '.{65535}';                $split_length -= 65535;            }            $rx .= '.{'.$split_length.'})/us';            return preg_split($rx, $string, null, \PREG_SPLIT_DELIM_CAPTURE | \PREG_SPLIT_NO_EMPTY);        }        $result = [];        $length = mb_strlen($string, $encoding);        for ($i = 0; $i < $length; $i += $split_length) {            $result[] = mb_substr($string, $i, $split_length, $encoding);        }        return $result;    }    public static function mb_strtolower($s, $encoding = null)    {        return self::mb_convert_case($s, \MB_CASE_LOWER, $encoding);    }    public static function mb_strtoupper($s, $encoding = null)    {        return self::mb_convert_case($s, \MB_CASE_UPPER, $encoding);    }    public static function mb_substitute_character($c = null)    {        if (null === $c) {            return 'none';        }        if (0 === strcasecmp($c, 'none')) {            return true;        }        if (80000 > \PHP_VERSION_ID) {            return false;        }        throw new \ValueError('Argument #1 ($substitute_character) must be ""none"", ""long"", ""entity"" or a valid codepoint');    }    public static function mb_substr($s, $start, $length = null, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            return (string) substr($s, $start, null === $length ? 2147483647 : $length);        }        if ($start < 0) {            $start = \iconv_strlen($s, $encoding) + $start;            if ($start < 0) {                $start = 0;            }        }        if (null === $length) {            $length = 2147483647;        } elseif ($length < 0) {            $length = \iconv_strlen($s, $encoding) + $length - $start;            if ($length < 0) {                return '';            }        }        return (string) \iconv_substr($s, $start, $length, $encoding);    }    public static function mb_stripos($haystack, $needle, $offset = 0, $encoding = null)    {        $haystack = self::mb_convert_case($haystack, self::MB_CASE_FOLD, $encoding);        $needle = self::mb_convert_case($needle, self::MB_CASE_FOLD, $encoding);        return self::mb_strpos($haystack, $needle, $offset, $encoding);    }    public static function mb_stristr($haystack, $needle, $part = false, $encoding = null)    {        $pos = self::mb_stripos($haystack, $needle, 0, $encoding);        return self::getSubpart($pos, $part, $haystack, $encoding);    }    public static function mb_strrchr($haystack, $needle, $part = false, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            $pos = strrpos($haystack, $needle);        } else {            $needle = self::mb_substr($needle, 0, 1, $encoding);            $pos = \iconv_strrpos($haystack, $needle, $encoding);        }        return self::getSubpart($pos, $part, $haystack, $encoding);    }    public static function mb_strrichr($haystack, $needle, $part = false, $encoding = null)    {        $needle = self::mb_substr($needle, 0, 1, $encoding);        $pos = self::mb_strripos($haystack, $needle, $encoding);        return self::getSubpart($pos, $part, $haystack, $encoding);    }    public static function mb_strripos($haystack, $needle, $offset = 0, $encoding = null)    {        $haystack = self::mb_convert_case($haystack, self::MB_CASE_FOLD, $encoding);        $needle = self::mb_convert_case($needle, self::MB_CASE_FOLD, $encoding);        return self::mb_strrpos($haystack, $needle, $offset, $encoding);    }    public static function mb_strstr($haystack, $needle, $part = false, $encoding = null)    {        $pos = strpos($haystack, $needle);        if (false === $pos) {            return false;        }        if ($part) {            return substr($haystack, 0, $pos);        }        return substr($haystack, $pos);    }    public static function mb_get_info($type = 'all')    {        $info = [            'internal_encoding' => self::$internalEncoding,            'http_output' => 'pass',            'http_output_conv_mimetypes' => '^(text/|application/xhtml\+xml)',            'func_overload' => 0,            'func_overload_list' => 'no overload',            'mail_charset' => 'UTF-8',            'mail_header_encoding' => 'BASE64',            'mail_body_encoding' => 'BASE64',            'illegal_chars' => 0,            'encoding_translation' => 'Off',            'language' => self::$language,            'detect_order' => self::$encodingList,            'substitute_character' => 'none',            'strict_detection' => 'Off',        ];        if ('all' === $type) {            return $info;        }        if (isset($info[$type])) {            return $info[$type];        }        return false;    }    public static function mb_http_input($type = '')    {        return false;    }    public static function mb_http_output($encoding = null)    {        return null !== $encoding ? 'pass' === $encoding : 'pass';    }    public static function mb_strwidth($s, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('UTF-8' !== $encoding) {            $s = \iconv($encoding, 'UTF-8//IGNORE', $s);        }        $s = preg_replace('/[\x{1100}-\x{115F}\x{2329}\x{232A}\x{2E80}-\x{303E}\x{3040}-\x{A4CF}\x{AC00}-\x{D7A3}\x{F900}-\x{FAFF}\x{FE10}-\x{FE19}\x{FE30}-\x{FE6F}\x{FF00}-\x{FF60}\x{FFE0}-\x{FFE6}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}]/u', '', $s, -1, $wide);        return ($wide << 1) + \iconv_strlen($s, 'UTF-8');    }    public static function mb_substr_count($haystack, $needle, $encoding = null)    {        return substr_count($haystack, $needle);    }    public static function mb_output_handler($contents, $status)    {        return $contents;    }    public static function mb_chr($code, $encoding = null)    {        if (0x80 > $code %= 0x200000) {            $s = \chr($code);        } elseif (0x800 > $code) {            $s = \chr(0xC0 | $code >> 6).\chr(0x80 | $code & 0x3F);        } elseif (0x10000 > $code) {            $s = \chr(0xE0 | $code >> 12).\chr(0x80 | $code >> 6 & 0x3F).\chr(0x80 | $code & 0x3F);        } else {            $s = \chr(0xF0 | $code >> 18).\chr(0x80 | $code >> 12 & 0x3F).\chr(0x80 | $code >> 6 & 0x3F).\chr(0x80 | $code & 0x3F);        }        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {            $s = mb_convert_encoding($s, $encoding, 'UTF-8');        }        return $s;    }    public static function mb_ord($s, $encoding = null)    {        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {            $s = mb_convert_encoding($s, 'UTF-8', $encoding);        }        if (1 === \strlen($s)) {            return \ord($s);        }        $code = ($s = unpack('C*', substr($s, 0, 4))) ? $s[1] : 0;        if (0xF0 <= $code) {            return (($code - 0xF0) << 18) + (($s[2] - 0x80) << 12) + (($s[3] - 0x80) << 6) + $s[4] - 0x80;        }        if (0xE0 <= $code) {            return (($code - 0xE0) << 12) + (($s[2] - 0x80) << 6) + $s[3] - 0x80;        }        if (0xC0 <= $code) {            return (($code - 0xC0) << 6) + $s[2] - 0x80;        }        return $code;    }    private static function getSubpart($pos, $part, $haystack, $encoding)    {        if (false === $pos) {            return false;        }        if ($part) {            return self::mb_substr($haystack, 0, $pos, $encoding);        }        return self::mb_substr($haystack, $pos, null, $encoding);    }    private static function html_encoding_callback(array $m)    {        $i = 1;        $entities = '';        $m = unpack('C*', htmlentities($m[0], \ENT_COMPAT, 'UTF-8'));        while (isset($m[$i])) {            if (0x80 > $m[$i]) {                $entities .= \chr($m[$i++]);                continue;            }            if (0xF0 <= $m[$i]) {                $c = (($m[$i++] - 0xF0) << 18) + (($m[$i++] - 0x80) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;            } elseif (0xE0 <= $m[$i]) {                $c = (($m[$i++] - 0xE0) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;            } else {                $c = (($m[$i++] - 0xC0) << 6) + $m[$i++] - 0x80;            }            $entities .= '&#'.$c.';';        }        return $entities;    }    private static function title_case(array $s)    {        return self::mb_convert_case($s[1], \MB_CASE_UPPER, 'UTF-8').self::mb_convert_case($s[2], \MB_CASE_LOWER, 'UTF-8');    }    private static function getData($file)    {        if (file_exists($file = __DIR__.'/Resources/unidata/'.$file.'.php')) {            return require $file;        }        return false;    }    private static function getEncoding($encoding)    {        if (null === $encoding) {            return self::$internalEncoding;        }        if ('UTF-8' === $encoding) {            return 'UTF-8';        }        $encoding = strtoupper($encoding);        if ('8BIT' === $encoding || 'BINARY' === $encoding) {            return 'CP850';        }        if ('UTF8' === $encoding) {            return 'UTF-8';        }        return $encoding;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_2014_10_12_100000_create_password_resets_table_763, Run the migrations.\n\n @return void\n,Pokreni migraciju,"    public function up()    {        Schema::create('password_resets', function (Blueprint $table) {            $table->string('email')->index();            $table->string('token')->index();            $table->timestamp('created_at');        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_2015_07_12_114933_create_books_table_766, Reverse the migrations.\n\n @return void\n,Poništi migracije,    public function down()    {        Schema::drop('books');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_2015_07_13_172121_create_images_table_769, Run the migrations.\n\n @return void\n,Pokreni migraciju,"    public function up()    {        Schema::create('images', function (Blueprint $table) {            $table->increments('id');            $table->string('name');            $table->string('url');            $table->nullableTimestamps();        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_2015_07_13_172121_create_images_table_770, Reverse the migrations.\n\n @return void\n,Poništi migracije,    public function down()    {        Schema::drop('images');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_2015_07_27_172342_create_chapters_table_772, Reverse the migrations.\n\n @return void\n,Poništi migracije,    public function down()    {        Schema::drop('chapters');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_2015_08_09_093534_create_page_revisions_table_775, Run the migrations.\n\n @return void\n,Pokreni migraciju,"    public function up()    {        Schema::create('page_revisions', function (Blueprint $table) {            $table->increments('id');            $table->integer('page_id')->indexed();            $table->string('name');            $table->longText('html');            $table->longText('text');            $table->integer('created_by');            $table->nullableTimestamps();        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_ActivityService_741, Removes the entity attachment from each of its activities\n and instead uses the 'extra' field with the entities name.\n Used when an entity is deleted.\n,Ukloni entitet dodatak svakom aktivitiju koji ga poseduje i umesto njega koristi polje 'extra' sa imenom entiteta. Koristi se kada je entiti izbrisan.,"    public function removeEntity(Entity $entity)    {        $entity->activity()->update([            'detail'       => $entity->name,            'entity_id'   => null,            'entity_type' => null,        ]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_Activity_735, Get the user this activity relates to.\n,Dohvatanje korisnika koji se odnosi na dati aktiviti.,    public function user(): BelongsTo    {        return $this->belongsTo(User::class);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_Activity_737, Check if this activity is intended to be for an entity.\n,Proveri da li je ovaj aktiviti namenjen nekom entitetu. ,"    public function isForEntity(): bool    {        return Str::startsWith($this->type, [            'page_', 'chapter_', 'book_', 'bookshelf_'        ]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_BrowserKitTest_785, Check if the page contains the given element.\n @param  string  $selector\n,Proveri da li stranica sadrži dati element.,"    protected function pageNotHasElement($selector)    {        $elements = $this->crawler->filter($selector);        $this->assertFalse(count($elements) > 0, ""The page contains "" . count($elements) . "" elements matching "" . $selector);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_CreatesApplication_786, Creates the application.\n\n @return \\Illuminate\\Foundation\\Application\n,Kreiraj aplikaciju.,    public function createApplication()    {        $app = require __DIR__.'/../bootstrap/app.php';        $app->make(Kernel::class)->bootstrap();        return $app;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_Tag_759, Get a full URL to start a tag name search for this tag name.\n,Dohvatati te punu URL adresu da biste započeli pretragu imena oznake za daiti naziv oznake. ,    public function nameUrl(): string    {        return url('/search?term=%5B' . urlencode($this->name) .'%5D');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
blueimp_jQuery-File-Upload_UploadHandler_1," jQuery File Upload Plugin PHP Class\\n https://github.com/blueimp/jQuery-File-Upload\\n\\n Copyright 2010, Sebastian Tschan\\n https://blueimp.net\\n\\n Licensed under the MIT license:\\n https://opensource.org/licenses/MIT\\n",JQuery dodatak za odpremanje datoteka,"class UploadHandler  {        protected $options;        // PHP File Upload error message codes:      // https://php.net/manual/en/features.file-upload.errors.php      protected $error_messages = array(          1 => 'The uploaded file exceeds the upload_max_filesize directive in php.ini',          2 => 'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form',          3 => 'The uploaded file was only partially uploaded',          4 => 'No file was uploaded',          6 => 'Missing a temporary folder',          7 => 'Failed to write file to disk',          8 => 'A PHP extension stopped the file upload',          'post_max_size' => 'The uploaded file exceeds the post_max_size directive in php.ini',          'max_file_size' => 'File is too big',          'min_file_size' => 'File is too small',          'accept_file_types' => 'Filetype not allowed',          'max_number_of_files' => 'Maximum number of files exceeded',          'invalid_file_type' => 'Invalid file type',          'max_width' => 'Image exceeds maximum width',          'min_width' => 'Image requires a minimum width',          'max_height' => 'Image exceeds maximum height',          'min_height' => 'Image requires a minimum height',          'abort' => 'File upload aborted',          'image_resize' => 'Failed to resize image'      );        const IMAGETYPE_GIF = 'image/gif';      const IMAGETYPE_JPEG = 'image/jpeg';      const IMAGETYPE_PNG = 'image/png';        protected $image_objects = array();      protected $response = array();        public function __construct($options = null, $initialize = true, $error_messages = null) {          $this->options = array(              'script_url' => $this->get_full_url().'/'.$this->basename($this->get_server_var('SCRIPT_NAME')),              'upload_dir' => dirname($this->get_server_var('SCRIPT_FILENAME')).'/files/',              'upload_url' => $this->get_full_url().'/files/',              'input_stream' => 'php://input',              'user_dirs' => false,              'mkdir_mode' => 0755,              'param_name' => 'files',              // Set the following option to 'POST', if your server does not support              // DELETE requests. This is a parameter sent to the client:              'delete_type' => 'DELETE',              'access_control_allow_origin' => '*',              'access_control_allow_credentials' => false,              'access_control_allow_methods' => array(                  'OPTIONS',                  'HEAD',                  'GET',                  'POST',                  'PUT',                  'PATCH',                  'DELETE'              ),              'access_control_allow_headers' => array(                  'Content-Type',                  'Content-Range',                  'Content-Disposition'              ),              // By default, allow redirects to the referer protocol+host:              'redirect_allow_target' => '/^'.preg_quote(                      parse_url($this->get_server_var('HTTP_REFERER'), PHP_URL_SCHEME)                      .'://'                      .parse_url($this->get_server_var('HTTP_REFERER'), PHP_URL_HOST)                      .'/', // Trailing slash to not match subdomains by mistake                      '/' // preg_quote delimiter param                  ).'/',              // Enable to provide file downloads via GET requests to the PHP script:              //     1. Set to 1 to download files via readfile method through PHP              //     2. Set to 2 to send a X-Sendfile header for lighttpd/Apache              //     3. Set to 3 to send a X-Accel-Redirect header for nginx              // If set to 2 or 3, adjust the upload_url option to the base path of              // the redirect parameter, e.g. '/files/'.              'download_via_php' => false,              // Read files in chunks to avoid memory limits when download_via_php              // is enabled, set to 0 to disable chunked reading of files:              'readfile_chunk_size' => 10 * 1024 * 1024, // 10 MiB              // Defines which files can be displayed inline when downloaded:              'inline_file_types' => '/\.(gif|jpe?g|png)$/i',              // Defines which files (based on their names) are accepted for upload.              // By default, only allows file uploads with image file extensions.              // Only change this setting after making sure that any allowed file              // types cannot be executed by the webserver in the files directory,              // e.g. PHP scripts, nor executed by the browser when downloaded,              // e.g. HTML files with embedded JavaScript code.              // Please also read the SECURITY.md document in this repository.              'accept_file_types' => '/\.(gif|jpe?g|png)$/i',              // Replaces dots in filenames with the given string.              // Can be disabled by setting it to false or an empty string.              // Note that this is a security feature for servers that support              // multiple file extensions, e.g. the Apache AddHandler Directive:              // https://httpd.apache.org/docs/current/mod/mod_mime.html#addhandler              // Before disabling it, make sure that files uploaded with multiple              // extensions cannot be executed by the webserver, e.g.              // ""example.php.png"" with embedded PHP code, nor executed by the              // browser when downloaded, e.g. ""example.html.gif"" with embedded              // JavaScript code.              'replace_dots_in_filenames' => '-',              // The php.ini settings upload_max_filesize and post_max_size              // take precedence over the following max_file_size setting:              'max_file_size' => null,              'min_file_size' => 1,              // The maximum number of files for the upload directory:              'max_number_of_files' => null,              // Reads first file bytes to identify and correct file extensions:              'correct_image_extensions' => false,              // Image resolution restrictions:              'max_width' => null,              'max_height' => null,              'min_width' => 1,              'min_height' => 1,              // Set the following option to false to enable resumable uploads:              'discard_aborted_uploads' => true,              // Set to 0 to use the GD library to scale and orient images,              // set to 1 to use imagick (if installed, falls back to GD),              // set to 2 to use the ImageMagick convert binary directly:              'image_library' => 1,              // Uncomment the following to define an array of resource limits              // for imagick:              /*              'imagick_resource_limits' => array(                  imagick::RESOURCETYPE_MAP => 32,                  imagick::RESOURCETYPE_MEMORY => 32              ),              */              // Command or path for to the ImageMagick convert binary:              'convert_bin' => 'convert',              // Uncomment the following to add parameters in front of each              // ImageMagick convert call (the limit constraints seem only              // to have an effect if put in front):              /*              'convert_params' => '-limit memory 32MiB -limit map 32MiB',              */              // Command or path for to the ImageMagick identify binary:              'identify_bin' => 'identify',              'image_versions' => array(                  // The empty image version key defines options for the original image.                  // Keep in mind: these image manipulations are inherited by all other image versions from this point onwards.                  // Also note that the property 'no_cache' is not inherited, since it's not a manipulation.                  '' => array(                      // Automatically rotate images based on EXIF meta data:                      'auto_orient' => true                  ),                  // You can add arrays to generate different versions.                  // The name of the key is the name of the version (example: 'medium').                  // the array contains the options to apply.                  /*                  'medium' => array(                      'max_width' => 800,                      'max_height' => 600                  ),                  */                  'thumbnail' => array(                      // Uncomment the following to use a defined directory for the thumbnails                      // instead of a subdirectory based on the version identifier.                      // Make sure that this directory doesn't allow execution of files if you                      // don't pose any restrictions on the type of uploaded files, e.g. by                      // copying the .htaccess file from the files directory for Apache:                      //'upload_dir' => dirname($this->get_server_var('SCRIPT_FILENAME')).'/thumb/',                      //'upload_url' => $this->get_full_url().'/thumb/',                      // Uncomment the following to force the max                      // dimensions and e.g. create square thumbnails:                      // 'auto_orient' => true,                      // 'crop' => true,                      // 'jpeg_quality' => 70,                      // 'no_cache' => true, (there's a caching option, but this remembers thumbnail sizes from a previous action!)                      // 'strip' => true, (this strips EXIF tags, such as geolocation)                      'max_width' => 80, // either specify width, or set to 0. Then width is automatically adjusted - keeping aspect ratio to a specified max_height.                      'max_height' => 80 // either specify height, or set to 0. Then height is automatically adjusted - keeping aspect ratio to a specified max_width.                  )              ),              'print_response' => true          );          if ($options) {              $this->options = $options + $this->options;          }          if ($error_messages) {              $this->error_messages = $error_messages + $this->error_messages;          }          if ($initialize) {              $this->initialize();          }      }        protected function initialize() {          switch ($this->get_server_var('REQUEST_METHOD')) {              case 'OPTIONS':              case 'HEAD':                  $this->head();                  break;              case 'GET':                  $this->get($this->options['print_response']);                  break;              case 'PATCH':              case 'PUT':              case 'POST':                  $this->post($this->options['print_response']);                  break;              case 'DELETE':                  $this->delete($this->options['print_response']);                  break;              default:                  $this->header('HTTP/1.1 405 Method Not Allowed');          }      }        protected function get_full_url() {          $https = !empty($_SERVER['HTTPS']) && strcasecmp($_SERVER['HTTPS'], 'on') === 0 ||              !empty($_SERVER['HTTP_X_FORWARDED_PROTO']) &&              strcasecmp($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') === 0;          return              ($https ? 'https://' : 'http://').              (!empty($_SERVER['REMOTE_USER']) ? $_SERVER['REMOTE_USER'].'@' : '').              (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : ($_SERVER['SERVER_NAME'].                  ($https && $_SERVER['SERVER_PORT'] === 443 ||                  $_SERVER['SERVER_PORT'] === 80 ? '' : ':'.$_SERVER['SERVER_PORT']))).              substr($_SERVER['SCRIPT_NAME'],0, strrpos($_SERVER['SCRIPT_NAME'], '/'));      }        protected function get_user_id() {          @session_start();          return session_id();      }        protected function get_user_path() {          if ($this->options['user_dirs']) {              return $this->get_user_id().'/';          }          return '';      }        protected function get_upload_path($file_name = null, $version = null) {          $file_name = $file_name ? $file_name : '';          if (empty($version)) {              $version_path = '';          } else {              $version_dir = @$this->options['image_versions'][$version]['upload_dir'];              if ($version_dir) {                  return $version_dir.$this->get_user_path().$file_name;              }              $version_path = $version.'/';          }          return $this->options['upload_dir'].$this->get_user_path()              .$version_path.$file_name;      }        protected function get_query_separator($url) {          return strpos($url, '?') === false ? '?' : '&';      }        protected function get_download_url($file_name, $version = null, $direct = false) {          if (!$direct && $this->options['download_via_php']) {              $url = $this->options['script_url']                  .$this->get_query_separator($this->options['script_url'])                  .$this->get_singular_param_name()                  .'='.rawurlencode($file_name);              if ($version) {                  $url .= '&version='.rawurlencode($version);              }              return $url.'&download=1';          }          if (empty($version)) {              $version_path = '';          } else {              $version_url = @$this->options['image_versions'][$version]['upload_url'];              if ($version_url) {                  return $version_url.$this->get_user_path().rawurlencode($file_name);              }              $version_path = rawurlencode($version).'/';          }          return $this->options['upload_url'].$this->get_user_path()              .$version_path.rawurlencode($file_name);      }        protected function set_additional_file_properties($file) {          $file->deleteUrl = $this->options['script_url']              .$this->get_query_separator($this->options['script_url'])              .$this->get_singular_param_name()              .'='.rawurlencode($file->name);          $file->deleteType = $this->options['delete_type'];          if ($file->deleteType !== 'DELETE') {              $file->deleteUrl .= '&_method=DELETE';          }          if ($this->options['access_control_allow_credentials']) {              $file->deleteWithCredentials = true;          }      }        // Fix for overflowing signed 32 bit integers,      // works for sizes up to 2^32-1 bytes (4 GiB - 1):      protected function fix_integer_overflow($size) {          if ($size < 0) {              $size += 2.0 * (PHP_INT_MAX + 1);          }          return $size;      }        protected function get_file_size($file_path, $clear_stat_cache = false) {          if ($clear_stat_cache) {              if (version_compare(PHP_VERSION, '5.3.0') >= 0) {                  clearstatcache(true, $file_path);              } else {                  clearstatcache();              }          }          return $this->fix_integer_overflow(filesize($file_path));      }        protected function is_valid_file_object($file_name) {          $file_path = $this->get_upload_path($file_name);          if (strlen($file_name) > 0 && $file_name[0] !== '.' && is_file($file_path)) {              return true;          }          return false;      }        protected function get_file_object($file_name) {          if ($this->is_valid_file_object($file_name)) {              $file = new \stdClass();              $file->name = $file_name;              $file->size = $this->get_file_size(                  $this->get_upload_path($file_name)              );              $file->url = $this->get_download_url($file->name);              foreach ($this->options['image_versions'] as $version => $options) {                  if (!empty($version)) {                      if (is_file($this->get_upload_path($file_name, $version))) {                          $file->{$version.'Url'} = $this->get_download_url(                              $file->name,                              $version                          );                      }                  }              }              $this->set_additional_file_properties($file);              return $file;          }          return null;      }        protected function get_file_objects($iteration_method = 'get_file_object') {          $upload_dir = $this->get_upload_path();          if (!is_dir($upload_dir)) {              return array();          }          return array_values(array_filter(array_map(              array($this, $iteration_method),              scandir($upload_dir)          )));      }        protected function count_file_objects() {          return count($this->get_file_objects('is_valid_file_object'));      }        protected function get_error_message($error) {          return isset($this->error_messages[$error]) ?              $this->error_messages[$error] : $error;      }        public function get_config_bytes($val) {          $val = trim($val);          $last = strtolower($val[strlen($val)-1]);          if (is_numeric($val)) {              $val = (int)$val;          } else {              $val = (int)substr($val, 0, -1);          }          switch ($last) {              case 'g':                  $val *= 1024;              case 'm':                  $val *= 1024;              case 'k':                  $val *= 1024;          }          return $this->fix_integer_overflow($val);      }        protected function validate_image_file($uploaded_file, $file, $error, $index) {          if ($this->imagetype($uploaded_file) !== $this->get_file_type($file->name)) {              $file->error = $this->get_error_message('invalid_file_type');              return false;          }          $max_width = @$this->options['max_width'];          $max_height = @$this->options['max_height'];          $min_width = @$this->options['min_width'];          $min_height = @$this->options['min_height'];          if ($max_width || $max_height || $min_width || $min_height) {              list($img_width, $img_height) = $this->get_image_size($uploaded_file);              // If we are auto rotating the image by default, do the checks on              // the correct orientation              if (                  @$this->options['image_versions']['']['auto_orient'] &&                  function_exists('exif_read_data') &&                  ($exif = @exif_read_data($uploaded_file)) &&                  (((int) @$exif['Orientation']) >= 5)              ) {                  $tmp = $img_width;                  $img_width = $img_height;                  $img_height = $tmp;                  unset($tmp);              }              if (!empty($img_width) && !empty($img_height)) {                  if ($max_width && $img_width > $max_width) {                      $file->error = $this->get_error_message('max_width');                      return false;                  }                  if ($max_height && $img_height > $max_height) {                      $file->error = $this->get_error_message('max_height');                      return false;                  }                  if ($min_width && $img_width < $min_width) {                      $file->error = $this->get_error_message('min_width');                      return false;                  }                  if ($min_height && $img_height < $min_height) {                      $file->error = $this->get_error_message('min_height');                      return false;                  }              }          }          return true;      }        protected function validate($uploaded_file, $file, $error, $index, $content_range) {          if ($error) {              $file->error = $this->get_error_message($error);              return false;          }          $content_length = $this->fix_integer_overflow(              (int)$this->get_server_var('CONTENT_LENGTH')          );          $post_max_size = $this->get_config_bytes(ini_get('post_max_size'));          if ($post_max_size && ($content_length > $post_max_size)) {              $file->error = $this->get_error_message('post_max_size');              return false;          }          if (!preg_match($this->options['accept_file_types'], $file->name)) {              $file->error = $this->get_error_message('accept_file_types');              return false;          }          if ($uploaded_file && is_uploaded_file($uploaded_file)) {              $file_size = $this->get_file_size($uploaded_file);          } else {              $file_size = $content_length;          }          if ($this->options['max_file_size'] && (                  $file_size > $this->options['max_file_size'] ||                  $file->size > $this->options['max_file_size'])          ) {              $file->error = $this->get_error_message('max_file_size');              return false;          }          if ($this->options['min_file_size'] &&              $file_size < $this->options['min_file_size']) {              $file->error = $this->get_error_message('min_file_size');              return false;          }          if (is_int($this->options['max_number_of_files']) &&              ($this->count_file_objects() >= $this->options['max_number_of_files']) &&              // Ignore additional chunks of existing files:              !is_file($this->get_upload_path($file->name))) {              $file->error = $this->get_error_message('max_number_of_files');              return false;          }          if (!$content_range && $this->has_image_file_extension($file->name)) {              return $this->validate_image_file($uploaded_file, $file, $error, $index);          }          return true;      }        protected function upcount_name_callback($matches) {          $index = isset($matches[1]) ? ((int)$matches[1]) + 1 : 1;          $ext = isset($matches[2]) ? $matches[2] : '';          return ' ('.$index.')'.$ext;      }        protected function upcount_name($name) {          return preg_replace_callback(              '/(?:(?: \(([\d]+)\))?(\.[^.]+))?$/',              array($this, 'upcount_name_callback'),              $name,              1          );      }        protected function get_unique_filename($file_path, $name, $size, $type, $error,          $index, $content_range) {          while(is_dir($this->get_upload_path($name))) {              $name = $this->upcount_name($name);          }          // Keep an existing filename if this is part of a chunked upload:          $uploaded_bytes = $this->fix_integer_overflow((int)@$content_range[1]);          while (is_file($this->get_upload_path($name))) {              if ($uploaded_bytes === $this->get_file_size(                      $this->get_upload_path($name))) {                  break;              }              $name = $this->upcount_name($name);          }          return $name;      }        protected function get_valid_image_extensions($file_path) {          switch ($this->imagetype($file_path)) {              case self::IMAGETYPE_JPEG:                  return array('jpg', 'jpeg');              case self::IMAGETYPE_PNG:                  return  array('png');              case self::IMAGETYPE_GIF:                  return array('gif');          }      }        protected function fix_file_extension($file_path, $name, $size, $type, $error,          $index, $content_range) {          // Add missing file extension for known image types:          if (strpos($name, '.') === false &&              preg_match('/^image\/(gif|jpe?g|png)/', $type, $matches)) {              $name .= '.'.$matches[1];          }          if ($this->options['correct_image_extensions']) {              $extensions = $this->get_valid_image_extensions($file_path);              // Adjust incorrect image file extensions:              if (!empty($extensions)) {                  $parts = explode('.', $name);                  $extIndex = count($parts) - 1;                  $ext = strtolower(@$parts[$extIndex]);                  if (!in_array($ext, $extensions)) {                      $parts[$extIndex] = $extensions[0];                      $name = implode('.', $parts);                  }              }          }          return $name;      }        protected function trim_file_name($file_path, $name, $size, $type, $error,          $index, $content_range) {          // Remove path information and dots around the filename, to prevent uploading          // into different directories or replacing hidden system files.          // Also remove control characters and spaces (\x00..\x20) around the filename:          $name = trim($this->basename(stripslashes($name)), "".\x00..\x20"");          // Replace dots in filenames to avoid security issues with servers          // that interpret multiple file extensions, e.g. ""example.php.png"":          $replacement = $this->options['replace_dots_in_filenames'];          if (!empty($replacement)) {              $parts = explode('.', $name);              if (count($parts) > 2) {                  $ext = array_pop($parts);                  $name = implode($replacement, $parts).'.'.$ext;              }          }          // Use a timestamp for empty filenames:          if (!$name) {              $name = str_replace('.', '-', microtime(true));          }          return $name;      }        protected function get_file_name($file_path, $name, $size, $type, $error,          $index, $content_range) {          $name = $this->trim_file_name($file_path, $name, $size, $type, $error,              $index, $content_range);          return $this->get_unique_filename(              $file_path,              $this->fix_file_extension($file_path, $name, $size, $type, $error,                  $index, $content_range),              $size,              $type,              $error,              $index,              $content_range          );      }        protected function get_scaled_image_file_paths($file_name, $version) {          $file_path = $this->get_upload_path($file_name);          if (!empty($version)) {              $version_dir = $this->get_upload_path(null, $version);              if (!is_dir($version_dir)) {                  mkdir($version_dir, $this->options['mkdir_mode'], true);              }              $new_file_path = $version_dir.'/'.$file_name;          } else {              $new_file_path = $file_path;          }          return array($file_path, $new_file_path);      }        protected function gd_get_image_object($file_path, $func, $no_cache = false) {          if (empty($this->image_objects[$file_path]) || $no_cache) {              $this->gd_destroy_image_object($file_path);              $this->image_objects[$file_path] = $func($file_path);          }          return $this->image_objects[$file_path];      }        protected function gd_set_image_object($file_path, $image) {          $this->gd_destroy_image_object($file_path);          $this->image_objects[$file_path] = $image;      }        protected function gd_destroy_image_object($file_path) {          $image = (isset($this->image_objects[$file_path])) ? $this->image_objects[$file_path] : null ;          return $image && imagedestroy($image);      }        protected function gd_imageflip($image, $mode) {          if (function_exists('imageflip')) {              return imageflip($image, $mode);          }          $new_width = $src_width = imagesx($image);          $new_height = $src_height = imagesy($image);          $new_img = imagecreatetruecolor($new_width, $new_height);          $src_x = 0;          $src_y = 0;          switch ($mode) {              case '1': // flip on the horizontal axis                  $src_y = $new_height - 1;                  $src_height = -$new_height;                  break;              case '2': // flip on the vertical axis                  $src_x  = $new_width - 1;                  $src_width = -$new_width;                  break;              case '3': // flip on both axes                  $src_y = $new_height - 1;                  $src_height = -$new_height;                  $src_x  = $new_width - 1;                  $src_width = -$new_width;                  break;              default:                  return $image;          }          imagecopyresampled(              $new_img,              $image,              0,              0,              $src_x,              $src_y,              $new_width,              $new_height,              $src_width,              $src_height          );          return $new_img;      }        protected function gd_orient_image($file_path, $src_img) {          if (!function_exists('exif_read_data')) {              return false;          }          $exif = @exif_read_data($file_path);          if ($exif === false) {              return false;          }          $orientation = (int)@$exif['Orientation'];          if ($orientation < 2 || $orientation > 8) {              return false;          }          switch ($orientation) {              case 2:                  $new_img = $this->gd_imageflip(                      $src_img,                      defined('IMG_FLIP_VERTICAL') ? IMG_FLIP_VERTICAL : 2                  );                  break;              case 3:                  $new_img = imagerotate($src_img, 180, 0);                  break;              case 4:                  $new_img = $this->gd_imageflip(                      $src_img,                      defined('IMG_FLIP_HORIZONTAL') ? IMG_FLIP_HORIZONTAL : 1                  );                  break;              case 5:                  $tmp_img = $this->gd_imageflip(                      $src_img,                      defined('IMG_FLIP_HORIZONTAL') ? IMG_FLIP_HORIZONTAL : 1                  );                  $new_img = imagerotate($tmp_img, 270, 0);                  imagedestroy($tmp_img);                  break;              case 6:                  $new_img = imagerotate($src_img, 270, 0);                  break;              case 7:                  $tmp_img = $this->gd_imageflip(                      $src_img,                      defined('IMG_FLIP_VERTICAL') ? IMG_FLIP_VERTICAL : 2                  );                  $new_img = imagerotate($tmp_img, 270, 0);                  imagedestroy($tmp_img);                  break;              case 8:                  $new_img = imagerotate($src_img, 90, 0);                  break;              default:                  return false;          }          $this->gd_set_image_object($file_path, $new_img);          return true;      }        protected function gd_create_scaled_image($file_name, $version, $options) {          if (!function_exists('imagecreatetruecolor')) {              error_log('Function not found: imagecreatetruecolor');              return false;          }          list($file_path, $new_file_path) =              $this->get_scaled_image_file_paths($file_name, $version);          $type = strtolower(substr(strrchr($file_name, '.'), 1));          switch ($type) {              case 'jpg':              case 'jpeg':                  $src_func = 'imagecreatefromjpeg';                  $write_func = 'imagejpeg';                  $image_quality = isset($options['jpeg_quality']) ?                      $options['jpeg_quality'] : 75;                  break;              case 'gif':                  $src_func = 'imagecreatefromgif';                  $write_func = 'imagegif';                  $image_quality = null;                  break;              case 'png':                  $src_func = 'imagecreatefrompng';                  $write_func = 'imagepng';                  $image_quality = isset($options['png_quality']) ?                      $options['png_quality'] : 9;                  break;              default:                  return false;          }          $src_img = $this->gd_get_image_object(              $file_path,              $src_func,              !empty($options['no_cache'])          );          $image_oriented = false;          if (!empty($options['auto_orient']) && $this->gd_orient_image(                  $file_path,                  $src_img              )) {              $image_oriented = true;              $src_img = $this->gd_get_image_object(                  $file_path,                  $src_func              );          }          $max_width = $img_width = imagesx($src_img);          $max_height = $img_height = imagesy($src_img);          if (!empty($options['max_width'])) {              $max_width = $options['max_width'];          }          if (!empty($options['max_height'])) {              $max_height = $options['max_height'];          }          $scale = min(              $max_width / $img_width,              $max_height / $img_height          );          if ($scale >= 1) {              if ($image_oriented) {                  return $write_func($src_img, $new_file_path, $image_quality);              }              if ($file_path !== $new_file_path) {                  return ",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,2,0,0,0,0,2,0,2,0,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0
symfony_http-foundation_HeaderUtils_8792, HTTP header utility functions.\n\n @author Christian Schmidt <github@chsc.dk>\n,Pomoćne funkcije za http heder.,"class HeaderUtils{    public const DISPOSITION_ATTACHMENT = 'attachment';    public const DISPOSITION_INLINE = 'inline';    /**     * This class should not be instantiated.     */    private function __construct()    {    }    /**     * Splits an HTTP header by one or more separators.     *     * Example:     *     *     HeaderUtils::split(""da, en-gb;q=0.8"", "",;"")     *     // => ['da'], ['en-gb', 'q=0.8']]     *     * @param string $separators List of characters to split on, ordered by     *                           precedence, e.g. "","", "";="", or "",;=""     *     * @return array Nested array with as many levels as there are characters in     *               $separators     */    public static function split(string $header, string $separators): array    {        $quotedSeparators = preg_quote($separators, '/');        preg_match_all('            /                (?!\s)                    (?:                        # quoted-string                        ""(?:[^""\\\\]|\\\\.)*(?:""|\\\\|$)                    |                        # token                        [^""'.$quotedSeparators.']+                    )+                (?<!\s)            |                # separator                \s*                (?<separator>['.$quotedSeparators.'])                \s*            /x', trim($header), $matches, \PREG_SET_ORDER);        return self::groupParts($matches, $separators);    }    /**     * Combines an array of arrays into one associative array.     *     * Each of the nested arrays should have one or two elements. The first     * value will be used as the keys in the associative array, and the second     * will be used as the values, or true if the nested array only contains one     * element. Array keys are lowercased.     *     * Example:     *     *     HeaderUtils::combine([[""foo"", ""abc""], [""bar""]])     *     // => [""foo"" => ""abc"", ""bar"" => true]     */    public static function combine(array $parts): array    {        $assoc = [];        foreach ($parts as $part) {            $name = strtolower($part[0]);            $value = $part[1] ?? true;            $assoc[$name] = $value;        }        return $assoc;    }    /**     * Joins an associative array into a string for use in an HTTP header.     *     * The key and value of each entry are joined with ""="", and all entries     * are joined with the specified separator and an additional space (for     * readability). Values are quoted if necessary.     *     * Example:     *     *     HeaderUtils::toString([""foo"" => ""abc"", ""bar"" => true, ""baz"" => ""a b c""], "","")     *     // => 'foo=abc, bar, baz=""a b c""'     */    public static function toString(array $assoc, string $separator): string    {        $parts = [];        foreach ($assoc as $name => $value) {            if (true === $value) {                $parts[] = $name;            } else {                $parts[] = $name.'='.self::quote($value);            }        }        return implode($separator.' ', $parts);    }    /**     * Encodes a string as a quoted string, if necessary.     *     * If a string contains characters not allowed by the ""token"" construct in     * the HTTP specification, it is backslash-escaped and enclosed in quotes     * to match the ""quoted-string"" construct.     */    public static function quote(string $s): string    {        if (preg_match('/^[a-z0-9!#$%&\'*.^_`|~-]+$/i', $s)) {            return $s;        }        return '""'.addcslashes($s, '""\\""').'""';    }    /**     * Decodes a quoted string.     *     * If passed an unquoted string that matches the ""token"" construct (as     * defined in the HTTP specification), it is passed through verbatimly.     */    public static function unquote(string $s): string    {        return preg_replace('/\\\\(.)|""/', '$1', $s);    }    /**     * Generates an HTTP Content-Disposition field-value.     *     * @param string $disposition      One of ""inline"" or ""attachment""     * @param string $filename         A unicode string     * @param string $filenameFallback A string containing only ASCII characters that     *                                 is semantically equivalent to $filename. If the filename is already ASCII,     *                                 it can be omitted, or just copied from $filename     *     * @return string A string suitable for use as a Content-Disposition field-value     *     * @throws \InvalidArgumentException     *     * @see RFC 6266     */    public static function makeDisposition(string $disposition, string $filename, string $filenameFallback = ''): string    {        if (!\in_array($disposition, [self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE])) {            throw new \InvalidArgumentException(sprintf('The disposition must be either ""%s"" or ""%s"".', self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE));        }        if ('' === $filenameFallback) {            $filenameFallback = $filename;        }        // filenameFallback is not ASCII.        if (!preg_match('/^[\x20-\x7e]*$/', $filenameFallback)) {            throw new \InvalidArgumentException('The filename fallback must only contain ASCII characters.');        }        // percent characters aren't safe in fallback.        if (false !== strpos($filenameFallback, '%')) {            throw new \InvalidArgumentException('The filename fallback cannot contain the ""%"" character.');        }        // path separators aren't allowed in either.        if (false !== strpos($filename, '/') || false !== strpos($filename, '\\') || false !== strpos($filenameFallback, '/') || false !== strpos($filenameFallback, '\\')) {            throw new \InvalidArgumentException('The filename and the fallback cannot contain the ""/"" and ""\\"" characters.');        }        $params = ['filename' => $filenameFallback];        if ($filename !== $filenameFallback) {            $params['filename*'] = ""utf-8''"".rawurlencode($filename);        }        return $disposition.'; '.self::toString($params, ';');    }    /**     * Like parse_str(), but preserves dots in variable names.     */    public static function parseQuery(string $query, bool $ignoreBrackets = false, string $separator = '&'): array    {        $q = [];        foreach (explode($separator, $query) as $v) {            if (false !== $i = strpos($v, ""\0"")) {                $v = substr($v, 0, $i);            }            if (false === $i = strpos($v, '=')) {                $k = urldecode($v);                $v = '';            } else {                $k = urldecode(substr($v, 0, $i));                $v = substr($v, $i);            }            if (false !== $i = strpos($k, ""\0"")) {                $k = substr($k, 0, $i);            }            $k = ltrim($k, ' ');            if ($ignoreBrackets) {                $q[$k][] = urldecode(substr($v, 1));                continue;            }            if (false === $i = strpos($k, '[')) {                $q[] = bin2hex($k).$v;            } else {                $q[] = bin2hex(substr($k, 0, $i)).rawurlencode(substr($k, $i)).$v;            }        }        if ($ignoreBrackets) {            return $q;        }        parse_str(implode('&', $q), $q);        $query = [];        foreach ($q as $k => $v) {            if (false !== $i = strpos($k, '_')) {                $query[substr_replace($k, hex2bin(substr($k, 0, $i)).'[', 0, 1 + $i)] = $v;            } else {                $query[hex2bin($k)] = $v;            }        }        return $query;    }    private static function groupParts(array $matches, string $separators, bool $first = true): array    {        $separator = $separators[0];        $partSeparators = substr($separators, 1);        $i = 0;        $partMatches = [];        $previousMatchWasSeparator = false;        foreach ($matches as $match) {            if (!$first && $previousMatchWasSeparator && isset($match['separator']) && $match['separator'] === $separator) {                $previousMatchWasSeparator = true;                $partMatches[$i][] = $match;            } elseif (isset($match['separator']) && $match['separator'] === $separator) {                $previousMatchWasSeparator = true;                ++$i;            } else {                $previousMatchWasSeparator = false;                $partMatches[$i][] = $match;            }        }        $parts = [];        if ($partSeparators) {            foreach ($partMatches as $matches) {                $parts[] = self::groupParts($matches, $partSeparators, false);            }        } else {            foreach ($partMatches as $matches) {                $parts[] = self::unquote($matches[0][0]);            }            if (!$first && 2 < \count($parts)) {                $parts = [                    $parts[0],                    implode($separator, \array_slice($parts, 1)),                ];            }        }        return $parts;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,3,0,0,0
matomo-org_matomo_LocalTracker_997, Tracker that uses core/Tracker.php directly.\n,Tragač koji direktno koristi glavni Tracker.php,"class Matomo_LocalTracker extends MatomoTracker{    protected function sendRequest($url, $method = 'GET', $data = null, $force = false)    {        self::$DEBUG_LAST_REQUESTED_URL = $url;        if ($this->DEBUG_APPEND_URL) {            $url .= $this->DEBUG_APPEND_URL;        }        // if doing a bulk request, store the url        if ($this->doBulkRequests && !$force) {            $this->storedTrackingActions[] = $url;            return true;        }        if ($method == 'POST') {            $requests = array();            foreach ($this->storedTrackingActions as $action) {                $requests[] = $this->parseUrl($action);            }            $testEnvironmentArgs = array();        } else {            $testEnvironmentArgs = $this->parseUrl($url);            if (!empty($this->token_auth)) {                $testEnvironmentArgs['token_auth'] = $this->token_auth;            }            $requests = array($testEnvironmentArgs);        }        // unset cached values        Cache::$cache = null;        Tracker\Visit::$dimensions = null;        // save some values        $plugins = Config::getInstance()->Plugins['Plugins'];        $oldTrackerConfig = Config::getInstance()->Tracker;        \Piwik\Plugin\Manager::getInstance()->unloadPlugins();        // modify config        \Piwik\SettingsServer::setIsTrackerApiRequest();        $GLOBALS['PIWIK_TRACKER_LOCAL_TRACKING'] = true;        Tracker::$initTrackerMode = false;        Tracker::setTestEnvironment($testEnvironmentArgs, $method);        // set language        $oldLang = isset($_SERVER['HTTP_ACCEPT_LANGUAGE']) ? $_SERVER['HTTP_ACCEPT_LANGUAGE'] : '';        $_SERVER['HTTP_ACCEPT_LANGUAGE'] = $this->acceptLanguage;        // set user agent        $oldUserAgent = isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '';        $_SERVER['HTTP_USER_AGENT'] = $this->userAgent;        // set cookie        $oldCookie = $_COOKIE;//        parse_str(parse_url($this->requestCookie, PHP_URL_QUERY), $_COOKIE);        // do tracking and capture output        ob_start();        $localTracker = new Tracker();        $request = new Tracker\RequestSet();        $request->setRequests($requests);        \Piwik\Plugin\Manager::getInstance()->loadTrackerPlugins();        $handler = Tracker\Handler\Factory::make();        $response = $localTracker->main($handler, $request);        if (!is_null($response)) {            echo $response;        }        $output = ob_get_contents();        ob_end_clean();        // restore vars        Config::getInstance()->Tracker = $oldTrackerConfig;        $_SERVER['HTTP_ACCEPT_LANGUAGE'] = $oldLang;        $_SERVER['HTTP_USER_AGENT'] = $oldUserAgent;        $_COOKIE = $oldCookie;        $GLOBALS['PIWIK_TRACKER_LOCAL_TRACKING'] = false;        \Piwik\SettingsServer::setIsNotTrackerApiRequest();        unset($_GET['bots']);        // reload plugins        \Piwik\Plugin\Manager::getInstance()->loadPlugins($plugins);        return $output;    }    private function parseUrl($url)    {        // parse url        $query = parse_url($url, PHP_URL_QUERY);        if ($query === false) {            return;        }        parse_str($query, $args);        // make sure bots is set if needed        if (isset($args['bots'])) {            $_GET['bots'] = true;        }        return $args;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0
dompdf_dompdf_Helpers_612," Builds a HTTP Content-Disposition header string using `$dispositionType`\n and `$filename`.\n\n If the filename contains any characters not in the ISO-8859-1 character\n set, a fallback filename will be included for clients not supporting the\n `filename\n @param string $dispositionType\n @param string $filename\n @return string\n",Izgradi niz Http zaglavlja despozicije sadržaja koristeći tip despozicije i naziv fajla. Ako datoteka sadrži znakove koji nisu u skupu znakova ISO-8859-1 biće zamenjeno rezervnim imenom datoteke za klijente koji ga ne podržavaju.,"    public static function buildContentDispositionHeader($dispositionType, $filename)    {        $encoding = mb_detect_encoding($filename);        $fallbackfilename = mb_convert_encoding($filename, ""ISO-8859-1"", $encoding);        $fallbackfilename = str_replace(""\"""", """", $fallbackfilename);        $encodedfilename = rawurlencode($filename);        $contentDisposition = ""Content-Disposition: $dispositionType; filename=\""$fallbackfilename\"""";        if ($fallbackfilename !== $filename) {            $contentDisposition .= ""; filename*=UTF-8''$encodedfilename"";        }        return $contentDisposition;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_helpers_730, Helper method to get the current User.\n Defaults to public 'Guest' user if not logged in.\n,Pomoćna metoda za dohvatanje trenutno prijavljenog korisnika. Podrazumevano vraća javno dostupnog gost korisnika ukoliko nema prijave.,function user(): User{    return auth()->user() ?: User::getDefault();},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_helpers_732, Check if the current user has general access.\n,Proveri da li trnutan korisnik ima opšti pristup.,function hasAppAccess(): bool{    return !auth()->guest() || setting('app-public');},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_202609_CreateIncidentsTable_1182, Run the migrations.\n,Pokreni migraciju,"    public function up()    {        Schema::create('incidents', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->integer('component_id')->default(0);            $table->string('name');            $table->integer('status');            $table->longText('message');            $table->integer('user_id');            $table->timestamps();            $table->softDeletes();            $table->index('component_id');            $table->index('status');            $table->index('user_id');        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_202609_CreateIncidentsTable_1183, Reverse the migrations.\n,Poništi migracije,    public function down()    {        Schema::drop('incidents');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_202730_CreateMetricPointsTable_1185, Reverse the migrations.\n,Poništi migracije,    public function down()    {        Schema::drop('metric_points');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_202826_CreateMetricsTable_1186, Run the migrations.\n,Pokreni migraciju,"    public function up()    {        Schema::create('metrics', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->string('name');            $table->string('suffix');            $table->text('description');            $table->decimal('default_value', 10, 3);            $table->tinyInteger('calc_type');            $table->boolean('display_chart')->default(1);            $table->timestamps();            $table->index('display_chart');        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_ComponentGroupTest_1213, This is the component group test class.\n\n @author James Brooks <james@alt-three.com>\n @author Graham Campbell <graham@alt-three.com>\n,Ovo je klasa koja ispituje grupaciju komponenti.,"class ComponentGroupTest extends AbstractApiTestCase{    const COMPONENT_GROUP_1_NAME = 'Component Group 1';    const COMPONENT_GROUP_2_NAME = 'Component Group 2';    public function test_can_get_all_component_groups()    {        $groups = factory(ComponentGroup::class, 2)            ->create(['visible' => ComponentGroup::VISIBLE_GUEST]);        $response = $this->json('GET', '/api/v1/components/groups');        $response->assertStatus(200);        $response->assertJsonFragment([            [                'id'                        => $groups[0]->id,                'name'                      => $groups[0]->name,                'created_at'                => (string) $groups[0]->created_at,                'updated_at'                => (string) $groups[0]->updated_at,                'order'                     => $groups[0]->order,                'collapsed'                 => $groups[0]->collapsed,                'visible'                   => $groups[0]->visible,                'enabled_components'        => $groups[0]->enabled_components,                'enabled_components_lowest' => $groups[0]->enabled_components_lowest,                'lowest_human_status'       => $groups[0]->lowest_human_status,            ],        ]);        $response->assertJsonFragment([            [                'id'                        => $groups[1]->id,                'name'                      => $groups[1]->name,                'created_at'                => (string) $groups[1]->created_at,                'updated_at'                => (string) $groups[1]->updated_at,                'order'                     => $groups[1]->order,                'collapsed'                 => $groups[1]->collapsed,                'visible'                   => $groups[1]->visible,                'enabled_components'        => $groups[1]->enabled_components,                'enabled_components_lowest' => $groups[1]->enabled_components_lowest,                'lowest_human_status'       => $groups[1]->lowest_human_status,            ],        ]);    }    public function test_cannot_get_invalid_component_group()    {        $response = $this->json('GET', '/api/v1/components/groups/1');        $response->assertStatus(404);    }    public function test_cannot_create_component_group_without_authorization()    {        $this->doesntExpectEvents(ComponentGroupWasCreatedEvent::class);        $response = $this->json('POST', '/api/v1/components/groups');        $response->assertStatus(401);    }    public function test_cannot_create_component_group_without_data()    {        $this->beUser();        $this->doesntExpectEvents(ComponentGroupWasCreatedEvent::class);        $response = $this->json('POST', '/api/v1/components/groups');        $response->assertStatus(400);    }    public function test_can_create_new_component_group()    {        $this->beUser();        $this->expectsEvents(ComponentGroupWasCreatedEvent::class);        $response = $this->json('POST', '/api/v1/components/groups', [            'name'      => 'Foo',            'order'     => 1,            'collapsed' => 1,            'visible'   => ComponentGroup::VISIBLE_GUEST,        ]);        $response->assertStatus(200);        $response->assertJsonFragment([            'name'      => 'Foo',            'order'     => 1,            'collapsed' => 1,            'visible'   => ComponentGroup::VISIBLE_GUEST,        ]);    }    public function test_can_get_single_component_group()    {        $group = factory(ComponentGroup::class)->create();        $response = $this->json('GET', '/api/v1/components/groups/1');        $response->assertStatus(200);        $response->assertJsonFragment(['name' => $group->name]);    }    public function test_can_update_component_group()    {        $this->beUser();        $group = factory(ComponentGroup::class)->create();        $this->expectsEvents(ComponentGroupWasUpdatedEvent::class);        $response = $this->json('PUT', '/api/v1/components/groups/1', [            'name' => 'Lorem Ipsum Groupous',        ]);        $response->assertStatus(200);        $response->assertJsonFragment(['name' => 'Lorem Ipsum Groupous']);    }    public function test_can_delete_component_group()    {        $this->beUser();        $group = factory(ComponentGroup::class)->create();        $this->expectsEvents(ComponentGroupWasRemovedEvent::class);        $response = $this->json('DELETE', '/api/v1/components/groups/1');        $response->assertStatus(204);    }    public function test_only_public_component_groups_are_shown_for_a_guest()    {        $this->createComponentGroups();        $response = $this->json('GET', '/api/v1/components/groups');        $response->assertStatus(200);        $response->assertJsonFragment(['name' => self::COMPONENT_GROUP_1_NAME]);    }    public function test_all_component_groups_are_displayed_for_logged_in_users()    {        $this->createComponentGroups()            ->signIn();        $response = $this->json('GET', '/api/v1/components/groups');        $response->assertStatus(200);        $response->assertJsonFragment(['name' => self::COMPONENT_GROUP_1_NAME]);    }    /**     * Set up the needed data for the tests.     *     * @return $this     */    protected function createComponentGroups()    {        $this->createComponentGroup(self::COMPONENT_GROUP_1_NAME, ComponentGroup::VISIBLE_GUEST)            ->createComponentGroup(self::COMPONENT_GROUP_2_NAME, ComponentGroup::VISIBLE_AUTHENTICATED);        return $this;    }    /**     * Create a component group.     *     * Also attaches a creator if any given as a parameter or exists in the test class.     *     * @param string $name     * @param string $visible     *     * @return $this     */    protected function createComponentGroup($name, $visible)    {        factory(ComponentGroup::class)            ->create(['name' => $name, 'visible' => $visible]);        return $this;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_CreateComponentCommand_1165, This is the create component command class.\n\n @author James Brooks <james@alt-three.com>\n,Ovo je klasa koja pravi komponente naredbi.,"final class CreateComponentCommand{    /**     * The component name.     *     * @var string     */    public $name;    /**     * The component description.     *     * @var string     */    public $description;    /**     * The component status.     *     * @var int     */    public $status;    /**     * The component link.     *     * @var string     */    public $link;    /**     * The component order.     *     * @var int     */    public $order;    /**     * The component group.     *     * @var int     */    public $group_id;    /**     * Is the component enabled?     *     * @var bool     */    public $enabled;    /**     * JSON meta data for the component.     *     * @var array|null     */    public $meta;    /**     * Tags string.     *     * @var string     */    public $tags;    /**     * The validation rules.     *     * @var string[]     */    public $rules = [        'name'        => 'required|string',        'description' => 'nullable|string',        'status'      => 'required|int|min:0|max:4',        'link'        => 'nullable|url',        'order'       => 'nullable|int',        'group_id'    => 'nullable|int',        'enabled'     => 'nullable|bool',        'meta'        => 'nullable|array',        'tags'        => 'nullable|string',    ];    /**     * Create a new add component command instance.     *     * @param string      $name     * @param string      $description     * @param int         $status     * @param string      $link     * @param int         $order     * @param int         $group_id     * @param bool        $enabled     * @param array|null  $meta     * @param string|null $tags     *     * @return void     */    public function __construct($name, $description, $status, $link, $order, $group_id, $enabled, $meta, $tags = null)    {        $this->name = $name;        $this->description = $description;        $this->status = (int) $status;        $this->link = $link;        $this->order = $order;        $this->group_id = $group_id;        $this->enabled = $enabled;        $this->meta = $meta;        $this->tags = $tags;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_IncidentTemplateTest_1218, This is the incident template test class.\n\n @author Marc Hagen <hello@marchagen.nl>\n,Ovo je klasa koja ispituje šablon za incident. ,"class IncidentTemplateTest extends AbstractApiTestCase{    public function test_can_get_all_incident_templates()    {        $templates = factory(IncidentTemplate::class, 3)->create();        $response = $this->json('GET', '/api/v1/incidents/templates');        $response->assertJsonFragment(['id' => $templates[0]->id]);        $response->assertJsonFragment(['id' => $templates[1]->id]);        $response->assertJsonFragment(['id' => $templates[2]->id]);        $response->assertStatus(200);    }    public function test_cannot_get_invalid_incident_template()    {        $response = $this->json('GET', '/api/v1/incidents/templates/1');        $response->assertStatus(404);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_SmokeTest_1199, This is the smoke test class.\n\n @author James Brooks <james@alt-three.com>\n,Ovo je klasa za smoke testiranje.,"class SmokeTest extends AbstractTestCase{    use DatabaseMigrations;    public function test_setup_page()    {        $this->get('/setup')->assertStatus(200);    }    public function test_status_page()    {        $this->configureApp();        $this->get('/')->assertStatus(200);    }    public function test_single_component_page()    {        $this->configureApp();        $this->get('/incidents/1')->assertStatus(200);    }    public function test_dashboard_auth_page()    {        $this->configureApp();        $this->get('/auth/login')->assertStatus(200);    }    protected function configureApp()    {        factory(Setting::class)->create([            'name'  => 'app_name',            'value' => 'Cachet Test Suite',        ]);        $component = factory(Component::class)->create();        $incident = factory(Incident::class)->create([            'component_id' => $component->id,        ]);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_TestListener_1203, A failure occurred.\n,Prijavi grešku.,"    public function addFailure(Test $test, AssertionFailedError $e, float $time): void    {        //    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_TestListener_1205, Risky test.\n,Dodaj riskantan test.,"    public function addRiskyTest(Test $test, \Throwable $t, float $time): void    {        //    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_TestListener_1206, Skipped test.\n,Dodaj skipped test.,"    public function addSkippedTest(Test $test, \Throwable $t, float $time): void    {        //    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_TestListener_1207, A test suite started.\n,Pokreni testni paket.,    public function startTestSuite(TestSuite $suite): void    {        //    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_TestListener_1208, A test suite ended.\n,Završi testni paket.,"    public function endTestSuite(TestSuite $suite): void    {        if ($suite->getName() !== 'Cachet Test Suite') {            return;        }        foreach (glob(__DIR__.'/../bootstrap/cache{,t}/*.php', GLOB_BRACE) as $file) {            unlink($file);        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_TestListener_1209, A test started.\n,Pokreni test.,    public function startTest(Test $test): void    {        //    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_UpdateComponentGroupCommand_1171, Create a add component group command instance.\n\n @param \\CachetHQ\\Cachet\\Models\\ComponentGroup $group\n @param string                                 $name\n @param int                                    $order\n @param int                                    $collapsed\n @param int                                    $visible\n\n @return void\n,Kreiraj instancu naredbe za dodavanje grupe komponenata.,"    public function __construct(ComponentGroup $group, $name, $order, $collapsed, $visible)    {        $this->group = $group;        $this->name = $name;        $this->order = (int) $order;        $this->collapsed = $collapsed;        $this->visible = (int) $visible;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_helpers_1162, Darken a color.\n\n @param string $hex\n @param int    $percent\n\n @return string\n,Dohvati tamniju nijansu boje.,"    function color_darken($hex, $percent)    {        $hex = preg_replace('/[^0-9a-f]/i', '', $hex);        $new_hex = '#';        if (strlen($hex) < 6) {            $hex = $hex[0] + $hex[0] + $hex[1] + $hex[1] + $hex[2] + $hex[2];        }        for ($i = 0; $i < 3; $i++) {            $dec = hexdec(substr($hex, $i * 2, 2));            $dec = min(max(0, $dec + $dec * $percent), 255);            $new_hex .= str_pad(dechex($dec), 2, 0, STR_PAD_LEFT);        }        return $new_hex;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_6667," Each concrete command is built with different receivers.\n There can be one, many or completely no receivers, but there can be other commands in the parameters.\n","Svaka konkretna naredba izgrađena je sa različitim prijemnicima. Moguće je proslediti jedan, više ili nijedan prijemnik kao parametar funkcije. Takođe mogu se javiti i druge komande kao parametri funkcije.",    public function __construct(private Receiver $output)    {    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_7426, Undo the command and make receiver to disable displaying messages date.\n,Poništi poslednju komandu i napravi prijemnik koji će da onemogući prikazivanje datuma poruke.,"    public function undo()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->disableDate();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_EBookAdapter_6689, This class makes the proper translation from one interface to another.\n,Ova klasa omogućava odgovarajuću tranziciju iz jednog interfejsa u drugi.,    public function open()    {        $this->eBook->unlock();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_EBook_6687," returns current page and total number of pages, like [10, 100] is page 10 of 100\n\n @return int[]\n","Vraća trenutnu stranicu i ukupan broj stranica u formatu [10, 100] gde je 10 broj trenutne stranice od njih 100.",    public function getPage(): array;,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Handler_6665, This approach by using a template method pattern ensures you that\n each subclass will not forget to call the successor\n,Korišćenjem šablonske metode osigurava se da će svaka podklasa pozvati i odgovarajuće metode nadklase.,    final public function handle(RequestInterface $request): ?string    {        $processed = $this->processing($request);        if ($processed === null && $this->successor !== null) {            // the request has not been processed by this handler => see the next            $processed = $this->successor->handle($request);        }        return $processed;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_HelloCommand_6398," This concrete command calls ""print"" on the Receiver, but an external\n invoker just knows that it can call ""execute""\n","Ova konkretna komanda poziva ""ispiši"" metodu na prijemniku. Tada će pozivalac znati da može da pozove ""izvrši"" metodu.","class HelloCommand implements Command{    /**     * Each concrete command is built with different receivers.     * There can be one, many or completely no receivers, but there can be other commands in the parameters     */    public function __construct(private Receiver $output)    {    }    /**     * execute and output ""Hello World"".     */    public function execute()    {        // sometimes, there is no receiver and this is the command which does all the work        $this->output->write('Hello World');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Invoker_6676, executes the command; the invoker is the same whatever is the command\n,Ova metoda izvršava komandu. Pozivalac je uvek isti bez obzira na tip komande.,    public function run()    {        $this->command->execute();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Invoker_7047, Invoker is using the command given to it.\n Example : an Application in SF2.\n,Klasa pozivalac koristi komandu koja mi je prosleđena. Primer:  Aplikacija u SF2,"class Invoker{    private Command $command;    /**     * in the invoker we find this kind of method for subscribing the command     * There can be also a stack, a list, a fixed set ...     */    public function setCommand(Command $cmd)    {        $this->command = $cmd;    }    /**     * executes the command; the invoker is the same whatever is the command     */    public function run()    {        $this->command->execute();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Kindle_6418," this is the adapted class. In production code, this could be a class from another package, some vendor code.\n Notice that it uses another naming scheme and the implementation does something similar but in another way\n","Ovo je prilagođena klasa. U kodu za proizvodnju ovo može biti klasa iz drugog paketa, ili nekog vendor koda. Obrati pažnju da koristi drugu šemu imenovanja i da implementacija radi nešto slično samo na drugi način.","class Kindle implements EBook{    private int $page = 1;    private int $totalPages = 100;    public function pressNext()    {        $this->page++;    }    public function unlock()    {    }    /**     * returns current page and total number of pages, like [10, 100] is page 10 of 100     *     * @return int[]     */    public function getPage(): array    {        return [$this->page, $this->totalPages];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_PostId_6411, This is a perfect example of a value object that is identifiable by it's value alone and\n is guaranteed to be valid each time an instance is created. Another important property of value objects\n is immutability.\n\n Notice also the use of a named constructor (fromInt) which adds a little context when creating an instance.\n,Ovo je odličan primer klase čiji objeki enkapsuliraju vrednost. Objekat je određen samom njegovom vrednošću i njegova validnost je zagarantovana prilikom kreiranja. Driga važna osobina vrednost objekta je nepromenljivost njegovog unutrašnjeg stanja. Obrati pažnju da se koristi imenovan konstruktor(iz int) koja pomalo utiče na kontekst prilikom kreiranja objekta.,class PostId{    public static function fromInt(int $id): PostId    {        self::ensureIsValid($id);        return new self($id);    }    private function __construct(private int $id)    {    }    public function toInt(): int    {        return $this->id;    }    private static function ensureIsValid(int $id)    {        if ($id <= 0) {            throw new InvalidArgumentException('Invalid PostId given');        }    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_PostRepository_6410, This class is situated between Entity layer (class Post) and access object layer (Persistence).\n\n Repository encapsulates the set of objects persisted in a data store and the operations performed over them\n providing a more object-oriented view of the persistence layer\n\n Repository also supports the objective of achieving a clean separation and one-way dependency\n between the domain and data mapping layers\n,Ova klasa predstavlja sponu između Entitet sloja (klasa Post) i sloja za pristup objektima (Baza podataka). Repository enkapsulira set objekata koji su smešteni u bazi podataka i operacije koje se izvršavaju nad njima. Ovakav pristup omogućava objektno orijentisanu realizaciju sloja za čuvanje podataka. On takođe doprinosi cilju jasnog razdvajanja logike  domena i sloja za mapiranje podataka i njihovu jednosmernu zavisnost. ,"class PostRepository{    public function __construct(private Persistence $persistence)    {    }    public function generateId(): PostId    {        return PostId::fromInt($this->persistence->generateId());    }    public function findById(PostId $id): Post    {        try {            $arrayData = $this->persistence->retrieve($id->toInt());        } catch (OutOfBoundsException $e) {            throw new OutOfBoundsException(sprintf('Post with id %d does not exist', $id->toInt()), 0, $e);        }        return Post::fromState($arrayData);    }    public function save(Post $post)    {        $this->persistence->persist([            'id' => $post->getId()->toInt(),            'statusId' => $post->getStatus()->toInt(),            'text' => $post->getText(),            'title' => $post->getTitle(),        ]);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_PostStatus_6685," Like PostId, this is a value object which holds the value of the current status of a Post. It can be constructed\n either from a string or int and is able to validate itself. An instance can then be converted back to int or string.\n","Ova klasa, kao i klasa Postid, enkapsulira vrednost u ovom slučaju vrednost statusa klase Post. Konstruiše se iz string ili int tipa pri čemu se vrši validacija kreiranog objekta. Instancirani objekat se može konvertovati nazad u int ili string.","class PostStatus{    const STATE_DRAFT_ID = 1;    const STATE_PUBLISHED_ID = 2;    const STATE_DRAFT = 'draft';    const STATE_PUBLISHED = 'published';    private static array $validStates = [        self::STATE_DRAFT_ID => self::STATE_DRAFT,        self::STATE_PUBLISHED_ID => self::STATE_PUBLISHED,    ];    public static function fromInt(int $statusId)    {        self::ensureIsValidId($statusId);        return new self($statusId, self::$validStates[$statusId]);    }    public static function fromString(string $status)    {        self::ensureIsValidName($status);        $state = array_search($status, self::$validStates);        if ($state === false) {            throw new InvalidArgumentException('Invalid state given!');        }        return new self($state, $status);    }    private function __construct(private int $id, private string $name)    {    }    public function toInt(): int    {        return $this->id;    }    /**     * there is a reason that I avoid using __toString() as it operates outside of the stack in PHP     * and is therefor not able to operate well with exceptions     */    public function toString(): string    {        return $this->name;    }    private static function ensureIsValidId(int $status)    {        if (!in_array($status, array_keys(self::$validStates), true)) {            throw new InvalidArgumentException('Invalid status id given');        }    }    private static function ensureIsValidName(string $status)    {        if (!in_array($status, self::$validStates, true)) {            throw new InvalidArgumentException('Invalid status name given');        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Receiver_6405, Enable receiver to display message date\n,Omogući prijemniku da prikaže datum poruke.,    public function enableDate()    {        $this->enableDate = true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Receiver_6679, Disable receiver to display message date\n,Onemogući prijemniku da prikaže datum poruke.,    public function disableDate()    {        $this->enableDate = false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Receiver_7050, Receiver is a specific service with its own contract and can be only concrete.\n,Klasa prijemnik je specfičan servis koji poseduje sopstveni ugovor i može biti jedino konkretan.,"class Receiver{    private bool $enableDate = false;    /**     * @var string[]     */    private array $output = [];    public function write(string $str)    {        if ($this->enableDate) {            $str .= ' ['.date('Y-m-d').']';        }        $this->output[] = $str;    }    public function getOutput(): string    {        return join(""\n"", $this->output);    }    /**     * Enable receiver to display message date     */    public function enableDate()    {        $this->enableDate = true;    }    /**     * Disable receiver to display message date     */    public function disableDate()    {        $this->enableDate = false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_UndoableCommand_6680, This method is used to undo change made by command execution\n,Ova metoda se koristi da poništi promenu izazvana izvršavanjem poslednje komande.,    public function undo();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractDoctrineAnnotationFixer_7624, Fixes Doctrine annotations from the given PHPDoc style comment.\n,Ispravlja anotacije doktrine u datom PHPDoc komentaru.,    abstract protected function fixAnnotations(DoctrineAnnotationTokens $doctrineAnnotationTokens): void;,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractLinesBeforeNamespaceFixer_6607, Make sure # of line breaks prefixing namespace is within given range.\n\n @param int $expectedMin min. # of line breaks\n @param int $expectedMax max. # of line breaks\n,Osiguraj da je # prelamanje linije koji predhodi prefiksu prostora imena u datom opsegu.  ,"    protected function fixLinesBeforeNamespace(Tokens $tokens, int $index, int $expectedMin, int $expectedMax): void    {        // Let's determine the total numbers of new lines before the namespace        // and the opening token        $openingTokenIndex = null;        $precedingNewlines = 0;        $newlineInOpening = false;        $openingToken = null;        for ($i = 1; $i <= 2; ++$i) {            if (isset($tokens[$index - $i])) {                $token = $tokens[$index - $i];                if ($token->isGivenKind(T_OPEN_TAG)) {                    $openingToken = $token;                    $openingTokenIndex = $index - $i;                    $newlineInOpening = false !== strpos($token->getContent(), ""\n"");                    if ($newlineInOpening) {                        ++$precedingNewlines;                    }                    break;                }                if (false === $token->isGivenKind(T_WHITESPACE)) {                    break;                }                $precedingNewlines += substr_count($token->getContent(), ""\n"");            }        }        if ($precedingNewlines >= $expectedMin && $precedingNewlines <= $expectedMax) {            return;        }        $previousIndex = $index - 1;        $previous = $tokens[$previousIndex];        if (0 === $expectedMax) {            // Remove all the previous new lines            if ($previous->isWhitespace()) {                $tokens->clearAt($previousIndex);            }            // Remove new lines in opening token            if ($newlineInOpening) {                $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, rtrim($openingToken->getContent()).' ']);            }            return;        }        $lineEnding = $this->whitespacesConfig->getLineEnding();        $newlinesForWhitespaceToken = $expectedMax;        if (null !== $openingToken) {            // Use the configured line ending for the PHP opening tag            $content = rtrim($openingToken->getContent());            $newContent = $content.$lineEnding;            $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, $newContent]);            --$newlinesForWhitespaceToken;        }        if (0 === $newlinesForWhitespaceToken) {            // We have all the needed new lines in the opening tag            if ($previous->isWhitespace()) {                // Let's remove the previous token containing extra new lines                $tokens->clearAt($previousIndex);            }            return;        }        if ($previous->isWhitespace()) {            // Fix the previous whitespace token            $tokens[$previousIndex] = new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken).substr($previous->getContent(), strrpos($previous->getContent(), ""\n"") + 1)]);        } else {            // Add a new whitespace token            $tokens->insertAt($index, new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken)]));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractLinesBeforeNamespaceFixer_7636, This abstract fixer is responsible for ensuring that a certain number of\n lines prefix a namespace declaration.\n\n @author Graham Campbell <graham@alt-three.com>\n\n @internal\n,Ova apstraktna klasa popravljača je odgovorana da se broj linija koja predhodi deklaraciji prostora imena ograniči na određeni broj.,"abstract class AbstractLinesBeforeNamespaceFixer extends AbstractFixer implements WhitespacesAwareFixerInterface{    /**     * Make sure # of line breaks prefixing namespace is within given range.     *     * @param int $expectedMin min. # of line breaks     * @param int $expectedMax max. # of line breaks     */    protected function fixLinesBeforeNamespace(Tokens $tokens, int $index, int $expectedMin, int $expectedMax): void    {        // Let's determine the total numbers of new lines before the namespace        // and the opening token        $openingTokenIndex = null;        $precedingNewlines = 0;        $newlineInOpening = false;        $openingToken = null;        for ($i = 1; $i <= 2; ++$i) {            if (isset($tokens[$index - $i])) {                $token = $tokens[$index - $i];                if ($token->isGivenKind(T_OPEN_TAG)) {                    $openingToken = $token;                    $openingTokenIndex = $index - $i;                    $newlineInOpening = false !== strpos($token->getContent(), ""\n"");                    if ($newlineInOpening) {                        ++$precedingNewlines;                    }                    break;                }                if (false === $token->isGivenKind(T_WHITESPACE)) {                    break;                }                $precedingNewlines += substr_count($token->getContent(), ""\n"");            }        }        if ($precedingNewlines >= $expectedMin && $precedingNewlines <= $expectedMax) {            return;        }        $previousIndex = $index - 1;        $previous = $tokens[$previousIndex];        if (0 === $expectedMax) {            // Remove all the previous new lines            if ($previous->isWhitespace()) {                $tokens->clearAt($previousIndex);            }            // Remove new lines in opening token            if ($newlineInOpening) {                $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, rtrim($openingToken->getContent()).' ']);            }            return;        }        $lineEnding = $this->whitespacesConfig->getLineEnding();        $newlinesForWhitespaceToken = $expectedMax;        if (null !== $openingToken) {            // Use the configured line ending for the PHP opening tag            $content = rtrim($openingToken->getContent());            $newContent = $content.$lineEnding;            $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, $newContent]);            --$newlinesForWhitespaceToken;        }        if (0 === $newlinesForWhitespaceToken) {            // We have all the needed new lines in the opening tag            if ($previous->isWhitespace()) {                // Let's remove the previous token containing extra new lines                $tokens->clearAt($previousIndex);            }            return;        }        if ($previous->isWhitespace()) {            // Fix the previous whitespace token            $tokens[$previousIndex] = new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken).substr($previous->getContent(), strrpos($previous->getContent(), ""\n"") + 1)]);        } else {            // Add a new whitespace token            $tokens->insertAt($index, new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken)]));        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractNoUselessElseFixer_6883," Return the first and last token index of the previous block.\n\n [0] First is either T_IF, T_ELSE or T_ELSEIF\n [1] Last is either '}' or ';' / T_CLOSE_TAG for short notation blocks\n\n @param int $index T_IF, T_ELSE, T_ELSEIF\n\n @return int[]\n","Vrati prvi i poslednji indeks tokena predhodnog bloka. Prvi je T_IF, T_ELSE, ili T_ELSEIF a poslednji '}' ili ';'. T_CLOSE_TAG koristi se za kratke blokove notacije.","    private function getPreviousBlock(Tokens $tokens, int $index): array    {        $close = $previous = $tokens->getPrevMeaningfulToken($index);        // short 'if' detection        if ($tokens[$close]->equals('}')) {            $previous = $tokens->findBlockStart(Tokens::BLOCK_TYPE_CURLY_BRACE, $close);        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_6892, This abstract fixer provides a base for fixers to fix types in PHPDoc.\n\n @author Graham Campbell <graham@alt-three.com>\n\n @internal\n,Abstraktna klasa popravljač predstavlja osnovnu klasu za popravljače čiji zadatak će biti ispravljanje tipova u PHPDoc.,"abstract class AbstractPhpdocTypesFixer extends AbstractFixer{    /**     * The annotation tags search inside.     *     * @var string[]     */    protected $tags;    /**     * {@inheritdoc}     */    public function __construct()    {        parent::__construct();        $this->tags = Annotation::getTagsWithTypes();    }    /**     * {@inheritdoc}     */    public function isCandidate(Tokens $tokens): bool    {        return $tokens->isTokenKindFound(T_DOC_COMMENT);    }    /**     * {@inheritdoc}     */    protected function applyFix(\SplFileInfo $file, Tokens $tokens): void    {        foreach ($tokens as $index => $token) {            if (!$token->isGivenKind(T_DOC_COMMENT)) {                continue;            }            $doc = new DocBlock($token->getContent());            $annotations = $doc->getAnnotationsOfType($this->tags);            if (empty($annotations)) {                continue;            }            foreach ($annotations as $annotation) {                $this->fixTypes($annotation);            }            $tokens[$index] = new Token([T_DOC_COMMENT, $doc->getContent()]);        }    }    /**     * Actually normalize the given type.     */    abstract protected function normalize(string $type): string;    /**     * Fix the types at the given line.     *     * We must be super careful not to modify parts of words.     *     * This will be nicely handled behind the scenes for us by the annotation class.     */    private function fixTypes(Annotation $annotation): void    {        $types = $annotation->getTypes();        $new = $this->normalizeTypes($types);        if ($types !== $new) {            $annotation->setTypes($new);        }    }    /**     * @param string[] $types     *     * @return string[]     */    private function normalizeTypes(array $types): array    {        foreach ($types as $index => $type) {            $types[$index] = $this->normalizeType($type);        }        return $types;    }    /**     * Prepare the type and normalize it.     */    private function normalizeType(string $type): string    {        if ('[]' === substr($type, -2)) {            return $this->normalizeType(substr($type, 0, -2)).'[]';        }        return $this->normalize($type);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_6896, Actually normalize the given type.\n,Normalizuj vrednost datog tipa.,    abstract protected function normalize(string $type): string;,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_6899, Prepare the type and normalize it.\n,Pripremi tip i normalizuj ga.,"    private function normalizeType(string $type): string    {        if ('[]' === substr($type, -2)) {            return $this->normalizeType(substr($type, 0, -2)).'[]';        }        return $this->normalize($type);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_403, Initiates color object from integer\\\\n\\\\n @param  int $value\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n,Inicijalizuj objekat boje iz celog broja.,    abstract public function initFromInteger($value);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_404, Initiates color object from given array\\n\\n @param  array $value\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n,Inicijalizuj objekat boje iz datog niza.,    abstract public function initFromArray($value);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_405, Initiates color object from given string\\\\n\\\\n @param  string $value\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n,Inicijalizuj objekat boje iz datog stringa.,    abstract public function initFromString($value);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_407," Initiates color object from given R, G and B values\\n\\n @param  int $r\\n @param  int $g\\n @param  int $b\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n","Inicijalizuj objekat boje iz datog R, G i B vrednosti.","    abstract public function initFromRgb($r, $g, $b);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_408," Initiates color object from given R, G, B and A values\n\n @param  int $r\n @param  int $g\n @param  int $b\n @param  float   $a\n @return \\Intervention\\Image\\AbstractColor\n","Inicijalizuj objekat boje iz datog R, G, B i A vrednosti.","    abstract public function initFromRgba($r, $g, $b, $a);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_409, Calculates integer value of current color instance\n\n @return int\n,Dohvati int vrednost trenutne instance boje.,    abstract public function getInt();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_410, Calculates hexadecimal value of current color instance\\n\\n @param  string $prefix\\n @return string\\n,Dohvati heksadecimalnu vrednost trnutne instance boje.,    abstract public function getHex($prefix);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_412, Calculates RGBA in string format of current color instance\n\n @return string\n,Dohvati RGBA vrednosti u string formatu trenutne instance boje.,    abstract public function getRgba();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractCommand_535, Executes current command on given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return mixed\\n,Izvrši trenuntu komandu na priloženoj slici.,    abstract public function execute($image);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractCommand_536, Creates new command instance\\\\n\\\\n @param array $arguments\\\\n,Kreiraj novu instancu komande.,    public function __construct($arguments)    {        $this->arguments = $arguments;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractCommand_538, Returns output data of current command\\n\\n @return mixed\\n,Dohvati izlazne podatke trenutne komande.,    public function getOutput()    {        return $this->output ? $this->output : null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractCommand_539, Determines if current instance has output data\\\\n\\\\n @return boolean\\\\n,Odredi da li trenutna instanca komande ima izlazne podatke.,    public function hasOutput()    {        return ! is_null($this->output);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractCommand_540, Sets output data of current command\\n\\n @param mixed $value\\n,Postavi izlazne podatke trenutne komade.,    public function setOutput($value)    {        $this->output = $value;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_416, Initiates new image from path in filesystem\n\n @param  string $path\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku sa date putanje u fajl sistemu.,    abstract public function initFromPath($path);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_417, Initiates new image from binary data\\n\\n @param  string $data\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicijalizuj novu sliku iz binarnog podatka.,    abstract public function initFromBinary($data);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_420, Init from given URL\\n\\n @param  string $url\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicijalizuj sliku iz datog URL-a,"    public function initFromUrl($url)    {                $options = [            'http' => [                'method'=>""GET"",                'header'=>""Accept-language: en\r\n"".                ""User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1216.0 Safari/537.2\r\n""          ]        ];                $context  = stream_context_create($options);                if ($data = @file_get_contents($url, false, $context)) {            return $this->initFromBinary($data);        }        throw new NotReadableException(            ""Unable to init from given url ("".$url."").""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_422, Determines if current source data is GD resource\n\n @return boolean\n,Odredi da li je trenutan izvor podatka slike iz GD resursa.,    public function isGdResource()    {        if (is_resource($this->data)) {            return (get_resource_type($this->data) == 'gd');        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_424, Determines if current source data is Intervention\\\\Image\\\\Image object\\n\\n @return boolean\\n,Odredi da li je trenutan izvor podatka slike intervencija.,"    public function isInterventionImage()    {        return is_a($this->data, '\Intervention\Image\Image');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_426, Determines if current data is Symfony UploadedFile component\\\\n\\\\n @return boolean\\\\n,Odredi da li je trenutan podatak Simfonijski UploadFile komponenta.,"    public function isSymfonyUpload()    {        return is_a($this->data, 'Symfony\Component\HttpFoundation\File\UploadedFile');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_428, Determines if current source data is url\n\n @return boolean\n,Odredi da li je trenutni izvor podatka slike url.,"    public function isUrl()    {        return (bool) filter_var($this->data, FILTER_VALIDATE_URL);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_429, Determines if current source data is a stream resource\\n\\n @return boolean\\n,Odredi da li je trenutni izvor podatka slike resurs toka.,    public function isStream()    {        if ($this->data instanceof StreamInterface) return true;        if (!is_resource($this->data)) return false;        if (get_resource_type($this->data) !== 'stream') return false;        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_430, Determines if current source data is binary data\\n\\n @return boolean\\n,Odredi da li je trenutni izvor podatka slike binaran podatak.,"    public function isBinary()    {        if (is_string($this->data)) {            $mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $this->data);            return (substr($mime, 0, 4) != 'text' && $mime != 'application/x-empty');        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_431, Determines if current source data is data-url\\\\n\\\\n @return boolean\\\\n,Odredi da li je trenutni izvor podatka slike podatak url.,    public function isDataUrl()    {        $data = $this->decodeDataUrl($this->data);        return is_null($data) ? false : true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_432, Determines if current source data is base64 encoded\n\n @return boolean\n,Odreid da li je trenutan izvor podatka primenjuje base64 šifrovanje.,"    public function isBase64()    {        if (!is_string($this->data)) {            return false;        }        return base64_encode(base64_decode($this->data)) === str_replace([""\n"", ""\r""], '', $this->data);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_433, Initiates new Image from Intervention\\\\\\\\Image\\\\\\\\Image\\\\n\\\\n @param  Image $object\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Inicijalizuj novu sliku iz objekta Intervencije.,    public function initFromInterventionImage($object)    {        return $object;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_434, Parses and decodes binary image data from data-url\\\\n\\\\n @param  string $data_url\\\\n @return string\\\\n,Parsiraj i dekoduj sliku binarne ekstenzije određenog url podatkom.,"    private function decodeDataUrl($data_url)    {        if (!is_string($data_url)) {            return null;        }        $pattern = ""/^data:(?:image\/[a-zA-Z\-\.]+)(?:charset=\"".+\"")?;base64,(?P<data>.+)$/"";        preg_match($pattern, $data_url, $matches);        if (is_array($matches) && array_key_exists('data', $matches)) {            return base64_decode($matches['data']);        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_435, Initiates new image from mixed data\\n\\n @param  mixed $data\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicijalizuj novu sliku iz mešovitih podataka.,"    public function init($data)    {        $this->data = $data;        switch (true) {            case $this->isGdResource():                return $this->initFromGdResource($this->data);            case $this->isImagick():                return $this->initFromImagick($this->data);            case $this->isInterventionImage():                return $this->initFromInterventionImage($this->data);            case $this->isSplFileInfo():                return $this->initFromPath($this->data->getRealPath());            case $this->isBinary():                return $this->initFromBinary($this->data);            case $this->isUrl():                return $this->initFromUrl($this->data);            case $this->isStream():                return $this->initFromStream($this->data);            case $this->isDataUrl():                return $this->initFromBinary($this->decodeDataUrl($this->data));            case $this->isFilePath():                return $this->initFromPath($this->data);            // isBase64 has to be after isFilePath to prevent false positives            case $this->isBase64():                return $this->initFromBinary(base64_decode($this->data));            default:                throw new NotReadableException(""Image source not readable"");        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_436, Decoder object transforms to string source data\\\\n\\\\n @return string\\\\n,Transofmiši objekat dekodera u string izvorni podatak.,    public function __toString()    {        return (string) $this->data;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_437, Creates new image instance\\n\\n @param  int     $width\\n @param  int     $height\\n @param  string  $background\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Kreiraj novu instancu slike.,"    abstract public function newImage($width, $height, $background);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_439, Checks if core module installation is available\n\n @return boolean\n,Proveri da li je dostupna instalacija osnovnog modula. ,    abstract protected function coreAvailable();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_440, Returns clone of given core\n\n @return mixed\n,Dohvati kloniran podatak jezgra.,    public function cloneCore($core)    {        return clone $core;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_441, Initiates new image from given input\\\\n\\\\n @param  mixed $data\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Inicijalizuj novu sliku iz datog ulaznog podatka.,    public function init($data)    {        return $this->decoder->init($data);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_442, Encodes given image\\\\n\\\\n @param  Image   $image\\\\n @param  string  $format\\\\n @param  int     $quality\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Šifriraj datu sliku.,"    public function encode($image, $format, $quality)    {        return $this->encoder->process($image, $format, $quality);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_443, Executes named command on given image\\\\n\\\\n @param  Image  $image\\\\n @param  string $name\\\\n @param  array $arguments\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Commands\\\\\\\\AbstractCommand\\\\n,"Izvrši komandu, označenu imenom, nad slikom.","    public function executeCommand($image, $name, $arguments)    {        $commandName = $this->getCommandClassName($name);        $command = new $commandName($arguments);        $command->execute($image);        return $command;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_452, Processes and returns image as WebP encoded string\\\\n\\\\n @return string\\\\n,Precesuiraj i vrati sliku kao WebP enkodovan string.,    abstract protected function processWebp();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_454, Sets image to process\\n\\n @param Image $image\\n,Postavi sliku za procesuiranje.,    protected function setImage($image)    {        $this->image = $image;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_456, Calculates bounding box of current font setting\n\n @return array\n,Proračunaj ivice kutije za podešavanja fonta.,    abstract public function getBoxSize();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_458, Get text to be written\\\\n\\\\n @return String\\\\n,Dohvati text za ispisivanje.,    public function getText()    {        return $this->text;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_459, Set font size in pixels\\n\\n @param  int $size\\n @return void\\n,Dohvati veličinu fonta u pikselima.,    public function size($size)    {        $this->size = $size;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_461, Set color of text to be written\\n\\n @param  mixed $color\\n @return void\\n,Postavi boju teksta za ispisivanje.,    public function color($color)    {        $this->color = $color;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_462, Get color of text\n\n @return mixed\n,Dohvati boju teksta.,    public function getColor()    {        return $this->color;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_464, Get rotation angle of text\n\n @return int\n,Dohvati ugao rotacije teksta.,    public function getAngle()    {        return $this->angle;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_467, Set vertical text alignment\n\n @param  string $valign\n @return void\n,Postavi vertikalno poravnanje teksta.,    public function valign($valign)    {        $this->valign = $valign;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_469, Set path to font file\\n\\n @param  string $file\\n @return void\\n,Postavi putanju do font datoteke.,    public function file($file)    {        $this->file = $file;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_470, Get path to font file\\n\\n @return string\\n,Dohvati putanju font datoteke.,    public function getFile()    {        return $this->file;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_471, Checks if current font has access to an applicable font file\\\\n\\\\n @return boolean\\\\n,Proveri da li trenutno izabrani font ima pristup primenjivom fajlu fonta.,    protected function hasApplicableFontFile()    {        if (is_string($this->file)) {            return file_exists($this->file);        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractFont_472, Counts lines of text to be written\\\\n\\\\n @return int\\\\n,Izbroji linije teksta za ispisivanje.,"    public function countLines()    {        return count(explode(PHP_EOL, $this->text));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Argument_542, Defines current argument as required\\n\\n @return \\\\Intervention\\\\Image\\\\Commands\\\\Argument\\n,Definiši trenutni argument kao neophodan.,"    public function required()    {        if ( ! array_key_exists($this->key, $this->command->arguments)) {            throw new InvalidArgumentException(                sprintf(""Missing argument %d for %s"", $this->key + 1, $this->getCommandName())            );        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Argument_545, Determines that current argument must be over a minimum value\n\n @return \\Intervention\\Image\\Commands\\Argument\n,Obezbedi da argument funkcije mora biti veći od minimalne zadate vrednost.,"    public function min($value)    {        $v = $this->type('numeric')->value();        if (is_null($v)) {            return $this;        }        if ($v < $value) {            throw new InvalidArgumentException(                sprintf('Argument %d must be at least %s.', $this->key, $value)            );        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Argument_546, Determines that current argument must be under a maxiumum value\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Commands\\\\\\\\Argument\\\\n,Obezbedi da argument funkcije mora biti manji od maksimalne zadate vrednost.,"    public function max($value)    {        $v = $this->type('numeric')->value();        if (is_null($v)) {            return $this;        }        if ($v > $value) {            throw new InvalidArgumentException(                sprintf('Argument %d may not be greater than %s.', $this->key, $value)            );        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Argument_547," Checks if value is ""PHP"" integer (120 but also 120.0)\\n\\n @param  mixed $value\\n @return boolean\\n","Proveri da li je vrednost ""PHP"" int tipa. (120 ali i 120.0)",    private function isDigit($value)    {        return is_numeric($value) ? intval($value) == $value : false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_BlurCommand_594, Applies blur effect on image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Primeni blur efekat na slici.,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(1);        for ($i=0; $i < intval($amount); $i++) {            imagefilter($image->getCore(), IMG_FILTER_GAUSSIAN_BLUR);        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_BrightnessCommand_595, Changes image brightness\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni osvetljenje slike.,"    public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return imagefilter($image->getCore(), IMG_FILTER_BRIGHTNESS, ($level * 2.55));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ChecksumCommand_548, Calculates checksum of given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Proračunaj kontrolnu sumu date slike.,"    public function execute($image)    {        $colors = [];        $size = $image->getSize();        for ($x=0; $x <= ($size->width-1); $x++) {            for ($y=0; $y <= ($size->height-1); $y++) {                $colors[] = $image->pickColor($x, $y, 'array');            }        }        $this->setOutput(md5(serialize($colors)));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_CircleCommand_549, Draw a circle centered on given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\image $image\\\\n @return boolean\\\\n,Nacrtaj krug sa centrom u datoj slici.,"    public function execute($image)    {        $diameter = $this->argument(0)->type('numeric')->required()->value();        $x = $this->argument(1)->type('numeric')->required()->value();        $y = $this->argument(2)->type('numeric')->required()->value();        $callback = $this->argument(3)->type('closure')->value();        $circle_classname = sprintf('\Intervention\Image\%s\Shapes\CircleShape',            $image->getDriver()->getDriverName());        $circle = new $circle_classname($diameter);        if ($callback instanceof Closure) {            $callback($circle);        }        $circle->applyToImage($image, $x, $y);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_564, Initiates color object from integer\\n\\n @param  int $value\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n,Inicijalizuj objekat boje objekta iz zadate int vrednosti.,    public function initFromInteger($value)    {        $this->a = ($value >> 24) & 0xFF;        $this->r = ($value >> 16) & 0xFF;        $this->g = ($value >> 8) & 0xFF;        $this->b = $value & 0xFF;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_565, Initiates color object from given array\\\\n\\\\n @param  array $value\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n,Inicijalizuj objekat boje iz datog niza.,"    public function initFromArray($array)    {        $array = array_values($array);        if (count($array) == 4) {            // color array with alpha value            list($r, $g, $b, $a) = $array;            $this->a = $this->alpha2gd($a);        } elseif (count($array) == 3) {            // color array without alpha value            list($r, $g, $b) = $array;            $this->a = 0;        }        $this->r = $r;        $this->g = $g;        $this->b = $b;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_567," Initiates color object from given R, G and B values\\\\n\\\\n @param  int $r\\\\n @param  int $g\\\\n @param  int $b\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n","Inicijalizuj objekat boje iz datog R, G i B vrednosti.","    public function initFromRgb($r, $g, $b)    {        $this->r = intval($r);        $this->g = intval($g);        $this->b = intval($b);        $this->a = 0;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_568, Initiates color object from given ImagickPixel object\n\n @param  ImagickPixel $value\n @return \\Intervention\\Image\\AbstractColor\n,Inicijalizuj boju objekta iz datog ImagickPixel objekta.,"    public function initFromObject($value)    {        throw new NotSupportedException(            ""GD colors cannot init from ImagickPixel objects.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_569, Calculates integer value of current color instance\\\\n\\\\n @return int\\\\n,Dohvati int vrednost trenutne instance boje.,    public function getInt()    {        return ($this->a << 24) + ($this->r << 16) + ($this->g << 8) + $this->b;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_571, Calculates RGBA in string format of current color instance\n\n @return string\n,Dohvati RGBA vrednosti u string formatu trenutne instance boje.,"    public function getRgba()    {        return sprintf('rgba(%d, %d, %d, %.2F)', $this->r, $this->g, $this->b, round(1 - $this->a / 127, 2));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_629, Initiates color object from given string\n\n @param  string $value\n\n @return \\Intervention\\Image\\AbstractColor\n,Inicijalizuj objekat boje iz datog stringa.,"    public function initFromString($value)    {        if ($color = $this->rgbaFromString($value)) {            $this->setPixel($color[0], $color[1], $color[2], $color[3]);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_631," Initiates color object from given R, G and B values\\n\\n @param  int $r\\n @param  int $g\\n @param  int $b\\n\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n","Inicijalizuj objekat boje iz datog R, G i B vrednosti.","    public function initFromRgb($r, $g, $b)    {        $this->setPixel($r, $g, $b);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_633, Calculates integer value of current color instance\\\\n\\\\n @return int\\\\n,Dohvati int vrednost trenutne instance boje.,    public function getInt()    {        $r = $this->getRedValue();        $g = $this->getGreenValue();        $b = $this->getBlueValue();        $a = intval(round($this->getAlphaValue() * 255));        return intval(($a << 24) + ($r << 16) + ($g << 8) + $b);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_635, Calculates RGBA in string format of current color instance\n\n @return string\n,Dohvati RGBA vrednosti u string formatu trenutne instance boje.,"    public function getRgba()    {        return sprintf('rgba(%d, %d, %d, %.2F)',            $this->getRedValue(),            $this->getGreenValue(),            $this->getBlueValue(),            $this->getAlphaValue()        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_636, Returns RGB red value of current color\\n\\n @return int\\n,Dohvati nijansu crvene trenutne boje.,    public function getRedValue()    {        return intval(round($this->pixel->getColorValue(\Imagick::COLOR_RED) * 255));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_637, Returns RGB green value of current color\\\\n\\\\n @return int\\\\n,Dohvati nijansu zelene trenutne boje.,    public function getGreenValue()    {        return intval(round($this->pixel->getColorValue(\Imagick::COLOR_GREEN) * 255));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_638, Returns RGB blue value of current color\\\\n\\\\n @return int\\\\n,Dohvati nijansu plave trenutne boje.,    public function getBlueValue()    {        return intval(round($this->pixel->getColorValue(\Imagick::COLOR_BLUE) * 255));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_640, Returns current color as ImagickPixel\\\\n\\\\n @return \\\\\\\\ImagickPixel\\\\n,Dohvati trenutnu boju kao ImagickPixel,    public function getPixel()    {        return $this->pixel;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ColorizeCommand_660, Changes balance of different RGB color channels\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni ujednačenost osnovnih elemenata RGB boje.,"    public function execute($image)    {        $red = $this->argument(0)->between(-100, 100)->required()->value();        $green = $this->argument(1)->between(-100, 100)->required()->value();        $blue = $this->argument(2)->between(-100, 100)->required()->value();        // normalize colorize levels        $red = $this->normalizeLevel($red);        $green = $this->normalizeLevel($green);        $blue = $this->normalizeLevel($blue);        $qrange = $image->getCore()->getQuantumRange();        // apply        $image->getCore()->levelImage(0, $red, $qrange['quantumRangeLong'], \Imagick::CHANNEL_RED);        $image->getCore()->levelImage(0, $green, $qrange['quantumRangeLong'], \Imagick::CHANNEL_GREEN);        $image->getCore()->levelImage(0, $blue, $qrange['quantumRangeLong'], \Imagick::CHANNEL_BLUE);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Constraint_476, Returns current size of constraint\\n\\n @return \\\\Intervention\\\\Image\\\\Size\\n,Dohvati trenutnu veličinu ograničenja.,    public function getSize()    {        return $this->size;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Constraint_477, Fix the given argument in current constraint\\n\\n @param  int $type\\n @return void\\n,Ispravi argument trenutnim ograničenjem.,    public function fix($type)    {        $this->fixed = ($this->fixed & ~(1 << $type)) | (1 << $type);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Constraint_478, Checks if given argument is fixed in current constraint\n\n @param  int  $type\n @return boolean\n,Proveri da li je dati argument ispravljen sa trenutnim ograničenjem.,    public function isFixed($type)    {        return (bool) ($this->fixed & (1 << $type));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ContrastCommand_661, Changes contrast of image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni kontrast slike.,"    public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return $image->getCore()->sigmoidalContrastImage($level > 0, $level / 4, 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_573, Initiates new image from path in filesystem\n\n @param  string $path\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku sa date putanje u fajl sistemu.,"    public function initFromPath($path)    {        if ( ! file_exists($path)) {            throw new NotReadableException(                ""Unable to find file ({$path}).""            );        }        // get mime type of file        $mime = finfo_file(finfo_open(FILEINFO_MIME_TYPE), $path);        // define core        switch (strtolower($mime)) {            case 'image/png':            case 'image/x-png':                $core = @imagecreatefrompng($path);                break;            case 'image/jpg':            case 'image/jpeg':            case 'image/pjpeg':                $core = @imagecreatefromjpeg($path);                if (!$core) {                    $core= @imagecreatefromstring(file_get_contents($path));                }                break;            case 'image/gif':                $core = @imagecreatefromgif($path);                break;            case 'image/webp':            case 'image/x-webp':                if ( ! function_exists('imagecreatefromwebp')) {                    throw new NotReadableException(                        ""Unsupported image type. GD/PHP installation does not support WebP format.""                    );                }                $core = @imagecreatefromwebp($path);                break;            default:                throw new NotReadableException(                    ""Unsupported image type. GD driver is only able to decode JPG, PNG, GIF or WebP files.""                );        }        if (empty($core)) {            throw new NotReadableException(                ""Unable to decode image from file ({$path}).""            );        }        $this->gdResourceToTruecolor($core);        // build image        $image = $this->initFromGdResource($core);        $image->mime = $mime;        $image->setFileInfoFromPath($path);        return $image;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_574, Initiates new image from GD resource\n\n @param  Resource $resource\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku iz GD resursa.,"    public function initFromGdResource($resource)    {        return new Image(new Driver, $resource);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_575, Initiates new image from Imagick object\n\n @param  Imagick $object\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku iz Imagick objekta.,"    public function initFromImagick(\Imagick $object)    {        throw new NotSupportedException(            ""Gd driver is unable to init from Imagick object.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_642, Initiates new image from path in filesystem\\n\\n @param  string $path\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicijalizuj novu sliku sa date putanje u fajl sistemu.,"    public function initFromPath($path)    {        $core = new \Imagick;        try {            $core->setBackgroundColor(new \ImagickPixel('transparent'));            $core->readImage($path);            $core->setImageType(defined('\Imagick::IMGTYPE_TRUECOLORALPHA') ? \Imagick::IMGTYPE_TRUECOLORALPHA : \Imagick::IMGTYPE_TRUECOLORMATTE);        } catch (\ImagickException $e) {            throw new \Intervention\Image\Exception\NotReadableException(                ""Unable to read image from path ({$path})."",                0,                $e            );        }        // build image        $image = $this->initFromImagick($core);        $image->setFileInfoFromPath($path);        return $image;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_645, Initiates new image from binary data\n\n @param  string $data\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku iz binarnog podatka.,"    public function initFromBinary($binary)    {        $core = new \Imagick;        try {            $core->setBackgroundColor(new \ImagickPixel('transparent'));            $core->readImageBlob($binary);        } catch (\ImagickException $e) {            throw new NotReadableException(                ""Unable to read image from binary data."",                0,                $e            );        }        // build image        $image = $this->initFromImagick($core);        $image->mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $binary);        return $image;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Driver_578, Reads given string into color object\\\\n\\\\n @param  string $value\\\\n @return AbstractColor\\\\n,Kreiraj objekat boje iz datog stringa.,    public function parseColor($value)    {        return new Color($value);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Driver_648, Checks if core module installation is available\\n\\n @return boolean\\n,Proveri da li je dati argument ispravljen sa trenutnim ograničenjem.,    protected function coreAvailable()    {        return (extension_loaded('imagick') && class_exists('Imagick'));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_EllipseCommand_550, Draws ellipse on given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Nacrtaj elipsu na datoj slici.,"    public function execute($image)    {        $width = $this->argument(0)->type('numeric')->required()->value();        $height = $this->argument(1)->type('numeric')->required()->value();        $x = $this->argument(2)->type('numeric')->required()->value();        $y = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $ellipse_classname = sprintf('\Intervention\Image\%s\Shapes\EllipseShape',            $image->getDriver()->getDriverName());        $ellipse = new $ellipse_classname($width, $height);        if ($callback instanceof Closure) {            $callback($ellipse);        }        $ellipse->applyToImage($image, $x, $y);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_581, Processes and returns encoded image as JPEG string\n\n @return string\n,Procesuiraj i vrati šifrovanu sliku kao JPEG string.,"    protected function processJpeg()    {        ob_start();        imagejpeg($this->image->getCore(), null, $this->quality);        $this->image->mime = image_type_to_mime_type(IMAGETYPE_JPEG);        $buffer = ob_get_contents();        ob_end_clean();        return $buffer;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_582, Processes and returns encoded image as PNG string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao PNG string.,"    protected function processPng()    {        ob_start();        $resource = $this->image->getCore();        imagealphablending($resource, false);        imagesavealpha($resource, true);        imagepng($resource, null, -1);        $this->image->mime = image_type_to_mime_type(IMAGETYPE_PNG);        $buffer = ob_get_contents();        ob_end_clean();        return $buffer;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_583, Processes and returns encoded image as GIF string\n\n @return string\n,Procesuiraj i vrati šifrovanu sliku kao GIF string.,    protected function processGif()    {        ob_start();        imagegif($this->image->getCore());        $this->image->mime = image_type_to_mime_type(IMAGETYPE_GIF);        $buffer = ob_get_contents();        ob_end_clean();        return $buffer;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_586, Processes and returns encoded image as ICO string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao ICO string.,"    protected function processIco()    {        throw new NotSupportedException(            ""ICO format is not supported by Gd Driver.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_587, Processes and returns encoded image as PSD string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao PSD string.,"    protected function processPsd()    {        throw new NotSupportedException(            ""PSD format is not supported by Gd Driver.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_649, Processes and returns encoded image as JPEG string\n\n @return string\n,Procesuiraj i vrati šifrovanu sliku kao JPEG string.,    protected function processJpeg()    {        $format = 'jpeg';        $compression = \Imagick::COMPRESSION_JPEG;        $imagick = $this->image->getCore();        $imagick->setImageBackgroundColor('white');        $imagick->setBackgroundColor('white');        $imagick = $imagick->mergeImageLayers(\Imagick::LAYERMETHOD_MERGE);        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        $imagick->setCompressionQuality($this->quality);        $imagick->setImageCompressionQuality($this->quality);        return $imagick->getImagesBlob();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_651, Processes and returns encoded image as GIF string\n\n @return string\n,Procesuiraj i vrati šifrovanu sliku kao GIF string.,    protected function processGif()    {        $format = 'gif';        $compression = \Imagick::COMPRESSION_LZW;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_653, Processes and returns encoded image as BMP string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao BMP string.,    protected function processBmp()    {        $format = 'bmp';        $compression = \Imagick::COMPRESSION_UNDEFINED;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_654, Processes and returns encoded image as ICO string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao ICO string.,    protected function processIco()    {        $format = 'ico';        $compression = \Imagick::COMPRESSION_UNDEFINED;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ExifCommand_551, Read Exif data from the given image\n\n Note: Windows PHP Users - in order to use this method you will need to\n enable the mbstring and exif extensions within the php.ini file.\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Pročitaj Exif podatke iz date slike. Beleška za Windows PHP korisnike: Da bi se koristila ova metoda potrebno je omogućiti mbstring i exif ekstenzije u okviru php.ini fajla.,"    public function execute($image)    {        if (!function_exists('exif_read_data')) {            throw new NotSupportedException(                ""Reading Exif data is not supported by this PHP installation.""            );        }        $key = $this->argument(0)->value();        // try to read exif data from image file        try {            $data = @exif_read_data($image->dirname . '/' . $image->basename);            if (!is_null($key) && is_array($data)) {                $data = array_key_exists($key, $data) ? $data[$key] : false;            }        } catch (\Exception $e) {            throw new NotReadableException(                sprintf(                    ""Cannot read the Exif data from the filename (%s) provided "",                    $image->dirname . '/' . $image->basename                ),                $e->getCode(),                $e            );        }        $this->setOutput($data);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FillCommand_666, Fills image with color or pattern\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Popuni prostor slike sa bojom ili obrascem.,"    public function execute($image)    {        $filling = $this->argument(0)->value();        $x = $this->argument(1)->type('digit')->value();        $y = $this->argument(2)->type('digit')->value();        $imagick = $image->getCore();        try {            // set image filling            $source = new Decoder;            $filling = $source->init($filling);        } catch (NotReadableException $e) {            // set solid color filling            $filling = new Color($filling);        }        // flood fill if coordinates are set        if (is_int($x) && is_int($y)) {            // flood fill with texture            if ($filling instanceof Image) {                // create tile                $tile = clone $image->getCore();                // mask away color at position                $tile->transparentPaintImage($tile->getImagePixelColor($x, $y), 0, 0, false);                // create canvas                $canvas = clone $image->getCore();                // fill canvas with texture                $canvas = $canvas->textureImage($filling->getCore());                // merge canvas and tile                $canvas->compositeImage($tile, \Imagick::COMPOSITE_DEFAULT, 0, 0);                // replace image core                $image->setCore($canvas);            // flood fill with color            } elseif ($filling instanceof Color) {                // create canvas with filling                $canvas = new \Imagick;                $canvas->newImage($image->getWidth(), $image->getHeight(), $filling->getPixel(), 'png');                // create tile to put on top                $tile = clone $image->getCore();                // mask away color at pos.                $tile->transparentPaintImage($tile->getImagePixelColor($x, $y), 0, 0, false);                // save alpha channel of original image                $alpha = clone $image->getCore();                // merge original with canvas and tile                $image->getCore()->compositeImage($canvas, \Imagick::COMPOSITE_DEFAULT, 0, 0);                $image->getCore()->compositeImage($tile, \Imagick::COMPOSITE_DEFAULT, 0, 0);                // restore alpha channel of original image                $image->getCore()->compositeImage($alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);            }        } else {            if ($filling instanceof Image) {                // fill whole image with texture                $image->setCore($image->getCore()->textureImage($filling->getCore()));            } elseif ($filling instanceof Color) {                // fill whole image with color                $draw = new \ImagickDraw();                $draw->setFillColor($filling->getPixel());                $draw->rectangle(0, 0, $image->getWidth(), $image->getHeight());                $image->getCore()->drawImage($draw);            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FilterInterface_563, Applies filter to given image\n\n @param  \\Intervention\\Image\\Image $image\n @return \\Intervention\\Image\\Image\n,Primeni filtere na datoj slici.,    public function applyFilter(Image $image);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FitCommand_601, Crops and resized an image at the same time\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Iseci i promeni veličinu slike u isto vreme.,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->value($width);        $constraints = $this->argument(2)->type('closure')->value();        $position = $this->argument(3)->type('string')->value('center');        // calculate size        $cropped = $image->getSize()->fit(new Size($width, $height), $position);        $resized = clone $cropped;        $resized = $resized->resize($width, $height, $constraints);        // modify image        $this->modify($image, 0, 0, $cropped->pivot->x, $cropped->pivot->y, $resized->getWidth(), $resized->getHeight(), $cropped->getWidth(), $cropped->getHeight());        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FlipCommand_668, Mirrors an image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Preslikaj sliku,"    public function execute($image)    {        $mode = $this->argument(0)->value('h');        if (in_array(strtolower($mode), [2, 'v', 'vert', 'vertical'])) {            // flip vertical            return $image->getCore()->flipImage();        } else {            // flip horizontal            return $image->getCore()->flopImage();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_588, Get font size in points\\n\\n @return int\\n,Dohvati veličinu fonta u tačkama.,    protected function getPointSize()    {        return intval(ceil($this->size * 0.75));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_589, Filter function to access internal integer font values\\n\\n @return int\\n,Filter funkcija za dohvatanje interne celobrojne vrednosti fonta.,"    private function getInternalFont()    {        $internalfont = is_null($this->file) ? 1 : $this->file;        $internalfont = is_numeric($internalfont) ? $internalfont : false;        if ( ! in_array($internalfont, [1, 2, 3, 4, 5])) {            throw new NotSupportedException(                sprintf('Internal GD font (%s) not available. Use only 1-5.', $internalfont)            );        }        return intval($internalfont);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_590, Get width of an internal font character\n\n @return int\n,Dohvati širinu unutrašnjeg font karaktera.,    private function getInternalFontWidth()    {        return $this->getInternalFont() + 4;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_656, Calculates bounding box of current font setting\\\\n\\\\n @return array\\\\n,Proračunaj granični opseg trenutne postavke fonta.,"    public function getBoxSize()    {        $box = [];        // build draw object        $draw = new \ImagickDraw();        $draw->setStrokeAntialias(true);        $draw->setTextAntialias(true);        // set font file        if ($this->hasApplicableFontFile()) {            $draw->setFont($this->file);        } else {            throw new RuntimeException(                ""Font file must be provided to apply text to image.""            );        }        $draw->setFontSize($this->size);        $dimensions = (new \Imagick())->queryFontMetrics($draw, $this->text);        if (strlen($this->text) == 0) {            // no text -> no boxsize            $box['width'] = 0;            $box['height'] = 0;        } else {            // get boxsize            $box['width'] = intval(abs($dimensions['textWidth']));            $box['height'] = intval(abs($dimensions['textHeight']));        }        return $box;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_GetSizeCommand_604, Reads size of given image instance in pixels\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Pročitaj veličinu date instance slike u pikselima.,"    public function execute($image)    {        $this->setOutput(new Size(            imagesx($image->getCore()),            imagesy($image->getCore())        ));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_GetSizeCommand_670, Reads size of given image instance in pixels\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Pročitaj veličinu date instance slike u pikselima.,"    public function execute($image)    {        /** @var \Imagick $core */        $core = $image->getCore();        $this->setOutput(new Size(            $core->getImageWidth(),            $core->getImageHeight()        ));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_GreyscaleCommand_671, Turns an image into a greyscale version\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Dohvati verziju slike bez boje.,"    public function execute($image)    {        return $image->getCore()->modulateImage(100, 0, 100);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageManager_503, Initiates an Image instance from different input types\n\n @param  mixed $data\n\n @return \\Intervention\\Image\\Image\n,Inicijalizuj instancu slike iz različitih ulaznih tipova.,    public function make($data)    {        return $this->createDriver()->init($data);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageManager_504, Creates a driver instance according to config settings\\n\\n @return \\\\Intervention\\\\Image\\\\AbstractDriver\\n,Kreiraj instancu upravljača u skladu sa konfiguracionim podešavanjima.,"    private function createDriver()    {        if (is_string($this->config['driver'])) {            $drivername = ucfirst($this->config['driver']);            $driverclass = sprintf('Intervention\\Image\\%s\\Driver', $drivername);            if (class_exists($driverclass)) {                return new $driverclass;            }            throw new NotSupportedException(                ""Driver ({$drivername}) could not be instantiated.""            );        }        if ($this->config['driver'] instanceof AbstractDriver) {            return $this->config['driver'];        }        throw new NotSupportedException(            ""Unknown driver type.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageManager_505, Check if all requirements are available\\\\n\\\\n @return void\\\\n,Proveri da li su svi uslovi zadovoljeni.,"    private function checkRequirements()    {        if ( ! function_exists('finfo_buffer')) {            throw new MissingDependencyException(                ""PHP Fileinfo extension must be installed/enabled to use Intervention Image.""            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLaravel4_514, Register the service provider.\\n\\n @return void\\n,Registruj servis provajder.,"    public function register()    {        $app = $this->app;        $app['image'] = $app->share(function ($app) {            return new ImageManager($app['config']->get('image::config'));        });        $app->alias('image', 'Intervention\Image\ImageManager');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLaravelRecent_515, Determines if Intervention Imagecache is installed\n\n @return boolean\n,Proveri da li je Intervantion Imagecache instaliran.,    private function cacheIsInstalled()    {        return class_exists('Intervention\\Image\\ImageCache');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProvider_509, Bootstrap the application events.\\n\\n @return void\\n,Pokreni aplikacioni sistem za upravljanje dogadjaje.,"    public function boot()    {        if (method_exists($this->provider, 'boot')) {            return $this->provider->boot();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProvider_510, Register the service provider.\\n\\n @return void\\n,Registruj servis provajder.,    public function register()    {        return $this->provider->register();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProvider_511, Return ServiceProvider according to Laravel version\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Provider\\\\\\\\ProviderInterface\\\\n,Dohvati servis provajder u skladu sa Laravel verzijom.,"    private function getProvider()    {        if ($this->app instanceof LumenApplication) {            $provider = '\Intervention\Image\ImageServiceProviderLumen';        } elseif (version_compare(IlluminateApplication::VERSION, '5.0', '<')) {            $provider = '\Intervention\Image\ImageServiceProviderLaravel4';        } else {            $provider = '\Intervention\Image\ImageServiceProviderLaravelRecent';        }        return new $provider($this->app);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_485, Magic method to catch all image calls\\n usually any AbstractCommand\\n\\n @param  string $name\\n @param  Array  $arguments\\n @return mixed\\n,Magična metoda za hvatanje svih poziva sa slikom.,"    public function __call($name, $arguments)    {        $command = $this->driver->executeCommand($this, $name, $arguments);        return $command->hasOutput() ? $command->getOutput() : $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_486, Runs a given filter on current image\n\n @param  FiltersFilterInterface $filter\n @return \\Intervention\\Image\\Image\n,Primeni filtere na datoj slici.,    public function filter(Filters\FilterInterface $filter)    {        return $filter->applyFilter($this);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_492, Checks if named backup exists\\n\\n @param  string $name\\n @return bool\\n,Proveri da li rezervna kopija sa datim imenom postoji.,"    private function backupExists($name)    {        return array_key_exists($name, $this->backups);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_InterlaceCommand_674, Toggles interlaced encoding mode\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Uključi isprepletan mod šifriranja.,    public function execute($image)    {        $mode = $this->argument(0)->type('bool')->value(true);        if ($mode) {            $mode = \Imagick::INTERLACE_LINE;        } else {            $mode = \Imagick::INTERLACE_NO;        }        $image->getCore()->setInterlaceScheme($mode);        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_InvertCommand_609, Inverts colors of an image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Invertuj boje na slici.,"    public function execute($image)    {        return imagefilter($image->getCore(), IMG_FILTER_NEGATE);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_IptcCommand_552, Read Iptc data from the given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Pročitaj lpct podatke sa date slike.,"    public function execute($image)    {        if ( ! function_exists('iptcparse')) {            throw new NotSupportedException(                ""Reading Iptc data is not supported by this PHP installation.""            );        }        $key = $this->argument(0)->value();        $info = [];        @getimagesize($image->dirname .'/'. $image->basename, $info);        $data = [];        if (array_key_exists('APP13', $info)) {            $iptc = iptcparse($info['APP13']);            if (is_array($iptc)) {                $data['DocumentTitle'] = isset($iptc[""2#005""][0]) ? $iptc[""2#005""][0] : null;                $data['Urgency'] = isset($iptc[""2#010""][0]) ? $iptc[""2#010""][0] : null;                $data['Category'] = isset($iptc[""2#015""][0]) ? $iptc[""2#015""][0] : null;                $data['Subcategories'] = isset($iptc[""2#020""][0]) ? $iptc[""2#020""][0] : null;                $data['Keywords'] = isset($iptc[""2#025""][0]) ? $iptc[""2#025""] : null;                $data['SpecialInstructions'] = isset($iptc[""2#040""][0]) ? $iptc[""2#040""][0] : null;                $data['CreationDate'] = isset($iptc[""2#055""][0]) ? $iptc[""2#055""][0] : null;                $data['CreationTime'] = isset($iptc[""2#060""][0]) ? $iptc[""2#060""][0] : null;                $data['AuthorByline'] = isset($iptc[""2#080""][0]) ? $iptc[""2#080""][0] : null;                $data['AuthorTitle'] = isset($iptc[""2#085""][0]) ? $iptc[""2#085""][0] : null;                $data['City'] = isset($iptc[""2#090""][0]) ? $iptc[""2#090""][0] : null;                $data['SubLocation'] = isset($iptc[""2#092""][0]) ? $iptc[""2#092""][0] : null;                $data['State'] = isset($iptc[""2#095""][0]) ? $iptc[""2#095""][0] : null;                $data['Country'] = isset($iptc[""2#101""][0]) ? $iptc[""2#101""][0] : null;                $data['OTR'] = isset($iptc[""2#103""][0]) ? $iptc[""2#103""][0] : null;                $data['Headline'] = isset($iptc[""2#105""][0]) ? $iptc[""2#105""][0] : null;                $data['Source'] = isset($iptc[""2#110""][0]) ? $iptc[""2#110""][0] : null;                $data['PhotoSource'] = isset($iptc[""2#115""][0]) ? $iptc[""2#115""][0] : null;                $data['Copyright'] = isset($iptc[""2#116""][0]) ? $iptc[""2#116""][0] : null;                $data['Caption'] = isset($iptc[""2#120""][0]) ? $iptc[""2#120""][0] : null;                $data['CaptionWriter'] = isset($iptc[""2#122""][0]) ? $iptc[""2#122""][0] : null;            }        }        if (! is_null($key) && is_array($data)) {            $data = array_key_exists($key, $data) ? $data[$key] : false;        }        $this->setOutput($data);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_LimitColorsCommand_676, Reduces colors of a given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Smanji intenzitet boja na slici.,"    public function execute($image)    {        $count = $this->argument(0)->value();        $matte = $this->argument(1)->value();        // get current image size        $size = $image->getSize();        // build 2 color alpha mask from original alpha        $alpha = clone $image->getCore();        $alpha->separateImageChannel(\Imagick::CHANNEL_ALPHA);        $alpha->transparentPaintImage('#ffffff', 0, 0, false);        $alpha->separateImageChannel(\Imagick::CHANNEL_ALPHA);        $alpha->negateImage(false);        if ($matte) {            // get matte color            $mattecolor = $image->getDriver()->parseColor($matte)->getPixel();            // create matte image            $canvas = new \Imagick;            $canvas->newImage($size->width, $size->height, $mattecolor, 'png');            // lower colors of original and copy to matte            $image->getCore()->quantizeImage($count, \Imagick::COLORSPACE_RGB, 0, false, false);            $canvas->compositeImage($image->getCore(), \Imagick::COMPOSITE_DEFAULT, 0, 0);            // copy new alpha to canvas            $canvas->compositeImage($alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);            // replace core            $image->setCore($canvas);        } else {            $image->getCore()->quantizeImage($count, \Imagick::COLORSPACE_RGB, 0, false, false);            $image->getCore()->compositeImage($alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_LineCommand_553, Draws line on given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Nacrtaj liniju na datoj slici.,"    public function execute($image)    {        $x1 = $this->argument(0)->type('numeric')->required()->value();        $y1 = $this->argument(1)->type('numeric')->required()->value();        $x2 = $this->argument(2)->type('numeric')->required()->value();        $y2 = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $line_classname = sprintf('\Intervention\Image\%s\Shapes\LineShape',            $image->getDriver()->getDriverName());        $line = new $line_classname($x2, $y2);        if ($callback instanceof Closure) {            $callback($line);        }        $line->applyToImage($image, $x1, $y1);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_MaskCommand_611, Applies an alpha mask to an image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Primeni alfa masku na slici.,"    public function execute($image)    {        $mask_source = $this->argument(0)->value();        $mask_w_alpha = $this->argument(1)->type('bool')->value(false);        $image_size = $image->getSize();        // create empty canvas        $canvas = $image->getDriver()->newImage($image_size->width, $image_size->height, [0,0,0,0]);        // build mask image from source        $mask = $image->getDriver()->init($mask_source);        $mask_size = $mask->getSize();        // resize mask to size of current image (if necessary)        if ($mask_size != $image_size) {            $mask->resize($image_size->width, $image_size->height);        }        imagealphablending($canvas->getCore(), false);        if ( ! $mask_w_alpha) {            // mask from greyscale image            imagefilter($mask->getCore(), IMG_FILTER_GRAYSCALE);        }        // redraw old image pixel by pixel considering alpha map        for ($x=0; $x < $image_size->width; $x++) {            for ($y=0; $y < $image_size->height; $y++) {                $color = $image->pickColor($x, $y, 'array');                $alpha = $mask->pickColor($x, $y, 'array');                if ($mask_w_alpha) {                    $alpha = $alpha[3]; // use alpha channel as mask                } else {                    if ($alpha[3] == 0) { // transparent as black                        $alpha = 0;                    } else {                        // $alpha = floatval(round((($alpha[0] + $alpha[1] + $alpha[3]) / 3) / 255, 2));                        // image is greyscale, so channel doesn't matter (use red channel)                        $alpha = floatval(round($alpha[0] / 255, 2));                    }                }                // preserve alpha of original image...                if ($color[3] < $alpha) {                    $alpha = $color[3];                }                // replace alpha value                $color[3] = $alpha;                // redraw pixel                $canvas->pixel($color, $x, $y);            }        }        // replace current image with masked instance        $image->setCore($canvas->getCore());        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_OpacityCommand_612, Defines opacity of an image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Definiši providnost slike.,"    public function execute($image)    {        $transparency = $this->argument(0)->between(0, 100)->required()->value();        // get size of image        $size = $image->getSize();        // build temp alpha mask        $mask_color = sprintf('rgba(0, 0, 0, %.1F)', $transparency / 100);        $mask = $image->getDriver()->newImage($size->width, $size->height, $mask_color);        // mask image        $image->mask($mask->getCore(), true);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_OrientateCommand_554, Correct image orientation according to Exif data\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Ispravi orijentaciju slike u skladu sa Exif podacima.,    public function execute($image)    {        switch ($image->exif('Orientation')) {            case 2:                $image->flip();                break;            case 3:                $image->rotate(180);                break;            case 4:                $image->rotate(180)->flip();                break;            case 5:                $image->rotate(270)->flip();                break;            case 6:                $image->rotate(270);                break;            case 7:                $image->rotate(90)->flip();                break;            case 8:                $image->rotate(90);                break;        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PixelCommand_614, Draws one pixel to a given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Iscrtaj jedan piksel na slici.,"    public function execute($image)    {        $color = $this->argument(0)->required()->value();        $color = new Color($color);        $x = $this->argument(1)->type('digit')->required()->value();        $y = $this->argument(2)->type('digit')->required()->value();        return imagesetpixel($image->getCore(), $x, $y, $color->getInt());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PixelateCommand_681, Applies a pixelation effect to a given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Primeni efekat pikselizacije na datoj slici.,"    public function execute($image)    {        $size = $this->argument(0)->type('digit')->value(10);        $width = $image->getWidth();        $height = $image->getHeight();        $image->getCore()->scaleImage(max(1, ($width / $size)), max(1, ($height / $size)));        $image->getCore()->scaleImage($width, $height);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PolygonShape_691, Create new polygon instance\n\n @param array $points\n,Kreiraj novu poligon instancu.,    public function __construct($points)    {        $this->points = $this->formatPoints($points);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PsrResponseCommand_556," Builds PSR7 compatible response. May replace ""response"" command in\n some future.\n\n Method will generate binary stream and put it inside PSR-7\n ResponseInterface. Following code can be optimized using native php\n streams and more ""clean"" streaming, however drivers has to be updated\n first.\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n",Kreiraj odgovor kompatibilan sa PSR-7 interfejs metodama. Metoda će kreirati binarni tok i postaviti ga u PSR-7 interfejs odgovora. Prateći kod se može optimizovati korišćenjem native php tokovima. Ipak drajveri se moraju nadograditi predhodno.,"    public function execute($image)    {        $format = $this->argument(0)->value();        $quality = $this->argument(1)->between(0, 100)->value();        //Encoded property will be populated at this moment        $stream = $image->stream($format, $quality);        $mimetype = finfo_buffer(            finfo_open(FILEINFO_MIME_TYPE),            $image->getEncoded()        );        $this->setOutput(new Response(            200,            [                'Content-Type'   => $mimetype,                'Content-Length' => strlen($image->getEncoded())            ],            $stream        ));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ResetCommand_682, Resets given image to its backup state\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Resetuj sliku na njeno predhodno sačuvano stanje.,"    public function execute($image)    {        $backupName = $this->argument(0)->value();        $backup = $image->getBackup($backupName);        if ($backup instanceof \Imagick) {            // destroy current core            $image->getCore()->clear();            // clone backup            $backup = clone $backup;            // reset to new resource            $image->setCore($backup);            return true;        }        throw new RuntimeException(            ""Backup not available. Call backup({$backupName}) before reset().""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ResizeCanvasCommand_617, Resizes image boundaries\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni veličinu granica u kojima se proteže slika.,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->required()->value();        $anchor = $this->argument(2)->value('center');        $relative = $this->argument(3)->type('boolean')->value(false);        $bgcolor = $this->argument(4)->value();        $original_width = $image->getWidth();        $original_height = $image->getHeight();        // check of only width or height is set        $width = is_null($width) ? $original_width : intval($width);        $height = is_null($height) ? $original_height : intval($height);        // check on relative width/height        if ($relative) {            $width = $original_width + $width;            $height = $original_height + $height;        }        // check for negative width/height        $width = ($width <= 0) ? $width + $original_width : $width;        $height = ($height <= 0) ? $height + $original_height : $height;        // create new canvas        $canvas = $image->getDriver()->newImage($width, $height, $bgcolor);        // set copy position        $canvas_size = $canvas->getSize()->align($anchor);        $image_size = $image->getSize()->align($anchor);        $canvas_pos = $image_size->relativePosition($canvas_size);        $image_pos = $canvas_size->relativePosition($image_size);        if ($width <= $original_width) {            $dst_x = 0;            $src_x = $canvas_pos->x;            $src_w = $canvas_size->width;        } else {            $dst_x = $image_pos->x;            $src_x = 0;            $src_w = $original_width;        }        if ($height <= $original_height) {            $dst_y = 0;            $src_y = $canvas_pos->y;            $src_h = $canvas_size->height;        } else {            $dst_y = $image_pos->y;            $src_y = 0;            $src_h = $original_height;        }        // make image area transparent to keep transparency        // even if background-color is set        $transparent = imagecolorallocatealpha($canvas->getCore(), 255, 255, 255, 127);        imagealphablending($canvas->getCore(), false); // do not blend / just overwrite        imagefilledrectangle($canvas->getCore(), $dst_x, $dst_y, $dst_x + $src_w - 1, $dst_y + $src_h - 1, $transparent);        // copy image into new canvas        imagecopy($canvas->getCore(), $image->getCore(), $dst_x, $dst_y, $src_x, $src_y, $src_w, $src_h);        // set new core to canvas        $image->setCore($canvas->getCore());        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ResizeCommand_618, Resizes image dimensions\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Promeni dimenzije slike.,"    public function execute($image)    {        $width = $this->argument(0)->value();        $height = $this->argument(1)->value();        $constraints = $this->argument(2)->type('closure')->value();        // resize box        $resized = $image->getSize()->resize($width, $height, $constraints);        // modify image        $this->modify($image, 0, 0, 0, 0, $resized->getWidth(), $resized->getHeight(), $image->getWidth(), $image->getHeight());        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Response_527, Builds response according to settings\n\n @return mixed\n,Napravi odgovor u skladu sa podešavanjima.,"    public function make()    {        $this->image->encode($this->format, $this->quality);        $data = $this->image->getEncoded();        $mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $data);        $length = strlen($data);        if (function_exists('app') && is_a($app = app(), 'Illuminate\Foundation\Application')) {            $response = IlluminateResponse::make($data);            $response->header('Content-Type', $mime);            $response->header('Content-Length', $length);        } elseif (class_exists('\Symfony\Component\HttpFoundation\Response')) {            $response = SymfonyResponse::create($data);            $response->headers->set('Content-Type', $mime);            $response->headers->set('Content-Length', $length);        } else {            header('Content-Type: ' . $mime);            header('Content-Length: ' . $length);            $response = $data;        }        return $response;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_RotateCommand_620, Rotates image counter clockwise\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Rotiraj sliku u smeru kazaljke na satu.,"    public function execute($image)    {        $angle = $this->argument(0)->type('numeric')->required()->value();        $color = $this->argument(1)->value();        $color = new Color($color);        // restrict rotations beyond 360 degrees, since the end result is the same        $angle %= 360;        // rotate image        $image->setCore(imagerotate($image->getCore(), $angle, $color->getInt()));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_RotateCommand_685, Rotates image counter clockwise\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Rotiraj sliku u smeru kazaljke na satu.,"    public function execute($image)    {        $angle = $this->argument(0)->type('numeric')->required()->value();        $color = $this->argument(1)->value();        $color = new Color($color);        // restrict rotations beyond 360 degrees, since the end result is the same        $angle %= 360;        // rotate image        $image->getCore()->rotateImage($color->getPixel(), ($angle * -1));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_SharpenCommand_621, Sharpen image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Izoštri sliku.,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(10);        // build matrix        $min = $amount >= 10 ? $amount * -0.01 : 0;        $max = $amount * -0.025;        $abs = ((4 * $min + 4 * $max) * -1) + 1;        $div = 1;        $matrix = [            [$min, $max, $min],            [$max, $abs, $max],            [$min, $max, $min]        ];        // apply the matrix        return imageconvolution($image->getCore(), $matrix, $div, 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Size_532, Calculate the current aspect ratio\\\\n\\\\n @return float\\\\n,Dohvati odnos širine i visine.,    public function getRatio()    {        return $this->width / $this->height;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Size_534, Checks if given size fits into current size\\\\n\\\\n @param  Size   $size\\\\n @return boolean\\\\n,Proveri da li data veličina slike odgovara trenutnoj veličini.,    public function fitsInto(Size $size)    {        return ($this->width <= $size->width) && ($this->height <= $size->height);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_TrimCommand_622, Trims away parts of an image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Odseci delove slike.,"    public function execute($image)    {        $base = $this->argument(0)->type('string')->value();        $away = $this->argument(1)->value();        $tolerance = $this->argument(2)->type('numeric')->value(0);        $feather = $this->argument(3)->type('numeric')->value(0);        $width = $image->getWidth();        $height = $image->getHeight();        // default values        $checkTransparency = false;        // define borders to trim away        if (is_null($away)) {            $away = ['top', 'right', 'bottom', 'left'];        } elseif (is_string($away)) {            $away = [$away];        }        // lower border names        foreach ($away as $key => $value) {            $away[$key] = strtolower($value);        }        // define base color position        switch (strtolower($base)) {            case 'transparent':            case 'trans':                $checkTransparency = true;                $base_x = 0;                $base_y = 0;                break;            case 'bottom-right':            case 'right-bottom':                $base_x = $width - 1;                $base_y = $height - 1;                break;            default:            case 'top-left':            case 'left-top':                $base_x = 0;                $base_y = 0;                break;        }        // pick base color        if ($checkTransparency) {            $color = new Color; // color will only be used to compare alpha channel        } else {            $color = $image->pickColor($base_x, $base_y, 'object');        }        $top_x = 0;        $top_y = 0;        $bottom_x = $width;        $bottom_y = $height;        // search upper part of image for colors to trim away        if (in_array('top', $away)) {            for ($y=0; $y < ceil($height/2); $y++) {                for ($x=0; $x < $width; $x++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $top_y = max(0, $y - $feather);                        break 2;                    }                }            }        }        // search left part of image for colors to trim away        if (in_array('left', $away)) {            for ($x=0; $x < ceil($width/2); $x++) {                for ($y=$top_y; $y < $height; $y++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $top_x = max(0, $x - $feather);                        break 2;                    }                }            }        }        // search lower part of image for colors to trim away        if (in_array('bottom', $away)) {            for ($y=($height-1); $y >= floor($height/2)-1; $y--) {                for ($x=$top_x; $x < $width; $x++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $bottom_y = min($height, $y+1 + $feather);                        break 2;                    }                }            }        }        // search right part of image for colors to trim away        if (in_array('right', $away)) {            for ($x=($width-1); $x >= floor($width/2)-1; $x--) {                for ($y=$top_y; $y < $bottom_y; $y++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $bottom_x = min($width, $x+1 + $feather);                        break 2;                    }                }            }        }        // trim parts of image        return $this->modify($image, 0, 0, $top_x, $top_y, ($bottom_x-$top_x), ($bottom_y-$top_y), ($bottom_x-$top_x), ($bottom_y-$top_y));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_WidenCommand_623, Resize image proportionally to given width\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni veličinu slike proporionalno sa zadatom širinom.,    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $additionalConstraints = $this->argument(1)->type('closure')->value();        $this->arguments[0] = $width;        $this->arguments[1] = null;        $this->arguments[2] = function ($constraint) use ($additionalConstraints) {            $constraint->aspectRatio();            if(is_callable($additionalConstraints))                $additionalConstraints($constraint);        };        return parent::execute($image);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Autoloader_126, Register the Autoloader with SPL\\\\\\\\n\\\\\\\\n,Registruj Autoloadersa sa SPL-om.,"    public static function register()    {        if (function_exists('__autoload')) {            // Register any existing autoloader function with SPL, so we don't get any clashes            spl_autoload_register('__autoload');        }        // Register ourselves with SPL        if (version_compare(PHP_VERSION, '5.3.0') >= 0) {            return spl_autoload_register(array('PHPExcel_Autoloader', 'load'), true, true);        } else {            return spl_autoload_register(array('PHPExcel_Autoloader', 'load'));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Autoloader_127, Autoload a class identified by name\\\\\\\\n\\\\\\\\n @param    string    $pClassName        Name of the object to load\\\\\\\\n,Automatski učitaj klasu određenu imenom.,"    public static function load($pClassName)    {        if ((class_exists($pClassName, false)) || (strpos($pClassName, 'PHPExcel') !== 0)) {            // Either already loaded, or not a PHPExcel class request            return false;        }        $pClassFilePath = PHPEXCEL_ROOT .            str_replace('_', DIRECTORY_SEPARATOR, $pClassName) .            '.php';        if ((file_exists($pClassFilePath) === false) || (is_readable($pClassFilePath) === false)) {            // Can't load            return false;        }        require($pClassFilePath);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_CachedObjectStorageFactory_132, Return the list of all available cache storage methods\\\\\\\\n\\\\\\\\n @return string[]\\\\\\\\n,Dohvati lisu svih dostupnih metoda za keširanje.,"    public static function getCacheStorageMethods()    {        $activeMethods = array();        foreach (self::$storageMethods as $storageMethod) {            $cacheStorageClass = 'PHPExcel_CachedObjectStorage_' . $storageMethod;            if (call_user_func(array($cacheStorageClass, 'cacheMethodIsAvailable'))) {                $activeMethods[] = $storageMethod;            }        }        return $activeMethods;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_CachedObjectStorageFactory_134, Clear the cache storage\\n\\n,Isprazni keš skladište za podatake.,    public static function finalize()    {        self::$cacheStorageMethod = null;        self::$cacheStorageClass = null;        self::$storageMethodParameters = array();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_139, __clone implementation. Cloning should not be allowed in a Singleton!\\n\\n @access    public\\n @throws    PHPExcel_Calculation_Exception\\n,Kloniranje objekata nije dozvoljeno u Singlton klasama.,    final public function __clone()    {        throw new PHPExcel_Calculation_Exception('Cloning the calculation engine is not allowed!');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_142, Set the Array Return Type (Array or Value of first element in the array)\\\\\\\\n\\\\\\\\n @access    public\\\\\\\\n @param     string    $returnType            Array return type\\\\\\\\n @return     boolean                    Success or failure\\\\\\\\n,Postavi povratni tip za niz.,    public static function setArrayReturnType($returnType)    {        if (($returnType == self::RETURN_ARRAY_AS_VALUE) ||            ($returnType == self::RETURN_ARRAY_AS_ERROR) ||            ($returnType == self::RETURN_ARRAY_AS_ARRAY)) {            self::$returnArrayAsType = $returnType;            return true;        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_151, Wrap string values in quotes\\n\\n @param mixed $value\\n @return mixed\\n,Uokviri string podatak sa znacima navoda.,"    public static function wrapResult($value)    {        if (is_string($value)) {            //    Error values cannot be ""wrapped""            if (preg_match('/^'.self::CALCULATION_REGEXP_ERROR.'$/i', $value, $match)) {                //    Return Excel errors ""as is""                return $value;            }            //    Return strings wrapped in quotes            return '""'.$value.'""';        //    Convert numeric errors to NaN error        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {            return PHPExcel_Calculation_Functions::NaN();        }        return $value;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_152, Remove quotes used as a wrapper to identify string values\n\n @param mixed $value\n @return mixed\n,Uklanjanje navodnika koje uokviruje string vrednost.,"    public static function unwrapResult($value)    {        if (is_string($value)) {            if ((isset($value{0})) && ($value{0} == '""') && (substr($value, -1) == '""')) {                return substr($value, 1, -1);            }        //    Convert numeric errors to NaN error        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {            return PHPExcel_Calculation_Functions::NaN();        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_154," Read the dimensions of a matrix, and re-index it with straight numeric keys starting from row 0, column 0\\\\n\\\\n @param    mixed        &$matrix        matrix operand\\\\n @return    array        An array comprising the number of rows, and number of columns\\\\n",Dohvati dimenzije matrica i reindeksiraj ga vrednostima počevši od nule.,"    private static function getMatrixDimensions(&$matrix)    {        $matrixRows = count($matrix);        $matrixColumns = 0;        foreach ($matrix as $rowKey => $rowValue) {            $matrixColumns = max(count($rowValue), $matrixColumns);            if (!is_array($rowValue)) {                $matrix[$rowKey] = array($rowValue);            } else {                $matrix[$rowKey] = array_values($rowValue);            }        }        $matrix = array_values($matrix);        return array($matrixRows, $matrixColumns);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_155, Ensure that paired matrix operands are both matrices of the same size\\\\\\\\n\\\\\\\\n @param    mixed        &$matrix1        First matrix operand\\\\\\\\n @param    mixed        &$matrix2        Second matrix operand\\\\\\\\n @param    integer        $matrix1Rows    Row size of first matrix operand\\\\\\\\n @param    integer        $matrix1Columns    Column size of first matrix operand\\\\\\\\n @param    integer        $matrix2Rows    Row size of second matrix operand\\\\\\\\n @param    integer        $matrix2Columns    Column size of second matrix operand\\\\\\\\n,Obezbedi da su matrice u operaciji istih dimenzija.,"    private static function resizeMatricesShrink(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Rows < $matrix1Rows) {                for ($i = $matrix2Rows; $i < $matrix1Rows; ++$i) {                    unset($matrix1[$i]);                }            }            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        unset($matrix1[$i][$j]);                    }                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Rows < $matrix2Rows) {                for ($i = $matrix1Rows; $i < $matrix2Rows; ++$i) {                    unset($matrix2[$i]);                }            }            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        unset($matrix2[$i][$j]);                    }                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_156, Ensure that paired matrix operands are both matrices of the same size\n\n @param    mixed        &$matrix1    First matrix operand\n @param    mixed        &$matrix2    Second matrix operand\n @param    integer        $matrix1Rows    Row size of first matrix operand\n @param    integer        $matrix1Columns    Column size of first matrix operand\n @param    integer        $matrix2Rows    Row size of second matrix operand\n @param    integer        $matrix2Columns    Column size of second matrix operand\n,Obezbedi da su matrice u operaciji istih dimenzija.,"    private static function resizeMatricesExtend(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $x = $matrix2[$i][$matrix2Columns-1];                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        $matrix2[$i][$j] = $x;                    }                }            }            if ($matrix2Rows < $matrix1Rows) {                $x = $matrix2[$matrix2Rows-1];                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $matrix2[$i] = $x;                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $x = $matrix1[$i][$matrix1Columns-1];                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        $matrix1[$i][$j] = $x;                    }                }            }            if ($matrix1Rows < $matrix2Rows) {                $x = $matrix1[$matrix1Rows-1];                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $matrix1[$i] = $x;                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_157, Format details of an operand for display in the log (based on operand type)\\\\\\\\n\\\\\\\\n @param    mixed        $value    First matrix operand\\\\\\\\n @return    mixed\\\\\\\\n,Formatiraj detalje operanta za prikazivanje u logu.,"    private function showValue($value)    {        if ($this->_debugLog->getWriteDebugLog()) {            $testArray = PHPExcel_Calculation_Functions::flattenArray($value);            if (count($testArray) == 1) {                $value = array_pop($testArray);            }            if (is_array($value)) {                $returnMatrix = array();                $pad = $rpad = ', ';                foreach ($value as $row) {                    if (is_array($row)) {                        $returnMatrix[] = implode($pad, array_map(array($this, 'showValue'), $row));                        $rpad = '; ';                    } else {                        $returnMatrix[] = $this->showValue($row);                    }                }                return '{ '.implode($rpad, $returnMatrix).' }';            } elseif (is_string($value) && (trim($value, '""') == $value)) {                return '""'.$value.'""';            } elseif (is_bool($value)) {                return ($value) ? self::$localeBoolean['TRUE'] : self::$localeBoolean['FALSE'];            }        }        return PHPExcel_Calculation_Functions::flattenSingleValue($value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_158, Format type and details of an operand for display in the log (based on operand type)\\\\n\\\\n @param    mixed        $value    First matrix operand\\\\n @return    mixed\\\\n,Formatiraj detalje I tip operanta za prikazivanje.u logu (zavisi od tipa operanta).,    private function showTypeDetails($value)    {        if ($this->_debugLog->getWriteDebugLog()) {            $testArray = PHPExcel_Calculation_Functions::flattenArray($value);            if (count($testArray) == 1) {                $value = array_pop($testArray);            }            if ($value === null) {                return 'a NULL value';            } elseif (is_float($value)) {                $typeString = 'a floating point number';            } elseif (is_int($value)) {                $typeString = 'an integer number';            } elseif (is_bool($value)) {                $typeString = 'a boolean';            } elseif (is_array($value)) {                $typeString = 'a matrix';            } else {                if ($value == '') {                    return 'an empty string';                } elseif ($value{0} == '#') {                    return 'a '.$value.' error';                } else {                    $typeString = 'a string';                }            }            return $typeString.' with a value of '.$this->showValue($value);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_160," trigger an error, but nicely, if need be\\n",Trigeruj grešku.,"    protected function raiseFormulaError($errorMessage)    {        $this->formulaError = $errorMessage;        $this->cyclicReferenceStack->clear();        if (!$this->suppressFormulaErrors) {            throw new PHPExcel_Calculation_Exception($errorMessage);        }        trigger_error($errorMessage, E_USER_ERROR);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_175,    Get Data validation rules\\\\n\\\\n    @return    PHPExcel_Cell_DataValidation\\\\n    @throws    PHPExcel_Exception\\\\n,Dohvati pravila za validaciju podataka,    public function getDataValidation()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot get data validation for cell that is not bound to a worksheet');        }        return $this->getWorksheet()->getDataValidation($this->getCoordinate());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_176,    Does this cell contain a Hyperlink?\\\\\\\\n\\\\\\\\n    @return boolean\\\\\\\\n    @throws    PHPExcel_Exception\\\\\\\\n,Odredi da li ćelija sadrži hyperlink.,    public function hasHyperlink()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot check for hyperlink when cell is not bound to a worksheet');        }        return $this->getWorksheet()->hyperlinkExists($this->getCoordinate());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_177,    Get Hyperlink\\\\\\\\n\\\\\\\\n    @return    PHPExcel_Cell_Hyperlink\\\\\\\\n    @throws    PHPExcel_Exception\\\\\\\\n,Dohvati hyperlink.,    public function getHyperlink()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot get hyperlink for cell that is not bound to a worksheet');        }        return $this->getWorksheet()->getHyperlink($this->getCoordinate());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_178,    Get parent worksheet\\n\\n    @return PHPExcel_CachedObjectStorage_CacheBase\\n,Dohvati roditeljev radni list.,    public function getParent()    {        return $this->parent;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_185,    Build range from coordinate strings\\\\n\\\\n    @param    array    $pRange    Array containg one or more arrays containing one or two coordinate strings\\\\n    @return    string    String representation of $pRange\\\\n    @throws    PHPExcel_Exception\\\\n,Kreiraj opseg iz datih stringova sa koordinatama.,"    public static function buildRange($pRange)    {        // Verify range        if (!is_array($pRange) || empty($pRange) || !is_array($pRange[0])) {            throw new PHPExcel_Exception('Range does not contain any information');        }        // Build range        $imploded = array();        $counter = count($pRange);        for ($i = 0; $i < $counter; ++$i) {            $pRange[$i] = implode(':', $pRange[$i]);        }        $imploded = implode(',', $pRange);        return $imploded;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_188," Implement PHP __clone to create a deep clone, not just a shallow copy.\\\\n",Implementacija funkcije za duboko kopiranje objekata.,    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if ((is_object($value)) && ($key != 'parent')) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Comment_219, Create a new PHPExcel_Comment\n\n @throws PHPExcel_Exception\n,Konstruktor za kreiranje komentar objekata u ekselu.,    public function __construct()    {        // Initialise variables        $this->author    = 'Author';        $this->text      = new PHPExcel_RichText();        $this->fillColor = new PHPExcel_Style_Color('FFFFFFE1');        $this->alignment = PHPExcel_Style_Alignment::HORIZONTAL_GENERAL;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Comment_230, Get hash code\\\\n\\\\n @return string    Hash code\\\\n,Dohvati heš kod.,    public function getHashCode()    {        return md5(            $this->author .            $this->text->getHashCode() .            $this->width .            $this->height .            $this->marginLeft .            $this->marginTop .            ($this->visible ? 1 : 0) .            $this->fillColor->getHashCode() .            $this->alignment .            __CLASS__        );    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_DocumentSecurity_253, Is some sort of document security enabled?\\\\n\\\\n @return boolean\\\\n,Da li je omogućena neka vrsta zaštite dokumenta.,    public function isSecurityEnabled()    {        return  $this->lockRevision ||                $this->lockStructure ||                $this->lockWindows;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_DocumentSecurity_259," Implement PHP __clone to create a deep clone, not just a shallow copy.\\\\\\\\n",Implementacija funkcije za duboko kopiranje objekata.,    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if (is_object($value)) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Exception_261, Error handler callback\n\n @param mixed $code\n @param mixed $string\n @param mixed $file\n @param mixed $line\n @param mixed $context\n,Povratna funkcija za obradu greške.,"    public static function errorHandlerCallback($code, $string, $file, $line, $context)    {        $e = new self($string, $code);        $e->line = $line;        $e->file = $file;        throw $e;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_107, Get index for sheet\\n\\n @param  PHPExcel_Worksheet $pSheet\\n @return int Sheet index\\n @throws PHPExcel_Exception\\n,Dohvati indeks stranice iz kolekcije Excel radnih stranica.,"    public function getIndex(PHPExcel_Worksheet $pSheet)    {        foreach ($this->workSheetCollection as $key => $value) {            if ($value->getHashCode() == $pSheet->getHashCode()) {                return $key;            }        }        throw new PHPExcel_Exception(""Sheet does not exist."");    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_115, Copy workbook (!= clone!)\\n\\n @return PHPExcel\\n,kopiraj radnu svesku,    public function copy()    {        $copied = clone $this;        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            $this->workSheetCollection[$i] = $this->workSheetCollection[$i]->copy();            $this->workSheetCollection[$i]->rebindParent($this);        }        return $copied;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_116," Implement PHP __clone to create a deep clone, not just a shallow copy.\\n",Implementacija funkcije za duboko kopiranje objekata.,    public function __clone()    {        foreach ($this as $key => $val) {            if (is_object($val) || (is_array($val))) {                $this->{$key} = unserialize(serialize($val));            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_123, Eliminate all unneeded cellXf and afterwards update the xfIndex for all cells\\n and columns in the workbook\\n,Eleminiši sve nepotrebne Xf ćelije i ažuriraj indekse kolona i redova svih preostalih ćelija u radnoj svesci.,"    public function garbageCollect()    {        // how many references are there to each cellXf ?        $countReferencesCellXf = array();        foreach ($this->cellXfCollection as $index => $cellXf) {            $countReferencesCellXf[$index] = 0;        }        foreach ($this->getWorksheetIterator() as $sheet) {            // from cells            foreach ($sheet->getCellCollection(false) as $cellID) {                $cell = $sheet->getCell($cellID);                ++$countReferencesCellXf[$cell->getXfIndex()];            }            // from row dimensions            foreach ($sheet->getRowDimensions() as $rowDimension) {                if ($rowDimension->getXfIndex() !== null) {                    ++$countReferencesCellXf[$rowDimension->getXfIndex()];                }            }            // from column dimensions            foreach ($sheet->getColumnDimensions() as $columnDimension) {                ++$countReferencesCellXf[$columnDimension->getXfIndex()];            }        }        // remove cellXfs without references and create mapping so we can update xfIndex        // for all cells and columns        $countNeededCellXfs = 0;        $map = array();        foreach ($this->cellXfCollection as $index => $cellXf) {            if ($countReferencesCellXf[$index] > 0 || $index == 0) { // we must never remove the first cellXf                ++$countNeededCellXfs;            } else {                unset($this->cellXfCollection[$index]);            }            $map[$index] = $countNeededCellXfs - 1;        }        $this->cellXfCollection = array_values($this->cellXfCollection);        // update the index for all cellXfs        foreach ($this->cellXfCollection as $i => $cellXf) {            $cellXf->setIndex($i);        }        // make sure there is always at least one cellXf (there should be)        if (empty($this->cellXfCollection)) {            $this->cellXfCollection[] = new PHPExcel_Style();        }        // update the xfIndex for all cells, row dimensions, column dimensions        foreach ($this->getWorksheetIterator() as $sheet) {            // for all cells            foreach ($sheet->getCellCollection(false) as $cellID) {                $cell = $sheet->getCell($cellID);                $cell->setXfIndex($map[$cell->getXfIndex()]);            }            // for all row dimensions            foreach ($sheet->getRowDimensions() as $rowDimension) {                if ($rowDimension->getXfIndex() !== null) {                    $rowDimension->setXfIndex($map[$rowDimension->getXfIndex()]);                }            }            // for all column dimensions            foreach ($sheet->getColumnDimensions() as $columnDimension) {                $columnDimension->setXfIndex($map[$columnDimension->getXfIndex()]);            }            // also do garbage collection for all the sheets            $sheet->garbageCollect();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_86," PHPExcel\n\n Copyright (c) 2006 - 2015 PHPExcel\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n @category   PHPExcel\n @package    PHPExcel\n @copyright  Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\n @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\n @version    ##VERSION##, ##DATE##\n",PHP implementacija klase za rad sa Ekselom.,"class PHPExcel{    /**     * Unique ID     *     * @var string     */    private $uniqueID;    /**     * Document properties     *     * @var PHPExcel_DocumentProperties     */    private $properties;    /**     * Document security     *     * @var PHPExcel_DocumentSecurity     */    private $security;    /**     * Collection of Worksheet objects     *     * @var PHPExcel_Worksheet[]     */    private $workSheetCollection = array();    /**     * Calculation Engine     *     * @var PHPExcel_Calculation     */    private $calculationEngine;    /**     * Active sheet index     *     * @var integer     */    private $activeSheetIndex = 0;    /**     * Named ranges     *     * @var PHPExcel_NamedRange[]     */    private $namedRanges = array();    /**     * CellXf supervisor     *     * @var PHPExcel_Style     */    private $cellXfSupervisor;    /**     * CellXf collection     *     * @var PHPExcel_Style[]     */    private $cellXfCollection = array();    /**     * CellStyleXf collection     *     * @var PHPExcel_Style[]     */    private $cellStyleXfCollection = array();    /**    * hasMacros : this workbook have macros ?    *    * @var bool    */    private $hasMacros = false;    /**    * macrosCode : all macros code (the vbaProject.bin file, this include form, code,  etc.), null if no macro    *    * @var binary    */    private $macrosCode;    /**    * macrosCertificate : if macros are signed, contains vbaProjectSignature.bin file, null if not signed    *    * @var binary    */    private $macrosCertificate;    /**    * ribbonXMLData : null if workbook is'nt Excel 2007 or not contain a customized UI    *    * @var null|string    */    private $ribbonXMLData;    /**    * ribbonBinObjects : null if workbook is'nt Excel 2007 or not contain embedded objects (picture(s)) for Ribbon Elements    * ignored if $ribbonXMLData is null    *    * @var null|array    */    private $ribbonBinObjects;    /**    * The workbook has macros ?    *    * @return boolean true if workbook has macros, false if not    */    public function hasMacros()    {        return $this->hasMacros;    }    /**    * Define if a workbook has macros    *    * @param boolean $hasMacros true|false    */    public function setHasMacros($hasMacros = false)    {        $this->hasMacros = (bool) $hasMacros;    }    /**    * Set the macros code    *    * @param string $MacrosCode string|null    */    public function setMacrosCode($MacrosCode = null)    {        $this->macrosCode=$MacrosCode;        $this->setHasMacros(!is_null($MacrosCode));    }    /**    * Return the macros code    *    * @return string|null    */    public function getMacrosCode()    {        return $this->macrosCode;    }    /**    * Set the macros certificate    *    * @param string|null $Certificate    */    public function setMacrosCertificate($Certificate = null)    {        $this->macrosCertificate=$Certificate;    }    /**    * Is the project signed ?    *    * @return boolean true|false    */    public function hasMacrosCertificate()    {        return !is_null($this->macrosCertificate);    }    /**    * Return the macros certificate    *    * @return string|null    */    public function getMacrosCertificate()    {        return $this->macrosCertificate;    }    /**    * Remove all macros, certificate from spreadsheet    *    */    public function discardMacros()    {        $this->hasMacros=false;        $this->macrosCode=null;        $this->macrosCertificate=null;    }    /**    * set ribbon XML data    *    */    public function setRibbonXMLData($Target = null, $XMLData = null)    {        if (!is_null($Target) && !is_null($XMLData)) {            $this->ribbonXMLData = array('target' => $Target, 'data' => $XMLData);        } else {            $this->ribbonXMLData = null;        }    }    /**    * retrieve ribbon XML Data    *    * return string|null|array    */    public function getRibbonXMLData($What = 'all') //we need some constants here...    {        $ReturnData = null;        $What = strtolower($What);        switch ($What){            case 'all':                $ReturnData = $this->ribbonXMLData;                break;            case 'target':            case 'data':                if (is_array($this->ribbonXMLData) && array_key_exists($What, $this->ribbonXMLData)) {                    $ReturnData = $this->ribbonXMLData[$What];                }                break;        }        return $ReturnData;    }    /**    * store binaries ribbon objects (pictures)    *    */    public function setRibbonBinObjects($BinObjectsNames = null, $BinObjectsData = null)    {        if (!is_null($BinObjectsNames) && !is_null($BinObjectsData)) {            $this->ribbonBinObjects = array('names' => $BinObjectsNames, 'data' => $BinObjectsData);        } else {            $this->ribbonBinObjects = null;        }    }    /**    * return the extension of a filename. Internal use for a array_map callback (php<5.3 don't like lambda function)    *    */    private function getExtensionOnly($ThePath)    {        return pathinfo($ThePath, PATHINFO_EXTENSION);    }    /**    * retrieve Binaries Ribbon Objects    *    */    public function getRibbonBinObjects($What = 'all')    {        $ReturnData = null;        $What = strtolower($What);        switch($What) {            case 'all':                return $this->ribbonBinObjects;                break;            case 'names':            case 'data':                if (is_array($this->ribbonBinObjects) && array_key_exists($What, $this->ribbonBinObjects)) {                    $ReturnData=$this->ribbonBinObjects[$What];                }                break;            case 'types':                if (is_array($this->ribbonBinObjects) &&                    array_key_exists('data', $this->ribbonBinObjects) && is_array($this->ribbonBinObjects['data'])) {                    $tmpTypes=array_keys($this->ribbonBinObjects['data']);                    $ReturnData = array_unique(array_map(array($this, 'getExtensionOnly'), $tmpTypes));                } else {                    $ReturnData=array(); // the caller want an array... not null if empty                }                break;        }        return $ReturnData;    }    /**    * This workbook have a custom UI ?    *    * @return boolean true|false    */    public function hasRibbon()    {        return !is_null($this->ribbonXMLData);    }    /**    * This workbook have additionnal object for the ribbon ?    *    * @return boolean true|false    */    public function hasRibbonBinObjects()    {        return !is_null($this->ribbonBinObjects);    }    /**     * Check if a sheet with a specified code name already exists     *     * @param string $pSheetCodeName  Name of the worksheet to check     * @return boolean     */    public function sheetCodeNameExists($pSheetCodeName)    {        return ($this->getSheetByCodeName($pSheetCodeName) !== null);    }    /**     * Get sheet by code name. Warning : sheet don't have always a code name !     *     * @param string $pName Sheet name     * @return PHPExcel_Worksheet     */    public function getSheetByCodeName($pName = '')    {        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            if ($this->workSheetCollection[$i]->getCodeName() == $pName) {                return $this->workSheetCollection[$i];            }        }        return null;    }     /**     * Create a new PHPExcel with one Worksheet     */    public function __construct()    {        $this->uniqueID = uniqid();        $this->calculationEngine = new PHPExcel_Calculation($this);        // Initialise worksheet collection and add one worksheet        $this->workSheetCollection = array();        $this->workSheetCollection[] = new PHPExcel_Worksheet($this);        $this->activeSheetIndex = 0;        // Create document properties        $this->properties = new PHPExcel_DocumentProperties();        // Create document security        $this->security = new PHPExcel_DocumentSecurity();        // Set named ranges        $this->namedRanges = array();        // Create the cellXf supervisor        $this->cellXfSupervisor = new PHPExcel_Style(true);        $this->cellXfSupervisor->bindParent($this);        // Create the default style        $this->addCellXf(new PHPExcel_Style);        $this->addCellStyleXf(new PHPExcel_Style);    }    /**     * Code to execute when this worksheet is unset()     *     */    public function __destruct()    {        $this->calculationEngine = null;        $this->disconnectWorksheets();    }    /**     * Disconnect all worksheets from this PHPExcel workbook object,     *    typically so that the PHPExcel object can be unset     *     */    public function disconnectWorksheets()    {        $worksheet = null;        foreach ($this->workSheetCollection as $k => &$worksheet) {            $worksheet->disconnectCells();            $this->workSheetCollection[$k] = null;        }        unset($worksheet);        $this->workSheetCollection = array();    }    /**     * Return the calculation engine for this worksheet     *     * @return PHPExcel_Calculation     */    public function getCalculationEngine()    {        return $this->calculationEngine;    }    //    function getCellCacheController()    /**     * Get properties     *     * @return PHPExcel_DocumentProperties     */    public function getProperties()    {        return $this->properties;    }    /**     * Set properties     *     * @param PHPExcel_DocumentProperties    $pValue     */    public function setProperties(PHPExcel_DocumentProperties $pValue)    {        $this->properties = $pValue;    }    /**     * Get security     *     * @return PHPExcel_DocumentSecurity     */    public function getSecurity()    {        return $this->security;    }    /**     * Set security     *     * @param PHPExcel_DocumentSecurity    $pValue     */    public function setSecurity(PHPExcel_DocumentSecurity $pValue)    {        $this->security = $pValue;    }    /**     * Get active sheet     *     * @return PHPExcel_Worksheet     *     * @throws PHPExcel_Exception     */    public function getActiveSheet()    {        return $this->getSheet($this->activeSheetIndex);    }    /**     * Create sheet and add it to this workbook     *     * @param  int|null $iSheetIndex Index where sheet should go (0,1,..., or null for last)     * @return PHPExcel_Worksheet     * @throws PHPExcel_Exception     */    public function createSheet($iSheetIndex = null)    {        $newSheet = new PHPExcel_Worksheet($this);        $this->addSheet($newSheet, $iSheetIndex);        return $newSheet;    }    /**     * Check if a sheet with a specified name already exists     *     * @param  string $pSheetName  Name of the worksheet to check     * @return boolean     */    public function sheetNameExists($pSheetName)    {        return ($this->getSheetByName($pSheetName) !== null);    }    /**     * Add sheet     *     * @param  PHPExcel_Worksheet $pSheet     * @param  int|null $iSheetIndex Index where sheet should go (0,1,..., or null for last)     * @return PHPExcel_Worksheet     * @throws PHPExcel_Exception     */    public function addSheet(PHPExcel_Worksheet $pSheet, $iSheetIndex = null)    {        if ($this->sheetNameExists($pSheet->getTitle())) {            throw new PHPExcel_Exception(                ""Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename this worksheet first.""            );        }        if ($iSheetIndex === null) {            if ($this->activeSheetIndex < 0) {                $this->activeSheetIndex = 0;            }            $this->workSheetCollection[] = $pSheet;        } else {            // Insert the sheet at the requested index            array_splice(                $this->workSheetCollection,                $iSheetIndex,                0,                array($pSheet)            );            // Adjust active sheet index if necessary            if ($this->activeSheetIndex >= $iSheetIndex) {                ++$this->activeSheetIndex;            }        }        if ($pSheet->getParent() === null) {            $pSheet->rebindParent($this);        }        return $pSheet;    }    /**     * Remove sheet by index     *     * @param  int $pIndex Active sheet index     * @throws PHPExcel_Exception     */    public function removeSheetByIndex($pIndex = 0)    {        $numSheets = count($this->workSheetCollection);        if ($pIndex > $numSheets - 1) {            throw new PHPExcel_Exception(                ""You tried to remove a sheet by the out of bounds index: {$pIndex}. The actual number of sheets is {$numSheets}.""            );        } else {            array_splice($this->workSheetCollection, $pIndex, 1);        }        // Adjust active sheet index if necessary        if (($this->activeSheetIndex >= $pIndex) &&            ($pIndex > count($this->workSheetCollection) - 1)) {            --$this->activeSheetIndex;        }    }    /**     * Get sheet by index     *     * @param  int $pIndex Sheet index     * @return PHPExcel_Worksheet     * @throws PHPExcel_Exception     */    public function getSheet($pIndex = 0)    {        if (!isset($this->workSheetCollection[$pIndex])) {            $numSheets = $this->getSheetCount();            throw new PHPExcel_Exception(                ""Your requested sheet index: {$pIndex} is out of bounds. The actual number of sheets is {$numSheets}.""            );        }        return $this->workSheetCollection[$pIndex];    }    /**     * Get all sheets     *     * @return PHPExcel_Worksheet[]     */    public function getAllSheets()    {        return $this->workSheetCollection;    }    /**     * Get sheet by name     *     * @param  string $pName Sheet name     * @return PHPExcel_Worksheet     */    public function getSheetByName($pName = '')    {        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            if ($this->workSheetCollection[$i]->getTitle() === $pName) {                return $this->workSheetCollection[$i];            }        }        return null;    }    /**     * Get index for sheet     *     * @param  PHPExcel_Worksheet $pSheet     * @return int Sheet index     * @throws PHPExcel_Exception     */    public function getIndex(PHPExcel_Worksheet $pSheet)    {        foreach ($this->workSheetCollection as $key => $value) {            if ($value->getHashCode() == $pSheet->getHashCode()) {                return $key;            }        }        throw new PHPExcel_Exception(""Sheet does not exist."");    }    /**     * Set index for sheet by sheet name.     *     * @param  string $sheetName Sheet name to modify index for     * @param  int $newIndex New index for the sheet     * @return int New sheet index     * @throws PHPExcel_Exception     */    public function setIndexByName($sheetName, $newIndex)    {        $oldIndex = $this->getIndex($this->getSheetByName($sheetName));        $pSheet = array_splice(            $this->workSheetCollection,            $oldIndex,            1        );        array_splice(            $this->workSheetCollection,            $newIndex,            0,            $pSheet        );        return $newIndex;    }    /**     * Get sheet count     *     * @return int     */    public function getSheetCount()    {        return count($this->workSheetCollection);    }    /**     * Get active sheet index     *     * @return int Active sheet index     */    public function getActiveSheetIndex()    {        return $this->activeSheetIndex;    }    /**     * Set active sheet index     *     * @param  int $pIndex Active sheet index     * @throws PHPExcel_Exception     * @return PHPExcel_Worksheet     */    public function setActiveSheetIndex($pIndex = 0)    {        $numSheets = count($this->workSheetCollection);        if ($pIndex > $numSheets - 1) {            throw new PHPExcel_Exception(                ""You tried to set a sheet active by the out of bounds index: {$pIndex}. The actual number of sheets is {$numSheets}.""            );        } else {            $this->activeSheetIndex = $pIndex;        }        return $this->getActiveSheet();    }    /**     * Set active sheet index by name     *     * @param  string $pValue Sheet title     * @return PHPExcel_Worksheet     * @throws PHPExcel_Exception     */    public function setActiveSheetIndexByName($pValue = '')    {        if (($worksheet = $this->getSheetByName($pValue)) instanceof PHPExcel_Worksheet) {            $this->setActiveSheetIndex($this->getIndex($worksheet));            return $worksheet;        }        throw new PHPExcel_Exception('Workbook does not contain sheet:' . $pValue);    }    /**     * Get sheet names     *     * @return string[]     */    public function getSheetNames()    {        $returnValue = array();        $worksheetCount = $this->getSheetCount();        for ($i = 0; $i < $worksheetCount; ++$i) {            $returnValue[] = $this->getSheet($i)->getTitle();        }        return $returnValue;    }    /**     * Add external sheet     *     * @param  PHPExcel_Worksheet $pSheet External sheet to add     * @param  int|null $iSheetIndex Index where sheet should go (0,1,..., or null for last)     * @throws PHPExcel_Exception     * @return PHPExcel_Worksheet     */    public function addExternalSheet(PHPExcel_Worksheet $pSheet, $iSheetIndex = null)    {        if ($this->sheetNameExists($pSheet->getTitle())) {            throw new PHPExcel_Exception(""Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename the external sheet first."");        }        // count how many cellXfs there are in this workbook currently, we will need this below        $countCellXfs = count($this->cellXfCollection);        // copy all the shared cellXfs from the external workbook and append them to the current        foreach ($pSheet->getParent()->getCellXfCollection() as $cellXf) {            $this->addCellXf(clone $cellXf);        }        // move sheet to this workbook        $pSheet->rebindParent($this);        // update the cellXfs        foreach ($pSheet->getCellCollection(false) as $cellID) {            $cell = $pSheet->getCell($cellID);            $cell->setXfIndex($cell->getXfIndex() + $countCellXfs);        }        return $this->addSheet($pSheet, $iSheetIndex);    }    /**     * Get named ranges     *     * @return PHPExcel_NamedRange[]     */    public function getNamedRanges()    {        return $this->namedRanges;    }    /**     * Add named range     *     * @param  PHPExcel_NamedRange $namedRange     * @return boolean     */    public function addNamedRange(PHPExcel_NamedRange $namedRange)    {        if ($namedRange->getScope() == null) {            // global scope            $this->namedRanges[$namedRange->getName()] = $namedRange;        } else {            // local scope            $this->namedRanges[$namedRange->getScope()->getTitle().'!'.$namedRange->getName()] = $namedRange;        }        return true;    }    /**     * Get named range     *     * @param  string $namedRange     * @param  PHPExcel_Worksheet|null $pSheet Scope. Use null for global scope     * @return PHPExcel_NamedRange|null     */    public function getNamedRange($namedRange, PHPExcel_Worksheet $pSheet = null)    {        $returnValue = null;        if ($namedRange != '' && ($namedRange !== null)) {            // first look for global defined name            if (isset($this->namedRanges[$namedRange])) {                $returnValue = $this->namedRanges[$namedRange];            }            // then look for local defined name (has priority over global defined name if both names exist)            if (($pSheet !== null) && isset($this->namedRanges[$pSheet->getTitle() . '!' . $namedRange])) {                $returnValue = $this->namedRanges[$pSheet->getTitle() . '!' . $namedRange];            }        }        return $returnValue;    }    /**     * Remove named range     *     * @param  string  $namedRange     * @param  PHPExcel_Worksheet|null  $pSheet  Scope: use null for global scope.     * @return PHPExcel     */    public function removeNamedRange($namedRange, PHPExcel_Worksheet $pSheet = null)    {        if ($pSheet === null) {            if (isset($this->namedRanges[$namedRange])) {                unset($this->namedRanges[$namedRange]);            }        } else {            if (isset($this->namedRanges[$pSheet->getTitle() . '!' . $namedRange])) {                unset($this->namedRanges[$pSheet->getTitle() . '!' . $namedRange]);            }        }        return $this;    }    /**     * Get worksheet iterator     *     * @return PHPExcel_WorksheetIterator     */    public function getWorksheetIterator()    {        return new PHPExcel_WorksheetIterator($this);    }    /**     * Copy workbook (!= clone!)     *     * @return PHPExcel     */    public function copy()    {        $copied = clone $this;        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            $this->workSheetCollection[$i] = $this->workSheetCollection[$i]->copy();            $this->workSheetCollection[$i]->rebindParent($this);        }        return $copied;    }    /**     * Implement PHP __clone to create a deep clone, not just a shallow copy.     */    public function __clone()    {        foreach ($this as $key => $val) {            if (is_object($val) || (is_array($val))) {                $this->{$key} = unserialize(serialize($val));            }        }    }    /**     * Get the workbook collection of cellXfs     *     * @return PHPExcel_Style[]     */    public function getCellXfCollection()    {        return $this->cellXfCollection;    }    /**     * Get cellXf by index     *     * @param  int $pIndex     * @return PHPExcel_Style     */    public function getCellXfByIndex($pIndex = 0)    {        return $this->cellXfCollection[$pIndex];    }    /**     * Get cellXf by hash code     *     * @param  string $pValue     * @return PHPExcel_Style|boolean False if no match found     */    public function getCellXfByHashCode($pValue = '')    {        foreach ($this->cellXfCollection as $cellXf) {            if ($cellXf->getHashCode() == $pValue) {                return $cellXf;            }        }        return false;    }    /**     * Check if style exists in style collection     *     * @param  PHPExcel_Style $pCellStyle     * @return boolean     */    public function cellXfExists($pCellStyle = null)    {        return in_array($pCellStyle, $this->cellXfCollection, true);    }    /**     * Get default style     *     * @return PHPExcel_Style     * @throws PHPExcel_Exception     */    public function getDefaultStyle()    {        if (isset($this->cellXfCollection[0])) {            return $this->cellXfCollection[0];        }        throw new PHPExcel_Exception('No default style found for this workbook');    }    /**     * Add a cellXf to the workbook     *     * @param PHPExcel_Style $style     */    public function addCellXf(PHPExcel_Style $style)    {        $this->cellXfCollection[] = $style;        $style->setIndex(count($this->cellXfCollection) - 1);    }    /**     * Remove cellXf by index. It is ensured that all cells get their xf index updated.     *     * @param integer $pIndex Index to cellXf     * @throws PHPExcel_Exception     */    public function removeCellXfByIndex($pIndex = 0)    {        if ($pIndex > count($this->cellXfCollection) - 1) {            throw new PHPExcel_Exception(""CellXf index is out of bounds."");        } else {            // first remove the cellXf            array_splice($this->cellXfCollection, $pIndex, 1);            // then update cellXf indexes for cells            foreach ($this->workSheetCollection as $worksheet) {                foreach ($worksheet->getCellCollection(false) as $cellID) {                    $cell = $worksheet->getCell($cellID);                    $xfIndex = $cell->getXfIndex();                    if ($xfIndex > $pIndex) {                        // decrease xf index by 1                        $cell->setXfIndex($xfIndex - 1);                    } elseif ($xfIndex == $pIndex) {                        // set to default xf index 0                        $cell->setXfIndex(0);                    }                }            }        }    }    /**     * Get the cellXf supervisor     *     * @return PHPExcel_Style     */    public function getCellXfSupervisor()    {        return $this->cellXfSupervisor;    }    /**     * Get the workbook collection of cellStyleXfs     *     * @return PHPExcel_Style[]     */    public function getCellStyleXfCollection()    {        return $this->cellStyleXfCollection;    }    /**     * Get cellStyleXf by index     *     * @param integer $pIndex Index to cellXf     * @return PHPExcel_Style     */    public function getCellStyleXfByIndex($pIndex = 0)    {        return $this->cellStyleXfCollection[$pIndex];    }    /**     * Get cellStyleXf by hash code     *     * @param  string $pValue     * @return PHPExcel_Style|boolean False if no match found     */    public function getCellStyleXfByHashCode($pValue = '')    {        foreach ($this->cellStyleXfCollection as $cellStyleXf) {            if ($cellStyleXf->getHashCode() == $pValue) {                return $cellStyleXf;            }        }        return false;    }    /**     * Add a cellStyleXf to the workbook     *     * @param PHPExcel_Style $pStyle     */    public function addCellStyleXf(PHPExcel_Style $pStyle)    {        $this->cellStyleXfCollection[] = $pStyle;        $pStyle->setIndex(count($this->cellStyleXfCollection) - 1);    }    /**     * Remove cellStyleXf by index     *     * @param integer $pIndex Index to cellXf     * @throws PHPExcel_Exception     */    public function removeCellStyleXfByIndex($pIndex = 0)    {        if ($pIndex > count($this->cellStyleXfCollection) - 1) {            throw new PHPExcel_Exception(""CellStyleXf index is out of bounds."");        } else {            array_splice($this->cellStyleXfCollection, $pIndex, 1);        }    }    /**     * Eliminate all unneeded cellXf and afterwards update the xfIndex for all cells     * and columns in the workbook     */    public function garbageCollect()    {        // how many references are there to each cellXf ?        $countReferencesCellXf = array();        foreach ($this->cellXfCollection as $index => $cellXf) {            $countReferencesCellXf[$index] = 0;        }        foreach ($this->getWorksheetIterator() as $sheet) {            // from cells            foreach ($sheet->getCellCollection(false) as $cellID) {                $cell = $sheet->getCell($cellID);                ++$countReferencesCellXf[$cell->getXfIndex()];            }            // from row dimensions            foreach ($sheet->getRowDimensions() as $rowDimension) {                if ($rowDimension->getXfIndex() !== null) {                    ++$countReferencesCellXf[$rowDimension->getXfIndex()];                }            }            // from column dimensions            foreach ($sheet->getColumnDimensions() as $columnDimension) {                ++$countReferencesCellXf[$columnDimension->getXfIndex()];            }        }        // remove cellXfs without references and create mapping so we can update xfIndex        // for all cells and columns        $countNeededCellXfs = 0;        $map = array();        foreach ($this->cellXfCollection as $index => $cellXf) {            if ($countReferencesCellXf[$index] > 0 || $index == 0) { // we must never remove the first cellXf                ++$countNeededCellXfs;            } else {                unset($this->cellXfCollection[$index]);            }            $map[$index] = $countNeededCellXfs - 1;        }        $this->cellXfCollection = array_values($this->cellXfCollection);        // update the index for all cellXfs        foreach ($this->cellXfCollection as $i => $cellXf) {            $cellXf->setIndex($i);        }        // make sure there is always at least one cellXf (there should be)        if (empty($this->cellXfCollection)) {            $this->cellXfCollection[] = new PHPExcel_Style();        }        // update the xfIndex for all cells, row dimensions, column dimensions        foreach ($this->getWorksheetIterator() as $sheet) {            // for all cells            foreach ($sheet->getCellCollection(false) as $cellID) {                $cell = $sheet->getCell($cellID);                $cell->setXfIndex($map[$cell->getXfIndex()]);            }            // for all row dimensions            foreach ($sheet->getRowDimensions() as $rowDimension) {                if ($rowDimension->getXfIndex() !== null) {                    $rowDimension->setXfIndex($map[$rowDimension->getXfIndex()]);                }            }            // for all column dimensions            foreach ($sheet->getColumnDimensions() as $columnDimension) {                $columnDimension->setXfIndex($map[$columnDimension->getXfIndex()]);            }            // also do garbage collection for all the sheets            $sheet->garbageCollect();        }    }    /**     * Return the unique ID value assigned to this spreadsheet workbook     *     * @return string     */    public function getID()    {        return $this->uniqueID;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_96, Create a new PHPExcel with one Worksheet\n,Konstruiši novi PHP eksel objekat sa jednom radnom sveskom.,    public function __construct()    {        $this->uniqueID = uniqid();        $this->calculationEngine = new PHPExcel_Calculation($this);        // Initialise worksheet collection and add one worksheet        $this->workSheetCollection = array();        $this->workSheetCollection[] = new PHPExcel_Worksheet($this);        $this->activeSheetIndex = 0;        // Create document properties        $this->properties = new PHPExcel_DocumentProperties();        // Create document security        $this->security = new PHPExcel_DocumentSecurity();        // Set named ranges        $this->namedRanges = array();        // Create the cellXf supervisor        $this->cellXfSupervisor = new PHPExcel_Style(true);        $this->cellXfSupervisor->bindParent($this);        // Create the default style        $this->addCellXf(new PHPExcel_Style);        $this->addCellStyleXf(new PHPExcel_Style);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_AbstractCollection_973, Add new item\\n\\n @param \\\\PhpOffice\\\\PhpWord\\\\Element\\\\AbstractContainer $item\\n @return int\\n,Dodaj novi podatak u kolekciju.,    public function addItem($item)    {        $index = $this->countItems() + 1;        $this->items[$index] = $item;        return $index;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Bookmarks_975, Bookmarks collection\\n\\n @since 0.12.0\\n,Klasa kolekcije obeleživača.,class Bookmarks extends AbstractCollection{},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_CollectionTest_1047, Test class for PhpOffice\\\\PhpWord\\\\Collection subnamespace\\n\\n Using concrete class Footnotes instead of AbstractCollection\\n,Klasa za testiranje PhpOffice. Koristi se podprostor imena kolekcije. Koristi se konkretna klasa Footnotes umesto klase abstraktne kolekcije.,"class CollectionTest extends \PHPUnit\Framework\TestCase{    /**     * Test collection     */    public function testCollection()    {        $object = new Footnotes();        $object->addItem(new Footnote()); // addItem #1        $this->assertEquals(2, $object->addItem(new Footnote())); // addItem #2. Should returns new item index        $this->assertCount(2, $object->getItems()); // getItems returns array        $this->assertInstanceOf('PhpOffice\\PhpWord\\Element\\Footnote', $object->getItem(1)); // getItem returns object        $this->assertNull($object->getItem(3)); // getItem returns null when invalid index is referenced        $object->setItem(2, null); // Set item #2 to null        $this->assertNull($object->getItem(2)); // Check if it's null    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_FootnotePropertiesTest_1050, Test setting style with normal value\n,Testiraj postavljanje parametara style sa normalnim vrednostima.,"    public function testSetGetNormal()    {        $footnoteProp = new FootnoteProperties();        $footnoteProp->setPos(FootnoteProperties::POSITION_DOC_END);        $footnoteProp->setNumFmt(NumberFormat::LOWER_ROMAN);        $footnoteProp->setNumStart(2);        $footnoteProp->setNumRestart(FootnoteProperties::RESTART_NUMBER_EACH_PAGE);        $this->assertEquals(FootnoteProperties::POSITION_DOC_END, $footnoteProp->getPos());        $this->assertEquals(NumberFormat::LOWER_ROMAN, $footnoteProp->getNumFmt());        $this->assertEquals(2, $footnoteProp->getNumStart());        $this->assertEquals(FootnoteProperties::RESTART_NUMBER_EACH_PAGE, $footnoteProp->getNumRestart());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_FootnotePropertiesTest_1051, Test throws exception if wrong position given\n\n @expectedException \\InvalidArgumentException\n,Test će izbaciti izuzetak ukoliko su prosleđene vrednosti za poziciju pogrešne.,    public function testWrongPos()    {        $footnoteProp = new FootnoteProperties();        $footnoteProp->setPos(NumberFormat::LOWER_ROMAN);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_FootnotePropertiesTest_1052, Test throws exception if wrong number format given\n\n @expectedException \\InvalidArgumentException\n,Test će izbaciti izuzetak ukoliko je prosleđen broj u lošem formatu.,    public function testWrongNumFmt()    {        $footnoteProp = new FootnoteProperties();        $footnoteProp->setNumFmt(FootnoteProperties::POSITION_DOC_END);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_IOFactoryTest_980, Create existing reader\n,Testiraj postojećeg čitača za Php office.,"    public function testExistingReaderCanBeCreated()    {        $this->assertInstanceOf(            'PhpOffice\\PhpWord\\Reader\\Word2007',            IOFactory::createReader('Word2007')        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_MediaTest_989, Add section link\n,Dodaj odeljak za linkovanje.,"    public function testAddSectionLinkElement()    {        $expected = Media::countElements('section') + 1;        $actual = Media::addElement('section', 'link', 'http://test.com');        $this->assertEquals($expected, $actual);        $this->assertCount(1, Media::getElements('section', 'link'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_MediaTest_991, Add footer media element and reset media\\n,Dodaj element futer medija i resetuj medij. ,"    public function testAddFooterMediaElement()    {        $local = __DIR__ . '/_files/images/mars.jpg';        $remote = self::getRemoteImageUrl();        Media::addElement('footer1', 'image', $local, new Image($local));        Media::addElement('footer1', 'image', $local, new Image($local));        Media::addElement('footer1', 'image', $remote, new Image($remote));        $this->assertCount(2, Media::getElements('footer1'));        Media::resetElements();        $this->assertCount(0, Media::getElements('footer1'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Media_873, Media collection\n,Klasa kolekcije Medija.,"class Media{    /**     * Media elements     *     * @var array     */    private static $elements = array();    /**     * Add new media element     *     * @since 0.10.0     * @since 0.9.2     *     * @param string $container section|headerx|footerx|footnote|endnote     * @param string $mediaType image|object|link     * @param string $source     * @param \PhpOffice\PhpWord\Element\Image $image     *     * @throws \PhpOffice\PhpWord\Exception\Exception     *     * @return int     */    public static function addElement($container, $mediaType, $source, Image $image = null)    {        // Assign unique media Id and initiate media container if none exists        $mediaId = md5($container . $source);        if (!isset(self::$elements[$container])) {            self::$elements[$container] = array();        }        // Add media if not exists or point to existing media        if (!isset(self::$elements[$container][$mediaId])) {            $mediaCount = self::countElements($container);            $mediaTypeCount = self::countElements($container, $mediaType);            $mediaTypeCount++;            $rId = ++$mediaCount;            $target = null;            $mediaData = array('mediaIndex' => $mediaTypeCount);            switch ($mediaType) {                // Images                case 'image':                    if (is_null($image)) {                        throw new Exception('Image object not assigned.');                    }                    $isMemImage = $image->isMemImage();                    $extension = $image->getImageExtension();                    $mediaData['imageExtension'] = $extension;                    $mediaData['imageType'] = $image->getImageType();                    if ($isMemImage) {                        $mediaData['isMemImage'] = true;                        $mediaData['createFunction'] = $image->getImageCreateFunction();                        $mediaData['imageFunction'] = $image->getImageFunction();                    }                    $target = ""{$container}_image{$mediaTypeCount}.{$extension}"";                    $image->setTarget($target);                    $image->setMediaIndex($mediaTypeCount);                    break;                // Objects                case 'object':                    $target = ""{$container}_oleObject{$mediaTypeCount}.bin"";                    break;                // Links                case 'link':                    $target = $source;                    break;            }            $mediaData['source'] = $source;            $mediaData['target'] = $target;            $mediaData['type'] = $mediaType;            $mediaData['rID'] = $rId;            self::$elements[$container][$mediaId] = $mediaData;            return $rId;        }        $mediaData = self::$elements[$container][$mediaId];        if (!is_null($image)) {            $image->setTarget($mediaData['target']);            $image->setMediaIndex($mediaData['mediaIndex']);        }        return $mediaData['rID'];    }    /**     * Get media elements count     *     * @param string $container section|headerx|footerx|footnote|endnote     * @param string $mediaType image|object|link     * @return int     * @since 0.10.0     */    public static function countElements($container, $mediaType = null)    {        $mediaCount = 0;        if (isset(self::$elements[$container])) {            foreach (self::$elements[$container] as $mediaData) {                if (!is_null($mediaType)) {                    if ($mediaType == $mediaData['type']) {                        $mediaCount++;                    }                } else {                    $mediaCount++;                }            }        }        return $mediaCount;    }    /**     * Get media elements     *     * @param string $container section|headerx|footerx|footnote|endnote     * @param string $type image|object|link     * @return array     * @since 0.10.0     */    public static function getElements($container, $type = null)    {        $elements = array();        // If header/footer, search for headerx and footerx where x is number        if ($container == 'header' || $container == 'footer') {            foreach (self::$elements as $key => $val) {                if (substr($key, 0, 6) == $container) {                    $elements[$key] = $val;                }            }            return $elements;        }        if (!isset(self::$elements[$container])) {            return $elements;        }        return self::getElementsByType($container, $type);    }    /**     * Get elements by media type     *     * @param string $container section|footnote|endnote     * @param string $type image|object|link     * @return array     * @since 0.11.0 Splitted from `getElements` to reduce complexity     */    private static function getElementsByType($container, $type = null)    {        $elements = array();        foreach (self::$elements[$container] as $key => $data) {            if ($type !== null) {                if ($type == $data['type']) {                    $elements[$key] = $data;                }            } else {                $elements[$key] = $data;            }        }        return $elements;    }    /**     * Reset media elements     */    public static function resetElements()    {        self::$elements = array();    }    /**     * Add new Section Media Element     *     * @deprecated 0.10.0     *     * @param  string $src     * @param  string $type     * @param  \PhpOffice\PhpWord\Element\Image $image     *     * @return int     *     * @codeCoverageIgnore     */    public static function addSectionMediaElement($src, $type, Image $image = null)    {        return self::addElement('section', $type, $src, $image);    }    /**     * Add new Section Link Element     *     * @deprecated 0.10.0     *     * @param string $linkSrc     *     * @return int     *     * @codeCoverageIgnore     */    public static function addSectionLinkElement($linkSrc)    {        return self::addElement('section', 'link', $linkSrc);    }    /**     * Get Section Media Elements     *     * @deprecated 0.10.0     *     * @param string $key     *     * @return array     *     * @codeCoverageIgnore     */    public static function getSectionMediaElements($key = null)    {        return self::getElements('section', $key);    }    /**     * Get Section Media Elements Count     *     * @deprecated 0.10.0     *     * @param string $key     *     * @return int     *     * @codeCoverageIgnore     */    public static function countSectionMediaElements($key = null)    {        return self::countElements('section', $key);    }    /**     * Add new Header Media Element     *     * @deprecated 0.10.0     *     * @param  int $headerCount     * @param  string $src     * @param  \PhpOffice\PhpWord\Element\Image $image     *     * @return int     *     * @codeCoverageIgnore     */    public static function addHeaderMediaElement($headerCount, $src, Image $image = null)    {        return self::addElement(""header{$headerCount}"", 'image', $src, $image);    }    /**     * Get Header Media Elements Count     *     * @deprecated 0.10.0     *     * @param string $key     *     * @return int     *     * @codeCoverageIgnore     */    public static function countHeaderMediaElements($key)    {        return self::countElements($key);    }    /**     * Get Header Media Elements     *     * @deprecated 0.10.0     *     * @return array     *     * @codeCoverageIgnore     */    public static function getHeaderMediaElements()    {        return self::getElements('header');    }    /**     * Add new Footer Media Element     *     * @deprecated 0.10.0     *     * @param  int $footerCount     * @param  string $src     * @param  \PhpOffice\PhpWord\Element\Image $image     *     * @return int     *     * @codeCoverageIgnore     */    public static function addFooterMediaElement($footerCount, $src, Image $image = null)    {        return self::addElement(""footer{$footerCount}"", 'image', $src, $image);    }    /**     * Get Footer Media Elements Count     *     * @deprecated 0.10.0     *     * @param string $key     *     * @return int     *     * @codeCoverageIgnore     */    public static function countFooterMediaElements($key)    {        return self::countElements($key);    }    /**     * Get Footer Media Elements     *     * @deprecated 0.10.0     *     * @return array     *     * @codeCoverageIgnore     */    public static function getFooterMediaElements()    {        return self::getElements('footer');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Media_875, Add new Section Link Element\n\n @deprecated 0.10.0\n\n @param string $linkSrc\n\n @return int\n\n @codeCoverageIgnore\n,Dodaj novi element za odeljak linkovanja.,"    public static function addSectionLinkElement($linkSrc)    {        return self::addElement('section', 'link', $linkSrc);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Media_876, Get Header Media Elements Count\\n\\n @deprecated 0.10.0\\n\\n @param string $key\\n\\n @return int\\n\\n @codeCoverageIgnore\\n,Dohvati broj elemenata medija zaglavlja.,    public static function countHeaderMediaElements($key)    {        return self::countElements($key);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Media_877, Get Header Media Elements\n\n @deprecated 0.10.0\n\n @return array\n\n @codeCoverageIgnore\n,Dohvati elemenate medija zaglavlja.,    public static function getHeaderMediaElements()    {        return self::getElements('header');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_1000, Test add title style\\n,Testiraj dodavanje stila za naslov.,"    public function testAddTitleStyle()    {        $phpWord = new PhpWord();        $titleLevel = 1;        $titleName = ""Heading_{$titleLevel}"";        $phpWord->addTitleStyle($titleLevel, array());        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Font', Style::getStyle($titleName));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_1001, Test load template\\n\\n @deprecated 0.12.0\\n,Testiraj učitavanje šablona.,"    public function testLoadTemplate()    {        $templateFqfn = __DIR__ . '/_files/templates/blank.docx';        $phpWord = new PhpWord();        $this->assertInstanceOf(            'PhpOffice\\PhpWord\\TemplateProcessor',            $phpWord->loadTemplate($templateFqfn)        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_1003, Test save\n,Sačuvaj test.,"    public function testSave()    {        $this->setOutputCallback(function () {        });        $phpWord = new PhpWord();        $section = $phpWord->addSection();        $section->addText('Hello world!');        $this->assertTrue($phpWord->save('test.docx', 'Word2007', true));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_1004, Test calling undefined method\n\n @expectedException \\BadMethodCallException\n @expectedExceptionMessage is not defined\n,Testiraj pozivanje nedefinisanih metoda.,    public function testCallUndefinedMethod()    {        $phpWord = new PhpWord();        $phpWord->undefinedMethod();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_993, Test class for PhpOffice\\PhpWord\\PhpWord\n\n @runTestsInSeparateProcesses\n,Klasa za testiranje PhpOffice.,"class PhpWordTest extends \PHPUnit\Framework\TestCase{    /**     * Test object creation     */    public function testConstruct()    {        $phpWord = new PhpWord();        $this->assertEquals(new DocInfo(), $phpWord->getDocInfo());        $this->assertEquals(Settings::DEFAULT_FONT_NAME, $phpWord->getDefaultFontName());        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, $phpWord->getDefaultFontSize());    }    /**     * Test create/get section     */    public function testCreateGetSections()    {        $phpWord = new PhpWord();        $phpWord->addSection();        $this->assertCount(1, $phpWord->getSections());    }    /**     * Test set/get default font name     */    public function testSetGetDefaultFontName()    {        $phpWord = new PhpWord();        $fontName = 'Times New Roman';        $this->assertEquals(Settings::DEFAULT_FONT_NAME, $phpWord->getDefaultFontName());        $phpWord->setDefaultFontName($fontName);        $this->assertEquals($fontName, $phpWord->getDefaultFontName());    }    /**     * Test set/get default font size     */    public function testSetGetDefaultFontSize()    {        $phpWord = new PhpWord();        $fontSize = 16;        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, $phpWord->getDefaultFontSize());        $phpWord->setDefaultFontSize($fontSize);        $this->assertEquals($fontSize, $phpWord->getDefaultFontSize());    }    /**     * Test set default paragraph style     */    public function testSetDefaultParagraphStyle()    {        $phpWord = new PhpWord();        $phpWord->setDefaultParagraphStyle(array());        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Paragraph', Style::getStyle('Normal'));    }    /**     * Test add styles     */    public function testAddStyles()    {        $phpWord = new PhpWord();        $styles = array(            'Paragraph' => 'Paragraph',            'Font'      => 'Font',            'Table'     => 'Table',            'Link'      => 'Font',        );        foreach ($styles as $key => $value) {            $method = ""add{$key}Style"";            $styleId = ""{$key} Style"";            $phpWord->$method($styleId, array());            $this->assertInstanceOf(""PhpOffice\\PhpWord\\Style\\{$value}"", Style::getStyle($styleId));        }    }    /**     * Test add title style     */    public function testAddTitleStyle()    {        $phpWord = new PhpWord();        $titleLevel = 1;        $titleName = ""Heading_{$titleLevel}"";        $phpWord->addTitleStyle($titleLevel, array());        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Font', Style::getStyle($titleName));    }    /**     * Test load template     *     * @deprecated 0.12.0     */    public function testLoadTemplate()    {        $templateFqfn = __DIR__ . '/_files/templates/blank.docx';        $phpWord = new PhpWord();        $this->assertInstanceOf(            'PhpOffice\\PhpWord\\TemplateProcessor',            $phpWord->loadTemplate($templateFqfn)        );    }    /**     * Test load template exception     *     * @deprecated 0.12.0     *     * @expectedException \PhpOffice\PhpWord\Exception\Exception     */    public function testLoadTemplateException()    {        $templateFqfn = implode(            DIRECTORY_SEPARATOR,            array(PHPWORD_TESTS_BASE_DIR, 'PhpWord', 'Tests', '_files', 'templates', 'blanks.docx')        );        $phpWord = new PhpWord();        $phpWord->loadTemplate($templateFqfn);    }    /**     * Test save     */    public function testSave()    {        $this->setOutputCallback(function () {        });        $phpWord = new PhpWord();        $section = $phpWord->addSection();        $section->addText('Hello world!');        $this->assertTrue($phpWord->save('test.docx', 'Word2007', true));    }    /**     * Test calling undefined method     *     * @expectedException \BadMethodCallException     * @expectedExceptionMessage is not defined     */    public function testCallUndefinedMethod()    {        $phpWord = new PhpWord();        $phpWord->undefinedMethod();    }    /**     * @covers \PhpOffice\PhpWord\PhpWord::getSection     */    public function testGetNotExistingSection()    {        $phpWord = new PhpWord();        $section = $phpWord->getSection(0);        $this->assertNull($section);    }    /**     * @covers \PhpOffice\PhpWord\PhpWord::getSection     */    public function testGetSection()    {        $phpWord = new PhpWord();        $phpWord->addSection();        $section = $phpWord->getSection(0);        $this->assertNotNull($section);    }    /**     * @covers \PhpOffice\PhpWord\PhpWord::sortSections     */    public function testSortSections()    {        $phpWord = new PhpWord();        $section1 = $phpWord->addSection();        $section1->addText('test1');        $section2 = $phpWord->addSection();        $section2->addText('test2');        $section2->addText('test3');        $this->assertEquals(1, $phpWord->getSection(0)->countElements());        $this->assertEquals(2, $phpWord->getSection(1)->countElements());        $phpWord->sortSections(function ($a, $b) {            $numElementsInA = $a->countElements();            $numElementsInB = $b->countElements();            if ($numElementsInA === $numElementsInB) {                return 0;            } elseif ($numElementsInA > $numElementsInB) {                return -1;            }            return 1;        });        $this->assertEquals(2, $phpWord->getSection(0)->countElements());        $this->assertEquals(1, $phpWord->getSection(1)->countElements());    }    /**     * @covers \PhpOffice\PhpWord\PhpWord::getSettings     */    public function testGetSettings()    {        $phpWord = new PhpWord();        $this->assertInstanceOf('PhpOffice\\PhpWord\\Metadata\\Settings', $phpWord->getSettings());    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_994, Test object creation\\n,Kreiranje objekta za testiranje.,"    public function testConstruct()    {        $phpWord = new PhpWord();        $this->assertEquals(new DocInfo(), $phpWord->getDocInfo());        $this->assertEquals(Settings::DEFAULT_FONT_NAME, $phpWord->getDefaultFontName());        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, $phpWord->getDefaultFontSize());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_996, Test set/get default font name\\n,Proveri postavljanje i dohvatanje podrazumevanog naziva za font.,"    public function testSetGetDefaultFontName()    {        $phpWord = new PhpWord();        $fontName = 'Times New Roman';        $this->assertEquals(Settings::DEFAULT_FONT_NAME, $phpWord->getDefaultFontName());        $phpWord->setDefaultFontName($fontName);        $this->assertEquals($fontName, $phpWord->getDefaultFontName());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_998, Test set default paragraph style\n,Proveri postavljanje podrazumevanog stila za paragraf.,"    public function testSetDefaultParagraphStyle()    {        $phpWord = new PhpWord();        $phpWord->setDefaultParagraphStyle(array());        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Paragraph', Style::getStyle('Normal'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWord_881, Create new instance\n\n Collections are created dynamically\n,Kreiraj novu instancu medija. Kolekcija se kreira dinamički.,"    public function __construct()    {        // Reset Media and styles        Media::resetElements();        Style::resetStyles();        // Collection        $collections = array('Bookmarks', 'Titles', 'Footnotes', 'Endnotes', 'Charts', 'Comments');        foreach ($collections as $collection) {            $class = 'PhpOffice\\PhpWord\\Collection\\' . $collection;            $this->collections[$collection] = new $class();        }        // Metadata        $metadata = array('DocInfo', 'Settings', 'Compatibility');        foreach ($metadata as $meta) {            $class = 'PhpOffice\\PhpWord\\Metadata\\' . $meta;            $this->metadata[$meta] = new $class();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_ProofStateTest_1054, Test class for PhpOffice\\\\PhpWord\\\\ComplexType\\\\ProofState\\n\\n @coversDefaultClass \\\\PhpOffice\\\\PhpWord\\\\ComplexType\\\\ProofState\\n,Klasa za testiranje PhpOffice.,"class ProofStateTest extends \PHPUnit\Framework\TestCase{    /**     * Tests the getters and setters     */    public function testGetSet()    {        $pState = new ProofState();        $pState->setGrammar(ProofState::CLEAN);        $pState->setSpelling(ProofState::DIRTY);        $this->assertEquals(ProofState::CLEAN, $pState->getGrammar());        $this->assertEquals(ProofState::DIRTY, $pState->getSpelling());    }    /**     * Test throws exception if wrong grammar proof state value given     *     * @expectedException \InvalidArgumentException     */    public function testWrongGrammar()    {        $pState = new ProofState();        $pState->setGrammar('Wrong');    }    /**     * Test throws exception if wrong spelling proof state value given     *     * @expectedException \InvalidArgumentException     */    public function testWrongSpelling()    {        $pState = new ProofState();        $pState->setSpelling('Wrong');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_ProofStateTest_1055, Tests the getters and setters\\n,Funkcija za testiranje getera i setera.,"    public function testGetSet()    {        $pState = new ProofState();        $pState->setGrammar(ProofState::CLEAN);        $pState->setSpelling(ProofState::DIRTY);        $this->assertEquals(ProofState::CLEAN, $pState->getGrammar());        $this->assertEquals(ProofState::DIRTY, $pState->getSpelling());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_ProofStateTest_1056, Test throws exception if wrong grammar proof state value given\n\n @expectedException \\InvalidArgumentException\n,Test će izbaciti izuzetak ukoliko je prosleđen pogrešan gramatički dokaz vrednosti stanja.,    public function testWrongGrammar()    {        $pState = new ProofState();        $pState->setGrammar('Wrong');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_SettingsTest_1012, Test set/get zip class\n,Testiraj seter i geter funkcije klase Zip,"    public function testSetGetZipClass()    {        $this->assertEquals(Settings::ZIPARCHIVE, Settings::getZipClass());        $this->assertFalse(Settings::setZipClass('foo'));        $this->assertEquals(Settings::ZIPARCHIVE, Settings::getZipClass());        $this->assertTrue(Settings::setZipClass(Settings::PCLZIP));        $this->assertEquals(Settings::getZipClass(), Settings::PCLZIP);        $this->assertFalse(Settings::setZipClass('foo'));        $this->assertEquals(Settings::getZipClass(), Settings::PCLZIP);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_SettingsTest_1013, Test set/get PDF renderer\\n,Testiraj seter i geter funkcije Pdf čitača.,"    public function testSetGetPdfRenderer()    {        $domPdfPath = realpath(PHPWORD_TESTS_BASE_DIR . '/../vendor/dompdf/dompdf');        $this->assertFalse(Settings::setPdfRenderer('FOO', 'dummy/path'));        $this->assertTrue(Settings::setPdfRenderer(Settings::PDF_RENDERER_DOMPDF, $domPdfPath));        $this->assertEquals(Settings::PDF_RENDERER_DOMPDF, Settings::getPdfRendererName());        $this->assertEquals($domPdfPath, Settings::getPdfRendererPath());        $this->assertFalse(Settings::setPdfRendererPath('dummy/path'));        $this->assertEquals($domPdfPath, Settings::getPdfRendererPath());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_SettingsTest_1018, Test set/get default font size\\n,Testiraj funkcije za postavljanje i dohvatanje podrazmevane veličine fonta.,"    public function testSetGetDefaultFontSize()    {        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, Settings::getDefaultFontSize());        $this->assertFalse(Settings::setDefaultFontSize(null));        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, Settings::getDefaultFontSize());        $this->assertTrue(Settings::setDefaultFontSize(12));        $this->assertEquals(12, Settings::getDefaultFontSize());        $this->assertFalse(Settings::setDefaultFontSize(null));        $this->assertEquals(12, Settings::getDefaultFontSize());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_SettingsTest_1019, Test set/get default paper\\n,Testiraj funkcije za postavljanje i dohvatanje podrazmevanog papira.,"    public function testSetGetDefaultPaper()    {        $dflt = Settings::DEFAULT_PAPER;        $chng = ($dflt === 'A4') ? 'Letter' : 'A4';        $doc = new PhpWord();        $this->assertEquals($dflt, Settings::getDefaultPaper());        $sec1 = $doc->addSection();        $this->assertEquals($dflt, $sec1->getStyle()->getPaperSize());        $this->assertFalse(Settings::setDefaultPaper(''));        $this->assertEquals($dflt, Settings::getDefaultPaper());        $this->assertTrue(Settings::setDefaultPaper($chng));        $this->assertEquals($chng, Settings::getDefaultPaper());        $sec2 = $doc->addSection();        $this->assertEquals($chng, $sec2->getStyle()->getPaperSize());        $sec3 = $doc->addSection(array('paperSize' => 'Legal'));        $this->assertEquals('Legal', $sec3->getStyle()->getPaperSize());        $this->assertFalse(Settings::setDefaultPaper(''));        $this->assertEquals($chng, Settings::getDefaultPaper());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_906, Identify the external library to use for rendering PDF files\\n\\n @param string $libraryName\\n @return bool\\n,Identifikuj spoljnu biblioteku koja će se koristiti za renderovanje pdf datoteka.,"    public static function setPdfRendererName($libraryName)    {        $pdfRenderers = array(self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_MPDF);        if (!in_array($libraryName, $pdfRenderers)) {            return false;        }        self::$pdfRendererName = $libraryName;        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_910, Set measurement unit\n\n @param string $value\n @return bool\n,Postavi jedinicu mere.,"    public static function setMeasurementUnit($value)    {        $units = array(self::UNIT_TWIP, self::UNIT_CM, self::UNIT_MM, self::UNIT_INCH,            self::UNIT_POINT, self::UNIT_PICA, );        if (!in_array($value, $units)) {            return false;        }        self::$measurementUnit = $value;        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_StyleTest_1023, Test default paragraph style\\n\\n @covers ::setDefaultParagraphStyle\\n @test\\n,Testiraj podrazumevani stil za paragraf.,"    public function testDefaultParagraphStyle()    {        $paragraph = array('alignment' => Jc::CENTER);        Style::setDefaultParagraphStyle($paragraph);        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Paragraph', Style::getStyle('Normal'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessorTest_1027, XSL stylesheet can be applied.\n\n @test\n @covers ::applyXslStyleSheet\n @depends testTemplateCanBeSavedInTemporaryLocation\n\n @param string $actualDocumentFqfn\n\n @throws \\Exception\n,Funkcija za testiranje da li se XSL tabela stilova može primeniti.,"    final public function testXslStyleSheetCanBeApplied($actualDocumentFqfn)    {        $expectedDocumentFqfn = __DIR__ . '/_files/documents/without_table_macros.docx';        $actualDocumentZip = new \ZipArchive();        $actualDocumentZip->open($actualDocumentFqfn);        $actualHeaderXml = $actualDocumentZip->getFromName('word/header1.xml');        $actualMainPartXml = $actualDocumentZip->getFromName('word/document.xml');        $actualFooterXml = $actualDocumentZip->getFromName('word/footer1.xml');        if (false === $actualDocumentZip->close()) {            throw new \Exception(""Could not close zip file \""{$actualDocumentFqfn}\""."");        }        $expectedDocumentZip = new \ZipArchive();        $expectedDocumentZip->open($expectedDocumentFqfn);        $expectedHeaderXml = $expectedDocumentZip->getFromName('word/header1.xml');        $expectedMainPartXml = $expectedDocumentZip->getFromName('word/document.xml');        $expectedFooterXml = $expectedDocumentZip->getFromName('word/footer1.xml');        if (false === $expectedDocumentZip->close()) {            throw new \Exception(""Could not close zip file \""{$expectedDocumentFqfn}\""."");        }        $this->assertXmlStringEqualsXmlString($expectedHeaderXml, $actualHeaderXml);        $this->assertXmlStringEqualsXmlString($expectedMainPartXml, $actualMainPartXml);        $this->assertXmlStringEqualsXmlString($expectedFooterXml, $actualFooterXml);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessorTest_1028, XSL stylesheet cannot be applied on failure in setting parameter value.\n\n @covers                   ::applyXslStyleSheet\n @expectedException        \\PhpOffice\\PhpWord\\Exception\\Exception\n @expectedExceptionMessage Could not set values for the given XSL style sheet parameters.\n @test\n,Testiraj da li će se primeniti XSL tabela stilova u slučaju greške u parametrima podešavanja.,"    final public function testXslStyleSheetCanNotBeAppliedOnFailureOfSettingParameterValue()    {        // Test is not needed for PHP 8.0, because internally validation throws TypeError exception.        if (\PHP_VERSION_ID >= 80000) {            $this->markTestSkipped('not needed for PHP 8.0');        }        $templateProcessor = new TemplateProcessor(__DIR__ . '/_files/templates/blank.docx');        $xslDomDocument = new \DOMDocument();        $xslDomDocument->load(__DIR__ . '/_files/xsl/passthrough.xsl');        /*         * We have to use error control below, because \XSLTProcessor::setParameter omits warning on failure.         * This warning fails the test.         */        @$templateProcessor->applyXslStyleSheet($xslDomDocument, array(1 => 'somevalue'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_943, Returns count of all variables in template.\n\n @return array\n,Vrati broj svih promenljivih u šablonu.,"    public function getVariableCount()    {        $variables = $this->getVariablesForPart($this->tempDocumentMainPart);        foreach ($this->tempDocumentHeaders as $headerXML) {            $variables = array_merge(                $variables,                $this->getVariablesForPart($headerXML)            );        }        foreach ($this->tempDocumentFooters as $footerXML) {            $variables = array_merge(                $variables,                $this->getVariablesForPart($footerXML)            );        }        return array_count_values($variables);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_946, Clones a table row and populates it's values from a two-dimensional array in a template document.\\n\\n @param string $search\\n @param array $values\\n,Dupliraj red tabele i popuni ga vrednostima dvomenzionalnog niza iz šablonskog dokumenta.,"    public function cloneRowAndSetValues($search, $values)    {        $this->cloneRow($search, count($values));        foreach ($values as $rowKey => $rowData) {            $rowNumber = $rowKey + 1;            foreach ($rowData as $macro => $replace) {                $this->setValue($macro . '#' . $rowNumber, $replace);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_947, Replace a block.\\n\\n @param string $blockname\\n @param string $replacement\\n,Zameni blok.,"    public function replaceBlock($blockname, $replacement)    {        $matches = array();        preg_match(            '/(<\?xml.*)(<w:p.*>\${' . $blockname . '}<\/w:.*?p>)(.*)(<w:p.*\${\/' . $blockname . '}<\/w:.*?p>)/is',            $this->tempDocumentMainPart,            $matches        );        if (isset($matches[3])) {            $this->tempDocumentMainPart = str_replace(                $matches[2] . $matches[3] . $matches[4],                $replacement,                $this->tempDocumentMainPart            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_948, Delete a block of text.\\n\\n @param string $blockname\\n,Izbriši tekstualni blok.,"    public function deleteBlock($blockname)    {        $this->replaceBlock($blockname, '');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_951, Saves the result document to the user defined file.\\n\\n @since 0.8.0\\n\\n @param string $fileName\\n,Sačuvaj rezultate dokumenta u korisnički definisanu datoteku.,"    public function saveAs($fileName)    {        $tempFileName = $this->save();        if (file_exists($fileName)) {            unlink($fileName);        }        /*         * Note: we do not use `rename` function here, because it loses file ownership data on Windows platform.         * As a result, user cannot open the file directly getting ""Access denied"" message.         *         * @see https://github.com/PHPOffice/PHPWord/issues/532         */        copy($tempFileName, $fileName);        unlink($tempFileName);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_953, Find and replace macros in the given XML section.\n\n @param mixed $search\n @param mixed $replace\n @param string $documentPartXML\n @param int $limit\n\n @return string\n,Pronađi i zameni makroe u datom xml odeljku sa vrednošću koja mu odgovara.,"    protected function setValueForPart($search, $replace, $documentPartXML, $limit)    {        // Note: we can't use the same function for both cases here, because of performance considerations.        if (self::MAXIMUM_REPLACEMENTS_DEFAULT === $limit) {            return str_replace($search, $replace, $documentPartXML);        }        $regExpEscaper = new RegExp();        return preg_replace($regExpEscaper->escape($search), $replace, $documentPartXML, $limit);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_954, Find all variables in $documentPartXML.\\n\\n @param string $documentPartXML\\n\\n @return string[]\\n,Pronađi sve promenljive u xml delu dokumenta.,"    protected function getVariablesForPart($documentPartXML)    {        $matches = array();        preg_match_all('/\$\{(.*?)}/i', $documentPartXML, $matches);        return $matches[1];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_961, Find the start position of the nearest table row before $offset.\n\n @param int $offset\n\n @throws \\PhpOffice\\PhpWord\\Exception\\Exception\n\n @return int\n,Pronađi najbližu početnu poziciju reda pre zadatog početnog pomeraja.,"    protected function findRowStart($offset)    {        $rowStart = strrpos($this->tempDocumentMainPart, '<w:tr ', ((strlen($this->tempDocumentMainPart) - $offset) * -1));        if (!$rowStart) {            $rowStart = strrpos($this->tempDocumentMainPart, '<w:tr>', ((strlen($this->tempDocumentMainPart) - $offset) * -1));        }        if (!$rowStart) {            throw new Exception('Can not find the start position of the row to clone.');        }        return $rowStart;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_962, Find the end position of the nearest table row after $offset.\\n\\n @param int $offset\\n\\n @return int\\n,Pronađi najbližu krajnju poziciju reda iza zadatog početnog pomeraja.,"    protected function findRowEnd($offset)    {        return strpos($this->tempDocumentMainPart, '</w:tr>', $offset) + 7;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_963, Replaces variable names in cloned\n rows/blocks with indexed names\n\n @param int $count\n @param string $xmlBlock\n\n @return string\n,Zameni naziv promenljive u dupliranom redu ili bloku sa indeksiranim imenom.,"    protected function indexClonedVariables($count, $xmlBlock)    {        $results = array();        for ($i = 1; $i <= $count; $i++) {            $results[] = preg_replace('/\$\{([^:]*?)(:.*?)?\}/', '\${\1#' . $i . '\2}', $xmlBlock);        }        return $results;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_964," Raplaces variables with values from array, array keys are the variable names\n\n @param array $variableReplacements\n @param string $xmlBlock\n\n @return string[]\n","Zameni promenljive sa nizom, gde su ključevi niza imena promenljivih. ","    protected function replaceClonedVariables($variableReplacements, $xmlBlock)    {        $results = array();        foreach ($variableReplacements as $replacementArray) {            $localXmlBlock = $xmlBlock;            foreach ($replacementArray as $search => $replacement) {                $localXmlBlock = $this->setValueForPart(self::ensureMacroCompleted($search), $replacement, $localXmlBlock, self::MAXIMUM_REPLACEMENTS_DEFAULT);            }            $results[] = $localXmlBlock;        }        return $results;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_GlassDataset_894, Classes: 6\n Samples per class:\n      70 float processed building windows\n      17 float processed vehicle windows\n      76 non-float processed building windows\n      13 containers\n      9 tableware\n      29 headlamps\n Samples total: 214\n Features per sample: 9.\n,,"class GlassDataset extends CsvDataset{    public function __construct()    {        $filepath = __DIR__.'/../../../data/glass.csv';        parent::__construct($filepath, 9, true);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_965, Find the start position of the nearest XML block start before $offset\\n\\n @param int $offset    Search position\\n @param string  $blockType XML Block tag\\n @return int -1 if block start not found\\n,Pronađite početnu poziciju najbližeg xml bloka koji počinje pre zadatog početnog pomeraja.,"    protected function findXmlBlockStart($offset, $blockType)    {        $reverseOffset = (strlen($this->tempDocumentMainPart) - $offset) * -1;        // first try XML tag with attributes        $blockStart = strrpos($this->tempDocumentMainPart, '<' . $blockType . ' ', $reverseOffset);        // if not found, or if found but contains the XML tag without attribute        if (false === $blockStart || strrpos($this->getSlice($blockStart, $offset), '<' . $blockType . '>')) {            // also try XML tag without attributes            $blockStart = strrpos($this->tempDocumentMainPart, '<' . $blockType . '>', $reverseOffset);        }        return ($blockStart === false) ? -1 : $blockStart;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_769," Add access.\\n\\n @param int $idProfile Profile ID\\n @param int $idRole Role ID\\n\\n @return string Whether access has been successfully granted (""ok"", ""error"")\\n",Dodaj prava pristupa.,"    public function addAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_770," Remove access.\\n\\n @param int $idProfile Profile ID\\n @param int $idRole Role ID\\n\\n @return string Whether access has been successfully removed (""ok"", ""error"")\\n",Ukloni prava pristupa.,"    public function removeAccess($idProfile, $idRole)    {        $sql = '            DELETE FROM `' . _DB_PREFIX_ . 'access`            WHERE `id_profile` = ""' . (int) $idProfile . '""            AND `id_authorization_role` = ""' . (int) $idRole . '""        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_771," Add module access.\\\\\\\\n\\\\\\\\n @param int $idProfile Profile ID\\\\\\\\n @param int $idRole Role ID\\\\\\\\n\\\\\\\\n @return string Whether module access has been successfully granted (""ok"", ""error"")\\\\\\\\n",Dodaj prava pristupa za modul.,"    public function addModuleAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'module_access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_773," Update (legacy) Module access.\\\\\\\\n\\\\\\\\n @param int $idProfile Profile ID\\\\\\\\n @param int $idModule Module ID\\\\\\\\n @param string $lgcAuth Legacy authorization\\\\\\\\n @param int $enabled Whether module access should be granted\\\\\\\\n\\\\\\\\n @return string Whether module access has been succesfully changed (""ok"", ""error"")\\\\\\\\n",Ažuriraj nasleđena prava pristupa modula.,"    public function updateLgcModuleAccess($idProfile, $idModule, $lgcAuth, $enabled)    {        $idProfile = (int) $idProfile;        $idModule = (int) $idModule;        if ($idModule == -1) {            $slug = 'ROLE_MOD_MODULE_%_';        } else {            $slug = self::findSlugByIdModule($idModule);        }        $whereClauses = [];        foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {            $slugLike = Db::getInstance()->escape($slug . $auth);            $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';        }        $roles = Db::getInstance()->executeS('            SELECT `id_authorization_role`            FROM `' . _DB_PREFIX_ . 'authorization_role` t            WHERE ' . implode(' OR ', $whereClauses) . '        ');        $res = [];        foreach ($roles as $role) {            if ($enabled) {                $res[] = $this->addModuleAccess($idProfile, $role['id_authorization_role']);            } else {                $res[] = $this->removeModuleAccess($idProfile, $role['id_authorization_role']);            }        }        return in_array('error', $res) ? 'error' : 'ok';    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressChecksumCore_789, Class AddressChecksumCore.\n,Glavna klasa za proračun kontrolne sume adrese.,"class AddressChecksumCore implements ChecksumInterface{    const SEPARATOR = '_';    /**     * Generate a checksum.     *     * @param Address $address     *     * @return string SHA1 checksum for the Address     */    public function generateChecksum($address)    {        if (!$address->id) {            return sha1('No address set');        }        $uniqId = '';        $fields = $address->getFields();        foreach ($fields as $name => $value) {            $uniqId .= $value . self::SEPARATOR;        }        $uniqId = rtrim($uniqId, self::SEPARATOR);        return sha1($uniqId);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_791, Class AddressFormatCore.\\\\\\\\n,Glavna klasa za formatiranje adresa.,"class AddressFormatCore extends ObjectModel{    const FORMAT_NEW_LINE = ""\n"";    /** @var int Address format */    public $id_address_format;    /** @var int Country ID */    public $id_country;    /** @var string Format */    public $format;    protected $_errorFormatList = [];    /**     * @see ObjectModel::$definition     */    public static $definition = [        'table' => 'address_format',        'primary' => 'id_country',        'fields' => [            'format' => ['type' => self::TYPE_HTML, 'validate' => 'isGenericName', 'required' => true],            'id_country' => ['type' => self::TYPE_INT],        ],    ];    /** @var array Default required form fields list */    public static $requireFormFieldsList = [        'firstname',        'lastname',        'address1',        'city',        'Country:name',    ];    /** @var array Default forbidden property list */    public static $forbiddenPropertyList = [        'deleted',        'date_add',        'alias',        'secure_key',        'note',        'newsletter',        'ip_registration_newsletter',        'newsletter_date_add',        'optin',        'passwd',        'last_passwd_gen',        'active',        'is_guest',        'date_upd',        'country',        'years',        'days',        'months',        'description',        'meta_description',        'short_description',        'link_rewrite',        'meta_title',        'meta_keywords',        'display_tax_label',        'need_zip_code',        'contains_states',        'call_prefixes',        'show_public_prices',        'max_payment',        'max_payment_days',        'geoloc_postcode',        'logged',        'account_number',        'groupBox',        'ape',        'max_payment',        'outstanding_allow_amount',        'call_prefix',        'definition',        'debug_list',    ];    /** @var array Default formbidden class list */    public static $forbiddenClassList = [        'Manufacturer',        'Supplier',    ];    const _CLEANING_REGEX_ = '#([^\w:_]+)#i';    /**     * Check if the the association of the field name and a class name     * is valid.     *     * @param string $className The name class     * @param string $fieldName The property name     * @param bool $isIdField Do we have to allow a property name to be started with 'id_'     *     * @return bool Association of the field and class name is valid     */    protected function _checkValidateClassField($className, $fieldName, $isIdField)    {        $isValid = false;        if (!class_exists($className)) {            $this->_errorFormatList[] = $this->trans('This class name does not exist.', [], 'Admin.Notifications.Error') .            ': ' . $className;        } else {            $obj = new $className();            $reflect = new ReflectionObject($obj);            // Check if the property is accessible            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                $propertyName = $property->getName();                if (($propertyName == $fieldName) && ($isIdField ||                        (!preg_match('/\bid\b|id_\w+|\bid[A-Z]\w+/', $propertyName)))) {                    $isValid = true;                }            }            if (!$isValid) {                $this->_errorFormatList[] = $this->trans('This property does not exist in the class or is forbidden.', [], 'Admin.Notifications.Error') .                ': ' . $className . ': ' . $fieldName;            }            unset(                $obj,                $reflect            );        }        return $isValid;    }    /**     * Verify the existence of a field name and check the availability     * of an association between a field name and a class (ClassName:fieldName)     * if the separator is overview.     *     * @param string $patternName The composition of the class and field name     * @param string $fieldsValidate The list of available field for the Address class     * @todo: Why is $fieldsValidate unused?     */    protected function _checkLiableAssociation($patternName, $fieldsValidate)    {        $patternName = trim($patternName);        if ($associationName = explode(':', $patternName)) {            $totalNameUsed = count($associationName);            if ($totalNameUsed > 2) {                $this->_errorFormatList[] = $this->trans('This association has too many elements.', [], 'Admin.Notifications.Error');            } elseif ($totalNameUsed == 1) {                $associationName[0] = strtolower($associationName[0]);                if (in_array($associationName[0], self::$forbiddenPropertyList) ||                    !$this->_checkValidateClassField('Address', $associationName[0], false)) {                    $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                    $associationName[0];                }            } elseif ($totalNameUsed == 2) {                if (empty($associationName[0]) || empty($associationName[1])) {                    $this->_errorFormatList[] = $this->trans('Syntax error with this pattern.', [], 'Admin.Notifications.Error') . ': ' . $patternName;                } else {                    $associationName[0] = ucfirst($associationName[0]);                    $associationName[1] = strtolower($associationName[1]);                    if (in_array($associationName[0], self::$forbiddenClassList)) {                        $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                        $associationName[0];                    } else {                        // Check if the id field name exist in the Address class                        // Don't check this attribute on Address (no sense)                        if ($associationName[0] != 'Address') {                            $this->_checkValidateClassField('Address', 'id_' . strtolower($associationName[0]), true);                        }                        // Check if the field name exist in the class write by the user                        $this->_checkValidateClassField($associationName[0], $associationName[1], false);                    }                }            }        }    }    /**     * Check if the set fields are valid.     */    public function checkFormatFields()    {        $this->_errorFormatList = [];        $fieldsValidate = Address::getFieldsValidate();        $usedKeyList = [];        $multipleLineFields = explode(self::FORMAT_NEW_LINE, $this->format);        if ($multipleLineFields && is_array($multipleLineFields)) {            foreach ($multipleLineFields as $lineField) {                if (($patternsName = preg_split(self::_CLEANING_REGEX_, $lineField, -1, PREG_SPLIT_NO_EMPTY))) {                    if (is_array($patternsName)) {                        foreach ($patternsName as $patternName) {                            if (!in_array($patternName, $usedKeyList)) {                                $this->_checkLiableAssociation($patternName, $fieldsValidate);                                $usedKeyList[] = $patternName;                            } else {                                $this->_errorFormatList[] = $this->trans('This key has already been used.', [], 'Admin.Notifications.Error') .                                    ': ' . $patternName;                            }                        }                    }                }            }            $this->checkRequiredFields($usedKeyList);        }        return (count($this->_errorFormatList)) ? false : true;    }    /**     * Checks that all required fields exist in a given fields list.     * Fills _errorFormatList array in case of absence of a required field.     *     * @param array $fieldList     */    protected function checkRequiredFields($fieldList)    {        foreach (self::getFieldsRequired() as $requiredField) {            if (!in_array($requiredField, $fieldList)) {                $this->_errorFormatList[] = $this->trans(                    'The %s field (in tab %s) is required.',                    [$requiredField, $this->getFieldTabName($requiredField)],                    'Admin.Notifications.Error');            }        }    }    /**     * Given a field name, get the name of the tab in which the field name can be found.     * For ex: Country:name => the tab is 'Country'.     * There should be only one separator in the string, otherwise throw an exception.     *     * @param string $field     *     * @return bool|string     *     * @throws AddressException     */    private function getFieldTabName($field)    {        if (strpos($field, ':') === false) {            // When there is no ':' separator, the field is in the Address tab            return 'Address';        }        $fieldTab = explode(':', $field);        if (count($fieldTab) === 2) {            // The part preceding the ':' separator is the name of the tab in which there is the required field            return $fieldTab[0];        }        throw new AddressException('Address format field is not valid');    }    /**     * Returns the error list.     */    public function getErrorList()    {        return $this->_errorFormatList;    }    /**     * Set the layout key with the liable value     * example : (firstname) => 'Presta' will result (Presta)     *         : (firstname-lastname) => 'Presta' and 'Shop' result '(Presta-Shop)'.     */    protected static function _setOriginalDisplayFormat(&$formattedValueList, $currentLine, $currentKeyList)    {        if ($currentKeyList && is_array($currentKeyList)) {            if ($originalFormattedPatternList = explode(' ', $currentLine)) {                // Foreach the available pattern                foreach ($originalFormattedPatternList as $patternNum => $pattern) {                    // Var allows to modify the good formatted key value when multiple key exist into the same pattern                    $mainFormattedKey = '';                    // Multiple key can be found in the same pattern                    foreach ($currentKeyList as $key) {                        // Check if we need to use an older modified pattern if a key has already be matched before                        $replacedValue = empty($mainFormattedKey) ? $pattern : $formattedValueList[$mainFormattedKey];                        $chars = $start = $end = str_replace($key, '', $replacedValue);                        if (preg_match(self::_CLEANING_REGEX_, $chars)) {                            if (Tools::substr($replacedValue, 0, Tools::strlen($chars)) == $chars) {                                $end = '';                            } else {                                $start = '';                            }                            if ($chars) {                                $replacedValue = str_replace($chars, '', $replacedValue);                            }                        }                        if ($formattedValue = preg_replace('/^' . $key . '$/', $formattedValueList[$key], $replacedValue, -1, $count)) {                            if ($count) {                                // Allow to check multiple key in the same pattern,                                if (empty($mainFormattedKey)) {                                    $mainFormattedKey = $key;                                }                                // Set the pattern value to an empty string if an older key has already been matched before                                if ($mainFormattedKey != $key) {                                    $formattedValueList[$key] = '';                                }                                // Store the new pattern value                                $formattedValueList[$mainFormattedKey] = $start . $formattedValue . $end;                                unset($originalFormattedPatternList[$patternNum]);                            }                        }                    }                }            }        }    }    /**     * Cleaned the layout set by the user.     */    public static function cleanOrderedAddress(&$orderedAddressField)    {        foreach ($orderedAddressField as &$line) {            $cleanedLine = '';            if (($keyList = preg_split(self::_CLEANING_REGEX_, $line, -1, PREG_SPLIT_NO_EMPTY))) {                foreach ($keyList as $key) {                    $cleanedLine .= $key . ' ';                }                $cleanedLine = trim($cleanedLine);                $line = $cleanedLine;            }        }    }    /**     * Returns the formatted fields with associated values.     *     * @param Address $address Address object     * @param AddressFormat $addressFormat The format     *     * @return array     */    public static function getFormattedAddressFieldsValues($address, $addressFormat, $id_lang = null)    {        if (!$id_lang) {            $id_lang = Context::getContext()->language->id;        }        $tab = [];        $temporyObject = [];        // Check if $address exist and it's an instanciate object of Address        if ($address && ($address instanceof Address)) {            foreach ($addressFormat as $line) {                if (($keyList = preg_split(self::_CLEANING_REGEX_, $line, -1, PREG_SPLIT_NO_EMPTY)) && is_array($keyList)) {                    foreach ($keyList as $pattern) {                        if ($associateName = explode(':', $pattern)) {                            $totalName = count($associateName);                            if ($totalName == 1 && isset($address->{$associateName[0]})) {                                $tab[$associateName[0]] = $address->{$associateName[0]};                            } else {                                $tab[$pattern] = '';                                // Check if the property exist in both classes                                if (($totalName == 2) && class_exists($associateName[0]) &&                                    property_exists($associateName[0], $associateName[1]) &&                                    property_exists($address, 'id_' . strtolower($associateName[0]))) {                                    $idFieldName = 'id_' . strtolower($associateName[0]);                                    if (!isset($temporyObject[$associateName[0]])) {                                        $temporyObject[$associateName[0]] = new $associateName[0]($address->{$idFieldName});                                    }                                    if ($temporyObject[$associateName[0]]) {                                        $tab[$pattern] = (is_array($temporyObject[$associateName[0]]->{$associateName[1]})) ?                                            ((isset($temporyObject[$associateName[0]]->{$associateName[1]}[$id_lang])) ?                                            $temporyObject[$associateName[0]]->{$associateName[1]}[$id_lang] : '') :                                            $temporyObject[$associateName[0]]->{$associateName[1]};                                    }                                }                            }                        }                    }                    AddressFormat::_setOriginalDisplayFormat($tab, $line, $keyList);                }            }        }        AddressFormat::cleanOrderedAddress($addressFormat);        return $tab;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_792, Check if the the association of the field name and a class name\\\\n is valid.\\\\n\\\\n @param string $className The name class\\\\n @param string $fieldName The property name\\\\n @param bool $isIdField Do we have to allow a property name to be started with 'id_'\\\\n\\\\n @return bool Association of the field and class name is valid\\\\n,Proveri da li je udrženje imena polja i klase validna,"    protected function _checkValidateClassField($className, $fieldName, $isIdField)    {        $isValid = false;        if (!class_exists($className)) {            $this->_errorFormatList[] = $this->trans('This class name does not exist.', [], 'Admin.Notifications.Error') .            ': ' . $className;        } else {            $obj = new $className();            $reflect = new ReflectionObject($obj);            // Check if the property is accessible            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                $propertyName = $property->getName();                if (($propertyName == $fieldName) && ($isIdField ||                        (!preg_match('/\bid\b|id_\w+|\bid[A-Z]\w+/', $propertyName)))) {                    $isValid = true;                }            }            if (!$isValid) {                $this->_errorFormatList[] = $this->trans('This property does not exist in the class or is forbidden.', [], 'Admin.Notifications.Error') .                ': ' . $className . ': ' . $fieldName;            }            unset(                $obj,                $reflect            );        }        return $isValid;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_793, Verify the existence of a field name and check the availability\n of an association between a field name and a class (ClassName:fieldName)\n if the separator is overview.\n\n @param string $patternName The composition of the class and field name\n @param string $fieldsValidate The list of available field for the Address class\n @todo: Why is $fieldsValidate unused?\n,"Verifikuj da naziva polja postoji i proveri njegovu dostupnost za združivanje sa imenom klase, ukoliko je separator pregledan.","    protected function _checkLiableAssociation($patternName, $fieldsValidate)    {        $patternName = trim($patternName);        if ($associationName = explode(':', $patternName)) {            $totalNameUsed = count($associationName);            if ($totalNameUsed > 2) {                $this->_errorFormatList[] = $this->trans('This association has too many elements.', [], 'Admin.Notifications.Error');            } elseif ($totalNameUsed == 1) {                $associationName[0] = strtolower($associationName[0]);                if (in_array($associationName[0], self::$forbiddenPropertyList) ||                    !$this->_checkValidateClassField('Address', $associationName[0], false)) {                    $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                    $associationName[0];                }            } elseif ($totalNameUsed == 2) {                if (empty($associationName[0]) || empty($associationName[1])) {                    $this->_errorFormatList[] = $this->trans('Syntax error with this pattern.', [], 'Admin.Notifications.Error') . ': ' . $patternName;                } else {                    $associationName[0] = ucfirst($associationName[0]);                    $associationName[1] = strtolower($associationName[1]);                    if (in_array($associationName[0], self::$forbiddenClassList)) {                        $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                        $associationName[0];                    } else {                        // Check if the id field name exist in the Address class                        // Don't check this attribute on Address (no sense)                        if ($associationName[0] != 'Address') {                            $this->_checkValidateClassField('Address', 'id_' . strtolower($associationName[0]), true);                        }                        // Check if the field name exist in the class write by the user                        $this->_checkValidateClassField($associationName[0], $associationName[1], false);                    }                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_794, Check if the set fields are valid.\\\\\\\\n,Proveri da li su postavljena polja validna.,"    public function checkFormatFields()    {        $this->_errorFormatList = [];        $fieldsValidate = Address::getFieldsValidate();        $usedKeyList = [];        $multipleLineFields = explode(self::FORMAT_NEW_LINE, $this->format);        if ($multipleLineFields && is_array($multipleLineFields)) {            foreach ($multipleLineFields as $lineField) {                if (($patternsName = preg_split(self::_CLEANING_REGEX_, $lineField, -1, PREG_SPLIT_NO_EMPTY))) {                    if (is_array($patternsName)) {                        foreach ($patternsName as $patternName) {                            if (!in_array($patternName, $usedKeyList)) {                                $this->_checkLiableAssociation($patternName, $fieldsValidate);                                $usedKeyList[] = $patternName;                            } else {                                $this->_errorFormatList[] = $this->trans('This key has already been used.', [], 'Admin.Notifications.Error') .                                    ': ' . $patternName;                            }                        }                    }                }            }            $this->checkRequiredFields($usedKeyList);        }        return (count($this->_errorFormatList)) ? false : true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_796," Given a field name, get the name of the tab in which the field name can be found.\n For ex: Country:name => the tab is 'Country'.\n There should be only one separator in the string, otherwise throw an exception.\n\n @param string $field\n\n @return bool|string\n\n @throws AddressException\n",Za dato ime polja vrati naziv tab sekcije u kojem se pojavljuje.,"    private function getFieldTabName($field)    {        if (strpos($field, ':') === false) {            // When there is no ':' separator, the field is in the Address tab            return 'Address';        }        $fieldTab = explode(':', $field);        if (count($fieldTab) === 2) {            // The part preceding the ':' separator is the name of the tab in which there is the required field            return $fieldTab[0];        }        throw new AddressException('Address format field is not valid');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_611," Set the access token used for requests.\\n\\n Note that at the time requests are sent, tokens are cached. A token will be\\n cached for each combination of service and authentication scopes. If a\\n cache pool is not provided, creating a new instance of the client will\\n allow modification of access tokens. If a persistent cache pool is\\n provided, in order to change the access token, you must clear the cached\\n token by calling `$client->getCache()->clear()`. (Use caution in this case,\\n as calling `clear()` will remove all cache items, including any items not\\n related to Google API PHP Client.)\\n\\n @param string|array $token\\n @throws InvalidArgumentException\\n",Glavna logika za proveru token id-ja je u AuthTest klasi. Ovo je samo opšta provera kako bismo bili sifurni da verifikujemo važeći id token ukoliko postoji.,"  public function setAccessToken($token)  {    if (is_string($token)) {      if ($json = json_decode($token, true)) {        $token = $json;      } else {        // assume $token is just the token string        $token = array(          'access_token' => $token,        );      }    }    if ($token == null) {      throw new InvalidArgumentException('invalid json token');    }    if (!isset($token['access_token'])) {      throw new InvalidArgumentException(""Invalid token format"");    }    $this->token = $token;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_VerifyTest_693, Most of the logic for ID token validation is in AuthTest -\n this is just a general check to ensure we verify a valid\n id token if one exists.\n,,"  public function testValidateIdToken()  {    $this->checkToken();    $jwt = $this->getJwtService();    $client = $this->getClient();    $http = $client->getHttpClient();    $token = $client->getAccessToken();    if ($client->isAccessTokenExpired()) {      $token = $client->fetchAccessTokenWithRefreshToken();    }    $segments = explode('.', $token['id_token']);    $this->assertCount(3, $segments);    // Extract the client ID in this case as it wont be set on the test client.    $data = json_decode($jwt->urlSafeB64Decode($segments[1]));    $verify = new Google_AccessToken_Verify($http);    $payload = $verify->verifyIdToken($token['id_token'], $data->aud);    $this->assertArrayHasKey('sub', $payload);    $this->assertGreaterThan(0, strlen($payload['sub']));    // TODO: Need to be smart about testing/disabling the    // caching for this test to make sense. Not sure how to do that    // at the moment.    $client = $this->getClient();    $http = $client->getHttpClient();    $data = json_decode($jwt->urlSafeB64Decode($segments[1]));    $verify = new Google_AccessToken_Verify($http);    $payload = $verify->verifyIdToken($token['id_token'], $data->aud);    $this->assertArrayHasKey('sub', $payload);    $this->assertGreaterThan(0, strlen($payload['sub']));  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_KernelDensityEstimation_3533, Default bandwidth for when one is not provided.\n Uses the normal distribution approximation bandwidth estimator.\n https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\n\n             â…•\n      / 4Ïƒâµ \\\n h = |  ---  |\n      \\ 3n  /\n\n\n @return float\n\n @throws Exception\\OutOfBoundsException\n,Dohvati podrazumevanu širinu opsega kada ona nije navedena. Procenjivač širine opsega koristi normalnu raspodelu kao aproksimaciju.,    private function getDefaultBandwidth(): float    {        $ï¼”Ïƒâµ = 4 * Descriptive::standardDeviation($this->data) ** 5;        $ï¼“n  = 3 * $this->n;        $â…•    = 0.2;        return ($ï¼”Ïƒâµ / $ï¼“n) ** $â…•;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3167, Cumulative distribution function\\n Probability of being below X.\\n Area under the normal distribution from -âˆž to X.\\n             _                  _\\n          1 |         / x - Î¼ \\\\  |\\n cdf(x) = - | 1 + erf|  ----- |  |\\n          2 |_        \\\\  Ïƒâˆš2  / _|\\n\\n @param float $x upper bound\\n\\n @return float cdf(x) below\\n,Kulmutivna funckija raspodele. Verovatnoća biti ispod vrednosti X. Vraća površinu ispod normalne raspodele od minus beskonačno do X.,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        return 1 / 2 * ( 1 + Special::erf(($x - $Î¼) / ($Ïƒ * \sqrt(2))) );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3164, Normal distribution\\n https://en.wikipedia.org/wiki/Normal_distribution\\n,Normalna raspodela,"class Normal extends Continuous{    /**     * Distribution parameter bounds limits     * Î¼ âˆˆ (-âˆž,âˆž)     * Ïƒ âˆˆ (0,âˆž)     * @var array     */    public const PARAMETER_LIMITS = [        'Î¼' => '(-âˆž,âˆž)',        'Ïƒ' => '(0,âˆž)',    ];    /**     * Distribution support bounds limits     * x âˆˆ (-âˆž,âˆž)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '(-âˆž,âˆž)',    ];    /** @var float Mean Parameter */    protected $Î¼;    /** @var float Standard Deviation Parameter */    protected $Ïƒ;    /**     * Normal constructor     *     * @param float $Î¼     * @param float $Ïƒ     */    public function __construct(float $Î¼, float $Ïƒ)    {        parent::__construct($Î¼, $Ïƒ);    }    /**     * Probability density function     *     *              1     * f(x|Î¼,Ïƒ) = ----- â„¯^âˆ’âŸ®x âˆ’ Î¼âŸ¯Â²âˆ•2ÏƒÂ²     *            ÏƒâˆšâŸ®2Ï€âŸ¯     *     * @param float $x random variable     *     * @return float f(x|Î¼,Ïƒ)     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼     = $this->Î¼;        $Ïƒ     = $this->Ïƒ;        $Ï€     = \M_PI;        $ÏƒâˆšâŸ®2Ï€âŸ¯ = $Ïƒ * \sqrt(2 * $Ï€);        $âŸ®xÂ âˆ’Â Î¼âŸ¯Â²âˆ•2ÏƒÂ² = \pow(($x - $Î¼), 2) / (2 * $Ïƒ ** 2);        $â„¯ï¼¾âˆ’âŸ®xÂ âˆ’Â Î¼âŸ¯Â²âˆ•2ÏƒÂ² = \exp(-$âŸ®xÂ âˆ’Â Î¼âŸ¯Â²âˆ•2ÏƒÂ²);        return ( 1 / $ÏƒâˆšâŸ®2Ï€âŸ¯ ) * $â„¯ï¼¾âˆ’âŸ®xÂ âˆ’Â Î¼âŸ¯Â²âˆ•2ÏƒÂ²;    }    /**     * Cumulative distribution function     * Probability of being below X.     * Area under the normal distribution from -âˆž to X.     *             _                  _     *          1 |         / x - Î¼ \  |     * cdf(x) = - | 1 + erf|  ----- |  |     *          2 |_        \  Ïƒâˆš2  / _|     *     * @param float $x upper bound     *     * @return float cdf(x) below     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        return 1 / 2 * ( 1 + Special::erf(($x - $Î¼) / ($Ïƒ * \sqrt(2))) );    }    /**     * Inverse CDF (quantile)     *     * @param float $p     *     * @return float     */    public function inverse(float $p): float    {        if ($p == 0) {            return -\INF;        }        if ($p == 1) {            return \INF;        }        return parent::inverse($p);    }    /**     * Mean of the distribution     *     * Î¼ = Î¼     *     * @return float     */    public function mean(): float    {        return $this->Î¼;    }    /**     * Median of the distribution     *     * median = Î¼     *     * @return float     */    public function median(): float    {        return $this->Î¼;    }    /**     * Mode of the distribution     *     * mode = Î¼     *     * @return float     */    public function mode(): float    {        return $this->Î¼;    }    /**     * Variance of the distribution     *     * var[X] = ÏƒÂ²     *     * @return float     */    public function variance(): float    {        return $this->Ïƒ ** 2;    }    /**     * Random number - Boxâ€“Muller transform     *     * https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform     */    public function rand()    {        $rand1 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        $rand2 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        return \sqrt(-2 * \log($rand1)) * \cos(2 * pi() * $rand2) * $this->Ïƒ + $this->Î¼;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_StandardNormal_3289," Standard normal tables for Z and related methods\n\n A standard normal table, also called the unit normal table or Z table,\n is a mathematical table for the values of Î¦, which are the values of the\n cumulative distribution function of the normal distribution.\n\n It is used to find the probability that a statistic is observed below,\n above, or between values on the standard normal distribution, and by extension,\n any normal distribution.\n\n Since probability tables cannot be printed for every normal distribution,\n as there are an infinite variety of normal distributions,\n it is common practice to convert a normal to a standard normal\n and then use the standard normal table to find probabilities.\n\n https://en.wikipedia.org/wiki/Standard_normal_table\n\n This table is provided only for completeness. It is common for statistics\n textbooks to include this table, so this library does as well. It is better\n to use the standard normal distribution CDF function when a Z score is required.\n","Budući da se tabele verovatnoće ne mogu ispisati za svaku normalnu raspodelu, jer postoji beskrajna raznolikost normalnih raspodela, uobičajna je praksa da se normala pretvori u standardnu normalu, a zatim koristi standardna normalna tabela za pronalaženje verovatnoća. Ova tabela je data samo radi potpunosti. Uobičajno je da udžbenici statistike uključuju ovu tabelu pa to radi i ova biblioteka. Bolje je koristiti standardnu CDF funkciju normalne raspodele kada je Z rezultat potreban.","class StandardNormal{    /**     * Z scores table - cumulative from mean     * Contains positive and negative Z scores.     * Negative z-score - value is to the left of the mean.     * Positive z-score - value is to the right of the mean.     * @var array     */    public const Z_SCORES = [    '-3.4' => [ 9 => 0.0002, 8 => 0.0003, 7 => 0.0003, 6 => 0.0003, 5 => 0.0003, 4 => 0.0003, 3 => 0.0003, 2 => 0.0003, 1 => 0.0003, 0 => 0.0003 ],    '-3.3' => [ 9 => 0.0003, 8 => 0.0004, 7 => 0.0004, 6 => 0.0004, 5 => 0.0004, 4 => 0.0004, 3 => 0.0004, 2 => 0.0005, 1 => 0.0005, 0 => 0.0005 ],    '-3.2' => [ 9 => 0.0005, 8 => 0.0005, 7 => 0.0005, 6 => 0.0006, 5 => 0.0006, 4 => 0.0006, 3 => 0.0006, 2 => 0.0006, 1 => 0.0007, 0 => 0.0007 ],    '-3.1' => [ 9 => 0.0007, 8 => 0.0007, 7 => 0.0008, 6 => 0.0008, 5 => 0.0008, 4 => 0.0008, 3 => 0.0009, 2 => 0.0009, 1 => 0.0009, 0 => 0.0010 ],    '-3.0' => [ 9 => 0.0010, 8 => 0.0010, 7 => 0.0011, 6 => 0.0011, 5 => 0.0011, 4 => 0.0012, 3 => 0.0012, 2 => 0.0013, 1 => 0.0013, 0 => 0.0013 ],    '-2.9' => [ 9 => 0.0014, 8 => 0.0014, 7 => 0.0015, 6 => 0.0015, 5 => 0.0016, 4 => 0.0016, 3 => 0.0017, 2 => 0.0018, 1 => 0.0018, 0 => 0.0019 ],    '-2.8' => [ 9 => 0.0019, 8 => 0.0020, 7 => 0.0021, 6 => 0.0021, 5 => 0.0022, 4 => 0.0023, 3 => 0.0023, 2 => 0.0024, 1 => 0.0025, 0 => 0.0026 ],    '-2.7' => [ 9 => 0.0026, 8 => 0.0027, 7 => 0.0028, 6 => 0.0029, 5 => 0.0030, 4 => 0.0031, 3 => 0.0032, 2 => 0.0033, 1 => 0.0034, 0 => 0.0035 ],    '-2.6' => [ 9 => 0.0036, 8 => 0.0037, 7 => 0.0038, 6 => 0.0039, 5 => 0.0040, 4 => 0.0041, 3 => 0.0043, 2 => 0.0044, 1 => 0.0045, 0 => 0.0047 ],    '-2.5' => [ 9 => 0.0048, 8 => 0.0049, 7 => 0.0051, 6 => 0.0052, 5 => 0.0054, 4 => 0.0055, 3 => 0.0057, 2 => 0.0059, 1 => 0.0060, 0 => 0.0062 ],    '-2.4' => [ 9 => 0.0064, 8 => 0.0066, 7 => 0.0068, 6 => 0.0069, 5 => 0.0071, 4 => 0.0073, 3 => 0.0075, 2 => 0.0078, 1 => 0.0080, 0 => 0.0082 ],    '-2.3' => [ 9 => 0.0084, 8 => 0.0087, 7 => 0.0089, 6 => 0.0091, 5 => 0.0094, 4 => 0.0096, 3 => 0.0099, 2 => 0.0102, 1 => 0.0104, 0 => 0.0107 ],    '-2.2' => [ 9 => 0.0110, 8 => 0.0113, 7 => 0.0116, 6 => 0.0119, 5 => 0.0122, 4 => 0.0125, 3 => 0.0129, 2 => 0.0132, 1 => 0.0136, 0 => 0.0139 ],    '-2.1' => [ 9 => 0.0143, 8 => 0.0146, 7 => 0.0150, 6 => 0.0154, 5 => 0.0158, 4 => 0.0162, 3 => 0.0166, 2 => 0.0170, 1 => 0.0174, 0 => 0.0179 ],    '-2.0' => [ 9 => 0.0183, 8 => 0.0188, 7 => 0.0192, 6 => 0.0197, 5 => 0.0202, 4 => 0.0207, 3 => 0.0212, 2 => 0.0217, 1 => 0.0222, 0 => 0.0228 ],    '-1.9' => [ 9 => 0.0233, 8 => 0.0239, 7 => 0.0244, 6 => 0.0250, 5 => 0.0256, 4 => 0.0262, 3 => 0.0268, 2 => 0.0274, 1 => 0.0281, 0 => 0.0287 ],    '-1.8' => [ 9 => 0.0294, 8 => 0.0301, 7 => 0.0307, 6 => 0.0314, 5 => 0.0322, 4 => 0.0329, 3 => 0.0336, 2 => 0.0344, 1 => 0.0351, 0 => 0.0359 ],    '-1.7' => [ 9 => 0.0367, 8 => 0.0375, 7 => 0.0384, 6 => 0.0392, 5 => 0.0401, 4 => 0.0409, 3 => 0.0418, 2 => 0.0427, 1 => 0.0436, 0 => 0.0446 ],    '-1.6' => [ 9 => 0.0455, 8 => 0.0465, 7 => 0.0475, 6 => 0.0485, 5 => 0.0495, 4 => 0.0505, 3 => 0.0516, 2 => 0.0526, 1 => 0.0537, 0 => 0.0548 ],    '-1.5' => [ 9 => 0.0559, 8 => 0.0571, 7 => 0.0582, 6 => 0.0594, 5 => 0.0606, 4 => 0.0618, 3 => 0.0630, 2 => 0.0643, 1 => 0.0655, 0 => 0.0668 ],    '-1.4' => [ 9 => 0.0681, 8 => 0.0694, 7 => 0.0708, 6 => 0.0721, 5 => 0.0735, 4 => 0.0749, 3 => 0.0764, 2 => 0.0778, 1 => 0.0793, 0 => 0.0808 ],    '-1.3' => [ 9 => 0.0823, 8 => 0.0838, 7 => 0.0853, 6 => 0.0869, 5 => 0.0885, 4 => 0.0901, 3 => 0.0918, 2 => 0.0934, 1 => 0.0951, 0 => 0.0968 ],    '-1.2' => [ 9 => 0.0985, 8 => 0.1003, 7 => 0.1020, 6 => 0.1038, 5 => 0.1056, 4 => 0.1075, 3 => 0.1093, 2 => 0.1112, 1 => 0.1131, 0 => 0.1151 ],    '-1.1' => [ 9 => 0.1170, 8 => 0.1190, 7 => 0.1210, 6 => 0.1230, 5 => 0.1251, 4 => 0.1271, 3 => 0.1292, 2 => 0.1314, 1 => 0.1335, 0 => 0.1357 ],    '-1.0' => [ 9 => 0.1379, 8 => 0.1401, 7 => 0.1423, 6 => 0.1446, 5 => 0.1469, 4 => 0.1492, 3 => 0.1515, 2 => 0.1539, 1 => 0.1562, 0 => 0.1587 ],    '-0.9' => [ 9 => 0.1611, 8 => 0.1635, 7 => 0.1660, 6 => 0.1685, 5 => 0.1711, 4 => 0.1736, 3 => 0.1762, 2 => 0.1788, 1 => 0.1814, 0 => 0.1841 ],    '-0.8' => [ 9 => 0.1867, 8 => 0.1894, 7 => 0.1922, 6 => 0.1949, 5 => 0.1977, 4 => 0.2005, 3 => 0.2033, 2 => 0.2061, 1 => 0.2090, 0 => 0.2119 ],    '-0.7' => [ 9 => 0.2148, 8 => 0.2177, 7 => 0.2206, 6 => 0.2236, 5 => 0.2266, 4 => 0.2296, 3 => 0.2327, 2 => 0.2358, 1 => 0.2389, 0 => 0.2420 ],    '-0.6' => [ 9 => 0.2451, 8 => 0.2483, 7 => 0.2514, 6 => 0.2546, 5 => 0.2578, 4 => 0.2611, 3 => 0.2643, 2 => 0.2676, 1 => 0.2709, 0 => 0.2743 ],    '-0.5' => [ 9 => 0.2776, 8 => 0.2810, 7 => 0.2843, 6 => 0.2877, 5 => 0.2912, 4 => 0.2946, 3 => 0.2981, 2 => 0.3015, 1 => 0.3050, 0 => 0.3085 ],    '-0.4' => [ 9 => 0.3121, 8 => 0.3156, 7 => 0.3192, 6 => 0.3228, 5 => 0.3264, 4 => 0.3300, 3 => 0.3336, 2 => 0.3372, 1 => 0.3409, 0 => 0.3446 ],    '-0.3' => [ 9 => 0.3483, 8 => 0.3520, 7 => 0.3557, 6 => 0.3594, 5 => 0.3632, 4 => 0.3669, 3 => 0.3707, 2 => 0.3745, 1 => 0.3783, 0 => 0.3821 ],    '-0.2' => [ 9 => 0.3829, 8 => 0.3897, 7 => 0.3936, 6 => 0.3974, 5 => 0.4013, 4 => 0.4052, 3 => 0.4090, 2 => 0.4129, 1 => 0.4168, 0 => 0.4207 ],    '-0.1' => [ 9 => 0.4247, 8 => 0.4286, 7 => 0.4325, 6 => 0.4364, 5 => 0.4404, 4 => 0.4443, 3 => 0.4483, 2 => 0.4522, 1 => 0.4562, 0 => 0.4602 ],    '-0.0' => [ 9 => 0.4641, 8 => 0.4681, 7 => 0.4721, 6 => 0.4761, 5 => 0.4801, 4 => 0.4840, 3 => 0.4880, 2 => 0.4920, 1 => 0.4960, 0 => 0.5000 ],     '0.0' => [ 0 => 0.50000, 1 => 0.50399, 2 => 0.50798, 3 => 0.51197, 4 => 0.51595, 5 => 0.51994, 6 => 0.52392, 7 => 0.52790, 8 => 0.53188, 9 => 0.53586 ],     '0.1' => [ 0 => 0.53980, 1 => 0.54380, 2 => 0.54776, 3 => 0.55172, 4 => 0.55567, 5 => 0.55966, 6 => 0.56360, 7 => 0.56749, 8 => 0.57142, 9 => 0.57535 ],     '0.2' => [ 0 => 0.57930, 1 => 0.58317, 2 => 0.58706, 3 => 0.59095, 4 => 0.59483, 5 => 0.59871, 6 => 0.60257, 7 => 0.60642, 8 => 0.61026, 9 => 0.61409 ],     '0.3' => [ 0 => 0.61791, 1 => 0.62172, 2 => 0.62552, 3 => 0.62930, 4 => 0.63307, 5 => 0.63683, 6 => 0.64058, 7 => 0.64431, 8 => 0.64803, 9 => 0.65173 ],     '0.4' => [ 0 => 0.65542, 1 => 0.65910, 2 => 0.66276, 3 => 0.66640, 4 => 0.67003, 5 => 0.67364, 6 => 0.67724, 7 => 0.68082, 8 => 0.68439, 9 => 0.68793 ],     '0.5' => [ 0 => 0.69146, 1 => 0.69497, 2 => 0.69847, 3 => 0.70194, 4 => 0.70540, 5 => 0.70884, 6 => 0.71226, 7 => 0.71566, 8 => 0.71904, 9 => 0.72240 ],     '0.6' => [ 0 => 0.72575, 1 => 0.72907, 2 => 0.73237, 3 => 0.73565, 4 => 0.73891, 5 => 0.74215, 6 => 0.74537, 7 => 0.74857, 8 => 0.75175, 9 => 0.75490 ],     '0.7' => [ 0 => 0.75804, 1 => 0.76115, 2 => 0.76424, 3 => 0.76730, 4 => 0.77035, 5 => 0.77337, 6 => 0.77637, 7 => 0.77935, 8 => 0.78230, 9 => 0.78524 ],     '0.8' => [ 0 => 0.78814, 1 => 0.79103, 2 => 0.79389, 3 => 0.79673, 4 => 0.79955, 5 => 0.80234, 6 => 0.80511, 7 => 0.80785, 8 => 0.81057, 9 => 0.81327 ],     '0.9' => [ 0 => 0.81594, 1 => 0.81859, 2 => 0.82121, 3 => 0.82381, 4 => 0.82639, 5 => 0.82894, 6 => 0.83147, 7 => 0.83398, 8 => 0.83646, 9 => 0.83891 ],     '1.0' => [ 0 => 0.84134, 1 => 0.84375, 2 => 0.84614, 3 => 0.84849, 4 => 0.85083, 5 => 0.85314, 6 => 0.85543, 7 => 0.85769, 8 => 0.85993, 9 => 0.86214 ],     '1.1' => [ 0 => 0.86433, 1 => 0.86650, 2 => 0.86864, 3 => 0.87076, 4 => 0.87286, 5 => 0.87493, 6 => 0.87698, 7 => 0.87900, 8 => 0.88100, 9 => 0.88298 ],     '1.2' => [ 0 => 0.88493, 1 => 0.88686, 2 => 0.88877, 3 => 0.89065, 4 => 0.89251, 5 => 0.89435, 6 => 0.89617, 7 => 0.89796, 8 => 0.89973, 9 => 0.90147 ],     '1.3' => [ 0 => 0.90320, 1 => 0.90490, 2 => 0.90658, 3 => 0.90824, 4 => 0.90988, 5 => 0.91149, 6 => 0.91308, 7 => 0.91466, 8 => 0.91621, 9 => 0.91774 ],     '1.4' => [ 0 => 0.91924, 1 => 0.92073, 2 => 0.92220, 3 => 0.92364, 4 => 0.92507, 5 => 0.92647, 6 => 0.92785, 7 => 0.92922, 8 => 0.93056, 9 => 0.93189 ],     '1.5' => [ 0 => 0.93319, 1 => 0.93448, 2 => 0.93574, 3 => 0.93699, 4 => 0.93822, 5 => 0.93943, 6 => 0.94062, 7 => 0.94179, 8 => 0.94295, 9 => 0.94408 ],     '1.6' => [ 0 => 0.94520, 1 => 0.94630, 2 => 0.94738, 3 => 0.94845, 4 => 0.94950, 5 => 0.95053, 6 => 0.95154, 7 => 0.95254, 8 => 0.95352, 9 => 0.95449 ],     '1.7' => [ 0 => 0.95543, 1 => 0.95637, 2 => 0.95728, 3 => 0.95818, 4 => 0.95907, 5 => 0.95994, 6 => 0.96080, 7 => 0.96164, 8 => 0.96246, 9 => 0.96327 ],     '1.8' => [ 0 => 0.96407, 1 => 0.96485, 2 => 0.96562, 3 => 0.96638, 4 => 0.96712, 5 => 0.96784, 6 => 0.96856, 7 => 0.96926, 8 => 0.96995, 9 => 0.97062 ],     '1.9' => [ 0 => 0.97128, 1 => 0.97193, 2 => 0.97257, 3 => 0.97320, 4 => 0.97381, 5 => 0.97441, 6 => 0.97500, 7 => 0.97558, 8 => 0.97615, 9 => 0.97670 ],     '2.0' => [ 0 => 0.97725, 1 => 0.97778, 2 => 0.97831, 3 => 0.97882, 4 => 0.97932, 5 => 0.97982, 6 => 0.98030, 7 => 0.98077, 8 => 0.98124, 9 => 0.98169 ],     '2.1' => [ 0 => 0.98214, 1 => 0.98257, 2 => 0.98300, 3 => 0.98341, 4 => 0.98382, 5 => 0.98422, 6 => 0.98461, 7 => 0.98500, 8 => 0.98537, 9 => 0.98574 ],     '2.2' => [ 0 => 0.98610, 1 => 0.98645, 2 => 0.98679, 3 => 0.98713, 4 => 0.98745, 5 => 0.98778, 6 => 0.98809, 7 => 0.98840, 8 => 0.98870, 9 => 0.98899 ],     '2.3' => [ 0 => 0.98928, 1 => 0.98956, 2 => 0.98983, 3 => 0.99010, 4 => 0.99036, 5 => 0.99061, 6 => 0.99086, 7 => 0.99111, 8 => 0.99134, 9 => 0.99158 ],     '2.4' => [ 0 => 0.99180, 1 => 0.99202, 2 => 0.99224, 3 => 0.99245, 4 => 0.99266, 5 => 0.99286, 6 => 0.99305, 7 => 0.99324, 8 => 0.99343, 9 => 0.99361 ],     '2.5' => [ 0 => 0.99379, 1 => 0.99396, 2 => 0.99413, 3 => 0.99430, 4 => 0.99446, 5 => 0.99461, 6 => 0.99477, 7 => 0.99492, 8 => 0.99506, 9 => 0.99520 ],     '2.6' => [ 0 => 0.99534, 1 => 0.99547, 2 => 0.99560, 3 => 0.99573, 4 => 0.99585, 5 => 0.99598, 6 => 0.99609, 7 => 0.99621, 8 => 0.99632, 9 => 0.99643 ],     '2.7' => [ 0 => 0.99653, 1 => 0.99664, 2 => 0.99674, 3 => 0.99683, 4 => 0.99693, 5 => 0.99702, 6 => 0.99711, 7 => 0.99720, 8 => 0.99728, 9 => 0.99736 ],     '2.8' => [ 0 => 0.99744, 1 => 0.99752, 2 => 0.99760, 3 => 0.99767, 4 => 0.99774, 5 => 0.99781, 6 => 0.99788, 7 => 0.99795, 8 => 0.99801, 9 => 0.99807 ],     '2.9' => [ 0 => 0.99813, 1 => 0.99819, 2 => 0.99825, 3 => 0.99831, 4 => 0.99836, 5 => 0.99841, 6 => 0.99846, 7 => 0.99851, 8 => 0.99856, 9 => 0.99861 ],     '3.0' => [ 0 => 0.99865, 1 => 0.99869, 2 => 0.99874, 3 => 0.99878, 4 => 0.99882, 5 => 0.99886, 6 => 0.99889, 7 => 0.99893, 8 => 0.99896, 9 => 0.99900 ],    ];    /**     * Get Z score probability (Î¦)     *     * @param float $Z     *     * @return float probability     *     * @throws Exception\BadDataException     */    public static function getZScoreProbability(float $Z): float    {        if (!preg_match('/^ (\-? \d [.] \d) (\d) $/x', \sprintf('%1.2f', $Z), $matches)) {            throw new Exception\BadParameterException(""Z does not match format X.XX: $Z"");        }        [$z, $ï¼‹0ï¼Ž0x] = [ $matches[1], $matches[2] ];        return self::Z_SCORES[$z][$ï¼‹0ï¼Ž0x];    }    /**     * Z scores for confidence intervals     * Key: confidence level %     * Value: Z score     * @var array     */    private const Z_SCORES_FOR_CONFIDENCE_INTERVALS = [        50     => 0.67449,        70     => 1.04,        75     => 1.15035,        80     => 1.282,        85     => 1.44,        90     => 1.64485,        92     => 1.75,        95     => 1.95996,        96     => 2.05,        97     => 2.17009,        98     => 2.326,        99     => 2.57583,        '99.5' => 2.81,        '99.8' => 3.08,        '99.9' => 3.29053,    ];    /**     * Get Z score for confidence interval     *     * @param  string $cl confidence level     *     * @return float Z score     *     * @throws Exception\BadDataException     */    public static function getZScoreForConfidenceInterval(string $cl): float    {        if (!\array_key_exists($cl, self::Z_SCORES_FOR_CONFIDENCE_INTERVALS)) {            throw new Exception\BadDataException('Not a valid confidence level');        }        return self::Z_SCORES_FOR_CONFIDENCE_INTERVALS[$cl];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
canvas_js_example,PHP Scatter / Point Charts & Graphs. Scatter charts represents data as a series of points with their axis co-ordinates determined by x and y value of data point. Scatter Charts are also referred as Scatter Plot / Point Chart. Given example shows simple Scatter Chart along with source code that you can try running locally.,"Php crtač dijagrama rasejanja i grafikona. Tabele rasejanja sadrže podatke u vidu niza koordinatnih tačaka od kojih svaka ima vrednosti koje odgovaraju x i y osi. Tabele rasejanja, se takođe oslovljava kao tabela tačaka ili dijagram rasejanja. Dat primer prikazuje jednostavnu tabelu rasejanja sa izvornim kodom koji možete lokalno pokrenuti.","<?php   $dataPoints = array( 	array(""x""=> 51, ""y""=> 51), 	array(""x""=> 77, ""y""=> 56), 	array(""x""=> 82, ""y""=> 57), 	array(""x""=> 82.5, ""y""=> 63.5), 	array(""x""=> 83, ""y""=> 59.5), 	array(""x""=> 85, ""y""=> 58), 	array(""x""=> 90, ""y""=> 65), 	array(""x""=> 97.5, ""y""=> 66), 	array(""x""=> 99, ""y""=> 59), 	array(""x""=> 102, ""y""=> 64), 	array(""x""=> 102, ""y""=> 63), 	array(""x""=> 111.5, ""y""=> 68), 	array(""x""=> 112, ""y""=> 70), 	array(""x""=> 113, ""y""=> 61), 	array(""x""=> 128, ""y""=> 65), 	array(""x""=> 132, ""y""=> 66.5), 	array(""x""=> 151, ""y""=> 71) ); 	 ?> <!DOCTYPE HTML> <html> <head>   <script> window.onload = function () {   var chart = new CanvasJS.Chart(""chartContainer"", { 	animationEnabled: true, 	exportEnabled: true, 	theme: ""light1"",  	title:{ 		text: ""Study of Height vs Weight"" 	}, 	axisX:{ 		title: ""Weight"", 		suffix: "" kg"" 	}, 	axisY:{ 		title: ""Height"", 		suffix: "" inch"" 	}, 	data: [{ 		type: ""scatter"", 		markerType: ""square"", 		markerSize: 10, 		toolTipContent: ""Height: {y} inch<br>Weight: {x} kg"", 		dataPoints: <?php echo json_encode($dataPoints, JSON_NUMERIC_CHECK); ?> 	}] }); chart.render();   } </script> </head> <body> <div id=""chartContainer"" style=""height: 370px; width: 100%;""></div> <script src=""https://canvasjs.com/assets/script/canvasjs.min.js""></script> </body> </html>",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1636, Handles incoming requests and transforms a $request into a $response by reference.\n\n @param ServerRequestInterface $request\n\n @return ResponseInterface|Promise\n @throws \\Exception\n,Rukovodi pristiglim zahtevima i transformiše zahtev u odgovor referencom.,"    public function onRequest(ServerRequestInterface $request)    {        if ($this->isPopulateServer()) {            $this->prepareEnvironment($request);        }        $remoteIp = $request->getHeaderLine('X-PHP-PM-Remote-IP');        $remotePort = $request->getHeaderLine('X-PHP-PM-Remote-Port');        $request = $request->withoutHeader('X-PHP-PM-Remote-IP');        $request = $request->withoutHeader('X-PHP-PM-Remote-Port');        $request = $request->withAttribute('remote_address', $remoteIp);        $request = $request->withAttribute('remote_port', $remotePort);        $logTime = \date('d/M/Y:H:i:s O');        $catchLog = function ($e) {            console_log((string) $e);            return new Response(500);        };        try {            $response = $this->handleRequest($request);        } catch (\Throwable $t) {            $response = $catchLog($t);        }        $promise = new Promise(function ($resolve) use ($response) {            return $resolve($response);        });        $promise = $promise->then(function (ResponseInterface $response) use ($request, $logTime, $remoteIp) {            if ($this->isLogging()) {                $this->logResponse($request, $response, $logTime, $remoteIp);            }            return $response;        });        return $promise;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7904, Request represents an HTTP request.\n\n The methods dealing with URL accept / return a raw path (% encoded):\n                  \n @author Fabien Potencier <fabien@symfony.com>\n,Klasa Request predstavlja http request,"class Request {     public const HEADER_FORWARDED = 0b000001; // When using RFC 7239     public const HEADER_X_FORWARDED_FOR = 0b000010;     public const HEADER_X_FORWARDED_HOST = 0b000100;     public const HEADER_X_FORWARDED_PROTO = 0b001000;     public const HEADER_X_FORWARDED_PORT = 0b010000;     public const HEADER_X_FORWARDED_PREFIX = 0b100000;      /** @deprecated since Symfony 5.2, use either ""HEADER_X_FORWARDED_FOR | HEADER_X_FORWARDED_HOST | HEADER_X_FORWARDED_PORT | HEADER_X_FORWARDED_PROTO"" or ""HEADER_X_FORWARDED_AWS_ELB"" or ""HEADER_X_FORWARDED_TRAEFIK"" constants instead. */     public const HEADER_X_FORWARDED_ALL = 0b1011110; // All ""X-Forwarded-*"" headers sent by ""usual"" reverse proxy     public const HEADER_X_FORWARDED_AWS_ELB = 0b0011010; // AWS ELB doesn't send X-Forwarded-Host     public const HEADER_X_FORWARDED_TRAEFIK = 0b0111110; // All ""X-Forwarded-*"" headers sent by Traefik reverse proxy      public const METHOD_HEAD = 'HEAD';     public const METHOD_GET = 'GET';     public const METHOD_POST = 'POST';     public const METHOD_PUT = 'PUT';     public const METHOD_PATCH = 'PATCH';     public const METHOD_DELETE = 'DELETE';     public const METHOD_PURGE = 'PURGE';     public const METHOD_OPTIONS = 'OPTIONS';     public const METHOD_TRACE = 'TRACE';     public const METHOD_CONNECT = 'CONNECT';      /**      * @var string[]      */     protected static $trustedProxies = [];      /**      * @var string[]      */     protected static $trustedHostPatterns = [];      /**      * @var string[]      */     protected static $trustedHosts = [];      protected static $httpMethodParameterOverride = false;      /**      * Custom parameters.      *      * @var ParameterBag      */     public $attributes;      /**      * Request body parameters ($_POST).      *      * @var InputBag      */     public $request;      /**      * Query string parameters ($_GET).      *      * @var InputBag      */     public $query;      /**      * Server and execution environment parameters ($_SERVER).      *      * @var ServerBag      */     public $server;      /**      * Uploaded files ($_FILES).      *      * @var FileBag      */     public $files;      /**      * Cookies ($_COOKIE).      *      * @var InputBag      */     public $cookies;      /**      * Headers (taken from the $_SERVER).      *      * @var HeaderBag      */     public $headers;      /**      * @var string|resource|false|null      */     protected $content;      /**      * @var array      */     protected $languages;      /**      * @var array      */     protected $charsets;      /**      * @var array      */     protected $encodings;      /**      * @var array      */     protected $acceptableContentTypes;      /**      * @var string      */     protected $pathInfo;      /**      * @var string      */     protected $requestUri;      /**      * @var string      */     protected $baseUrl;      /**      * @var string      */     protected $basePath;      /**      * @var string      */     protected $method;      /**      * @var string      */     protected $format;      /**      * @var SessionInterface|callable      */     protected $session;      /**      * @var string      */     protected $locale;      /**      * @var string      */     protected $defaultLocale = 'en';      /**      * @var array      */     protected static $formats;      protected static $requestFactory;      /**      * @var string|null      */     private $preferredFormat;     private $isHostValid = true;     private $isForwardedValid = true;      /**      * @var bool|null      */     private $isSafeContentPreferred;      private static $trustedHeaderSet = -1;      private const FORWARDED_PARAMS = [         self::HEADER_X_FORWARDED_FOR => 'for',         self::HEADER_X_FORWARDED_HOST => 'host',         self::HEADER_X_FORWARDED_PROTO => 'proto',         self::HEADER_X_FORWARDED_PORT => 'host',     ];      /**      * Names for headers that can be trusted when      * using trusted proxies.      *      * The FORWARDED header is the standard as of rfc7239.      *      * The other headers are non-standard, but widely used      * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).      */     private const TRUSTED_HEADERS = [         self::HEADER_FORWARDED => 'FORWARDED',         self::HEADER_X_FORWARDED_FOR => 'X_FORWARDED_FOR',         self::HEADER_X_FORWARDED_HOST => 'X_FORWARDED_HOST',         self::HEADER_X_FORWARDED_PROTO => 'X_FORWARDED_PROTO',         self::HEADER_X_FORWARDED_PORT => 'X_FORWARDED_PORT',         self::HEADER_X_FORWARDED_PREFIX => 'X_FORWARDED_PREFIX',     ];      /**      * @param array                $query      The GET parameters      * @param array                $request    The POST parameters      * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)      * @param array                $cookies    The COOKIE parameters      * @param array                $files      The FILES parameters      * @param array                $server     The SERVER parameters      * @param string|resource|null $content    The raw body data      */     public function __construct(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)     {         $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);     }      /**      * Sets the parameters for this request.      *      * This method also re-initializes all properties.      *      * @param array                $query      The GET parameters      * @param array                $request    The POST parameters      * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)      * @param array                $cookies    The COOKIE parameters      * @param array                $files      The FILES parameters      * @param array                $server     The SERVER parameters      * @param string|resource|null $content    The raw body data      */     public function initialize(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)     {         $this->request = new InputBag($request);         $this->query = new InputBag($query);         $this->attributes = new ParameterBag($attributes);         $this->cookies = new InputBag($cookies);         $this->files = new FileBag($files);         $this->server = new ServerBag($server);         $this->headers = new HeaderBag($this->server->getHeaders());          $this->content = $content;         $this->languages = null;         $this->charsets = null;         $this->encodings = null;         $this->acceptableContentTypes = null;         $this->pathInfo = null;         $this->requestUri = null;         $this->baseUrl = null;         $this->basePath = null;         $this->method = null;         $this->format = null;     }      /**      * Creates a new request with values from PHP's super globals.      *      * @return static      */     public static function createFromGlobals()     {         $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);          if (0 === strpos($request->headers->get('CONTENT_TYPE', ''), 'application/x-www-form-urlencoded')             && \in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])         ) {             parse_str($request->getContent(), $data);             $request->request = new InputBag($data);         }          return $request;     }      /**      * Creates a Request based on a given URI and configuration.      *      * The information contained in the URI always take precedence      * over the other information (server and parameters).      *      * @param string               $uri        The URI      * @param string               $method     The HTTP method      * @param array                $parameters The query (GET) or request (POST) parameters      * @param array                $cookies    The request cookies ($_COOKIE)      * @param array                $files      The request files ($_FILES)      * @param array                $server     The server parameters ($_SERVER)      * @param string|resource|null $content    The raw body data      *      * @return static      */     public static function create(string $uri, string $method = 'GET', array $parameters = [], array $cookies = [], array $files = [], array $server = [], $content = null)     {         $server = array_replace([             'SERVER_NAME' => 'localhost',             'SERVER_PORT' => 80,             'HTTP_HOST' => 'localhost',             'HTTP_USER_AGENT' => 'Symfony',             'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',             'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',             'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',             'REMOTE_ADDR' => '127.0.0.1',             'SCRIPT_NAME' => '',             'SCRIPT_FILENAME' => '',             'SERVER_PROTOCOL' => 'HTTP/1.1',             'REQUEST_TIME' => time(),             'REQUEST_TIME_FLOAT' => microtime(true),         ], $server);          $server['PATH_INFO'] = '';         $server['REQUEST_METHOD'] = strtoupper($method);          $components = parse_url($uri);         if (isset($components['host'])) {             $server['SERVER_NAME'] = $components['host'];             $server['HTTP_HOST'] = $components['host'];         }          if (isset($components['scheme'])) {             if ('https' === $components['scheme']) {                 $server['HTTPS'] = 'on';                 $server['SERVER_PORT'] = 443;             } else {                 unset($server['HTTPS']);                 $server['SERVER_PORT'] = 80;             }         }          if (isset($components['port'])) {             $server['SERVER_PORT'] = $components['port'];             $server['HTTP_HOST'] .= ':'.$components['port'];         }          if (isset($components['user'])) {             $server['PHP_AUTH_USER'] = $components['user'];         }          if (isset($components['pass'])) {             $server['PHP_AUTH_PW'] = $components['pass'];         }          if (!isset($components['path'])) {             $components['path'] = '/';         }          switch (strtoupper($method)) {             case 'POST':             case 'PUT':             case 'DELETE':                 if (!isset($server['CONTENT_TYPE'])) {                     $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';                 }                 // no break             case 'PATCH':                 $request = $parameters;                 $query = [];                 break;             default:                 $request = [];                 $query = $parameters;                 break;         }          $queryString = '';         if (isset($components['query'])) {             parse_str(html_entity_decode($components['query']), $qs);              if ($query) {                 $query = array_replace($qs, $query);                 $queryString = http_build_query($query, '', '&');             } else {                 $query = $qs;                 $queryString = $components['query'];             }         } elseif ($query) {             $queryString = http_build_query($query, '', '&');         }          $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');         $server['QUERY_STRING'] = $queryString;          return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);     }      /**      * Sets a callable able to create a Request instance.      *      * This is mainly useful when you need to override the Request class      * to keep BC with an existing system. It should not be used for any      * other purpose.      */     public static function setFactory(?callable $callable)     {         self::$requestFactory = $callable;     }      /**      * Clones a request and overrides some of its parameters.      *      * @param array $query      The GET parameters      * @param array $request    The POST parameters      * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)      * @param array $cookies    The COOKIE parameters      * @param array $files      The FILES parameters      * @param array $server     The SERVER parameters      *      * @return static      */     public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)     {         $dup = clone $this;         if (null !== $query) {             $dup->query = new InputBag($query);         }         if (null !== $request) {             $dup->request = new InputBag($request);         }         if (null !== $attributes) {             $dup->attributes = new ParameterBag($attributes);         }         if (null !== $cookies) {             $dup->cookies = new InputBag($cookies);         }         if (null !== $files) {             $dup->files = new FileBag($files);         }         if (null !== $server) {             $dup->server = new ServerBag($server);             $dup->headers = new HeaderBag($dup->server->getHeaders());         }         $dup->languages = null;         $dup->charsets = null;         $dup->encodings = null;         $dup->acceptableContentTypes = null;         $dup->pathInfo = null;         $dup->requestUri = null;         $dup->baseUrl = null;         $dup->basePath = null;         $dup->method = null;         $dup->format = null;          if (!$dup->get('_format') && $this->get('_format')) {             $dup->attributes->set('_format', $this->get('_format'));         }          if (!$dup->getRequestFormat(null)) {             $dup->setRequestFormat($this->getRequestFormat(null));         }          return $dup;     }      /**      * Clones the current request.      *      * Note that the session is not cloned as duplicated requests      * are most of the time sub-requests of the main one.      */     public function __clone()     {         $this->query = clone $this->query;         $this->request = clone $this->request;         $this->attributes = clone $this->attributes;         $this->cookies = clone $this->cookies;         $this->files = clone $this->files;         $this->server = clone $this->server;         $this->headers = clone $this->headers;     }      /**      * Returns the request as a string.      *      * @return string The request      */     public function __toString()     {         $content = $this->getContent();          $cookieHeader = '';         $cookies = [];          foreach ($this->cookies as $k => $v) {             $cookies[] = $k.'='.$v;         }          if (!empty($cookies)) {             $cookieHeader = 'Cookie: '.implode('; ', $cookies).""\r\n"";         }          return             sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).""\r\n"".             $this->headers.             $cookieHeader.""\r\n"".             $content;     }      /**      * Overrides the PHP global variables according to this request instance.      *      * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.      * $_FILES is never overridden, see rfc1867      */     public function overrideGlobals()     {         $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));          $_GET = $this->query->all();         $_POST = $this->request->all();         $_SERVER = $this->server->all();         $_COOKIE = $this->cookies->all();          foreach ($this->headers->all() as $key => $value) {             $key = strtoupper(str_replace('-', '_', $key));             if (\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {                 $_SERVER[$key] = implode(', ', $value);             } else {                 $_SERVER['HTTP_'.$key] = implode(', ', $value);             }         }          $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];          $requestOrder = ini_get('request_order') ?: ini_get('variables_order');         $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';          $_REQUEST = [[]];          foreach (str_split($requestOrder) as $order) {             $_REQUEST[] = $request[$order];         }          $_REQUEST = array_merge(...$_REQUEST);     }      /**      * Sets a list of trusted proxies.      *      * You should only list the reverse proxies that you manage directly.      *      * @param array $proxies          A list of trusted proxies, the string 'REMOTE_ADDR' will be replaced with $_SERVER['REMOTE_ADDR']      * @param int   $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies      */     public static function setTrustedProxies(array $proxies, int $trustedHeaderSet)     {         if (self::HEADER_X_FORWARDED_ALL === $trustedHeaderSet) {             trigger_deprecation('symfony/http-foundation', '5.2', 'The ""HEADER_X_FORWARDED_ALL"" constant is deprecated, use either ""HEADER_X_FORWARDED_FOR | HEADER_X_FORWARDED_HOST | HEADER_X_FORWARDED_PORT | HEADER_X_FORWARDED_PROTO"" or ""HEADER_X_FORWARDED_AWS_ELB"" or ""HEADER_X_FORWARDED_TRAEFIK"" constants instead.');         }         self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {             if ('REMOTE_ADDR' !== $proxy) {                 $proxies[] = $proxy;             } elseif (isset($_SERVER['REMOTE_ADDR'])) {                 $proxies[] = $_SERVER['REMOTE_ADDR'];             }              return $proxies;         }, []);         self::$trustedHeaderSet = $trustedHeaderSet;     }      /**      * Gets the list of trusted proxies.      *      * @return array An array of trusted proxies      */     public static function getTrustedProxies()     {         return self::$trustedProxies;     }      /**      * Gets the set of trusted headers from trusted proxies.      *      * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies      */     public static function getTrustedHeaderSet()     {         return self::$trustedHeaderSet;     }      /**      * Sets a list of trusted host patterns.      *      * You should only list the hosts you manage using regexs.      *      * @param array $hostPatterns A list of trusted host patterns      */     public static function setTrustedHosts(array $hostPatterns)     {         self::$trustedHostPatterns = array_map(function ($hostPattern) {             return sprintf('{%s}i', $hostPattern);         }, $hostPatterns);         // we need to reset trusted hosts on trusted host patterns change         self::$trustedHosts = [];     }      /**      * Gets the list of trusted host patterns.      *      * @return array An array of trusted host patterns      */     public static function getTrustedHosts()     {         return self::$trustedHostPatterns;     }      /**      * Normalizes a query string.      *      * It builds a normalized query string, where keys/value pairs are alphabetized,      * have consistent escaping and unneeded delimiters are removed.      *      * @return string A normalized query string for the Request      */     public static function normalizeQueryString(?string $qs)     {         if ('' === ($qs ?? '')) {             return '';         }          $qs = HeaderUtils::parseQuery($qs);         ksort($qs);          return http_build_query($qs, '', '&', \PHP_QUERY_RFC3986);     }      /**      * Enables support for the _method request parameter to determine the intended HTTP method.      *      * Be warned that enabling this feature might lead to CSRF issues in your code.      * Check that you are using CSRF tokens when required.      * If the HTTP method parameter override is enabled, an html-form with method ""POST"" can be altered      * and used to send a ""PUT"" or ""DELETE"" request via the _method request parameter.      * If these methods are not protected against CSRF, this presents a possible vulnerability.      *      * The HTTP method can only be overridden when the real HTTP method is POST.      */     public static function enableHttpMethodParameterOverride()     {         self::$httpMethodParameterOverride = true;     }      /**      * Checks whether support for the _method request parameter is enabled.      *      * @return bool True when the _method request parameter is enabled, false otherwise      */     public static function getHttpMethodParameterOverride()     {         return self::$httpMethodParameterOverride;     }      /**      * Gets a ""parameter"" value from any bag.      *      * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the      * flexibility in controllers, it is better to explicitly get request parameters from the appropriate      * public property instead (attributes, query, request).      *      * Order of precedence: PATH (routing placeholders or custom attributes), GET, POST      *      * @param mixed $default The default value if the parameter key does not exist      *      * @return mixed      */     public function get(string $key, $default = null)     {         if ($this !== $result = $this->attributes->get($key, $this)) {             return $result;         }          if ($this->query->has($key)) {             return $this->query->all()[$key];         }          if ($this->request->has($key)) {             return $this->request->all()[$key];         }          return $default;     }      /**      * Gets the Session.      *      * @return SessionInterface The session      */     public function getSession()     {         $session = $this->session;         if (!$session instanceof SessionInterface && null !== $session) {             $this->setSession($session = $session());         }          if (null === $session) {             throw new SessionNotFoundException('Session has not been set.');         }          return $session;     }      /**      * Whether the request contains a Session which was started in one of the      * previous requests.      *      * @return bool      */     public function hasPreviousSession()     {         // the check for $this->session avoids malicious users trying to fake a session cookie with proper name         return $this->hasSession() && $this->cookies->has($this->getSession()->getName());     }      /**      * Whether the request contains a Session object.      *      * This method does not give any information about the state of the session object,      * like whether the session is started or not. It is just a way to check if this Request      * is associated with a Session instance.      *      * @return bool true when the Request contains a Session object, false otherwise      */     public function hasSession()     {         return null !== $this->session;     }      public function setSession(SessionInterface $session)     {         $this->session = $session;     }      /**      * @internal      */     public function setSessionFactory(callable $factory)     {         $this->session = $factory;     }      /**      * Returns the client IP addresses.      *      * In the returned array the most trusted IP address is first, and the      * least trusted one last. The ""real"" client IP address is the last one,      * but this is also the least trusted one. Trusted proxies are stripped.      *      * Use this method carefully; you should use getClientIp() instead.      *      * @return array The client IP addresses      *      * @see getClientIp()      */     public function getClientIps()     {         $ip = $this->server->get('REMOTE_ADDR');          if (!$this->isFromTrustedProxy()) {             return [$ip];         }          return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];     }      /**      * Returns the client IP address.      *      * This method can read the client IP address from the ""X-Forwarded-For"" header      * when trusted proxies were set via ""setTrustedProxies()"". The ""X-Forwarded-For""      * header value is a comma+space separated list of IP addresses, the left-most      * being the original client, and each successive proxy that passed the request      * adding the IP address where it received the request from.      *      * If your reverse proxy uses a different header name than ""X-Forwarded-For"",      * (""Client-Ip"" for instance), configure it via the $trustedHeaderSet      * argument of the Request::setTrustedProxies() method instead.      *      * @return string|null The client IP address      *      * @see getClientIps()      * @see https://wikipedia.org/wiki/X-Forwarded-For      */     public function getClientIp()     {         $ipAddresses = $this->getClientIps();          return $ipAddresses[0];     }      /**      * Returns current script name.      *      * @return string      */     public function getScriptName()     {         return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));     }      /**      * Returns the path being requested relative to the executed script.      *      * The path info always starts with a /.      *      * Suppose this request is instantiated from /mysite on localhost:      *      *  * http://localhost/mysite              returns an empty string      *  * http://localhost/mysite/about        returns '/about'      *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'      *  * http://localhost/mysite/about?var=1  returns '/about'      *      * @return string The raw path (i.e. not urldecoded)      */     public function getPathInfo()     {         if (null === $this->pathInfo) {             $this->pathInfo = $this->preparePathInfo();         }          return $this->pathInfo;     }      /**      * Returns the root path from which this request is executed.      *      * Suppose that an index.php file instantiates this request object:      *      *  * http://localhost/index.php         returns an empty string      *  * http://localhost/index.php/page    returns an empty string      *  * http://localhost/web/index.php     returns '/web'      *  * http://localhost/we%20b/index.php  returns '/we%20b'      *      * @return string The raw path (i.e. not urldecoded)      */     public function getBasePath()     {         if (null === $this->basePath) {             $this->basePath = $this->prepareBasePath();         }          return $this->basePath;     }      /**      * Returns the root URL from which this request is executed.      *      * The base URL never ends with a /.      *      * This is similar to getBasePath(), except that it also includes the      * script filename (e.g. index.php) if one exists.      *      * @return string The raw URL (i.e. not urldecoded)      */     public function getBaseUrl()     {         $trustedPrefix = '';          // the proxy prefix must be prepended to any prefix being needed at the webserver level         if ($this->isFromTrustedProxy() && $trustedPrefixValues = $this->getTrustedValues(self::HEADER_X_FORWARDED_PREFIX)) {             $trustedPrefix = rtrim($trustedPrefixValues[0], '/');         }          return $trustedPrefix.$this->getBaseUrlReal();     }      /**      * Returns the real base URL received by the webserver from which this request is executed.      * The URL does not include trusted reverse proxy prefix.      *      * @return string The raw URL (i.e. not urldecoded)      */     private function getBaseUrlReal()     {         if (null === $this->baseUrl) {             $this->baseUrl = $this->prepareBaseUrl();         }          return $this->baseUrl;     }      /**      * Gets the request's scheme.      *      * @return string      */     public function getScheme()     {         return $this->isSecure() ? 'https' : 'http';     }      /**      * Returns the port on which the request is made.      *      * This method can read the client port from the ""X-Forwarded-Port"" header      * when trusted proxies were set via ""setTrustedProxies()"".      *      * The ""X-Forwarded-Port"" header must contain the client port.      *      * @return int|string can be a string if fetched from the server bag      */     public function getPort()     {         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {             $host = $host[0];         } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {             $host = $host[0];         } elseif (!$host = $this->headers->get('HOST')) {             return $this->server->get('SERVER_PORT');         }          if ('[' === $host[0]) {             $pos = strpos($host, ':', strrpos($host, ']'));         } else {             $pos = strrpos($host, ':');         }          if (false !== $pos && $port = substr($host, $pos + 1)) {             return (int) $port;         }          return 'https' === $this->getScheme() ? 443 : 80;     }      /**      * Returns the user.      *      * @return string|null      */     public function getUser()     {         return $this->headers->get('PHP_AUTH_USER');     }      /**      * Returns the password.      *      * @return string|null      */     public function getPassword()     {         return $this->headers->get('PHP_AUTH_PW');     }      /**      * Gets the user info.      *      * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server      */     public function getUserInfo()     {         $userinfo = $this->getUser();          $pass = $this->getPassword();         if ('' != $pass) {             $userinfo .= "":$pass"";         }          return $userinfo;     }      /**      * Returns the HTTP host being requested.      *      * The port name will be appended to the host if it's non-standard.      *      * @return string      */     public function getHttpHost()     {         $scheme = $this->getScheme();         $port = $this->getPort();          if (('http' == $scheme && 80 == $port) || ('https' == $scheme && 443 == $port)) {             return $this->getHost();         }          return $this->getHost().':'.$port;     }      /**      * Returns the requested URI (path and query string).      *      * @return string The raw URI (i.e. not URI decoded)      */     public function getRequestUri()     {         if (null === $this->requestUri) {             $this->requestUri = $this->prepareRequestUri();         }          return $this->requestUri;     }      /**      * Gets the scheme and HTTP host.      *      * If the URL was called with basic authentication, the user      * and the password are not added to the generated string.      *      * @return string The scheme and HTTP host      */     public function getSchemeAndHttpHost()     {         return $this->getScheme().'://'.$this->getHttpHost();     }      /**      * Generates a normalized URI (URL) for the Request.      *      * @return string A normalized URI (URL) for the Request      *      * @see getQueryString()      */     public function getUri()     {         if (null !== $qs = $this->getQueryString()) {             $qs = '?'.$qs;         }          return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;     }      /**      * Generates a normalized URI for the given path.      *      * @param string $path A path to use instead of the current one      *      * @return string The normalized URI for the path      */     public function getUriForPath(string $path)     {         return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;     }      /**      * Returns the path as relative reference from the current Request path.      *      * Only the URIs path component (no schema, host etc.) is relevant and must be given.      * Both paths must be absolute and not contain relative parts.      * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.      * Furthermore, they can be used to reduce the link size in documents.      *      * Example target paths, given a base path of ""/a/b/c/d"":      * - ""/a/b/c/d""     -> """"      * - ""/a/b/c/""      -> ""./""      * - ""/a/b/""        -> ""../""      * - ""/a/b/c/other"" -> ""other""      * - ""/a/x/y""       -> ""../../x/y""      *      * @return string The relative target path      */     public function getRelativeUriForPath(string $path)     {         // be sure that we are dealing with an absolute path         if (!isset($path[0]) || '/' !== $path[0]) {             return $path;         }          if ($path === $basePath = $this->getPathInfo())",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,3,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0
symfony_http-foundation_Request_7910," Sets a list of trusted proxies.\n\n You should only list the reverse proxies that you manage directly.\n\n @param array $proxies          A list of trusted proxies, the string 'REMOTE_ADDR' will be replaced with $_SERVER['REMOTE_ADDR']\n @param int   $trustedHeaderSet A bit field of Request::HEADER_",Postavlja listu pouzdanih proksija. Trebalo biste navesti obrnute proksije kojima direktno upravljate.,"    public static function setTrustedProxies(array $proxies, int $trustedHeaderSet)    {        if (self::HEADER_X_FORWARDED_ALL === $trustedHeaderSet) {            trigger_deprecation('symfony/http-foundation', '5.2', 'The ""HEADER_X_FORWARDED_ALL"" constant is deprecated, use either ""HEADER_X_FORWARDED_FOR | HEADER_X_FORWARDED_HOST | HEADER_X_FORWARDED_PORT | HEADER_X_FORWARDED_PROTO"" or ""HEADER_X_FORWARDED_AWS_ELB"" or ""HEADER_X_FORWARDED_TRAEFIK"" constants instead.');        }        self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {            if ('REMOTE_ADDR' !== $proxy) {                $proxies[] = $proxy;            } elseif (isset($_SERVER['REMOTE_ADDR'])) {                $proxies[] = $_SERVER['REMOTE_ADDR'];            }            return $proxies;        }, []);        self::$trustedHeaderSet = $trustedHeaderSet;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8894," Indicates whether this request originated from a trusted proxy.\n\n This can be useful to determine whether or not to trust the\n contents of a proxy-specific header.\n\n @return bool true if the request came from a trusted proxy, false otherwise\n","Proveri da li je zahtev pristigao od pouzdanog proksi servera. Ovo je korisno prilikom utvrđivanja da li se sadržaju zaglavlja, specifičnog za proksi, može verovati.","    public function isFromTrustedProxy()    {        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR', ''), self::$trustedProxies);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_8693, AsyncTcpConnection.\n,Asinhrona TCP konekcija.,"class AsyncTcpConnection extends TcpConnection{    /**     * Emitted when socket connection is successfully established.     *     * @var callable|null     */    public $onConnect = null;    /**     * Transport layer protocol.     *     * @var string     */    public $transport = 'tcp';    /**     * Status.     *     * @var int     */    protected $_status = self::STATUS_INITIAL;    /**     * Remote host.     *     * @var string     */    protected $_remoteHost = '';    /**     * Remote port.     *     * @var int     */    protected $_remotePort = 80;    /**     * Connect start time.     *     * @var float     */    protected $_connectStartTime = 0;    /**     * Remote URI.     *     * @var string     */    protected $_remoteURI = '';    /**     * Context option.     *     * @var array     */    protected $_contextOption = null;    /**     * Reconnect timer.     *     * @var int     */    protected $_reconnectTimer = null;    /**     * PHP built-in protocols.     *     * @var array     */    protected static $_builtinTransports = array(        'tcp'   => 'tcp',        'udp'   => 'udp',        'unix'  => 'unix',        'ssl'   => 'ssl',        'sslv2' => 'sslv2',        'sslv3' => 'sslv3',        'tls'   => 'tls'    );    /**     * Construct.     *     * @param string $remote_address     * @param array $context_option     * @throws Exception     */    public function __construct($remote_address, array $context_option = array())    {        $address_info = \parse_url($remote_address);        if (!$address_info) {            list($scheme, $this->_remoteAddress) = \explode(':', $remote_address, 2);            if (!$this->_remoteAddress) {                Worker::safeEcho(new \Exception('bad remote_address'));            }        } else {            if (!isset($address_info['port'])) {                $address_info['port'] = 0;            }            if (!isset($address_info['path'])) {                $address_info['path'] = '/';            }            if (!isset($address_info['query'])) {                $address_info['query'] = '';            } else {                $address_info['query'] = '?' . $address_info['query'];            }            $this->_remoteAddress = ""{$address_info['host']}:{$address_info['port']}"";            $this->_remoteHost    = $address_info['host'];            $this->_remotePort    = $address_info['port'];            $this->_remoteURI     = ""{$address_info['path']}{$address_info['query']}"";            $scheme               = isset($address_info['scheme']) ? $address_info['scheme'] : 'tcp';        }        $this->id = $this->_id = self::$_idRecorder++;        if(\PHP_INT_MAX === self::$_idRecorder){            self::$_idRecorder = 0;        }        // Check application layer protocol class.        if (!isset(self::$_builtinTransports[$scheme])) {            $scheme         = \ucfirst($scheme);            $this->protocol = '\\Protocols\\' . $scheme;            if (!\class_exists($this->protocol)) {                $this->protocol = ""\\Workerman\\Protocols\\$scheme"";                if (!\class_exists($this->protocol)) {                    throw new Exception(""class \\Protocols\\$scheme not exist"");                }            }        } else {            $this->transport = self::$_builtinTransports[$scheme];        }        // For statistics.        ++self::$statistics['connection_count'];        $this->maxSendBufferSize         = self::$defaultMaxSendBufferSize;        $this->maxPackageSize            = self::$defaultMaxPackageSize;        $this->_contextOption            = $context_option;        static::$connections[$this->_id] = $this;    }    /**     * Do connect.     *     * @return void     */    public function connect()    {        if ($this->_status !== self::STATUS_INITIAL && $this->_status !== self::STATUS_CLOSING &&            $this->_status !== self::STATUS_CLOSED) {            return;        }        $this->_status           = self::STATUS_CONNECTING;        $this->_connectStartTime = \microtime(true);        if ($this->transport !== 'unix') {            if (!$this->_remotePort) {                $this->_remotePort = $this->transport === 'ssl' ? 443 : 80;                $this->_remoteAddress = $this->_remoteHost.':'.$this->_remotePort;            }            // Open socket connection asynchronously.            if ($this->_contextOption) {                $context = \stream_context_create($this->_contextOption);                $this->_socket = \stream_socket_client(""tcp://{$this->_remoteHost}:{$this->_remotePort}"",                    $errno, $errstr, 0, \STREAM_CLIENT_ASYNC_CONNECT, $context);            } else {                $this->_socket = \stream_socket_client(""tcp://{$this->_remoteHost}:{$this->_remotePort}"",                    $errno, $errstr, 0, \STREAM_CLIENT_ASYNC_CONNECT);            }        } else {            $this->_socket = \stream_socket_client(""{$this->transport}://{$this->_remoteAddress}"", $errno, $errstr, 0,                \STREAM_CLIENT_ASYNC_CONNECT);        }        // If failed attempt to emit onError callback.        if (!$this->_socket || !\is_resource($this->_socket)) {            $this->emitError(\WORKERMAN_CONNECT_FAIL, $errstr);            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }            return;        }        // Add socket to global event loop waiting connection is successfully established or faild.        Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'checkConnection'));        // For windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_EXCEPT, array($this, 'checkConnection'));        }    }    /**     * Reconnect.     *     * @param int $after     * @return void     */    public function reconnect($after = 0)    {        $this->_status                   = self::STATUS_INITIAL;        static::$connections[$this->_id] = $this;        if ($this->_reconnectTimer) {            Timer::del($this->_reconnectTimer);        }        if ($after > 0) {            $this->_reconnectTimer = Timer::add($after, array($this, 'connect'), null, false);            return;        }        $this->connect();    }    /**     * CancelReconnect.     */    public function cancelReconnect()    {        if ($this->_reconnectTimer) {            Timer::del($this->_reconnectTimer);        }    }    /**     * Get remote address.     *     * @return string     */    public function getRemoteHost()    {        return $this->_remoteHost;    }    /**     * Get remote URI.     *     * @return string     */    public function getRemoteURI()    {        return $this->_remoteURI;    }    /**     * Try to emit onError callback.     *     * @param int    $code     * @param string $msg     * @return void     */    protected function emitError($code, $msg)    {        $this->_status = self::STATUS_CLOSING;        if ($this->onError) {            try {                \call_user_func($this->onError, $this, $code, $msg);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }    /**     * Check connection is successfully established or faild.     *     * @param resource $socket     * @return void     */    public function checkConnection()    {        // Remove EV_EXPECT for windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->del($this->_socket, EventInterface::EV_EXCEPT);        }        // Remove write listener.        Worker::$globalEvent->del($this->_socket, EventInterface::EV_WRITE);        if ($this->_status !== self::STATUS_CONNECTING) {            return;        }        // Check socket state.        if ($address = \stream_socket_get_name($this->_socket, true)) {            // Nonblocking.            \stream_set_blocking($this->_socket, false);            // Compatible with hhvm            if (\function_exists('stream_set_read_buffer')) {                \stream_set_read_buffer($this->_socket, 0);            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && $this->transport === 'tcp') {                $raw_socket = \socket_import_stream($this->_socket);                \socket_set_option($raw_socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($raw_socket, \SOL_TCP, \TCP_NODELAY, 1);            }            // SSL handshake.            if ($this->transport === 'ssl') {                $this->_sslHandshakeCompleted = $this->doSslHandshake($this->_socket);                if ($this->_sslHandshakeCompleted === false) {                    return;                }            } else {                // There are some data waiting to send.                if ($this->_sendBuffer) {                    Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'baseWrite'));                }            }            // Register a listener waiting read event.            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));            $this->_status                = self::STATUS_ESTABLISHED;            $this->_remoteAddress         = $address;            // Try to emit onConnect callback.            if ($this->onConnect) {                try {                    \call_user_func($this->onConnect, $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }            // Try to emit protocol::onConnect            if ($this->protocol && \method_exists($this->protocol, 'onConnect')) {                try {                    \call_user_func(array($this->protocol, 'onConnect'), $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }        } else {            // Connection failed.            $this->emitError(\WORKERMAN_CONNECT_FAIL, 'connect ' . $this->_remoteAddress . ' fail after ' . round(\microtime(true) - $this->_connectStartTime, 4) . ' seconds');            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,2,0,1,0,0,0,0,0,0,0,0,0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7760, Write statistics data to disk.\n\n @return void\n,Sačuvaj statističke podatke na disk.,"    protected static function writeConnectionsStatisticsToStatusFile()    {        // For master process.        if (static::$_masterPid === \posix_getpid()) {            \file_put_contents(static::$_statisticsFile, ""--------------------------------------------------------------------- WORKERMAN CONNECTION STATUS --------------------------------------------------------------------------------\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile, ""PID      Worker          CID       Trans   Protocol        ipv4   ipv6   Recv-Q       Send-Q       Bytes-R      Bytes-W       Status         Local Address          Foreign Address\n"", \FILE_APPEND);            \chmod(static::$_statisticsFile, 0722);            foreach (static::getAllWorkerPids() as $worker_pid) {                \posix_kill($worker_pid, \SIGIO);            }            return;        }        // For child processes.        $bytes_format = function($bytes)        {            if($bytes > 1024*1024*1024*1024) {                return round($bytes/(1024*1024*1024*1024), 1).""TB"";            }            if($bytes > 1024*1024*1024) {                return round($bytes/(1024*1024*1024), 1).""GB"";            }            if($bytes > 1024*1024) {                return round($bytes/(1024*1024), 1).""MB"";            }            if($bytes > 1024) {                return round($bytes/(1024), 1).""KB"";            }            return $bytes.""B"";        };        $pid = \posix_getpid();        $str = '';        \reset(static::$_workers);        $current_worker = current(static::$_workers);        $default_worker_name = $current_worker->name;        /** @var \Workerman\Worker $worker */        foreach(TcpConnection::$connections as $connection) {            /** @var \Workerman\Connection\TcpConnection $connection */            $transport      = $connection->transport;            $ipv4           = $connection->isIpV4() ? ' 1' : ' 0';            $ipv6           = $connection->isIpV6() ? ' 1' : ' 0';            $recv_q         = $bytes_format($connection->getRecvBufferQueueSize());            $send_q         = $bytes_format($connection->getSendBufferQueueSize());            $local_address  = \trim($connection->getLocalAddress());            $remote_address = \trim($connection->getRemoteAddress());            $state          = $connection->getStatus(false);            $bytes_read     = $bytes_format($connection->bytesRead);            $bytes_written  = $bytes_format($connection->bytesWritten);            $id             = $connection->id;            $protocol       = $connection->protocol ? $connection->protocol : $connection->transport;            $pos            = \strrpos($protocol, '\\');            if ($pos) {                $protocol = \substr($protocol, $pos+1);            }            if (\strlen($protocol) > 15) {                $protocol = \substr($protocol, 0, 13) . '..';            }            $worker_name = isset($connection->worker) ? $connection->worker->name : $default_worker_name;            if (\strlen($worker_name) > 14) {                $worker_name = \substr($worker_name, 0, 12) . '..';            }            $str .= \str_pad($pid, 9) . \str_pad($worker_name, 16) .  \str_pad($id, 10) . \str_pad($transport, 8)                . \str_pad($protocol, 16) . \str_pad($ipv4, 7) . \str_pad($ipv6, 7) . \str_pad($recv_q, 13)                . \str_pad($send_q, 13) . \str_pad($bytes_read, 13) . \str_pad($bytes_written, 13) . ' '                . \str_pad($state, 14) . ' ' . \str_pad($local_address, 22) . ' ' . \str_pad($remote_address, 22) .""\n"";        }        if ($str) {            \file_put_contents(static::$_statisticsFile, $str, \FILE_APPEND);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0
matomo-org_matomo_BaseFactory_116, Should return a message to use in an Exception when an invalid class ID is supplied to\\n {@link factory()}.\\n,Vraća naziv izuzetka za prosleđeni id.,"    protected static function getInvalidClassIdExceptionMessage($id)    {        return ""Invalid class ID '$id' for "" . get_called_class() . ""::factory()."";    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_8699, Check connection is successfully established or faild.\n\n @param resource $socket\n @return void\n,Proveri da li je konekcija uspostavljena ili ne.,"    public function checkConnection()    {        // Remove EV_EXPECT for windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->del($this->_socket, EventInterface::EV_EXCEPT);        }        // Remove write listener.        Worker::$globalEvent->del($this->_socket, EventInterface::EV_WRITE);        if ($this->_status !== self::STATUS_CONNECTING) {            return;        }        // Check socket state.        if ($address = \stream_socket_get_name($this->_socket, true)) {            // Nonblocking.            \stream_set_blocking($this->_socket, false);            // Compatible with hhvm            if (\function_exists('stream_set_read_buffer')) {                \stream_set_read_buffer($this->_socket, 0);            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && $this->transport === 'tcp') {                $raw_socket = \socket_import_stream($this->_socket);                \socket_set_option($raw_socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($raw_socket, \SOL_TCP, \TCP_NODELAY, 1);            }            // SSL handshake.            if ($this->transport === 'ssl') {                $this->_sslHandshakeCompleted = $this->doSslHandshake($this->_socket);                if ($this->_sslHandshakeCompleted === false) {                    return;                }            } else {                // There are some data waiting to send.                if ($this->_sendBuffer) {                    Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'baseWrite'));                }            }            // Register a listener waiting read event.            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));            $this->_status                = self::STATUS_ESTABLISHED;            $this->_remoteAddress         = $address;            // Try to emit onConnect callback.            if ($this->onConnect) {                try {                    \call_user_func($this->onConnect, $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }            // Try to emit protocol::onConnect            if ($this->protocol && \method_exists($this->protocol, 'onConnect')) {                try {                    \call_user_func(array($this->protocol, 'onConnect'), $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }        } else {            // Connection failed.            $this->emitError(\WORKERMAN_CONNECT_FAIL, 'connect ' . $this->_remoteAddress . ' fail after ' . round(\microtime(true) - $this->_connectStartTime, 4) . ' seconds');            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_798, Set the layout key with the liable value\n example : (firstname) => 'Presta' will result (Presta)\n         : (firstname-lastname) => 'Presta' and 'Shop' result '(Presta-Shop)'.\n,Postavi izgled ključa sa pouzdanom vrednošću.,"    protected static function _setOriginalDisplayFormat(&$formattedValueList, $currentLine, $currentKeyList)    {        if ($currentKeyList && is_array($currentKeyList)) {            if ($originalFormattedPatternList = explode(' ', $currentLine)) {                // Foreach the available pattern                foreach ($originalFormattedPatternList as $patternNum => $pattern) {                    // Var allows to modify the good formatted key value when multiple key exist into the same pattern                    $mainFormattedKey = '';                    // Multiple key can be found in the same pattern                    foreach ($currentKeyList as $key) {                        // Check if we need to use an older modified pattern if a key has already be matched before                        $replacedValue = empty($mainFormattedKey) ? $pattern : $formattedValueList[$mainFormattedKey];                        $chars = $start = $end = str_replace($key, '', $replacedValue);                        if (preg_match(self::_CLEANING_REGEX_, $chars)) {                            if (Tools::substr($replacedValue, 0, Tools::strlen($chars)) == $chars) {                                $end = '';                            } else {                                $start = '';                            }                            if ($chars) {                                $replacedValue = str_replace($chars, '', $replacedValue);                            }                        }                        if ($formattedValue = preg_replace('/^' . $key . '$/', $formattedValueList[$key], $replacedValue, -1, $count)) {                            if ($count) {                                // Allow to check multiple key in the same pattern,                                if (empty($mainFormattedKey)) {                                    $mainFormattedKey = $key;                                }                                // Set the pattern value to an empty string if an older key has already been matched before                                if ($mainFormattedKey != $key) {                                    $formattedValueList[$key] = '';                                }                                // Store the new pattern value                                $formattedValueList[$mainFormattedKey] = $start . $formattedValue . $end;                                unset($originalFormattedPatternList[$patternNum]);                            }                        }                    }                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
