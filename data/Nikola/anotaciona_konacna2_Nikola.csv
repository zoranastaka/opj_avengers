pair_id,comment,Komentar,code,"upit
","pretvaranje int u string
","red sa prioritetom
","pretvaranje string u datum
","sortiranje string liste
","Äuvanje liste u datoteku
","postgresql konekcija
","konfuziona matrica
","postavljanje radnog direktorijuma
","grupisanje po izbrojanim podacima
","binomna raspodela
","aes Å¡ifrovanje
","linearna regresija
","vreme tolerisanja za prijem na soketu
","upisivanje u csv datoteku
","pretvaranje decimalnog u heksadecimalni broj
","izvoz podataka u excel
","dijagram rasejanja
","pretvaranje json u csv
","lepo ispiÅ¡i json
","zamena delova datoteke
","klasterizacija metodom k-srednjih vrednosti
","povezivanje na sql server
","html Å¡ifrovan string
","odreÄ‘ivanje proteklog vremena koriÅ¡Ä‡enjem Äasovnika
","parsiranje binarne datoteke u prilagoÄ‘enu klasu
","dohvatanje trenutne ip adrese
","pretvaranje int u bool
","isÄitavanje tekstualne datoteke liniju po liniju
","dohvatanje putanje izvrÅ¡avanja
","odprema json datoteke pomoÄ‡u HttpClient POST zahteva
","dohvatanje unutraÅ¡njeg svojstva html taga
","pretvaranje string u broj
","formatiranje datuma
","nepromenjivi (readonly) niz
","filtriranje niza
","mapa u json
","parsiranje json datoteke
","dohvati trenutnu vrednost posmatraÄa
","dohvati naziv za vrednost enumerisanog tipa podatka
","Å¡ifriraj url
","kreiraj kolaÄiÄ‡
","kako isprazniti niz
","kako dohvatiti danaÅ¡nji datum
","kako Å¡tiklirati checkbox
","inicijalizacija niza
","kako obrnuti string
","proÄitaj svojstva datoteke
","prekopiraj u klibord
","pretvaranje html stranice u pdf
","konverzija json u xml datoteku
","kako nasumiÄno izabrati broj
","normalna raspodela
","Nelder-Mead optimizacija
","hashset za odreÄ‘ivanje broja razliÄitih elemenata
","kako dohvatiti naziv tabele iz baze
","deserializacija json-a
","pronaÄ‘i int unutar stringa
","dohvatanje jedinstvenog identifikatora trenutnog procesa
","regex ne razlikuje velika i mala slova
","prilagoÄ‘eni http odgovor greÅ¡ke
","kako odrediti da li je string valida reÄ
","zamena http entiteta
","sakrij atribute datoteke
","sortiraj viÅ¡e nizova na osnovu redosleda drugih sortiranih nizova
","levenshteinova slicnost stringova
","kako dohvatiti html kod sa veb sajta
","baferisano Äitanje teksta ÄitaÄem fajlova
","aes Å¡ifrovanje u ctr naÄinu rada
","matrica mnoÅ¾enja
","Å¡tampanje rezimea modela
","jedinstveni elementi
","izvlaÄenje podataka iz sadrÅ¾aja html koda
","toplotna mapa iz 3d koordinata
","dohvatanje svih roditelja xml Ävora
","kako rekurzivno raspakovati zip datoteku
","podvuci tekst u label vidÅ¾etu
","raspakivanje velikih datoteka
","kopiranje putanje fajla
","dohvati opis http statusnog koda
","nasumiÄno izvuci x stavki iz liste
","konvertuj string datum u yyyymmdd format
","pretvoriti utc vreme u epohu
","sve permutacije liste
","izvuci geografsku Å¡irinu i duÅ¾inu iz datog unosa
","kako proveriti da je checkbox Å¡tikliran
","pretvoriti uint8 niz u sliku
","memoizacija na disk - persistentna memoizacija
","parsiranje argumenata komandne linije
","kako proÄitati sadrÅ¾aj iz .gz zapakovanog fajla
","slanje binarnih podataka preko seriske veze
","otpakovanje podataka iz tekstualne datoteke
","pozicije podstingova u stringu
","Äitanje elemenata iz html-a - <td>
","oduzimanje medijana iz svake kolone
","uklanjanja zaglavlja prilikom spajanja nekoliko datoteka
","parsiranje query stringa u url-u
","rangiranje fazi Älanova na osnovu stepena podudaranja
","izlaz u html datoteku
",kako efikasno proÄitati .csv datoteku
cakephp_cakephp_BaseAuthenticate_1177, Get query object for fetching user from database.\\\\n\\\\n @param string $username The username/identifier.\\\\n @return \\\\\\\\Cake\\\\\\\\ORM\\\\\\\\Query\\\\n,Dohvatanje objekta iz upita radi preuzimanja podataka o korisniku iz baze podataka,"    protected function _query(string $username): Query    {        $config = $this->_config;        $table = $this->getTableLocator()->get($config['userModel']);        $options = [            'conditions' => [$table->aliasField($config['fields']['username']) => $username],        ];        $finder = $config['finder'];        if (is_array($finder)) {            $options += current($finder);            $finder = key($finder);        }        if (!isset($options['username'])) {            $options['username'] = $username;        }        return $table->find($finder, $options);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Alias_810, Get all found aliases from DB with search query.\\n\\n @return string Comma separated aliases\\n,Dohvatanje svih pronađenih pseudonima iz baze podataka pomoću upita za pretragu,"    public function getAliases()    {        if (!Alias::isFeatureActive()) {            return '';        }        $aliases = Db::getInstance()->executeS('SELECT a.aliasFROM `' . _DB_PREFIX_ . 'alias` aWHERE `search` = \'' . pSQL($this->search) . '\'');        $aliases = array_map('implode', $aliases);        return implode(', ', $aliases);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2416, Retrieves all annotations for a user.\n\n @param int $userId\n\n @return QueryBuilder\n,Dohvata sve napomene za korisnika,"    public function findAnnotationsByPageId($entryId, $userId)    {        return $this->createQueryBuilder('a')            ->where('a.entry = :entryId')->setParameter('entryId', $entryId)            ->andwhere('a.user = :userId')->setParameter('userId', $userId)            ->getQuery()            ->getResult()        ;    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7937, Generates a normalized URI (URL) for the Request.\n\n @return string A normalized URI (URL) for the Request\n\n @see getQueryString()\n,Generiše normalizovani URI (URL) za zahtev,    public function getUri()    {        if (null !== $qs = $this->getQueryString()) {            $qs = '?'.$qs;        }        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;    },2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_786, Returns Address ID for a given Supplier ID.\\n\\n @since 1.5.0\\n\\n @param int $id_supplier Supplier ID\\n\\n @return int $id_address Address ID\\n,Vraća ID adrese za dati ID dobavljača,    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    },3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_787, Check if the alias already exists.\\\\n\\\\n @param string $alias Alias of an address\\\\n @param int $id_address Address id\\\\n @param int $id_customer Customer id\\\\n\\\\n @return false|string|null Amount of aliases found\\\\n @todo: Find out if we shouldn't be returning an int instead? (breaking change)\\\\n,Proverava da li pseudonim već postoji,"    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Alias_812, This method is allow to know if a alias exist for AdminImportController.\\\\\\\\n\\\\\\\\n @param int $idAlias Alias ID\\\\\\\\n\\\\\\\\n @return bool\\\\\\\\n\\\\\\\\n @since 1.5.6.0\\\\\\\\n,Ovaj metod dozvoljava da se zna postoji li pseudonim za AdminImportController,"    public static function aliasExists($idAlias)    {        $sql = new DbQuery();        $sql->select('a.`id_alias`');        $sql->from('alias', 'a');        $sql->where('a.`id_alias` = ' . (int) $idAlias);        $row = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow($sql, false);        return isset($row['id_alias']);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1205," This attempts to find media, other files, and download them\n\n @param string $path\n @return PageInterface|false\n","Pokušava da pronađe medije, druge datoteke i preuzme ih","    public function fallbackUrl($path)    {        $this->fireEvent('onPageFallBackUrl');        /** @var Uri $uri */        $uri = $this['uri'];        /** @var Config $config */        $config = $this['config'];        $uri_extension = strtolower($uri->extension());        $fallback_types = $config->get('system.media.allowed_fallback_types', null);        $supported_types = $config->get('media.types');        // Check whitelist first, then ensure extension is a valid media type        if (!empty($fallback_types) && !in_array($uri_extension, $fallback_types, true)) {            return false;        }        if (!array_key_exists($uri_extension, $supported_types)) {            return false;        }        $path_parts = pathinfo($path);        /** @var Pages $pages */        $pages = $this['pages'];        $page = $pages->find($path_parts['dirname'], true);        if ($page) {            $media = $page->media()->all();            $parsed_url = parse_url(rawurldecode($uri->basename()));            $media_file = $parsed_url['path'];            // if this is a media object, try actions first            if (isset($media[$media_file])) {                /** @var Medium $medium */                $medium = $media[$media_file];                foreach ($uri->query(null, true) as $action => $params) {                    if (in_array($action, ImageMedium::$magic_actions, true)) {                        call_user_func_array([&$medium, $action], explode(',', $params));                    }                }                Utils::download($medium->path(), false);            }            // unsupported media type, try to download it...            if ($uri_extension) {                $extension = $uri_extension;            } else {                if (isset($path_parts['extension'])) {                    $extension = $path_parts['extension'];                } else {                    $extension = null;                }            }            if ($extension) {                $download = true;                if (in_array(ltrim($extension, '.'), $config->get('system.media.unsupported_inline_types', []), true)) {                    $download = false;                }                Utils::download($page->path() . DIRECTORY_SEPARATOR . $uri->basename(), $download);            }            // Nothing found            return false;        }        return $page;    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Client_9, Applies the array of request options to a request.\\n,Primenjuje niz opcionih zahteva na zahtev,"    private function applyOptions(RequestInterface $request, array &$options): RequestInterface    {        $modify = [            'set_headers' => [],        ];        if (isset($options['headers'])) {            $modify['set_headers'] = $options['headers'];            unset($options['headers']);        }        if (isset($options['form_params'])) {            if (isset($options['multipart'])) {                throw new InvalidArgumentException('You cannot use '                    . 'form_params and multipart at the same time. Use the '                    . 'form_params option if you want to send application/'                    . 'x-www-form-urlencoded requests, and the multipart '                    . 'option to send multipart/form-data requests.');            }            $options['body'] = \http_build_query($options['form_params'], '', '&');            unset($options['form_params']);            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'application/x-www-form-urlencoded';        }        if (isset($options['multipart'])) {            $options['body'] = new Psr7\MultipartStream($options['multipart']);            unset($options['multipart']);        }        if (isset($options['json'])) {            $options['body'] = Utils::jsonEncode($options['json']);            unset($options['json']);            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'application/json';        }        if (!empty($options['decode_content'])            && $options['decode_content'] !== true        ) {            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Accept-Encoding'], $options['_conditional']);            $modify['set_headers']['Accept-Encoding'] = $options['decode_content'];        }        if (isset($options['body'])) {            if (\is_array($options['body'])) {                throw $this->invalidBody();            }            $modify['body'] = Psr7\Utils::streamFor($options['body']);            unset($options['body']);        }        if (!empty($options['auth']) && \is_array($options['auth'])) {            $value = $options['auth'];            $type = isset($value[2]) ? \strtolower($value[2]) : 'basic';            switch ($type) {                case 'basic':                    // Ensure that we don't have the header in different case and set the new value.                    $modify['set_headers'] = Psr7\Utils::caselessRemove(['Authorization'], $modify['set_headers']);                    $modify['set_headers']['Authorization'] = 'Basic '                        . \base64_encode(""$value[0]:$value[1]"");                    break;                case 'digest':                    // @todo: Do not rely on curl                    $options['curl'][\CURLOPT_HTTPAUTH] = \CURLAUTH_DIGEST;                    $options['curl'][\CURLOPT_USERPWD] = ""$value[0]:$value[1]"";                    break;                case 'ntlm':                    $options['curl'][\CURLOPT_HTTPAUTH] = \CURLAUTH_NTLM;                    $options['curl'][\CURLOPT_USERPWD] = ""$value[0]:$value[1]"";                    break;            }        }        if (isset($options['query'])) {            $value = $options['query'];            if (\is_array($value)) {                $value = \http_build_query($value, '', '&', \PHP_QUERY_RFC3986);            }            if (!\is_string($value)) {                throw new InvalidArgumentException('query must be a string or array');            }            $modify['query'] = $value;            unset($options['query']);        }        // Ensure that sink is not an invalid value.        if (isset($options['sink'])) {            // TODO: Add more sink validation?            if (\is_bool($options['sink'])) {                throw new InvalidArgumentException('sink must not be a boolean');            }        }        $request = Psr7\Utils::modifyRequest($request, $modify);        if ($request->getBody() instanceof Psr7\MultipartStream) {            // Use a multipart/form-data POST if a Content-Type is not set.            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'multipart/form-data; boundary='                . $request->getBody()->getBoundary();        }        // Merge in conditional headers if they are not present.        if (isset($options['_conditional'])) {            // Build up the changes so it's in a single clone of the message.            $modify = [];            foreach ($options['_conditional'] as $k => $v) {                if (!$request->hasHeader($k)) {                    $modify['set_headers'][$k] = $v;                }            }            $request = Psr7\Utils::modifyRequest($request, $modify);            // Don't pass this internal value along to middleware/handlers.            unset($options['_conditional']);        }        return $request;    }",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_InvalidVisits_265, Adds one site and sends several invalid tracking requests. The result should be\\n one website with no visits.\\n,Dodaje jedan vebsajt i šalje nekoliko nevažećih zahteva za praćenje. Rezultat bi trebalo da bude jedan vebsajt bez poseta,"class InvalidVisits extends Fixture{    public $idSite = 1;    public $dateTime = '2009-01-04 00:11:42';    public $trackInvalidRequests = true;    public function setUp(): void    {        $this->setUpWebsitesAndGoals();        $this->trackVisits();    }    public function tearDown(): void    {        // empty    }    private function setUpWebsitesAndGoals()    {        if (!self::siteCreated($idSite = 1)) {            self::createWebsite($this->dateTime);        }    }    private function trackVisits()    {        if (!$this->trackInvalidRequests) {            return;        }        $dateTime = $this->dateTime;        $idSite = $this->idSite;        API::getInstance()->setGlobalExcludedUserAgents('globalexcludeduseragent');        Cache::regenerateCacheWebsiteAttributes([1]);        // Trigger empty request        $trackerUrl = self::getTrackerUrl();        $response = Http::fetchRemoteFile($trackerUrl);        self::assertTrue(strpos($response, 'Keep full control of your data with the leading free') !== false, 'Piwik empty request response not correct: ' . $response);        $t = self::getTracker($idSite, $dateTime, $defaultInit = true);        // test GoogleBot UA visitor        $t->setUserAgent('Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)');        self::checkResponse($t->doTrackPageView('bot visit, please do not record'));        // Test IP Exclusion works with or without IP exclusion        foreach (array(false, true) as $enable) {            $excludedIp = '154.1.12.34';            API::getInstance()->updateSite($idSite, 'new site name', $url = array('http://site.com'), $ecommerce = 0, $ss = 1, $ss_kwd = '', $ss_cat = '', $excludedIp . ',1.2.3.4', $excludedQueryParameters = null, $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = 'excludeduseragentstring');            Cache::regenerateCacheWebsiteAttributes([1]);            // Enable IP Anonymization            $t->DEBUG_APPEND_URL = '&forceIpAnonymization=' . (int)$enable;            // test with excluded User Agent            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729) (excludeduseragentstring)');            $t->setIp('211.1.2.3');            self::checkResponse($t->doTrackPageView('visit from excluded User Agent'));            $t->setUserAgent('Mozilla/5.0 (Windows NT 6.1; rv:6.0) Gecko/20110814 Firefox/6.0 Google (+https://developers.google.com/+/web/snippet/)');            self::checkResponse($t->doTrackPageView('visit from excluded User Agent'));            // test w/ global excluded User Agent            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729) (globalexcludeduseragent)');            $t->setIp('211.1.2.3');            self::checkResponse($t->doTrackPageView('visit from global excluded User Agent'));            // test with excluded IP            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729)'); // restore normal user agent            $t->setIp($excludedIp);            self::checkResponse($t->doTrackPageView('visit from IP excluded'));            // test with global list of excluded IPs            $excludedIpBis = '145.5.3.4';            API::getInstance()->setGlobalExcludedIps($excludedIpBis);            Cache::regenerateCacheWebsiteAttributes([1]);            $t->setIp($excludedIpBis);            self::checkResponse($t->doTrackPageView('visit from IP globally excluded'));        }        // test unknown url exclusion works        $urls = array(""http://piwik.net"", ""http://my.stuff.com/"");        API::getInstance()->updateSite($idSite, $siteName = null, $urls, $ecommerce = null, $siteSearch = null,            $searchKeywordParameters = null, $searchCategoryParameters = null, $excludedIps = null, $excludedQueryParams = null,            $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = null,            $keepUrlFragments = null, $type = null, $settings = null, $excludeUnknownUrls = 1);        Cache::regenerateCacheWebsiteAttributes([1]);        $t->setIp(""125.4.5.6"");        $t->setUrl(""http://piwik.com/to/the/moon"");        $t->doTrackPageView(""ignored, not from piwik.net"");        $t->setUrl(""http://their.stuff.com/back/to/the/future"");        $t->doTrackPageView(""ignored, not from my.stuff.com"");        // undo exclude unknown urls change (important when multiple fixtures are setup together, as is done in OmniFixture)        API::getInstance()->updateSite($idSite, $siteName = null, $urls, $ecommerce = null, $siteSearch = null,            $searchKeywordParameters = null, $searchCategoryParameters = null, $excludedIps = null, $excludedQueryParams = null,            $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = null,            $keepUrlFragments = null, $type = null, $settings = null, $excludeUnknownUrls = 0);        Cache::regenerateCacheWebsiteAttributes([1]);        try {            @$t->setAttributionInfo(array());            self::fail();        } catch (Exception $e) {        }        try {            $t->setAttributionInfo(json_encode('test'));            self::fail();        } catch (Exception $e) {        }        $t->setAttributionInfo(json_encode(array()));    }}",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_RowEvolution_242," This class generates a Row evolution dataset, from input request\\n\\n",Ova klasa generiše niz podataka o evoluciji redova na osnovu unetog zahteva,"class RowEvolution{    private static $actionsUrlReports = array(        'getPageUrls',        'getPageUrlsFollowingSiteSearch',        'getEntryPageUrls',        'getExitPageUrls',        'getPageUrl'    );    public function getRowEvolution($idSite, $period, $date, $apiModule, $apiAction, $label = false, $segment = false, $column = false, $language = false, $apiParameters = array(), $legendAppendMetric = true, $labelUseAbsoluteUrl = true, $labelSeries = '')    {        // validation of requested $period & $date        if ($period == 'range') {            // load days in the range            $period = 'day';        }        if (!Period::isMultiplePeriod($date, $period)) {            throw new Exception(""Row evolutions can not be processed with this combination of \'date\' and \'period\' parameters."");        }        $label = DataTablePostProcessor::unsanitizeLabelParameter($label);        $labels = Piwik::getArrayFromApiParameter($label, $onlyUnique = empty($labelSeries));        $metadata = $this->getRowEvolutionMetaData($idSite, $period, $date, $apiModule, $apiAction, $language, $apiParameters);        $dataTable = $this->loadRowEvolutionDataFromAPI($metadata, $idSite, $period, $date, $apiModule, $apiAction, $labels, $segment, $apiParameters);        if (empty($dataTable->getDataTables())) {            return array();        }        if (empty($labels)) {            $labels = $this->getLabelsFromDataTable($dataTable, $labels);            $dataTable = $this->enrichRowAddMetadataLabelIndex($labels, $dataTable);        }        if (count($labels) != 1) {            $data = $this->getMultiRowEvolution(                $dataTable,                $metadata,                $apiModule,                $apiAction,                $labels,                $column,                $legendAppendMetric,                $labelUseAbsoluteUrl,                $labelSeries            );        } else {            $data = $this->getSingleRowEvolution(                $idSite,                $dataTable,                $metadata,                $apiModule,                $apiAction,                $labels[0],                $labelUseAbsoluteUrl            );        }        return $data;    }    /**     * @param array $labels     * @param DataTable\Map $dataTable     * @return mixed     */    protected function enrichRowAddMetadataLabelIndex($labels, $dataTable)    {        // set label index metadata        $labelsToIndex = array_flip($labels);        foreach ($dataTable->getDataTables() as $table) {            foreach ($table->getRows() as $row) {                $label = $row->getColumn('label');                if (isset($labelsToIndex[$label])) {                    $row->setMetadata(LabelFilter::FLAG_IS_ROW_EVOLUTION, $labelsToIndex[$label]);                }            }        }        return $dataTable;    }    /**     * @param DataTable\Map $dataTable     * @param array $labels     * @return array     */    protected function getLabelsFromDataTable($dataTable, $labels)    {        // if no labels specified, use all possible labels as list        foreach ($dataTable->getDataTables() as $table) {            $labels = array_merge($labels, $table->getColumn('label'));        }        $labels = array_values(array_unique($labels));        // if the filter_limit query param is set, treat it as a request to limit        // the number of labels used        $limit = Common::getRequestVar('filter_limit', false);        if ($limit != false            && $limit >= 0        ) {            $labels = array_slice($labels, 0, $limit);        }        return $labels;    }    /**     * Get row evolution for a single label     * @param DataTable\Map $dataTable     * @param array $metadata     * @param string $apiModule     * @param string $apiAction     * @param string $label     * @param bool $labelUseAbsoluteUrl     * @return array containing  report data, metadata, label, logo     */    private function getSingleRowEvolution($idSite, $dataTable, $metadata, $apiModule, $apiAction, $label, $labelUseAbsoluteUrl = true)    {        $metricNames = array_keys($metadata['metrics']);        $logo = $actualLabel = false;        $urlFound = false;        foreach ($dataTable->getDataTables() as $subTable) {            /** @var $subTable DataTable */            $subTable->applyQueuedFilters();            if ($subTable->getRowsCount() > 0) {                /** @var $row Row */                $row = $subTable->getFirstRow();                if (!$actualLabel) {                    $logo = $row->getMetadata('logo');                    $actualLabel = $this->getRowUrlForEvolutionLabel($row, $apiModule, $apiAction, $labelUseAbsoluteUrl);                    $urlFound = $actualLabel !== false;                    if (empty($actualLabel)) {                        $actualLabel = $row->getColumn('label');                    }                }                // remove all columns that are not in the available metrics.                // this removes the label as well (which is desired for two reasons: (1) it was passed                // in the request, (2) it would cause the evolution graph to show the label in the legend).                foreach ($row->getColumns() as $column => $value) {                    if (!in_array($column, $metricNames) && $column != 'label_html') {                        $row->deleteColumn($column);                    }                }                $row->deleteMetadata();            }        }        $this->enhanceRowEvolutionMetaData($metadata, $dataTable);        // if we have a recursive label and no url, use the path        if (!$urlFound) {            $actualLabel = $this->formatQueryLabelForDisplay($idSite, $apiModule, $apiAction, $label);        }        $return = array(            'label'      => SafeDecodeLabel::decodeLabelSafe($actualLabel),            'reportData' => $dataTable,            'metadata'   => $metadata        );        if (!empty($logo)) {            $return['logo'] = $logo;        }        return $return;    }    private function formatQueryLabelForDisplay($idSite, $apiModule, $apiAction, $label)    {        // rows with subtables do not contain URL metadata. this hack makes sure the label titles in row        // evolution popovers look like URLs.        if ($apiModule == 'Actions'            && in_array($apiAction, self::$actionsUrlReports)        ) {            $mainUrl = Site::getMainUrlFor($idSite);            $mainUrlHost = @parse_url($mainUrl, PHP_URL_HOST);            $replaceRegex = ""/\\s*"" . preg_quote(LabelFilter::SEPARATOR_RECURSIVE_LABEL) . ""\\s*/"";            $cleanLabel = preg_replace($replaceRegex, '/', $label);            $result = $mainUrlHost . '/' . $cleanLabel . '/';        } else {            $result = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        }        // remove @ terminal operator occurrences        return str_replace(LabelFilter::TERMINAL_OPERATOR, '', $result);    }    /**     * @param Row $row     * @param string $apiModule     * @param string $apiAction     * @param bool $labelUseAbsoluteUrl     * @return bool|string     */    private function getRowUrlForEvolutionLabel($row, $apiModule, $apiAction, $labelUseAbsoluteUrl)    {        $url = $row->getMetadata('url');        if ($url            && ($apiModule == 'Actions'                || ($apiModule == 'Referrers'                    && $apiAction == 'getWebsites'))            && $labelUseAbsoluteUrl        ) {            $actualLabel = preg_replace(';^http(s)?://(www.)?;i', '', $url);            return $actualLabel;        }        return false;    }    /**     * @param array $metadata see getRowEvolutionMetaData()     * @param int $idSite     * @param string $period     * @param string $date     * @param string $apiModule     * @param string $apiAction     * @param string|bool $label     * @param string|bool $segment     * @param array $apiParameters     * @throws Exception     * @return DataTable\Map|DataTable     */    private function loadRowEvolutionDataFromAPI($metadata, $idSite, $period, $date, $apiModule, $apiAction, $label, $segment, $apiParameters)    {        if (!is_array($label)) {            $label = array($label);        }        $label = array_map('rawurlencode', $label);        $parameters = array(            'method'                   => $apiModule . '.' . $apiAction,            'label'                    => $label,            'idSite'                   => $idSite,            'period'                   => $period,            'date'                     => $date,            'format'                   => 'original',            'serialize'                => '0',            'segment'                  => $segment,            // data for row evolution should NOT be limited            'filter_limit'             => -1,            // if more than one label is used, we add metadata to ensure we know which            // row corresponds with which label (since the labels can change, and rows            // can be sorted in a different order)            'labelFilterAddLabelIndex' => count($label) > 1 ? 1 : 0,        );        if (!empty($apiParameters) && is_array($apiParameters)) {            foreach ($apiParameters as $param => $value) {                $parameters[$param] = $value;            }        }        // add ""processed metrics"" like actions per visit or bounce rate        // note: some reports should not be filtered with AddColumnProcessedMetrics        // specifically, reports without the Metrics::INDEX_NB_VISITS metric such as Goals.getVisitsUntilConversion & Goal.getDaysToConversion        // this is because the AddColumnProcessedMetrics filter removes all datable rows lacking this metric        if (isset($metadata['metrics']['nb_visits'])) {            $parameters['filter_add_columns_when_show_all_columns'] = '0';        }        $url = Url::getQueryStringFromParameters($parameters);        $request = new Request($url);        try {            $dataTable = $request->process();        } catch (Exception $e) {            throw new Exception(""API returned an error: "" . $e->getMessage() . ""\n"");        }        return $dataTable;    }    /**     * For a given API report, returns a simpler version     * of the metadata (will return only the metrics and the dimension name)     * @param $idSite     * @param $period     * @param $date     * @param $apiModule     * @param $apiAction     * @param $language     * @param $apiParameters     * @throws Exception     * @return array     */    private function getRowEvolutionMetaData($idSite, $period, $date, $apiModule, $apiAction, $language, $apiParameters)    {        $reportMetadata = API::getInstance()->getMetadata($idSite, $apiModule, $apiAction, $apiParameters, $language,            $period, $date, $hideMetricsDoc = false, $showSubtableReports = true);        if (empty($reportMetadata)) {            throw new Exception(""Requested report $apiModule.$apiAction for Website id=$idSite ""                . ""not found in the list of available reports. \n"");        }        $reportMetadata = reset($reportMetadata);        $metrics = $reportMetadata['metrics'];        if (isset($reportMetadata['processedMetrics']) && is_array($reportMetadata['processedMetrics'])) {            $metrics = $metrics + $reportMetadata['processedMetrics'];        }        if (empty($reportMetadata['dimension'])) {            throw new Exception(sprintf('Reports like %s.%s which do not have a dimension are not supported by row evolution', $apiModule, $apiAction));        }        $dimension = $reportMetadata['dimension'];        return compact('metrics', 'dimension');    }    /**     * Given the Row evolution dataTable, and the associated metadata,     * enriches the metadata with min/max values, and % change between the first period and the last one     * @param array $metadata     * @param DataTable\Map $dataTable     */    private function enhanceRowEvolutionMetaData(&$metadata, $dataTable)    {        // prepare result array for metrics        $metricsResult = array();        foreach ($metadata['metrics'] as $metric => $name) {            $metricsResult[$metric] = array('name' => $name);            if (!empty($metadata['logos'][$metric])) {                $metricsResult[$metric]['logo'] = $metadata['logos'][$metric];            }        }        unset($metadata['logos']);        $subDataTables = $dataTable->getDataTables();        if (empty($subDataTables)) {            throw new \Exception(""Unexpected state: row evolution API call returned empty DataTable\\Map."");        }        $firstDataTable = reset($subDataTables);        $this->checkDataTableInstance($firstDataTable);        $firstDataTableRow = $firstDataTable->getFirstRow();        $lastDataTable = end($subDataTables);        $this->checkDataTableInstance($lastDataTable);        $lastDataTableRow = $lastDataTable->getFirstRow();        // Process min/max values        $firstNonZeroFound = array();        foreach ($subDataTables as $subDataTable) {            // $subDataTable is the report for one period, it has only one row            $firstRow = $subDataTable->getFirstRow();            foreach ($metadata['metrics'] as $metric => $label) {                $value = $firstRow ? floatval($firstRow->getColumn($metric)) : 0;                if ($value > 0) {                    $firstNonZeroFound[$metric] = true;                } else if (!isset($firstNonZeroFound[$metric])) {                    continue;                }                if (!isset($metricsResult[$metric]['min'])                    || $metricsResult[$metric]['min'] > $value                ) {                    $metricsResult[$metric]['min'] = $value;                }                if (!isset($metricsResult[$metric]['max'])                    || $metricsResult[$metric]['max'] < $value                ) {                    $metricsResult[$metric]['max'] = $value;                }            }        }        // Process % change between first/last values        foreach ($metadata['metrics'] as $metric => $label) {            $first = $firstDataTableRow ? floatval($firstDataTableRow->getColumn($metric)) : 0;            $last = $lastDataTableRow ? floatval($lastDataTableRow->getColumn($metric)) : 0;            // do not calculate evolution if the first value is 0 (to avoid divide-by-zero)            if ($first == 0) {                continue;            }            $change = CalculateEvolutionFilter::calculate($last, $first, $quotientPrecision = 0, true, true);            $metricsResult[$metric]['change'] = $change;        }        $metadata['metrics'] = $metricsResult;    }    /** Get row evolution for a multiple labels */    private function getMultiRowEvolution(DataTable\Map $dataTable, $metadata, $apiModule, $apiAction, $labels, $column,                                          $legendAppendMetric = true,                                          $labelUseAbsoluteUrl = true,                                          $labelSeries = '')    {        $labelSeries = explode(',', $labelSeries);        $labelSeries = array_filter($labelSeries, 'strlen');        $labelSeries = array_map('intval', $labelSeries);        if (!isset($metadata['metrics'][$column])) {            // invalid column => use the first one that's available            $metrics = array_keys($metadata['metrics']);            $column = reset($metrics);        }        // get the processed label and logo (if any) for every requested label        $actualLabels = $logos = array();        foreach ($labels as $labelIdx => $label) {            foreach ($dataTable->getDataTables() as $table) {                $labelRow = $this->getRowEvolutionRowFromLabelIdx($table, $labelIdx);                if ($labelRow) {                    $actualLabels[$labelIdx] = $this->getRowUrlForEvolutionLabel(                        $labelRow, $apiModule, $apiAction, $labelUseAbsoluteUrl);                    $prettyLabel = $labelRow->getColumn('label_html');                    if ($prettyLabel !== false) {                        $actualLabels[$labelIdx] = $prettyLabel;                    }                    $logos[$labelIdx] = $labelRow->getMetadata('logo');                    if (!empty($actualLabels[$labelIdx])) {                        break;                    }                }            }            if (empty($actualLabels[$labelIdx])) {                $cleanLabel = $this->cleanOriginalLabel($label);                $actualLabels[$labelIdx] = $cleanLabel;            }            if (isset($labelSeries[$labelIdx])) {                $labelSeriesIndex = $labelSeries[$labelIdx];                $actualLabels[$labelIdx] .= ' ' . DataComparisonFilter::getPrettyComparisonLabelFromSeriesIndex($labelSeriesIndex);            }        }        // convert rows to be array($column.'_'.$labelIdx => $value) as opposed to        // array('label' => $label, 'column' => $value).        $dataTableMulti = $dataTable->getEmptyClone();        foreach ($dataTable->getDataTables() as $tableLabel => $table) {            $newRow = new Row();            foreach ($labels as $labelIdx => $label) {                $row = $this->getRowEvolutionRowFromLabelIdx($table, $labelIdx);                $value = 0;                if ($row) {                    $value = $row->getColumn($column);                    $value = floatVal(str_replace(',', '.', $value));                }                if ($value == '') {                    $value = 0;                }                $newLabel = $column . '_' . (int)$labelIdx;                $newRow->addColumn($newLabel, $value);            }            $newTable = $table->getEmptyClone();            if (!empty($labels)) { // only add a row if the row has data (no labels === no data)                $newTable->addRow($newRow);            }            $dataTableMulti->addTable($newTable, $tableLabel);        }        // the available metrics for the report are returned as metadata / columns        $metadata['columns'] = $metadata['metrics'];        // metadata / metrics should document the rows that are compared        // this way, UI code can be reused        $metadata['metrics'] = array();        foreach ($actualLabels as $labelIndex => $label) {            if ($legendAppendMetric) {                $label .= ' (' . $metadata['columns'][$column] . ')';            }            $metricName = $column . '_' . $labelIndex;            $metadata['metrics'][$metricName] = $label;            if (!empty($logos[$labelIndex])) {                $metadata['logos'][$metricName] = $logos[$labelIndex];            }        }        $this->enhanceRowEvolutionMetaData($metadata, $dataTableMulti);        return array(            'column'     => $column,            'reportData' => $dataTableMulti,            'metadata'   => $metadata        );    }    /**     * Returns the row in a datatable by its LabelFilter::FLAG_IS_ROW_EVOLUTION metadata.     *     * @param DataTable $table     * @param int $labelIdx     * @return Row|false     */    private function getRowEvolutionRowFromLabelIdx($table, $labelIdx)    {        $labelIdx = (int)$labelIdx;        foreach ($table->getRows() as $row) {            if ($row->getMetadata(LabelFilter::FLAG_IS_ROW_EVOLUTION) === $labelIdx) {                return $row;            }        }        return false;    }    /**     * Returns a prettier, more comprehensible version of a row evolution label for display.     */    private function cleanOriginalLabel($label)    {        $label = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        $label = SafeDecodeLabel::decodeLabelSafe($label);        return $label;    }    private function checkDataTableInstance($lastDataTable)    {        if (!($lastDataTable instanceof DataTable)) {            throw new \Exception(""Unexpected state: row evolution returned DataTable\\Map w/ incorrect child table type: "" . get_class($lastDataTable));        }    }}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1354," Sets a value. If the key did not exist before it will be created.\\\\n\\\\n @param string $app app\\\\n @param string $key key\\\\n @param string|float|int $value value\\\\n @return bool True if the value was inserted or updated, false if the value was the same\\\\n",Postavlja vrednost. Ako ključ nije postojao pre nego što će biti kreiran,"public function setValue($app, $key, $value) {return $this->emittingCall(function (&$afterArray) use (&$app, &$key, &$value) {if (!$this->hasKey($app, $key)) {$inserted = (bool) $this->conn->insertIfNotExist('*PREFIX*appconfig', ['appid' => $app,'configkey' => $key,'configvalue' => $value,], ['appid','configkey',]);if ($inserted) {if (!isset($this->cache[$app])) {$this->cache[$app] = [];}$this->cache[$app][$key] = $value;return true;}}$sql = $this->conn->getQueryBuilder();$sql->update('appconfig')->set('configvalue', $sql->createParameter('configvalue'))->where($sql->expr()->eq('appid', $sql->createParameter('app')))->andWhere($sql->expr()->eq('configkey', $sql->createParameter('configkey')))->setParameter('configvalue', $value)->setParameter('app', $app)->setParameter('configkey', $key);/* * Only limit to the existing value for non-Oracle DBs: * http://docs.oracle.com/cd/E11882_01/server.112/e26088/conditions002.htm#i1033286 * > Large objects (LOBs) are not supported in comparison conditions. */if (!($this->conn instanceof \OC\DB\OracleConnection)) {// Only update the value when it is not the same$sql->andWhere($sql->expr()->neq('configvalue', $sql->createParameter('configvalue')))->setParameter('configvalue', $value);}if (isset($this->cache[$app], $this->cache[$app][$key])) {$afterArray['update'] = true;$afterArray['oldvalue'] = $this->cache[$app][$key];}$changedRow = (bool) $sql->execute();$this->cache[$app][$key] = $value;return $changedRow;}, [",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1355, Deletes a key\\\\n\\\\n @param string $app app\\\\n @param string $key key\\\\n @return boolean|null\\\\n,Briše ključ,"public function deleteKey($app, $key) {$this->emittingCall(function () use (&$app, &$key) {$this->loadConfigValues();$sql = $this->conn->getQueryBuilder();$sql->delete('appconfig')->where($sql->expr()->eq('appid', $sql->createParameter('app')))->andWhere($sql->expr()->eq('configkey', $sql->createParameter('configkey')))->setParameter('app', $app)->setParameter('configkey', $key);$sql->execute();unset($this->cache[$app][$key]);return true;}, [",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1356, Remove app from appconfig\n\n @param string $app app\n @return boolean|null\n\n Removes all keys in appconfig belonging to the app.\n,Uklanja aplikaciju iz appconfig,"public function deleteApp($app) {$this->emittingCall(function () use (&$app) {$this->loadConfigValues();$sql = $this->conn->getQueryBuilder();$sql->delete('appconfig')->where($sql->expr()->eq('appid', $sql->createParameter('app')))->setParameter('app', $app);$sql->execute();unset($this->cache[$app]);return true;}, [",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swoft-cloud_swoft_DbSelector_3501, Class DbSelector\n\n @since 2.0\n\n @Bean()\n,Klasa DbSelector,"class DbSelector implements DbSelectorInterface{    /**     * @param Connection $connection     */    public function select(Connection $connection): void    {        $selectIndex  = (int)context()->getRequest()->query('id', 0);        $createDbName = $connection->getDb();        if ($selectIndex == 0) {            $selectIndex = '';        }        if ($createDbName == 'test2') {            $createDbName = 'test';        }        $dbName = sprintf('%s%s', $createDbName, (string)$selectIndex);        $connection->db($dbName);    }}",1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_UploadedFile_9948, Returns the maximum size of an uploaded file as configured in php.ini.\n\n @return int|float The maximum size of an uploaded file in bytes (returns float if size > PHP_INT_MAX)\n,Vraća maksimalnu veličinu učitane datoteke kako je konfigurisana u php.ini fajlu,"final class UrlHelper{    private $requestStack;    private $requestContext;    public function __construct(RequestStack $requestStack, RequestContext $requestContext = null)    {        $this->requestStack = $requestStack;        $this->requestContext = $requestContext;    }    public function getAbsoluteUrl(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $this->getAbsoluteUrlFromContext($path);        }        if ('#' === $path[0]) {            $path = $request->getRequestUri().$path;        } elseif ('?' === $path[0]) {            $path = $request->getPathInfo().$path;        }        if (!$path || '/' !== $path[0]) {            $prefix = $request->getPathInfo();            $last = \strlen($prefix) - 1;            if ($last !== $pos = strrpos($prefix, '/')) {                $prefix = substr($prefix, 0, $pos).'/';            }            return $request->getUriForPath($prefix.$path);        }        return $request->getSchemeAndHttpHost().$path;    }    public function getRelativePath(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $path;        }        return $request->getRelativeUriForPath($path);    }    private function getAbsoluteUrlFromContext(string $path): string    {        if (null === $this->requestContext || '' === $host = $this->requestContext->getHost()) {            return $path;        }        $scheme = $this->requestContext->getScheme();        $port = '';        if ('http' === $scheme && 80 !== $this->requestContext->getHttpPort()) {            $port = ':'.$this->requestContext->getHttpPort();        } elseif ('https' === $scheme && 443 !== $this->requestContext->getHttpsPort()) {            $port = ':'.$this->requestContext->getHttpsPort();        }        if ('#' === $path[0]) {            $queryString = $this->requestContext->getQueryString();            $path = $this->requestContext->getPathInfo().($queryString ? '?'.$queryString : '').$path;        } elseif ('?' === $path[0]) {            $path = $this->requestContext->getPathInfo().$path;        }        if ('/' !== $path[0]) {            $path = rtrim($this->requestContext->getBaseUrl(), '/').'/'.$path;        }        return $scheme.'://'.$host.$port.$path;    }}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_UriSigner_3083, Signs URIs.\n\n @author Fabien Potencier <fabien@symfony.com>\n,Potpisuje URI linkove,"    public function check(string $uri)    {        $url = parse_url($uri);        if (isset($url['query'])) {            parse_str($url['query'], $params);        } else {            $params = [];        }        if (empty($params[$this->parameter])) {            return false;        }        $hash = $params[$this->parameter];        unset($params[$this->parameter]);        return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2087, Get current url.\n\n @return string\n,Preuzmi trenutni url,"class Client extends BaseClient{    /**     * @var string     */    protected $baseUri = 'https://api.weixin.qq.com/cgi-bin/';    /**     * Allow media type.     *     * @var array     */    protected $allowTypes = ['image', 'voice', 'video', 'thumb'];    /**     * Upload image.     *     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadImage($path)    {        return $this->upload('image', $path);    }    /**     * Upload video.     *     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadVideo($path)    {        return $this->upload('video', $path);    }    /**     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadVoice($path)    {        return $this->upload('voice', $path);    }    /**     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadThumb($path)    {        return $this->upload('thumb', $path);    }    /**     * Upload temporary material.     *     * @param string $type     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function upload(string $type, string $path)    {        if (!file_exists($path) || !is_readable($path)) {            throw new InvalidArgumentException(sprintf(""File does not exist, or the file is unreadable: '%s'"", $path));        }        if (!in_array($type, $this->allowTypes, true)) {            throw new InvalidArgumentException(sprintf(""Unsupported media type: '%s'"", $type));        }        return $this->httpUpload('media/upload', ['media' => $path], ['type' => $type]);    }    /**     * @param string $path     * @param string $title     * @param string $description     *     * @return array|\EasyWeChat\Kernel\Support\Collection|object|\Psr\Http\Message\ResponseInterface|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadVideoForBroadcasting(string $path, string $title, string $description)    {        $response = $this->uploadVideo($path);        /** @var array $arrayResponse */        $arrayResponse = $this->detectAndCastResponseToType($response, 'array');        if (!empty($arrayResponse['media_id'])) {            return $this->createVideoForBroadcasting($arrayResponse['media_id'], $title, $description);        }        return $response;    }    /**     * @param string $mediaId     * @param string $title     * @param string $description     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function createVideoForBroadcasting(string $mediaId, string $title, string $description)    {        return $this->httpPostJson('media/uploadvideo', [            'media_id' => $mediaId,            'title' => $title,            'description' => $description,        ]);    }    /**     * Fetch item from WeChat server.     *     * @param string $mediaId     *     * @return \EasyWeChat\Kernel\Http\StreamResponse|\Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function get(string $mediaId)    {        $response = $this->requestRaw('media/get', 'GET', [            'query' => [                'media_id' => $mediaId,            ],        ]);        if (false !== stripos($response->getHeaderLine('Content-disposition'), 'attachment')) {            return StreamResponse::buildFromPsrResponse($response);        }        return $this->castResponseToType($response, $this->app['config']->get('response_type'));    }    /**     * @param string $mediaId     *     * @return array|\EasyWeChat\Kernel\Http\Response|\EasyWeChat\Kernel\Support\Collection|object|\Psr\Http\Message\ResponseInterface|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function getJssdkMedia(string $mediaId)    {        $response = $this->requestRaw('media/get/jssdk', 'GET', [            'query' => [                'media_id' => $mediaId,            ],        ]);        if (false !== stripos($response->getHeaderLine('Content-disposition'), 'attachment')) {            return StreamResponse::buildFromPsrResponse($response);        }        return $this->castResponseToType($response, $this->app['config']->get('response_type'));    }}",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2418, Find annotations for entry id.\\n\\n @param int $entryId\\n @param int $userId\\n\\n @return array\\n,Pronađite napomene za ID unos,"    public function findLastAnnotationByPageId($entryId, $userId)    {        return $this->createQueryBuilder('a')            ->where('a.entry = :entryId')->setParameter('entryId', $entryId)            ->andwhere('a.user = :userId')->setParameter('userId', $userId)            ->orderBy('a.id', 'DESC')            ->setMaxResults(1)            ->getQuery()            ->getOneOrNullResult();    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2419, Remove all annotations for a user id.\\n Used when a user want to reset all informations.\\n\\n @param int $userId\\n,Uklonite sve napomene za korisnički ID. Koristi se kada korisnik žželi da resetuje sve informacije,"    public function removeAllByUserId($userId)    {        $this->getEntityManager()            ->createQuery('DELETE FROM Wallabag\AnnotationBundle\Entity\Annotation a WHERE a.user = :userId')            ->setParameter('userId', $userId)            ->execute();    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2421,Return a query builder to used by other getBuilderFor\\n @param int $userId\\n\\n @return QueryBuilder\\n,Vratite graditelj upita onom koji koristi drugi getBuilderFor,"    private function getSortedQueryBuilderByUser($userId)    {        return $this->createQueryBuilder('a')            ->leftJoin('a.user', 'u')            ->andWhere('u.id = :userId')->setParameter('userId', $userId)            ->orderBy('a.id', 'desc')        ;    }",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
woocommerce_woocommerce_class-wc-breadcrumb_1834, Add crumbs for a term.\n\n @param int    $term_id  Term ID.\n @param string $taxonomy Taxonomy.\n,Dodajte mrvice (crumbs) za pojam,"protected function search_trail() {if ( is_search() ) {/* translators: %s: search term */$this->add_crumb( sprintf( __( 'Search results for &ldquo;%s&rdquo;', 'woocommerce' ), get_search_query() ), remove_query_arg( 'paged' ) );}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_444, Returns classname of given command name\n\n @param  string $name\n @return string\n,Vraća ime klase za ime date komande,"    private function getCommandClassName($name)    {        $name = mb_convert_case($name[0], MB_CASE_UPPER, 'utf-8') . mb_substr($name, 1, mb_strlen($name));                $drivername = $this->getDriverName();        $classnameLocal = sprintf('\Intervention\Image\%s\Commands\%sCommand', $drivername, ucfirst($name));        $classnameGlobal = sprintf('\Intervention\Image\Commands\%sCommand', ucfirst($name));        if (class_exists($classnameLocal)) {            return $classnameLocal;        } elseif (class_exists($classnameGlobal)) {            return $classnameGlobal;        }        throw new NotSupportedException(            ""Command ({$name}) is not available for driver ({$drivername}).""        );    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Input_363, Fetch the IP Address\n\n Determines and validates the visitor's IP address.\n\n @return\tstring\tIP address\n,Preuzimanje IP adrese. Određuje i potvrđuje IP adresu posetioca,"public function ip_address(){if ($this->ip_address !== FALSE){return $this->ip_address;}$proxy_ips = config_item('proxy_ips');if ( ! empty($proxy_ips) && ! is_array($proxy_ips)){$proxy_ips = explode(',', str_replace(' ', '', $proxy_ips));}$this->ip_address = $this->server('REMOTE_ADDR');if ($proxy_ips){foreach (array('HTTP_X_FORWARDED_FOR', 'HTTP_CLIENT_IP', 'HTTP_X_CLIENT_IP', 'HTTP_X_CLUSTER_CLIENT_IP') as $header){if (($spoof = $this->server($header)) !== NULL){// Some proxies typically list the whole chain of IP// addresses through which the client has reached us.// e.g. client_ip, proxy_ip1, proxy_ip2, etc.sscanf($spoof, '%[^,]', $spoof);if ( ! $this->valid_ip($spoof)){$spoof = NULL;}else{break;}}}if ($spoof){for ($i = 0, $c = count($proxy_ips); $i < $c; $i++){// Check if we have an IP address or a subnetif (strpos($proxy_ips[$i], '/') === FALSE){// An IP address (and not a subnet) is specified.// We can compare right away.if ($proxy_ips[$i] === $this->ip_address){$this->ip_address = $spoof;break;}continue;}// We have a subnet ... now the heavy lifting beginsisset($separator) OR $separator = $this->valid_ip($this->ip_address, 'ipv6') ? ':' : '.';// If the proxy entry doesn't match the IP protocol - skip itif (strpos($proxy_ips[$i], $separator) === FALSE){continue;}// Convert the REMOTE_ADDR IP address to binary, if neededif ( ! isset($ip, $sprintf)){if ($separator === ':'){// Make sure we're have the ""full"" IPv6 format$ip = explode(':',str_replace('::',str_repeat(':', 9 - substr_count($this->ip_address, ':')),$this->ip_address));for ($j = 0; $j < 8; $j++){$ip[$j] = intval($ip[$j], 16);}$sprintf = '%016b%016b%016b%016b%016b%016b%016b%016b';}else{$ip = explode('.', $this->ip_address);$sprintf = '%08b%08b%08b%08b';}$ip = vsprintf($sprintf, $ip);}// Split the netmask length off the network addresssscanf($proxy_ips[$i], '%[^/]/%d', $netaddr, $masklen);// Again, an IPv6 address is most likely in a compressed formif ($separator === ':'){$netaddr = explode(':', str_replace('::', str_repeat(':', 9 - substr_count($netaddr, ':')), $netaddr));for ($j = 0; $j < 8; $j++){$netaddr[$j] = intval($netaddr[$j], 16);}}else{$netaddr = explode('.', $netaddr);}// Convert to binary and finally compareif (strncmp($ip, vsprintf($sprintf, $netaddr), $masklen) === 0){$this->ip_address = $spoof;break;}}}}if ( ! $this->valid_ip($this->ip_address)){return $this->ip_address = '0.0.0.0';}return $this->ip_address;}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1130, The GravCache object is used throughout Grav to store and retrieve cached data.\\n It uses DoctrineCache library and supports a variety of caching mechanisms. Those include:\\n\\n APCu\\n RedisCache\\n MemCache\\n MemCacheD\\n FileSystem\\n,"Objekt GravCache koristi se u celom Grav-u za skladištenje i preuzimanje keširanih podataka. Koristi biblioteku DoctrineCache i podržava razne mehanizme keširanja. To uključuje: APCu, RedisCache, MemCache, MemCacheD, FileSistem","class Cache extends Getters{    /** @var string Cache key. */    protected $key;    /** @var int */    protected $lifetime;    /** @var int */    protected $now;    /** @var Config $config */    protected $config;    /** @var DoctrineCache\CacheProvider */    protected $driver;    /** @var CacheInterface */    protected $simpleCache;    /** @var string */    protected $driver_name;    /** @var string */    protected $driver_setting;    /** @var bool */    protected $enabled;    /** @var string */    protected $cache_dir;    protected static $standard_remove = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'cache://images',        'asset://',    ];    protected static $standard_remove_no_images = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'asset://',    ];    protected static $all_remove = [        'cache://',        'cache://images',        'asset://',        'tmp://'    ];    protected static $assets_remove = [        'asset://'    ];    protected static $images_remove = [        'cache://images'    ];    protected static $cache_remove = [        'cache://'    ];    protected static $tmp_remove = [        'tmp://'    ];    /**     * Constructor     *     * @param Grav $grav     */    public function __construct(Grav $grav)    {        $this->init($grav);    }    /**     * Initialization that sets a base key and the driver based on configuration settings     *     * @param  Grav $grav     * @return void     */    public function init(Grav $grav)    {        $this->config = $grav['config'];        $this->now = time();        if (null === $this->enabled) {            $this->enabled = (bool)$this->config->get('system.cache.enabled');        }        /** @var Uri $uri */        $uri = $grav['uri'];        $prefix = $this->config->get('system.cache.prefix');        $uniqueness = substr(md5($uri->rootUrl(true) . $this->config->key() . GRAV_VERSION), 2, 8);        // Cache key allows us to invalidate all cache on configuration changes.        $this->key = ($prefix ? $prefix : 'g') . '-' . $uniqueness;        $this->cache_dir = $grav['locator']->findResource('cache://doctrine/' . $uniqueness, true, true);        $this->driver_setting = $this->config->get('system.cache.driver');        $this->driver = $this->getCacheDriver();        $this->driver->setNamespace($this->key);        /** @var EventDispatcher $dispatcher */        $dispatcher = Grav::instance()['events'];        $dispatcher->addListener('onSchedulerInitialized', [$this, 'onSchedulerInitialized']);    }    /**     * @return CacheInterface     */    public function getSimpleCache()    {        if (null === $this->simpleCache) {            $cache = new \Grav\Framework\Cache\Adapter\DoctrineCache($this->driver, '', $this->getLifetime());            // Disable cache key validation.            $cache->setValidation(false);            $this->simpleCache = $cache;        }        return $this->simpleCache;    }    /**     * Deletes the old out of date file-based caches     *     * @return int     */    public function purgeOldCache()    {        $cache_dir = dirname($this->cache_dir);        $current = basename($this->cache_dir);        $count = 0;        foreach (new DirectoryIterator($cache_dir) as $file) {            $dir = $file->getBasename();            if ($dir === $current || $file->isDot() || $file->isFile()) {                continue;            }            Folder::delete($file->getPathname());            $count++;        }        return $count;    }    /**     * Public accessor to set the enabled state of the cache     *     * @param bool|int $enabled     * @return void     */    public function setEnabled($enabled)    {        $this->enabled = (bool)$enabled;    }    /**     * Returns the current enabled state     *     * @return bool     */    public function getEnabled()    {        return $this->enabled;    }    /**     * Get cache state     *     * @return string     */    public function getCacheStatus()    {        return 'Cache: [' . ($this->enabled ? 'true' : 'false') . '] Setting: [' . $this->driver_setting . '] Driver: [' . $this->driver_name . ']';    }    /**     * Automatically picks the cache mechanism to use.  If you pick one manually it will use that     * If there is no config option for $driver in the config, or it's set to 'auto', it will     * pick the best option based on which cache extensions are installed.     *     * @return DoctrineCache\CacheProvider  The cache driver to use     */    public function getCacheDriver()    {        $setting = $this->driver_setting;        $driver_name = 'file';        // CLI compatibility requires a non-volatile cache driver        if ($this->config->get('system.cache.cli_compatibility') && (            $setting === 'auto' || $this->isVolatileDriver($setting))) {            $setting = $driver_name;        }        if (!$setting || $setting === 'auto') {            if (extension_loaded('apcu')) {                $driver_name = 'apcu';            } elseif (extension_loaded('wincache')) {                $driver_name = 'wincache';            }        } else {            $driver_name = $setting;        }        $this->driver_name = $driver_name;        switch ($driver_name) {            case 'apc':            case 'apcu':                $driver = new DoctrineCache\ApcuCache();                break;            case 'wincache':                $driver = new DoctrineCache\WinCacheCache();                break;            case 'memcache':                if (extension_loaded('memcache')) {                    $memcache = new \Memcache();                    $memcache->connect(                        $this->config->get('system.cache.memcache.server', 'localhost'),                        $this->config->get('system.cache.memcache.port', 11211)                    );                    $driver = new DoctrineCache\MemcacheCache();                    $driver->setMemcache($memcache);                } else {                    throw new LogicException('Memcache PHP extension has not been installed');                }                break;            case 'memcached':                if (extension_loaded('memcached')) {                    $memcached = new \Memcached();                    $memcached->addServer(                        $this->config->get('system.cache.memcached.server', 'localhost'),                        $this->config->get('system.cache.memcached.port', 11211)                    );                    $driver = new DoctrineCache\MemcachedCache();                    $driver->setMemcached($memcached);                } else {                    throw new LogicException('Memcached PHP extension has not been installed');                }                break;            case 'redis':                if (extension_loaded('redis')) {                    $redis = new \Redis();                    $socket = $this->config->get('system.cache.redis.socket', false);                    $password = $this->config->get('system.cache.redis.password', false);                    $databaseId = $this->config->get('system.cache.redis.database', 0);                    if ($socket) {                        $redis->connect($socket);                    } else {                        $redis->connect(                            $this->config->get('system.cache.redis.server', 'localhost'),                            $this->config->get('system.cache.redis.port', 6379)                        );                    }                    // Authenticate with password if set                    if ($password && !$redis->auth($password)) {                        throw new \RedisException('Redis authentication failed');                    }                    // Select alternate ( !=0 ) database ID if set                    if ($databaseId && !$redis->select($databaseId)) {                        throw new \RedisException('Could not select alternate Redis database ID');                    }                    $driver = new DoctrineCache\RedisCache();                    $driver->setRedis($redis);                } else {                    throw new LogicException('Redis PHP extension has not been installed');                }                break;            default:                $driver = new DoctrineCache\FilesystemCache($this->cache_dir);                break;        }        return $driver;    }    /**     * Gets a cached entry if it exists based on an id. If it does not exist, it returns false     *     * @param  string $id the id of the cached entry     * @return mixed|bool     returns the cached entry, can be any type, or false if doesn't exist     */    public function fetch($id)    {        if ($this->enabled) {            return $this->driver->fetch($id);        }        return false;    }    /**     * Stores a new cached entry.     *     * @param  string       $id       the id of the cached entry     * @param  array|object|int $data     the data for the cached entry to store     * @param  int|null     $lifetime the lifetime to store the entry in seconds     */    public function save($id, $data, $lifetime = null)    {        if ($this->enabled) {            if ($lifetime === null) {                $lifetime = $this->getLifetime();            }            $this->driver->save($id, $data, $lifetime);        }    }    /**     * Deletes an item in the cache based on the id     *     * @param string $id    the id of the cached data entry     * @return bool         true if the item was deleted successfully     */    public function delete($id)    {        if ($this->enabled) {            return $this->driver->delete($id);        }        return false;    }    /**     * Deletes all cache     *     * @return bool     */    public function deleteAll()    {        if ($this->enabled) {            return $this->driver->deleteAll();        }        return false;    }    /**     * Returns a boolean state of whether or not the item exists in the cache based on id key     *     * @param string $id    the id of the cached data entry     * @return bool         true if the cached items exists     */    public function contains($id)    {        if ($this->enabled) {            return $this->driver->contains(($id));        }        return false;    }    /**     * Getter method to get the cache key     *     * @return string     */    public function getKey()    {        return $this->key;    }    /**     * Setter method to set key (Advanced)     *     * @param string $key     * @return void     */    public function setKey($key)    {        $this->key = $key;        $this->driver->setNamespace($this->key);    }    /**     * Helper method to clear all Grav caches     *     * @param string $remove standard|all|assets-only|images-only|cache-only     * @return array     */    public static function clearCache($remove = 'standard')    {        $locator = Grav::instance()['locator'];        $output = [];        $user_config = USER_DIR . 'config/system.yaml';        switch ($remove) {            case 'all':                $remove_paths = self::$all_remove;                break;            case 'assets-only':                $remove_paths = self::$assets_remove;                break;            case 'images-only':                $remove_paths = self::$images_remove;                break;            case 'cache-only':                $remove_paths = self::$cache_remove;                break;            case 'tmp-only':                $remove_paths = self::$tmp_remove;                break;            case 'invalidate':                $remove_paths = [];                break;            default:                if (Grav::instance()['config']->get('system.cache.clear_images_by_default')) {                    $remove_paths = self::$standard_remove;                } else {                    $remove_paths = self::$standard_remove_no_images;                }        }        // Delete entries in the doctrine cache if required        if (in_array($remove, ['all', 'standard'])) {            $cache = Grav::instance()['cache'];            $cache->driver->deleteAll();        }        // Clearing cache event to add paths to clear        Grav::instance()->fireEvent('onBeforeCacheClear', new Event(['remove' => $remove, 'paths' => &$remove_paths]));        foreach ($remove_paths as $stream) {            // Convert stream to a real path            try {                $path = $locator->findResource($stream, true, true);                if ($path === false) {                    continue;                }                $anything = false;                $files = glob($path . '/*');                if (is_array($files)) {                    foreach ($files as $file) {                        if (is_link($file)) {                            $output[] = '<yellow>Skipping symlink:  </yellow>' . $file;                        } elseif (is_file($file)) {                            if (@unlink($file)) {                                $anything = true;                            }                        } elseif (is_dir($file)) {                            if (Folder::delete($file, false)) {                                $anything = true;                            }                        }                    }                }                if ($anything) {                    $output[] = '<red>Cleared:  </red>' . $path . '/*';                }            } catch (Exception $e) {                // stream not found or another error while deleting files.                $output[] = '<red>ERROR: </red>' . $e->getMessage();            }        }        $output[] = '';        if (($remove === 'all' || $remove === 'standard') && file_exists($user_config)) {            touch($user_config);            $output[] = '<red>Touched: </red>' . $user_config;            $output[] = '';        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }        Grav::instance()->fireEvent('onAfterCacheClear', new Event(['remove' => $remove, 'output' => &$output]));        return $output;    }    /**     * @return void     */    public static function invalidateCache()    {        $user_config = USER_DIR . 'config/system.yaml';        if (file_exists($user_config)) {            touch($user_config);        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }    }    /**     * Set the cache lifetime programmatically     *     * @param int $future timestamp     * @return void     */    public function setLifetime($future)    {        if (!$future) {            return;        }        $interval = (int)($future - $this->now);        if ($interval > 0 && $interval < $this->getLifetime()) {            $this->lifetime = $interval;        }    }    /**     * Retrieve the cache lifetime (in seconds)     *     * @return int     */    public function getLifetime()    {        if ($this->lifetime === null) {            $this->lifetime = (int)($this->config->get('system.cache.lifetime') ?: 604800); // 1 week default        }        return $this->lifetime;    }    /**     * Returns the current driver name     *     * @return string     */    public function getDriverName()    {        return $this->driver_name;    }    /**     * Returns the current driver setting     *     * @return string     */    public function getDriverSetting()    {        return $this->driver_setting;    }    /**     * is this driver a volatile driver in that it resides in PHP process memory     *     * @param string $setting     * @return bool     */    public function isVolatileDriver($setting)    {        if (in_array($setting, ['apc', 'apcu', 'xcache', 'wincache'])) {            return true;        }        return false;    }    /**     * Static function to call as a scheduled Job to purge old Doctrine files     *     * @param bool $echo     *     * @return string|void     */    public static function purgeJob($echo = false)    {        /** @var Cache $cache */        $cache = Grav::instance()['cache'];        $deleted_folders = $cache->purgeOldCache();        $msg = 'Purged ' . $deleted_folders . ' old cache folders...';        if ($echo) {            echo $msg;        } else {            return $msg;        }    }    /**     * Static function to call as a scheduled Job to clear Grav cache     *     * @param string $type     * @return void     */    public static function clearJob($type)    {        $result = static::clearCache($type);        static::invalidateCache();        echo strip_tags(implode(""\n"", $result));    }    /**     * @param Event $event     * @return void     */    public function onSchedulerInitialized(Event $event)    {        /** @var Scheduler $scheduler */        $scheduler = $event['scheduler'];        $config = Grav::instance()['config'];        // File Cache Purge        $at = $config->get('system.cache.purge_at');        $name = 'cache-purge';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::purgeJob', [true], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');        // Cache Clear        $at = $config->get('system.cache.clear_at');        $clear_type = $config->get('system.cache.clear_job_type');        $name = 'cache-clear';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::clearJob', [$clear_type], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');    }}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_654," This class defines attributes, valid values, and usage which is generated\\\\n from a given json schema.\\\\n http://tools.ietf.org/html/draft-zyp-json-schema-03#section-5\\\\n\\\\n","Ova klasa definiše atribute, važeće vrednosti i upotrebu koja se generiše iz date json šeme","class Model implements \ArrayAccess{  /**   * If you need to specify a NULL JSON value, use Google\Model::NULL_VALUE   * instead - it will be replaced when converting to JSON with a real null.   */  const NULL_VALUE = ""{}gapi-php-null"";  protected $internal_gapi_mappings = array();  protected $modelData = array();  protected $processed = array();  /**   * Polymorphic - accepts a variable number of arguments dependent   * on the type of the model subclass.   */  final public function __construct()  {    if (func_num_args() == 1 && is_array(func_get_arg(0))) {      // Initialize the model with the array's contents.      $array = func_get_arg(0);      $this->mapTypes($array);    }    $this->gapiInit();  }  /**   * Getter that handles passthrough access to the data array, and lazy object creation.   * @param string $key Property name.   * @return mixed The value if any, or null.   */  public function __get($key)  {    $keyType = $this->keyType($key);    $keyDataType = $this->dataType($key);    if ($keyType && !isset($this->processed[$key])) {      if (isset($this->modelData[$key])) {        $val = $this->modelData[$key];      } elseif ($keyDataType == 'array' || $keyDataType == 'map') {        $val = array();      } else {        $val = null;      }      if ($this->isAssociativeArray($val)) {        if ($keyDataType && 'map' == $keyDataType) {          foreach ($val as $arrayKey => $arrayItem) {              $this->modelData[$key][$arrayKey] =                new $keyType($arrayItem);          }        } else {          $this->modelData[$key] = new $keyType($val);        }      } else if (is_array($val)) {        $arrayObject = array();        foreach ($val as $arrayIndex => $arrayItem) {          $arrayObject[$arrayIndex] = new $keyType($arrayItem);        }        $this->modelData[$key] = $arrayObject;      }      $this->processed[$key] = true;    }    return isset($this->modelData[$key]) ? $this->modelData[$key] : null;  }  /**   * Initialize this object's properties from an array.   *   * @param array $array Used to seed this object's properties.   * @return void   */  protected function mapTypes($array)  {    // Hard initialise simple types, lazy load more complex ones.    foreach ($array as $key => $val) {      if ($keyType = $this->keyType($key)) {        $dataType = $this->dataType($key);        if ($dataType == 'array' || $dataType == 'map') {          $this->$key = array();          foreach ($val as $itemKey => $itemVal) {            if ($itemVal instanceof $keyType) {              $this->{$key}[$itemKey] = $itemVal;            } else {              $this->{$key}[$itemKey] = new $keyType($itemVal);            }          }        } elseif ($val instanceof $keyType) {          $this->$key = $val;        } else {          $this->$key = new $keyType($val);        }        unset($array[$key]);      } elseif (property_exists($this, $key)) {          $this->$key = $val;          unset($array[$key]);      } elseif (property_exists($this, $camelKey = $this->camelCase($key))) {          // This checks if property exists as camelCase, leaving it in array as snake_case          // in case of backwards compatibility issues.          $this->$camelKey = $val;      }    }    $this->modelData = $array;  }  /**   * Blank initialiser to be used in subclasses to do  post-construction initialisation - this   * avoids the need for subclasses to have to implement the variadics handling in their   * constructors.   */  protected function gapiInit()  {    return;  }  /**   * Create a simplified object suitable for straightforward   * conversion to JSON. This is relatively expensive   * due to the usage of reflection, but shouldn't be called   * a whole lot, and is the most straightforward way to filter.   */  public function toSimpleObject()  {    $object = new stdClass();    // Process all other data.    foreach ($this->modelData as $key => $val) {      $result = $this->getSimpleValue($val);      if ($result !== null) {        $object->$key = $this->nullPlaceholderCheck($result);      }    }    // Process all public properties.    $reflect = new ReflectionObject($this);    $props = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);    foreach ($props as $member) {      $name = $member->getName();      $result = $this->getSimpleValue($this->$name);      if ($result !== null) {        $name = $this->getMappedName($name);        $object->$name = $this->nullPlaceholderCheck($result);      }    }    return $object;  }  /**   * Handle different types of values, primarily   * other objects and map and array data types.   */  private function getSimpleValue($value)  {    if ($value instanceof Model) {      return $value->toSimpleObject();    } else if (is_array($value)) {      $return = array();      foreach ($value as $key => $a_value) {        $a_value = $this->getSimpleValue($a_value);        if ($a_value !== null) {          $key = $this->getMappedName($key);          $return[$key] = $this->nullPlaceholderCheck($a_value);        }      }      return $return;    }    return $value;  }  /**   * Check whether the value is the null placeholder and return true null.   */  private function nullPlaceholderCheck($value)  {    if ($value === self::NULL_VALUE) {      return null;    }    return $value;  }  /**   * If there is an internal name mapping, use that.   */  private function getMappedName($key)  {    if (isset($this->internal_gapi_mappings, $this->internal_gapi_mappings[$key])) {      $key = $this->internal_gapi_mappings[$key];    }    return $key;  }  /**   * Returns true only if the array is associative.   * @param array $array   * @return bool True if the array is associative.   */  protected function isAssociativeArray($array)  {    if (!is_array($array)) {      return false;    }    $keys = array_keys($array);    foreach ($keys as $key) {      if (is_string($key)) {        return true;      }    }    return false;  }  /**   * Verify if $obj is an array.   * @throws \Google\Exception Thrown if $obj isn't an array.   * @param array $obj Items that should be validated.   * @param string $method Method expecting an array as an argument.   */  public function assertIsArray($obj, $method)  {    if ($obj && !is_array($obj)) {      throw new GoogleException(          ""Incorrect parameter type passed to $method(). Expected an array.""      );    }  }  public function offsetExists($offset)  {    return isset($this->$offset) || isset($this->modelData[$offset]);  }  public function offsetGet($offset)  {    return isset($this->$offset) ?        $this->$offset :        $this->__get($offset);  }  public function offsetSet($offset, $value)  {    if (property_exists($this, $offset)) {      $this->$offset = $value;    } else {      $this->modelData[$offset] = $value;      $this->processed[$offset] = true;    }  }  public function offsetUnset($offset)  {    unset($this->modelData[$offset]);  }  protected function keyType($key)  {    $keyType = $key . ""Type"";    // ensure keyType is a valid class    if (property_exists($this, $keyType) && class_exists($this->$keyType)) {      return $this->$keyType;    }  }  protected function dataType($key)  {    $dataType = $key . ""DataType"";    if (property_exists($this, $dataType)) {      return $this->$dataType;    }  }  public function __isset($key)  {    return isset($this->modelData[$key]);  }  public function __unset($key)  {    unset($this->modelData[$key]);  }  /**   * Convert a string to camelCase   * @param  string $value   * @return string   */  private function camelCase($value)  {    $value = ucwords(str_replace(array('-', '_'), ' ', $value));    $value = str_replace(' ', '', $value);    $value[0] = strtolower($value[0]);    return $value;  }}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1637, Handle a redirected request from master.\n\n @param ServerRequestInterface $request\n @return ResponseInterface\n,Obrađuje preusmereni zahtev od mastera,"    protected function handleRequest(ServerRequestInterface $request)    {        if ($this->getStaticDirectory()) {            $staticResponse = $this->serveStatic($request);            if ($staticResponse instanceof ResponseInterface) {                return $staticResponse;            }        }        if ($bridge = $this->getBridge()) {            try {                $response = $bridge->handle($request);            } catch (\Throwable $t) {                \error_log(                    'An exception was thrown by the bridge. Forcing restart of the worker. The exception was: ' .                    (string)$t                );                $response = new Response(500, [], 'Unexpected error');                @\ob_end_clean();                $this->shutdown();            }            $this->sendCurrentFiles();        } else {            $response = new Response(404, [], 'No Bridge defined');        }        if (\headers_sent()) {            //when a script sent headers the cgi process needs to die because the second request            //trying to send headers again will fail (headers already sent fatal). Its best to not even            //try to send headers because this break the whole approach of php-pm using php-cgi.            \error_log(                'Headers have been sent, but not redirected to client. Forcing restart of the worker. ' .                'Make sure your application does not send headers on its own.'            );            $this->shutdown();        }        $this->sendMessage($this->controller, 'stats', ['memory_usage' => \round(\memory_get_peak_usage(true)/1048576, 2)]); // Convert memory usage to MB        return $response;    }",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ClassNotFoundFatalErrorHandler_1769," ErrorHandler for classes that do not exist.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\FatalErrorHandler\\\\ClassNotFoundFatalErrorHandler instead.\\n",ErrorHandler za klase koje ne postoje,"class ClassNotFoundFatalErrorHandler implements FatalErrorHandlerInterface{    /**     * {@inheritdoc}     */    public function handleError(array $error, FatalErrorException $exception)    {        if (!preg_match('/^(Class|Interface|Trait) [\'""]([^\'""]+)[\'""] not found$/', $error['message'], $matches)) {            return null;        }        $typeName = strtolower($matches[1]);        $fullyQualifiedClassName = $matches[2];        if (false !== $namespaceSeparatorIndex = strrpos($fullyQualifiedClassName, '\\')) {            $className = substr($fullyQualifiedClassName, $namespaceSeparatorIndex + 1);            $namespacePrefix = substr($fullyQualifiedClassName, 0, $namespaceSeparatorIndex);            $message = sprintf('Attempted to load %s ""%s"" from namespace ""%s"".', $typeName, $className, $namespacePrefix);            $tail = ' for another namespace?';        } else {            $className = $fullyQualifiedClassName;            $message = sprintf('Attempted to load %s ""%s"" from the global namespace.', $typeName, $className);            $tail = '?';        }        if ($candidates = $this->getClassCandidates($className)) {            $tail = array_pop($candidates).'""?';            if ($candidates) {                $tail = ' for e.g. ""'.implode('"", ""', $candidates).'"" or ""'.$tail;            } else {                $tail = ' for ""'.$tail;            }        }        $message .= ""\nDid you forget a \""use\"" statement"".$tail;        return new ClassNotFoundException($message, $exception);    }    /**     * Tries to guess the full namespace for a given class name.     *     * By default, it looks for PSR-0 and PSR-4 classes registered via a Symfony or a Composer     * autoloader (that should cover all common cases).     *     * @param string $class A class name (without its namespace)     *     * @return array An array of possible fully qualified class names     */    private function getClassCandidates(string $class): array    {        if (!\is_array($functions = spl_autoload_functions())) {            return [];        }        // find Symfony and Composer autoloaders        $classes = [];        foreach ($functions as $function) {            if (!\is_array($function)) {                continue;            }            // get class loaders wrapped by DebugClassLoader            if ($function[0] instanceof DebugClassLoader) {                $function = $function[0]->getClassLoader();                if (!\is_array($function)) {                    continue;                }            }            if ($function[0] instanceof ComposerClassLoader || $function[0] instanceof SymfonyClassLoader) {                foreach ($function[0]->getPrefixes() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }            if ($function[0] instanceof ComposerClassLoader) {                foreach ($function[0]->getPrefixesPsr4() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }        }        return array_unique($classes);    }    private function findClassInPath(string $path, string $class, string $prefix): array    {        if (!$path = realpath($path.'/'.strtr($prefix, '\\_', '//')) ?: realpath($path.'/'.\dirname(strtr($prefix, '\\_', '//'))) ?: realpath($path)) {            return [];        }        $classes = [];        $filename = $class.'.php';        foreach (new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS), \RecursiveIteratorIterator::LEAVES_ONLY) as $file) {            if ($filename == $file->getFileName() && $class = $this->convertFileToClass($path, $file->getPathName(), $prefix)) {                $classes[] = $class;            }        }        return $classes;    }    private function convertFileToClass(string $path, string $file, string $prefix): ?string    {        $candidates = [            // namespaced class            $namespacedClass = str_replace([$path.\DIRECTORY_SEPARATOR, '.php', '/'], ['', '', '\\'], $file),            // namespaced class (with target dir)            $prefix.$namespacedClass,            // namespaced class (with target dir and separator)            $prefix.'\\'.$namespacedClass,            // PEAR class            str_replace('\\', '_', $namespacedClass),            // PEAR class (with target dir)            str_replace('\\', '_', $prefix.$namespacedClass),            // PEAR class (with target dir and separator)            str_replace('\\', '_', $prefix.'\\'.$namespacedClass),        ];        if ($prefix) {            $candidates = array_filter($candidates, function ($candidate) use ($prefix) { return 0 === strpos($candidate, $prefix); });        }        // We cannot use the autoloader here as most of them use require; but if the class        // is not found, the new autoloader call will require the file again leading to a        // ""cannot redeclare class"" error.        foreach ($candidates as $candidate) {            if ($this->classExists($candidate)) {                return $candidate;            }        }        try {            require_once $file;        } catch (\Throwable $e) {            return null;        }        foreach ($candidates as $candidate) {            if ($this->classExists($candidate)) {                return $candidate;            }        }        return null;    }    private function classExists(string $class): bool    {        return class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);    }}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_FileBag_9727, Converts uploaded files to UploadedFile instances.\n\n @param array|UploadedFile $file A (multi-dimensional) array of uploaded file information\n\n @return UploadedFile[]|UploadedFile|null A (multi-dimensional) array of UploadedFile instances\n,Pretvara otpremljene datoteke u UploadedFile instance ,"    protected function convertFileInformation($file)    {        if ($file instanceof UploadedFile) {            return $file;        }        if (\is_array($file)) {            $file = $this->fixPhpFilesArray($file);            $keys = array_keys($file);            sort($keys);            if (self::FILE_KEYS == $keys) {                if (\UPLOAD_ERR_NO_FILE == $file['error']) {                    $file = null;                } else {                    $file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['error'], false);                }            } else {                $file = array_map([$this, 'convertFileInformation'], $file);                if (array_keys($keys) === $keys) {                    $file = array_filter($file);                }            }        }        return $file;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_ParameterBag_8812, ParameterBag is a container for key/value pairs.\n\n @author Fabien Potencier <fabien@symfony.com>\n,ParameterBag je kontejner za parove ključ/vrijednost,"class ParameterBag implements \IteratorAggregate, \Countable{    /**     * Parameter storage.     */    protected $parameters;    public function __construct(array $parameters = [])    {        $this->parameters = $parameters;    }    /**     * Returns the parameters.     *     * @param string|null $key The name of the parameter to return or null to get them all     *     * @return array An array of parameters     */    public function all(/*string $key = null*/)    {        $key = \func_num_args() > 0 ? func_get_arg(0) : null;        if (null === $key) {            return $this->parameters;        }        if (!\is_array($value = $this->parameters[$key] ?? [])) {            throw new BadRequestException(sprintf('Unexpected value for parameter ""%s"": expecting ""array"", got ""%s"".', $key, get_debug_type($value)));        }        return $value;    }    /**     * Returns the parameter keys.     *     * @return array An array of parameter keys     */    public function keys()    {        return array_keys($this->parameters);    }    /**     * Replaces the current parameters by a new set.     */    public function replace(array $parameters = [])    {        $this->parameters = $parameters;    }    /**     * Adds parameters.     */    public function add(array $parameters = [])    {        $this->parameters = array_replace($this->parameters, $parameters);    }    /**     * Returns a parameter by name.     *     * @param mixed $default The default value if the parameter key does not exist     *     * @return mixed     */    public function get(string $key, $default = null)    {        return \array_key_exists($key, $this->parameters) ? $this->parameters[$key] : $default;    }    /**     * Sets a parameter by name.     *     * @param mixed $value The value     */    public function set(string $key, $value)    {        $this->parameters[$key] = $value;    }    /**     * Returns true if the parameter is defined.     *     * @return bool true if the parameter exists, false otherwise     */    public function has(string $key)    {        return \array_key_exists($key, $this->parameters);    }    /**     * Removes a parameter.     */    public function remove(string $key)    {        unset($this->parameters[$key]);    }    /**     * Returns the alphabetic characters of the parameter value.     *     * @return string The filtered value     */    public function getAlpha(string $key, string $default = '')    {        return preg_replace('/[^[:alpha:]]/', '', $this->get($key, $default));    }    /**     * Returns the alphabetic characters and digits of the parameter value.     *     * @return string The filtered value     */    public function getAlnum(string $key, string $default = '')    {        return preg_replace('/[^[:alnum:]]/', '', $this->get($key, $default));    }    /**     * Returns the digits of the parameter value.     *     * @return string The filtered value     */    public function getDigits(string $key, string $default = '')    {        // we need to remove - and + because they're allowed in the filter        return str_replace(['-', '+'], '', $this->filter($key, $default, \FILTER_SANITIZE_NUMBER_INT));    }    /**     * Returns the parameter value converted to integer.     *     * @return int The filtered value     */    public function getInt(string $key, int $default = 0)    {        return (int) $this->get($key, $default);    }    /**     * Returns the parameter value converted to boolean.     *     * @return bool The filtered value     */    public function getBoolean(string $key, bool $default = false)    {        return $this->filter($key, $default, \FILTER_VALIDATE_BOOLEAN);    }    /**     * Filter key.     *     * @param mixed $default Default = null     * @param int   $filter  FILTER_* constant     * @param mixed $options Filter options     *     * @see https://php.net/filter-var     *     * @return mixed     */    public function filter(string $key, $default = null, int $filter = \FILTER_DEFAULT, $options = [])    {        $value = $this->get($key, $default);        // Always turn $options into an array - this allows filter_var option shortcuts.        if (!\is_array($options) && $options) {            $options = ['flags' => $options];        }        // Add a convenience check for arrays.        if (\is_array($value) && !isset($options['flags'])) {            $options['flags'] = \FILTER_REQUIRE_ARRAY;        }        if ((\FILTER_CALLBACK & $filter) && !(($options['options'] ?? null) instanceof \Closure)) {            trigger_deprecation('symfony/http-foundation', '5.2', 'Not passing a Closure together with FILTER_CALLBACK to ""%s()"" is deprecated. Wrap your filter in a closure instead.', __METHOD__);            // throw new \InvalidArgumentException(sprintf('A Closure must be passed to ""%s()"" when FILTER_CALLBACK is used, ""%s"" given.', __METHOD__, get_debug_type($options['options'] ?? null)));        }        return filter_var($value, $filter, $options);    }    /**     * Returns an iterator for parameters.     *     * @return \ArrayIterator An \ArrayIterator instance     */    public function getIterator()    {        return new \ArrayIterator($this->parameters);    }    /**     * Returns the number of parameters.     *     * @return int The number of parameters     */    public function count()    {        return \count($this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Compiler_9130, Adds a quoted string to the compiled code.\n\n @return $this\n,Dodaje citirani niz kompajliranom kodu,"class Environment{    public const VERSION = '3.3.3-DEV';    public const VERSION_ID = 30303;    public const MAJOR_VERSION = 3;    public const MINOR_VERSION = 3;    public const RELEASE_VERSION = 3;    public const EXTRA_VERSION = 'DEV';    private $charset;    private $loader;    private $debug;    private $autoReload;    private $cache;    private $lexer;    private $parser;    private $compiler;    private $globals = [];    private $resolvedGlobals;    private $loadedTemplates;    private $strictVariables;    private $templateClassPrefix = '__TwigTemplate_';    private $originalCache;    private $extensionSet;    private $runtimeLoaders = [];    private $runtimes = [];    private $optionsHash;    /**     * Constructor.     *     * Available options:     *     *  * debug: When set to true, it automatically set ""auto_reload"" to true as     *           well (default to false).     *     *  * charset: The charset used by the templates (default to UTF-8).     *     *  * cache: An absolute path where to store the compiled templates,     *           a \Twig\Cache\CacheInterface implementation,     *           or false to disable compilation cache (default).     *     *  * auto_reload: Whether to reload the template if the original source changed.     *                 If you don't provide the auto_reload option, it will be     *                 determined automatically based on the debug value.     *     *  * strict_variables: Whether to ignore invalid variables in templates     *                      (default to false).     *     *  * autoescape: Whether to enable auto-escaping (default to html):     *                  * false: disable auto-escaping     *                  * html, js: set the autoescaping to one of the supported strategies     *                  * name: set the autoescaping strategy based on the template name extension     *                  * PHP callback: a PHP callback that returns an escaping strategy based on the template ""name""     *     *  * optimizations: A flag that indicates which optimizations to apply     *                   (default to -1 which means that all optimizations are enabled;     *                   set it to 0 to disable).     */    public function __construct(LoaderInterface $loader, $options = [])    {        $this->setLoader($loader);        $options = array_merge([            'debug' => false,            'charset' => 'UTF-8',            'strict_variables' => false,            'autoescape' => 'html',            'cache' => false,            'auto_reload' => null,            'optimizations' => -1,        ], $options);        $this->debug = (bool) $options['debug'];        $this->setCharset($options['charset'] ?? 'UTF-8');        $this->autoReload = null === $options['auto_reload'] ? $this->debug : (bool) $options['auto_reload'];        $this->strictVariables = (bool) $options['strict_variables'];        $this->setCache($options['cache']);        $this->extensionSet = new ExtensionSet();        $this->addExtension(new CoreExtension());        $this->addExtension(new EscaperExtension($options['autoescape']));        $this->addExtension(new OptimizerExtension($options['optimizations']));    }    /**     * Enables debugging mode.     */    public function enableDebug()    {        $this->debug = true;        $this->updateOptionsHash();    }    /**     * Disables debugging mode.     */    public function disableDebug()    {        $this->debug = false;        $this->updateOptionsHash();    }    /**     * Checks if debug mode is enabled.     *     * @return bool true if debug mode is enabled, false otherwise     */    public function isDebug()    {        return $this->debug;    }    /**     * Enables the auto_reload option.     */    public function enableAutoReload()    {        $this->autoReload = true;    }    /**     * Disables the auto_reload option.     */    public function disableAutoReload()    {        $this->autoReload = false;    }    /**     * Checks if the auto_reload option is enabled.     *     * @return bool true if auto_reload is enabled, false otherwise     */    public function isAutoReload()    {        return $this->autoReload;    }    /**     * Enables the strict_variables option.     */    public function enableStrictVariables()    {        $this->strictVariables = true;        $this->updateOptionsHash();    }    /**     * Disables the strict_variables option.     */    public function disableStrictVariables()    {        $this->strictVariables = false;        $this->updateOptionsHash();    }    /**     * Checks if the strict_variables option is enabled.     *     * @return bool true if strict_variables is enabled, false otherwise     */    public function isStrictVariables()    {        return $this->strictVariables;    }    /**     * Gets the current cache implementation.     *     * @param bool $original Whether to return the original cache option or the real cache instance     *     * @return CacheInterface|string|false A Twig\Cache\CacheInterface implementation,     *                                     an absolute path to the compiled templates,     *                                     or false to disable cache     */    public function getCache($original = true)    {        return $original ? $this->originalCache : $this->cache;    }    /**     * Sets the current cache implementation.     *     * @param CacheInterface|string|false $cache A Twig\Cache\CacheInterface implementation,     *                                           an absolute path to the compiled templates,     *                                           or false to disable cache     */    public function setCache($cache)    {        if (\is_string($cache)) {            $this->originalCache = $cache;            $this->cache = new FilesystemCache($cache);        } elseif (false === $cache) {            $this->originalCache = $cache;            $this->cache = new NullCache();        } elseif ($cache instanceof CacheInterface) {            $this->originalCache = $this->cache = $cache;        } else {            throw new \LogicException('Cache can only be a string, false, or a \Twig\Cache\CacheInterface implementation.');        }    }    /**     * Gets the template class associated with the given string.     *     * The generated template class is based on the following parameters:     *     *  * The cache key for the given template;     *  * The currently enabled extensions;     *  * Whether the Twig C extension is available or not;     *  * PHP version;     *  * Twig version;     *  * Options with what environment was created.     *     * @param string   $name  The name for which to calculate the template class name     * @param int|null $index The index if it is an embedded template     *     * @internal     */    public function getTemplateClass(string $name, int $index = null): string    {        $key = $this->getLoader()->getCacheKey($name).$this->optionsHash;        return $this->templateClassPrefix.hash('sha256', $key).(null === $index ? '' : '___'.$index);    }    /**     * Renders a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws SyntaxError  When an error occurred during compilation     * @throws RuntimeError When an error occurred during rendering     */    public function render($name, array $context = []): string    {        return $this->load($name)->render($context);    }    /**     * Displays a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws SyntaxError  When an error occurred during compilation     * @throws RuntimeError When an error occurred during rendering     */    public function display($name, array $context = []): void    {        $this->load($name)->display($context);    }    /**     * Loads a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws RuntimeError When a previously generated cache is corrupted     * @throws SyntaxError  When an error occurred during compilation     */    public function load($name): TemplateWrapper    {        if ($name instanceof TemplateWrapper) {            return $name;        }        return new TemplateWrapper($this, $this->loadTemplate($this->getTemplateClass($name), $name));    }    /**     * Loads a template internal representation.     *     * This method is for internal use only and should never be called     * directly.     *     * @param string $name  The template name     * @param int    $index The index if it is an embedded template     *     * @throws LoaderError  When the template cannot be found     * @throws RuntimeError When a previously generated cache is corrupted     * @throws SyntaxError  When an error occurred during compilation     *     * @internal     */    public function loadTemplate(string $cls, string $name, int $index = null): Template    {        $mainCls = $cls;        if (null !== $index) {            $cls .= '___'.$index;        }        if (isset($this->loadedTemplates[$cls])) {            return $this->loadedTemplates[$cls];        }        if (!class_exists($cls, false)) {            $key = $this->cache->generateKey($name, $mainCls);            if (!$this->isAutoReload() || $this->isTemplateFresh($name, $this->cache->getTimestamp($key))) {                $this->cache->load($key);            }            $source = null;            if (!class_exists($cls, false)) {                $source = $this->getLoader()->getSourceContext($name);                $content = $this->compileSource($source);                $this->cache->write($key, $content);                $this->cache->load($key);                if (!class_exists($mainCls, false)) {                    /* Last line of defense if either $this->bcWriteCacheFile was used,                     * $this->cache is implemented as a no-op or we have a race condition                     * where the cache was cleared between the above calls to write to and load from                     * the cache.                     */                    eval('?>'.$content);                }                if (!class_exists($cls, false)) {                    throw new RuntimeError(sprintf('Failed to load Twig template ""%s"", index ""%s"": cache might be corrupted.', $name, $index), -1, $source);                }            }        }        $this->extensionSet->initRuntime();        return $this->loadedTemplates[$cls] = new $cls($this);    }    /**     * Creates a template from source.     *     * This method should not be used as a generic way to load templates.     *     * @param string $template The template source     * @param string $name     An optional name of the template to be used in error messages     *     * @throws LoaderError When the template cannot be found     * @throws SyntaxError When an error occurred during compilation     */    public function createTemplate(string $template, string $name = null): TemplateWrapper    {        $hash = hash('sha256', $template, false);        if (null !== $name) {            $name = sprintf('%s (string template %s)', $name, $hash);        } else {            $name = sprintf('__string_template__%s', $hash);        }        $loader = new ChainLoader([            new ArrayLoader([$name => $template]),            $current = $this->getLoader(),        ]);        $this->setLoader($loader);        try {            return new TemplateWrapper($this, $this->loadTemplate($this->getTemplateClass($name), $name));        } finally {            $this->setLoader($current);        }    }    /**     * Returns true if the template is still fresh.     *     * Besides checking the loader for freshness information,     * this method also checks if the enabled extensions have     * not changed.     *     * @param int $time The last modification time of the cached template     */    public function isTemplateFresh(string $name, int $time): bool    {        return $this->extensionSet->getLastModified() <= $time && $this->getLoader()->isFresh($name, $time);    }    /**     * Tries to load a template consecutively from an array.     *     * Similar to load() but it also accepts instances of \Twig\Template and     * \Twig\TemplateWrapper, and an array of templates where each is tried to be loaded.     *     * @param string|TemplateWrapper|array $names A template or an array of templates to try consecutively     *     * @throws LoaderError When none of the templates can be found     * @throws SyntaxError When an error occurred during compilation     */    public function resolveTemplate($names): TemplateWrapper    {        if (!\is_array($names)) {            return $this->load($names);        }        foreach ($names as $name) {            try {                return $this->load($name);            } catch (LoaderError $e) {            }        }        throw new LoaderError(sprintf('Unable to find one of the following templates: ""%s"".', implode('"", ""', $names)));    }    public function setLexer(Lexer $lexer)    {        $this->lexer = $lexer;    }    /**     * @throws SyntaxError When the code is syntactically wrong     */    public function tokenize(Source $source): TokenStream    {        if (null === $this->lexer) {            $this->lexer = new Lexer($this);        }        return $this->lexer->tokenize($source);    }    public function setParser(Parser $parser)    {        $this->parser = $parser;    }    /**     * Converts a token stream to a node tree.     *     * @throws SyntaxError When the token stream is syntactically or semantically wrong     */    public function parse(TokenStream $stream): ModuleNode    {        if (null === $this->parser) {            $this->parser = new Parser($this);        }        return $this->parser->parse($stream);    }    public function setCompiler(Compiler $compiler)    {        $this->compiler = $compiler;    }    /**     * Compiles a node and returns the PHP code.     */    public function compile(Node $node): string    {        if (null === $this->compiler) {            $this->compiler = new Compiler($this);        }        return $this->compiler->compile($node)->getSource();    }    /**     * Compiles a template source code.     *     * @throws SyntaxError When there was an error during tokenizing, parsing or compiling     */    public function compileSource(Source $source): string    {        try {            return $this->compile($this->parse($this->tokenize($source)));        } catch (Error $e) {            $e->setSourceContext($source);            throw $e;        } catch (\Exception $e) {            throw new SyntaxError(sprintf('An exception has been thrown during the compilation of a template (""%s"").', $e->getMessage()), -1, $source, $e);        }    }    public function setLoader(LoaderInterface $loader)    {        $this->loader = $loader;    }    public function getLoader(): LoaderInterface    {        return $this->loader;    }    public function setCharset(string $charset)    {        if ('UTF8' === $charset = null === $charset ? null : strtoupper($charset)) {            // iconv on Windows requires ""UTF-8"" instead of ""UTF8""            $charset = 'UTF-8';        }        $this->charset = $charset;    }    public function getCharset(): string    {        return $this->charset;    }    public function hasExtension(string $class): bool    {        return $this->extensionSet->hasExtension($class);    }    public function addRuntimeLoader(RuntimeLoaderInterface $loader)    {        $this->runtimeLoaders[] = $loader;    }    public function getExtension(string $class): ExtensionInterface    {        return $this->extensionSet->getExtension($class);    }    /**     * Returns the runtime implementation of a Twig element (filter/function/tag/test).     *     * @param string $class A runtime class name     *     * @return object The runtime implementation     *     * @throws RuntimeError When the template cannot be found     */    public function getRuntime(string $class)    {        if (isset($this->runtimes[$class])) {            return $this->runtimes[$class];        }        foreach ($this->runtimeLoaders as $loader) {            if (null !== $runtime = $loader->load($class)) {                return $this->runtimes[$class] = $runtime;            }        }        throw new RuntimeError(sprintf('Unable to load the ""%s"" runtime.', $class));    }    public function addExtension(ExtensionInterface $extension)    {        $this->extensionSet->addExtension($extension);        $this->updateOptionsHash();    }    /**     * @param ExtensionInterface[] $extensions An array of extensions     */    public function setExtensions(array $extensions)    {        $this->extensionSet->setExtensions($extensions);        $this->updateOptionsHash();    }    /**     * @return ExtensionInterface[] An array of extensions (keys are for internal usage only and should not be relied on)     */    public function getExtensions(): array    {        return $this->extensionSet->getExtensions();    }    public function addTokenParser(TokenParserInterface $parser)    {        $this->extensionSet->addTokenParser($parser);    }    /**     * @return TokenParserInterface[]     *     * @internal     */    public function getTokenParsers(): array    {        return $this->extensionSet->getTokenParsers();    }    /**     * @internal     */    public function getTokenParser(string $name): ?TokenParserInterface    {        return $this->extensionSet->getTokenParser($name);    }    public function registerUndefinedTokenParserCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedTokenParserCallback($callable);    }    public function addNodeVisitor(NodeVisitorInterface $visitor)    {        $this->extensionSet->addNodeVisitor($visitor);    }    /**     * @return NodeVisitorInterface[]     *     * @internal     */    public function getNodeVisitors(): array    {        return $this->extensionSet->getNodeVisitors();    }    public function addFilter(TwigFilter $filter)    {        $this->extensionSet->addFilter($filter);    }    /**     * @internal     */    public function getFilter(string $name): ?TwigFilter    {        return $this->extensionSet->getFilter($name);    }    public function registerUndefinedFilterCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedFilterCallback($callable);    }    /**     * Gets the registered Filters.     *     * Be warned that this method cannot return filters defined with registerUndefinedFilterCallback.     *     * @return TwigFilter[]     *     * @see registerUndefinedFilterCallback     *     * @internal     */    public function getFilters(): array    {        return $this->extensionSet->getFilters();    }    public function addTest(TwigTest $test)    {        $this->extensionSet->addTest($test);    }    /**     * @return TwigTest[]     *     * @internal     */    public function getTests(): array    {        return $this->extensionSet->getTests();    }    /**     * @internal     */    public function getTest(string $name): ?TwigTest    {        return $this->extensionSet->getTest($name);    }    public function addFunction(TwigFunction $function)    {        $this->extensionSet->addFunction($function);    }    /**     * @internal     */    public function getFunction(string $name): ?TwigFunction    {        return $this->extensionSet->getFunction($name);    }    public function registerUndefinedFunctionCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedFunctionCallback($callable);    }    /**     * Gets registered functions.     *     * Be warned that this method cannot return functions defined with registerUndefinedFunctionCallback.     *     * @return TwigFunction[]     *     * @see registerUndefinedFunctionCallback     *     * @internal     */    public function getFunctions(): array    {        return $this->extensionSet->getFunctions();    }    /**     * Registers a Global.     *     * New globals can be added before compiling or rendering a template;     * but after, you can only update existing globals.     *     * @param mixed $value The global value     */    public function addGlobal(string $name, $value)    {        if ($this->extensionSet->isInitialized() && !\array_key_exists($name, $this->getGlobals())) {            throw new \LogicException(sprintf('Unable to add global ""%s"" as the runtime or the extensions have already been initialized.', $name));        }        if (null !== $this->resolvedGlobals) {            $this->resolvedGlobals[$name] = $value;        } else {            $this->globals[$name] = $value;        }    }    /**     * @internal     */    public function getGlobals(): array    {        if ($this->extensionSet->isInitialized()) {            if (null === $this->resolvedGlobals) {                $this->resolvedGlobals = array_merge($this->extensionSet->getGlobals(), $this->globals);            }            return $this->resolvedGlobals;        }        return array_merge($this->extensionSet->getGlobals(), $this->globals);    }    public function mergeGlobals(array $context): array    {        // we don't use array_merge as the context being generally        // bigger than globals, this code is faster.        foreach ($this->getGlobals() as $key => $value) {            if (!\array_key_exists($key, $context)) {                $context[$key] = $value;            }        }        return $context;    }    /**     * @internal     */    public function getUnaryOperators(): array    {        return $this->extensionSet->getUnaryOperators();    }    /**     * @internal     */    public function getBinaryOperators(): array    {        return $this->extensionSet->getBinaryOperators();    }    private function updateOptionsHash(): void    {        $this->optionsHash = implode(':', [            $this->extensionSet->getSignature(),            \PHP_MAJOR_VERSION,            \PHP_MINOR_VERSION,            self::VERSION,            (int) $this->debug,            (int) $this->strictVariables,        ]);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1197, Does the queue have an item with the given priority?\n\n @param  int $priority\n @return bool\n,Da li red ima stavku sa datim prioritetom?,    public function hasPriority($priority)    {        foreach ($this->items as $item) {            if ($item['priority'] === $priority) {                return true;            }        }        return false;    },0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_FulfilledPromise_710, A promise that has been fulfilled.\\\\\\\\n\\\\\\\\n Thenning off of this promise will invoke the onFulfilled callback\\\\\\\\n immediately and ignore other callbacks.\\\\\\\\n,Obećanje koje je ispunjeno. Isključivanje ovog obećanja odmah će pozvati onFulfished povratni poziv i zanemariti druge povratne pozive,"class FulfilledPromise implements PromiseInterface{    private $value;    public function __construct($value)    {        if (is_object($value) && method_exists($value, 'then')) {            throw new \InvalidArgumentException(                'You cannot create a FulfilledPromise with a promise.'            );        }        $this->value = $value;    }    public function then(        callable $onFulfilled = null,        callable $onRejected = null    ) {        // Return itself if there is no onFulfilled function.        if (!$onFulfilled) {            return $this;        }        $queue = Utils::queue();        $p = new Promise([$queue, 'run']);        $value = $this->value;        $queue->add(static function () use ($p, $value, $onFulfilled) {            if (Is::pending($p)) {                try {                    $p->resolve($onFulfilled($value));                } catch (\Throwable $e) {                    $p->reject($e);                } catch (\Exception $e) {                    $p->reject($e);                }            }        });        return $p;    }    public function otherwise(callable $onRejected)    {        return $this->then(null, $onRejected);    }    public function wait($unwrap = true, $defaultDelivery = null)    {        return $unwrap ? $this->value : null;    }    public function getState()    {        return self::FULFILLED;    }    public function resolve($value)    {        if ($value !== $this->value) {            throw new \LogicException(""Cannot resolve a fulfilled promise"");        }    }    public function reject($reason)    {        throw new \LogicException(""Cannot reject a fulfilled promise"");    }    public function cancel()    {        // pass    }}",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_laravel_2019_08_19_000000_create_failed_jobs_table_13, Run the migrations.\\n\\n @return void\\n,Pokretanje migracija,"    public function up()    {        Schema::create('failed_jobs', function (Blueprint $table) {            $table->id();            $table->string('uuid')->unique();            $table->text('connection');            $table->text('queue');            $table->longText('payload');            $table->longText('exception');            $table->timestamp('failed_at')->useCurrent();        });    }",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractDumper_9251, Abstract mechanism for dumping a Data object.\n\n @author Nicolas Grekas <p@tchwork.com>\n,Apstraktni mehanizam za odbacivanje objekta podataka,"class AmqpCaster{    private const FLAGS = [        \AMQP_DURABLE => 'AMQP_DURABLE',        \AMQP_PASSIVE => 'AMQP_PASSIVE',        \AMQP_EXCLUSIVE => 'AMQP_EXCLUSIVE',        \AMQP_AUTODELETE => 'AMQP_AUTODELETE',        \AMQP_INTERNAL => 'AMQP_INTERNAL',        \AMQP_NOLOCAL => 'AMQP_NOLOCAL',        \AMQP_AUTOACK => 'AMQP_AUTOACK',        \AMQP_IFEMPTY => 'AMQP_IFEMPTY',        \AMQP_IFUNUSED => 'AMQP_IFUNUSED',        \AMQP_MANDATORY => 'AMQP_MANDATORY',        \AMQP_IMMEDIATE => 'AMQP_IMMEDIATE',        \AMQP_MULTIPLE => 'AMQP_MULTIPLE',        \AMQP_NOWAIT => 'AMQP_NOWAIT',        \AMQP_REQUEUE => 'AMQP_REQUEUE',    ];    private const EXCHANGE_TYPES = [        \AMQP_EX_TYPE_DIRECT => 'AMQP_EX_TYPE_DIRECT',        \AMQP_EX_TYPE_FANOUT => 'AMQP_EX_TYPE_FANOUT',        \AMQP_EX_TYPE_TOPIC => 'AMQP_EX_TYPE_TOPIC',        \AMQP_EX_TYPE_HEADERS => 'AMQP_EX_TYPE_HEADERS',    ];    public static function castConnection(\AMQPConnection $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'is_connected' => $c->isConnected(),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPConnection\x00login""])) {            return $a;        }        // BC layer in the amqp lib        if (method_exists($c, 'getReadTimeout')) {            $timeout = $c->getReadTimeout();        } else {            $timeout = $c->getTimeout();        }        $a += [            $prefix.'is_connected' => $c->isConnected(),            $prefix.'login' => $c->getLogin(),            $prefix.'password' => $c->getPassword(),            $prefix.'host' => $c->getHost(),            $prefix.'vhost' => $c->getVhost(),            $prefix.'port' => $c->getPort(),            $prefix.'read_timeout' => $timeout,        ];        return $a;    }    public static function castChannel(\AMQPChannel $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'is_connected' => $c->isConnected(),            $prefix.'channel_id' => $c->getChannelId(),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPChannel\x00connection""])) {            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'prefetch_size' => $c->getPrefetchSize(),            $prefix.'prefetch_count' => $c->getPrefetchCount(),        ];        return $a;    }    public static function castQueue(\AMQPQueue $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'flags' => self::extractFlags($c->getFlags()),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPQueue\x00name""])) {            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'channel' => $c->getChannel(),            $prefix.'name' => $c->getName(),            $prefix.'arguments' => $c->getArguments(),        ];        return $a;    }    public static function castExchange(\AMQPExchange $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'flags' => self::extractFlags($c->getFlags()),        ];        $type = isset(self::EXCHANGE_TYPES[$c->getType()]) ? new ConstStub(self::EXCHANGE_TYPES[$c->getType()], $c->getType()) : $c->getType();        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPExchange\x00name""])) {            $a[""\x00AMQPExchange\x00type""] = $type;            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'channel' => $c->getChannel(),            $prefix.'name' => $c->getName(),            $prefix.'type' => $type,            $prefix.'arguments' => $c->getArguments(),        ];        return $a;    }    public static function castEnvelope(\AMQPEnvelope $c, array $a, Stub $stub, bool $isNested, int $filter = 0)    {        $prefix = Caster::PREFIX_VIRTUAL;        $deliveryMode = new ConstStub($c->getDeliveryMode().(2 === $c->getDeliveryMode() ? ' (persistent)' : ' (non-persistent)'), $c->getDeliveryMode());        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPEnvelope\x00body""])) {            $a[""\0AMQPEnvelope\0delivery_mode""] = $deliveryMode;            return $a;        }        if (!($filter & Caster::EXCLUDE_VERBOSE)) {            $a += [$prefix.'body' => $c->getBody()];        }        $a += [            $prefix.'delivery_tag' => $c->getDeliveryTag(),            $prefix.'is_redelivery' => $c->isRedelivery(),            $prefix.'exchange_name' => $c->getExchangeName(),            $prefix.'routing_key' => $c->getRoutingKey(),            $prefix.'content_type' => $c->getContentType(),            $prefix.'content_encoding' => $c->getContentEncoding(),            $prefix.'headers' => $c->getHeaders(),            $prefix.'delivery_mode' => $deliveryMode,            $prefix.'priority' => $c->getPriority(),            $prefix.'correlation_id' => $c->getCorrelationId(),            $prefix.'reply_to' => $c->getReplyTo(),            $prefix.'expiration' => $c->getExpiration(),            $prefix.'message_id' => $c->getMessageId(),            $prefix.'timestamp' => $c->getTimeStamp(),            $prefix.'type' => $c->getType(),            $prefix.'user_id' => $c->getUserId(),            $prefix.'app_id' => $c->getAppId(),        ];        return $a;    }    private static function extractFlags(int $flags): ConstStub    {        $flagsArray = [];        foreach (self::FLAGS as $value => $name) {            if ($flags & $value) {                $flagsArray[] = $name;            }        }        if (!$flagsArray) {            $flagsArray = ['AMQP_NOPARAM'];        }        return new ConstStub(implode('|', $flagsArray), $flags);    }}",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7002, Write statistics data to disk.\n\n @return void\n,Zapisuje statističke podatke na disk,"    protected static function writeConnectionsStatisticsToStatusFile()    {        // For master process.        if (static::$_masterPid === \posix_getpid()) {            \file_put_contents(static::$_statisticsFile, ""--------------------------------------------------------------------- WORKERMAN CONNECTION STATUS --------------------------------------------------------------------------------\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile, ""PID      Worker          CID       Trans   Protocol        ipv4   ipv6   Recv-Q       Send-Q       Bytes-R      Bytes-W       Status         Local Address          Foreign Address\n"", \FILE_APPEND);            \chmod(static::$_statisticsFile, 0722);            foreach (static::getAllWorkerPids() as $worker_pid) {                \posix_kill($worker_pid, \SIGIO);            }            return;        }        // For child processes.        $bytes_format = function($bytes)        {            if($bytes > 1024*1024*1024*1024) {                return round($bytes/(1024*1024*1024*1024), 1).""TB"";            }            if($bytes > 1024*1024*1024) {                return round($bytes/(1024*1024*1024), 1).""GB"";            }            if($bytes > 1024*1024) {                return round($bytes/(1024*1024), 1).""MB"";            }            if($bytes > 1024) {                return round($bytes/(1024), 1).""KB"";            }            return $bytes.""B"";        };        $pid = \posix_getpid();        $str = '';        \reset(static::$_workers);        $current_worker = current(static::$_workers);        $default_worker_name = $current_worker->name;        /** @var \Workerman\Worker $worker */        foreach(TcpConnection::$connections as $connection) {            /** @var \Workerman\Connection\TcpConnection $connection */            $transport      = $connection->transport;            $ipv4           = $connection->isIpV4() ? ' 1' : ' 0';            $ipv6           = $connection->isIpV6() ? ' 1' : ' 0';            $recv_q         = $bytes_format($connection->getRecvBufferQueueSize());            $send_q         = $bytes_format($connection->getSendBufferQueueSize());            $local_address  = \trim($connection->getLocalAddress());            $remote_address = \trim($connection->getRemoteAddress());            $state          = $connection->getStatus(false);            $bytes_read     = $bytes_format($connection->bytesRead);            $bytes_written  = $bytes_format($connection->bytesWritten);            $id             = $connection->id;            $protocol       = $connection->protocol ? $connection->protocol : $connection->transport;            $pos            = \strrpos($protocol, '\\');            if ($pos) {                $protocol = \substr($protocol, $pos+1);            }            if (\strlen($protocol) > 15) {                $protocol = \substr($protocol, 0, 13) . '..';            }            $worker_name = isset($connection->worker) ? $connection->worker->name : $default_worker_name;            if (\strlen($worker_name) > 14) {                $worker_name = \substr($worker_name, 0, 12) . '..';            }            $str .= \str_pad($pid, 9) . \str_pad($worker_name, 16) .  \str_pad($id, 10) . \str_pad($transport, 8)                . \str_pad($protocol, 16) . \str_pad($ipv4, 7) . \str_pad($ipv6, 7) . \str_pad($recv_q, 13)                . \str_pad($send_q, 13) . \str_pad($bytes_read, 13) . \str_pad($bytes_written, 13) . ' '                . \str_pad($state, 14) . ' ' . \str_pad($local_address, 22) . ' ' . \str_pad($remote_address, 22) .""\n"";        }        if ($str) {            \file_put_contents(static::$_statisticsFile, $str, \FILE_APPEND);        }    }",0,0,2,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7372, check if child processes is really running\n,Proverite da li se podređeni procesi zaista izvode,"    protected static function writeConnectionsStatisticsToStatusFile()    {        // For master process.        if (static::$_masterPid === \posix_getpid()) {            \file_put_contents(static::$_statisticsFile, ""--------------------------------------------------------------------- WORKERMAN CONNECTION STATUS --------------------------------------------------------------------------------\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile, ""PID      Worker          CID       Trans   Protocol        ipv4   ipv6   Recv-Q       Send-Q       Bytes-R      Bytes-W       Status         Local Address          Foreign Address\n"", \FILE_APPEND);            \chmod(static::$_statisticsFile, 0722);            foreach (static::getAllWorkerPids() as $worker_pid) {                \posix_kill($worker_pid, \SIGIO);            }            return;        }        // For child processes.        $bytes_format = function($bytes)        {            if($bytes > 1024*1024*1024*1024) {                return round($bytes/(1024*1024*1024*1024), 1).""TB"";            }            if($bytes > 1024*1024*1024) {                return round($bytes/(1024*1024*1024), 1).""GB"";            }            if($bytes > 1024*1024) {                return round($bytes/(1024*1024), 1).""MB"";            }            if($bytes > 1024) {                return round($bytes/(1024), 1).""KB"";            }            return $bytes.""B"";        };        $pid = \posix_getpid();        $str = '';        \reset(static::$_workers);        $current_worker = current(static::$_workers);        $default_worker_name = $current_worker->name;        /** @var \Workerman\Worker $worker */        foreach(TcpConnection::$connections as $connection) {            /** @var \Workerman\Connection\TcpConnection $connection */            $transport      = $connection->transport;            $ipv4           = $connection->isIpV4() ? ' 1' : ' 0';            $ipv6           = $connection->isIpV6() ? ' 1' : ' 0';            $recv_q         = $bytes_format($connection->getRecvBufferQueueSize());            $send_q         = $bytes_format($connection->getSendBufferQueueSize());            $local_address  = \trim($connection->getLocalAddress());            $remote_address = \trim($connection->getRemoteAddress());            $state          = $connection->getStatus(false);            $bytes_read     = $bytes_format($connection->bytesRead);            $bytes_written  = $bytes_format($connection->bytesWritten);            $id             = $connection->id;            $protocol       = $connection->protocol ? $connection->protocol : $connection->transport;            $pos            = \strrpos($protocol, '\\');            if ($pos) {                $protocol = \substr($protocol, $pos+1);            }            if (\strlen($protocol) > 15) {                $protocol = \substr($protocol, 0, 13) . '..';            }            $worker_name = isset($connection->worker) ? $connection->worker->name : $default_worker_name;            if (\strlen($worker_name) > 14) {                $worker_name = \substr($worker_name, 0, 12) . '..';            }            $str .= \str_pad($pid, 9) . \str_pad($worker_name, 16) .  \str_pad($id, 10) . \str_pad($transport, 8)                . \str_pad($protocol, 16) . \str_pad($ipv4, 7) . \str_pad($ipv6, 7) . \str_pad($recv_q, 13)                . \str_pad($send_q, 13) . \str_pad($bytes_read, 13) . \str_pad($bytes_written, 13) . ' '                . \str_pad($state, 14) . ' ' . \str_pad($local_address, 22) . ' ' . \str_pad($remote_address, 22) .""\n"";        }        if ($str) {            \file_put_contents(static::$_statisticsFile, $str, \FILE_APPEND);        }    }",0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7771, Stop current worker instance.\n\n @return void\n,Zaustavite trenutnu radnu instancu,"class Worker{    /**     * Version.     *     * @var string     */    const VERSION = '4.0.19';    /**     * Status starting.     *     * @var int     */    const STATUS_STARTING = 1;    /**     * Status running.     *     * @var int     */    const STATUS_RUNNING = 2;    /**     * Status shutdown.     *     * @var int     */    const STATUS_SHUTDOWN = 4;    /**     * Status reloading.     *     * @var int     */    const STATUS_RELOADING = 8;    /**     * After sending the restart command to the child process KILL_WORKER_TIMER_TIME seconds,     * if the process is still living then forced to kill.     *     * @var int     */    const KILL_WORKER_TIMER_TIME = 2;    /**     * Default backlog. Backlog is the maximum length of the queue of pending connections.     *     * @var int     */    const DEFAULT_BACKLOG = 102400;    /**     * Max udp package size.     *     * @var int     */    const MAX_UDP_PACKAGE_SIZE = 65535;    /**     * The safe distance for columns adjacent     *     * @var int     */    const UI_SAFE_LENGTH = 4;    /**     * Worker id.     *     * @var int     */    public $id = 0;    /**     * Name of the worker processes.     *     * @var string     */    public $name = 'none';    /**     * Number of worker processes.     *     * @var int     */    public $count = 1;    /**     * Unix user of processes, needs appropriate privileges (usually root).     *     * @var string     */    public $user = '';    /**     * Unix group of processes, needs appropriate privileges (usually root).     *     * @var string     */    public $group = '';    /**     * reloadable.     *     * @var bool     */    public $reloadable = true;    /**     * reuse port.     *     * @var bool     */    public $reusePort = false;    /**     * Emitted when worker processes start.     *     * @var callable     */    public $onWorkerStart = null;    /**     * Emitted when a socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when data is received.     *     * @var callable     */    public $onMessage = null;    /**     * Emitted when the other end of the socket sends a FIN packet.     *     * @var callable     */    public $onClose = null;    /**     * Emitted when an error occurs with connection.     *     * @var callable     */    public $onError = null;    /**     * Emitted when the send buffer becomes full.     *     * @var callable     */    public $onBufferFull = null;    /**     * Emitted when the send buffer becomes empty.     *     * @var callable     */    public $onBufferDrain = null;    /**     * Emitted when worker processes stoped.     *     * @var callable     */    public $onWorkerStop = null;    /**     * Emitted when worker processes get reload signal.     *     * @var callable     */    public $onWorkerReload = null;    /**     * Transport layer protocol.     *     * @var string     */    public $transport = 'tcp';    /**     * Store all connections of clients.     *     * @var array     */    public $connections = array();    /**     * Application layer protocol.     *     * @var string     */    public $protocol = null;    /**     * Root path for autoload.     *     * @var string     */    protected $_autoloadRootPath = '';    /**     * Pause accept new connections or not.     *     * @var bool     */    protected $_pauseAccept = true;    /**     * Is worker stopping ?     * @var bool     */    public $stopping = false;    /**     * Daemonize.     *     * @var bool     */    public static $daemonize = false;    /**     * Stdout file.     *     * @var string     */    public static $stdoutFile = '/dev/null';    /**     * The file to store master process PID.     *     * @var string     */    public static $pidFile = '';    /**     * Log file.     *     * @var mixed     */    public static $logFile = '';    /**     * Global event loop.     *     * @var EventInterface     */    public static $globalEvent = null;    /**     * Emitted when the master process get reload signal.     *     * @var callable     */    public static $onMasterReload = null;    /**     * Emitted when the master process terminated.     *     * @var callable     */    public static $onMasterStop = null;    /**     * EventLoopClass     *     * @var string     */    public static $eventLoopClass = '';    /**     * Process title     *     * @var string     */    public static $processTitle = 'WorkerMan';    /**     * The PID of master process.     *     * @var int     */    protected static $_masterPid = 0;    /**     * Listening socket.     *     * @var resource     */    protected $_mainSocket = null;    /**     * Socket name. The format is like this http://0.0.0.0:80 .     *     * @var string     */    protected $_socketName = '';    /** parse from _socketName avoid parse again in master or worker     * LocalSocket The format is like tcp://0.0.0.0:8080     * @var string     */    protected $_localSocket=null;    /**     * Context of socket.     *     * @var resource     */    protected $_context = null;    /**     * All worker instances.     *     * @var Worker[]     */    protected static $_workers = array();    /**     * All worker processes pid.     * The format is like this [worker_id=>[pid=>pid, pid=>pid, ..], ..]     *     * @var array     */    protected static $_pidMap = array();    /**     * All worker processes waiting for restart.     * The format is like this [pid=>pid, pid=>pid].     *     * @var array     */    protected static $_pidsToRestart = array();    /**     * Mapping from PID to worker process ID.     * The format is like this [worker_id=>[0=>$pid, 1=>$pid, ..], ..].     *     * @var array     */    protected static $_idMap = array();    /**     * Current status.     *     * @var int     */    protected static $_status = self::STATUS_STARTING;    /**     * Maximum length of the worker names.     *     * @var int     */    protected static $_maxWorkerNameLength = 12;    /**     * Maximum length of the socket names.     *     * @var int     */    protected static $_maxSocketNameLength = 12;    /**     * Maximum length of the process user names.     *     * @var int     */    protected static $_maxUserNameLength = 12;    /**     * Maximum length of the Proto names.     *     * @var int     */    protected static $_maxProtoNameLength = 4;    /**     * Maximum length of the Processes names.     *     * @var int     */    protected static $_maxProcessesNameLength = 9;    /**     * Maximum length of the Status names.     *     * @var int     */    protected static $_maxStatusNameLength = 1;    /**     * The file to store status info of current worker process.     *     * @var string     */    protected static $_statisticsFile = '';    /**     * Start file.     *     * @var string     */    protected static $_startFile = '';    /**     * OS.     *     * @var string     */    protected static $_OS = \OS_TYPE_LINUX;    /**     * Processes for windows.     *     * @var array     */    protected static $_processForWindows = array();    /**     * Status info of current worker process.     *     * @var array     */    protected static $_globalStatistics = array(        'start_timestamp'  => 0,        'worker_exit_info' => array()    );    /**     * Available event loops.     *     * @var array     */    protected static $_availableEventLoops = array(        'event'    => '\Workerman\Events\Event',        'libevent' => '\Workerman\Events\Libevent'    );    /**     * PHP built-in protocols.     *     * @var array     */    protected static $_builtinTransports = array(        'tcp'   => 'tcp',        'udp'   => 'udp',        'unix'  => 'unix',        'ssl'   => 'tcp'    );    /**     * PHP built-in error types.     *     * @var array     */    protected static $_errorType = array(        \E_ERROR             => 'E_ERROR',             // 1        \E_WARNING           => 'E_WARNING',           // 2        \E_PARSE             => 'E_PARSE',             // 4        \E_NOTICE            => 'E_NOTICE',            // 8        \E_CORE_ERROR        => 'E_CORE_ERROR',        // 16        \E_CORE_WARNING      => 'E_CORE_WARNING',      // 32        \E_COMPILE_ERROR     => 'E_COMPILE_ERROR',     // 64        \E_COMPILE_WARNING   => 'E_COMPILE_WARNING',   // 128        \E_USER_ERROR        => 'E_USER_ERROR',        // 256        \E_USER_WARNING      => 'E_USER_WARNING',      // 512        \E_USER_NOTICE       => 'E_USER_NOTICE',       // 1024        \E_STRICT            => 'E_STRICT',            // 2048        \E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR', // 4096        \E_DEPRECATED        => 'E_DEPRECATED',        // 8192        \E_USER_DEPRECATED   => 'E_USER_DEPRECATED'   // 16384    );    /**     * Graceful stop or not.     *     * @var bool     */    protected static $_gracefulStop = false;    /**     * Standard output stream     * @var resource     */    protected static $_outputStream = null;    /**     * If $outputStream support decorated     * @var bool     */    protected static $_outputDecorated = null;    /**     * Run all worker instances.     *     * @return void     */    public static function runAll()    {        static::checkSapiEnv();        static::init();        static::parseCommand();        static::daemonize();        static::initWorkers();        static::installSignal();        static::saveMasterPid();        static::displayUI();        static::forkWorkers();        static::resetStd();        static::monitorWorkers();    }    /**     * Check sapi.     *     * @return void     */    protected static function checkSapiEnv()    {        // Only for cli.        if (\PHP_SAPI !== 'cli') {            exit(""Only run in command line mode \n"");        }        if (\DIRECTORY_SEPARATOR === '\\') {            self::$_OS = \OS_TYPE_WINDOWS;        }    }    /**     * Init.     *     * @return void     */    protected static function init()    {        \set_error_handler(function($code, $msg, $file, $line){            Worker::safeEcho(""$msg in file $file on line $line\n"");        });        // Start file.        $backtrace        = \debug_backtrace();        static::$_startFile = $backtrace[\count($backtrace) - 1]['file'];        $unique_prefix = \str_replace('/', '_', static::$_startFile);        // Pid file.        if (empty(static::$pidFile)) {            static::$pidFile = __DIR__ . ""/../$unique_prefix.pid"";        }        // Log file.        if (empty(static::$logFile)) {            static::$logFile = __DIR__ . '/../workerman.log';        }        $log_file = (string)static::$logFile;        if (!\is_file($log_file)) {            \touch($log_file);            \chmod($log_file, 0622);        }        // State.        static::$_status = static::STATUS_STARTING;        // For statistics.        static::$_globalStatistics['start_timestamp'] = \time();        // Process title.        static::setProcessTitle(static::$processTitle . ': master process  start_file=' . static::$_startFile);        // Init data for worker id.        static::initId();        // Timer init.        Timer::init();    }    /**     * Lock.     *     * @return void     */    protected static function lock()    {        $fd = \fopen(static::$_startFile, 'r');        if ($fd && !flock($fd, LOCK_EX)) {            static::log('Workerman['.static::$_startFile.'] already running.');            exit;        }    }    /**     * Unlock.     *     * @return void     */    protected static function unlock()    {        $fd = \fopen(static::$_startFile, 'r');        $fd && flock($fd, \LOCK_UN);    }    /**     * Init All worker instances.     *     * @return void     */    protected static function initWorkers()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        static::$_statisticsFile = __DIR__ . '/../workerman-' .posix_getpid().'.status';        foreach (static::$_workers as $worker) {            // Worker name.            if (empty($worker->name)) {                $worker->name = 'none';            }            // Get unix user of the worker process.            if (empty($worker->user)) {                $worker->user = static::getCurrentUser();            } else {                if (\posix_getuid() !== 0 && $worker->user !== static::getCurrentUser()) {                    static::log('Warning: You must have the root privileges to change uid and gid.');                }            }            // Socket name.            $worker->socket = $worker->getSocketName();            // Status name.            $worker->status = '<g> [OK] </g>';            // Get column mapping for UI            foreach(static::getUiColumns() as $column_name => $prop){                !isset($worker->{$prop}) && $worker->{$prop} = 'NNNN';                $prop_length = \strlen($worker->{$prop});                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                static::$$key = \max(static::$$key, $prop_length);            }            // Listen.            if (!$worker->reusePort) {                $worker->listen();            }        }    }    /**     * Reload all worker instances.     *     * @return void     */    public static function reloadAllWorkers()    {        static::init();        static::initWorkers();        static::displayUI();        static::$_status = static::STATUS_RELOADING;    }    /**     * Get all worker instances.     *     * @return array     */    public static function getAllWorkers()    {        return static::$_workers;    }    /**     * Get global event-loop instance.     *     * @return EventInterface     */    public static function getEventLoop()    {        return static::$globalEvent;    }    /**     * Get main socket resource     * @return resource     */    public function getMainSocket(){        return $this->_mainSocket;    }    /**     * Init idMap.     * return void     */    protected static function initId()    {        foreach (static::$_workers as $worker_id => $worker) {            $new_id_map = array();            $worker->count = $worker->count < 1 ? 1 : $worker->count;            for($key = 0; $key < $worker->count; $key++) {                $new_id_map[$key] = isset(static::$_idMap[$worker_id][$key]) ? static::$_idMap[$worker_id][$key] : 0;            }            static::$_idMap[$worker_id] = $new_id_map;        }    }    /**     * Get unix user of current porcess.     *     * @return string     */    protected static function getCurrentUser()    {        $user_info = \posix_getpwuid(\posix_getuid());        return $user_info['name'];    }    /**     * Display staring UI.     *     * @return void     */    protected static function displayUI()    {        global $argv;        if (\in_array('-q', $argv)) {            return;        }        if (static::$_OS !== \OS_TYPE_LINUX) {            static::safeEcho(""----------------------- WORKERMAN -----------------------------\r\n"");            static::safeEcho('Workerman version:'. static::VERSION. '          PHP version:'. \PHP_VERSION. ""\r\n"");            static::safeEcho(""------------------------ WORKERS -------------------------------\r\n"");            static::safeEcho(""worker               listen                              processes status\r\n"");            return;        }        //show version        $line_version = 'Workerman version:' . static::VERSION . \str_pad('PHP version:', 22, ' ', \STR_PAD_LEFT) . \PHP_VERSION . \PHP_EOL;        !\defined('LINE_VERSIOIN_LENGTH') && \define('LINE_VERSIOIN_LENGTH', \strlen($line_version));        $total_length = static::getSingleLineTotalLength();        $line_one = '<n>' . \str_pad('<w> WORKERMAN </w>', $total_length + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . '</n>'. \PHP_EOL;        $line_two = \str_pad('<w> WORKERS </w>' , $total_length  + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . \PHP_EOL;        static::safeEcho($line_one . $line_version . $line_two);        //Show title        $title = '';        foreach(static::getUiColumns() as $column_name => $prop){            $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';            //just keep compatible with listen name            $column_name === 'socket' && $column_name = 'listen';            $title.= ""<w>{$column_name}</w>""  .  \str_pad('', static::$$key + static::UI_SAFE_LENGTH - \strlen($column_name));        }        $title && static::safeEcho($title . \PHP_EOL);        //Show content        foreach (static::$_workers as $worker) {            $content = '';            foreach(static::getUiColumns() as $column_name => $prop){                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                \preg_match_all(""/(<n>|<\/n>|<w>|<\/w>|<g>|<\/g>)/is"", $worker->{$prop}, $matches);                $place_holder_length = !empty($matches) ? \strlen(\implode('', $matches[0])) : 0;                $content .= \str_pad($worker->{$prop}, static::$$key + static::UI_SAFE_LENGTH + $place_holder_length);            }            $content && static::safeEcho($content . \PHP_EOL);        }        //Show last line        $line_last = \str_pad('', static::getSingleLineTotalLength(), '-') . \PHP_EOL;        !empty($content) && static::safeEcho($line_last);        if (static::$daemonize) {            foreach ($argv as $index => $value) {                if ($value == '-d') {                    unset($argv[$index]);                } elseif ($value == 'start' || $value == 'restart') {                    $argv[$index] = 'stop';                }            }            static::safeEcho(""Input \""php "".implode(' ', $argv).""\"" to stop. Start success.\n\n"");        } else {            static::safeEcho(""Press Ctrl+C to stop. Start success.\n"");        }    }    /**     * Get UI columns to be shown in terminal     *     * 1. $column_map: array('ui_column_name' => 'clas_property_name')     * 2. Consider move into configuration in future     *     * @return array     */    public static function getUiColumns()    {        return array(            'proto'     =>  'transport',            'user'      =>  'user',            'worker'    =>  'name',            'socket'    =>  'socket',            'processes' =>  'count',            'status'    =>  'status',        );    }    /**     * Get single line total length for ui     *     * @return int     */    public static function getSingleLineTotalLength()    {        $total_length = 0;        foreach(static::getUiColumns() as $column_name => $prop){            $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';            $total_length += static::$$key + static::UI_SAFE_LENGTH;        }        //keep beauty when show less colums        !\defined('LINE_VERSIOIN_LENGTH') && \define('LINE_VERSIOIN_LENGTH', 0);        $total_length <= LINE_VERSIOIN_LENGTH && $total_length = LINE_VERSIOIN_LENGTH;        return $total_length;    }    /**     * Parse command.     *     * @return void     */    protected static function parseCommand()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        global $argv;        // Check argv;        $start_file = $argv[0];        $usage = ""Usage: php yourfile <command> [mode]\nCommands: \nstart\t\tStart worker in DEBUG mode.\n\t\tUse mode -d to start in DAEMON mode.\nstop\t\tStop worker.\n\t\tUse mode -g to stop gracefully.\nrestart\t\tRestart workers.\n\t\tUse mode -d to start in DAEMON mode.\n\t\tUse mode -g to stop gracefully.\nreload\t\tReload codes.\n\t\tUse mode -g to reload gracefully.\nstatus\t\tGet worker status.\n\t\tUse mode -d to show live status.\nconnections\tGet worker connections.\n"";        $available_commands = array(            'start',            'stop',            'restart',            'reload',            'status',            'connections',        );        $available_mode = array(            '-d',            '-g'        );        $command = $mode = '';        foreach ($argv as $value) {            if (\in_array($value, $available_commands)) {                $command = $value;            } elseif (\in_array($value, $available_mode)) {                $mode = $value;            }        }        if (!$command) {            exit($usage);        }        // Start command.        $mode_str = '';        if ($command === 'start') {            if ($mode === '-d' || static::$daemonize) {                $mode_str = 'in DAEMON mode';            } else {                $mode_str = 'in DEBUG mode';            }        }        static::log(""Workerman[$start_file] $command $mode_str"");        // Get master process PID.        $master_pid      = \is_file(static::$pidFile) ? (int)\file_get_contents(static::$pidFile) : 0;        // Master is still alive?        if (static::checkMasterIsAlive($master_pid)) {            if ($command === 'start') {                static::log(""Workerman[$start_file] already running"");                exit;            }        } elseif ($command !== 'start' && $command !== 'restart') {            static::log(""Workerman[$start_file] not run"");            exit;        }        $statistics_file =  __DIR__ . ""/../workerman-$master_pid.status"";        // execute command.        switch ($command) {            case 'start':                if ($mode === '-d') {                    static::$daemonize = true;                }                break;            case 'status':                while (1) {                    if (\is_file($statistics_file)) {                        @\unlink($statistics_file);                    }                    // Master process will send SIGUSR2 signal to all child processes.                    \posix_kill($master_pid, SIGUSR2);                    // Sleep 1 second.                    \sleep(1);                    // Clear terminal.                    if ($mode === '-d') {                        static::safeEcho(""\33[H\33[2J\33(B\33[m"", true);                    }                    // Echo status data.                    static::safeEcho(static::formatStatusData($statistics_file));                    if ($mode !== '-d') {                        exit(0);                    }                    static::safeEcho(""\nPress Ctrl+C to quit.\n\n"");                }                exit(0);            case 'connections':                if (\is_file($statistics_file) && \is_writable($statistics_file)) {                    \unlink($statistics_file);                }                // Master process will send SIGIO signal to all child processes.                \posix_kill($master_pid, SIGIO);                // Waiting amoment.                \usleep(500000);                // Display statisitcs data from a disk file.                if(\is_readable($statistics_file)) {                    \readfile($statistics_file);                }                exit(0);            case 'restart':            case 'stop':                if ($mode === '-g') {                    static::$_gracefulStop = true;                    $sig = \SIGHUP;                    static::log(""Workerman[$start_file] is gracefully stopping ..."");                } else {                    static::$_gracefulStop = false;                    $sig = \SIGINT;                    static::log(""Workerman[$start_file] is stopping ..."");                }                // Send stop signal to master process.                $master_pid && \posix_kill($master_pid, $sig);                // Timeout.                $timeout    = 5;                $start_time = \time();                // Check master process is still alive?                while (1) {                    $master_is_alive = $master_pid && \posix_kill((int) $master_pid, 0);                    if ($master_is_alive) {                        // Timeout?                        if (!static::$_gracefulStop && \time() - $start_time >= $timeout) {                            static::log(""Workerman[$start_file] stop fail"");                            exit;                        }                        // Waiting amoment.                        \usleep(10000);                        continue;                    }                    // Stop success.                    static::log(""Workerman[$start_file] stop success"");                    if ($command === 'stop') {                        exit(0);                    }                    if ($mode === '-d') {                        static::$daemonize = true;                    }                    break;                }                break;            case 'reload':                if($mode === '-g'){                    $sig = \SIGQUIT;                }else{                    $sig = \SIGUSR1;                }                \posix_kill($master_pid, $sig);                exit;            default :                if (isset($command)) {                    static::safeEcho('Unknown command: ' . $command . ""\n"");                }                exit($usage);        }    }    /**     * Format status data.     *     * @param $statistics_file     * @return string     */    protected static function formatStatusData($statistics_file)    {        static $total_request_cache = array();        if (!\is_readable($statistics_file)) {            return '';        }        $info = \file($statistics_file, \FILE_IGNORE_NEW_LINES);        if (!$info) {            return '';        }        $status_str = '';        $current_total_request = array();        $worker_info = \unserialize($info[0]);        \ksort($worker_info, SORT_NUMERIC);        unset($info[0]);        $data_waiting_sort = array();        $read_process_status = false;        $total_requests = 0;        $total_qps = 0;        $total_connections = 0;        $total_fails = 0;        $total_memory = 0;        $total_timers = 0;        $maxLen1 = static::$_maxSocketNameLength;        $maxLen2 = static::$_maxWorkerNameLength;        foreach($info as $key => $value) {            if (!$read_process_status) {                $status_str .= $value . ""\n"";                if (\preg_match('/^pid.*?memory.*?listening/', $value)) {                    $read_process_status = true;                }                continue;            }            if(\preg_match('/^[0-9]+/', $value, $pid_math)) {                $pid = $pid_math[0];                $data_waiting_sort[$pid] = $value;                if(\preg_match('/^\S+?\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?/', $value, $match)) {                    $total_memory += \intval(\str_ireplace('M','',$match[1]));                    $maxLen1 = \max($maxLen1,\strlen($match[2]));                    $maxLen2 = \max($maxLen2,\strlen($match[3]));                    $total_connections += \intval($match[4]);                    $total_fails += \intval($match[5]);                    $total_timers += \intval($match[6]);                    $current_total_request[$pid] = $match[7];                    $total_requests += \intval($match[7]);                }            }        }        foreach($worker_info as $pid => $info) {            if (!isset($data_waiting_sort[$pid])) {                $status_str .= ""$pid\t"" . \str_pad('N/A', 7) . "" ""                    . \str_pad($info['listen'], static::$_maxSocketNameLength) . "" ""                    . \str_pad($info['name'], static::$_maxWorkerNameLength) . "" ""                    . \str_pad('N/A', 11) . "" "" . \str_pad('N/A', 9) . "" ""                    . \str_pad('N/A', 7) . "" "" . \str_pad('N/A', 13) . "" N/A    [busy] \n"";                continue;            }            //$qps = isset($total_request_cache[$pid]) ? $current_total_request[$pid]            if (!isset($total_request_cache[$pid]) || !isset($current_total_request[$pid])) {                $qps = 0;            } else {                $qps = $current_total_request[$pid] - $total_request_cache[$pid];                $total_qps += $qps;            }            $status_str .= $data_waiting_sort[$pid]. "" "" . \str_pad($qps, 6) ."" [idle]\n"";        }        $total_request_cache = $current_total_request;        $status_str .= ""----------------------------------------------PROCESS STATUS---------------------------------------------------\n"";        $status_str .= ""Summary\t"" . \str_pad($total_memory.'M', 7) . "" ""            . \str_pad('-', $maxLen1) . "" ""            . \str_pad('-', $maxLen2) . "" ""            . \str_pad($total_connections, 11) . "" "" . \str_pad($total_fails, 9) . "" ""            . \str_pad($total_timers, 7) . "" "" . \str_pad($total_requests, 13) . "" ""            . \str_pad($total_qps,6)."" [Summary] \n"";        return $status_str;    }    /**     * Install signal handler.     *     * @return void     */    protected static function installSignal()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        $signalHandler = '\Workerman\Worker::signalHandler';        // stop        \pcntl_signal(\SIGINT, $signalHandler, false);        // stop        \pcntl_signal(\SIGTERM, $signalHandler, false);        // graceful stop        \pcntl_signal(\SIGHUP, $signalHandler, false);        // reload        \pcntl_signal(\SIGUSR1, $signalHandler, false);        // graceful reload        \pcntl_signal(\SIGQUIT, $signalHandler, false);        // status        \pcntl_signal(\SIGUSR2, $signalHandler, false);        // connection status        \pcntl_signal(\SIGIO, $signalHandler, false);        // ignore        \pcntl_signal(\SIGPIPE, \SIG_IGN, false);    }    /**     * Reinstall signal handler.     *     * @return void     */    protected static function reinstallSignal()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        $signalHandler = '\Workerman\Worker::signalHandler';        // uninstall stop signal handler        \pcntl_signal(\SIGINT, \SIG_IGN, false);        // uninstall stop signal handler        \pcntl_signal(\SIGTERM, \SIG_IGN, false);        // uninstall graceful stop signal handler        \pcntl_signal(\SIGHUP, \SIG_IGN, false);        // uninstall reload signal handler        \pcntl_signal(\SIGUSR1, \SIG_IGN, false);        // uninstall graceful reload signal handler        \pcntl_signal(\SIGQUIT, \SIG_IGN, false);        // uninstall status signal handler        \pcntl_signal(\SIGUSR2, \SIG_IGN, false);        // uninstall connections status signal handler        \pcntl_signal(\SIGIO, \SIG_IGN, false);        // reinstall stop signal handler        static::$globalEvent->add(\SIGINT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful stop signal handler        static::$globalEvent->add(\SIGHUP, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall reload signal handler        static::$globalEvent->add(\SIGUSR1, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful reload signal handler        static::$globalEvent->add(\SIGQUIT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall status signal handler        static::$globalEvent->add(\SIGUSR2, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall connection status signal handler        static::$globalEvent->add(\SIGIO, EventInterface::EV_SIGNAL, $signalHandler);    }    /**     * Signal handler.     *     * @param int $signal     */    public static function signalHandler($signal)    {        switch ($signal) {            // Stop.            case \SIGINT:            case \SIGTERM:                static::$_gracefulStop = false;                static::stopAll();                break;            // Graceful stop.            case \SIGHUP:                static::$_gracefulStop = true;                static::stopAll();                break;            // Reload.            case \SIGQUIT:            case \SIGUSR1:                static::$_gracefulStop = $signal === \SIGQUIT;                static::$_pidsToRestart = static::getAllWorkerPids();                static::reload();                break;            // Show status.            case \SIGUSR2:                static::writeStatisticsToStatusFile();                break;            // Show connection status.            case \SIGIO:                static::writeConnectionsStatisticsToStatusFile();                break;        }    }    /**     * Run as deamon mode.     *     * @throws Exception     */    protected static function daemonize()    {        if (!static::$daemonize || static::$_OS !== \OS_TYPE_LINUX) {            return;        }        \umask(0);        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception('Fork fail');        } elseif ($pid > 0) {            exit(0);        }        if (-1 === \posix_setsid()) {            throw new Exception(""Setsid fail"");        }        // Fork again avoid SVR4 system regain the control of terminal.        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception(""Fork fail"");        } elseif (0 !== $pid) {            exit(0);        }    }    /**     * Redirect sta",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1080, Finder allows to build rules to find files and directories.\n\n It is a thin wrapper around several specialized iterator classes.\n\n All rules may be invoked several times.\n\n All methods return the current Finder object to allow chaining:\n\n     $finder = Finder::create()->files()->name('\n @author Fabien Potencier <fabien@symfony.com>\n,Finder omogućava izgradnju pravila za pronalaženje datoteka i direktorija. To je tanki omotač oko nekoliko specijalizovanih klasa iteratora. Sva pravila se mogu pozivati nekoliko puta. Sve metode vraćaju trenutni objekt Finder-a u dozvoliti ulančavanje,"class Finder implements \IteratorAggregate, \Countable{    public const IGNORE_VCS_FILES = 1;    public const IGNORE_DOT_FILES = 2;    public const IGNORE_VCS_IGNORED_FILES = 4;    private $mode = 0;    private $names = [];    private $notNames = [];    private $exclude = [];    private $filters = [];    private $depths = [];    private $sizes = [];    private $followLinks = false;    private $reverseSorting = false;    private $sort = false;    private $ignore = 0;    private $dirs = [];    private $dates = [];    private $iterators = [];    private $contains = [];    private $notContains = [];    private $paths = [];    private $notPaths = [];    private $ignoreUnreadableDirs = false;    private static $vcsPatterns = ['.svn', '_svn', 'CVS', '_darcs', '.arch-params', '.monotone', '.bzr', '.git', '.hg'];    public function __construct()    {        $this->ignore = static::IGNORE_VCS_FILES | static::IGNORE_DOT_FILES;    }    /**     * Creates a new Finder.     *     * @return static     */    public static function create()    {        return new static();    }    /**     * Restricts the matching to directories only.     *     * @return $this     */    public function directories()    {        $this->mode = Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES;        return $this;    }    /**     * Restricts the matching to files only.     *     * @return $this     */    public function files()    {        $this->mode = Iterator\FileTypeFilterIterator::ONLY_FILES;        return $this;    }    /**     * Adds tests for the directory depth.     *     * Usage:     *     *     $finder->depth('> 1') // the Finder will start matching at level 1.     *     $finder->depth('< 3') // the Finder will descend at most 3 levels of directories below the starting point.     *     $finder->depth(['>= 1', '< 3'])     *     * @param string|int|string[]|int[] $levels The depth level expression or an array of depth levels     *     * @return $this     *     * @see DepthRangeFilterIterator     * @see NumberComparator     */    public function depth($levels)    {        foreach ((array) $levels as $level) {            $this->depths[] = new Comparator\NumberComparator($level);        }        return $this;    }    /**     * Adds tests for file dates (last modified).     *     * The date must be something that strtotime() is able to parse:     *     *     $finder->date('since yesterday');     *     $finder->date('until 2 days ago');     *     $finder->date('> now - 2 hours');     *     $finder->date('>= 2005-10-15');     *     $finder->date(['>= 2005-10-15', '<= 2006-05-27']);     *     * @param string|string[] $dates A date range string or an array of date ranges     *     * @return $this     *     * @see strtotime     * @see DateRangeFilterIterator     * @see DateComparator     */    public function date($dates)    {        foreach ((array) $dates as $date) {            $this->dates[] = new Comparator\DateComparator($date);        }        return $this;    }    /**     * Adds rules that files must match.     *     * You can use patterns (delimited with / sign), globs or simple strings.     *     *     $finder->name('*.php')     *     $finder->name('/\.php$/') // same as above     *     $finder->name('test.php')     *     $finder->name(['test.py', 'test.php'])     *     * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function name($patterns)    {        $this->names = array_merge($this->names, (array) $patterns);        return $this;    }    /**     * Adds rules that files must not match.     *     * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function notName($patterns)    {        $this->notNames = array_merge($this->notNames, (array) $patterns);        return $this;    }    /**     * Adds tests that file contents must match.     *     * Strings or PCRE patterns can be used:     *     *     $finder->contains('Lorem ipsum')     *     $finder->contains('/Lorem ipsum/i')     *     $finder->contains(['dolor', '/ipsum/i'])     *     * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns     *     * @return $this     *     * @see FilecontentFilterIterator     */    public function contains($patterns)    {        $this->contains = array_merge($this->contains, (array) $patterns);        return $this;    }    /**     * Adds tests that file contents must not match.     *     * Strings or PCRE patterns can be used:     *     *     $finder->notContains('Lorem ipsum')     *     $finder->notContains('/Lorem ipsum/i')     *     $finder->notContains(['lorem', '/dolor/i'])     *     * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns     *     * @return $this     *     * @see FilecontentFilterIterator     */    public function notContains($patterns)    {        $this->notContains = array_merge($this->notContains, (array) $patterns);        return $this;    }    /**     * Adds rules that filenames must match.     *     * You can use patterns (delimited with / sign) or simple strings.     *     *     $finder->path('some/special/dir')     *     $finder->path('/some\/special\/dir/') // same as above     *     $finder->path(['some dir', 'another/dir'])     *     * Use only / as dirname separator.     *     * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function path($patterns)    {        $this->paths = array_merge($this->paths, (array) $patterns);        return $this;    }    /**     * Adds rules that filenames must not match.     *     * You can use patterns (delimited with / sign) or simple strings.     *     *     $finder->notPath('some/special/dir')     *     $finder->notPath('/some\/special\/dir/') // same as above     *     $finder->notPath(['some/file.txt', 'another/file.log'])     *     * Use only / as dirname separator.     *     * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function notPath($patterns)    {        $this->notPaths = array_merge($this->notPaths, (array) $patterns);        return $this;    }    /**     * Adds tests for file sizes.     *     *     $finder->size('> 10K');     *     $finder->size('<= 1Ki');     *     $finder->size(4);     *     $finder->size(['> 10K', '< 20K'])     *     * @param string|int|string[]|int[] $sizes A size range string or an integer or an array of size ranges     *     * @return $this     *     * @see SizeRangeFilterIterator     * @see NumberComparator     */    public function size($sizes)    {        foreach ((array) $sizes as $size) {            $this->sizes[] = new Comparator\NumberComparator($size);        }        return $this;    }    /**     * Excludes directories.     *     * Directories passed as argument must be relative to the ones defined with the `in()` method. For example:     *     *     $finder->in(__DIR__)->exclude('ruby');     *     * @param string|array $dirs A directory path or an array of directories     *     * @return $this     *     * @see ExcludeDirectoryFilterIterator     */    public function exclude($dirs)    {        $this->exclude = array_merge($this->exclude, (array) $dirs);        return $this;    }    /**     * Excludes ""hidden"" directories and files (starting with a dot).     *     * This option is enabled by default.     *     * @return $this     *     * @see ExcludeDirectoryFilterIterator     */    public function ignoreDotFiles(bool $ignoreDotFiles)    {        if ($ignoreDotFiles) {            $this->ignore |= static::IGNORE_DOT_FILES;        } else {            $this->ignore &= ~static::IGNORE_DOT_FILES;        }        return $this;    }    /**     * Forces the finder to ignore version control directories.     *     * This option is enabled by default.     *     * @return $this     *     * @see ExcludeDirectoryFilterIterator     */    public function ignoreVCS(bool $ignoreVCS)    {        if ($ignoreVCS) {            $this->ignore |= static::IGNORE_VCS_FILES;        } else {            $this->ignore &= ~static::IGNORE_VCS_FILES;        }        return $this;    }    /**     * Forces Finder to obey .gitignore and ignore files based on rules listed there.     *     * This option is disabled by default.     *     * @return $this     */    public function ignoreVCSIgnored(bool $ignoreVCSIgnored)    {        if ($ignoreVCSIgnored) {            $this->ignore |= static::IGNORE_VCS_IGNORED_FILES;        } else {            $this->ignore &= ~static::IGNORE_VCS_IGNORED_FILES;        }        return $this;    }    /**     * Adds VCS patterns.     *     * @see ignoreVCS()     *     * @param string|string[] $pattern VCS patterns to ignore     */    public static function addVCSPattern($pattern)    {        foreach ((array) $pattern as $p) {            self::$vcsPatterns[] = $p;        }        self::$vcsPatterns = array_unique(self::$vcsPatterns);    }    /**     * Sorts files and directories by an anonymous function.     *     * The anonymous function receives two \SplFileInfo instances to compare.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sort(\Closure $closure)    {        $this->sort = $closure;        return $this;    }    /**     * Sorts files and directories by name.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByName(bool $useNaturalSort = false)    {        $this->sort = $useNaturalSort ? Iterator\SortableIterator::SORT_BY_NAME_NATURAL : Iterator\SortableIterator::SORT_BY_NAME;        return $this;    }    /**     * Sorts files and directories by type (directories before files), then by name.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByType()    {        $this->sort = Iterator\SortableIterator::SORT_BY_TYPE;        return $this;    }    /**     * Sorts files and directories by the last accessed time.     *     * This is the time that the file was last accessed, read or written to.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByAccessedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_ACCESSED_TIME;        return $this;    }    /**     * Reverses the sorting.     *     * @return $this     */    public function reverseSorting()    {        $this->reverseSorting = true;        return $this;    }    /**     * Sorts files and directories by the last inode changed time.     *     * This is the time that the inode information was last modified (permissions, owner, group or other metadata).     *     * On Windows, since inode is not available, changed time is actually the file creation time.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByChangedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_CHANGED_TIME;        return $this;    }    /**     * Sorts files and directories by the last modified time.     *     * This is the last time the actual contents of the file were last modified.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByModifiedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_MODIFIED_TIME;        return $this;    }    /**     * Filters the iterator with an anonymous function.     *     * The anonymous function receives a \SplFileInfo and must return false     * to remove files.     *     * @return $this     *     * @see CustomFilterIterator     */    public function filter(\Closure $closure)    {        $this->filters[] = $closure;        return $this;    }    /**     * Forces the following of symlinks.     *     * @return $this     */    public function followLinks()    {        $this->followLinks = true;        return $this;    }    /**     * Tells finder to ignore unreadable directories.     *     * By default, scanning unreadable directories content throws an AccessDeniedException.     *     * @return $this     */    public function ignoreUnreadableDirs(bool $ignore = true)    {        $this->ignoreUnreadableDirs = $ignore;        return $this;    }    /**     * Searches files and directories which match defined rules.     *     * @param string|string[] $dirs A directory path or an array of directories     *     * @return $this     *     * @throws DirectoryNotFoundException if one of the directories does not exist     */    public function in($dirs)    {        $resolvedDirs = [];        foreach ((array) $dirs as $dir) {            if (is_dir($dir)) {                $resolvedDirs[] = $this->normalizeDir($dir);            } elseif ($glob = glob($dir, (\defined('GLOB_BRACE') ? \GLOB_BRACE : 0) | \GLOB_ONLYDIR | \GLOB_NOSORT)) {                sort($glob);                $resolvedDirs = array_merge($resolvedDirs, array_map([$this, 'normalizeDir'], $glob));            } else {                throw new DirectoryNotFoundException(sprintf('The ""%s"" directory does not exist.', $dir));            }        }        $this->dirs = array_merge($this->dirs, $resolvedDirs);        return $this;    }    /**     * Returns an Iterator for the current Finder configuration.     *     * This method implements the IteratorAggregate interface.     *     * @return \Iterator|SplFileInfo[] An iterator     *     * @throws \LogicException if the in() method has not been called     */    public function getIterator()    {        if (0 === \count($this->dirs) && 0 === \count($this->iterators)) {            throw new \LogicException('You must call one of in() or append() methods before iterating over a Finder.');        }        if (1 === \count($this->dirs) && 0 === \count($this->iterators)) {            $iterator = $this->searchInDirectory($this->dirs[0]);            if ($this->sort || $this->reverseSorting) {                $iterator = (new Iterator\SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();            }            return $iterator;        }        $iterator = new \AppendIterator();        foreach ($this->dirs as $dir) {            $iterator->append(new \IteratorIterator(new LazyIterator(function () use ($dir) {                return $this->searchInDirectory($dir);            })));        }        foreach ($this->iterators as $it) {            $iterator->append($it);        }        if ($this->sort || $this->reverseSorting) {            $iterator = (new Iterator\SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();        }        return $iterator;    }    /**     * Appends an existing set of files/directories to the finder.     *     * The set can be another Finder, an Iterator, an IteratorAggregate, or even a plain array.     *     * @return $this     *     * @throws \InvalidArgumentException when the given argument is not iterable     */    public function append(iterable $iterator)    {        if ($iterator instanceof \IteratorAggregate) {            $this->iterators[] = $iterator->getIterator();        } elseif ($iterator instanceof \Iterator) {            $this->iterators[] = $iterator;        } elseif ($iterator instanceof \Traversable || \is_array($iterator)) {            $it = new \ArrayIterator();            foreach ($iterator as $file) {                $file = $file instanceof \SplFileInfo ? $file : new \SplFileInfo($file);                $it[$file->getPathname()] = $file;            }            $this->iterators[] = $it;        } else {            throw new \InvalidArgumentException('Finder::append() method wrong argument type.');        }        return $this;    }    /**     * Check if any results were found.     *     * @return bool     */    public function hasResults()    {        foreach ($this->getIterator() as $_) {            return true;        }        return false;    }    /**     * Counts all the results collected by the iterators.     *     * @return int     */    public function count()    {        return iterator_count($this->getIterator());    }    private function searchInDirectory(string $dir): \Iterator    {        $exclude = $this->exclude;        $notPaths = $this->notPaths;        if (static::IGNORE_VCS_FILES === (static::IGNORE_VCS_FILES & $this->ignore)) {            $exclude = array_merge($exclude, self::$vcsPatterns);        }        if (static::IGNORE_DOT_FILES === (static::IGNORE_DOT_FILES & $this->ignore)) {            $notPaths[] = '#(^|/)\..+(/|$)#';        }        if (static::IGNORE_VCS_IGNORED_FILES === (static::IGNORE_VCS_IGNORED_FILES & $this->ignore)) {            $gitignoreFilePath = sprintf('%s/.gitignore', $dir);            if (!is_readable($gitignoreFilePath)) {                throw new \RuntimeException(sprintf('The ""ignoreVCSIgnored"" option cannot be used by the Finder as the ""%s"" file is not readable.', $gitignoreFilePath));            }            $notPaths = array_merge($notPaths, [Gitignore::toRegex(file_get_contents($gitignoreFilePath))]);        }        $minDepth = 0;        $maxDepth = \PHP_INT_MAX;        foreach ($this->depths as $comparator) {            switch ($comparator->getOperator()) {                case '>':                    $minDepth = $comparator->getTarget() + 1;                    break;                case '>=':                    $minDepth = $comparator->getTarget();                    break;                case '<':                    $maxDepth = $comparator->getTarget() - 1;                    break;                case '<=':                    $maxDepth = $comparator->getTarget();                    break;                default:                    $minDepth = $maxDepth = $comparator->getTarget();            }        }        $flags = \RecursiveDirectoryIterator::SKIP_DOTS;        if ($this->followLinks) {            $flags |= \RecursiveDirectoryIterator::FOLLOW_SYMLINKS;        }        $iterator = new Iterator\RecursiveDirectoryIterator($dir, $flags, $this->ignoreUnreadableDirs);        if ($exclude) {            $iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $exclude);        }        $iterator = new \RecursiveIteratorIterator($iterator, \RecursiveIteratorIterator::SELF_FIRST);        if ($minDepth > 0 || $maxDepth < \PHP_INT_MAX) {            $iterator = new Iterator\DepthRangeFilterIterator($iterator, $minDepth, $maxDepth);        }        if ($this->mode) {            $iterator = new Iterator\FileTypeFilterIterator($iterator, $this->mode);        }        if ($this->names || $this->notNames) {            $iterator = new Iterator\FilenameFilterIterator($iterator, $this->names, $this->notNames);        }        if ($this->contains || $this->notContains) {            $iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);        }        if ($this->sizes) {            $iterator = new Iterator\SizeRangeFilterIterator($iterator, $this->sizes);        }        if ($this->dates) {            $iterator = new Iterator\DateRangeFilterIterator($iterator, $this->dates);        }        if ($this->filters) {            $iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);        }        if ($this->paths || $notPaths) {            $iterator = new Iterator\PathFilterIterator($iterator, $this->paths, $notPaths);        }        return $iterator;    }    /**     * Normalizes given directory names by removing trailing slashes.     *     * Excluding: (s)ftp:// or ssh2.(s)ftp:// wrapper     */    private function normalizeDir(string $dir): string    {        if ('/' === $dir) {            return $dir;        }        $dir = rtrim($dir, '/'.\DIRECTORY_SEPARATOR);        if (preg_match('#^(ssh2\.)?s?ftp://#', $dir)) {            $dir .= '/';        }        return $dir;    }}",0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3492," Compute the P-th percentile of a list of numbers\\n\\n Linear interpolation between closest ranks method - Second variant, C = 1\\n P-th percentile (0 <= P <= 100) of a list of N ordered values (sorted from least to greatest)\\n Similar method used in NumPy and Excel\\n https://en.wikipedia.org/wiki/Percentile#Second_variant.2C_.7F.27.22.60UNIQ--postMath-00000043-QINU.60.22.27.7F\\n\\n      P\\n x - --- (N - 1) + 1\\n     100\\n\\n P = percentile\\n N = number of elements in list\\n\\n Î½(x) = Î½â‚“ + xï¼…1(Î½â‚“â‚Šâ‚ - Î½â‚“)\\n\\n âŒŠxâŒ‹  = integer part of x\\n xï¼…1 = fraction part of x\\n Î½â‚“   = number in position x in sorted list of numbers\\n Î½â‚“â‚Šâ‚ = number in position x + 1 in sorted list of number\\n\\n @param float[] $numbers\\n @param float   $P percentile to calculate\\n\\n @return float in list corresponding to P percentile\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if $P percentile is not between 0 and 100\\n","Izračunajte P-ti percentil iz liste brojeva . Metoda linearne interpolacije između najbližih rangova - Druga varijanta, C = 1. P-ti percentil (0 <= P <= 100) liste N uređenih vrednosti (poređanih od najmanje do najveće). Slična metoda korišćena u NumPi i Excel-u","    public static function percentile(array $numbers, float $P): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the P-th percentile of an empty list of numbers');        }        if ($P < 0 || $P > 100) {            throw new Exception\OutOfBoundsException('Percentile P must be between 0 and 100.');        }        $N = \count($numbers);        if ($N === 1) {            return \array_shift($numbers);        }        \sort($numbers);        if ($P == 100) {            return  $numbers[$N - 1];        }        $x    = ($P / 100) * ($N - 1) + 1;        $âŒŠxâŒ‹  = \intval($x);        $xï¼…1 = $x - $âŒŠxâŒ‹;        $Î½â‚“   = $numbers[$âŒŠxâŒ‹ - 1];        $Î½â‚“â‚Šâ‚ = $numbers[$âŒŠxâŒ‹];        return $Î½â‚“ + $xï¼…1 * ($Î½â‚“â‚Šâ‚ - $Î½â‚“);    }",0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericalIntegration_3024, Sorts our coordinates (arrays) by their x-component (first number) such\n that consecutive coordinates have an increasing x-component.\n\n @param  array[] $points\n\n @return array[]\n,Sortira naše koordinate (nizove) prema njihovim k-komponentama (prvi broj) tako da uzastopne koordinate imaju rastuću k-komponentu,"    protected static function sort(array $points): array    {        \usort($points, function ($a, $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }",0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_9684, Sorts items by descending quality.\n,Sortira stavke prema opadajućem kvalitetu,"    private function sort(): void    {        if (!$this->sorted) {            uasort($this->items, function (AcceptHeaderItem $a, AcceptHeaderItem $b) {                $qA = $a->getQuality();                $qB = $b->getQuality();                if ($qA === $qB) {                    return $a->getIndex() > $b->getIndex() ? 1 : -1;                }                return $qA > $qB ? -1 : 1;            });            $this->sorted = true;        }    }",0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_MaxCharacter_2067, This function returns\n the character which is\n repeated maximum no. of\n times in the given string.\n\n @param string $string\n @return string\n,Ova funkcija vraća znak koji je ponovljen maksimum br. puta u datom nizu,function maxCharacter(string $string){    if (empty($string)) {        throw new \Exception('Please pass a non-empty string value');    }    $characterCountTable = []; // A variable to maintain the character counts    $string              = strtolower($string); // For case-insensitive checking    $characters          = str_split($string); // Splitting the string to a Character Array.    foreach ($characters as $character) {        $currentCharacterCount = 1;        if (isset($characterCountTable[$character])) {            $currentCharacterCount = $characterCountTable[$character] + 1;        }        $characterCountTable[$character] = $currentCharacterCount;    }    arsort($characterCountTable);    return array_keys($characterCountTable)[0];},0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_9683, Returns first item.\n\n @return AcceptHeaderItem|null\n,Vraća prvu stavku,    public function first()    {        $this->sort();        return !empty($this->items) ? reset($this->items) : null;    },0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3491," Quartiles - Inclusive method (R method)\n Three points that divide the data set into four equal groups, each group comprising a quarter of the data.\n https://en.wikipedia.org/wiki/Quartile\n\n 0% is smallest number\n Q1 (25%) is first quartile (lower quartile, 25th percentile)\n Q2 (50%) is second quartile (median, 50th percentile)\n Q3 (75%) is third quartile (upper quartile, 75th percentile)\n 100% is largest number\n interquartile_range is the difference between the upper and lower quartiles. (IQR = Qâ‚ƒ - Qâ‚)\n\n Method used\n  - Use the median to divide the ordered data set into two halves.\n   - If there are an odd number of data points in the original ordered data set,\n     include the median (the central value in the ordered list) in both halves.\n   - If there are an even number of data points in the original ordered data set,\n     split this data set exactly in half.\n  - The lower quartile value is the median of the lower half of the data.\n    The upper quartile value is the median of the upper half of the data.\n\n The values found by this method are also known as ""Tukey\'s hinges"".\n This is the method that the programming language R uses by default.\n\n @param float[] $numbers\n\n @return array (0%, Q1, Q2, Q3, 100%, IQR)\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n","Kvartili - Inkluzivna metoda (R metoda).Tri tačke koje skup podataka dele na četiri jednake grupe, a svaka grupa čini četvrtinu podataka https://en.vikipedia.org/viki/Kuartile\n\n 0% je najmanji broj K1 (25%) je prvi kvartil (donji kvartil, 25. percentil), K2 (50%) je drugi kvartil (medijana, 50. percentil), K3 (75%) je treći kvartil (gornji) kvartil, 75. percentil) , 100% je najveći broj. Interquartile_range je razlika između gornjeg i donjeg kvartila. (IKR = Ka‚ƒ - Ka ‚). Korišćena metoda - Koristiti medijanu da podeli poređani skup podataka na dve polovine. Ako u originalnim uređenim podacima postoji neparan broj tačaka podataka skupa, uključite medijanu (centralnu vrednost na uređenoj listi) u obe polovine. Ako u originalnom uređenom skupu podataka postoji paran broj tačaka podataka, podelite ovaj skup podataka tačno na pola. Vrednost donjeg kvartila je medijana donje polovine podataka.Vrednost gornjeg kvartila je srednja vrednost gornje polovine podataka. Vrednosti pronađene ovom metodom poznate su i kao „Tukey\'s hinges"". Ovo je metoda koju programski jezik R podrazumevano koristi","    public static function quartilesInclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);            // Add median to both halves            $median = Average::median($numbers);            \array_push($lower_half, $median);            \array_unshift($upper_half, $median);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }",0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_EigenTransformerBase_898, Calculates eigenValues and eigenVectors of the given matrix. Returns\n top eigenVectors along with the largest eigenValues. The total explained variance\n of these eigenVectors will be no less than desired $totalVariance value\n,Izračunava eigenValues i eigenVectors date matrice. Vraća top eigenVectors zajedno sa najvećim eigenValues. Ukupna objašnjena varijansa ovih eigenVectors neće biti manja od željene $totalVariance vrednosti,    protected function eigenDecomposition(array $matrix): void    {        $eig = new EigenvalueDecomposition($matrix);        $eigVals = $eig->getRealEigenvalues();        $eigVects = $eig->getEigenvectors();        $totalEigVal = array_sum($eigVals);        // Sort eigenvalues in descending order        arsort($eigVals);        $explainedVar = 0.0;        $vectors = [];        $values = [];        foreach ($eigVals as $i => $eigVal) {            $explainedVar += $eigVal / $totalEigVal;            $vectors[] = $eigVects[$i];            $values[] = $eigVal;            if ($this->numFeatures !== null) {                if (count($vectors) == $this->numFeatures) {                    break;                }            } else {                if ($explainedVar >= $this->totalVariance) {                    break;                }            }        }        $this->eigValues = $values;        $this->eigVectors = $vectors;    },0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SimpsonsRule_3028," Use Simpson's Rule to approximate the definite integral of a\n function f(x). Our input can support either a set of arrays, or a callback\n function with arguments (to produce a set of arrays). Each array in our\n input contains two numbers which correspond to coordinates (x, y) or\n equivalently, (x, f(x)), of the function f(x) whose definite integral we\n are approximating.\n\n Note: Simpson's method requires that we have an even number of\n subintervals (we must supply an odd number of points) and also that the\n size of each subinterval is equal (spacing between each point is equal).\n\n The bounds of the definite integral to which we are approximating is\n determined by the our inputs.\n\n Example: approximate([0, 10], [5, 5], [10, 7]) will approximate the definite\n integral of the function that produces these coordinates with a lower\n bound of 0, and an upper bound of 10.\n\n Example: approximate(function($x) {return $x a set of arrays by evaluating the callback at 5 evenly spaced points\n between 0 and 4. Then, this array will be used in our approximation.\n\n Simpson's Rule:\n\n xn        â¿â»Â¹ xáµ¢â‚Šâ‚\n âˆ« f(x)dx = âˆ‘   âˆ« f(x)dx\n xâ‚        â±â¼Â¹  xáµ¢\n\n         â½â¿â»Â¹â¾/Â² h\n          = âˆ‘    - [fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯ + 4fâŸ®xâ‚‚áµ¢âŸ¯ + fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯] + O(hâµfâ—(x))\n           â±â¼Â¹   3\n where h = (xn - xâ‚) / (n - 1)\n\n @param callable|array $source  The source of our approximation. Should be either\n                                a callback function or a set of arrays. Each array\n                                (point) contains precisely two numbers, an x and y.\n                                Example array: [[1,2], [2,3], [3,4]].\n                                Example callback: function($x) {return $x @param number         ...$args The arguments of our callback function: start,\n                                end, and n. Example: approximate($source, 0, 8, 5).\n                                If $source is a set of points, do not input any\n                                $args. Example: approximate($source).\n\n @return float                  The approximation to the integral of f(x)\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n","Koristite Simpsonovo pravilo za približavanje konačnog integrala funkcije f(x). Naš ulaz može podržati ili skup nizova, ili funkciju povratnog poziva sa argumentima (da bi se dobio niz nizova). Svaki niz u našem ulazu sadrži dva broja koji odgovaraju koordinatama (x, i) ili ekvivalentno, (x, f (x)), funkcije f(x) čiji konačni integral aproksimiramo. Napomena: Simpsonova metoda zahteva da imamo paran broj podintervala (moramo dostaviti neparan broj tačaka) i da je veličina svakog podintervala jednaka (razmak između svake tačke je jednak). Granice definitivnog integrala kojem se približavamo određuju naši unosi. Primer: approximate([0, 10], [5, 5], [10, 7]) će približite konačni integral funkcije koja daje ove koordinate sa donjom granicom 0, a gornjom granicom 10. Primer: approximate(funkcija ($x) {vrati $x skup nizova procenjujući povratni poziv u 5 ravnomerno raspoređenih tačaka između 0 i 4. Zatim će se ovaj niz koristiti u našoj aproksimaciji","    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 3);        Validation::isSubintervalsMultiple($points, $m = 2);        $sorted = self::sort($points);        Validation::isSpacingConstant($sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $subintervals  = $n - 1;        $a             = $sorted[0][$x];        $b             = $sorted[$n - 1][$x];        $h             = ($b - $a) / $subintervals;        $approximation = 0;        /*         * Summation         * â½â¿â»Â¹â¾/Â² h         *    âˆ‘    - [fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯ + 4fâŸ®xâ‚‚áµ¢âŸ¯ + fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯] + O(hâµfâ—(x))         *   â±â¼Â¹   3         *  where h = (xn - xâ‚) / (n - 1)         */        for ($i = 1; $i < ($subintervals / 2) + 1; $i++) {            $xâ‚‚áµ¢â‚‹â‚          = $sorted[(2 * $i) - 2][$x];            $xâ‚‚áµ¢            = $sorted[(2 * $i) - 1][$x];            $xâ‚‚áµ¢â‚Šâ‚          = $sorted[(2 * $i)][$x];            $fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯        = $sorted[(2 * $i) - 2][$y];  // yâ‚‚áµ¢â‚‹â‚            $fâŸ®xâ‚‚áµ¢âŸ¯          = $sorted[(2 * $i) - 1][$y];  // yâ‚‚áµ¢            $fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯        = $sorted[(2 * $i)][$y];    // yâ‚‚áµ¢â‚Šâ‚            $lagrange       = LagrangePolynomial::interpolate([[$xâ‚‚áµ¢â‚‹â‚, $fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯], [$xâ‚‚áµ¢, $fâŸ®xâ‚‚áµ¢âŸ¯], [$xâ‚‚áµ¢â‚Šâ‚, $fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xâ‚‚áµ¢â‚Šâ‚) - $integral($xâ‚‚áµ¢â‚‹â‚); // definite integral of lagrange polynomial        }        return $approximation;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_TrapezoidalRule_3032," Use the Trapezoidal Rule to approximate the definite integral of a\\n function f(x). Our input can support either a set of arrays, or a callback\\n function with arguments (to produce a set of arrays). Each array in our\\n input contains two numbers which correspond to coordinates (x, y) or\\n equivalently, (x, f(x)), of the function f(x) whose definite integral we\\n are approximating.\\n\\n The bounds of the definite integral to which we are approximating is\\n determined by the our inputs.\\n\\n Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite\\n integral of the function that produces these coordinates with a lower\\n bound of 0, and an upper bound of 10.\\n\\n Example: approximate(function($x) {return $x a set of arrays by evaluating the callback at 5 evenly spaced points\\n between 0 and 4. Then, this array will be used in our approximation.\\n\\n Trapezoidal Rule:\\n\\n xn        â¿â»Â¹ xáµ¢â‚Šâ‚\\n âˆ« f(x)dx = âˆ‘   âˆ« f(x)dx\\n xâ‚        â±â¼Â¹  xáµ¢\\n\\n           â¿â»Â¹  h\\n          = âˆ‘   - [f(xáµ¢â‚Šâ‚) + f(xáµ¢)] + O(hÂ³fâ€³(x))\\n           â±â¼Â¹  2\\n\\n  where h = xáµ¢â‚Šâ‚ - xáµ¢\\n  note: this implementation does not compute the error term.\\n @param callable|array $source The source of our approximation. Should be either\\n                               a callback function or a set of arrays. Each array\\n                               (point) contains precisely two numbers, an x and y.\\n                               Example array: [[1,2], [2,3], [3,4]].\\n                               Example callback: function($x) {return $x @param number        ...$args The arguments of our callback function: start,\\n                               end, and n. Example: approximate($source, 0, 8, 5).\\n                               If $source is a set of points, do not input any\\n                               $args. Example: approximate($source).\\n\\n @return float                The approximation to the integral of f(x)\\n\\n @throws Exception\\\\BadDataException\\n @throws \\\\MathPHP\\\\Exception\\\\IncorrectTypeException\\n","Koristite trapezoidno pravilo za približavanje konačnog integrala funkcije f(x). Naš ulaz može podržati ili skup nizova, ili funkciju povratnog poziva sa argumentima (za stvaranje niza nizova). Svaki niz u našem ulazu sadrži dva broja koji odgovaraju koordinatama (x, i) ili ekvivalentno, (x, f(x)), funkcije f(x) čiji konačni integral aproksimiramo. Granice konačnog integrala kojem se približavamo određene su našim ulazima. Primer: approximate([0, 10], [3, 5] , [10, 7]) približiće konačni integral funkcije koja proizvodi ove koordinate sa donjom granicom 0, a gornjom granicom 10. Primer: approximate(funkcija ($x) {vrati $x skup nizova procenom povratnog poziva u 5 ravnomerno raspoređenih tačaka između 0 i 4. Tada će se ovaj niz koristiti u našoj aproksimaciji","    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         * â¿â»Â¹  h         *  âˆ‘   - [f(xáµ¢â‚Šâ‚) + f(xáµ¢)]         * â±â¼Â¹  2         *  where h = xáµ¢â‚Šâ‚ - xáµ¢         */        for ($i = 0; $i < $steps; $i++) {            $xáµ¢             = $sorted[$i][$x];            $xáµ¢â‚Šâ‚           = $sorted[$i + 1][$x];            $fâŸ®xáµ¢âŸ¯           = $sorted[$i][$y];    // yáµ¢            $fâŸ®xáµ¢â‚Šâ‚âŸ¯         = $sorted[$i + 1][$y];  // yáµ¢â‚Šâ‚            $lagrange       = LagrangePolynomial::interpolate([[$xáµ¢, $fâŸ®xáµ¢âŸ¯], [$xáµ¢â‚Šâ‚, $fâŸ®xáµ¢â‚Šâ‚âŸ¯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xáµ¢â‚Šâ‚) - $integral($xáµ¢); // definite integral of lagrange polynomial        }        return $approximation;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_ReleaseController_980, Ensure sorting of the changelog lines.\\n @param string[] $changelog\\n @return string[]\\n,Obezbedite sortiranje redova dnevnika promena,"abstract class TestCase extends \PHPUnit\Framework\TestCase{    public static $params;    /**     * Clean up after test case.     */    public static function tearDownAfterClass()    {        parent::tearDownAfterClass();        $logger = Yii::getLogger();        $logger->flush();    }    /**     * Returns a test configuration param from /data/config.php.     * @param string $name params name     * @param mixed $default default value to use when param is not set.     * @return mixed  the value of the configuration param     */    public static function getParam($name, $default = null)    {        if (static::$params === null) {            static::$params = require __DIR__ . '/data/config.php';        }        return isset(static::$params[$name]) ? static::$params[$name] : $default;    }    /**     * Clean up after test.     * By default the application created with [[mockApplication]] will be destroyed.     */    protected function tearDown()    {        parent::tearDown();        $this->destroyApplication();    }    /**     * Populates Yii::$app with a new application     * The application will be destroyed on tearDown() automatically.     * @param array $config The application configuration, if needed     * @param string $appClass name of the application class to create     */    protected function mockApplication($config = [], $appClass = '\yii\console\Application')    {        new $appClass(ArrayHelper::merge([            'id' => 'testapp',            'basePath' => __DIR__,            'vendorPath' => $this->getVendorPath(),        ], $config));    }    protected function mockWebApplication($config = [], $appClass = '\yii\web\Application')    {        new $appClass(ArrayHelper::merge([            'id' => 'testapp',            'basePath' => __DIR__,            'vendorPath' => $this->getVendorPath(),            'aliases' => [                '@bower' => '@vendor/bower-asset',                '@npm' => '@vendor/npm-asset',            ],            'components' => [                'request' => [                    'cookieValidationKey' => 'wefJDF8sfdsfSDefwqdxj9oq',                    'scriptFile' => __DIR__ . '/index.php',                    'scriptUrl' => '/index.php',                ],            ],        ], $config));    }    protected function getVendorPath()    {        $vendor = dirname(dirname(__DIR__)) . '/vendor';        if (!is_dir($vendor)) {            $vendor = dirname(dirname(dirname(dirname(__DIR__))));        }        return $vendor;    }    /**     * Destroys application in Yii::$app by setting it to null.     */    protected function destroyApplication()    {        if (\Yii::$app && \Yii::$app->has('session', true)) {            \Yii::$app->session->close();        }        \Yii::$app = null;    }    /**     * Asserting two strings equality ignoring line endings.     * @param string $expected     * @param string $actual     * @param string $message     */    protected function assertEqualsWithoutLE($expected, $actual, $message = '')    {        $expected = str_replace(""\r\n"", ""\n"", $expected);        $actual = str_replace(""\r\n"", ""\n"", $actual);        $this->assertEquals($expected, $actual, $message);    }    /**     * Asserts that a haystack contains a needle ignoring line endings.     *     * @param mixed $needle     * @param mixed $haystack     * @param string $message     */    protected function assertContainsWithoutLE($needle, $haystack, $message = '')    {        $needle = str_replace(""\r\n"", ""\n"", $needle);        $haystack = str_replace(""\r\n"", ""\n"", $haystack);        $this->assertContains($needle, $haystack, $message);    }    /**     * Invokes a inaccessible method.     * @param $object     * @param $method     * @param array $args     * @param bool $revoke whether to make method inaccessible after execution     * @return mixed     * @since 2.0.11     */    protected function invokeMethod($object, $method, $args = [], $revoke = true)    {        $reflection = new \ReflectionObject($object);        $method = $reflection->getMethod($method);        $method->setAccessible(true);        $result = $method->invokeArgs($object, $args);        if ($revoke) {            $method->setAccessible(false);        }        return $result;    }    /**     * Sets an inaccessible object property to a designated value.     * @param $object     * @param $propertyName     * @param $value     * @param bool $revoke whether to make property inaccessible after setting     * @since 2.0.11     */    protected function setInaccessibleProperty($object, $propertyName, $value, $revoke = true)    {        $class = new \ReflectionClass($object);        while (!$class->hasProperty($propertyName)) {            $class = $class->getParentClass();        }        $property = $class->getProperty($propertyName);        $property->setAccessible(true);        $property->setValue($object, $value);        if ($revoke) {            $property->setAccessible(false);        }    }    /**     * Gets an inaccessible object property.     * @param $object     * @param $propertyName     * @param bool $revoke whether to make property inaccessible after getting     * @return mixed     */    protected function getInaccessibleProperty($object, $propertyName, $revoke = true)    {        $class = new \ReflectionClass($object);        while (!$class->hasProperty($propertyName)) {            $class = $class->getParentClass();        }        $property = $class->getProperty($propertyName);        $property->setAccessible(true);        $result = $property->getValue($object);        if ($revoke) {            $property->setAccessible(false);        }        return $result;    }    /**     * Asserts that value is one of expected values.     *     * @param mixed $actual     * @param array $expected     * @param string $message     */    public function assertIsOneOf($actual, array $expected, $message = '')    {        self::assertThat($actual, new IsOneOfAssert($expected), $message);    }    /**     * Changes db component config     * @param $db     */    protected function switchDbConnection($db)    {        $databases = $this->getParam('databases');        if (isset($databases[$db])) {            $database = $databases[$db];            Yii::$app->db->close();            Yii::$app->db->dsn = isset($database['dsn']) ? $database['dsn'] : null;            Yii::$app->db->username = isset($database['username']) ? $database['username'] : null;            Yii::$app->db->password = isset($database['password']) ? $database['password'] : null;        }    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3436, Statistical averages\n,Statistički proseci,"class Average{    /**************************************************************************     * Averages of a list of numbers     **************************************************************************/    /**     * Calculate the mean average of a list of numbers     *     *     âˆ‘âŸ®xáµ¢âŸ¯     * xÌ„ = -----     *       n     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function mean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the average of an empty list of numbers');        }        return \array_sum($numbers) / \count($numbers);    }    /**     * Calculate the weighted mean average of a list of numbers     * https://en.wikipedia.org/wiki/Weighted_arithmetic_mean     *     *     âˆ‘âŸ®xáµ¢wáµ¢âŸ¯     * xÌ„ = -----     *      âˆ‘âŸ®wáµ¢âŸ¯     *     * @param float[] $numbers     * @param float[] $weights     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\BadDataException if the number of numbers and weights are not equal     */    public static function weightedMean(array $numbers, array $weights): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the weightedMean of an empty list of numbers');        }        if (empty($weights)) {            return Average::mean($numbers);        }        if (\count($numbers) !== \count($weights)) {            throw new Exception\BadDataException('Numbers and weights must have the same number of elements.');        }        $âˆ‘âŸ®xáµ¢wáµ¢âŸ¯ = \array_sum(\array_map(            function ($xáµ¢, $wáµ¢) {                return $xáµ¢ * $wáµ¢;            },            $numbers,            $weights        ));        $âˆ‘âŸ®wáµ¢âŸ¯ = \array_sum($weights);        return $âˆ‘âŸ®xáµ¢wáµ¢âŸ¯ / $âˆ‘âŸ®wáµ¢âŸ¯;    }    /**     * Calculate the median average of a list of numbers     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if kth-smallest k is out of bounds     */    public static function median(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median of an empty list of numbers');        }        if (\count($numbers) === 1) {            return \array_pop($numbers);        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // For odd number of numbers, take the middle indexed number        if (\count($numbers) % 2 == 1) {            $middle_index = \intdiv(\count($numbers), 2);            return self::kthSmallest($numbers, $middle_index);        }        // For even number of items, take the mean of the middle two indexed numbers        $left_middle_index  = \intdiv(\count($numbers), 2) - 1;        $left_median        = self::kthSmallest($numbers, $left_middle_index);        $right_middle_index = $left_middle_index + 1;        $right_median       = self::kthSmallest($numbers, $right_middle_index);        return self::mean([ $left_median, $right_median ]);    }    /**     * Return the kth smallest value in an array     * Uses a linear-time algorithm: O(n) time in worst case.     *     * if $a = [1,2,3,4,6,7]     *     * kthSmallest($a, 4) = 6     *     * Algorithm:     *  1) If n is small, just sort and return     *  2) Otherwise, group into 5-element subsets and mind the median     *  3) Find the median of the medians     *  4) Find L and U sets     *     - L is numbers lower than the median of medians     *     - U is numbers higher than the median of medians     *  5) Recursive step     *     - if k is the median of medians, return that     *     - Otherwise, recursively search in smaller group.     *     * @param float[] $numbers     * @param int    $k zero indexed - must be less than n (count of $numbers)     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if k â‰¥ n     */    public static function kthSmallest(array $numbers, int $k): float    {        $n = \count($numbers);        if ($n === 0) {            throw new Exception\BadDataException('Cannot find the k-th smallest of an empty list of numbers');        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException('k cannot be greater than or equal to the count of numbers');        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // If the array is 5 elements or smaller, use quicksort and return the element of interest.        if ($n <= 5) {            \sort($numbers);            return $numbers[$k];        }        // Otherwise, we are going to slice $numbers into 5-element slices and find the median of each.        $num_slices = \ceil($n / 5);        $median_array = [];        for ($i = 0; $i < $num_slices; $i++) {            $median_array[] = self::median(\array_slice($numbers, 5 * $i, 5));        }        // Then we find the median of the medians.        $median_of_medians = self::median($median_array);        // Next we walk the array and separate it into values that are greater than or less than this ""median of medians"".        $lower_upper   = self::splitAtValue($numbers, $median_of_medians);        $lower_number = \count($lower_upper['lower']);        $equal_number = $lower_upper['equal'];        // Lastly, we find which group of values our value of interest is in, and find it in the smaller array.        if ($k < $lower_number) {            return self::kthSmallest($lower_upper['lower'], $k);        } elseif ($k < ($lower_number + $equal_number)) {            return $median_of_medians;        } else {            return self::kthSmallest($lower_upper['upper'], $k - $lower_number - $equal_number);        }    }    /**     * Given an array and a value, separate the array into two groups,     * those values which are greater than the value, and those that are less     * than the value. Also, tell how many times the value appears in the array.     *     * @param float[] $numbers     * @param float   $value     *     * @return array     */    private static function splitAtValue(array $numbers, float $value): array    {        $lower        = [];        $upper        = [];        $number_equal = 0;        foreach ($numbers as $number) {            if ($number < $value) {                $lower[] = $number;            } elseif ($number > $value) {                $upper[] = $number;            } else {                $number_equal++;            }        }        return [            'lower' => $lower,            'upper' => $upper,            'equal' => $number_equal,        ];    }    /**     * Calculate the mode average of a list of numbers     * If multiple modes (bimodal, trimodal, etc.), all modes will be returned.     * Always returns an array, even if only one mode.     *     * @param float[] $numbers     *     * @return float[] of mode(s)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function mode(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the mode of an empty list of numbers');        }        // Count how many times each number occurs.        // Determine the max any number occurs.        // Find all numbers that occur max times.        $number_strings = \array_map('\strval', $numbers);        $number_counts  = \array_count_values($number_strings);        $max            = \max($number_counts);        $modes          = array();        foreach ($number_counts as $number => $count) {            if ($count === $max) {                $modes[] = $number;            }        }        // Cast back to numbers        return \array_map('\floatval', $modes);    }    /**     * Geometric mean     * A type of mean which indicates the central tendency or typical value of a set of numbers     * by using the product of their values (as opposed to the arithmetic mean which uses their sum).     * https://en.wikipedia.org/wiki/Geometric_mean     *                    __________     * Geometric mean = â¿âˆšaâ‚€aâ‚aâ‚‚ â‹¯     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function geometricMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the geometric mean of an empty list of numbers');        }        $n       = \count($numbers);        $aâ‚€aâ‚aâ‚‚â‹¯ = \array_reduce(            $numbers,            function ($carry, $a) {                return $carry * $a;            },            1        );        $â¿âˆšaâ‚€aâ‚aâ‚‚â‹¯ = \pow($aâ‚€aâ‚aâ‚‚â‹¯, 1 / $n);        return $â¿âˆšaâ‚€aâ‚aâ‚‚â‹¯;    }    /**     * Harmonic mean (subcontrary mean)     * The harmonic mean can be expressed as the reciprocal of the arithmetic mean of the reciprocals.     * Appropriate for situations when the average of rates is desired.     * https://en.wikipedia.org/wiki/Harmonic_mean     *     *     *        n     * H = ------     *      n  1     *      âˆ‘  -     *     â±â¼Â¹ xáµ¢     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\BadDataException if there are negative numbers     */    public static function harmonicMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the harmonic mean of an empty list of numbers');        }        $negativeValues = \array_filter(            $numbers,            function ($x) {                return $x < 0;            }        );        if (!empty($negativeValues)) {            throw new Exception\BadDataException('Harmonic mean cannot be computed for negative values.');        }        $n      = \count($numbers);        $âˆ‘1ï¼xáµ¢ = \array_sum(Map\Single::reciprocal($numbers));        return $n / $âˆ‘1ï¼xáµ¢;    }    /**     * Contraharmonic mean     * A function complementary to the harmonic mean.     * A special case of the Lehmer mean, Lâ‚‚(x), where p = 2.     * https://en.wikipedia.org/wiki/Contraharmonic_mean     *     * @param  float[] $numbers     *     * @return float     */    public static function contraharmonicMean(array $numbers): float    {        $p = 2;        return self::lehmerMean($numbers, $p);    }    /**     * Root mean square (quadratic mean)     * The square root of the arithmetic mean of the squares of a set of numbers.     * https://en.wikipedia.org/wiki/Root_mean_square     *           ___________     *          /xâ‚+Â²xâ‚‚Â²+ â‹¯     * x rms = / -----------     *        âˆš       n     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function rootMeanSquare(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the root mean square of an empty list of numbers');        }        $n = \count($numbers);        $xâ‚Â²ï¼‹xâ‚‚Â²ï¼‹â‹¯ = \array_sum(\array_map(            function ($x) {                return $x ** 2;            },            $numbers        ));        return \sqrt($xâ‚Â²ï¼‹xâ‚‚Â²ï¼‹â‹¯ / $n);    }    /**     * Quadradic mean (root mean square)     * Convenience function for rootMeanSquare     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quadraticMean(array $numbers): float    {        return self::rootMeanSquare($numbers);    }    /**     * Trimean (TM, or Tukey's trimean)     * A measure of a probability distribution's location defined as     * a weighted average of the distribution's median and its two quartiles.     * https://en.wikipedia.org/wiki/Trimean     *     *      Qâ‚ + 2Qâ‚‚ + Qâ‚ƒ     * TM = -------------     *            4     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function trimean(array $numbers): float    {        $quartiles = Descriptive::quartiles($numbers);        $Qâ‚        = $quartiles['Q1'];        $Qâ‚‚        = $quartiles['Q2'];        $Qâ‚ƒ        = $quartiles['Q3'];        return ($Qâ‚ + 2 * $Qâ‚‚ + $Qâ‚ƒ) / 4;    }    /**     * Interquartile mean (IQM)     * A measure of central tendency based on the truncated mean of the interquartile range.     * Only the data in the second and third quartiles is used (as in the interquartile range),     * and the lowest 25% and the highest 25% of the scores are discarded.     * https://en.wikipedia.org/wiki/Interquartile_mean     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\OutOfBoundsException     */    public static function interquartileMean(array $numbers): float    {        return self::truncatedMean($numbers, 25);    }    /**     * IQM (Interquartile mean)     * Convenience function for interquartileMean     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\OutOfBoundsException     */    public static function iqm(array $numbers): float    {        return self::truncatedMean($numbers, 25);    }    /**     * Cubic mean     * https://en.wikipedia.org/wiki/Cubic_mean     *              _________     *             / 1  n     * x cubic = Â³/  -  âˆ‘ xáµ¢Â³     *           âˆš   n â±â¼Â¹     *     * @param array $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function cubicMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the cubic mean of an empty list of numbers');        }        $n    = \count($numbers);        $âˆ‘xáµ¢Â³ = \array_sum(Map\Single::cube($numbers));        return \pow($âˆ‘xáµ¢Â³ / $n, 1 / 3);    }    /**     * Truncated mean (trimmed mean)     * The mean after discarding given parts of a probability distribution or sample     * at the high and low end, and typically discarding an equal amount of both.     * This number of points to be discarded is given as a percentage of the total number of points.     * https://en.wikipedia.org/wiki/Truncated_mean     *     * Trim count = floor( (trim percent / 100) * sample size )     *     * For example: [8, 3, 7, 1, 3, 9] with a trim of 20%     * First sort the list: [1, 3, 3, 7, 8, 9]     * Sample size = 6     * Then determine trim count: floot(20/100 * 6 ) = 1     * Trim the list by removing 1 from each end: [3, 3, 7, 8]     * Finally, find the mean: 5.2     *     * @param float[] $numbers     * @param int     $trim_percent Percent between 0-99     *     * @return float     *     * @throws Exception\OutOfBoundsException if trim percent is not between 0 and 99     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function truncatedMean(array $numbers, int $trim_percent): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the truncated mean of an empty list of numbers');        }        if ($trim_percent < 0 || $trim_percent > 99) {            throw new Exception\OutOfBoundsException('Trim percent must be between 0 and 99.');        }        $n          = \count($numbers);        $trim_count = \floor($n * ($trim_percent / 100));        \sort($numbers);        for ($i = 1; $i <= $trim_count; $i++) {            \array_shift($numbers);            \array_pop($numbers);        }        return self::mean($numbers);    }    /**     * Lehmer mean     * https://en.wikipedia.org/wiki/Lehmer_mean     *     *          âˆ‘xáµ¢áµ–     * Lp(x) = ------     *         âˆ‘xáµ¢áµ–â»Â¹     *     * Special cases:     *  L-âˆž(x) is the min(x)     *  Lâ‚€(x) is the harmonic mean     *  LÂ½(xâ‚€, xâ‚) is the geometric mean if computed against two numbers     *  Lâ‚(x) is the arithmetic mean     *  Lâ‚‚(x) is the contraharmonic mean     *  Lâˆž(x) is the max(x)     *     * @param  float[] $numbers     * @param  float   $p     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function lehmerMean(array $numbers, $p): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the lehmer mean of an empty list of numbers');        }        // Special cases for infinite p        if ($p == -\INF) {            return \min($numbers);        }        if ($p == \INF) {            return \max($numbers);        }        // Standard case for non-infinite p        $âˆ‘xáµ¢áµ–   = \array_sum(Map\Single::pow($numbers, $p));        $âˆ‘xáµ¢áµ–â»Â¹ = \array_sum(Map\Single::pow($numbers, $p - 1));        return $âˆ‘xáµ¢áµ– / $âˆ‘xáµ¢áµ–â»Â¹;    }    /**     * Generalized mean (power mean, HÃ¶lder mean)     * https://en.wikipedia.org/wiki/Generalized_mean     *     *          / 1  n    \ 1/p     * Mp(x) = |  -  âˆ‘ xáµ¢áµ–|     *          \ n â±â¼Â¹   /     *     * Special cases:     *  M-âˆž(x) is \min(x)     *  Mâ‚‹â‚(x) is the harmonic mean     *  Mâ‚€(x) is the geometric mean     *  Mâ‚(x) is the arithmetic mean     *  Mâ‚‚(x) is the quadratic mean     *  Mâ‚ƒ(x) is the cubic mean     *  Mâˆž(x) is max(X)     *     * @param  float[] $numbers     * @param  float   $p     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function generalizedMean(array $numbers, float $p): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the generalized mean of an empty list of numbers');        }        // Special cases for infinite p        if ($p == -\INF) {            return \min($numbers);        }        if ($p == \INF) {            return \max($numbers);        }        // Special case for p = 0 (geometric mean)        if ($p == 0) {            return self::geometricMean($numbers);        }        // Standard case for non-infinite p        $n    = \count($numbers);        $âˆ‘xáµ¢áµ– = \array_sum(Map\Single::pow($numbers, $p));        return \pow($âˆ‘xáµ¢áµ– / $n, 1 / $p);    }    /**     * Power mean (generalized mean)     * Convenience method for generalizedMean     *     * @param  float[] $numbers     * @param  float $p     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function powerMean(array $numbers, float $p): float    {        return self::generalizedMean($numbers, $p);    }    /**************************************************************************     * Moving averages (list of numbers)     **************************************************************************/    /**     * Simple n-point moving average SMA     * The unweighted mean of the previous n data.     *     * First calculate initial average:     *  â¿â»Â¹     *   âˆ‘ xáµ¢     *  áµ¢â‚Œâ‚€     *     * To calculating successive values, a new value comes into the sum and an old value drops out:     *  SMAtoday = SMAyesterday + NewNumber/N - DropNumber/N     *     * @param  float[] $numbers     * @param  int     $n       n-point moving average     *     * @return float[] of averages for each n-point time period     */    public static function simpleMovingAverage(array $numbers, int $n): array    {        $m   = \count($numbers);        $SMA = [];        // Counters        $new       = $n; // New value comes into the sum        $drop      = 0;  // Old value drops out        $yesterday = 0;  // Yesterday's SMA        // Base case: initial average        $SMA[] = \array_sum(\array_slice($numbers, 0, $n)) / $n;        // Calculating successive values: New value comes in; old value drops out        while ($new < $m) {            $SMA[] = $SMA[$yesterday] + ($numbers[$new] / $n) - ($numbers[$drop] / $n);            $drop++;            $yesterday++;            $new++;        }        return $SMA;    }    /**     * Cumulative moving average (CMA)     *     * Base case for initial average:     *         xâ‚€     *  CMAâ‚€ = --     *         1     *     * Standard case:     *         xáµ¢ + (i * CMAáµ¢â‚‹â‚)     *  CMAáµ¢ = -----------------     *              i + 1     *     * @param  float[] $numbers     *     * @return float[] of cumulative averages     */    public static function cumulativeMovingAverage(array $numbers): array    {        $m   = \count($numbers);        $CMA = [];        // Base case: first average is just itself        $CMA[] = $numbers[0];        for ($i = 1; $i < $m; $i++) {            $CMA[] = (($numbers[$i]) + ($CMA[$i - 1] * $i)) / ($i + 1);        }        return $CMA;    }    /**     * Weighted n-point moving average (WMA)     *     * Similar to simple n-point moving average,     * however, each n-point has a weight associated with it,     * and instead of dividing by n, we divide by the sum of the weights.     *     * Each weighted average = âˆ‘(weighted values) / âˆ‘(weights)     *     * @param  array  $numbers     * @param  int    $n       n-point moving average     * @param  array  $weights Weights for each n points     *     * @return array of averages     *     * @throws Exception\BadDataException if number of weights is not equal to number of n-points     */    public static function weightedMovingAverage(array $numbers, int $n, array $weights): array    {        if (\count($weights) !== $n) {            throw new Exception\BadDataException('Number of weights must equal number of n-points');        }        $m   = \count($numbers);        $âˆ‘w  = \array_sum($weights);        $WMA = [];        for ($i = 0; $i <= $m - $n; $i++) {            $âˆ‘wp   = \array_sum(Map\Multi::multiply(\array_slice($numbers, $i, $n), $weights));            $WMA[] = $âˆ‘wp / $âˆ‘w;        }        return $WMA;    }    /**     * Exponential moving average (EMA)     *     * The start of the EPA is seeded with the first data point.     * Then each day after that:     *  EMAtoday = Î±â‹…xtoday + (1-Î±)EMAyesterday     *     *   where     *    Î±: coefficient that represents the degree of weighting decrease, a constant smoothing factor between 0 and 1.     *     * @param array  $numbers     * @param int    $n       Length of the EPA     *     * @return array of exponential moving averages     */    public static function exponentialMovingAverage(array $numbers, int $n): array    {        $m   = \count($numbers);        $Î±   = 2 / ($n + 1);        $EMA = [];        // Start off by seeding with the first data point        $EMA[] = $numbers[0];        // Each day after: EMAtoday = Î±â‹…xtoday + (1-Î±)EMAyesterday        for ($i = 1; $i < $m; $i++) {            $EMA[] = ($Î± * $numbers[$i]) + ((1 - $Î±) * $EMA[$i - 1]);        }        return $EMA;    }    /**************************************************************************     * Averages of two numbers     **************************************************************************/    /**     * Arithmetic-Geometric mean     *     * First, compute the arithmetic and geometric means of x and y, calling them aâ‚ and gâ‚ respectively.     * Then, use iteration, with aâ‚ taking the place of x and gâ‚ taking the place of y.     * Both a and g will converge to the same mean.     * https://en.wikipedia.org/wiki/Arithmetic%E2%80%93geometric_mean     *     * x and y â‰¥ 0     * If x or y = 0, then agm = 0     * If x or y < 0, then NaN     *     * @param  float $x     * @param  float $y     *     * @return float     */    public static function arithmeticGeometricMean(float $x, float $y): float    {        // x or y < 0 = NaN        if ($x < 0 || $y < 0) {            return \NAN;        }        // x or y zero = 0        if ($x == 0 || $y == 0) {            return 0;        }        // Standard case x and y > 0        [$a, $g] = [$x, $y];        for ($i = 0; $i <= 10; $i++) {            [$a, $g] = [self::mean([$a, $g]), self::geometricMean([$a, $g])];        }        return $a;    }    /**     * Convenience method for arithmeticGeometricMean     *     * @param  float $x     * @param  float $y     *     * @return float     */    public static function agm(float $x, float $y): float    {        return self::arithmeticGeometricMean($x, $y);    }    /**     * Logarithmic mean     * A function of two non-negative numbers which is equal to their     * difference divided by the logarithm of their quotient.     *     * https://en.wikipedia.org/wiki/Logarithmic_mean     *     *  Mlm(x, y) = 0 if x = 0 or y = 0     *              x if x = y     *  otherwise:     *                y - x     *             -----------     *             ln y - ln x     *     * @param  float $x     * @param  float $y     *     * @return float     */    public static function logarithmicMean(float $x, float $y): float    {        if ($x == 0 || $y == 0) {            return 0;        }        if ($x == $y) {            return $x;        }        return ($y - $x) / (\log($y) - \log($x));    }    /**     * Heronian mean     * https://en.wikipedia.org/wiki/Heronian_mean     *            __     * H = â…“(A + âˆšAB + B)     *     * @param  float $A     * @param  float $B     *     * @return float     */    public static function heronianMean(float $A, float $B): float    {        return 1 / 3 * ($A + \sqrt($A * $B) + $B);    }    /**     * Identric mean     * https://en.wikipedia.org/wiki/Identric_mean     *                 ____     *          1     / xË£     * I(x,y) = - Ë£â»Ê¸/  --     *          â„¯   âˆš   yÊ¸     *     * @param  float $x     * @param  float $y     *     * @return float     *     * @throws Exception\OutOfBoundsException if x or y is â‰¤ 0     */    public static function identricMean(float $x, float $y): float    {        // x and y must be positive        if ($x <= 0 || $y <= 0) {            throw new Exception\OutOfBoundsException('x and y must be positive real numbers.');        }        // Special case: x if x = y        if ($x == $y) {            return $x;        }        // Standard case        $â„¯  = \M_E;        $xË£ = $x ** $x;        $yÊ¸ = $y ** $y;        return 1 / $â„¯ * \pow($xË£ / $yÊ¸, 1 / ($x - $y));    }    /**     * Get a report of all the averages over a list of numbers     * Includes mean, median mode, geometric mean, harmonic mean, quardratic mean     *     * @param array $numbers     *     * @return array [ mean, median, mode, geometric_mean, harmonic_mean,     *                 contraharmonic_mean, quadratic_mean, trimean, iqm, cubic_mean ]     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function describe(array $numbers): array    {        return [            'mean'                => self::mean($numbers),            'median'              => self::median($numbers),            'mode'                => self::mode($numbers),            'geometric_mean'      => self::geometricMean($numbers),            'harmonic_mean'       => self::harmonicMean($numbers),            'contraharmonic_mean' => self::contraharmonicMean($numbers),            'quadratic_mean'      => self::quadraticMean($numbers),            'trimean'             => self::trimean($numbers),            'iqm'                 => self::iqm($numbers),            'cubic_mean'          => self::cubicMean($numbers),        ];    }}",0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RegularGridInterpolator_3003," Find the indicies and norm distances for search point\\n\\n @param float[] $xi 1-dimensional array ( search point = [x,y,z ....] )\\n\\n @return array[] (indices in grid for search point, normDistances for search point)\\n",Pronađite indekse i normativne udaljenosti za tačku pretraživanja,"    private function findIndices($xi): array    {        $indices       = [];  // Find relevant edges between which xi are situated        $normDistances = [];  // Compute distance to lower edge in unity units        // Iterate through dimensions x-y-z-...>        // $grid - 1nd array, example all x values (or all y..)        // $x float, search point: x or y or z...        foreach (Iter::zip($xi, $this->grid) as [$x, $grid]) {            $gridSize = \count($grid);                       // Column count            $i        = Search::sorted($grid, $x) - 1;  // Min match index            if ($i < 0) {                $i = 0;            }            if ($i > $gridSize - 2) {                $i = $gridSize - 2;            }            $indices[]       = $i;            $lessValue       = $grid[$i];            $greaterValue    = $grid[$i + 1];            $normDistances[] = ($x - $lessValue) / ($greaterValue - $lessValue);        }        return [$indices, $normDistances];    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_BaseYii_998, Configures an object with the initial property values.\\n @param object $object the object to be configured\\n @param array $properties the property initial values given in terms of name-value pairs.\\n @return object the object itself\\n,Konfiguriše objekat sa početnim vrednostima svojstava,"class ClassmapController extends Controller{    public $defaultAction = 'create';    /**     * Creates a class map for the core Yii classes.     * @param string $root    the root path of Yii framework. Defaults to YII2_PATH.     * @param string $mapFile the file to contain the class map. Defaults to YII2_PATH . '/classes.php'.     */    public function actionCreate($root = null, $mapFile = null)    {        if ($root === null) {            $root = YII2_PATH;        }        $root = FileHelper::normalizePath($root);        if ($mapFile === null) {            $mapFile = YII2_PATH . '/classes.php';        }        $options = [            'filter' => function ($path) {                if (is_file($path)) {                    $file = basename($path);                    if ($file[0] < 'A' || $file[0] > 'Z') {                        return false;                    }                }                return null;            },            'only' => ['*.php'],            'except' => [                '/Yii.php',                '/BaseYii.php',                '/console/',                '/requirements/',            ],        ];        $files = FileHelper::findFiles($root, $options);        $map = [];        foreach ($files as $file) {            if (strpos($file, $root) !== 0) {                throw new Exception(""Something wrong: $file\n"");            }            $path = str_replace('\\', '/', substr($file, \strlen($root)));            $map[$path] = ""  'yii"" . substr(str_replace('/', '\\', $path), 0, -4) . ""' => YII2_PATH . '$path',"";        }        ksort($map);        $map = implode(""\n"", $map);        $output = <<<EOD<?php/** * Yii core class map. * * This file is automatically generated by the ""build classmap"" command under the ""build"" folder. * Do not modify it directly. * * @link http://www.yiiframework.com/ * @copyright Copyright (c) 2008 Yii Software LLC * @license http://www.yiiframework.com/license/ */return [$map];EOD;        if (is_file($mapFile) && file_get_contents($mapFile) === $output) {            echo ""Nothing changed.\n"";        } else {            file_put_contents($mapFile, $output);            echo ""Class map saved in $mapFile\n"";        }    }}",0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_ReleaseController_979, Extract changelog content for a specific version.\\n @param string $file\\n @param string $version\\n @return array\\n,Izdvoja sadržaj changelog-a  za određenu verziju,"    protected function resortChangelog($changelog)    {        // cleanup whitespace        foreach ($changelog as $i => $line) {            $changelog[$i] = rtrim($line);        }        $changelog = array_filter($changelog);        $i = 0;        ArrayHelper::multisort($changelog, function ($line) use (&$i) {            if (preg_match('/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/', $line, $m)) {                $o = ['Bug' => 'C', 'Enh' => 'D', 'Chg' => 'E', 'New' => 'F'];                return $o[$m[1]] . ' ' . (!empty($m[2]) ? $m[2] : 'AAAA' . $i++);            }            return 'B' . $i++;        }, SORT_ASC, SORT_NATURAL);        // re-add leading and trailing lines        array_unshift($changelog, '');        $changelog[] = '';        $changelog[] = '';        return $changelog;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_1486, Initialize the debugger\\n\\n @return $this\\n @throws DebugBarException\\n,Inicijalizacija debagera,"    public function init()    {        if ($this->initialized) {            return $this;        }        $this->grav = Grav::instance();        $this->config = $this->grav['config'];        // Enable/disable debugger based on configuration.        $this->enabled = (bool)$this->config->get('system.debugger.enabled');        $this->censored = (bool)$this->config->get('system.debugger.censored', false);        if ($this->enabled) {            $this->initialized = true;            $clockwork = $debugbar = null;            switch ($this->config->get('system.debugger.provider', 'debugbar')) {                case 'clockwork':                    $this->clockwork = $clockwork = new Clockwork();                    break;                default:                    $this->debugbar = $debugbar = new DebugBar();            }            $plugins_config = (array)$this->config->get('plugins');            ksort($plugins_config);            if ($clockwork) {                $log = $this->grav['log'];                $clockwork->setStorage(new FileStorage('cache://clockwork'));                if (extension_loaded('xdebug')) {                    $clockwork->addDataSource(new XdebugDataSource());                }                if ($log instanceof Logger) {                    $clockwork->addDataSource(new MonologDataSource($log));                }                $timeline = $clockwork->timeline();                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Server');                    $event->finalize($this->requestTime, GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Loading');                    $event->finalize(GRAV_REQUEST_TIME, $this->currentTime);                }                $event = $timeline->event('Site Setup');                $event->finalize($this->currentTime, microtime(true));            }            if ($this->censored) {                $censored = ['CENSORED' => true];            }            if ($debugbar) {                $debugbar->addCollector(new PhpInfoCollector());                $debugbar->addCollector(new MessagesCollector());                if (!$this->censored) {                    $debugbar->addCollector(new RequestDataCollector());                }                $debugbar->addCollector(new TimeDataCollector($this->requestTime));                $debugbar->addCollector(new MemoryCollector());                $debugbar->addCollector(new ExceptionsCollector());                $debugbar->addCollector(new ConfigCollector($censored ?? (array)$this->config->get('system'), 'Config'));                $debugbar->addCollector(new ConfigCollector($censored ?? $plugins_config, 'Plugins'));                $debugbar->addCollector(new ConfigCollector($this->config->get('streams.schemes'), 'Streams'));                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Server', $debugbar['time']->getRequestStartTime(), GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Loading', GRAV_REQUEST_TIME, $this->currentTime);                }                $debugbar['time']->addMeasure('Site Setup', $this->currentTime, microtime(true));            }            $this->addMessage('Grav v' . GRAV_VERSION . ' - PHP ' . PHP_VERSION);            $this->config->debug();            if ($clockwork) {                $clockwork->info('System Configuration', $censored ?? $this->config->get('system'));                $clockwork->info('Plugins Configuration', $censored ?? $plugins_config);                $clockwork->info('Streams', $this->config->get('streams.schemes'));            }        }        return $this;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Correlation_3480, Ï„ - Kendall rank correlation coefficient (Kendall's tau)\\n\\n A statistic used to measure the ordinal association between two\\n measured quantities. It is a measure of rank correlation:\\n the similarity of the orderings of the data when ranked by each\\n of the quantities.\\n https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient\\n https://onlinecourses.science.psu.edu/stat509/node/158\\n\\n tau-a (no rank ties):\\n\\n        nc - nd\\n   Ï„ = ----------\\n       n(n - 1)/2\\n\\n   Where\\n     nc: number of concordant pairs\\n     nd: number of discordant pairs\\n\\n tau-b (rank ties exist):\\n\\n                 nc - nd\\n   Ï„ = -----------------------------\\n       âˆš(nc + nd + Xâ‚€)(nc + nd + Yâ‚€)\\n\\n   Where\\n     Xâ‚€: number of pairs tied only on the X variable\\n     Yâ‚€: number of pairs tied only on the Y variable\\n\\n @param array $X values for random variable X\\n @param array $Y values for random variable Y\\n\\n @todo Implement with algorithm faster than O(nÂ²)\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if both random variables do not have the same number of elements\\n,Kendallov koeficijent korelacije ranga (Kendallov tau) Statistika koja se koristi za merenje redne povezanosti između dve izmerene veličine. To je mera korelacije ranga: sličnost redosleda podataka kada ih rangira svaka količina,"    public static function kendallsTau(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('Both random variables must have the same number of elements');        }        $n = \count($X);        // Match X and Y pairs and sort by X rank        $xy = \array_map(            function ($x, $y) {                return [$x, $y];            },            $X,            $Y        );        \usort($xy, function ($a, $b) {            return $a[0] <=> $b[0];        });        // Initialize counters        $nc      = 0;  // concordant pairs        $nd      = 0;  // discordant pairs        $ties_x  = 0;  // ties xáµ¢ = xâ±¼        $ties_y  = 0;  // ties yáµ¢ = yâ±¼        $ties_xy = 0;  // ties xáµ¢ = xâ±¼ and yáµ¢ = yâ±¼        // Tally concordant, discordant, and tied pairs        for ($i = 0; $i < $n; $i++) {            for ($j = $i + 1; $j < $n; $j++) {                // xáµ¢ = xâ±¼ and yáµ¢ = yâ±¼ -- neither concordant or discordant                if ($xy[$i][self::X] == $xy[$j][self::X] && $xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_xy++;                // xáµ¢ = xâ±¼ -- neither concordant or discordant                } elseif ($xy[$i][self::X] == $xy[$j][self::X]) {                    $ties_x++;                // yáµ¢ = yâ±¼ -- neither concordant or discordant                } elseif ($xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_y++;                // xáµ¢ < xâ±¼ and yáµ¢ < yâ±¼ -- concordant                } elseif ($xy[$i][self::X] < $xy[$j][self::X] && $xy[$i][self::Y] < $xy[$j][self::Y]) {                    $nc++;                // xáµ¢ > xâ±¼ and yáµ¢ < yâ±¼ or  xáµ¢ < xâ±¼ and yáµ¢ > yâ±¼ -- discordant                } else {                    $nd++;                }            }        }        // Numerator: (number of concordant pairs) - (number of discordant pairs)        $âŸ®ncÂ âˆ’Â ndâŸ¯ = $nc - $nd;        /* tau-a (no rank ties):         *         *        nc - nd         *   Ï„ = ----------         *       n(n - 1)/2         */        if ($ties_x == 0 && $ties_y == 0) {            return $âŸ®ncÂ âˆ’Â ndâŸ¯ / (($n * ($n - 1)) / 2);        }        /* tau-b (rank ties exist):         *         *                 nc - nd         *   Ï„ = -----------------------------         *       âˆš(nc + nd + Xâ‚€)(nc + nd + Yâ‚€)         */        return $âŸ®ncÂ âˆ’Â ndâŸ¯ / \sqrt(($nc + $nd + $ties_x) * ($nc + $nd + $ties_y));    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_CorsController_1436, WhiteLists a domain for CORS\n\n @NoAdminRequired\n @NoSubadminRequired\n\n @param string $domain The domain to whitelist\n @return JSONResponse\n, WhiteLists domen za CORS,"public function addDomain($domain) {if ($this->isValidUrl($domain)) {$userId = $this->userId;$domains = \json_decode($this->config->getUserValue($userId, 'core', 'domains', '[]'), true);$domains = \array_filter($domains);\array_push($domains, $domain);// In case same domain is added$domains = \array_unique($domains);// Store as comma separated string$domainsString = \json_encode($domains);$this->config->setUserValue($userId, 'core', 'domains', $domainsString);$this->logger->debug(""The domain {$domain} has been white-listed."", ['app' => $this->appName]);return new JSONResponse([ 'domains' => $domains]);} else {$errorMsg = $this->l10n->t(""Invalid url '%s'. Urls should be set up like 'http://www.example.com' or 'https://www.example.com'"", \strip_tags($domain));return new JSONResponse([ 'message' => $errorMsg ]);}",0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_InstalledVersions_2524," Returns a list of all package names which are present, either by being installed, replaced or provided\n\n @return string[]\n @psalm-return list<string>\n","Prikazuje listu svih prisutnih imena paketa, bilo instaliranjem, zamenom ili pružanjem","    public static function getInstalledPackages()    {        $packages = array();        foreach (self::getInstalled() as $installed) {            $packages[] = array_keys($installed['versions']);        }        if (1 === \count($packages)) {            return $packages[0];        }        return array_keys(array_flip(\call_user_func_array('array_merge', $packages)));    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_FrameCollection_8407, Exposes a fluent interface for dealing with an ordered list\n of stack-trace frames.\n,Izlaže tečan interfejs koji se bavi uređenom listom stack-trace frejmova,"class FrameCollection implements ArrayAccess, IteratorAggregate, Serializable, Countable{    /**     * @var array[]     */    private $frames;    /**     * @param array $frames     */    public function __construct(array $frames)    {        $this->frames = array_map(function ($frame) {            return new Frame($frame);        }, $frames);    }    /**     * Filters frames using a callable, returns the same FrameCollection     *     * @param  callable        $callable     * @return FrameCollection     */    public function filter($callable)    {        $this->frames = array_values(array_filter($this->frames, $callable));        return $this;    }    /**     * Map the collection of frames     *     * @param  callable        $callable     * @return FrameCollection     */    public function map($callable)    {        // Contain the map within a higher-order callable        // that enforces type-correctness for the $callable        $this->frames = array_map(function ($frame) use ($callable) {            $frame = call_user_func($callable, $frame);            if (!$frame instanceof Frame) {                throw new UnexpectedValueException(                    ""Callable to "" . __CLASS__ . ""::map must return a Frame object""                );            }            return $frame;        }, $this->frames);        return $this;    }    /**     * Returns an array with all frames, does not affect     * the internal array.     *     * @todo   If this gets any more complex than this,     *         have getIterator use this method.     * @see    FrameCollection::getIterator     * @return array     */    public function getArray()    {        return $this->frames;    }    /**     * @see IteratorAggregate::getIterator     * @return ArrayIterator     */    public function getIterator()    {        return new ArrayIterator($this->frames);    }    /**     * @see ArrayAccess::offsetExists     * @param int $offset     */    public function offsetExists($offset)    {        return isset($this->frames[$offset]);    }    /**     * @see ArrayAccess::offsetGet     * @param int $offset     */    public function offsetGet($offset)    {        return $this->frames[$offset];    }    /**     * @see ArrayAccess::offsetSet     * @param int $offset     */    public function offsetSet($offset, $value)    {        throw new \Exception(__CLASS__ . ' is read only');    }    /**     * @see ArrayAccess::offsetUnset     * @param int $offset     */    public function offsetUnset($offset)    {        throw new \Exception(__CLASS__ . ' is read only');    }    /**     * @see Countable::count     * @return int     */    public function count()    {        return count($this->frames);    }    /**     * Count the frames that belongs to the application.     *     * @return int     */    public function countIsApplication()    {        return count(array_filter($this->frames, function (Frame $f) {            return $f->isApplication();        }));    }    /**     * @see Serializable::serialize     * @return string     */    public function serialize()    {        return serialize($this->frames);    }    /**     * @see Serializable::unserialize     * @param string $serializedFrames     */    public function unserialize($serializedFrames)    {        $this->frames = unserialize($serializedFrames);    }    /**     * @param Frame[] $frames Array of Frame instances, usually from $e->getPrevious()     */    public function prependFrames(array $frames)    {        $this->frames = array_merge($frames, $this->frames);    }    /**     * Gets the innermost part of stack trace that is not the same as that of outer exception     *     * @param  FrameCollection $parentFrames Outer exception frames to compare tail against     * @return Frame[]     */    public function topDiff(FrameCollection $parentFrames)    {        $diff = $this->frames;        $parentFrames = $parentFrames->getArray();        $p = count($parentFrames)-1;        for ($i = count($diff)-1; $i >= 0 && $p >= 0; $i--) {            /** @var Frame $tailFrame */            $tailFrame = $diff[$i];            if ($tailFrame->equals($parentFrames[$p])) {                unset($diff[$i]);            }            $p--;        }        return $diff;    }}",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_961," Given a segment, will return a list of the most used values for this particular segment.\n @param $segmentName\n @param $idSite\n @throws \\Exception\n @return array\n",Dati segment vratiće listu najčešće korišćenih vrednosti za ovaj određeni segment,"    public function getSuggestedValuesForSegment($segmentName, $idSite)    {        if (empty(Config::getInstance()->General['enable_segment_suggested_values'])) {            return array();        }        Piwik::checkUserHasViewAccess($idSite);        $maxSuggestionsToReturn = 30;        $segment = $this->findSegment($segmentName, $idSite);        // if segment has suggested values callback then return result from it instead        $suggestedValuesCallbackRequiresTable = false;        if (!empty($segment['suggestedValuesApi']) && is_string($segment['suggestedValuesApi']) && !Rules::isBrowserTriggerEnabled()) {            $now = Date::now()->setTimezone(Site::getTimezoneFor($idSite));            if (self::$_autoSuggestLookBack != 60) {                // in Auto suggest tests we need to assume now is in 2018...                // we do - 20 to make sure the year is still correct otherwise could end up being 2017-12-31 and the recorded visits are over several days in the tests we make sure to select the last day a visit was recorded                $now = $now->subDay(self::$_autoSuggestLookBack - 20);            }            // we want to avoid launching the archiver should browser archiving be enabled as this can be very slow... we then rather            // use the live api.            $period = 'year';            $date = $now->toString();            if ($now->toString('m') == '01') {                if (Rules::isArchivingDisabledFor(array($idSite), new Segment('', array($idSite)), 'range')) {                    $date = $now->subYear(1)->toString(); // use previous year data to avoid using range                } else {                    $period = 'range';                    $date = $now->subMonth(1)->toString() . ',' . $now->addDay(1)->toString();                }            }            $apiParts = explode('.', $segment['suggestedValuesApi']);            $meta = $this->getMetadata($idSite, $apiParts[0], $apiParts[1]);            $flat = !empty($meta[0]['actionToLoadSubTables']) && $meta[0]['actionToLoadSubTables'] == $apiParts[1];            $table = Request::processRequest($segment['suggestedValuesApi'], array(                'idSite' => $idSite,                'period' => $period,                'date' => $date,                'segment' => '',                'filter_offset' => 0,                'flat' => (int) $flat,                'filter_limit' => $maxSuggestionsToReturn            ));            if ($table && $table instanceof DataTable && $table->getRowsCount()) {                $values = [];                foreach ($table->getRowsWithoutSummaryRow() as $row) {                    $segment = $row->getMetadata('segment');                    $remove = array(                        $segmentName . Segment\SegmentExpression::MATCH_EQUAL,                        $segmentName . Segment\SegmentExpression::MATCH_STARTS_WITH                    );                    // we don't look at row columns since this could include rows that won't work eg Other summary rows. etc                    // and it is generally not reliable.                    if (!empty($segment) && preg_match('/^' . implode('|',$remove) . '/', $segment)) {                        $values[] = urldecode(urldecode(str_replace($remove, '', $segment)));                    }                }                $values = array_slice($values, 0, $maxSuggestionsToReturn);                $values = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $values);                return $values;            }        }        if (isset($segment['suggestedValuesCallback'])) {            $suggestedValuesCallbackRequiresTable = $this->doesSuggestedValuesCallbackNeedData(                $segment['suggestedValuesCallback']);            if (!$suggestedValuesCallbackRequiresTable) {                return call_user_func($segment['suggestedValuesCallback'], $idSite, $maxSuggestionsToReturn);            }        }        // if period=range is disabled, do not proceed        if (!Period\Factory::isPeriodEnabledForAPI('range')) {            return array();        }        if (!empty($segment['unionOfSegments'])) {            $values = array();            foreach ($segment['unionOfSegments'] as $unionSegmentName) {                $unionSegment = $this->findSegment($unionSegmentName, $idSite, $_showAllSegments = true);                try {                    $result = $this->getSuggestedValuesForSegmentName($idSite, $unionSegment, $maxSuggestionsToReturn);                    if (!empty($result)) {                        $values = array_merge($result, $values);                    }                } catch (\Exception $e) {                    // we ignore if there was no data found for $unionSegmentName                }            }            if (empty($values)) {                throw new \Exception(""There was no data to suggest for $segmentName"");            }        } else {            $values = $this->getSuggestedValuesForSegmentName($idSite, $segment, $maxSuggestionsToReturn);        }        $values = $this->getMostFrequentValues($values);        $values = array_slice($values, 0, $maxSuggestionsToReturn);        $values = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $values);        return $values;    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_786, Returns the list of plugins that archive the given reports.\n\n @param array $archiveNames\n @return array\n,Prikazuje listu dodataka koji arhiviraju date izveštaje,    private function getRequestedPlugins($archiveNames)    {        $result = array();        foreach ($archiveNames as $name) {            $result[] = self::getPluginForReport($name);        }        return array_unique($result);    },0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_FileList_955, Retrieve the filtered file list as an array.\n\n @return array\n,Dohvatite filtriranu listu datoteka kao niz,"    public function getList()    {        $fileList = [];        foreach ($this->fileIterator as $file) {            $fileList[] = str_replace($this->rootPath, '', $file);        }        return $fileList;    }//end getList()",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9832, Gets a list of languages acceptable by the client browser.\n\n @return array Languages ordered in the user browser preferences\n,,"    public function getLanguages()    {        if (null !== $this->languages) {            return $this->languages;        }        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();        $this->languages = [];        foreach ($languages as $lang => $acceptHeaderItem) {            if (false !== strpos($lang, '-')) {                $codes = explode('-', $lang);                if ('i' === $codes[0]) {                    // Language not listed in ISO 639 that are not variants                    // of any listed language, which can be registered with the                    // i-prefix, such as i-cherokee                    if (\count($codes) > 1) {                        $lang = $codes[1];                    }                } else {                    for ($i = 0, $max = \count($codes); $i < $max; ++$i) {                        if (0 === $i) {                            $lang = strtolower($codes[0]);                        } else {                            $lang .= '_'.strtoupper($codes[$i]);                        }                    }                }            }            $this->languages[] = $lang;        }        return $this->languages;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_ArgsStub_9204, Represents a list of function arguments.\n\n @author Nicolas Grekas <p@tchwork.com>\n,Predstavlja listu argumenata funkcije,"final class CliContextProvider implements ContextProviderInterface{    public function getContext(): ?array    {        if ('cli' !== \PHP_SAPI) {            return null;        }        return [            'command_line' => $commandLine = implode(' ', $_SERVER['argv'] ?? []),            'identifier' => hash('crc32b', $commandLine.$_SERVER['REQUEST_TIME_FLOAT']),        ];    }}",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_DevController_956, Get a list of subdirectories for directory specified.\n @param string $dir directory to read\n\n @return array list of subdirectories\n,Dobija listu jezika prihvatljivih za klijentski pregledač,"    protected function listSubDirs($dir)    {        $list = [];        $handle = opendir($dir);        if ($handle === false) {            throw new InvalidParamException(""Unable to open directory: $dir"");        }        while (($file = readdir($handle)) !== false) {            if ($file === '.' || $file === '..') {                continue;            }            // ignore hidden directories            if (strpos($file, '.') === 0) {                continue;            }            if (is_dir(""$dir/$file"")) {                $list[] = ""$dir/$file"";            }        }        closedir($handle);        return $list;    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_CachedObjectStorageFactory_132, Return the list of all available cache storage methods\\n\\n @return string[]\\n,Vratite listu svih dostupnih metoda keš memorije,"    public static function getCacheStorageMethods()    {        $activeMethods = array();        foreach (self::$storageMethods as $storageMethod) {            $cacheStorageClass = 'PHPExcel_CachedObjectStorage_' . $storageMethod;            if (call_user_func(array($cacheStorageClass, 'cacheMethodIsAvailable'))) {                $activeMethods[] = $storageMethod;            }        }        return $activeMethods;    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_198, Get postgresql db options\n,Dohvatite postgresql db opcije,"    function getOptionsPostgresql(): array    {        return [            'host'     => env('DATA_POSTGRES_HOST'),            'username' => env('DATA_POSTGRES_USER'),            'password' => env('DATA_POSTGRES_PASS'),            'port'     => env('DATA_POSTGRES_PORT'),            'dbname'   => env('DATA_POSTGRES_NAME'),            'schema'   => env('DATA_POSTGRES_SCHEMA'),        ];    }",0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_200, Get sqlite db options\n,Dohvatite sqlite db opcije,"    function getOptionsSqlite(): array    {        return [            'dbname' => codecept_root_dir(env('DATA_SQLITE_NAME')),        ];    }",0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_2095, Get mysql db options\n,Dohvatite mysql db opcije,"    function getOptionsMysql(): array    {        return [            'host'     => env('DATA_MYSQL_HOST'),            'username' => env('DATA_MYSQL_USER'),            'password' => env('DATA_MYSQL_PASS'),            'dbname'   => env('DATA_MYSQL_NAME'),            'port'     => env('DATA_MYSQL_PORT'),            'charset'  => env('DATA_MYSQL_CHARSET'),        ];    }",0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2688, Matrix factory to create matrices of all types.\n Use factory instead of instantiating individual Matrix classes.\n,Fabrika matrica za stvaranje matrica svih tipova. Koristitite fabriku umesto instanciranja pojedinačnih klasa matrica,"class MatrixFactory{    /**     * Factory method     *     * @param  number[][] $A 2-dimensional array of Matrix data     * @param float|null $Îµ Optional error tolerance     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public static function create(array $A, ?float $Îµ = null): Matrix    {        self::checkParams($A);        $matrix_type = self::determineMatrixType($A);        switch ($matrix_type) {            case 'numeric':            case 'numeric_square':                return self::createNumeric($A, $Îµ);            case 'complex':                return new ComplexMatrix($A);            case 'object':                return new ObjectMatrix($A);            case 'object_square':                return new ObjectSquareMatrix($A);        }        throw new Exception\IncorrectTypeException('Unknown matrix type: ' . print_r($A, true));    }    /**     * @param number[][] $A     * @param float|null $Îµ Optional error tolerance     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     */    public static function createNumeric(array $A, ?float $Îµ = null): NumericMatrix    {        $m = \count($A);        $n = \count($A[0]);        if ($m === $n) {            $A = new NumericSquareMatrix($A);            $A->setError($Îµ);            return $A;        }        $A = new NumericMatrix($A);        $A->setError($Îµ);        return $A;    }    /**     * Factory method to create a matrix from an array of Vectors     *     * Example:     *        [1]       [4]        [7]       [8]     *   Xâ‚ = [2]  Xâ‚‚ = [2]   Xâ‚ƒ = [8]  Xâ‚„ = [4]     *        [1]       [13]       [1]       [5]     *     *       [1  4 7 8]     *   R = [2  2 8 4]     *       [1 13 1 5]     *     * @param  Vector[] $A array of Vectors     * @param float|null $Îµ Optional error tolerance     *     * @return Matrix     *     * @throws Exception\MatrixException if the Vectors are not all the same length     * @throws Exception\IncorrectTypeException     * @throws Exception\BadDataException     */    public static function createFromVectors(array $A, ?float $Îµ = null): NumericMatrix    {        // Check that all vectors are the same length        $m = $A[0]->getN();        $n = \count($A);        for ($j = 1; $j < $n; $j++) {            if ($A[$j]->getN() !== $m) {                throw new Exception\MatrixException('Vectors being combined into matrix have different lengths');            }        }        // Concatenate all the vectors        $R = [];        foreach ($A as $V) {            $R[] = $V->getVector();        }        // Transpose to create matrix from the vector columns        return (self::createNumeric($R, $Îµ))->transpose();    }    /**     * Column vector (column matrix)     * m Ã— 1 matrix consisting of a single column of m elements.     *     *     [xâ‚]     * x = [xâ‚‚]     *     [â‹® ]     *     [xm]     *     * @param array $A m Ã— 1 vector representing the matrix     *     * @return Matrix     */    public static function createFromColumnVector(array $A): Matrix    {        foreach ($A as $item) {            if (\is_array($item)) {                throw new Exception\BadDataException('Column vector data must be a one-dimensional array');            }        }        $R = [];        foreach ($A as $value) {            $R[] = [$value];        }        return self::create($R);    }    /**     * Row vector (row matrix)     * 1 Ã— n matrix consisting of a single row of n elements.     *     * x = [xâ‚ xâ‚‚ â‹¯ xn]     *     * @param array $A 1 Ã— n vector representing the matrix     *     * @return Matrix     */    public static function createFromRowVector(array $A): Matrix    {        foreach ($A as $item) {            if (\is_array($item)) {                throw new Exception\BadDataException('Row vector data must be a one-dimensional array');            }        }        $R = [$A];        return self::create($R);    }    /**     * Factory method     *     * @param  array[] $A 2-dimensional array of Matrix data     *     * @return FunctionMatrix     */    public static function createFunctionMatrix(array $A): FunctionMatrix    {        self::checkParams($A);        if (!is_callable($A[0][0])) {            throw new Exception\BadDataException('FunctionMatrix must be made of functions - got ' . gettype($A[0][0]));        }        return new FunctionMatrix($A);    }    /**************************************************************************     * SPECIAL MATRICES - Not created from an array of arrays     *  - identity     *  - exchange     *  - downshiftPermutation     *  - upshiftPermutation     *  - zero     *  - one     *  - eye     *  - diagonal     *  - hilbert     *  - vandermonde     *  - givens     **************************************************************************/    /**     * Identity matrix - n x n matrix with ones in the diagonal     *     * Example:     *  n = 3;     *     *      [1 0 0]     *  A = [0 1 0]     *      [0 0 1]     *     * @param int   $n size of matrix     *     * @return NumericSquareMatrix     *     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function identity(int $n): NumericSquareMatrix    {        if ($n < 0) {            throw new Exception\OutOfBoundsException(""n must be â‰¥ 0. n = $n"");        }        $R = [];        for ($i = 0; $i < $n; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $i == $j ? 1 : 0;            }        }        return new NumericSquareMatrix($R);    }    /**     * Exchange matrix - n x n matrix with ones in the reverse diagonal     * Row-reversed, or column-reversed version of the identity matrix.     * https://en.wikipedia.org/wiki/Exchange_matrix     *     * Example:     *  n = 3;     *     *      [0 0 1]     *  A = [0 1 0]     *      [1 0 0]     *     * @param int $n size of matrix     *     * @return NumericSquareMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function exchange(int $n): NumericSquareMatrix    {        if ($n < 0) {            throw new Exception\OutOfBoundsException(""n must be â‰¥ 0. n = $n"");        }        $R = [];        $one = $n - 1;        for ($i = 0; $i < $n; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $j == $one ? 1 : 0;            }            $one--;        }        return new NumericSquareMatrix($R);    }    /**     * Downshift permutation matrix     * Pushes the components of a vector down one notch with wraparound     *     *       [0, 0, 0, 1] [xâ‚]   [xâ‚„]     *       [1, 0, 0, 0] [xâ‚‚]   [xâ‚]     * Dâ‚„x = [0, 1, 0, 0] [xâ‚ƒ] = [xâ‚‚]     *       [0, 0, 1, 0] [xâ‚„]   [xâ‚ƒ]     *     * @param  int $n     *     * @return NumericSquareMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function downshiftPermutation(int $n): NumericSquareMatrix    {        $I = self::identity($n)->getMatrix();        $bottom_row = \array_pop($I);        \array_unshift($I, $bottom_row);        return new NumericSquareMatrix($I);    }    /**     * Upshift permutation matrix - Dáµ€     * Pushes the components of a vector up one notch with wraparound     *     * @param  int $n     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     */    public static function upshiftPermutation(int $n): Matrix    {        return self::downshiftPermutation($n)->transpose();    }    /**     * Zero matrix - m x n matrix with all elements being zeros     *     * Example:     *  m = 3; n = 3     *     *      [0 0 0]     *  A = [0 0 0]     *      [0 0 0]     *     * @param int $m rows     * @param int $n columns     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m < 1 or n < 1     */    public static function zero(int $m, int $n): NumericMatrix    {        if ($m < 1 || $n < 1) {            throw new Exception\OutOfBoundsException(""m and n must be > 0. m = $m, n = $n"");        }        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 0;            }        }        return self::createNumeric($R);    }    /**     * Ones matrix - m x n matrix with all elements being ones     *     * Example:     *  m = 3; n = 3     *     *      [1 1 1]     *  A = [1 1 1]     *      [1 1 1]     *     * @param int $m rows     * @param int $n columns     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m or n < 1     */    public static function one(int $m, int $n): NumericMatrix    {        if ($m < 1 || $n < 1) {            throw new Exception\OutOfBoundsException(""m and n must be > 0. m = $m, n = $n"");        }        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 1;            }        }        return self::createNumeric($R);    }    /**     * Eye matrix - ones on the k diagonal and zeros everywhere else.     * Diagonal can start at any column.     * Option to set the diagonal to any number.     *     * Example:     *  m = 3; n = 3; k = 1; x = 1 (3x3 matrix with 1s on the kth (1) diagonal)     *     *      [0 1 0]     *  A = [0 0 1]     *      [0 0 0]     *     * @param int        $m number of rows     * @param int        $n number of columns     * @param int        $k Diagonal to fill with xs     * @param float|null $x (optional; default 1)     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m, n, or k are < 0; if k >= n     */    public static function eye(int $m, int $n, int $k, float $x = null): NumericMatrix    {        if ($n < 0 || $m < 0 || $k < 0) {            throw new Exception\OutOfBoundsException(""m, n and k must be â‰¥ 0. m = $m, n = $n, k = $k"");        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException(""k must be < n. k = $k, n = $n"");        }        $x = $x ?? 1;        $R = (self::zero($m, $n))->getMatrix();        for ($i = 0; $i < $m; $i++) {            if (($k + $i) < $n) {                $R[$i][$k + $i] = $x;            }        }        return self::createNumeric($R);    }    /**     * A Diagonal Matrix is constructed from a single-row array.     * The elements of this array are placed on the diagonal of a square matrix.     *     * Example:     *  D = [1, 2, 3]     *     *     [1 0 0]     * A = [0 2 0]     *     [0 0 3]     *     * @param array $D elements of the diagonal     *     * @return NumericDiagonalMatrix     *     * @throws Exception\MatrixException     */    public static function diagonal(array $D): NumericDiagonalMatrix    {        $m = \count($D);        $A = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $m; $j++) {                if ($i == $j) {                    $A[$i][$j] = $D[$i];                } else {                    $A[$i][$j] = 0;                }            }        }        return new NumericDiagonalMatrix($A);    }    /**     * Hilbert matrix - a square matrix with entries being the unit fractions     * https://en.wikipedia.org/wiki/Hilbert_matrix     *     *           1     * Hij = ---------     *       i + j - 1     *     * Example: n = 5     *     *     [1 Â½ â…“ Â¼ â…•]     *     [Â½ â…“ Â¼ â…• â…™]     * H = [â…“ Â¼ â…• â…™ â…]     *     [Â¼ â…• â…™ â… â…›]     *     [â…• â…™ â… â…› â…‘]     *     * @param int $n     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException     */    public static function hilbert(int $n): NumericMatrix    {        if ($n < 1) {            throw new Exception\OutOfBoundsException(""n must be > 0. m = $n"");        }        $H = [];        for ($i = 1; $i <= $n; $i++) {            for ($j = 1; $j <= $n; $j++) {                $H[$i - 1][$j - 1] = 1 / ($i + $j - 1);            }        }        return new NumericSquareMatrix($H);    }    /**     * Create the Vandermonde Matrix from a simple array.     *     * @param array $M (Î±â‚, Î±â‚‚, Î±â‚ƒ â‹¯ Î±m)     * @param int   $n     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public static function vandermonde(array $M, int $n): NumericMatrix    {        $A = [];        foreach ($M as $row => $Î±) {            for ($i = 0; $i < $n; $i++) {                $A[$row][$i] = $Î± ** $i;            }        }        return self::createNumeric($A);    }   /**    * Construct a Givens rotation matrix    *    *               [  1 â‹¯ 0 â‹¯ 0 â‹¯ 0  ]    *               [  â‹® â‹± â‹®   â‹®   â‹®   ]    *               [  0 â‹¯ c â‹¯-s â‹¯ 0  ]    * G (ð’¾,ð’¿,Î¸) =   [  â‹®   â‹®  â‹± â‹®  â‹®  ]    *               [  0 â‹¯ s â‹¯ c â‹¯ 0  ]    *               [  â‹®    â‹®   â‹® â‹± â‹® ]    *               [  0 â‹¯ 0 â‹¯ 0 â‹¯ 1 ]    *    * https://en.wikipedia.org/wiki/Givens_rotation    *    * @param int   $m The row in G in which the top of the rotation lies    * @param int   $n The column in G in which the left of the rotation lies    * @param float $angle The angle to use in the trigonometric functions    * @param int   $size The total number of rows in G    *    * @return NumericMatrix    *    * @throws Exception\BadDataException    * @throws Exception\MathException    * @throws Exception\OutOfBoundsException    */    public static function givens(int $m, int $n, float $angle, int $size): NumericMatrix    {        if ($m >= $size || $n >= $size || $m < 0 || $n < 0) {            throw new Exception\OutOfBoundsException(""m and n must be within the matrix"");        }        $G         = MatrixFactory::identity($size)->getMatrix();        $G[$m][$m] = \cos($angle);        $G[$n][$n] = \cos($angle);        $G[$m][$n] = -1 * \sin($angle);        $G[$n][$m] = \sin($angle);        return self::createNumeric($G);    }    /**     * Create a Matrix of random numbers     *     * @param int $m   number of rows     * @param int $n   number of columns     * @param int $min lower bound for the random number (optional - default: 0)     * @param int $max upper bound for the random number (optional - default: 20)     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     */    public static function random(int $m, int $n, int $min = 0, int $max = 20): NumericMatrix    {        $A = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $A[$i][$j] = \rand($min, $max);            }        }        return self::createNumeric($A);    }    /* ************************************************************************     * PRIVATE HELPER METHODS     * ***********************************************************************/    /**     * Check input parameters     *     * @param  array    $A     *     * @throws Exception\BadDataException if array data not provided for matrix creation     * @throws Exception\MatrixException if any row has a different column count     */    private static function checkParams(array $A): void    {        if (empty($A)) {            throw new Exception\BadDataException('Array data not provided for Matrix creation');        }        if (isset($A[0]) && \is_array($A[0])) {            $column_count = \count($A[0]);            foreach ($A as $i => $row) {                if (\count($row) !== $column_count) {                    throw new Exception\MatrixException(""Row $i has a different column count: "" . \count($row) . ""; was expecting $column_count."");                }            }        }    }    /**     * Determine what type of matrix to create     *     * @param  array[] $A 2-dimensional array of Matrix data     *     * @return string indicating what matrix type to create     */    private static function determineMatrixType(array $A): string    {        $m = \count($A);        $n = \count($A[0]);        // Object (closure) matrices        if (\is_object($A[0][0])) {            if ($A[0][0] instanceof Complex) {                return 'complex';            }            return $m === $n                ? 'object_square'                : 'object';        }        // Numeric matrix        if (\is_numeric($A[0][0])) {            return $m === $n                ? 'numeric_square'                : 'numeric';        }        // Unknown or bad data        return 'unknown';    }}",0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Eigenvector_2617, Find the zero columns\n\n @param  NumericMatrix $M\n\n @return array\n,Pronađite nulte kolone,"    private static function findZeroColumns(NumericMatrix $M): array    {        $m = $M->getM();        $zero_columns = [];        for ($i = 0; $i < $M->getN(); $i++) {            if ($M->getColumn($i) == \array_fill(0, $m, 0)) {                $zero_columns[] = $i;            }        }        return $zero_columns;    }",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2631," Returns the elements on the diagonal of a square matrix as an array\n     [1 2 3]\n A = [4 5 6]\n     [7 8 9]\n\n getDiagonalElements($A) = [1, 5, 9]\n\n @return array\n",Vraća elemente na dijagonali kvadratne matrice kao niz,"    public function getDiagonalElements(): array    {        $diagonal = [];        for ($i = 0; $i < \min($this->m, $this->n); $i++) {            $diagonal[] = $this->A[$i][$i];        }        return $diagonal;    }",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2633," Returns the elements on the subdiagonal of a square matrix as an array\n     [1 2 3]\n A = [4 5 6]\n     [7 8 9]\n\n getSubdiagonalElements($A) = [4, 8]\n\n http://mathworld.wolfram.com/Subdiagonal.html\n\n @return array\n",Vraća elemente na poddijagonali kvadratne matrice kao niz,    public function getSubdiagonalElements(): array    {        $subdiagonal = [];        if ($this->isSquare()) {            for ($i = 1; $i < $this->m; $i++) {                $subdiagonal[] = $this->A[$i][$i - 1];            }        }        return $subdiagonal;    },0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1490, Returns PTY state.\\n\\n @return bool\\n,Vraća PTY stanje,"    public function getWorkingDirectory()    {        if (null === $this->cwd) {            // getcwd() will return false if any one of the parent directories does not have            // the readable or search mode set, even if the current directory does            return getcwd() ?: null;        }        return $this->cwd;    }",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1485, Get the local PsySH config file.\n\n Searches for a project specific config file `.psysh.php` in the current\n working directory.\n\n @return string\n,Dohvatanje lokalne datoteke za konfiguraciju PsySH. Pretražuje konfiguracionu datoteku specifičnu za projekat `.psish.php` u trenutnom radnom direktorijumu,    public function getLocalConfigFile()    {        $localConfig = \getcwd().'/.psysh.php';        if (@\is_file($localConfig)) {            return $localConfig;        }    },0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_ProcessFailedExceptionTest_1552, Tests ProcessFailedException throws exception if the process was successful.\\\\n,Testovi ProcessFailedException bacaju izuzetak ako je proces bio uspešan,"    public function testDisabledOutputInFailedExceptionDoesNotPopulateOutput()    {        $cmd = 'php';        $exitCode = 1;        $exitText = 'General error';        $workingDirectory = getcwd();        $process = $this->getMockBuilder(Process::class)->setMethods(['isSuccessful', 'isOutputDisabled', 'getExitCode', 'getExitCodeText', 'getOutput', 'getErrorOutput', 'getWorkingDirectory'])->setConstructorArgs([[$cmd]])->getMock();        $process->expects($this->once())            ->method('isSuccessful')            ->willReturn(false);        $process->expects($this->never())            ->method('getOutput');        $process->expects($this->never())            ->method('getErrorOutput');        $process->expects($this->once())            ->method('getExitCode')            ->willReturn($exitCode);        $process->expects($this->once())            ->method('getExitCodeText')            ->willReturn($exitText);        $process->expects($this->once())            ->method('isOutputDisabled')            ->willReturn(true);        $process->expects($this->once())            ->method('getWorkingDirectory')            ->willReturn($workingDirectory);        $exception = new ProcessFailedException($process);        $this->assertEquals(            ""The command \""$cmd\"" failed.\n\nExit Code: $exitCode($exitText)\n\nWorking directory: {$workingDirectory}"",            str_replace(""'php'"", 'php', $exception->getMessage())        );    }",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_871, Processes a long (--example) command line argument.\\n\\n @param string $arg The command line argument.\\n @param int    $pos The position of the argument on the command line.\\n\\n @return void\\n @throws \\\\PHP_CodeSniffer\\\\Exceptions\\\\DeepExitException\\n,Obrađuje dugi (--primer) argument gomandne linije,"    public function processLongArgument($arg, $pos)    {        switch ($arg) {        case 'help':            ob_start();            $this->printUsage();            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'version':            $output  = 'PHP_CodeSniffer version '.self::VERSION.' ('.self::STABILITY.') ';            $output .= 'by Squiz (http://www.squiz.net)'.PHP_EOL;            throw new DeepExitException($output, 0);        case 'colors':            if (isset(self::$overriddenDefaults['colors']) === true) {                break;            }            $this->colors = true;            self::$overriddenDefaults['colors'] = true;            break;        case 'no-colors':            if (isset(self::$overriddenDefaults['colors']) === true) {                break;            }            $this->colors = false;            self::$overriddenDefaults['colors'] = true;            break;        case 'cache':            if (isset(self::$overriddenDefaults['cache']) === true) {                break;            }            if (defined('PHP_CODESNIFFER_IN_TESTS') === false) {                $this->cache = true;                self::$overriddenDefaults['cache'] = true;            }            break;        case 'no-cache':            if (isset(self::$overriddenDefaults['cache']) === true) {                break;            }            $this->cache = false;            self::$overriddenDefaults['cache'] = true;            break;        case 'ignore-annotations':            if (isset(self::$overriddenDefaults['annotations']) === true) {                break;            }            $this->annotations = false;            self::$overriddenDefaults['annotations'] = true;            break;        case 'config-set':            if (isset($this->cliArgs[($pos + 1)]) === false                || isset($this->cliArgs[($pos + 2)]) === false            ) {                $error  = 'ERROR: Setting a config option requires a name and value'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $key     = $this->cliArgs[($pos + 1)];            $value   = $this->cliArgs[($pos + 2)];            $current = self::getConfigData($key);            try {                $this->setConfigData($key, $value);            } catch (\Exception $e) {                throw new DeepExitException($e->getMessage().PHP_EOL, 3);            }            $output = 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            if ($current === null) {                $output .= ""Config value \""$key\"" added successfully"".PHP_EOL;            } else {                $output .= ""Config value \""$key\"" updated successfully; old value was \""$current\"""".PHP_EOL;            }            throw new DeepExitException($output, 0);        case 'config-delete':            if (isset($this->cliArgs[($pos + 1)]) === false) {                $error  = 'ERROR: Deleting a config option requires the name of the option'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $output = 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            $key     = $this->cliArgs[($pos + 1)];            $current = self::getConfigData($key);            if ($current === null) {                $output .= ""Config value \""$key\"" has not been set"".PHP_EOL;            } else {                try {                    $this->setConfigData($key, null);                } catch (\Exception $e) {                    throw new DeepExitException($e->getMessage().PHP_EOL, 3);                }                $output .= ""Config value \""$key\"" removed successfully; old value was \""$current\"""".PHP_EOL;            }            throw new DeepExitException($output, 0);        case 'config-show':            ob_start();            $data = self::getAllConfigData();            echo 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            $this->printConfigData($data);            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'runtime-set':            if (isset($this->cliArgs[($pos + 1)]) === false                || isset($this->cliArgs[($pos + 2)]) === false            ) {                $error  = 'ERROR: Setting a runtime config option requires a name and value'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $key   = $this->cliArgs[($pos + 1)];            $value = $this->cliArgs[($pos + 2)];            $this->cliArgs[($pos + 1)] = '';            $this->cliArgs[($pos + 2)] = '';            self::setConfigData($key, $value, true);            if (isset(self::$overriddenDefaults['runtime-set']) === false) {                self::$overriddenDefaults['runtime-set'] = [];            }            self::$overriddenDefaults['runtime-set'][$key] = true;            break;        default:            if (substr($arg, 0, 7) === 'sniffs=') {                if (isset(self::$overriddenDefaults['sniffs']) === true) {                    break;                }                $sniffs = explode(',', substr($arg, 7));                foreach ($sniffs as $sniff) {                    if (substr_count($sniff, '.') !== 2) {                        $error  = 'ERROR: The specified sniff code ""'.$sniff.'"" is invalid'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                }                $this->sniffs = $sniffs;                self::$overriddenDefaults['sniffs'] = true;            } else if (substr($arg, 0, 8) === 'exclude=') {                if (isset(self::$overriddenDefaults['exclude']) === true) {                    break;                }                $sniffs = explode(',', substr($arg, 8));                foreach ($sniffs as $sniff) {                    if (substr_count($sniff, '.') !== 2) {                        $error  = 'ERROR: The specified sniff code ""'.$sniff.'"" is invalid'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                }                $this->exclude = $sniffs;                self::$overriddenDefaults['exclude'] = true;            } else if (defined('PHP_CODESNIFFER_IN_TESTS') === false                && substr($arg, 0, 6) === 'cache='            ) {                if ((isset(self::$overriddenDefaults['cache']) === true                    && $this->cache === false)                    || isset(self::$overriddenDefaults['cacheFile']) === true                ) {                    break;                }                // Turn caching on.                $this->cache = true;                self::$overriddenDefaults['cache'] = true;                $this->cacheFile = Util\Common::realpath(substr($arg, 6));                // It may not exist and return false instead.                if ($this->cacheFile === false) {                    $this->cacheFile = substr($arg, 6);                    $dir = dirname($this->cacheFile);                    if (is_dir($dir) === false) {                        $error  = 'ERROR: The specified cache file path ""'.$this->cacheFile.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    if ($dir === '.') {                        // Passed cache file is a file in the current directory.                        $this->cacheFile = getcwd().'/'.basename($this->cacheFile);                    } else {                        if ($dir[0] === '/') {                            // An absolute path.                            $dir = Util\Common::realpath($dir);                        } else {                            $dir = Util\Common::realpath(getcwd().'/'.$dir);                        }                        if ($dir !== false) {                            // Cache file path is relative.                            $this->cacheFile = $dir.'/'.basename($this->cacheFile);                        }                    }                }//end if                self::$overriddenDefaults['cacheFile'] = true;                if (is_dir($this->cacheFile) === true) {                    $error  = 'ERROR: The specified cache file path ""'.$this->cacheFile.'"" is a directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if (substr($arg, 0, 10) === 'bootstrap=') {                $files     = explode(',', substr($arg, 10));                $bootstrap = [];                foreach ($files as $file) {                    $path = Util\Common::realpath($file);                    if ($path === false) {                        $error  = 'ERROR: The specified bootstrap file ""'.$file.'"" does not exist'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    $bootstrap[] = $path;                }                $this->bootstrap = array_merge($this->bootstrap, $bootstrap);                self::$overriddenDefaults['bootstrap'] = true;            } else if (substr($arg, 0, 10) === 'file-list=') {                $fileList = substr($arg, 10);                $path     = Util\Common::realpath($fileList);                if ($path === false) {                    $error  = 'ERROR: The specified file list ""'.$fileList.'"" does not exist'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }                $files = file($path);                foreach ($files as $inputFile) {                    $inputFile = trim($inputFile);                    // Skip empty lines.                    if ($inputFile === '') {                        continue;                    }                    $this->processFilePath($inputFile);                }            } else if (substr($arg, 0, 11) === 'stdin-path=') {                if (isset(self::$overriddenDefaults['stdinPath']) === true) {                    break;                }                $this->stdinPath = Util\Common::realpath(substr($arg, 11));                // It may not exist and return false instead, so use whatever they gave us.                if ($this->stdinPath === false) {                    $this->stdinPath = trim(substr($arg, 11));                }                self::$overriddenDefaults['stdinPath'] = true;            } else if (PHP_CODESNIFFER_CBF === false && substr($arg, 0, 12) === 'report-file=') {                if (isset(self::$overriddenDefaults['reportFile']) === true) {                    break;                }                $this->reportFile = Util\Common::realpath(substr($arg, 12));                // It may not exist and return false instead.                if ($this->reportFile === false) {                    $this->reportFile = substr($arg, 12);                    $dir = Util\Common::realpath(dirname($this->reportFile));                    if (is_dir($dir) === false) {                        $error  = 'ERROR: The specified report file path ""'.$this->reportFile.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    $this->reportFile = $dir.'/'.basename($this->reportFile);                }//end if                self::$overriddenDefaults['reportFile'] = true;                if (is_dir($this->reportFile) === true) {                    $error  = 'ERROR: The specified report file path ""'.$this->reportFile.'"" is a directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if (substr($arg, 0, 13) === 'report-width=') {                if (isset(self::$overriddenDefaults['reportWidth']) === true) {                    break;                }                $this->reportWidth = substr($arg, 13);                self::$overriddenDefaults['reportWidth'] = true;            } else if (substr($arg, 0, 9) === 'basepath=') {                if (isset(self::$overriddenDefaults['basepath']) === true) {                    break;                }                self::$overriddenDefaults['basepath'] = true;                if (substr($arg, 9) === '') {                    $this->basepath = null;                    break;                }                $this->basepath = Util\Common::realpath(substr($arg, 9));                // It may not exist and return false instead.                if ($this->basepath === false) {                    $this->basepath = substr($arg, 9);                }                if (is_dir($this->basepath) === false) {                    $error  = 'ERROR: The specified basepath ""'.$this->basepath.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if ((substr($arg, 0, 7) === 'report=' || substr($arg, 0, 7) === 'report-')) {                $reports = [];                if ($arg[6] === '-') {                    // This is a report with file output.                    $split = strpos($arg, '=');                    if ($split === false) {                        $report = substr($arg, 7);                        $output = null;                    } else {                        $report = substr($arg, 7, ($split - 7));                        $output = substr($arg, ($split + 1));                        if ($output === false) {                            $output = null;                        } else {                            $dir = Util\Common::realpath(dirname($output));                            if (is_dir($dir) === false) {                                $error  = 'ERROR: The specified '.$report.' report file path ""'.$output.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                                $error .= $this->printShortUsage(true);                                throw new DeepExitException($error, 3);                            }                            $output = $dir.'/'.basename($output);                            if (is_dir($output) === true) {                                $error  = 'ERROR: The specified '.$report.' report file path ""'.$output.'"" is a directory'.PHP_EOL.PHP_EOL;                                $error .= $this->printShortUsage(true);                                throw new DeepExitException($error, 3);                            }                        }//end if                    }//end if                    $reports[$report] = $output;                } else {                    // This is a single report.                    if (isset(self::$overriddenDefaults['reports']) === true) {                        break;                    }                    $reportNames = explode(',', substr($arg, 7));                    foreach ($reportNames as $report) {                        $reports[$report] = null;                    }                }//end if                // Remove the default value so the CLI value overrides it.                if (isset(self::$overriddenDefaults['reports']) === false) {                    $this->reports = $reports;                } else {                    $this->reports = array_merge($this->reports, $reports);                }                self::$overriddenDefaults['reports'] = true;            } else if (substr($arg, 0, 7) === 'filter=') {                if (isset(self::$overriddenDefaults['filter']) === true) {                    break;                }                $this->filter = substr($arg, 7);                self::$overriddenDefaults['filter'] = true;            } else if (substr($arg, 0, 9) === 'standard=') {                $standards = trim(substr($arg, 9));                if ($standards !== '') {                    $this->standards = explode(',', $standards);                }                self::$overriddenDefaults['standards'] = true;            } else if (substr($arg, 0, 11) === 'extensions=') {                if (isset(self::$overriddenDefaults['extensions']) === true) {                    break;                }                $extensions    = explode(',', substr($arg, 11));                $newExtensions = [];                foreach ($extensions as $ext) {                    $slash = strpos($ext, '/');                    if ($slash !== false) {                        // They specified the tokenizer too.                        list($ext, $tokenizer) = explode('/', $ext);                        $newExtensions[$ext]   = strtoupper($tokenizer);                        continue;                    }                    if (isset($this->extensions[$ext]) === true) {                        $newExtensions[$ext] = $this->extensions[$ext];                    } else {                        $newExtensions[$ext] = 'PHP';                    }                }                $this->extensions = $newExtensions;                self::$overriddenDefaults['extensions'] = true;            } else if (substr($arg, 0, 7) === 'suffix=') {                if (isset(self::$overriddenDefaults['suffix']) === true) {                    break;                }                $this->suffix = substr($arg, 7);                self::$overriddenDefaults['suffix'] = true;            } else if (substr($arg, 0, 9) === 'parallel=') {                if (isset(self::$overriddenDefaults['parallel']) === true) {                    break;                }                $this->parallel = max((int) substr($arg, 9), 1);                self::$overriddenDefaults['parallel'] = true;            } else if (substr($arg, 0, 9) === 'severity=') {                $this->errorSeverity   = (int) substr($arg, 9);                $this->warningSeverity = $this->errorSeverity;                if (isset(self::$overriddenDefaults['errorSeverity']) === false) {                    self::$overriddenDefaults['errorSeverity'] = true;                }                if (isset(self::$overriddenDefaults['warningSeverity']) === false) {                    self::$overriddenDefaults['warningSeverity'] = true;                }            } else if (substr($arg, 0, 15) === 'error-severity=') {                if (isset(self::$overriddenDefaults['errorSeverity']) === true) {                    break;                }                $this->errorSeverity = (int) substr($arg, 15);                self::$overriddenDefaults['errorSeverity'] = true;            } else if (substr($arg, 0, 17) === 'warning-severity=') {                if (isset(self::$overriddenDefaults['warningSeverity']) === true) {                    break;                }                $this->warningSeverity = (int) substr($arg, 17);                self::$overriddenDefaults['warningSeverity'] = true;            } else if (substr($arg, 0, 7) === 'ignore=') {                if (isset(self::$overriddenDefaults['ignored']) === true) {                    break;                }                // Split the ignore string on commas, unless the comma is escaped                // using 1 or 3 slashes (\, or \\\,).                $patterns = preg_split(                    '/(?<=(?<!\\\\)\\\\\\\\),|(?<!\\\\),/',                    substr($arg, 7)                );                $ignored = [];                foreach ($patterns as $pattern) {                    $pattern = trim($pattern);                    if ($pattern === '') {                        continue;                    }                    $ignored[$pattern] = 'absolute';                }                $this->ignored = $ignored;                self::$overriddenDefaults['ignored'] = true;            } else if (substr($arg, 0, 10) === 'generator='                && PHP_CODESNIFFER_CBF === false            ) {                if (isset(self::$overriddenDefaults['generator']) === true) {                    break;                }                $this->generator = substr($arg, 10);                self::$overriddenDefaults['generator'] = true;            } else if (substr($arg, 0, 9) === 'encoding=') {                if (isset(self::$overriddenDefaults['encoding']) === true) {                    break;                }                $this->encoding = strtolower(substr($arg, 9));                self::$overriddenDefaults['encoding'] = true;            } else if (substr($arg, 0, 10) === 'tab-width=') {                if (isset(self::$overriddenDefaults['tabWidth']) === true) {                    break;                }                $this->tabWidth = (int) substr($arg, 10);                self::$overriddenDefaults['tabWidth'] = true;            } else {                if ($this->dieOnUnknownArg === false) {                    $eqPos = strpos($arg, '=');                    try {                        if ($eqPos === false) {                            $this->values[$arg] = $arg;                        } else {                            $value = substr($arg, ($eqPos + 1));                            $arg   = substr($arg, 0, $eqPos);                            $this->values[$arg] = $value;                        }                    } catch (RuntimeException $e) {                        // Value is not valid, so just ignore it.                    }                } else {                    $this->processUnknownArgument('--'.$arg, $pos);                }            }//end if            break;        }//end switch    }//end processLongArgument()",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_837, Get values of current AttributeGroup instance for the webservice.\\\\\\\\n\\\\\\\\n @return array|false|mysqli_result|PDOStatement|resource|null\\\\\\\\n,Dohvatanje vrednosti trenutne instance AttributeGroup za veb servis,"    public function getWsProductOptionValues()    {        $result = Db::getInstance()->executeS(            'SELECT a.id_attribute AS idFROM `' . _DB_PREFIX_ . 'attribute` a' . Shop::addSqlAssociation('attribute', 'a') . 'WHERE a.id_attribute_group = ' . (int) $this->id        );        return $result;    }",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_840, Get the highest AttributeGroup position.\\\\n\\\\n @return int $position Position\\\\n,Dohvatanje najviše pozicije AttributeGroup-e,    public static function getHigherPosition()    {        $sql = 'SELECT MAX(`position`)FROM `' . _DB_PREFIX_ . 'attribute_group`';        $position = Db::getInstance()->getValue($sql);        return (is_numeric($position)) ? $position : -1;    },1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attribute_826, Return true if the Attribute is a color.\n\n @return bool Color is the attribute type\n,Vrati tačno ako je atribut boja,    public function isColorAttribute()    {        if (!Db::getInstance()->getRow('SELECT `group_type`FROM `' . _DB_PREFIX_ . 'attribute_group`WHERE `id_attribute_group` = (SELECT `id_attribute_group`FROM `' . _DB_PREFIX_ . 'attribute`WHERE `id_attribute` = ' . (int) $this->id . ')AND group_type = \'color\'')) {            return false;        }        return Db::getInstance()->numRows();    },1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attribute_825, Check if the given name is an Attribute within the given AttributeGroup.\\n\\n @param int $idAttributeGroup AttributeGroup\\n @param string $name Attribute name\\n @param int $idLang Language ID\\n\\n @return array|bool\\n,Proverite da li je dato ime atribut unutar date AttributeGroup,"    public static function isAttribute($idAttributeGroup, $name, $idLang)    {        if (!Combination::isFeatureActive()) {            return [];        }        $result = Db::getInstance()->getValue('SELECT COUNT(*)FROM `' . _DB_PREFIX_ . 'attribute_group` agLEFT JOIN `' . _DB_PREFIX_ . 'attribute_group_lang` aglON (ag.`id_attribute_group` = agl.`id_attribute_group` AND agl.`id_lang` = ' . (int) $idLang . ')LEFT JOIN `' . _DB_PREFIX_ . 'attribute` aON a.`id_attribute_group` = ag.`id_attribute_group`LEFT JOIN `' . _DB_PREFIX_ . 'attribute_lang` alON (a.`id_attribute` = al.`id_attribute` AND al.`id_lang` = ' . (int) $idLang . ')' . Shop::addSqlAssociation('attribute_group', 'ag') . '' . Shop::addSqlAssociation('attribute', 'a') . 'WHERE al.`name` = \'' . pSQL($name) . '\' AND ag.`id_attribute_group` = ' . (int) $idAttributeGroup . 'ORDER BY agl.`name` ASC, a.`position` ASC');        return (int) $result > 0;    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attribute_828, Move an attribute inside its group.\n\n @param bool $direction Up (1) or Down (0)\n @param int $position Current position of the attribute\n\n @return bool Update result\n,Premestite atribut unutar njegove grupe,"    public function updatePosition($direction, $position)    {        if (!$idAttributeGroup = (int) Tools::getValue('id_attribute_group')) {            $idAttributeGroup = (int) $this->id_attribute_group;        }        $sql = 'SELECT a.`id_attribute`, a.`position`, a.`id_attribute_group`FROM `' . _DB_PREFIX_ . 'attribute` aWHERE a.`id_attribute_group` = ' . (int) $idAttributeGroup . 'ORDER BY a.`position` ASC';        if (!$res = Db::getInstance()->executeS($sql)) {            return false;        }        foreach ($res as $attribute) {            if ((int) $attribute['id_attribute'] == (int) $this->id) {                $movedAttribute = $attribute;            }        }        if (!isset($movedAttribute) || !isset($position)) {            return false;        }        // < and > statements rather than BETWEEN operator        // since BETWEEN is treated differently according to databases        $res1 = Db::getInstance()->execute(            'UPDATE `' . _DB_PREFIX_ . 'attribute`SET `position`= `position` ' . ($direction ? '- 1' : '+ 1') . 'WHERE `position`' . ($direction                ? '> ' . (int) $movedAttribute['position'] . ' AND `position` <= ' . (int) $position                : '< ' . (int) $movedAttribute['position'] . ' AND `position` >= ' . (int) $position) . 'AND `id_attribute_group`=' . (int) $movedAttribute['id_attribute_group']        );        $res2 = Db::getInstance()->execute(            'UPDATE `' . _DB_PREFIX_ . 'attribute`SET `position` = ' . (int) $position . 'WHERE `id_attribute` = ' . (int) $movedAttribute['id_attribute'] . 'AND `id_attribute_group`=' . (int) $movedAttribute['id_attribute_group']        );        return $res1 && $res2;    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_832, Deletes current AttributeGroup from database.\n\n @return bool True if delete was successful\n\n @throws PrestaShopException\n,Briše trenutnu AttributeGroup-u iz baze podataka,"    public function delete()    {        if (!$this->hasMultishopEntries() || Shop::getContext() == Shop::CONTEXT_ALL) {            /* Select children in order to find linked combinations */            $attributeIds = Db::getInstance()->executeS(                'SELECT `id_attribute`FROM `' . _DB_PREFIX_ . 'attribute`WHERE `id_attribute_group` = ' . (int) $this->id            );            if ($attributeIds === false) {                return false;            }            /* Removing attributes to the found combinations */            $toRemove = [];            foreach ($attributeIds as $attribute) {                $toRemove[] = (int) $attribute['id_attribute'];            }            if (!empty($toRemove) && Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'product_attribute_combination`WHERE `id_attribute`IN (' . implode(', ', $toRemove) . ')') === false) {                return false;            }            /* Remove combinations if they do not possess attributes anymore */            if (!AttributeGroup::cleanDeadCombinations()) {                return false;            }            /* Also delete related attributes */            if (count($toRemove)) {                if (!Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_lang`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_shop`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute` WHERE `id_attribute_group` = ' . (int) $this->id)) {                    return false;                }            }            $this->cleanPositions();        }        $return = parent::delete();        if ($return) {            Hook::exec('actionAttributeGroupDelete', ['id_attribute_group' => $this->id]);        }        return $return;    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attribute_829, get highest position.\n\n Get the highest attribute position from a group attribute\n\n @param int $idAttributeGroup AttributeGroup ID\n\n @return int $position Position\n @todo: Shouldn't this be called getHighestPosition instead?\n,Dobiti najvišu poziciju.  Dobiti najvišu poziciju atributa iz grupe atributa,    public static function getHigherPosition($idAttributeGroup)    {        $sql = 'SELECT MAX(`position`)FROM `' . _DB_PREFIX_ . 'attribute`WHERE id_attribute_group = ' . (int) $idAttributeGroup;        $position = Db::getInstance()->getValue($sql);        return (is_numeric($position)) ? $position : -1;    },1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_782, Check if Address is used (at least one order placed).\\\\n\\\\n @return int Order count for this Address\\\\n,Proverite da li se koristi adresa (bar jedna narudžbina postavljena).,    public function isUsed()    {        if ((int) $this->id <= 0) {            return false;        }        $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT COUNT(`id_order`) AS usedFROM `' . _DB_PREFIX_ . 'orders`WHERE `id_address_delivery` = ' . (int) $this->id . 'OR `id_address_invoice` = ' . (int) $this->id);        return $result > 0 ? (int) $result : false;    },1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_783, Get Country and State of this Address.\\\\n\\\\n @param int $id_address Address ID\\\\n\\\\n @return array\\\\n,Dohvata državu i adresu udržavi,"    public static function getCountryAndState($id_address)    {        if (isset(self::$_idCountries[$id_address])) {            return self::$_idCountries[$id_address];        }        if ($id_address) {            $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT `id_country`, `id_state`, `vat_number`, `postcode` FROM `' . _DB_PREFIX_ . 'address`WHERE `id_address` = ' . (int) $id_address);        } else {            $result = false;        }        self::$_idCountries[$id_address] = $result;        return $result;    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_780, Check if the Country is active for a given address.\n\n @param int $id_address Address ID for which we want to get the Country status\n\n @return int Country status\n,Proverite da li je država aktivna za datu adresu,"    public static function isCountryActiveById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        $cache_id = 'Address::isCountryActiveById_' . (int) $id_address;        if (!Cache::isStored($cache_id)) {            $result = (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT c.`active`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`WHERE a.`id_address` = ' . (int) $id_address);            Cache::store($cache_id, $result);            return $result;        }        return Cache::retrieve($cache_id);    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Combinatorics_3052, Central Binomial Coefficient\\n\\n (2n)   (2n)!\\n (  ) = ----- for n â‰¥ 0\\n (n )   (n!)Â²\\n\\n https://en.wikipedia.org/wiki/Central_binomial_coefficient\\n\\n @param  int $n\\n\\n @return float number\\n\\n @throws Exception\\\\OutOfBoundsException if n < 0\\n,Centralni binomni koeficijent,    public static function centralBinomialCoefficient(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute negative central binomial coefficient.');        }        $âŸ®2nâŸ¯ï¼ = self::factorial(2 * $n);        $âŸ®nï¼âŸ¯Â² = (self::factorial($n)) ** 2;        return $âŸ®2nâŸ¯ï¼ / $âŸ®nï¼âŸ¯Â²;    },0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3220," PMF multiplication method\n\n Evaluate binomial probabilities using a method that avoids unnecessary overflow and underflow\n Catherine Loader: http://octave.1599824.n4.nabble.com/attachment/3829107/0/loader2000Fast.pdf\n\n               x             x   n-x\n              __  n - x + i __   __\n p(x; n, p) = ||  --------- || p ||  (1 - p)\n              â±â¼Â¹     i     â±â¼Â¹  â±â¼Â¹\n\n @param int   $r number of successful events\n @param int   $n number of events\n @param float $p probability of success\n\n @return float\n",PMF metoda množenja. Procenite binomne verovatnoće pomoću metode koja izbegava nepotrebno prelivanje i podlivanje,"    private function multiplicationMethod(int $r, int $n, float $p): float    {        if (2 * $r > $n) {            return $this->multiplicationMethod($n - $r, $n, 1 - $p);        }        [$jâ‚€, $jâ‚, $jâ‚‚] = [0, 0, 0];        $f = 1;        while (($jâ‚€ < $r) | ($jâ‚ < $r) | ($jâ‚‚ < $n - $r)) {            if (($jâ‚€ < $r) && ($f < 1)) {                $jâ‚€++;                $f *= ($n - $r + $jâ‚€) / $jâ‚€;            } elseif ($jâ‚ < $r) {                $jâ‚++;                $f *= $p;            } else {                $jâ‚‚++;                $f *= 1 - $p;            }        }        return $f;    }",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Hypergeometric_3240," Cumulative distribution function\n\n           (  n  )(  N - n  )      _                           _\n           (k + 1)(K - k - 1)     | 1, k + 1 - K, k + 1 - n      |\n cdf = 1 - ------------------ â‚ƒFâ‚‚ |                          ; 1 |\n                  (N)             | k + 2, N + k + 2 - K - n     |\n                  (K)             |_                            _|\n\n N is the population size,\n K is the number of success states in the population,\n n is the number of draws,\n k is the number of observed successes,\n (a)\n (b) is a binomial coefficient.\n â‚ƒFâ‚‚ is the generalized hypergeometric function\n\n N âˆˆ {0, 1, 2, ...}\n K âˆˆ {0, 1, 2, ..., N}\n n âˆˆ {0, 1, 2, ..., N}\n k âˆˆ {max(0, n + K - N), ..., min(n, K)}\n\n @param  int $k number of observed successes\n\n @return float\n",Funkcija kumulativne raspodele,"    public function cdf(int $k): float    {        Support::checkLimits($this->support_limit, ['k' => $k]);        $N = $this->N;        $K = $this->K;        $n = $this->n;        $nCâŸ®kÂ ï¼‹Â 1âŸ¯         = Combinatorics::combinations($n, $k + 1);        $âŸ®NÂ âˆ’Â nâŸ¯CâŸ®KÂ âˆ’Â kÂ âˆ’Â 1âŸ¯ = Combinatorics::combinations(($N - $n), ($K - $k - 1));        $NCK              = Combinatorics::combinations($N, $K);        $â‚ƒFâ‚‚ = Special::generalizedHypergeometric(3, 2, 1, $k + 1 - $K, $k + 1 - $n, $k + 2, $N + $k + 2 - $K - $n, 1);        return (($nCâŸ®kÂ ï¼‹Â 1âŸ¯ * $âŸ®NÂ âˆ’Â nâŸ¯CâŸ®KÂ âˆ’Â kÂ âˆ’Â 1âŸ¯) / $NCK) * $â‚ƒFâ‚‚;    }",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Continuous_3086, Produce a random number with a particular distribution\n\n @return number\n\n @throws \\Exception\n,"Napravite slučajni broj sa određenom raspodelom
","    public function rand()    {        return $this->inverse(\random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX);    }",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Common_338, Is HTTPS?\n\n Determines if the application is accessed via an encrypted\n (HTTPS) connection.\n\n @return\tbool\n,Da li je HTTPS?  Određuje da li se aplikaciji pristupa preko šifrovane (HTTPS) veze,function is_https(){if ( ! empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off'){return TRUE;}elseif (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) === 'https'){return TRUE;}elseif ( ! empty($_SERVER['HTTP_FRONT_END_HTTPS']) && strtolower($_SERVER['HTTP_FRONT_END_HTTPS']) !== 'off'){return TRUE;}return FALSE;},0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Linear_3576," Simple linear regression - least squares method\n\n A model with a single explanatory variable.\n Fits a straight line through the set of n points in such a way that makes\n the sum of squared residuals of the model (that is, vertical distances\n between the points of the data set and the fitted line) as small as possible.\n https://en.wikipedia.org/wiki/Simple_linear_regression\n\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\n Find the equation y = mx + b\n\n      _ _   __\n      x y - xy\n m = _________\n      _     __\n     (x)Â² - xÂ²\n\n     _    _\n b = y - mx\n","Jednostavna linearna regresija - metoda najmanjih kvadrata. Model sa jednom objašnjenom promenljivom. Uklapa pravu liniju kroz skup od n tačaka na takav načinkoji pravi da zabir kvadratnih reziduala modela (tj. , vertikalne udaljenosti između tačaka skupa podataka i prave koja fituje podatke) bude što je moguće manji","class Linear extends ParametricRegression{    use Methods\LeastSquares;    use Models\LinearModel;    /**     * Average of x     * @var number     */    private $xbar;    /**     * Average of y     * @var number     */    private $ybar;    /**     * Sum of squared deviations of x     * @var number     */    private $SSx;    /**     * Sum of squares residuals     * @var number     */    private $SSres;    /**     * Calculates the regression parameters.     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     * @throws Exception\MathException     */    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs)->getColumn(0);    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_WeightedLinear_3603," Weighted linear regression - least squares method\n\n A model with a single explanatory variable.\n Fits a straight line through the set of n points in such a way that makes\n the sum of squared residuals of the model (that is, vertical distances\n between the points of the data set and the fitted line) as small as possible.\n https://en.wikipedia.org/wiki/Simple_linear_regression\n\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\n Find the equation y = mx + b\n\n","Ponderisana linearna regresija - metoda najmanjih kvadrata. Model sa jednom promenljivom objašnjenja. Uklapa se prava linija kroz skup od n tačaka na takav način da zbir kvadratnih reziduala modela (tj. , vertikalne udaljenosti između tačaka skupa podataka i ugrađene prave) bude što je moguće manji","class WeightedLinear extends ParametricRegression{    use Models\LinearModel;    use Methods\WeightedLeastSquares;    /**     * Array of weights     * @var array     */    private $ws;    /**     * @param array $points     * @param array $ws     Weights     */    public function __construct(array $points, array $ws)    {        $this->ws = $ws;        parent::__construct($points);    }    /**     * Calculates the regression parameters.     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     */    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs, $this->ws)->getColumn(0);    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PowerLaw_3590, Calculate the regression parameters by least squares on linearized data\\n ln(y) = ln(A) + B\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\MathException\\n,Izračunava parametre regresije po metodi najmanjih kvadrata na linearizovanim podacima  ln(i) = ln(A) + B,"    public function calculate(): void    {        // Linearize the relationship by taking the log of both sides.        $xâ€™ = \array_map('\log', $this->xs);        $yâ€™ = \array_map('\log', $this->ys);        // Perform Least Squares Fit        $linearized_parameters = $this->leastSquares($yâ€™, $xâ€™)->getColumn(0);        // Translate the linearized parameters back.        $this->a = \exp($linearized_parameters[0]);        $this->b = $linearized_parameters[1];        $this->parameters = [$this->a, $this->b];    }",0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LinearModel_3634, Get regression equation (y = mx + b)\n\n @param array $params\n\n @return string\n,Dobijanje regresione jednačine (y = mx + b),"    public function getModelEquation(array $params): string    {        return \sprintf('y = %fx + %f', $params[self::$M], $params[self::$B]);    }",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LinearModel_3633," Get regression parameters (coefficients)\\n m = slope\\n b = y intercept\\n\\n @param array $params\\n\\n @return array [ m => number, b => number ]\\n",Dobijanje regresionih parametara (koeficijenata) m = nagib  b = y presek,"    public function getModelParameters(array $params): array    {        return [            'm' => $params[self::$M],            'b' => $params[self::$B],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PowerModel_3640, Get regression equation (y = axáµ‡) in format y = ax^b\\n\\n @param array $params\\n\\n @return string\\n,Dobijanje regresione jednačine (y = axáµ‡) u formatu y = ax^b,"    public function getModelEquation(array $params): string    {        return \sprintf('y = %fx^%f', $params[self::$A], $params[self::$B]);    }",0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Regression_3593," Constructor - Prepares the data arrays for regression analysis\\n\\n @param array $points [ [x, y], [x, y], ... ]\\n",Konstruktor - Priprema nizove podataka za regresionu analizu,"    public function __construct(array $points)    {        $this->points = $points;        $this->n      = \count($points);        // Get list of x points and y points.        // This will be fine for linear or polynomial regression, where there is only one x,        // but if expanding to multiple linear, the format will have to change.        $this->xs = \array_map(function ($point) {            return $point[0];        }, $points);        $this->ys = \array_map(function ($point) {            return $point[1];        }, $points);    }",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_9648, Try to emit onError callback.\n\n @param int    $code\n @param string $msg\n @return void\n,Pokušava da emitujete onError povratni poziv,"    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncUdpConnection_7027, Connect.\n\n @return void\n,Konekcija,"class AsyncUdpConnection extends UdpConnection{    /**     * Emitted when socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when socket connection closed.     *     * @var callable     */    public $onClose = null;    /**     * Connected or not.     *     * @var bool     */    protected $connected = false;    /**     * Context option.     *     * @var array     */    protected $_contextOption = null;    /**     * Construct.     *     * @param string $remote_address     * @throws Exception     */    public function __construct($remote_address, $context_option = null)    {        // Get the application layer communication protocol and listening address.        list($scheme, $address) = \explode(':', $remote_address, 2);        // Check application layer protocol class.        if ($scheme !== 'udp') {            $scheme         = \ucfirst($scheme);            $this->protocol = '\\Protocols\\' . $scheme;            if (!\class_exists($this->protocol)) {                $this->protocol = ""\\Workerman\\Protocols\\$scheme"";                if (!\class_exists($this->protocol)) {                    throw new Exception(""class \\Protocols\\$scheme not exist"");                }            }        }                $this->_remoteAddress = \substr($address, 2);        $this->_contextOption = $context_option;    }        /**     * For udp package.     *     * @param resource $socket     * @return bool     */    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }    /**     * Sends data on the connection.     *     * @param string $send_buffer     * @param bool   $raw     * @return void|boolean     */    public function send($send_buffer, $raw = false)    {        if (false === $raw && $this->protocol) {            $parser      = $this->protocol;            $send_buffer = $parser::encode($send_buffer, $this);            if ($send_buffer === '') {                return;            }        }        if ($this->connected === false) {            $this->connect();        }        return \strlen($send_buffer) === \stream_socket_sendto($this->_socket, $send_buffer, 0);    }            /**     * Close connection.     *     * @param mixed $data     * @param bool $raw     *     * @return bool     */    public function close($data = null, $raw = false)    {        if ($data !== null) {            $this->send($data, $raw);        }        Worker::$globalEvent->del($this->_socket, EventInterface::EV_READ);        \fclose($this->_socket);        $this->connected = false;        // Try to emit onClose callback.        if ($this->onClose) {            try {                \call_user_func($this->onClose, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        $this->onConnect = $this->onMessage = $this->onClose = null;        return true;    }    /**     * Connect.     *     * @return void     */    public function connect()    {        if ($this->connected === true) {            return;        }        if ($this->_contextOption) {            $context = \stream_context_create($this->_contextOption);            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg,                30, \STREAM_CLIENT_CONNECT, $context);        } else {            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg);        }        if (!$this->_socket) {            Worker::safeEcho(new \Exception($errmsg));            return;        }                \stream_set_blocking($this->_socket, false);                if ($this->onMessage) {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));        }        $this->connected = true;        // Try to emit onConnect callback.        if ($this->onConnect) {            try {                \call_user_func($this->onConnect, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncUdpConnection_7782, AsyncTcpConnection.\n,Asinhrona Tcp konekcija,"class AsyncUdpConnection extends UdpConnection{    /**     * Emitted when socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when socket connection closed.     *     * @var callable     */    public $onClose = null;    /**     * Connected or not.     *     * @var bool     */    protected $connected = false;    /**     * Context option.     *     * @var array     */    protected $_contextOption = null;    /**     * Construct.     *     * @param string $remote_address     * @throws Exception     */    public function __construct($remote_address, $context_option = null)    {        // Get the application layer communication protocol and listening address.        list($scheme, $address) = \explode(':', $remote_address, 2);        // Check application layer protocol class.        if ($scheme !== 'udp') {            $scheme         = \ucfirst($scheme);            $this->protocol = '\\Protocols\\' . $scheme;            if (!\class_exists($this->protocol)) {                $this->protocol = ""\\Workerman\\Protocols\\$scheme"";                if (!\class_exists($this->protocol)) {                    throw new Exception(""class \\Protocols\\$scheme not exist"");                }            }        }                $this->_remoteAddress = \substr($address, 2);        $this->_contextOption = $context_option;    }        /**     * For udp package.     *     * @param resource $socket     * @return bool     */    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }    /**     * Sends data on the connection.     *     * @param string $send_buffer     * @param bool   $raw     * @return void|boolean     */    public function send($send_buffer, $raw = false)    {        if (false === $raw && $this->protocol) {            $parser      = $this->protocol;            $send_buffer = $parser::encode($send_buffer, $this);            if ($send_buffer === '') {                return;            }        }        if ($this->connected === false) {            $this->connect();        }        return \strlen($send_buffer) === \stream_socket_sendto($this->_socket, $send_buffer, 0);    }            /**     * Close connection.     *     * @param mixed $data     * @param bool $raw     *     * @return bool     */    public function close($data = null, $raw = false)    {        if ($data !== null) {            $this->send($data, $raw);        }        Worker::$globalEvent->del($this->_socket, EventInterface::EV_READ);        \fclose($this->_socket);        $this->connected = false;        // Try to emit onClose callback.        if ($this->onClose) {            try {                \call_user_func($this->onClose, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        $this->onConnect = $this->onMessage = $this->onClose = null;        return true;    }    /**     * Connect.     *     * @return void     */    public function connect()    {        if ($this->connected === true) {            return;        }        if ($this->_contextOption) {            $context = \stream_context_create($this->_contextOption);            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg,                30, \STREAM_CLIENT_CONNECT, $context);        } else {            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg);        }        if (!$this->_socket) {            Worker::safeEcho(new \Exception($errmsg));            return;        }                \stream_set_blocking($this->_socket, false);                if ($this->onMessage) {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));        }        $this->connected = true;        // Try to emit onConnect callback.        if ($this->onConnect) {            try {                \call_user_func($this->onConnect, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7015, Accept a connection.\n\n @param resource $socket\n @return void\n,Prihvatanje konekcije,"    public function acceptUdpConnection($socket)    {        \set_error_handler(function(){});        $recv_buffer = \stream_socket_recvfrom($socket, static::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        \restore_error_handler();        if (false === $recv_buffer || empty($remote_address)) {            return false;        }        // UdpConnection.        $connection           = new UdpConnection($socket, $remote_address);        $connection->protocol = $this->protocol;        if ($this->onMessage) {            try {                if ($this->protocol !== null) {                    /** @var \Workerman\Protocols\ProtocolInterface $parser */                    $parser = $this->protocol;                    if ($parser && \method_exists($parser, 'input')) {                        while ($recv_buffer !== '') {                            $len = $parser::input($recv_buffer, $connection);                            if ($len === 0)                                return true;                            $package = \substr($recv_buffer, 0, $len);                            $recv_buffer = \substr($recv_buffer, $len);                            $data = $parser::decode($package, $connection);                            if ($data === false)                                continue;                            \call_user_func($this->onMessage, $connection, $data);                        }                    } else {                        $data = $parser::decode($recv_buffer, $connection);                        // Discard bad packets.                        if ($data === false)                            return true;                        \call_user_func($this->onMessage, $connection, $data);                    }                } else {                    \call_user_func($this->onMessage, $connection, $recv_buffer);                }                ++ConnectionInterface::$statistics['total_request'];            } catch (\Exception $e) {                static::log($e);                exit(250);            } catch (\Error $e) {                static::log($e);                exit(250);            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_7022, Get remote URI.\n\n @return string\n,Dohvatanje udaljenog URI-ja,"    public function checkConnection()    {        // Remove EV_EXPECT for windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->del($this->_socket, EventInterface::EV_EXCEPT);        }        // Remove write listener.        Worker::$globalEvent->del($this->_socket, EventInterface::EV_WRITE);        if ($this->_status !== self::STATUS_CONNECTING) {            return;        }        // Check socket state.        if ($address = \stream_socket_get_name($this->_socket, true)) {            // Nonblocking.            \stream_set_blocking($this->_socket, false);            // Compatible with hhvm            if (\function_exists('stream_set_read_buffer')) {                \stream_set_read_buffer($this->_socket, 0);            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && $this->transport === 'tcp') {                $raw_socket = \socket_import_stream($this->_socket);                \socket_set_option($raw_socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($raw_socket, \SOL_TCP, \TCP_NODELAY, 1);            }            // SSL handshake.            if ($this->transport === 'ssl') {                $this->_sslHandshakeCompleted = $this->doSslHandshake($this->_socket);                if ($this->_sslHandshakeCompleted === false) {                    return;                }            } else {                // There are some data waiting to send.                if ($this->_sendBuffer) {                    Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'baseWrite'));                }            }            // Register a listener waiting read event.            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));            $this->_status                = self::STATUS_ESTABLISHED;            $this->_remoteAddress         = $address;            // Try to emit onConnect callback.            if ($this->onConnect) {                try {                    \call_user_func($this->onConnect, $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }            // Try to emit protocol::onConnect            if ($this->protocol && \method_exists($this->protocol, 'onConnect')) {                try {                    \call_user_func(array($this->protocol, 'onConnect'), $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }        } else {            // Connection failed.            $this->emitError(\WORKERMAN_CONNECT_FAIL, 'connect ' . $this->_remoteAddress . ' fail after ' . round(\microtime(true) - $this->_connectStartTime, 4) . ' seconds');            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7003, Write statistics data to disk.\n\n @return void\n,Upisivanje statističkih podataka na disk,"    public function listen()    {        if (!$this->_socketName) {            return;        }        // Autoload.        Autoloader::setRootPath($this->_autoloadRootPath);        if (!$this->_mainSocket) {            $local_socket = $this->parseSocketAddress();            // Flag.            $flags = $this->transport === 'udp' ? \STREAM_SERVER_BIND : \STREAM_SERVER_BIND | \STREAM_SERVER_LISTEN;            $errno = 0;            $errmsg = '';            // SO_REUSEPORT.            if ($this->reusePort) {                \stream_context_set_option($this->_context, 'socket', 'so_reuseport', 1);            }            // Create an Internet or Unix domain server socket.            $this->_mainSocket = \stream_socket_server($local_socket, $errno, $errmsg, $flags, $this->_context);            if (!$this->_mainSocket) {                throw new Exception($errmsg);            }            if ($this->transport === 'ssl') {                \stream_socket_enable_crypto($this->_mainSocket, false);            } elseif ($this->transport === 'unix') {                $socket_file = \substr($local_socket, 7);                if ($this->user) {                    \chown($socket_file, $this->user);                }                if ($this->group) {                    \chgrp($socket_file, $this->group);                }            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && static::$_builtinTransports[$this->transport] === 'tcp') {                \set_error_handler(function(){});                $socket = \socket_import_stream($this->_mainSocket);                \socket_set_option($socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($socket, \SOL_TCP, \TCP_NODELAY, 1);                \restore_error_handler();            }            // Non blocking.            \stream_set_blocking($this->_mainSocket, false);        }        $this->resumeAccept();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1633, Attempt a connection through the unix socket until it succeeds.\\\\n This is a workaround for an issue where the (hardcoded) 1s socket timeout is triggered due to a busy socket.\\\\n,Pokušaj konekcije kroz unik soket sve dok ne uspe. Ovo je rešenje za problem kod koga se pokreće (tvrdo kodirano) 1s soketa isticanje vremena zbog zauzetog soketa,"    private function tryConnect()    {        try {            $this->doConnect();        } catch (\RuntimeException $ex) {            // Failed to connect to the controller, there was probably a timeout accessing the socket...            $this->loop->addTimer(1, function () {                $this->tryConnect();            });        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncUdpConnection_7026, For udp package.\n\n @param resource $socket\n @return bool\n,Za udp paket,"    public function connect()    {        if ($this->connected === true) {            return;        }        if ($this->_contextOption) {            $context = \stream_context_create($this->_contextOption);            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg,                30, \STREAM_CLIENT_CONNECT, $context);        } else {            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg);        }        if (!$this->_socket) {            Worker::safeEcho(new \Exception($errmsg));            return;        }                \stream_set_blocking($this->_socket, false);                if ($this->onMessage) {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));        }        $this->connected = true;        // Try to emit onConnect callback.        if ($this->onConnect) {            try {                \call_user_func($this->onConnect, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7769, Get socket name.\n\n @return string\n,Dohvatiti ime soketa,"    public function stop()    {        // Try to emit onWorkerStop callback.        if ($this->onWorkerStop) {            try {                \call_user_func($this->onWorkerStop, $this);            } catch (\Exception $e) {                static::log($e);                exit(250);            } catch (\Error $e) {                static::log($e);                exit(250);            }        }        // Remove listener for server socket.        $this->unlisten();        // Close all connections for the worker.        if (!static::$_gracefulStop) {            foreach ($this->connections as $connection) {                $connection->close();            }        }        // Clear callback.        $this->onMessage = $this->onClose = $this->onError = $this->onBufferDrain = $this->onBufferFull = null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1497," Performs a check between the timeout definition and the time the process started.\\n\\n In case you run a background process (with the start method), you should\\n trigger this method regularly to ensure the process timeout\\n\\n @throws ProcessTimedOutException In case the timeout was reached\\n","Obavlja proveru između definicije vremenskog ograničenja i vremena pokretanja procesa. U slučaju da pokrenete pozadinski proces (sa metodom pokretanja), trebali biste redovno pokretati ovu metodu kako biste osigurali vremensko ograničenje procesa
","    public static function isPtySupported()    {        static $result;        if (null !== $result) {            return $result;        }        if ('\\' === \DIRECTORY_SEPARATOR) {            return $result = false;        }        return $result = (bool) @proc_open('echo 1 >/dev/null', [['pty'], ['pty'], ['pty']], $pipes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_HexadecimalToDecimal_2055, This function converts the\n submitted Decimal Number to\n Hexadecimal Number.\n\n @param string $decimalNumber\n @return string\n,Ova funkcija pretvara poslati decimalni broj u heksadecimalni broj,"function decimalToHex($decimalNumber){    $hexDigits = [];    // Mapping for HexaDecimal Digits after 9    $hexDigitMappings = [        10 => 'A',        11 => 'B',        12 => 'C',        13 => 'D',        14 => 'E',        15 => 'F',    ];    if (!is_numeric($decimalNumber)) {        throw new \Exception('Please pass a valid Decimal Number for Converting it to a Hexadecimal Number.');    }    while ($decimalNumber > 0) {        $remainder = ($decimalNumber % 16);        $decimalNumber /= 16;        if (empty($hexDigits) && 0 === $remainder) {            continue;        }        $hexDigits[] = $remainder;    }    $hexDigits = array_reverse($hexDigits);    foreach ($hexDigits as $index => $digit) {        if ($digit > 9) {            $hexDigits[$index] = $hexDigitMappings[$digit];        }    }    $hexNumber = ltrim(implode('', $hexDigits), '0'); // Connecting all the digits and removing leading zeroes.    return $hexNumber;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10278," Returns true if the string contains only hexadecimal chars, false\n otherwise.\n\n @return bool Whether or not $str contains only hexadecimal chars\n","Vraća true ako niz sadrži samo heksadecimalne znakove, false u suprotnom",    public function isHexadecimal()    {        return $this->matchesPattern('^[[:xdigit:]]*$');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Loader_378," Prepare variables for _ci_vars, to be later extract()-ed inside views\\n\\n Converts objects to associative arrays and filters-out internal\\n variable names (i.e. keys prefixed with '_ci_').\\n\\n @param\\tmixed\\t$vars\\n @return\\tarray\\n","Pripremite promenljive za _ci_vars, koje će kasnije biti ekstrahovane unutar view-a. Pretvara objekte u asocijativne nizove i filtrira unutrašnja imena promenljivih (npr. ključevi sa prefiksom '_ci_')","protected function _ci_prepare_view_vars($vars){if ( ! is_array($vars)){$vars = is_object($vars)? get_object_vars($vars): array();}foreach (array_keys($vars) as $key){if (strncmp($key, '_ci_', 4) === 0){unset($vars[$key]);}}return $vars;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_665, Convert a string to camelCase\\n @param  string $value\\n @return string\\n,Pretvorite niz u camelCase,"  private function camelCase($value)  {    $value = ucwords(str_replace(array('-', '_'), ' ', $value));    $value = str_replace(' ', '', $value);    $value[0] = strtolower($value[0]);    return $value;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Util_1553," Normalize file path, convert all slashes to Linux-style and get rid of '..', '.'.\\n\\n @param string $filePath\\n @return string|null\\n","Normalizirajte putanju do datoteke, pretvorite sve kose crte u Linuk stil i oslobodite se „..“, „.“","    public static function normalize(string $filePath): ?string    {        $filePath = realpath($filePath);        if ($filePath === false) {            return null;        }        return str_replace('\\', DIRECTORY_SEPARATOR, $filePath);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_1742," ExceptionHandler converts an exception to a Response object.\\n\\n It is mostly useful in debug mode to replace the default PHP/XDebug\\n output with something prettier and more useful.\\n\\n As this class is mainly used during Kernel boot, where nothing is yet\\n available, the Response content is always HTML.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n @author Nicolas Grekas <p@tchwork.com>\\n\\n @final since Symfony 4.3\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\ErrorHandler instead.\\n","ExceptionHandler pretvara izuzetak u Response objekat. Najčešće se koristi u debug modu kao zamena podrazumevanog PHP/XDebug izlaz nečim lepšim i korisnijim. Kako se ova klasa uglavnom koristi tokom pokretanja kernela, gde još ništa nije dostupno, sadržaj odgovora je uvek HTML","class ExceptionHandler{    private const GHOST_ADDONS = [        '02-14' => self::GHOST_HEART,        '02-29' => self::GHOST_PLUS,        '10-18' => self::GHOST_GIFT,    ];    private const GHOST_GIFT = 'M124.005 5.36c.396-.715 1.119-1.648-.124-1.873-.346-.177-.692-.492-1.038-.141-.769.303-1.435.728-.627 1.523.36.514.685 1.634 1.092 1.758.242-.417.47-.842.697-1.266zm-1.699 1.977c-.706-1.26-1.274-2.612-2.138-3.774-1.051-1.123-3.122-.622-3.593.825-.625 1.431.724 3.14 2.251 2.96 1.159.02 2.324.072 3.48-.011zm5.867.043c1.502-.202 2.365-2.092 1.51-3.347-.757-1.34-2.937-1.387-3.698-.025-.659 1.1-1.23 2.25-1.835 3.38 1.336.077 2.686.06 4.023-.008zm2.487 1.611c.512-.45 2.494-.981.993-1.409-.372-.105-.805-.59-1.14-.457-.726.902-1.842 1.432-3.007 1.376-.228.075-1.391-.114-1.077.1.822.47 1.623.979 2.474 1.395.595-.317 1.173-.667 1.757-1.005zm-11.696.255l1.314-.765c-1.338-.066-2.87.127-3.881-.95-.285-.319-.559-.684-.954-.282-.473.326-1.929.66-.808 1.058.976.576 1.945 1.167 2.946 1.701.476-.223.926-.503 1.383-.762zm6.416 2.846c.567-.456 1.942-.89 1.987-1.38-1.282-.737-2.527-1.56-3.87-2.183-.461-.175-.835.094-1.207.328-1.1.654-2.225 1.267-3.288 1.978 1.39.86 2.798 1.695 4.219 2.504.725-.407 1.44-.83 2.16-1.247zm5.692 1.423l1.765-1.114c-.005-1.244.015-2.488-.019-3.732a77.306 77.306 0 0 0-3.51 2.084c-.126 1.282-.062 2.586-.034 3.876.607-.358 1.2-.741 1.798-1.114zm-13.804-.784c.06-1.06.19-2.269-1.09-2.583-.807-.376-1.926-1.341-2.548-1.332-.02 1.195-.01 2.39-.011 3.585 1.192.744 2.364 1.524 3.582 2.226.119-.616.041-1.269.067-1.896zm8.541 4.105l2.117-1.336c-.003-1.284.05-2.57-.008-3.853-.776.223-1.662.91-2.48 1.337l-1.834 1.075c.012 1.37-.033 2.744.044 4.113.732-.427 1.443-.887 2.161-1.336zm-2.957-.72v-2.057c-1.416-.828-2.828-1.664-4.25-2.482-.078 1.311-.033 2.627-.045 3.94 1.416.887 2.817 1.798 4.25 2.655.057-.683.036-1.372.045-2.057zm8.255 2.755l1.731-1.153c-.024-1.218.06-2.453-.062-3.658-1.2.685-2.358 1.464-3.537 2.195.028 1.261-.058 2.536.072 3.786.609-.373 1.2-.777 1.796-1.17zm-13.851-.683l-.014-1.916c-1.193-.746-2.37-1.517-3.58-2.234-.076 1.224-.033 2.453-.044 3.679 1.203.796 2.392 1.614 3.61 2.385.048-.636.024-1.276.028-1.914zm8.584 4.199l2.102-1.396c-.002-1.298.024-2.596-.01-3.893-1.427.88-2.843 1.775-4.25 2.686-.158 1.253-.055 2.545-.056 3.811.437.266 1.553-.912 2.214-1.208zm-2.988-.556c-.085-.894.365-2.154-.773-2.5-1.146-.727-2.288-1.46-3.45-2.163-.17 1.228.008 2.508-.122 3.751a79.399 79.399 0 0 0 4.278 2.885c.117-.641.044-1.32.067-1.973zm-4.872-.236l-5.087-3.396c.002-3.493-.047-6.988.015-10.48.85-.524 1.753-.954 2.627-1.434-.564-1.616.25-3.58 1.887-4.184 1.372-.563 3.025-.055 3.9 1.13l1.906-.978 1.916.987c.915-1.086 2.483-1.706 3.842-1.097 1.631.573 2.52 2.532 1.936 4.145.88.497 1.837.886 2.644 1.492.036 3.473 0 6.946-.003 10.419-3.374 2.233-6.693 4.55-10.122 6.699-.997 0-1.858-1.083-2.783-1.522a735.316 735.316 0 0 1-2.678-1.781z';    private const GHOST_HEART = 'M125.914 8.305c3.036-8.71 14.933 0 0 11.2-14.932-11.2-3.036-19.91 0-11.2z';    private const GHOST_PLUS = 'M111.368 8.97h7.324V1.645h7.512v7.323h7.324v7.513h-7.324v7.323h-7.512v-7.323h-7.324z';    private $debug;    private $charset;    private $handler;    private $caughtBuffer;    private $caughtLength;    private $fileLinkFormat;    public function __construct(bool $debug = true, string $charset = null, $fileLinkFormat = null)    {        $this->debug = $debug;        $this->charset = $charset ?: ini_get('default_charset') ?: 'UTF-8';        $this->fileLinkFormat = $fileLinkFormat;    }    /**     * Registers the exception handler.     *     * @param bool        $debug          Enable/disable debug mode, where the stack trace is displayed     * @param string|null $charset        The charset used by exception messages     * @param string|null $fileLinkFormat The IDE link template     *     * @return static     */    public static function register($debug = true, $charset = null, $fileLinkFormat = null)    {        $handler = new static($debug, $charset, $fileLinkFormat);        $prev = set_exception_handler([$handler, 'handle']);        if (\is_array($prev) && $prev[0] instanceof ErrorHandler) {            restore_exception_handler();            $prev[0]->setExceptionHandler([$handler, 'handle']);        }        return $handler;    }    /**     * Sets a user exception handler.     *     * @param callable $handler An handler that will be called on Exception     *     * @return callable|null The previous exception handler if any     */    public function setHandler(callable $handler = null)    {        $old = $this->handler;        $this->handler = $handler;        return $old;    }    /**     * Sets the format for links to source files.     *     * @param string|FileLinkFormatter $fileLinkFormat The format for links to source files     *     * @return string The previous file link format     */    public function setFileLinkFormat($fileLinkFormat)    {        $old = $this->fileLinkFormat;        $this->fileLinkFormat = $fileLinkFormat;        return $old;    }    /**     * Sends a response for the given Exception.     *     * To be as fail-safe as possible, the exception is first handled     * by our simple exception handler, then by the user exception handler.     * The latter takes precedence and any output from the former is cancelled,     * if and only if nothing bad happens in this handling path.     */    public function handle(\Exception $exception)    {        if (null === $this->handler || $exception instanceof OutOfMemoryException) {            $this->sendPhpResponse($exception);            return;        }        $caughtLength = $this->caughtLength = 0;        ob_start(function ($buffer) {            $this->caughtBuffer = $buffer;            return '';        });        $this->sendPhpResponse($exception);        while (null === $this->caughtBuffer && ob_end_flush()) {            // Empty loop, everything is in the condition        }        if (isset($this->caughtBuffer[0])) {            ob_start(function ($buffer) {                if ($this->caughtLength) {                    // use substr_replace() instead of substr() for mbstring overloading resistance                    $cleanBuffer = substr_replace($buffer, '', 0, $this->caughtLength);                    if (isset($cleanBuffer[0])) {                        $buffer = $cleanBuffer;                    }                }                return $buffer;            });            echo $this->caughtBuffer;            $caughtLength = ob_get_length();        }        $this->caughtBuffer = null;        try {            ($this->handler)($exception);            $this->caughtLength = $caughtLength;        } catch (\Exception $e) {            if (!$caughtLength) {                // All handlers failed. Let PHP handle that now.                throw $exception;            }        }    }    /**     * Sends the error associated with the given Exception as a plain PHP response.     *     * This method uses plain PHP functions like header() and echo to output     * the response.     *     * @param \Throwable|FlattenException $exception A \Throwable or FlattenException instance     */    public function sendPhpResponse($exception)    {        if ($exception instanceof \Throwable) {            $exception = FlattenException::createFromThrowable($exception);        }        if (!headers_sent()) {            header(sprintf('HTTP/1.0 %s', $exception->getStatusCode()));            foreach ($exception->getHeaders() as $name => $value) {                header($name.': '.$value, false);            }            header('Content-Type: text/html; charset='.$this->charset);        }        echo $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the full HTML content associated with the given exception.     *     * @param \Exception|FlattenException $exception An \Exception or FlattenException instance     *     * @return string The HTML content as a string     */    public function getHtml($exception)    {        if (!$exception instanceof FlattenException) {            $exception = FlattenException::create($exception);        }        return $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the HTML content associated with the given exception.     *     * @return string The content as a string     */    public function getContent(FlattenException $exception)    {        switch ($exception->getStatusCode()) {            case 404:                $title = 'Sorry, the page you are looking for could not be found.';                break;            default:                $title = $this->debug ? $this->escapeHtml($exception->getMessage()) : 'Whoops, looks like something went wrong.';        }        if (!$this->debug) {            return <<<EOF                <div class=""container"">                    <h1>$title</h1>                </div>EOF;        }        $content = '';        try {            $count = \count($exception->getAllPrevious());            $total = $count + 1;            foreach ($exception->toArray() as $position => $e) {                $ind = $count - $position + 1;                $class = $this->formatClass($e['class']);                $message = nl2br($this->escapeHtml($e['message']));                $content .= sprintf(<<<'EOF'                    <div class=""trace trace-as-html"">                        <table class=""trace-details"">                            <thead class=""trace-head""><tr><th>                                <h3 class=""trace-class"">                                    <span class=""text-muted"">(%d/%d)</span>                                    <span class=""exception_title"">%s</span>                                </h3>                                <p class=""break-long-words trace-message"">%s</p>                            </th></tr></thead>                            <tbody>EOF                    , $ind, $total, $class, $message);                foreach ($e['trace'] as $trace) {                    $content .= '<tr><td>';                    if ($trace['function']) {                        $content .= sprintf('at <span class=""trace-class"">%s</span><span class=""trace-type"">%s</span><span class=""trace-method"">%s</span>', $this->formatClass($trace['class']), $trace['type'], $trace['function']);                        if (isset($trace['args'])) {                            $content .= sprintf('(<span class=""trace-arguments"">%s</span>)', $this->formatArgs($trace['args']));                        }                    }                    if (isset($trace['file']) && isset($trace['line'])) {                        $content .= $this->formatPath($trace['file'], $trace['line']);                    }                    $content .= ""</td></tr>\n"";                }                $content .= ""</tbody>\n</table>\n</div>\n"";            }        } catch (\Exception $e) {            // something nasty happened and we cannot throw an exception anymore            if ($this->debug) {                $e = FlattenException::create($e);                $title = sprintf('Exception thrown when handling an exception (%s: %s)', $e->getClass(), $this->escapeHtml($e->getMessage()));            } else {                $title = 'Whoops, looks like something went wrong.';            }        }        $symfonyGhostImageContents = $this->getSymfonyGhostAsSvg();        return <<<EOF            <div class=""exception-summary"">                <div class=""container"">                    <div class=""exception-message-wrapper"">                        <h1 class=""break-long-words exception-message"">$title</h1>                        <div class=""exception-illustration hidden-xs-down"">$symfonyGhostImageContents</div>                    </div>                </div>            </div>            <div class=""container"">                $content            </div>EOF;    }    /**     * Gets the stylesheet associated with the given exception.     *     * @return string The stylesheet as a string     */    public function getStylesheet(FlattenException $exception)    {        if (!$this->debug) {            return <<<'EOF'                body { background-color: #fff; color: #222; font: 16px/1.5 -apple-system, BlinkMacSystemFont, ""Segoe UI"", Roboto, ""Helvetica Neue"", Arial, sans-serif; margin: 0; }                .container { margin: 30px; max-width: 600px; }                h1 { color: #dc3545; font-size: 24px; }EOF;        }        return <<<'EOF'            body { background-color: #F9F9F9; color: #222; font: 14px/1.4 Helvetica, Arial, sans-serif; margin: 0; padding-bottom: 45px; }            a { cursor: pointer; text-decoration: none; }            a:hover { text-decoration: underline; }            abbr[title] { border-bottom: none; cursor: help; text-decoration: none; }            code, pre { font: 13px/1.5 Consolas, Monaco, Menlo, ""Ubuntu Mono"", ""Liberation Mono"", monospace; }            table, tr, th, td { background: #FFF; border-collapse: collapse; vertical-align: top; }            table { background: #FFF; border: 1px solid #E0E0E0; box-shadow: 0px 0px 1px rgba(128, 128, 128, .2); margin: 1em 0; width: 100%; }            table th, table td { border: solid #E0E0E0; border-width: 1px 0; padding: 8px 10px; }            table th { background-color: #E0E0E0; font-weight: bold; text-align: left; }            .hidden-xs-down { display: none; }            .block { display: block; }            .break-long-words { -ms-word-break: break-all; word-break: break-all; word-break: break-word; -webkit-hyphens: auto; -moz-hyphens: auto; hyphens: auto; }            .text-muted { color: #999; }            .container { max-width: 1024px; margin: 0 auto; padding: 0 15px; }            .container::after { content: """"; display: table; clear: both; }            .exception-summary { background: #B0413E; border-bottom: 2px solid rgba(0, 0, 0, 0.1); border-top: 1px solid rgba(0, 0, 0, .3); flex: 0 0 auto; margin-bottom: 30px; }            .exception-message-wrapper { display: flex; align-items: center; min-height: 70px; }            .exception-message { flex-grow: 1; padding: 30px 0; }            .exception-message, .exception-message a { color: #FFF; font-size: 21px; font-weight: 400; margin: 0; }            .exception-message.long { font-size: 18px; }            .exception-message a { border-bottom: 1px solid rgba(255, 255, 255, 0.5); font-size: inherit; text-decoration: none; }            .exception-message a:hover { border-bottom-color: #ffffff; }            .exception-illustration { flex-basis: 111px; flex-shrink: 0; height: 66px; margin-left: 15px; opacity: .7; }            .trace + .trace { margin-top: 30px; }            .trace-head .trace-class { color: #222; font-size: 18px; font-weight: bold; line-height: 1.3; margin: 0; position: relative; }            .trace-message { font-size: 14px; font-weight: normal; margin: .5em 0 0; }            .trace-file-path, .trace-file-path a { color: #222; margin-top: 3px; font-size: 13px; }            .trace-class { color: #B0413E; }            .trace-type { padding: 0 2px; }            .trace-method { color: #B0413E; font-weight: bold; }            .trace-arguments { color: #777; font-weight: normal; padding-left: 2px; }            @media (min-width: 575px) {                .hidden-xs-down { display: initial; }            }EOF;    }    private function decorate(string $content, string $css): string    {        return <<<EOF<!DOCTYPE html><html>    <head>        <meta charset=""{$this->charset}"" />        <meta name=""robots"" content=""noindex,nofollow"" />        <style>$css</style>    </head>    <body>        $content    </body></html>EOF;    }    private function formatClass(string $class): string    {        $parts = explode('\\', $class);        return sprintf('<abbr title=""%s"">%s</abbr>', $class, array_pop($parts));    }    private function formatPath(string $path, int $line): string    {        $file = $this->escapeHtml(preg_match('#[^/\\\\]*+$#', $path, $file) ? $file[0] : $path);        $fmt = $this->fileLinkFormat ?: ini_get('xdebug.file_link_format') ?: get_cfg_var('xdebug.file_link_format');        if (!$fmt) {            return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');        }        if (\is_string($fmt)) {            $i = strpos($f = $fmt, '&', max(strrpos($f, '%f'), strrpos($f, '%l'))) ?: \strlen($f);            $fmt = [substr($f, 0, $i)] + preg_split('/&([^>]++)>/', substr($f, $i), -1, \PREG_SPLIT_DELIM_CAPTURE);            for ($i = 1; isset($fmt[$i]); ++$i) {                if (0 === strpos($path, $k = $fmt[$i++])) {                    $path = substr_replace($path, $fmt[$i], 0, \strlen($k));                    break;                }            }            $link = strtr($fmt[0], ['%f' => $path, '%l' => $line]);        } else {            try {                $link = $fmt->format($path, $line);            } catch (\Exception $e) {                return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');            }        }        return sprintf('<span class=""block trace-file-path"">in <a href=""%s"" title=""Go to source""><strong>%s</string>%s</a></span>', $this->escapeHtml($link), $file, 0 < $line ? ' line '.$line : '');    }    /**     * Formats an array as a string.     */    private function formatArgs(array $args): string    {        $result = [];        foreach ($args as $key => $item) {            if ('object' === $item[0]) {                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));            } elseif ('array' === $item[0]) {                $formattedValue = sprintf('<em>array</em>(%s)', \is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);            } elseif ('null' === $item[0]) {                $formattedValue = '<em>null</em>';            } elseif ('boolean' === $item[0]) {                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';            } elseif ('resource' === $item[0]) {                $formattedValue = '<em>resource</em>';            } else {                $formattedValue = str_replace(""\n"", '', $this->escapeHtml(var_export($item[1], true)));            }            $result[] = \is_int($key) ? $formattedValue : sprintf(""'%s' => %s"", $this->escapeHtml($key), $formattedValue);        }        return implode(', ', $result);    }    /**     * HTML-encodes a string.     */    private function escapeHtml(string $str): string    {        return htmlspecialchars($str, \ENT_COMPAT | \ENT_SUBSTITUTE, $this->charset);    }    private function getSymfonyGhostAsSvg(): string    {        return '<svg viewBox=""0 0 136 81"" xmlns=""http://www.w3.org/2000/svg"" fill-rule=""evenodd"" clip-rule=""evenodd"" stroke-linejoin=""round"" stroke-miterlimit=""1.4""><path d=""M92.4 20.4a23.2 23.2 0 0 1 9 1.9 23.7 23.7 0 0 1 5.2 3 24.3 24.3 0 0 1 3.4 3.4 24.8 24.8 0 0 1 5 9.4c.5 1.7.8 3.4 1 5.2v14.5h.4l.5.2a7.4 7.4 0 0 0 2.5.2l.2-.2.6-.8.8-1.3-.2-.1a5.5 5.5 0 0 1-.8-.3 5.6 5.6 0 0 1-2.3-1.8 5.7 5.7 0 0 1-.9-1.6 6.5 6.5 0 0 1-.2-2.8 7.3 7.3 0 0 1 .5-2l.3-.3.8-.9.3-.3c.2-.2.5-.3.8-.3H120.7c.2 0 .3-.1.4 0h.4l.2.1.3.2.2-.4.3-.4.1-.1 1.2-1 .3-.2.4-.1.4-.1h.3l1.5.1.4.1.8.5.1.2 1 1.1v.2H129.4l.4-.2 1.4-.5h1.1c.3 0 .7.2 1 .4.2 0 .3.2.5.3l.2.2.5.3.4.6.1.3.4 1.4.1.4v.6a7.8 7.8 0 0 1-.1.6 9.9 9.9 0 0 1-.8 2.4 7.8 7.8 0 0 1-3 3.3 6.4 6.4 0 0 1-1 .5 6.1 6.1 0 0 1-.6.2l-.7.1h-.1a23.4 23.4 0 0 1-.2 1.7 14.3 14.3 0 0 1-.6 2.1l-.8 2a9.2 9.2 0 0 1-.4.6l-.7 1a9.1 9.1 0 0 1-2.3 2.2c-.9.5-2 .6-3 .7l-1.4.1h-.5l-.4.1a15.8 15.8 0 0 1-2.8-.1v4.2a9.7 9.7 0 0 1-.7 3.5 9.6 9.6 0 0 1-1.7 2.8 9.3 9.3 0 0 1-3 2.3 9 9 0 0 1-5.4.7 9 9 0 0 1-3-1 9.4 9.4 0 0 1-2.7-2.5 10 10 0 0 1-1 1.2 9.3 9.3 0 0 1-2 1.3 9 9 0 0 1-2.4 1 9 9 0 0 1-6.5-1.1A9.4 9.4 0 0 1 85 77V77a10.9 10.9 0 0 1-.6.6 9.3 9.3 0 0 1-2.7 2 9 9 0 0 1-6 .8 9 9 0 0 1-2.4-1 9.3 9.3 0 0 1-2.3-1.7 9.6 9.6 0 0 1-1.8-2.8 9.7 9.7 0 0 1-.8-3.7v-4a18.5 18.5 0 0 1-2.9.2l-1.2-.1c-1.9-.3-3.7-1-5.1-2.1A8.2 8.2 0 0 1 58 64a10.2 10.2 0 0 1-.9-1.2 15.3 15.3 0 0 1-.7-1.3 20.8 20.8 0 0 1-1.9-6.2v-.2a6.5 6.5 0 0 1-1-.3 6.1 6.1 0 0 1-.6-.3 6.6 6.6 0 0 1-.9-.5 8.2 8.2 0 0 1-2.7-3.8 10 10 0 0 1-.3-1 10.3 10.3 0 0 1-.3-1.9V47v-.4l.1-.4.6-1.4.1-.2a2 2 0 0 1 .8-.8l.3-.2.3-.2a3.2 3.2 0 0 1 1.8-.5h.4l.3.2 1.4.6.2.2.4.3.3.4.7-.7.2-.2.4-.2.6-.2h2.1l.4.2.4.2.3.2.8 1 .2-.1h.1v-.1H63l1.1.1h.3l.8.5.3.4.7 1 .2.3.1.5a11 11 0 0 1 .2 1.5c0 .8 0 1.6-.3 2.3a6 6 0 0 1-.5 1.2 5.5 5.5 0 0 1-3.3 2.5 12.3 12.3 0 0 0 1.4 3h.1l.2.1 1 .2h1.5l.5-.2H67.8l.5-.2h.1V44v-.4a26.7 26.7 0 0 1 .3-2.3 24.7 24.7 0 0 1 5.7-12.5 24.2 24.2 0 0 1 3.5-3.3 23.7 23.7 0 0 1 4.9-3 23.2 23.2 0 0 1 5.6-1.7 23.7 23.7 0 0 1 4-.3zm-.3 2a21.2 21.2 0 0 0-8 1.7 21.6 21.6 0 0 0-4.8 2.7 22.2 22.2 0 0 0-3.2 3 22.7 22.7 0 0 0-5 9.2 23.4 23.4 0 0 0-.7 4.9v15.7l-.5.1a34.3 34.3 0 0 1-1.5.3h-.2l-.4.1h-.4l-.9.2a10 10 0 0 1-1.9 0c-.5 0-1-.2-1.5-.4a1.8 1.8 0 0 1-.3-.2 2 2 0 0 1-.3-.3 5.2 5.2 0 0 1-.1-.2 9 9 0 0 1-.6-.9 13.8 13.8 0 0 1-1-2 14.3 14.3 0 0 1-.6-2 14 14 0 0 1-.1-.8v-.2h.3a12.8 12.8 0 0 0 1.4-.2 4.4 4.4 0 0 0 .3 0 3.6 3.6 0 0 0 1.1-.7 3.4 3.4 0 0 0 1.2-1.7l.2-1.2a5.1 5.1 0 0 0 0-.8 7.2 7.2 0 0 0-.1-.8l-.7-1-1.2-.2-1 .7-.1 1.3a5 5 0 0 1 .1.4v.6a1 1 0 0 1 0 .3c-.1.3-.4.4-.7.5l-1.2.4v-.7A9.9 9.9 0 0 1 60 49l.3-.6v-.2l.1-.1v-1.6l-1-1.2h-1.5l-1 1.1v.4a5.3 5.3 0 0 0-.2.6 5.5 5.5 0 0 0 0 .5c0 .7 0 1.4.3 2 0 .4.2.8.4 1.2L57 51a9.5 9.5 0 0 1-1.1-.5h-.2a2 2 0 0 1-.4-.3c-.4-.4-.5-1-.6-1.6a5.6 5.6 0 0 1 0-.5v-.5-.5l-.6-1.5-1.4-.6-.9.3s-.2 0-.3.2a2 2 0 0 1-.1 0l-.6 1.4v.7a8.5 8.5 0 0 0 .5 2c.4 1.1 1 2.1 2 2.8a4.7 4.7 0 0 0 2.1.9h1a22.8 22.8 0 0 0 .1 1 18.1 18.1 0 0 0 .8 3.8 18.2 18.2 0 0 0 1.6 3.7l1 1.3c1 1 2.3 1.6 3.7 2a11.7 11.7 0 0 0 4.8 0h.4l.5-.2.5-.1.6-.2v6.6a8 8 0 0 0 .1 1.3 7.5 7.5 0 0 0 2.4 4.3 7.2 7.2 0 0 0 2.3 1.3 7 7 0 0 0 7-1.1 7.5 7.5 0 0 0 2-2.6A7.7 7.7 0 0 0 85 72V71a8.2 8.2 0 0 0 .2 1.3c0 .7.3 1.4.6 2a7.5 7.5 0 0 0 1.7 2.3 7.3 7.3 0 0 0 2.2 1.4 7.1 7.1 0 0 0 4.6.2 7.2 7.2 0 0 0 2.4-1.2 7.5 7.5 0 0 0 2.1-2.7 7.8 7.8 0 0 0 .7-2.4V71a9.3 9.3 0 0 0 .1.6 7.6 7.6 0 0 0 .6 2.5 7.5 7.5 0 0 0 2.4 3 7.1 7.1 0 0 0 7 .8 7.3 7.3 0 0 0 2.3-1.5 7.5 7.5 0 0 0 1.6-2.3 7.6 7.6 0 0 0 .5-2l.1-1.1v-6.7l.4.1a12.2 12.2 0 0 0 2 .5 11.1 11.1 0 0 0 2.5 0h.8l1.2-.1a9.5 9.5 0 0 0 1.4-.2l.9-.3a3.5 3.5 0 0 0 .6-.4l1.2-1.4a12.2 12.2 0 0 0 .8-1.2c0-.3.2-.5.3-.7a15.9 15.9 0 0 0 .7-2l.3-1.6v-1.3l.2-.9V54.6a15.5 15.5 0 0 0 1.8 0 4.5 4.5 0 0 0 1.4-.5 5.7 5.7 0 0 0 2.5-3.2 7.6 7.6 0 0 0 .4-1.5v-.3l-.4-1.4a5.2 5.2 0 0 1-.2-.1l-.4-.4a3.8 3.8 0 0 0-.2 0 1.4 1.4 0 0 0-.5-.2l-1.4.4-.7 1.3v.7a5.7 5.7 0 0 1-.1.8l-.7 1.4a1.9 1.9 0 0 1-.5.3h-.3a9.6 9.6 0 0 1-.8.3 8.8 8.8 0 0 1-.6 0l.2-.4.2-.5.2-.3v-.4l.1-.2V50l.1-1 .1-.6v-.6a4.8 4.8 0 0 0 0-.8v-.2l-1-1.1-1.5-.2-1.1 1-.2 1.4v.1l.2.4.2.3v.4l.1 1.1v.3l.1.5v.8a9.6 9.6 0 0 1-.8-.3l-.2-.1h-.3l-.8-.1h-.2a1.6 1.6 0 0 1-.2-.2.9.9 0 0 1-.2-.2 1 1 0 0 1-.1-.5l.2-.9v-1.2l-.9-.8h-1.2l-.8.9v.3a4.8 4.8 0 0 0-.3 2l.3.9a3.5 3.5 0 0 0 1.2 1.6l1 .5.8.2 1.4.1h.4l.2.1a12.1 12.1 0 0 1-1 2.6 13.2 13.2 0 0 1-.8 1.5 9.5 9.5 0 0 1-1 1.2l-.2.3a1.7 1.7 0 0 1-.4.3 2.4 2.4 0 0 1-.7.2h-2.5a7.8 7.8 0 0 1-.6-.2l-.7-.2h-.2a14.8 14.8 0 0 1-.6-.2 23.4 23.4 0 0 1-.4-.1l-.4-.1-.3-.1V43.9a34.6 34.6 0 0 0 0-.6 23.6 23.6 0 0 0-.4-3 22.7 22.7 0 0 0-1.5-4.7 22.6 22.6 0 0 0-4.6-6.7 21.9 21.9 0 0 0-6.9-4.7 21.2 21.2 0 0 0-8.1-1.8H92zm9.1 33.7l.3.1a1 1 0 0 1 .6.8v.4a8.4 8.4 0 0 1 0 .5 8.8 8.8 0 0 1-1.6 4.2l-1 1.3A10 10 0 0 1 95 66c-1.3.3-2.7.4-4 .3a10.4 10.4 0 0 1-2.7-.8 10 10 0 0 1-3.6-2.5 9.3 9.3 0 0 1-.8-1 9 9 0 0 1-.7-1.2 8.6 8.6 0 0 1-.8-3.4V57a1 1 0 0 1 .3-.6 1 1 0 0 1 1.3-.2 1 1 0 0 1 .4.8v.4a6.5 6.5 0 0 0 .5 2.2 7 7 0 0 0 2.1 2.8l1 .6c2.6 1.6 6 1.6 8.5 0a8 8 0 0 0 1.1-.6 7.6 7.6 0 0 0 1.2-1.2 7 7 0 0 0 1-1.7 6.5 6.5 0 0 0 .4-2.5 1 1 0 0 1 .7-1h.4zM30.7 43.7c-15.5 1-28.5-6-30.1-16.4C-1.2 15.7 11.6 4 29 1.3 46.6-1.7 62.3 5.5 64 17.1c1.6 10.4-8.7 21-23.7 25a31.2 31.2 0 0 0 0 .9v.3a19 19 0 0 0 .1 1l.1.4.1.9a4.7 4.7 0 0 0 .5 1l.7 1a9.2 9.2 0 0 0 1.2 1l1.5.8.6.8-.7.6-1.1.3a11.2 11.2 0 0 1-2.6.4 8.6 8.6 0 0 1-3-.5 8.5 8.5 0 0 1-1-.4 11.2 11.2 0 0 1-1.8-1.2 13.3 13.3 0 0 1-1-1 18 18 0 0 1-.7-.6l-.4-.4a23.4 23.4 0 0 1-1.3-1.8l-.1-.1-.3-.5V45l-.3-.6v-.7zM83.1 36c3.6 0 6.5 3.2 6.5 7.1 0 4-3 7.2-6.5 7.2S76.7 47 76.7 43 79.6 36 83 36zm18 0c3.6 0 6.5 3.2 6.5 7.1 0 4-2.9 7.2-6.4 7.2S94.7 47 94.7 43s3-7.1 6.5-7.1zm-18 6.1c2 0 3.5 1.6 3.5 3.6S85 49.2 83 49.2s-3.4-1.6-3.4-3.6S81.2 42 83 42zm17.9 0c1.9 0 3.4 1.6 3.4 3.6s-1.5 3.6-3.4 3.6c-2 0-3.5-1.6-3.5-3.6S99.1 42 101 42zM17 28c-.3 1.6-1.8 5-5.2 5.8-2.5.6-4.1-.8-4.5-2.6-.4-1.9.7-3.5 2.1-4.5A3.5 3.5 0 0 1 8 24.6c-.4-2 .8-3.7 3.2-4.2 1.9-.5 3.1.2 3.4 1.5.3 1.1-.5 2.2-1.8 2.5-.9.3-1.6 0-1.7-.6a1.4 1.4 0 0 1 0-.7s.3.2 1 0c.7-.1 1-.7.9-1.2-.2-.6-1-.8-1.8-.6-1 .2-2 1-1.7 2.6.3 1 .9 1.6 1.5 1.8l.7-.2c1-.2 1.5 0 1.6.5 0 .4-.2 1-1.2 1.2a3.3 3.3 0 0 1-1.5 0c-.9.7-1.6 1.9-1.3 3.2.3 1.3 1.3 2.2 3 1.8 2.5-.7 3.8-3.7 4.2-5-.3-.5-.6-1-.7-1.6-.1-.5.1-1 .9-1.2.4 0 .7.2.8.8a2.8 2.8 0 0 1 0 1l.7 1c.6-2 1.4-4 1.7-4 .6-.2 1.5.6 1.5.6-.8.7-1.7 2.4-2.3 4.2.8.6 1.6 1 2.1 1 .5-.1.8-.6 1-1.2-.3-2.2 1-4.3 2.3-4.6.7-.2 1.3.2 1.4.8.1.5 0 1.3-.9 1.7-.2-1-.6-1.3-1-1.3-.4.1-.7 1.4-.4 2.8.2 1 .7 1.5 1.3 1.4.8-.2 1.3-1.2 1.7-2.1-.3-2.1.9-4.2 2.2-4.5.7-.2 1.2.1 1.4 1 .4 1.4-1 2.8-2.2 3.4.3.7.7 1 1.3.9 1-.3 1.6-1.5 2-2.5l-.5-3v-.3s1.6-.3 1.8.6v.1c.2-.6.7-1.2 1.3-1.4.8-.1 1.5.6 1.7 1.6.5 2.2-.5 4.4-1.8 4.7H33a31.9 31.9 0 0 0 1 5.2c-.4.1-1.8.4-2-.4l-.5-5.6c-.5 1-1.3 2.2-2.5 2.4-1 .3-1.6-.3-2-1.1-.5 1-1.3 2.1-2.4 2.4-.8.2-1.5-.1-2-1-.3.8-.9 1.5-1.5 1.7-.7.1-1.5-.3-2.4-1-.3.8-.4 1.6-.4 2.2 0 0-.7 0-.8-.4-.1-.5 0-1.5.3-2.7a10.3 10.3 0 0 1-.7-.8zm38.2-17.8l.2.9c.5 1.9.4 4.4.8 6.4 0 .6-.4 3-1.4 3.3-.2 0-.3 0-.4-.4-.1-.7 0-1.6-.3-2.6-.2-1.1-.8-1.6-1.5-1.5-.8.2-1.3 1-1.6 2l-.1-.5c-.2-1-1.8-.6-1.8-.6a6.2 6.2 0 0 1 .4 1.3l.2 1c-.2.5-.6 1-1.2 1l-.2.1a7 7 0 0 0-.1-.8c-.3-1.1-1-2-1.6-1.8a.7.7 0 0 0-.4.3c-1.3.3-2.4 2-2.1 3.9-.2.9-.6 1.7-1 1.9-.5 0-.8-.5-1.1-1.8l-.1-1.2a4 4 0 0 0 0-1.7c0-.4-.4-.7-.8-.6-.7.2-.9 1.7-.5 3.8-.2 1-.6 2-1.3 2-.4.2-.8-.2-1-1l-.2-3c1.2-.5 2-1 1.8-1.7-.1-.5-.8-.7-.8-.7s0 .7-1 1.2l-.2-1.4c-.1-.6-.4-1-1.7-.6l.4 1 .2 1.5h-1v.8c0 .3.4.3 1 .2 0 1.3 0 2.7.2 3.6.3 1.4 1.2 2 2 1.7 1-.2 1.6-1.3 2-2.3.3 1.2 1 2 1.9 1.7.7-.2 1.2-1.1 1.6-2.2.4.8 1.1 1.1 2 1 1.2-.4 1.7-1.6 1.8-2.8h.2c.6-.2 1-.6 1.3-1 0 .8 0 1.5.2 2.1.1.5.3.7.6.6.5-.1 1-.9 1-.9a4 4 0 0 1-.3-1c-.3-1.3.3-3.6 1-3.7.2 0 .3.2.5.7v.8l.2 1.5v.7c.2.7.7 1.3 1.5 1 1.3-.2 2-2.6 2.1-3.9.3.2.6.2 1 .1-.6-2.2 0-6.1-.3-7.9-.1-.4-1-.5-1.7-.5h-.4zm-21.5 12c.4 0 .7.3 1 1.1.2 1.3-.3 2.6-.9 2.8-.2 0-.7 0-1-1.2v-.4c0-1.3.4-2 1-2.2zm-5.2 1c.3 0 .6.2.6.5.2.6-.3 1.3-1.2 2-.3-1.4.1-2.3.6-2.5zm18-.4c-.5.2-1-.4-1.2-1.2-.2-1 0-2.1.7-2.5v.5c.2.7.6 1.5 1.3 1.9 0 .7-.2 1.2-.7 1.3zm10-1.6c0 .5.4.7 1 .6.8-.2 1-1 .8-1.6 0-.5-.4-1-1-.8-.5.1-1 .9-.8 1.8zm-14.3-5.5c0-.4-.5-.7-1-.5-.8.2-1 1-.9 1.5.2.6.5 1 1 .8.5 0 1.1-1 1-1.8z"" fill=""#fff"" fill-opacity="".6""/>'.$this->addElementToGhost().'</svg>';    }    private function addElementToGhost(): string    {        if (!isset(self::GHOST_ADDONS[date('m-d')])) {            return '';        }        return '<path d=""'.self::GHOST_ADDONS[date('m-d')].'"" fill=""#fff"" fill-opacity=""0.6""></path>';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidFactory_1998," Returns an RFC 4122 variant Uuid, created from the provided bytes and version\\n\\n @param string $bytes The byte string to convert to a UUID\\n @param int $version The RFC 4122 version to apply to the UUID\\n\\n @return UuidInterface An instance of UuidInterface, created from the\\n     byte string and version\\n\\n @psalm-pure\\n","Vraća RFC 4122 varijantu Uuid, kreiranu od ponuđenih bajtova i verzije","    private function uuidFromBytesAndVersion(string $bytes, int $version): UuidInterface    {        /** @var array $unpackedTime */        $unpackedTime = unpack('n*', substr($bytes, 6, 2));        $timeHi = (int) $unpackedTime[1];        $timeHiAndVersion = pack('n*', BinaryUtils::applyVersion($timeHi, $version));        /** @var array $unpackedClockSeq */        $unpackedClockSeq = unpack('n*', substr($bytes, 8, 2));        $clockSeqHi = (int) $unpackedClockSeq[1];        $clockSeqHiAndReserved = pack('n*', BinaryUtils::applyVariant($clockSeqHi));        $bytes = substr_replace($bytes, $timeHiAndVersion, 6, 2);        $bytes = substr_replace($bytes, $clockSeqHiAndReserved, 8, 2);        if ($this->isDefaultFeatureSet) {            return LazyUuidFromString::fromBytes($bytes);        }        return $this->uuid($bytes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_exporter_Exporter_1035, Exports a value into a single-line string.\n\n The output of this method is similar to the output of\n SebastianBergmann\\Exporter\\Exporter::export().\n\n Newlines are replaced by the visible string '\\n'.\n Contents of arrays and objects (if any) are replaced by '...'.\n,Izvozi vrednost u jednoredni niz. Izlaz ove metode sličan je izlazu SebastianBergmann\\Exporter\\Exporter::export(). Novi redovi se zamenjuju vidljivim stringom '\\ n'. Sadržaj nizova i objekata (ako ih ima) zamenjuje se sa '...',"    public function shortenedExport(mixed $value): string    {        if (is_string($value)) {            $string = str_replace(""\n"", '', $this->export($value));            if (function_exists('mb_strlen') && function_exists('mb_substr') && mb_strlen($string) > 40) {                return mb_substr($string, 0, 30) . '...' . mb_substr($string, -7);            }            if (strlen($string) > 40) {                return substr($string, 0, 30) . '...' . substr($string, -7);            }            return $string;        }        if (is_object($value)) {            return sprintf(                '%s Object (%s)',                get_class($value),                count($this->toArray($value)) > 0 ? '...' : ''            );        }        if (is_array($value)) {            return sprintf(                'Array (%s)',                count($value) > 0 ? '...' : ''            );        }        return $this->export($value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LOESS_3573, LOESS - Locally Weighted Scatterplot Smoothing (Local regression)\\n\\n A non-parametric method for fitting a smooth curve between two variables.\\n https://en.wikipedia.org/wiki/Local_regression\\n,LOESS - Lokalno ponderisano ujednačavanje dijagrama rasejavanja (lokalna regresija). Neparametarska metoda za uklapanje glatke krive između dve promenljive,"class LOESS extends NonParametricRegression{    use Methods\WeightedLeastSquares;    /**     * Smoothness parameter     * @var number     */    protected $Î±;    /**     * Order of the polynomial fit     * @var int     */    protected $Î»;    /**     * Number of points considered in the local regression     * @var int     */    protected $number_of_points;    /**     * @param array $points [ [x, y], [x, y], ... ]     * @param float $Î±      Smoothness parameter (bandwidth)     *                       Determines how much of the data is used to fit each local polynomial     *                       ((Î» + 1) / n, 1]     * @param int    $Î»      Order of the polynomial to fit     *     * @throws Exception\OutOfBoundsException if Î± is â‰¤ Î» + 1 or > 1     */    public function __construct($points, float $Î±, int $Î»)    {        $this->Î± = $Î±;        $this->Î» = $Î»;        parent::__construct($points);        // Î± âˆˆ ((Î» + 1) / n, 1]        if (($Î± <= ($Î» + 1) / $this->n) || $Î± > 1) {            throw new Exception\OutOfBoundsException('Smoothness parameter Î± must be between ' . ($Î» + 1) / $this->n . "" and 1; given $Î±"");        }        // Number of points considered in the local regression        $this->number_of_points = \min((int) \ceil($this->Î± * $this->n), $this->n);    }    /**     * Evaluate for x     * Use the smoothness parameter Î± to determine the subset of data to consider for     * local regression. Perform a weighted least squares regression and evaluate x.     *     * @param  float $x     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\VectorException     */    public function evaluate(float $x): float    {        $Î± = $this->Î±;        $Î» = $this->Î»;        // The number of points considered in the local regression        $Î”x    = Single::abs(Single::subtract($this->xs, $x));        $Î±áµ—Ê°Î”x = Average::kthSmallest($Î”x, $this->number_of_points - 1);        $arg   = Single::min(Single::divide($Î”x, $Î±áµ—Ê°Î”x * \max($Î±, 1)), 1);        // Kernel function: tricube = (1-argÂ³)Â³        $tricube = Single::cube(Single::multiply(Single::subtract(Single::cube($arg), 1), -1));        $weights = $tricube;        // Local Regression Parameters        $parameters = $this->leastSquares($this->ys, $this->xs, $weights, $Î»);        $X          = MatrixFactory::vandermonde([$x], $Î» + 1);        return $X->multiply($parameters)[0][0];    }}",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_947, Replace a block.\n\n @param string $blockname\n @param string $replacement\n,Zamena bloka,"    public function replaceBlock($blockname, $replacement)    {        $matches = array();        preg_match(            '/(<\?xml.*)(<w:p.*>\${' . $blockname . '}<\/w:.*?p>)(.*)(<w:p.*\${\/' . $blockname . '}<\/w:.*?p>)/is',            $this->tempDocumentMainPart,            $matches        );        if (isset($matches[3])) {            $this->tempDocumentMainPart = str_replace(                $matches[2] . $matches[3] . $matches[4],                $replacement,                $this->tempDocumentMainPart            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
erusev_parsedown_Parsedown_1872, Replace occurrences $regexp with $Elements in $text. Return an array of\n elements representing the replacement.\n,Zamenite pojave $regexp sa $Elements u $text. Vrati niz elemenata koji predstavljaju zamenu,"    protected static function pregReplaceElements($regexp, $Elements, $text)    {        $newElements = array();        while (preg_match($regexp, $text, $matches, PREG_OFFSET_CAPTURE))        {            $offset = $matches[0][1];            $before = substr($text, 0, $offset);            $after = substr($text, $offset + strlen($matches[0][0]));            $newElements[] = array('text' => $before);            foreach ($Elements as $Element)            {                $newElements[] = $Element;            }            $text = $after;        }        $newElements[] = array('text' => $text);        return $newElements;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Fixer_889, Replace the entire contents of a token.\\n\\n @param int    $stackPtr The position of the token in the token stack.\\n @param string $content  The new content of the token.\\n\\n @return bool If the change was accepted.\\n,Zamenite celokupan sadržaj tokena,"    public function replaceToken($stackPtr, $content)    {        if ($this->inConflict === true) {            return false;        }        if ($this->inChangeset === false            && isset($this->fixedTokens[$stackPtr]) === true        ) {            $indent = ""\t"";            if (empty($this->changeset) === false) {                $indent .= ""\t"";            }            if (PHP_CODESNIFFER_VERBOSITY > 1) {                @ob_end_clean();                echo ""$indent* token $stackPtr has already been modified, skipping *"".PHP_EOL;                ob_start();            }            return false;        }        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $bt = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);            if ($bt[1]['class'] === 'PHP_CodeSniffer\Fixer') {                $sniff = $bt[2]['class'];                $line  = $bt[1]['line'];            } else {                $sniff = $bt[1]['class'];                $line  = $bt[0]['line'];            }            $sniff = Util\Common::getSniffCode($sniff);            $tokens     = $this->currentFile->getTokens();            $type       = $tokens[$stackPtr]['type'];            $tokenLine  = $tokens[$stackPtr]['line'];            $oldContent = Common::prepareForOutput($this->tokens[$stackPtr]);            $newContent = Common::prepareForOutput($content);            if (trim($this->tokens[$stackPtr]) === '' && isset($this->tokens[($stackPtr + 1)]) === true) {                // Add some context for whitespace only changes.                $append      = Common::prepareForOutput($this->tokens[($stackPtr + 1)]);                $oldContent .= $append;                $newContent .= $append;            }        }//end if        if ($this->inChangeset === true) {            $this->changeset[$stackPtr] = $content;            if (PHP_CODESNIFFER_VERBOSITY > 1) {                @ob_end_clean();                echo ""\t\tQ: $sniff:$line replaced token $stackPtr ($type on line $tokenLine) \""$oldContent\"" => \""$newContent\"""".PHP_EOL;                ob_start();            }            return true;        }        if (isset($this->oldTokenValues[$stackPtr]) === false) {            $this->oldTokenValues[$stackPtr] = [                'curr' => $content,                'prev' => $this->tokens[$stackPtr],                'loop' => $this->loops,            ];        } else {            if ($this->oldTokenValues[$stackPtr]['prev'] === $content                && $this->oldTokenValues[$stackPtr]['loop'] === ($this->loops - 1)            ) {                if (PHP_CODESNIFFER_VERBOSITY > 1) {                    $indent = ""\t"";                    if (empty($this->changeset) === false) {                        $indent .= ""\t"";                    }                    $loop = $this->oldTokenValues[$stackPtr]['loop'];                    @ob_end_clean();                    echo ""$indent**** $sniff:$line has possible conflict with another sniff on loop $loop; caused by the following change ****"".PHP_EOL;                    echo ""$indent**** replaced token $stackPtr ($type on line $tokenLine) \""$oldContent\"" => \""$newContent\"" ****"".PHP_EOL;                }                if ($this->oldTokenValues[$stackPtr]['loop'] >= ($this->loops - 1)) {                    $this->inConflict = true;                    if (PHP_CODESNIFFER_VERBOSITY > 1) {                        echo ""$indent**** ignoring all changes until next loop ****"".PHP_EOL;                    }                }                if (PHP_CODESNIFFER_VERBOSITY > 1) {                    ob_start();                }                return false;            }//end if            $this->oldTokenValues[$stackPtr]['prev'] = $this->oldTokenValues[$stackPtr]['curr'];            $this->oldTokenValues[$stackPtr]['curr'] = $content;            $this->oldTokenValues[$stackPtr]['loop'] = $this->loops;        }//end if        $this->fixedTokens[$stackPtr] = $this->tokens[$stackPtr];        $this->tokens[$stackPtr]      = $content;        $this->numFixes++;        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $indent = ""\t"";            if (empty($this->changeset) === false) {                $indent .= ""\tA: "";            }            if (ob_get_level() > 0) {                ob_end_clean();            }            echo ""$indent$sniff:$line replaced token $stackPtr ($type on line $tokenLine) \""$oldContent\"" => \""$newContent\"""".PHP_EOL;            ob_start();        }        return true;    }//end replaceToken()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1547, Get a PHP manual database connection.\n\n @return \\PDO\n,Kreiranje PHP ručnog povezivanja sa bazom podataka,"    public function getManualDb()    {        if (!isset($this->manualDb)) {            $dbFile = $this->getManualDbFile();            if (\is_file($dbFile)) {                try {                    $this->manualDb = new \PDO('sqlite:'.$dbFile);                } catch (\PDOException $e) {                    if ($e->getMessage() === 'could not find driver') {                        throw new RuntimeException('SQLite PDO driver not found', 0, $e);                    } else {                        throw $e;                    }                }            }        }        return $this->manualDb;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_RedisCache_581, Redis <http://redis.io> cache backend\\n Requires phpredis native extension <https://github.com/phpredis/phpredis#installation>.\\n,Redis <http://redis.io> ke[iran bekend. Zahteva izvorni dodatak phpredis <https://github.com/phpredis/phpredis#installation>,"class RedisCache implements CacheInterface{    const KEY_PREFIX = 'botman:cache:';    /** @var Redis */    private $redis;    private $host;    private $port;    private $auth;    /**     * RedisCache constructor.     * @param $host     * @param $port     * @param $auth     */    public function __construct($host = '127.0.0.1', $port = 6379, $auth = null)    {        if (! class_exists('Redis')) {            throw new RuntimeException('phpredis extension is required for RedisCache');        }        $this->host = $host;        $this->port = $port;        $this->auth = $auth;        $this->connect();    }    /**     * Determine if an item exists in the cache.     *     * @param  string $key     * @return bool     */    public function has($key)    {        /*         * Version >= 4.0 of phpredis returns an integer instead of bool         */        $check = $this->redis->exists($this->decorateKey($key));        if (is_bool($check)) {            return $check;        }        return $check > 0;    }    /**     * Retrieve an item from the cache by key.     *     * @param  string $key     * @param  mixed $default     * @return mixed     */    public function get($key, $default = null)    {        return $this->redis->get($this->decorateKey($key)) ?: $default;    }    /**     * Retrieve an item from the cache and delete it.     *     * @param  string $key     * @param  mixed $default     * @return mixed     */    public function pull($key, $default = null)    {        $redisKey = $this->decorateKey($key);        $r = $this->redis->multi()            ->get($redisKey)            ->del($redisKey)            ->exec();        return $r[0] ?: $default;    }    /**     * Store an item in the cache.     *     * @param  string $key     * @param  mixed $value     * @param  \DateTime|int $minutes     * @return void     */    public function put($key, $value, $minutes)    {        if ($minutes instanceof \Datetime) {            $seconds = $minutes->getTimestamp() - time();        } else {            $seconds = $minutes * 60;        }        $this->redis->setex($this->decorateKey($key), $seconds, $value);    }    /**     * Namespace botman keys in redis.     *     * @param $key     * @return string     */    private function decorateKey($key)    {        return self::KEY_PREFIX.$key;    }    private function connect()    {        $this->redis = new Redis();        $this->redis->connect($this->host, $this->port);        if ($this->auth !== null) {            $this->redis->auth($this->auth);        }        if (function_exists('igbinary_serialize') && defined('Redis::SERIALIZER_IGBINARY')) {            $this->redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_IGBINARY);        } else {            $this->redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);        }    }    public function __wakeup()    {        $this->connect();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderUtils_7879," Encodes a string as a quoted string, if necessary.\n\n If a string contains characters not allowed by the ""token"" construct in\n the HTTP specification, it is backslash-escaped and enclosed in quotes\n to match the ""quoted-string"" construct.\n","Ako je potrebno, kodira niz kao citirani niz. Ako niz sadrži znakove koji nisu dozvoljeni ""token"" konstrukcijom u HTTP specifikaciji, stavlja se kosa crta u navodnike da bi se podudarao sa "" citiranim stringom"" konstrukcija","    public static function quote(string $s): string    {        if (preg_match('/^[a-z0-9!#$%&\'*.^_`|~-]+$/i', $s)) {            return $s;        }        return '""'.addcslashes($s, '""\\""').'""';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_Tag_760, Get a full URL to start a tag name and value search for this tag's values.\n,Dohvata URL do početka imena taga i pretražuje po vrednosti taj taga,    public function valueUrl(): string    {        return url('/search?term=%5B' . urlencode($this->name) .'%3D' . urlencode($this->value) . '%5D');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_2259, Formats an array as a string.\\n,Formatira niz kao string,"    private function formatArgs(array $args): string    {        $result = [];        foreach ($args as $key => $item) {            if ('object' === $item[0]) {                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));            } elseif ('array' === $item[0]) {                $formattedValue = sprintf('<em>array</em>(%s)', \is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);            } elseif ('null' === $item[0]) {                $formattedValue = '<em>null</em>';            } elseif ('boolean' === $item[0]) {                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';            } elseif ('resource' === $item[0]) {                $formattedValue = '<em>resource</em>';            } else {                $formattedValue = str_replace(""\n"", '', $this->escapeHtml(var_export($item[1], true)));            }            $result[] = \is_int($key) ? $formattedValue : sprintf(""'%s' => %s"", $this->escapeHtml($key), $formattedValue);        }        return implode(', ', $result);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_PhpExecutableFinderTest_1550, tests find() with the env var PHP_PATH.\\\\n,Testira find () sa env var PHP_PATH,"class PhpExecutableFinder{    private $executableFinder;    public function __construct()    {        $this->executableFinder = new ExecutableFinder();    }    /**     * Finds The PHP executable.     *     * @return string|false The PHP executable path or false if it cannot be found     */    public function find(bool $includeArgs = true)    {        if ($php = getenv('PHP_BINARY')) {            if (!is_executable($php)) {                $command = '\\' === \DIRECTORY_SEPARATOR ? 'where' : 'command -v';                if ($php = strtok(exec($command.' '.escapeshellarg($php)), \PHP_EOL)) {                    if (!is_executable($php)) {                        return false;                    }                } else {                    return false;                }            }            return $php;        }        $args = $this->findArguments();        $args = $includeArgs && $args ? ' '.implode(' ', $args) : '';        // PHP_BINARY return the current sapi executable        if (\PHP_BINARY && \in_array(\PHP_SAPI, ['cgi-fcgi', 'cli', 'cli-server', 'phpdbg'], true)) {            return \PHP_BINARY.$args;        }        if ($php = getenv('PHP_PATH')) {            if (!@is_executable($php)) {                return false;            }            return $php;        }        if ($php = getenv('PHP_PEAR_PHP_BIN')) {            if (@is_executable($php)) {                return $php;            }        }        if (@is_executable($php = \PHP_BINDIR.('\\' === \DIRECTORY_SEPARATOR ? '\\php.exe' : '/php'))) {            return $php;        }        $dirs = [\PHP_BINDIR];        if ('\\' === \DIRECTORY_SEPARATOR) {            $dirs[] = 'C:\xampp\php\\';        }        return $this->executableFinder->find('php', false, $dirs);    }    /**     * Finds the PHP executable arguments.     *     * @return array The PHP executable arguments     */    public function findArguments()    {        $arguments = [];        if ('phpdbg' === \PHP_SAPI) {            $arguments[] = '-qrr';        }        return $arguments;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_PhpExecutableFinder_1452, An executable finder specifically designed for the PHP executable.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Johannes M. Schmitt <schmittjoh@gmail.com>\n,Izvršni pretraživač posebno dizajniran za PHP izvršnu datoteku,"class PhpExecutableFinder{    private $executableFinder;    public function __construct()    {        $this->executableFinder = new ExecutableFinder();    }    /**     * Finds The PHP executable.     *     * @return string|false The PHP executable path or false if it cannot be found     */    public function find(bool $includeArgs = true)    {        if ($php = getenv('PHP_BINARY')) {            if (!is_executable($php)) {                $command = '\\' === \DIRECTORY_SEPARATOR ? 'where' : 'command -v';                if ($php = strtok(exec($command.' '.escapeshellarg($php)), \PHP_EOL)) {                    if (!is_executable($php)) {                        return false;                    }                } else {                    return false;                }            }            return $php;        }        $args = $this->findArguments();        $args = $includeArgs && $args ? ' '.implode(' ', $args) : '';        // PHP_BINARY return the current sapi executable        if (\PHP_BINARY && \in_array(\PHP_SAPI, ['cgi-fcgi', 'cli', 'cli-server', 'phpdbg'], true)) {            return \PHP_BINARY.$args;        }        if ($php = getenv('PHP_PATH')) {            if (!@is_executable($php)) {                return false;            }            return $php;        }        if ($php = getenv('PHP_PEAR_PHP_BIN')) {            if (@is_executable($php)) {                return $php;            }        }        if (@is_executable($php = \PHP_BINDIR.('\\' === \DIRECTORY_SEPARATOR ? '\\php.exe' : '/php'))) {            return $php;        }        $dirs = [\PHP_BINDIR];        if ('\\' === \DIRECTORY_SEPARATOR) {            $dirs[] = 'C:\xampp\php\\';        }        return $this->executableFinder->find('php', false, $dirs);    }    /**     * Finds the PHP executable arguments.     *     * @return array The PHP executable arguments     */    public function findArguments()    {        $arguments = [];        if ('phpdbg' === \PHP_SAPI) {            $arguments[] = '-qrr';        }        return $arguments;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Composer_1153, Class Composer\n @package Grav\\Common\n, Class Composer,"class Composer{    /** @const Default composer location */    const DEFAULT_PATH = 'bin/composer.phar';    /**     * Returns the location of composer.     *     * @return string     */    public static function getComposerLocation()    {        if (!function_exists('shell_exec') || stripos(PHP_OS, 'win') === 0) {            return self::DEFAULT_PATH;        }        // check for global composer install        $path = trim((string)shell_exec('command -v composer'));        // fall back to grav bundled composer        if (!$path || !preg_match('/(composer|composer\.phar)$/', $path)) {            $path = self::DEFAULT_PATH;        }        return $path;    }    /**     * Return the composer executable file path     *     * @return string     */    public static function getComposerExecutor()    {        $executor = PHP_BINARY . ' ';        $composer = static::getComposerLocation();        if ($composer !== static::DEFAULT_PATH && is_executable($composer)) {            $file = fopen($composer, 'rb');            $firstLine = fgets($file);            fclose($file);            if (!preg_match('/^#!.+php/i', $firstLine)) {                $executor = '';            }        }        return $executor . $composer;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppHelper_1360, Gets the content of an URL by using CURL or a fallback if it is not\\n installed\\n @param string $url the url that should be fetched\\n @return string the content of the webpage\\n @deprecated 8.1.0 Use \\\\OCP\\\\IServerContainer::getHTTPClientService\\n,Dobija sadržaj URL-a pomoću CURL ili otpozivanja (fallback) ako nije instaliran,public function getUrlContent($url) {try {$client = \OC::$server->getHTTPClientService()->newClient();$response = $client->get($url);return $response->getBody();} catch (\Exception $e) {return false;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_VerifyTest_694, Most of the logic for ID token validation is in AuthTest -\n this is just a general check to ensure we verify a valid\n id token if one exists.\n,Većina logike za proveru ID tokena je u AuthTest delu ovo je samo opšta provera kako bismo bili sigurni da verifikujemo važeći ID token ako postoji,"  public function testLeewayIsUnchangedWhenPassingInJwt()  {    $this->checkToken();    $jwt = $this->getJwtService();    // set arbitrary leeway so we can check this later    $jwt::$leeway = $leeway = 1.5;    $client = $this->getClient();    $token = $client->getAccessToken();    if ($client->isAccessTokenExpired()) {      $token = $client->fetchAccessTokenWithRefreshToken();    }    $segments = explode('.', $token['id_token']);    $this->assertCount(3, $segments);    // Extract the client ID in this case as it wont be set on the test client.    $data = json_decode($jwt->urlSafeB64Decode($segments[1]));    $verify = new Google_AccessToken_Verify($client->getHttpClient(), null, $jwt);    $payload = $verify->verifyIdToken($token['id_token'], $data->aud);    // verify the leeway is set as it was    $this->assertEquals($leeway, $jwt::$leeway);  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_165, Returns an element if its id is found\\n\\n @param    string  Element id to find\\n @return   HTML_QuickForm2_Node|null\\n,Vraća element ako je pronađen njegov id,    public function getElementById($id)    {        foreach ($this->getRecursiveIterator() as $element) {            if ($id == $element->getId()) {                return $element;            }        }        return null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_Iban_928, Calculates mod97 on a numeric string\n\n @param string $number Numeric string\n @return int\n,Izračunava mod97 na numeričkom nizu,"    public static function mod97($number)    {        $checksum = (int)$number[0];        for ($i = 1, $size = strlen($number); $i < $size; $i++) {            $checksum = (10 * $checksum + (int) $number[$i]) % 97;        }        return $checksum;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Frame_593, Return the border box of the frame\n\n @return array\n,Vratite granični okvir frame-a,"    public function get_border_box()    {        $style = $this->_style;        $cb = $this->_containing_block;        $x = $this->_position[""x""] + (float)$style->length_in_pt($style->margin_left, $cb[""w""]);        $y = $this->_position[""y""] + (float)$style->length_in_pt($style->margin_top, $cb[""w""]);        $w = $style->length_in_pt(            [                $style->border_left_width,                $style->padding_left,                $style->width,                $style->padding_right,                $style->border_right_width            ],            $cb[""w""]);        $h = $style->length_in_pt(            [                $style->border_top_width,                $style->padding_top,                $style->padding_bottom,                $style->border_bottom_width,                $style->length_in_pt($style->height, $cb[""h""])            ],            $cb[""w""]);        return [0 => $x, ""x"" => $x,            1 => $y, ""y"" => $y,            2 => $w, ""w"" => $w,            3 => $h, ""h"" => $h];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Browser_1454, Get the current major version identifier\n\n @return int the browser major version identifier\n,Dohvata trenutni identifikator glavne verzije,"    public function getVersion()    {        $version = explode('.', $this->getLongVersion());        return (int)$version[0];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonPeriod_317, Format the date period as ISO 8601.\\n\\n @return string\\n,Formatirajte datumski period kao ISO 8601,"    public function toIso8601String()    {        $parts = [];        if ($this->recurrences !== null) {            $parts[] = 'R'.$this->recurrences;        }        $parts[] = $this->startDate->toIso8601String();        $parts[] = $this->dateInterval->spec();        if ($this->endDate !== null) {            $parts[] = $this->endDate->toIso8601String();        }        return implode('/', $parts);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9885, Returns the Date header as a DateTime instance.\n\n @throws \\RuntimeException When the header is not parseable\n\n @final\n,Vraća zaglavlje datuma kao instancu DateTime,"    public function setDate(\DateTimeInterface $date): object    {        if ($date instanceof \DateTime) {            $date = \DateTimeImmutable::createFromMutable($date);        }        $date = $date->setTimezone(new \DateTimeZone('UTC'));        $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT');        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Cache_2474, Reads/writes to a filesystem cache\n\n @author Jordi Boggiano <j.boggiano@seld.be>\n,Čita/piše u fajl sistem keš memoriju,"class Cache{    private static $cacheCollected = null;    private $io;    private $root;    private $enabled = true;    private $allowlist;    private $filesystem;    private $readOnly;    /**     * @param IOInterface $io     * @param string      $cacheDir   location of the cache     * @param string      $allowlist  List of characters that are allowed in path names (used in a regex character class)     * @param Filesystem  $filesystem optional filesystem instance     * @param bool        $readOnly   whether the cache is in readOnly mode     */    public function __construct(IOInterface $io, $cacheDir, $allowlist = 'a-z0-9.', Filesystem $filesystem = null, $readOnly = false)    {        $this->io = $io;        $this->root = rtrim($cacheDir, '/\\') . '/';        $this->allowlist = $allowlist;        $this->filesystem = $filesystem ?: new Filesystem();        $this->readOnly = (bool) $readOnly;        if (!self::isUsable($cacheDir)) {            $this->enabled = false;            return;        }        if (            (!is_dir($this->root) && !Silencer::call('mkdir', $this->root, 0777, true))            || !is_writable($this->root)        ) {            $this->io->writeError('<warning>Cannot create cache directory ' . $this->root . ', or directory is not writable. Proceeding without cache</warning>');            $this->enabled = false;        }    }    /**     * @param bool $readOnly     */    public function setReadOnly($readOnly)    {        $this->readOnly = (bool) $readOnly;    }    /**     * @return bool     */    public function isReadOnly()    {        return $this->readOnly;    }    public static function isUsable($path)    {        return !preg_match('{(^|[\\\\/])(\$null|nul|NUL|/dev/null)([\\\\/]|$)}', $path);    }    public function isEnabled()    {        return $this->enabled;    }    public function getRoot()    {        return $this->root;    }    public function read($file)    {        if ($this->enabled) {            $file = preg_replace('{[^'.$this->allowlist.']}i', '-', $file);            if (file_exists($this->root . $file)) {                $this->io->writeError('Reading '.$this->root . $file.' from cache', true, IOInterface::DEBUG);                return file_get_contents($this->root . $file);            }        }        return false;    }    public function write($file, $contents)    {        if ($this->enabled && !$this->readOnly) {            $file = preg_replace('{[^'.$this->allowlist.']}i', '-', $file);            $this->io->writeError('Writing '.$this->root . $file.' into cache', true, IOInterface::DEBUG);            $tempFileName = $this->root . $file . uniqid('.', true) . '.tmp';            try {                return file_put_contents($tempFileName, $contents) !== false && rename($tempFileName, $this->root . $file);            } catch (\ErrorException $e) {                $this->io->writeError('<warning>Failed to write into cache: '.$e->getMessage().'</warning>', true, IOInterface::DEBUG);                if (preg_match('{^file_put_contents\(\): Only ([0-9]+) of ([0-9]+) bytes written}', $e->getMessage(), $m)) {                    // Remove partial file.                    unlink($tempFileName);                    $message = sprintf(                        '<warning>Writing %1$s into cache failed after %2$u of %3$u bytes written, only %4$u bytes of free space available</warning>',                        $tempFileName,                        $m[1],                        $m[2],                        @disk_free_space(dirname($tempFileName))                    );                    $this->io->writeError($message);                    return false;                }                throw $e;            }        }        return false;    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_FrameCollection_9359," Filters frames using a callable, returns the same FrameCollection\n\n @param  callable        $callable\n @return FrameCollection\n","Filtrira frejmove koristeći pozivnu promenjivu, vraća isti FrameCollection","    public function filter($callable)    {        $this->frames = array_values(array_filter($this->frames, $callable));        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_589, Filter function to access internal integer font values\\\\n\\\\n @return int\\\\n,Funkcija filtriranja za pristup unutrašnjim celobrojnim font vrednostima,"    private function getInternalFont()    {        $internalfont = is_null($this->file) ? 1 : $this->file;        $internalfont = is_numeric($internalfont) ? $internalfont : false;        if ( ! in_array($internalfont, [1, 2, 3, 4, 5])) {            throw new NotSupportedException(                sprintf('Internal GD font (%s) not available. Use only 1-5.', $internalfont)            );        }        return intval($internalfont);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1558, Return filters for processing lines from safe universal phalcon.c\n\n @return array\n,Vraća filtere za linije za obradu iz sigurnog univerzalnog phalcon.c,"    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_ExcludeDirectoryFilterIterator_1141," Filters the iterator values.\n\n @return bool True if the value should be kept, false otherwise\n",Filtrira vrednosti iteratora,"    public function accept()    {        if ($this->isRecursive && isset($this->excludedDirs[$this->getFilename()]) && $this->isDir()) {            return false;        }        if ($this->excludedPattern) {            $path = $this->isDir() ? $this->current()->getRelativePathname() : $this->current()->getRelativePath();            $path = str_replace('\\', '/', $path);            return !preg_match($this->excludedPattern, $path);        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_8732, Filters items on their value using given regex.\n\n @return self\n,Filtrira stavke prema njihovoj vrednosti pomoću datog regularnog izraza,"    public function filter(string $pattern)    {        return new self(array_filter($this->items, function (AcceptHeaderItem $item) use ($pattern) {            return preg_match($pattern, $item->getValue());        }));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_ActivityService_742, Filters out similar activity.\n @param Activity[] $activities\n @return array\n,Filtrira slične aktivnosti,    protected function filterSimilar(iterable $activities): array    {        $newActivity = [];        $previousItem = null;        foreach ($activities as $activityItem) {            if (!$previousItem || !$activityItem->isSimilarTo($previousItem)) {                $newActivity[] = $activityItem;            }            $previousItem = $activityItem;        }        return $newActivity;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonPeriod_278, Parse given ISO 8601 string into an array of arguments.\\n\\n @SuppressWarnings(PHPMD.ElseExpression)\\n\\n @param string $iso\\n\\n @return array\\n,Analizirajte dati ISO 8601 string u niz argumenata,"    protected static function parseIso8601($iso)    {        $result = [];        $interval = null;        $start = null;        $end = null;        foreach (explode('/', $iso) as $key => $part) {            if ($key === 0 && preg_match('/^R([0-9]*)$/', $part, $match)) {                $parsed = \strlen($match[1]) ? (int) $match[1] : null;            } elseif ($interval === null && $parsed = CarbonInterval::make($part)) {                $interval = $part;            } elseif ($start === null && $parsed = Carbon::make($part)) {                $start = $part;            } elseif ($end === null && $parsed = Carbon::make(static::addMissingParts($start ?? '', $part))) {                $end = $part;            } else {                throw new InvalidPeriodParameterException(""Invalid ISO 8601 specification: $iso."");            }            $result[] = $parsed;        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_generate-api-docs_2099, Read the file and parse it\n,Pročitajte datoteku i raščlanite,"function processDocument(string $file): array{    $return   = [];    $contents = file_get_contents($file);    $parse    = zephir_parse_file($contents, '(eval code)');    foreach ($parse as $item) {        $type = $item['type'] ?? '';        if ('namespace' === $type) {            $return['namespace'] = $item['name'];            continue;        }        if ('comment' === $type) {            $return['comment'] = getDocblockMethod($item['value']);            continue;        }        if ('use' === $type) {            $uses    = $return['uses'] ?? [];            $aliases = $item['aliases'];            foreach ($aliases as $alias) {                $uses[] = $alias['name'];            }            $return['uses'] = $uses;        }        if ('class' === $type || 'interface' === $type) {            $signature = '';            if (1 === ($item['final'] ?? 0)) {                $signature .= ' Final';            }            if (1 === ($item['abstract'] ?? 0)) {                $signature .= ' Abstract';            }            $signature           .= ('class' === $type) ? ' Class ' : ' Interface ';            $signature           .= $return['namespace'] . '\\' . $item['name'];            $return['signature'] = ltrim($signature);            //$return['signature'] = ltrim(str_replace('Phalcon\\', '', $signature));            $return['extends'] = $item['extends'] ?? '';            if (true === is_array($return['extends'])) {                $return['extends'] = $return['extends'][0]['value'];            }            $implements = $item['implements'] ?? [];            if (count($implements) > 0) {                foreach ($implements as $implement) {                    $return['implements'][] = $implement['value'];                }            }            $definition           = $item['definition'] ?? [];            $return['constants']  = parseConstants($definition);            $return['properties'] = parseProperties($definition);            $return['methods']    = parseMethods($definition);        }    }    return $return;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_439, Get current ordered number\\\\\\\\n\\\\\\\\n @return int\\\\\\\\n,Dobijte trenutni naručeni broj,    public function mockery_getCurrentOrder()    {        return $this->_currentOrder;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2087, Get current url.\\n\\n @return string\\n,Preuzmi trenutni url,    public function getUrl(): string    {        if ($this->url) {            return $this->url;        }        return Support\current_url();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AdminAccessController_861," Get the current profile id.\n\n @return int the $_GET['profile'] if valid, else 1 (the first profile id)\n",Preuzmi trenutni profil,    public function getCurrentProfileId()    {        return (isset($_GET['id_profile']) && !empty($_GET['id_profile']) && is_numeric($_GET['id_profile'])) ? (int) $_GET['id_profile'] : 1;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_453, Processes and returns encoded image as data-url string\n\n @return string\n,Obrađuje i vraća kodiranu sliku kao data-url string,"    protected function processDataUrl()    {        $mime = $this->image->mime ? $this->image->mime : 'image/png';        return sprintf('data:%s;base64,%s',            $mime,            base64_encode($this->process($this->image, $mime, $this->quality))        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Cookie_7839, Creates a cookie copy with a new value.\n\n @return static\n,Stvara kopiju kolačića sa novom vrednošću,    public function withValue(?string $value): self    {        $cookie = clone $this;        $cookie->value = $value;        return $cookie;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Cookie_9709, Creates a cookie copy with a new path on the server in which the cookie will be available on.\n\n @return static\n,Stvara kopiju kolačića sa novom putanjom na serveru na kojem će kolačić biti dostupan,    public function withPath(string $path): self    {        $cookie = clone $this;        $cookie->path = '' === $path ? '/' : $path;        return $cookie;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Cookie_9711, Returns the cookie as a string.\n\n @return string The cookie\n,Vraća kolačić kao string,"    public function __toString()    {        if ($this->isRaw()) {            $str = $this->getName();        } else {            $str = str_replace(self::RESERVED_CHARS_FROM, self::RESERVED_CHARS_TO, $this->getName());        }        $str .= '=';        if ('' === (string) $this->getValue()) {            $str .= 'deleted; expires='.gmdate('D, d-M-Y H:i:s T', time() - 31536001).'; Max-Age=0';        } else {            $str .= $this->isRaw() ? $this->getValue() : rawurlencode($this->getValue());            if (0 !== $this->getExpiresTime()) {                $str .= '; expires='.gmdate('D, d-M-Y H:i:s T', $this->getExpiresTime()).'; Max-Age='.$this->getMaxAge();            }        }        if ($this->getPath()) {            $str .= '; path='.$this->getPath();        }        if ($this->getDomain()) {            $str .= '; domain='.$this->getDomain();        }        if (true === $this->isSecure()) {            $str .= '; secure';        }        if (true === $this->isHttpOnly()) {            $str .= '; httponly';        }        if (null !== $this->getSameSite()) {            $str .= '; samesite='.$this->getSameSite();        }        return $str;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Middleware_1084, Middleware that adds cookies to requests.\n\n The options array must be set to a CookieJarInterface in order to use\n cookies. This is typically handled for you by a client.\n\n @return callable Returns a function that accepts the next handler.\n,Međuprogrami koji dodaju kolačiće zahtevima. Niz opcija mora biti postavljeno na CookieJarInterface da bi se koristilo kolačiće. Ovo za vas obično rešava klijent,"    public static function cookies(): callable    {        return static function (callable $handler): callable {            return static function ($request, array $options) use ($handler) {                if (empty($options['cookies'])) {                    return $handler($request, $options);                } elseif (!($options['cookies'] instanceof CookieJarInterface)) {                    throw new \InvalidArgumentException('cookies must be an instance of GuzzleHttp\Cookie\CookieJarInterface');                }                $cookieJar = $options['cookies'];                $request = $cookieJar->withCookieHeader($request);                return $handler($request, $options)                    ->then(                        static function (ResponseInterface $response) use ($cookieJar, $request): ResponseInterface {                            $cookieJar->extractCookies($request, $response);                            return $response;                        }                    );            };        };    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3410, Remove an element from the set\\n Does nothing if the element does not exist in the set.\\n\\n @param  mixed $x\\n\\n @return Set (this set)\\n,Uklonite element iz skupa. Ne radi ništa ako element ne postoji u skupu,    public function remove($x): Set    {        unset($this->A[$this->getKey($x)]);        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3411, Remove elements from the set\n Does nothing if the element does not exist in the set.\n\n @param  array $x\n\n @return Set (this set)\n,Ukloni elemente iz skupa. Ne čini ništa ako element ne postoji u skupu,    public function removeMulti(array $x): Set    {        foreach ($x as $member) {            unset($this->A[$this->getKey($member)]);        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Frame_7485," Unserializes the frame data, while also preserving\n any existing comment data.\n\n @see Serializable::unserialize\n @param string $serializedFrame\n","Neserijalizuje podatke okvira, istovremeno zadržavajući sve postojeće podatke komentara",    public function unserialize($serializedFrame)    {        $frame = unserialize($serializedFrame);        if (!empty($frame['_comments'])) {            $this->comments = $frame['_comments'];            unset($frame['_comments']);        }        $this->frame = $frame;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_FrameCollection_7120, Gets the innermost part of stack trace that is not the same as that of outer exception\n\n @param  FrameCollection $parentFrames Outer exception frames to compare tail against\n @return Frame[]\n,Dobiva unutrašnji deo traga steka koji nije isti kao onaj spoljnog izuzetka,    public function topDiff(FrameCollection $parentFrames)    {        $diff = $this->frames;        $parentFrames = $parentFrames->getArray();        $p = count($parentFrames)-1;        for ($i = count($diff)-1; $i >= 0 && $p >= 0; $i--) {            /** @var Frame $tailFrame */            $tailFrame = $diff[$i];            if ($tailFrame->equals($parentFrames[$p])) {                unset($diff[$i]);            }            $p--;        }        return $diff;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_RowEvolution_983," Given the Row evolution dataTable, and the associated metadata,\n enriches the metadata with min/max values, and % change between the first period and the last one\n @param array $metadata\n @param DataTable\\Map $dataTable\n","S datim redom dataTable i povezanim metapodacima, obogaćuje metapodatke min/max vrednostima i % promena između prvog i poslednjeg perioda","    private function enhanceRowEvolutionMetaData(&$metadata, $dataTable)    {        // prepare result array for metrics        $metricsResult = array();        foreach ($metadata['metrics'] as $metric => $name) {            $metricsResult[$metric] = array('name' => $name);            if (!empty($metadata['logos'][$metric])) {                $metricsResult[$metric]['logo'] = $metadata['logos'][$metric];            }        }        unset($metadata['logos']);        $subDataTables = $dataTable->getDataTables();        if (empty($subDataTables)) {            throw new \Exception(""Unexpected state: row evolution API call returned empty DataTable\\Map."");        }        $firstDataTable = reset($subDataTables);        $this->checkDataTableInstance($firstDataTable);        $firstDataTableRow = $firstDataTable->getFirstRow();        $lastDataTable = end($subDataTables);        $this->checkDataTableInstance($lastDataTable);        $lastDataTableRow = $lastDataTable->getFirstRow();        // Process min/max values        $firstNonZeroFound = array();        foreach ($subDataTables as $subDataTable) {            // $subDataTable is the report for one period, it has only one row            $firstRow = $subDataTable->getFirstRow();            foreach ($metadata['metrics'] as $metric => $label) {                $value = $firstRow ? floatval($firstRow->getColumn($metric)) : 0;                if ($value > 0) {                    $firstNonZeroFound[$metric] = true;                } else if (!isset($firstNonZeroFound[$metric])) {                    continue;                }                if (!isset($metricsResult[$metric]['min'])                    || $metricsResult[$metric]['min'] > $value                ) {                    $metricsResult[$metric]['min'] = $value;                }                if (!isset($metricsResult[$metric]['max'])                    || $metricsResult[$metric]['max'] < $value                ) {                    $metricsResult[$metric]['max'] = $value;                }            }        }        // Process % change between first/last values        foreach ($metadata['metrics'] as $metric => $label) {            $first = $firstDataTableRow ? floatval($firstDataTableRow->getColumn($metric)) : 0;            $last = $lastDataTableRow ? floatval($lastDataTableRow->getColumn($metric)) : 0;            // do not calculate evolution if the first value is 0 (to avoid divide-by-zero)            if ($first == 0) {                continue;            }            $change = CalculateEvolutionFilter::calculate($last, $first, $quotientPrecision = 0, true, true);            $metricsResult[$metric]['change'] = $change;        }        $metadata['metrics'] = $metricsResult;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_657, Initialize this object's properties from an array.\\\\\\\\n\\\\\\\\n @param array $array Used to seed this object's properties.\\\\\\\\n @return void\\\\\\\\n,Inicijalizuje svojstva objekta iz niza,"  protected function mapTypes($array)  {    // Hard initialise simple types, lazy load more complex ones.    foreach ($array as $key => $val) {      if ($keyType = $this->keyType($key)) {        $dataType = $this->dataType($key);        if ($dataType == 'array' || $dataType == 'map') {          $this->$key = array();          foreach ($val as $itemKey => $itemVal) {            if ($itemVal instanceof $keyType) {              $this->{$key}[$itemKey] = $itemVal;            } else {              $this->{$key}[$itemKey] = new $keyType($itemVal);            }          }        } elseif ($val instanceof $keyType) {          $this->$key = $val;        } else {          $this->$key = new $keyType($val);        }        unset($array[$key]);      } elseif (property_exists($this, $key)) {          $this->$key = $val;          unset($array[$key]);      } elseif (property_exists($this, $camelKey = $this->camelCase($key))) {          // This checks if property exists as camelCase, leaving it in array as snake_case          // in case of backwards compatibility issues.          $this->$camelKey = $val;      }    }    $this->modelData = $array;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_865, Unset the value of an inaccessible property.\n\n @param string $name The name of the property.\n\n @return void\n,"Poništite vrednost nepristupačnog svojstva
",    public function __unset($name)    {        $this->settings[$name] = null;    }//end __unset(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_SymfonyRequirements_2453, This class specifies all requirements and optional recommendations that\n are necessary to run the Symfony Standard Edition.\n\n @author Tobias Schultze <http://tobion.de>\n @author Fabien Potencier <fabien@symfony.com>\n,Ova klasa navodi sve zahteve i opcionalne preporuke koji su potrebni za pokretanje Symfony Standard Edition,"class SymfonyRequirements extends RequirementCollection{    const LEGACY_REQUIRED_PHP_VERSION = '5.3.3';    const REQUIRED_PHP_VERSION = '5.5.9';    /**     * Constructor that initializes the requirements.     */    public function __construct()    {        /* mandatory requirements follow */        $installedPhpVersion = PHP_VERSION;        $requiredPhpVersion = $this->getPhpRequiredVersion();        $this->addRecommendation(            $requiredPhpVersion,            'Vendors should be installed in order to check all requirements.',            'Run the <code>composer install</code> command.',            'Run the ""composer install"" command.'        );        if (false !== $requiredPhpVersion) {            $this->addRequirement(                version_compare($installedPhpVersion, $requiredPhpVersion, '>='),                sprintf('PHP version must be at least %s (%s installed)', $requiredPhpVersion, $installedPhpVersion),                sprintf('You are running PHP version ""<strong>%s</strong>"", but Symfony needs at least PHP ""<strong>%s</strong>"" to run.                Before using Symfony, upgrade your PHP installation, preferably to the latest version.',                    $installedPhpVersion, $requiredPhpVersion),                sprintf('Install PHP %s or newer (installed version is %s)', $requiredPhpVersion, $installedPhpVersion)            );        }        $this->addRequirement(            version_compare($installedPhpVersion, '5.3.16', '!='),            'PHP version must not be 5.3.16 as Symfony won\'t work properly with it',            'Install PHP 5.3.17 or newer (or downgrade to an earlier PHP version)'        );        $this->addRequirement(            is_dir(__DIR__.'/../vendor/composer'),            'Vendor libraries must be installed',            'Vendor libraries are missing. Install composer following instructions from <a href=""http://getcomposer.org/"">http://getcomposer.org/</a>. '.                'Then run ""<strong>php composer.phar install</strong>"" to install them.'        );        $cacheDir = is_dir(__DIR__.'/../var/cache') ? __DIR__.'/../var/cache' : __DIR__.'/cache';        $this->addRequirement(            is_writable($cacheDir),            'app/cache/ or var/cache/ directory must be writable',            'Change the permissions of either ""<strong>app/cache/</strong>"" or  ""<strong>var/cache/</strong>"" directory so that the web server can write into it.'        );        $logsDir = is_dir(__DIR__.'/../var/logs') ? __DIR__.'/../var/logs' : __DIR__.'/logs';        $this->addRequirement(            is_writable($logsDir),            'app/logs/ or var/logs/ directory must be writable',            'Change the permissions of either ""<strong>app/logs/</strong>"" or  ""<strong>var/logs/</strong>"" directory so that the web server can write into it.'        );        if (version_compare($installedPhpVersion, '7.0.0', '<')) {            $this->addPhpIniRequirement(                'date.timezone', true, false,                'date.timezone setting must be set',                'Set the ""<strong>date.timezone</strong>"" setting in php.ini<a href=""#phpini"">*</a> (like Europe/Paris).'            );        }        if (false !== $requiredPhpVersion && version_compare($installedPhpVersion, $requiredPhpVersion, '>=')) {            $this->addRequirement(                in_array(@date_default_timezone_get(), DateTimeZone::listIdentifiers(), true),                sprintf('Configured default timezone ""%s"" must be supported by your installation of PHP', @date_default_timezone_get()),                'Your default timezone is not supported by PHP. Check for typos in your <strong>php.ini</strong> file and have a look at the list of deprecated timezones at <a href=""http://php.net/manual/en/timezones.others.php"">http://php.net/manual/en/timezones.others.php</a>.'            );        }        $this->addRequirement(            function_exists('iconv'),            'iconv() must be available',            'Install and enable the <strong>iconv</strong> extension.'        );        $this->addRequirement(            function_exists('json_encode'),            'json_encode() must be available',            'Install and enable the <strong>JSON</strong> extension.'        );        $this->addRequirement(            function_exists('session_start'),            'session_start() must be available',            'Install and enable the <strong>session</strong> extension.'        );        $this->addRequirement(            function_exists('ctype_alpha'),            'ctype_alpha() must be available',            'Install and enable the <strong>ctype</strong> extension.'        );        $this->addRequirement(            function_exists('token_get_all'),            'token_get_all() must be available',            'Install and enable the <strong>Tokenizer</strong> extension.'        );        $this->addRequirement(            function_exists('simplexml_import_dom'),            'simplexml_import_dom() must be available',            'Install and enable the <strong>SimpleXML</strong> extension.'        );        if (function_exists('apc_store') && ini_get('apc.enabled')) {            if (version_compare($installedPhpVersion, '5.4.0', '>=')) {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.1.13', '>='),                    'APC version must be at least 3.1.13 when using PHP 5.4',                    'Upgrade your <strong>APC</strong> extension (3.1.13+).'                );            } else {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.0.17', '>='),                    'APC version must be at least 3.0.17',                    'Upgrade your <strong>APC</strong> extension (3.0.17+).'                );            }        }        $this->addPhpIniRequirement('detect_unicode', false);        if (extension_loaded('suhosin')) {            $this->addPhpIniRequirement(                'suhosin.executor.include.whitelist',                create_function('$cfgValue', 'return false !== stripos($cfgValue, ""phar"");'),                false,                'suhosin.executor.include.whitelist must be configured correctly in php.ini',                'Add ""<strong>phar</strong>"" to <strong>suhosin.executor.include.whitelist</strong> in php.ini<a href=""#phpini"">*</a>.'            );        }        if (extension_loaded('xdebug')) {            $this->addPhpIniRequirement(                'xdebug.show_exception_trace', false, true            );            $this->addPhpIniRequirement(                'xdebug.scream', false, true            );            $this->addPhpIniRecommendation(                'xdebug.max_nesting_level',                create_function('$cfgValue', 'return $cfgValue > 100;'),                true,                'xdebug.max_nesting_level should be above 100 in php.ini',                'Set ""<strong>xdebug.max_nesting_level</strong>"" to e.g. ""<strong>250</strong>"" in php.ini<a href=""#phpini"">*</a> to stop Xdebug\'s infinite recursion protection erroneously throwing a fatal error in your project.'            );        }        $pcreVersion = defined('PCRE_VERSION') ? (float) PCRE_VERSION : null;        $this->addRequirement(            null !== $pcreVersion,            'PCRE extension must be available',            'Install the <strong>PCRE</strong> extension (version 8.0+).'        );        if (extension_loaded('mbstring')) {            $this->addPhpIniRequirement(                'mbstring.func_overload',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'string functions should not be overloaded',                'Set ""<strong>mbstring.func_overload</strong>"" to <strong>0</strong> in php.ini<a href=""#phpini"">*</a> to disable function overloading by the mbstring extension.'            );        }        /* optional recommendations follow */        if (file_exists(__DIR__.'/../vendor/composer')) {            require_once __DIR__.'/../vendor/autoload.php';            try {                $r = new ReflectionClass('Sensio\Bundle\DistributionBundle\SensioDistributionBundle');                $contents = file_get_contents(dirname($r->getFileName()).'/Resources/skeleton/app/SymfonyRequirements.php');            } catch (ReflectionException $e) {                $contents = '';            }            $this->addRecommendation(                file_get_contents(__FILE__) === $contents,                'Requirements file should be up-to-date',                'Your requirements file is outdated. Run composer install and re-check your configuration.'            );        }        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.4', '>='),            'You should use at least PHP 5.3.4 due to PHP bug #52083 in earlier versions',            'Your project might malfunction randomly due to PHP bug #52083 (""Notice: Trying to get property of non-object""). Install PHP 5.3.4 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.8', '>='),            'When using annotations you should have at least PHP 5.3.8 due to PHP bug #55156',            'Install PHP 5.3.8 or newer if your project uses annotations.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.0', '!='),            'You should not use PHP 5.4.0 due to the PHP bug #61453',            'Your project might not work properly due to the PHP bug #61453 (""Cannot dump definitions which have method calls""). Install PHP 5.4.1 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.11', '>='),            'When using the logout handler from the Symfony Security Component, you should have at least PHP 5.4.11 due to PHP bug #63379 (as a workaround, you can also set invalidate_session to false in the security logout handler configuration)',            'Install PHP 5.4.11 or newer if your project uses the logout handler from the Symfony Security Component.'        );        $this->addRecommendation(            (version_compare($installedPhpVersion, '5.3.18', '>=') && version_compare($installedPhpVersion, '5.4.0', '<'))            ||            version_compare($installedPhpVersion, '5.4.8', '>='),            'You should use PHP 5.3.18+ or PHP 5.4.8+ to always get nice error messages for fatal errors in the development environment due to PHP bug #61767/#60909',            'Install PHP 5.3.18+ or PHP 5.4.8+ if you want nice error messages for all fatal errors in the development environment.'        );        if (null !== $pcreVersion) {            $this->addRecommendation(                $pcreVersion >= 8.0,                sprintf('PCRE extension should be at least version 8.0 (%s installed)', $pcreVersion),                '<strong>PCRE 8.0+</strong> is preconfigured in PHP since 5.3.2 but you are using an outdated version of it. Symfony probably works anyway but it is recommended to upgrade your PCRE extension.'            );        }        $this->addRecommendation(            class_exists('DomDocument'),            'PHP-DOM and PHP-XML modules should be installed',            'Install and enable the <strong>PHP-DOM</strong> and the <strong>PHP-XML</strong> modules.'        );        $this->addRecommendation(            function_exists('mb_strlen'),            'mb_strlen() should be available',            'Install and enable the <strong>mbstring</strong> extension.'        );        $this->addRecommendation(            function_exists('utf8_decode'),            'utf8_decode() should be available',            'Install and enable the <strong>XML</strong> extension.'        );        $this->addRecommendation(            function_exists('filter_var'),            'filter_var() should be available',            'Install and enable the <strong>filter</strong> extension.'        );        if (!defined('PHP_WINDOWS_VERSION_BUILD')) {            $this->addRecommendation(                function_exists('posix_isatty'),                'posix_isatty() should be available',                'Install and enable the <strong>php_posix</strong> extension (used to colorize the CLI output).'            );        }        $this->addRecommendation(            extension_loaded('intl'),            'intl extension should be available',            'Install and enable the <strong>intl</strong> extension (used for validators).'        );        if (extension_loaded('intl')) {            // in some WAMP server installations, new Collator() returns null            $this->addRecommendation(                null !== new Collator('fr_FR'),                'intl extension should be correctly configured',                'The intl extension does not behave properly. This problem is typical on PHP 5.3.X x64 WIN builds.'            );            // check for compatible ICU versions (only done when you have the intl extension)            if (defined('INTL_ICU_VERSION')) {                $version = INTL_ICU_VERSION;            } else {                $reflector = new ReflectionExtension('intl');                ob_start();                $reflector->info();                $output = strip_tags(ob_get_clean());                preg_match('/^ICU version +(?:=> )?(.*)$/m', $output, $matches);                $version = $matches[1];            }            $this->addRecommendation(                version_compare($version, '4.0', '>='),                'intl ICU version should be at least 4+',                'Upgrade your <strong>intl</strong> extension with a newer ICU version (4+).'            );            if (class_exists('Symfony\Component\Intl\Intl')) {                $this->addRecommendation(                    \Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion(),                    sprintf('intl ICU version installed on your system is outdated (%s) and does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                    'To get the latest internationalization data upgrade the ICU system package and the intl PHP extension.'                );                if (\Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion()) {                    $this->addRecommendation(                        \Symfony\Component\Intl\Intl::getIcuDataVersion() === \Symfony\Component\Intl\Intl::getIcuVersion(),                        sprintf('intl ICU version installed on your system (%s) does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                        'To avoid internationalization data inconsistencies upgrade the symfony/intl component.'                    );                }            }            $this->addPhpIniRecommendation(                'intl.error_level',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'intl.error_level should be 0 in php.ini',                'Set ""<strong>intl.error_level</strong>"" to ""<strong>0</strong>"" in php.ini<a href=""#phpini"">*</a> to inhibit the messages when an error occurs in ICU functions.'            );        }        $accelerator =            (extension_loaded('eaccelerator') && ini_get('eaccelerator.enable'))            ||            (extension_loaded('apc') && ini_get('apc.enabled'))            ||            (extension_loaded('Zend Optimizer+') && ini_get('zend_optimizerplus.enable'))            ||            (extension_loaded('Zend OPcache') && ini_get('opcache.enable'))            ||            (extension_loaded('xcache') && ini_get('xcache.cacher'))            ||            (extension_loaded('wincache') && ini_get('wincache.ocenabled'))        ;        $this->addRecommendation(            $accelerator,            'a PHP accelerator should be installed',            'Install and/or enable a <strong>PHP accelerator</strong> (highly recommended).'        );        if ('WIN' === strtoupper(substr(PHP_OS, 0, 3))) {            $this->addRecommendation(                $this->getRealpathCacheSize() >= 5 * 1024 * 1024,                'realpath_cache_size should be at least 5M in php.ini',                'Setting ""<strong>realpath_cache_size</strong>"" to e.g. ""<strong>5242880</strong>"" or ""<strong>5M</strong>"" in php.ini<a href=""#phpini"">*</a> may improve performance on Windows significantly in some cases.'            );        }        $this->addPhpIniRecommendation('short_open_tag', false);        $this->addPhpIniRecommendation('magic_quotes_gpc', false, true);        $this->addPhpIniRecommendation('register_globals', false, true);        $this->addPhpIniRecommendation('session.auto_start', false);        $this->addRecommendation(            class_exists('PDO'),            'PDO should be installed',            'Install <strong>PDO</strong> (mandatory for Doctrine).'        );        if (class_exists('PDO')) {            $drivers = PDO::getAvailableDrivers();            $this->addRecommendation(                count($drivers) > 0,                sprintf('PDO should have some drivers installed (currently available: %s)', count($drivers) ? implode(', ', $drivers) : 'none'),                'Install <strong>PDO drivers</strong> (mandatory for Doctrine).'            );        }    }    /**     * Loads realpath_cache_size from php.ini and converts it to int.     *     * (e.g. 16k is converted to 16384 int)     *     * @return int     */    protected function getRealpathCacheSize()    {        $size = ini_get('realpath_cache_size');        $size = trim($size);        $unit = '';        if (!ctype_digit($size)) {            $unit = strtolower(substr($size, -1, 1));            $size = (int) substr($size, 0, -1);        }        switch ($unit) {            case 'g':                return $size * 1024 * 1024 * 1024;            case 'm':                return $size * 1024 * 1024;            case 'k':                return $size * 1024;            default:                return (int) $size;        }    }    /**     * Defines PHP required version from Symfony version.     *     * @return string|false The PHP required version or false if it could not be guessed     */    protected function getPhpRequiredVersion()    {        if (!file_exists($path = __DIR__.'/../composer.lock')) {            return false;        }        $composerLock = json_decode(file_get_contents($path), true);        foreach ($composerLock['packages'] as $package) {            $name = $package['name'];            if ('symfony/symfony' !== $name && 'symfony/http-kernel' !== $name) {                continue;            }            return (int) $package['version'][1] > 2 ? self::REQUIRED_PHP_VERSION : self::LEGACY_REQUIRED_PHP_VERSION;        }        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_SymfonyRequirements_2446, Returns both requirements and recommendations.\n\n @return Requirement[]\n,Vraća i zahteve i preporuke,"class SymfonyRequirements extends RequirementCollection{    const LEGACY_REQUIRED_PHP_VERSION = '5.3.3';    const REQUIRED_PHP_VERSION = '5.5.9';    /**     * Constructor that initializes the requirements.     */    public function __construct()    {        /* mandatory requirements follow */        $installedPhpVersion = PHP_VERSION;        $requiredPhpVersion = $this->getPhpRequiredVersion();        $this->addRecommendation(            $requiredPhpVersion,            'Vendors should be installed in order to check all requirements.',            'Run the <code>composer install</code> command.',            'Run the ""composer install"" command.'        );        if (false !== $requiredPhpVersion) {            $this->addRequirement(                version_compare($installedPhpVersion, $requiredPhpVersion, '>='),                sprintf('PHP version must be at least %s (%s installed)', $requiredPhpVersion, $installedPhpVersion),                sprintf('You are running PHP version ""<strong>%s</strong>"", but Symfony needs at least PHP ""<strong>%s</strong>"" to run.                Before using Symfony, upgrade your PHP installation, preferably to the latest version.',                    $installedPhpVersion, $requiredPhpVersion),                sprintf('Install PHP %s or newer (installed version is %s)', $requiredPhpVersion, $installedPhpVersion)            );        }        $this->addRequirement(            version_compare($installedPhpVersion, '5.3.16', '!='),            'PHP version must not be 5.3.16 as Symfony won\'t work properly with it',            'Install PHP 5.3.17 or newer (or downgrade to an earlier PHP version)'        );        $this->addRequirement(            is_dir(__DIR__.'/../vendor/composer'),            'Vendor libraries must be installed',            'Vendor libraries are missing. Install composer following instructions from <a href=""http://getcomposer.org/"">http://getcomposer.org/</a>. '.                'Then run ""<strong>php composer.phar install</strong>"" to install them.'        );        $cacheDir = is_dir(__DIR__.'/../var/cache') ? __DIR__.'/../var/cache' : __DIR__.'/cache';        $this->addRequirement(            is_writable($cacheDir),            'app/cache/ or var/cache/ directory must be writable',            'Change the permissions of either ""<strong>app/cache/</strong>"" or  ""<strong>var/cache/</strong>"" directory so that the web server can write into it.'        );        $logsDir = is_dir(__DIR__.'/../var/logs') ? __DIR__.'/../var/logs' : __DIR__.'/logs';        $this->addRequirement(            is_writable($logsDir),            'app/logs/ or var/logs/ directory must be writable',            'Change the permissions of either ""<strong>app/logs/</strong>"" or  ""<strong>var/logs/</strong>"" directory so that the web server can write into it.'        );        if (version_compare($installedPhpVersion, '7.0.0', '<')) {            $this->addPhpIniRequirement(                'date.timezone', true, false,                'date.timezone setting must be set',                'Set the ""<strong>date.timezone</strong>"" setting in php.ini<a href=""#phpini"">*</a> (like Europe/Paris).'            );        }        if (false !== $requiredPhpVersion && version_compare($installedPhpVersion, $requiredPhpVersion, '>=')) {            $this->addRequirement(                in_array(@date_default_timezone_get(), DateTimeZone::listIdentifiers(), true),                sprintf('Configured default timezone ""%s"" must be supported by your installation of PHP', @date_default_timezone_get()),                'Your default timezone is not supported by PHP. Check for typos in your <strong>php.ini</strong> file and have a look at the list of deprecated timezones at <a href=""http://php.net/manual/en/timezones.others.php"">http://php.net/manual/en/timezones.others.php</a>.'            );        }        $this->addRequirement(            function_exists('iconv'),            'iconv() must be available',            'Install and enable the <strong>iconv</strong> extension.'        );        $this->addRequirement(            function_exists('json_encode'),            'json_encode() must be available',            'Install and enable the <strong>JSON</strong> extension.'        );        $this->addRequirement(            function_exists('session_start'),            'session_start() must be available',            'Install and enable the <strong>session</strong> extension.'        );        $this->addRequirement(            function_exists('ctype_alpha'),            'ctype_alpha() must be available',            'Install and enable the <strong>ctype</strong> extension.'        );        $this->addRequirement(            function_exists('token_get_all'),            'token_get_all() must be available',            'Install and enable the <strong>Tokenizer</strong> extension.'        );        $this->addRequirement(            function_exists('simplexml_import_dom'),            'simplexml_import_dom() must be available',            'Install and enable the <strong>SimpleXML</strong> extension.'        );        if (function_exists('apc_store') && ini_get('apc.enabled')) {            if (version_compare($installedPhpVersion, '5.4.0', '>=')) {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.1.13', '>='),                    'APC version must be at least 3.1.13 when using PHP 5.4',                    'Upgrade your <strong>APC</strong> extension (3.1.13+).'                );            } else {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.0.17', '>='),                    'APC version must be at least 3.0.17',                    'Upgrade your <strong>APC</strong> extension (3.0.17+).'                );            }        }        $this->addPhpIniRequirement('detect_unicode', false);        if (extension_loaded('suhosin')) {            $this->addPhpIniRequirement(                'suhosin.executor.include.whitelist',                create_function('$cfgValue', 'return false !== stripos($cfgValue, ""phar"");'),                false,                'suhosin.executor.include.whitelist must be configured correctly in php.ini',                'Add ""<strong>phar</strong>"" to <strong>suhosin.executor.include.whitelist</strong> in php.ini<a href=""#phpini"">*</a>.'            );        }        if (extension_loaded('xdebug')) {            $this->addPhpIniRequirement(                'xdebug.show_exception_trace', false, true            );            $this->addPhpIniRequirement(                'xdebug.scream', false, true            );            $this->addPhpIniRecommendation(                'xdebug.max_nesting_level',                create_function('$cfgValue', 'return $cfgValue > 100;'),                true,                'xdebug.max_nesting_level should be above 100 in php.ini',                'Set ""<strong>xdebug.max_nesting_level</strong>"" to e.g. ""<strong>250</strong>"" in php.ini<a href=""#phpini"">*</a> to stop Xdebug\'s infinite recursion protection erroneously throwing a fatal error in your project.'            );        }        $pcreVersion = defined('PCRE_VERSION') ? (float) PCRE_VERSION : null;        $this->addRequirement(            null !== $pcreVersion,            'PCRE extension must be available',            'Install the <strong>PCRE</strong> extension (version 8.0+).'        );        if (extension_loaded('mbstring')) {            $this->addPhpIniRequirement(                'mbstring.func_overload',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'string functions should not be overloaded',                'Set ""<strong>mbstring.func_overload</strong>"" to <strong>0</strong> in php.ini<a href=""#phpini"">*</a> to disable function overloading by the mbstring extension.'            );        }        /* optional recommendations follow */        if (file_exists(__DIR__.'/../vendor/composer')) {            require_once __DIR__.'/../vendor/autoload.php';            try {                $r = new ReflectionClass('Sensio\Bundle\DistributionBundle\SensioDistributionBundle');                $contents = file_get_contents(dirname($r->getFileName()).'/Resources/skeleton/app/SymfonyRequirements.php');            } catch (ReflectionException $e) {                $contents = '';            }            $this->addRecommendation(                file_get_contents(__FILE__) === $contents,                'Requirements file should be up-to-date',                'Your requirements file is outdated. Run composer install and re-check your configuration.'            );        }        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.4', '>='),            'You should use at least PHP 5.3.4 due to PHP bug #52083 in earlier versions',            'Your project might malfunction randomly due to PHP bug #52083 (""Notice: Trying to get property of non-object""). Install PHP 5.3.4 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.8', '>='),            'When using annotations you should have at least PHP 5.3.8 due to PHP bug #55156',            'Install PHP 5.3.8 or newer if your project uses annotations.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.0', '!='),            'You should not use PHP 5.4.0 due to the PHP bug #61453',            'Your project might not work properly due to the PHP bug #61453 (""Cannot dump definitions which have method calls""). Install PHP 5.4.1 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.11', '>='),            'When using the logout handler from the Symfony Security Component, you should have at least PHP 5.4.11 due to PHP bug #63379 (as a workaround, you can also set invalidate_session to false in the security logout handler configuration)',            'Install PHP 5.4.11 or newer if your project uses the logout handler from the Symfony Security Component.'        );        $this->addRecommendation(            (version_compare($installedPhpVersion, '5.3.18', '>=') && version_compare($installedPhpVersion, '5.4.0', '<'))            ||            version_compare($installedPhpVersion, '5.4.8', '>='),            'You should use PHP 5.3.18+ or PHP 5.4.8+ to always get nice error messages for fatal errors in the development environment due to PHP bug #61767/#60909',            'Install PHP 5.3.18+ or PHP 5.4.8+ if you want nice error messages for all fatal errors in the development environment.'        );        if (null !== $pcreVersion) {            $this->addRecommendation(                $pcreVersion >= 8.0,                sprintf('PCRE extension should be at least version 8.0 (%s installed)', $pcreVersion),                '<strong>PCRE 8.0+</strong> is preconfigured in PHP since 5.3.2 but you are using an outdated version of it. Symfony probably works anyway but it is recommended to upgrade your PCRE extension.'            );        }        $this->addRecommendation(            class_exists('DomDocument'),            'PHP-DOM and PHP-XML modules should be installed',            'Install and enable the <strong>PHP-DOM</strong> and the <strong>PHP-XML</strong> modules.'        );        $this->addRecommendation(            function_exists('mb_strlen'),            'mb_strlen() should be available',            'Install and enable the <strong>mbstring</strong> extension.'        );        $this->addRecommendation(            function_exists('utf8_decode'),            'utf8_decode() should be available',            'Install and enable the <strong>XML</strong> extension.'        );        $this->addRecommendation(            function_exists('filter_var'),            'filter_var() should be available',            'Install and enable the <strong>filter</strong> extension.'        );        if (!defined('PHP_WINDOWS_VERSION_BUILD')) {            $this->addRecommendation(                function_exists('posix_isatty'),                'posix_isatty() should be available',                'Install and enable the <strong>php_posix</strong> extension (used to colorize the CLI output).'            );        }        $this->addRecommendation(            extension_loaded('intl'),            'intl extension should be available',            'Install and enable the <strong>intl</strong> extension (used for validators).'        );        if (extension_loaded('intl')) {            // in some WAMP server installations, new Collator() returns null            $this->addRecommendation(                null !== new Collator('fr_FR'),                'intl extension should be correctly configured',                'The intl extension does not behave properly. This problem is typical on PHP 5.3.X x64 WIN builds.'            );            // check for compatible ICU versions (only done when you have the intl extension)            if (defined('INTL_ICU_VERSION')) {                $version = INTL_ICU_VERSION;            } else {                $reflector = new ReflectionExtension('intl');                ob_start();                $reflector->info();                $output = strip_tags(ob_get_clean());                preg_match('/^ICU version +(?:=> )?(.*)$/m', $output, $matches);                $version = $matches[1];            }            $this->addRecommendation(                version_compare($version, '4.0', '>='),                'intl ICU version should be at least 4+',                'Upgrade your <strong>intl</strong> extension with a newer ICU version (4+).'            );            if (class_exists('Symfony\Component\Intl\Intl')) {                $this->addRecommendation(                    \Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion(),                    sprintf('intl ICU version installed on your system is outdated (%s) and does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                    'To get the latest internationalization data upgrade the ICU system package and the intl PHP extension.'                );                if (\Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion()) {                    $this->addRecommendation(                        \Symfony\Component\Intl\Intl::getIcuDataVersion() === \Symfony\Component\Intl\Intl::getIcuVersion(),                        sprintf('intl ICU version installed on your system (%s) does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                        'To avoid internationalization data inconsistencies upgrade the symfony/intl component.'                    );                }            }            $this->addPhpIniRecommendation(                'intl.error_level',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'intl.error_level should be 0 in php.ini',                'Set ""<strong>intl.error_level</strong>"" to ""<strong>0</strong>"" in php.ini<a href=""#phpini"">*</a> to inhibit the messages when an error occurs in ICU functions.'            );        }        $accelerator =            (extension_loaded('eaccelerator') && ini_get('eaccelerator.enable'))            ||            (extension_loaded('apc') && ini_get('apc.enabled'))            ||            (extension_loaded('Zend Optimizer+') && ini_get('zend_optimizerplus.enable'))            ||            (extension_loaded('Zend OPcache') && ini_get('opcache.enable'))            ||            (extension_loaded('xcache') && ini_get('xcache.cacher'))            ||            (extension_loaded('wincache') && ini_get('wincache.ocenabled'))        ;        $this->addRecommendation(            $accelerator,            'a PHP accelerator should be installed',            'Install and/or enable a <strong>PHP accelerator</strong> (highly recommended).'        );        if ('WIN' === strtoupper(substr(PHP_OS, 0, 3))) {            $this->addRecommendation(                $this->getRealpathCacheSize() >= 5 * 1024 * 1024,                'realpath_cache_size should be at least 5M in php.ini',                'Setting ""<strong>realpath_cache_size</strong>"" to e.g. ""<strong>5242880</strong>"" or ""<strong>5M</strong>"" in php.ini<a href=""#phpini"">*</a> may improve performance on Windows significantly in some cases.'            );        }        $this->addPhpIniRecommendation('short_open_tag', false);        $this->addPhpIniRecommendation('magic_quotes_gpc', false, true);        $this->addPhpIniRecommendation('register_globals', false, true);        $this->addPhpIniRecommendation('session.auto_start', false);        $this->addRecommendation(            class_exists('PDO'),            'PDO should be installed',            'Install <strong>PDO</strong> (mandatory for Doctrine).'        );        if (class_exists('PDO')) {            $drivers = PDO::getAvailableDrivers();            $this->addRecommendation(                count($drivers) > 0,                sprintf('PDO should have some drivers installed (currently available: %s)', count($drivers) ? implode(', ', $drivers) : 'none'),                'Install <strong>PDO drivers</strong> (mandatory for Doctrine).'            );        }    }    /**     * Loads realpath_cache_size from php.ini and converts it to int.     *     * (e.g. 16k is converted to 16384 int)     *     * @return int     */    protected function getRealpathCacheSize()    {        $size = ini_get('realpath_cache_size');        $size = trim($size);        $unit = '';        if (!ctype_digit($size)) {            $unit = strtolower(substr($size, -1, 1));            $size = (int) substr($size, 0, -1);        }        switch ($unit) {            case 'g':                return $size * 1024 * 1024 * 1024;            case 'm':                return $size * 1024 * 1024;            case 'k':                return $size * 1024;            default:                return (int) $size;        }    }    /**     * Defines PHP required version from Symfony version.     *     * @return string|false The PHP required version or false if it could not be guessed     */    protected function getPhpRequiredVersion()    {        if (!file_exists($path = __DIR__.'/../composer.lock')) {            return false;        }        $composerLock = json_decode(file_get_contents($path), true);        foreach ($composerLock['packages'] as $package) {            $name = $package['name'];            if ('symfony/symfony' !== $name && 'symfony/http-kernel' !== $name) {                continue;            }            return (int) $package['version'][1] > 2 ? self::REQUIRED_PHP_VERSION : self::LEGACY_REQUIRED_PHP_VERSION;        }        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_DateTimeComparator_2334, Compares DateTimeInterface instances for equality.\n,Upoređuje instance DateTimeInterface radi jednakosti,"class DateTimeComparator extends ObjectComparator{    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return ($expected instanceof DateTime || $expected instanceof DateTimeInterface) &&               ($actual instanceof DateTime || $actual instanceof DateTimeInterface);    }    /**     * Asserts that two values are equal.     *     * @param mixed $expected     First value to compare     * @param mixed $actual       Second value to compare     * @param float $delta        Allowed numerical distance between two values to consider them equal     * @param bool  $canonicalize Arrays are sorted before comparison when set to true     * @param bool  $ignoreCase   Case is ignored when set to true     * @param array $processed    List of already processed elements (used to prevent infinite recursion)     *     * @throws ComparisonFailure     * @throws Exception     */    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false, array &$processed = [])/*: void*/    {        /** @var DateTimeInterface $expected */        /** @var DateTimeInterface $actual */        $absDelta = abs($delta);        $delta    = new DateInterval(sprintf('PT%dS', $absDelta));        $delta->f = $absDelta - floor($absDelta);        $actualClone = (clone $actual)            ->setTimezone(new DateTimeZone('UTC'));        $expectedLower = (clone $expected)            ->setTimezone(new DateTimeZone('UTC'))            ->sub($delta);        $expectedUpper = (clone $expected)            ->setTimezone(new DateTimeZone('UTC'))            ->add($delta);        if ($actualClone < $expectedLower || $actualClone > $expectedUpper) {            throw new ComparisonFailure(                $expected,                $actual,                $this->dateTimeToString($expected),                $this->dateTimeToString($actual),                false,                'Failed asserting that two DateTime objects are equal.'            );        }    }    /**     * Returns an ISO 8601 formatted string representation of a datetime or     * 'Invalid DateTimeInterface object' if the provided DateTimeInterface was not properly     * initialized.     */    private function dateTimeToString(DateTimeInterface $datetime): string    {        $string = $datetime->format('Y-m-d\TH:i:s.uO');        return $string ?: 'Invalid DateTimeInterface object';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
45. how to make the checkbox checked (checkbox,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
phpspec_prophecy_ArgumentsWildcard_2935, Initializes wildcard.\n\n @param array $arguments Array of argument tokens or values\n,Inicijalizacija wildcard-a,    public function __construct(array $arguments)    {        foreach ($arguments as $argument) {            if (!$argument instanceof Token\TokenInterface) {                $argument = new Token\ExactValueToken($argument);            }            $this->tokens[] = $argument;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
woocommerce_woocommerce_RestockRefundedItemsAdjuster_1935, Class to adjust or initialize the restock refunded items.\n,Klasa za prilagođavanje ili inicijalizaciju vraćenih stavki,public static function initialize( $mockable_classes ) {if ( ! is_array( $mockable_classes ) || empty( $mockable_classes ) ) {throw new \Exception( 'StaticMockerHack::initialize:: $mockable_classes must be a non-empty associative array of class name => array of class methods.' );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2546, Create a random ArbitraryInteger\\n\\n @param int $bytes\\n\\n @return Number\\\\ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n,Napravite slučajni ArbitrarInteger broj,"    public static function rand(int $bytes): Number\ArbitraryInteger    {        if ($bytes <= 0) {            throw new Exception\BadParameterException('Cannot produce a random number with zero or negative bytes.');        }        return Number\ArbitraryInteger::fromBinary(\random_bytes($bytes), \mt_rand(0, 1) === 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_KernelDensityEstimation_3533, Default bandwidth for when one is not provided.\\n Uses the normal distribution approximation bandwidth estimator.\\n https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\\n\\n             â…•\\n      / 4Ïƒâµ \\\\\\n h = |  ---  |\\n      \\\\ 3n  /\\n\\n\\n @return float\\n\\n @throws Exception\\\\OutOfBoundsException\\n,Podrazumevana širina opsega kada nije obezbeđena. Koristi procenjivač širine opsega aproksimacije normalne distribucije,    private function getDefaultBandwidth(): float    {        $ï¼”Ïƒâµ = 4 * Descriptive::standardDeviation($this->data) ** 5;        $ï¼“n  = 3 * $this->n;        $â…•    = 0.2;        return ($ï¼”Ïƒâµ / $ï¼“n) ** $â…•;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LogNormal_3141, Log normal distribution - probability density function\\n\\n https://en.wikipedia.org/wiki/Log-normal_distribution\\n\\n                 (ln x - Î¼)Â²\\n         1     - ----------\\n pdf = ----- â„¯       2ÏƒÂ²\\n       xÏƒâˆš2Ï€\\n\\n @param  float $x > 0\\n\\n @return float\\n,Logaritamska Normalna raspodela  - funkcija gustine verovatnoće,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        $Ï€ = \M_PI;        $xÏƒâˆš2Ï€      = $x * $Ïƒ * \sqrt(2 * $Ï€);        $âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² = \pow(\log($x) - $Î¼, 2);        $ÏƒÂ²         = $Ïƒ ** 2;        return (1 / $xÏƒâˆš2Ï€) * \exp(-($âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² / (2 * $ÏƒÂ²)));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3284, Normal distribution\n https://en.wikipedia.org/wiki/Multivariate_normal_distribution\n,Normalna raspodela,"class Normal{    /** @var array location */    protected $Î¼;    /** @var NumericMatrix covariance matrix */    protected $âˆ‘;    /**     * Constructor     *     * @param array         $Î¼ âˆˆ Ráµ   location     * @param NumericMatrix $âˆ‘ âˆˆ RáµË£áµ covariance matrix     *     * @throws Exception\BadDataException if the covariance matrix does not have the same number of rows and columns as number of elements in Î¼     * @throws Exception\BadDataException if the covariance matrix is not positive definite     */    public function __construct(array $Î¼, NumericMatrix $âˆ‘)    {        $k = \count($Î¼);        if ($âˆ‘->getM() !== $k || $âˆ‘->getN() !== $k) {            throw new Exception\BadDataException(                'Covariance matrix âˆ‘ must have the the same number of rows and columns as there are X elements. ' .                ""X has $k elements. Covariance matrix âˆ‘ has "" . $âˆ‘->getM() . ' rows and ' . $âˆ‘->getN() . ' columns.'            );        }        if (!$âˆ‘->isPositiveDefinite()) {            throw new Exception\BadDataException(""Covariance matrix âˆ‘ is not positive definite:\n$âˆ‘"");        }        $this->Î¼ = $Î¼;        $this->âˆ‘ = $âˆ‘;    }    /**     * Probability density function     *     *                 exp(âˆ’Â½(x âˆ’Â Î¼)áµ€âˆ‘â»Â¹(xÂ âˆ’Â Î¼))     * fx(xâ‚,...,xk) = -------------------------     *                        âˆš(2Ï€)áµâ”‚âˆ‘â”‚     *     * x is a real k-dimensional column vector     * Î¼ is a real k-dimensinoal column vector of means     * â”‚âˆ‘â”‚ â‰¡ det(âˆ‘)     *     * @param array  $X âˆˆ Ráµ   k-dimensional random vector     *     * @return float density     *     * @throws Exception\BadDataException if X and Î¼ do not have the same number of elements     */    public function pdf(array $X): float    {        $k = \count($X);        $Î¼ = $this->Î¼;        $âˆ‘ = $this->âˆ‘;        if (\count($Î¼) !== $k) {            throw new Exception\BadDataException(""X and Î¼ must have the same number of elements. X has $k and Î¼ has "" . \count($Î¼));        }        $Ï€ = \M_PI;        $â”‚âˆ‘â”‚      = $âˆ‘->det();        $âˆšâŸ®2Ï€âŸ¯áµâ”‚âˆ‘â”‚ = \sqrt((2 * $Ï€) ** $k * $â”‚âˆ‘â”‚);        $Î”       = Map\Multi::subtract($X, $Î¼);        $âŸ®xÂ âˆ’Â Î¼âŸ¯  = new Vector($Î”);        $âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€ = MatrixFactory::createFromRowVector($Î”);        $âˆ‘â»Â¹     = $âˆ‘->inverse();        $expâŸ®âˆ’Â½âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€âˆ‘â»Â¹âŸ®xÂ âˆ’Â Î¼âŸ¯âŸ¯ = \exp(            $âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€->scalarDivide(-2)                ->multiply($âˆ‘â»Â¹)                ->multiply($âŸ®xÂ âˆ’Â Î¼âŸ¯)                ->get(0, 0)        );        return $expâŸ®âˆ’Â½âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€âˆ‘â»Â¹âŸ®xÂ âˆ’Â Î¼âŸ¯âŸ¯ / $âˆšâŸ®2Ï€âŸ¯áµâ”‚âˆ‘â”‚;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3167, Cumulative distribution function\n Probability of being below X.\n Area under the normal distribution from -âˆž to X.\n             _                  _\n          1 |         / x - Î¼ \\  |\n cdf(x) = - | 1 + erf|  ----- |  |\n          2 |_        \\  Ïƒâˆš2  / _|\n\n @param float $x upper bound\n\n @return float cdf(x) below\n,Funkcija kumulativne raspodele. Verovatnoća da bude ispod X. Površina ispod normalne raspodele od -a do X,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        return 1 / 2 * ( 1 + Special::erf(($x - $Î¼) / ($Ïƒ * \sqrt(2))) );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Installer_2547, Whether or not generated autoloader are optimized\n\n @param  bool      $optimizeAutoloader\n @return Installer\n,Bez obzira da li je ili ne generisan automatski  se autoloader optimizuje,    public function setOptimizeAutoloader($optimizeAutoloader)    {        $this->optimizeAutoloader = (bool) $optimizeAutoloader;        if (!$this->optimizeAutoloader) {            // Force classMapAuthoritative off when not optimizing the            // autoloader            $this->setClassMapAuthoritative(false);        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1228, Uses previously generated safe universal build and generates optimized build for a specific platform\\n,Koristi prethodno generisanu sigurnu univerzalni build i generiše optimizovani build za određenu platformu,"class Generator_Optimized{    /**     * Directory, where safe universal build files are generated     *     * @var string     */    protected string $sourceBuildDir;    /**     * Platform settings for supported optimized builds     *     * @var array     */    protected array $settings;    /**     * Filters for processing (optimizing) lines from safe universal phalcon.c     *     * @var array     */    protected array $filters;    /**     * @param string $sourceBuildDir     * @param string $output32Dir     * @param string $output64Dir     */    public function __construct(string $sourceBuildDir, string $output32Dir, string $output64Dir)    {        $this->sourceBuildDir = $sourceBuildDir;        $this->settings = $this->getPlatformsSettings($output32Dir, $output64Dir);        $this->filters = $this->getFilters();    }    /**     * Return array of supported platform settings for optimized builds     *     * @param string $output32Dir     * @param string $output64Dir     * @return array     */    protected function getPlatformsSettings(string $output32Dir, string $output64Dir)    {        return array(            '32bit' => array(                'dir' => $output32Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey32($string) . 'UL';                }            ),            '64bit' => array(                'dir' => $output64Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey64($string) . 'UL';                }            ),        );    }    /**     * Return filters for processing lines from safe universal phalcon.c     *     * @return array     */    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }    /**     * Run generation process     */    public function run()    {        echo 'Generating builds, optimized for 32-bit and 64-bit platforms... ';        $this->cleanBuildDirectories();        $this->copyFilesFromSourceBuildDir();        $this->copyAndOptimizePhalconC();        echo ""OK\n"";    }    /**     * Delete all files in target directories     */    public function cleanBuildDirectories()    {        foreach ($this->settings as $setting) {            Util::cleanDirectory($setting['dir']);        }    }    /**     * Copy all files from the original safe universal build directory     */    protected function copyFilesFromSourceBuildDir()    {        $files = glob($this->sourceBuildDir . '/*.*');        foreach ($files as $file) {            // phalcon.c is processed in a separate optimization func            if (basename($file) == 'phalcon.zep.c') {                continue;            }            foreach ($this->settings as $setting) {                copy($file, $setting['dir'] . '/' . basename($file));            }        }    }    /**     * Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.     * Precalculation is, actually, the optimization being performed.     */    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }    /**     * Pass line through filters and add the processed result to platform builds     *     * @param string $line     * @param array $result     */    protected function filterLine($line, &$result)    {        /** @var callable|null $func */        $func = null;        foreach ($this->filters as $filter) {            if (!preg_match($filter['regexp'], $line, $matches)) {                continue;            }            $func = $filter['func'];            break; // We don't expect more than one replacement to be made on the same line        }        foreach ($this->settings as $platform => $setting) {            $result[$platform] .= $func ? $func($line, $matches, $setting['hashFunc']) : $line;        }    }}",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_834, Get all attributes groups for a given language.\\n\\n @param int $idLang Language id\\n\\n @return array Attributes groups\\n,Dohvata sve grupe atributa za dati jezik,"    public static function getAttributesGroups($idLang)    {        if (!Combination::isFeatureActive()) {            return [];        }        return Db::getInstance()->executeS('SELECT DISTINCT agl.`name`, ag.*, agl.*FROM `' . _DB_PREFIX_ . 'attribute_group` ag' . Shop::addSqlAssociation('attribute_group', 'ag') . 'LEFT JOIN `' . _DB_PREFIX_ . 'attribute_group_lang` aglON (ag.`id_attribute_group` = agl.`id_attribute_group` AND `id_lang` = ' . (int) $idLang . ')ORDER BY `name` ASC');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2164, Extracts the key from a command with multiple keys only when all keys in\n the arguments array produce the same hash.\n\n @param CommandInterface $command Command instance.\n\n @return string|null\n,Izdvaja ključ iz naredbe sa više ključeva samo kada svi ključevi u polju argumenata proizvode isto heširanje,    protected function getKeyFromInterleavedArguments(CommandInterface $command)    {        $arguments = $command->getArguments();        $keys = array();        for ($i = 0; $i < count($arguments); $i += 2) {            $keys[] = $arguments[$i];        }        if ($this->checkSameSlotForKeys($keys)) {            return $arguments[0];        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
"59. get current process id (getmypid, current process",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
walkor_Workerman_Worker_8679, Check errors when current process exited.\n\n @return void\n,Proverite greške kada je trenutni proces završio,"    public static function log($msg)    {        $msg = $msg . ""\n"";        if (!static::$daemonize) {            static::safeEcho($msg);        }        \file_put_contents((string)static::$logFile, \date('Y-m-d H:i:s') . ' ' . 'pid:'            . (static::$_OS === \OS_TYPE_LINUX ? \posix_getpid() : 1) . ' ' . $msg, \FILE_APPEND | \LOCK_EX);    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_9621, Exit current process.\n\n @return void\n,Izađite iz trenutnog procesa,"    public static function checkIfChildRunning()    {        foreach (static::$_pidMap as $worker_id => $worker_pid_array) {            foreach ($worker_pid_array as $pid => $worker_pid) {                if (!\posix_kill($pid, 0)) {                    unset(static::$_pidMap[$worker_id][$pid]);                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_DateComparator_390, DateCompare compiles date comparisons.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n,DateCompare kompajlira poređenje datuma,"class DateComparator extends Comparator{    /**     * @param string $test A comparison string     *     * @throws \InvalidArgumentException If the test is not understood     */    public function __construct(string $test)    {        if (!preg_match('#^\s*(==|!=|[<>]=?|after|since|before|until)?\s*(.+?)\s*$#i', $test, $matches)) {            throw new \InvalidArgumentException(sprintf('Don\'t understand ""%s"" as a date test.', $test));        }        try {            $date = new \DateTime($matches[2]);            $target = $date->format('U');        } catch (\Exception $e) {            throw new \InvalidArgumentException(sprintf('""%s"" is not a valid date.', $matches[2]));        }        $operator = $matches[1] ?? '==';        if ('since' === $operator || 'after' === $operator) {            $operator = '>';        }        if ('until' === $operator || 'before' === $operator) {            $operator = '<';        }        $this->setOperator($operator);        $this->setTarget($target);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_JsonResponse_8807, Response represents an HTTP response in JSON format.\n\n Note that this class does not force the returned JSON content to be an\n object. It is however recommended that you do return an object as it\n protects yourself against XSSI and JSON-JavaScript Hijacking.\n\n @see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside\n\n @author Igor Wiedler <igor@wiedler.ch>\n,"Odgovor predstavlja HTTP odgovor u JSON formatu. Imajte na umu da ova klasa ne prisiljava vraćeni JSON sadržaj da bude objekat. Međutim, preporučuje se da vratite objekat jer se on štiti od XSSSI i JSON-JavaScript hakovanja","class JsonResponse extends Response{    protected $data;    protected $callback;    // Encode <, >, ', &, and "" characters in the JSON, making it also safe to be embedded into HTML.    // 15 === JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT    public const DEFAULT_ENCODING_OPTIONS = 15;    protected $encodingOptions = self::DEFAULT_ENCODING_OPTIONS;    /**     * @param mixed $data    The response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     * @param bool  $json    If the data is already a JSON string     */    public function __construct($data = null, int $status = 200, array $headers = [], bool $json = false)    {        parent::__construct('', $status, $headers);        if ($json && !\is_string($data) && !is_numeric($data) && !\is_callable([$data, '__toString'])) {            throw new \TypeError(sprintf('""%s"": If $json is set to true, argument $data must be a string or object implementing __toString(), ""%s"" given.', __METHOD__, get_debug_type($data)));        }        if (null === $data) {            $data = new \ArrayObject();        }        $json ? $this->setJson($data) : $this->setData($data);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::create(['key' => 'value'])     *         ->setSharedMaxAge(300);     *     * @param mixed $data    The JSON response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     *     * @return static     *     * @deprecated since Symfony 5.1, use __construct() instead.     */    public static function create($data = null, int $status = 200, array $headers = [])    {        trigger_deprecation('symfony/http-foundation', '5.1', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($data, $status, $headers);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::fromJsonString('{""key"": ""value""}')     *         ->setSharedMaxAge(300);     *     * @param string $data    The JSON response string     * @param int    $status  The response status code     * @param array  $headers An array of response headers     *     * @return static     */    public static function fromJsonString(string $data, int $status = 200, array $headers = [])    {        return new static($data, $status, $headers, true);    }    /**     * Sets the JSONP callback.     *     * @param string|null $callback The JSONP callback or null to use none     *     * @return $this     *     * @throws \InvalidArgumentException When the callback name is not valid     */    public function setCallback(string $callback = null)    {        if (null !== $callback) {            // partially taken from https://geekality.net/2011/08/03/valid-javascript-identifier/            // partially taken from https://github.com/willdurand/JsonpCallbackValidator            //      JsonpCallbackValidator is released under the MIT License. See https://github.com/willdurand/JsonpCallbackValidator/blob/v1.1.0/LICENSE for details.            //      (c) William Durand <william.durand1@gmail.com>            $pattern = '/^[$_\p{L}][$_\p{L}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\x{200C}\x{200D}]*(?:\[(?:""(?:\\\.|[^""\\\])*""|\'(?:\\\.|[^\'\\\])*\'|\d+)\])*?$/u';            $reserved = [                'break', 'do', 'instanceof', 'typeof', 'case', 'else', 'new', 'var', 'catch', 'finally', 'return', 'void', 'continue', 'for', 'switch', 'while',                'debugger', 'function', 'this', 'with', 'default', 'if', 'throw', 'delete', 'in', 'try', 'class', 'enum', 'extends', 'super',  'const', 'export',                'import', 'implements', 'let', 'private', 'public', 'yield', 'interface', 'package', 'protected', 'static', 'null', 'true', 'false',            ];            $parts = explode('.', $callback);            foreach ($parts as $part) {                if (!preg_match($pattern, $part) || \in_array($part, $reserved, true)) {                    throw new \InvalidArgumentException('The callback name is not valid.');                }            }        }        $this->callback = $callback;        return $this->update();    }    /**     * Sets a raw string containing a JSON document to be sent.     *     * @return $this     */    public function setJson(string $json)    {        $this->data = $json;        return $this->update();    }    /**     * Sets the data to be sent as JSON.     *     * @param mixed $data     *     * @return $this     *     * @throws \InvalidArgumentException     */    public function setData($data = [])    {        try {            $data = json_encode($data, $this->encodingOptions);        } catch (\Exception $e) {            if ('Exception' === \get_class($e) && 0 === strpos($e->getMessage(), 'Failed calling ')) {                throw $e->getPrevious() ?: $e;            }            throw $e;        }        if (\PHP_VERSION_ID >= 70300 && (\JSON_THROW_ON_ERROR & $this->encodingOptions)) {            return $this->setJson($data);        }        if (\JSON_ERROR_NONE !== json_last_error()) {            throw new \InvalidArgumentException(json_last_error_msg());        }        return $this->setJson($data);    }    /**     * Returns options used while encoding data to JSON.     *     * @return int     */    public function getEncodingOptions()    {        return $this->encodingOptions;    }    /**     * Sets options used while encoding data to JSON.     *     * @return $this     */    public function setEncodingOptions(int $encodingOptions)    {        $this->encodingOptions = $encodingOptions;        return $this->setData(json_decode($this->data));    }    /**     * Updates the content and headers according to the JSON data and callback.     *     * @return $this     */    protected function update()    {        if (null !== $this->callback) {            // Not using application/javascript for compatibility reasons with older browsers.            $this->headers->set('Content-Type', 'text/javascript');            return $this->setContent(sprintf('/**/%s(%s);', $this->callback, $this->data));        }        // Only set the header when there is none or when it equals 'text/javascript' (from a previous update with callback)        // in order to not overwrite a custom definition.        if (!$this->headers->has('Content-Type') || 'text/javascript' === $this->headers->get('Content-Type')) {            $this->headers->set('Content-Type', 'application/json');        }        return $this->setContent($this->data);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_DebugClassLoader_1727," Autoloader checking if the class is really defined in the file found.\n\n The ClassLoader will wrap all registered autoloaders\n and will throw an exception if a file is found but does\n not declare the class.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Christophe Coevoet <stof@notk.org>\n @author Nicolas Grekas <p@tchwork.com>\n @author Guilhem Niot <guilhem.niot@gmail.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\DebugClassLoader instead.\n","Autoloader proverava da li je klasa zaista definisana u pronađenoj datoteci. ClassLoader će umotati sve registrovane autoloadere i izbaciće izuzetak ako je datoteka pronađena, ali ne deklariše klasu","class DebugClassLoader{    private $classLoader;    private $isFinder;    private $loaded = [];    private static $caseCheck;    private static $checkedClasses = [];    private static $final = [];    private static $finalMethods = [];    private static $deprecated = [];    private static $internal = [];    private static $internalMethods = [];    private static $annotatedParameters = [];    private static $darwinCache = ['/' => ['/', []]];    private static $method = [];    public function __construct(callable $classLoader)    {        $this->classLoader = $classLoader;        $this->isFinder = \is_array($classLoader) && method_exists($classLoader[0], 'findFile');        if (!isset(self::$caseCheck)) {            $file = file_exists(__FILE__) ? __FILE__ : rtrim(realpath('.'), \DIRECTORY_SEPARATOR);            $i = strrpos($file, \DIRECTORY_SEPARATOR);            $dir = substr($file, 0, 1 + $i);            $file = substr($file, 1 + $i);            $test = strtoupper($file) === $file ? strtolower($file) : strtoupper($file);            $test = realpath($dir.$test);            if (false === $test || false === $i) {                // filesystem is case sensitive                self::$caseCheck = 0;            } elseif (substr($test, -\strlen($file)) === $file) {                // filesystem is case insensitive and realpath() normalizes the case of characters                self::$caseCheck = 1;            } elseif (false !== stripos(\PHP_OS, 'darwin')) {                // on MacOSX, HFS+ is case insensitive but realpath() doesn't normalize the case of characters                self::$caseCheck = 2;            } else {                // filesystem case checks failed, fallback to disabling them                self::$caseCheck = 0;            }        }    }    /**     * Gets the wrapped class loader.     *     * @return callable The wrapped class loader     */    public function getClassLoader()    {        return $this->classLoader;    }    /**     * Wraps all autoloaders.     */    public static function enable()    {        // Ensures we don't hit https://bugs.php.net/42098        class_exists(\Symfony\Component\Debug\ErrorHandler::class);        class_exists(\Psr\Log\LogLevel::class);        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (!\is_array($function) || !$function[0] instanceof self) {                $function = [new static($function), 'loadClass'];            }            spl_autoload_register($function);        }    }    /**     * Disables the wrapping.     */    public static function disable()    {        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (\is_array($function) && $function[0] instanceof self) {                $function = $function[0]->getClassLoader();            }            spl_autoload_register($function);        }    }    /**     * @return string|null     */    public function findFile($class)    {        return $this->isFinder ? $this->classLoader[0]->findFile($class) ?: null : null;    }    /**     * Loads the given class or interface.     *     * @param string $class The name of the class     *     * @throws \RuntimeException     */    public function loadClass($class)    {        $e = error_reporting(error_reporting() | \E_PARSE | \E_ERROR | \E_CORE_ERROR | \E_COMPILE_ERROR);        try {            if ($this->isFinder && !isset($this->loaded[$class])) {                $this->loaded[$class] = true;                if (!$file = $this->classLoader[0]->findFile($class) ?: false) {                    // no-op                } elseif (\function_exists('opcache_is_script_cached') && @opcache_is_script_cached($file)) {                    include $file;                    return;                } elseif (false === include $file) {                    return;                }            } else {                ($this->classLoader)($class);                $file = false;            }        } finally {            error_reporting($e);        }        $this->checkClass($class, $file);    }    private function checkClass(string $class, string $file = null)    {        $exists = null === $file || class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);        if (null !== $file && $class && '\\' === $class[0]) {            $class = substr($class, 1);        }        if ($exists) {            if (isset(self::$checkedClasses[$class])) {                return;            }            self::$checkedClasses[$class] = true;            $refl = new \ReflectionClass($class);            if (null === $file && $refl->isInternal()) {                return;            }            $name = $refl->getName();            if ($name !== $class && 0 === strcasecmp($name, $class)) {                throw new \RuntimeException(sprintf('Case mismatch between loaded and declared class names: ""%s"" vs ""%s"".', $class, $name));            }            $deprecations = $this->checkAnnotations($refl, $name);            foreach ($deprecations as $message) {                @trigger_error($message, \E_USER_DEPRECATED);            }        }        if (!$file) {            return;        }        if (!$exists) {            if (false !== strpos($class, '/')) {                throw new \RuntimeException(sprintf('Trying to autoload a class with an invalid name ""%s"". Be careful that the namespace separator is ""\"" in PHP, not ""/"".', $class));            }            throw new \RuntimeException(sprintf('The autoloader expected class ""%s"" to be defined in file ""%s"". The file was found but the class was not in it, the class name or namespace probably has a typo.', $class, $file));        }        if (self::$caseCheck && $message = $this->checkCase($refl, $file, $class)) {            throw new \RuntimeException(sprintf('Case mismatch between class and real file names: ""%s"" vs ""%s"" in ""%s"".', $message[0], $message[1], $message[2]));        }    }    public function checkAnnotations(\ReflectionClass $refl, $class)    {        $deprecations = [];        // Don't trigger deprecations for classes in the same vendor        if (2 > $len = 1 + (strpos($class, '\\') ?: strpos($class, '_'))) {            $len = 0;            $ns = '';        } else {            $ns = str_replace('_', '\\', substr($class, 0, $len));        }        // Detect annotations on the class        if (false !== $doc = $refl->getDocComment()) {            foreach (['final', 'deprecated', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    self::${$annotation}[$class] = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                }            }            if ($refl->isInterface() && false !== strpos($doc, 'method') && preg_match_all('#\n \* @method\s+(static\s+)?+(?:[\w\|&\[\]\\\]+\s+)?(\w+(?:\s*\([^\)]*\))?)+(.+?([[:punct:]]\s*)?)?(?=\r?\n \*(?: @|/$|\r?\n))#', $doc, $notice, \PREG_SET_ORDER)) {                foreach ($notice as $method) {                    $static = '' !== $method[1];                    $name = $method[2];                    $description = $method[3] ?? null;                    if (false === strpos($name, '(')) {                        $name .= '()';                    }                    if (null !== $description) {                        $description = trim($description);                        if (!isset($method[4])) {                            $description .= '.';                        }                    }                    self::$method[$class][] = [$class, $name, $static, $description];                }            }        }        $parent = get_parent_class($class);        $parentAndOwnInterfaces = $this->getOwnInterfaces($class, $parent ?: null);        if ($parent) {            $parentAndOwnInterfaces[$parent] = $parent;            if (!isset(self::$checkedClasses[$parent])) {                $this->checkClass($parent);            }            if (isset(self::$final[$parent])) {                $deprecations[] = sprintf('The ""%s"" class is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $parent, self::$final[$parent], $class);            }        }        // Detect if the parent is annotated        foreach ($parentAndOwnInterfaces + class_uses($class, false) as $use) {            if (!isset(self::$checkedClasses[$use])) {                $this->checkClass($use);            }            if (isset(self::$deprecated[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len) && !isset(self::$deprecated[$class])) {                $type = class_exists($class, false) ? 'class' : (interface_exists($class, false) ? 'interface' : 'trait');                $verb = class_exists($use, false) || interface_exists($class, false) ? 'extends' : (interface_exists($use, false) ? 'implements' : 'uses');                $deprecations[] = sprintf('The ""%s"" %s %s ""%s"" that is deprecated%s.', $class, $type, $verb, $use, self::$deprecated[$use]);            }            if (isset(self::$internal[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len)) {                $deprecations[] = sprintf('The ""%s"" %s is considered internal%s. It may change without further notice. You should not use it from ""%s"".', $use, class_exists($use, false) ? 'class' : (interface_exists($use, false) ? 'interface' : 'trait'), self::$internal[$use], $class);            }            if (isset(self::$method[$use])) {                if ($refl->isAbstract()) {                    if (isset(self::$method[$class])) {                        self::$method[$class] = array_merge(self::$method[$class], self::$method[$use]);                    } else {                        self::$method[$class] = self::$method[$use];                    }                } elseif (!$refl->isInterface()) {                    $hasCall = $refl->hasMethod('__call');                    $hasStaticCall = $refl->hasMethod('__callStatic');                    foreach (self::$method[$use] as $method) {                        [$interface, $name, $static, $description] = $method;                        if ($static ? $hasStaticCall : $hasCall) {                            continue;                        }                        $realName = substr($name, 0, strpos($name, '('));                        if (!$refl->hasMethod($realName) || !($methodRefl = $refl->getMethod($realName))->isPublic() || ($static && !$methodRefl->isStatic()) || (!$static && $methodRefl->isStatic())) {                            $deprecations[] = sprintf('Class ""%s"" should implement method ""%s::%s""%s', $class, ($static ? 'static ' : '').$interface, $name, null == $description ? '.' : ': '.$description);                        }                    }                }            }        }        if (trait_exists($class)) {            return $deprecations;        }        // Inherit @final, @internal and @param annotations for methods        self::$finalMethods[$class] = [];        self::$internalMethods[$class] = [];        self::$annotatedParameters[$class] = [];        foreach ($parentAndOwnInterfaces as $use) {            foreach (['finalMethods', 'internalMethods', 'annotatedParameters'] as $property) {                if (isset(self::${$property}[$use])) {                    self::${$property}[$class] = self::${$property}[$class] ? self::${$property}[$use] + self::${$property}[$class] : self::${$property}[$use];                }            }        }        foreach ($refl->getMethods(\ReflectionMethod::IS_PUBLIC | \ReflectionMethod::IS_PROTECTED) as $method) {            if ($method->class !== $class) {                continue;            }            if ($parent && isset(self::$finalMethods[$parent][$method->name])) {                [$declaringClass, $message] = self::$finalMethods[$parent][$method->name];                $deprecations[] = sprintf('The ""%s::%s()"" method is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);            }            if (isset(self::$internalMethods[$class][$method->name])) {                [$declaringClass, $message] = self::$internalMethods[$class][$method->name];                if (strncmp($ns, $declaringClass, $len)) {                    $deprecations[] = sprintf('The ""%s::%s()"" method is considered internal%s. It may change without further notice. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);                }            }            // To read method annotations            $doc = $method->getDocComment();            if (isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }                foreach (self::$annotatedParameters[$class][$method->name] as $parameterName => $deprecation) {                    if (!isset($definedParameters[$parameterName]) && !($doc && preg_match(""/\\n\\s+\\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\\\${$parameterName}\\b/"", $doc))) {                        $deprecations[] = sprintf($deprecation, $class);                    }                }            }            if (!$doc) {                continue;            }            $finalOrInternal = false;            foreach (['final', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    $message = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                    self::${$annotation.'Methods'}[$class][$method->name] = [$class, $message];                    $finalOrInternal = true;                }            }            if ($finalOrInternal || $method->isConstructor() || false === strpos($doc, '@param') || StatelessInvocation::class === $class) {                continue;            }            if (!preg_match_all('#\n\s+\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\$([a-zA-Z0-9_\x7f-\xff]++)#', $doc, $matches, \PREG_SET_ORDER)) {                continue;            }            if (!isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }            }            foreach ($matches as [, $parameterType, $parameterName]) {                if (!isset($definedParameters[$parameterName])) {                    $parameterType = trim($parameterType);                    self::$annotatedParameters[$class][$method->name][$parameterName] = sprintf('The ""%%s::%s()"" method will require a new ""%s$%s"" argument in the next major version of its %s ""%s"", not defining it is deprecated.', $method->name, $parameterType ? $parameterType.' ' : '', $parameterName, interface_exists($class) ? 'interface' : 'parent class', $method->class);                }            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_IpUtils_8805," Compares two IPv6 addresses.\n In case a subnet is given, it checks if it contains the request IP.\n\n @author David Soria Parra <dsp at php dot net>\n\n @see https://github.com/dsp/v6tools\n\n @param string $ip IPv6 address or subnet in CIDR notation\n\n @return bool Whether the IP is valid\n\n @throws \\RuntimeException When IPV6 support is not enabled\n","Poredi dve IPv6 adrese. U slučaju davanja podmreže, ona proverava da li sadrži IP zahtev","    public static function checkIp6(?string $requestIp, string $ip)    {        $cacheKey = $requestIp.'-'.$ip;        if (isset(self::$checkedIps[$cacheKey])) {            return self::$checkedIps[$cacheKey];        }        if (!((\extension_loaded('sockets') && \defined('AF_INET6')) || @inet_pton('::1'))) {            throw new \RuntimeException('Unable to check Ipv6. Check that PHP was not compiled with option ""disable-ipv6"".');        }        if (false !== strpos($ip, '/')) {            [$address, $netmask] = explode('/', $ip, 2);            if ('0' === $netmask) {                return (bool) unpack('n*', @inet_pton($address));            }            if ($netmask < 1 || $netmask > 128) {                return self::$checkedIps[$cacheKey] = false;            }        } else {            $address = $ip;            $netmask = 128;        }        $bytesAddr = unpack('n*', @inet_pton($address));        $bytesTest = unpack('n*', @inet_pton($requestIp));        if (!$bytesAddr || !$bytesTest) {            return self::$checkedIps[$cacheKey] = false;        }        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {            $left = $netmask - 16 * ($i - 1);            $left = ($left <= 16) ? $left : 16;            $mask = ~(0xffff >> $left) & 0xffff;            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {                return self::$checkedIps[$cacheKey] = false;            }        }        return self::$checkedIps[$cacheKey] = true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
firefly-iii_firefly-iii_breadcrumbs_832, Cuts away the middle of a string when it's very long.\\n\\n @param string $string\\n\\n @return string\\n,Odseče sredinu od stringa kada je veoma dugačka,"    function limitStringLength(string $string): string    {        $maxChars = 75;        $length   = \strlen($string);        $result   = $string;        if ($length > $maxChars) {            $result = substr_replace($string, ' ... ', (int)($maxChars / 2), $length - $maxChars);        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_RowEvolution_986," Returns a prettier, more comprehensible version of a row evolution label for display.\n","Vraća lepšu, razumljiviju verziju oznake evolucije reda za prikaz","    private function cleanOriginalLabel($label)    {        $label = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        $label = SafeDecodeLabel::decodeLabelSafe($label);        return $label;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1151," Prepare the version number.\n\n @todo Remove the error supression from str_replace() call.\n\n @param string $ver The string version, like ""2.6.21.2152"";\n\n @return float\n",Pripremite broj verzije,"    public function prepareVersionNo($ver)    {        $ver = str_replace(array('_', ' ', '/'), '.', $ver);        $arrVer = explode('.', $ver, 2);        if (isset($arrVer[1])) {            $arrVer[1] = @str_replace('.', '', $arrVer[1]); // @todo: treat strings versions.        }        return (float) implode('.', $arrVer);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_432, Determines if current source data is base64 encoded\\\\n\\\\n @return boolean\\\\n,Određuje da li su trenutni izvorni podaci base64 kodirani ,"    public function isBase64()    {        if (!is_string($this->data)) {            return false;        }        return base64_encode(base64_decode($this->data)) === str_replace([""\n"", ""\r""], '', $this->data);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Frame_6725," Returns the full contents of the file for this frame,\n if it's known.\n @return string|null\n","Vraća puni sadržaj datoteke za dati frejm, ako je poznat","    public function getFileContents()    {        if ($this->fileContentsCache === null && $filePath = $this->getFile()) {            // Leave the stage early when 'Unknown' or '[internal]' is passed            // this would otherwise raise an exception when            // open_basedir is enabled.            if ($filePath === ""Unknown"" || $filePath === '[internal]') {                return null;            }            try {                $this->fileContentsCache = file_get_contents($filePath);            } catch (ErrorException $exception) {                // Internal file paths of PHP extensions cannot be opened            }        }        return $this->fileContentsCache;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1643, Buffer incoming data until slave connection is available\\\\n and headers have been received\\\\n\\\\n @param string $data\\\\n,Podaci dolaze preko bafera dok ne bude dostupna pomoćna veza i zaglavlja se ne prime,"    public function handleData($data)    {        $this->incomingBuffer .= $data;        if ($this->connection && $this->isHeaderEnd($this->incomingBuffer)) {            $remoteAddress = (string) $this->incoming->getRemoteAddress();            $headersToReplace = [                'X-PHP-PM-Remote-IP' => \trim(\parse_url($remoteAddress, PHP_URL_HOST), '[]'),                'X-PHP-PM-Remote-Port' => \trim(\parse_url($remoteAddress, PHP_URL_PORT), '[]')            ];            $buffer = $this->replaceHeader($this->incomingBuffer, $headersToReplace);            $this->connection->write($buffer);            $this->incoming->removeListener('data', [$this, 'handleData']);            $this->incoming->pipe($this->connection);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_BufferingLogger_1725," A buffering logger that stacks logs for later.\n\n @author Nicolas Grekas <p@tchwork.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\BufferingLogger instead.\n",Loger bafera slaže evidencije za kasnije,"class BufferingLogger extends AbstractLogger{    private $logs = [];    /**     * @return void     */    public function log($level, $message, array $context = [])    {        $this->logs[] = [$level, $message, $context];    }    public function cleanLogs()    {        $logs = $this->logs;        $this->logs = [];        return $logs;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8045, Cleans or flushes output buffers up to target level.\n\n Resulting level can be greater than target level if a non-removable buffer has been encountered.\n\n @final\n,Čisti ili ispira izlazne bafere do ciljanog nivoa. Rezultatni nivo može biti veći od ciljnog ako je naišao na ne uklonjivi bafer,"    public function __toString()    {        return            sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText).""\r\n"".            $this->headers.""\r\n"".            $this->getContent();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_BodySummarizer_1389, Returns a summarized message body.\n,Prikazuje sažeto telo poruke,"    public function summarize(MessageInterface $message): ?string    {        return $this->truncateAt === null            ? \GuzzleHttp\Psr7\Message::bodySummary($message)            : \GuzzleHttp\Psr7\Message::bodySummary($message, $this->truncateAt);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_CompositeExpectation_418, Return the string summary of this composite expectation\\\\\\\\n\\\\\\\\n @return string\\\\\\\\n,Vrati string rezime složenog očekivanja,"    public function __toString()    {        $return = '[';        $parts = array();        foreach ($this->_expectations as $exp) {            $parts[] = (string) $exp;        }        $return .= implode(', ', $parts) . ']';        return $return;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_SlavePool_1678, Return a human-readable summary of the slaves in the pool.\\\\n\\\\n @return array\\\\n,Vratite čoveku čitljiv sažetak slaves-a u pool-u,"    public function getStatusSummary()    {        $map = [            'total' => Slave::ANY,            'ready' => Slave::READY,            'busy' => Slave::BUSY,            'created' => Slave::CREATED,            'registered' => Slave::REGISTERED,            'closed' => Slave::CLOSED        ];        return \array_map(function ($state) {            return \count($this->getByStatus($state));        }, $map);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
spatie_array-functions_array_functions_1062, Returns an array with the unique values from all the given arrays.\n\n @param \\array[] $arrays\n\n @return array\n,Prikazuje niz sa jedinstvenim vrednostima iz svih zadatih nizova,"function array_merge_values(array ...$arrays){    $allValues = array_reduce($arrays, static function ($carry, $array) {        return array_merge($carry, $array);    }, []);    return array_values(array_unique($allValues));}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PrestaShop_PrestaShop_CMSCategory_855, Return an array of all children of the current CMSCategory.\\\\n\\\\n @return PrestaShopCollection Collection of CMSCategory\\\\n,Vrati niz svih podređenih elemenata trenutne CMSCategorije,"    private function getAllChildren()    {        // Get children        $toDelete = [(int) $this->id];        $this->recursiveDelete($toDelete, (int) $this->id);        $toDelete = array_unique($toDelete);        // remove id of current CMSCategory because we want only ids of children        unset($toDelete[0]);        if (count($toDelete)) {            $children = new PrestaShopCollection('CMSCategory');            $children->where('id_cms_category', 'in', $toDelete);            return $children;        }        return $toDelete;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Apriori_811," Calculates frequent k item sets, where count($samples) == $k - 1.\n\n @param mixed[][] $samples\n\n @return mixed[][]\n","Izračunava česte k skupove predmeta, gde je count($samples) == $k - 1","    private function candidates(array $samples): array    {        $candidates = [];        foreach ($samples as $p) {            foreach ($samples as $q) {                if (count(array_merge(array_diff($p, $q), array_diff($q, $p))) != 2) {                    continue;                }                $candidate = array_values(array_unique(array_merge($p, $q)));                if ($this->contains($candidates, $candidate)) {                    continue;                }                foreach ($this->samples as $sample) {                    if ($this->subset($sample, $candidate)) {                        $candidates[] = $candidate;                        continue 2;                    }                }            }        }        return $candidates;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Integer_2969, Radical (or squarefree kernel)\\n The radical of a positive integer is the product of its distinct prime factors.\\n\\n @see    https://en.wikipedia.org/wiki/Radical_of_an_integer\\n @see    https://oeis.org/A007947\\n\\n @param  int $n\\n\\n @return int the radical of n\\n\\n @throws Exception\\\\OutOfBoundsException if n is < 1.\\n,Radikal (ili jezgro bez kvadrata) Radikal pozitivnog celog broja proizvod je njegovih različitih osnovnih faktora,    public static function radical(int $n): int    {        return \array_product(\array_unique(self::primeFactorization($n)));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_FunctionExtension_3331," XPath expression translator function extension.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-FranÃ§ois Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n",Proširenje funkcije prevodioca izraza XPath. Ova komponenta je port Python cssselect biblioteke,"class FunctionExtension extends AbstractExtension{    /**     * {@inheritdoc}     */    public function getFunctionTranslators(): array    {        return [            'nth-child' => [$this, 'translateNthChild'],            'nth-last-child' => [$this, 'translateNthLastChild'],            'nth-of-type' => [$this, 'translateNthOfType'],            'nth-last-of-type' => [$this, 'translateNthLastOfType'],            'contains' => [$this, 'translateContains'],            'lang' => [$this, 'translateLang'],        ];    }    /**     * @throws ExpressionErrorException     */    public function translateNthChild(XPathExpr $xpath, FunctionNode $function, bool $last = false, bool $addNameTest = true): XPathExpr    {        try {            [$a, $b] = Parser::parseSeries($function->getArguments());        } catch (SyntaxErrorException $e) {            throw new ExpressionErrorException(sprintf('Invalid series: ""%s"".', implode('"", ""', $function->getArguments())), 0, $e);        }        $xpath->addStarPrefix();        if ($addNameTest) {            $xpath->addNameTest();        }        if (0 === $a) {            return $xpath->addCondition('position() = '.($last ? 'last() - '.($b - 1) : $b));        }        if ($a < 0) {            if ($b < 1) {                return $xpath->addCondition('false()');            }            $sign = '<=';        } else {            $sign = '>=';        }        $expr = 'position()';        if ($last) {            $expr = 'last() - '.$expr;            --$b;        }        if (0 !== $b) {            $expr .= ' - '.$b;        }        $conditions = [sprintf('%s %s 0', $expr, $sign)];        if (1 !== $a && -1 !== $a) {            $conditions[] = sprintf('(%s) mod %d = 0', $expr, $a);        }        return $xpath->addCondition(implode(' and ', $conditions));        // todo: handle an+b, odd, even        // an+b means every-a, plus b, e.g., 2n+1 means odd        // 0n+b means b        // n+0 means a=1, i.e., all elements        // an means every a elements, i.e., 2n means even        // -n means -1n        // -1n+6 means elements 6 and previous    }    public function translateNthLastChild(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        return $this->translateNthChild($xpath, $function, true);    }    public function translateNthOfType(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        return $this->translateNthChild($xpath, $function, false, false);    }    /**     * @throws ExpressionErrorException     */    public function translateNthLastOfType(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        if ('*' === $xpath->getElement()) {            throw new ExpressionErrorException('""*:nth-of-type()"" is not implemented.');        }        return $this->translateNthChild($xpath, $function, true, false);    }    /**     * @throws ExpressionErrorException     */    public function translateContains(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        $arguments = $function->getArguments();        foreach ($arguments as $token) {            if (!($token->isString() || $token->isIdentifier())) {                throw new ExpressionErrorException('Expected a single string or identifier for :contains(), got '.implode(', ', $arguments));            }        }        return $xpath->addCondition(sprintf(            'contains(string(.), %s)',            Translator::getXpathLiteral($arguments[0]->getValue())        ));    }    /**     * @throws ExpressionErrorException     */    public function translateLang(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        $arguments = $function->getArguments();        foreach ($arguments as $token) {            if (!($token->isString() || $token->isIdentifier())) {                throw new ExpressionErrorException('Expected a single string or identifier for :lang(), got '.implode(', ', $arguments));            }        }        return $xpath->addCondition(sprintf(            'lang(%s)',            Translator::getXpathLiteral($arguments[0]->getValue())        ));    }    /**     * {@inheritdoc}     */    public function getName(): string    {        return 'function';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
symfony_css-selector_Translator_3301," XPath expression translator interface.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-FranÃ§ois Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n",Interfejs prevodioca izraza XPath. Ova komponenta je port Python cssselect biblioteke,"class Translator implements TranslatorInterface{    private $mainParser;    /**     * @var ParserInterface[]     */    private $shortcutParsers = [];    /**     * @var Extension\ExtensionInterface[]     */    private $extensions = [];    private $nodeTranslators = [];    private $combinationTranslators = [];    private $functionTranslators = [];    private $pseudoClassTranslators = [];    private $attributeMatchingTranslators = [];    public function __construct(ParserInterface $parser = null)    {        $this->mainParser = $parser ?? new Parser();        $this            ->registerExtension(new Extension\NodeExtension())            ->registerExtension(new Extension\CombinationExtension())            ->registerExtension(new Extension\FunctionExtension())            ->registerExtension(new Extension\PseudoClassExtension())            ->registerExtension(new Extension\AttributeMatchingExtension())        ;    }    public static function getXpathLiteral(string $element): string    {        if (false === strpos($element, ""'"")) {            return ""'"".$element.""'"";        }        if (false === strpos($element, '""')) {            return '""'.$element.'""';        }        $string = $element;        $parts = [];        while (true) {            if (false !== $pos = strpos($string, ""'"")) {                $parts[] = sprintf(""'%s'"", substr($string, 0, $pos));                $parts[] = ""\""'\"""";                $string = substr($string, $pos + 1);            } else {                $parts[] = ""'$string'"";                break;            }        }        return sprintf('concat(%s)', implode(', ', $parts));    }    /**     * {@inheritdoc}     */    public function cssToXPath(string $cssExpr, string $prefix = 'descendant-or-self::'): string    {        $selectors = $this->parseSelectors($cssExpr);        /** @var SelectorNode $selector */        foreach ($selectors as $index => $selector) {            if (null !== $selector->getPseudoElement()) {                throw new ExpressionErrorException('Pseudo-elements are not supported.');            }            $selectors[$index] = $this->selectorToXPath($selector, $prefix);        }        return implode(' | ', $selectors);    }    /**     * {@inheritdoc}     */    public function selectorToXPath(SelectorNode $selector, string $prefix = 'descendant-or-self::'): string    {        return ($prefix ?: '').$this->nodeToXPath($selector);    }    /**     * @return $this     */    public function registerExtension(Extension\ExtensionInterface $extension): self    {        $this->extensions[$extension->getName()] = $extension;        $this->nodeTranslators = array_merge($this->nodeTranslators, $extension->getNodeTranslators());        $this->combinationTranslators = array_merge($this->combinationTranslators, $extension->getCombinationTranslators());        $this->functionTranslators = array_merge($this->functionTranslators, $extension->getFunctionTranslators());        $this->pseudoClassTranslators = array_merge($this->pseudoClassTranslators, $extension->getPseudoClassTranslators());        $this->attributeMatchingTranslators = array_merge($this->attributeMatchingTranslators, $extension->getAttributeMatchingTranslators());        return $this;    }    /**     * @throws ExpressionErrorException     */    public function getExtension(string $name): Extension\ExtensionInterface    {        if (!isset($this->extensions[$name])) {            throw new ExpressionErrorException(sprintf('Extension ""%s"" not registered.', $name));        }        return $this->extensions[$name];    }    /**     * @return $this     */    public function registerParserShortcut(ParserInterface $shortcut): self    {        $this->shortcutParsers[] = $shortcut;        return $this;    }    /**     * @throws ExpressionErrorException     */    public function nodeToXPath(NodeInterface $node): XPathExpr    {        if (!isset($this->nodeTranslators[$node->getNodeName()])) {            throw new ExpressionErrorException(sprintf('Node ""%s"" not supported.', $node->getNodeName()));        }        return $this->nodeTranslators[$node->getNodeName()]($node, $this);    }    /**     * @throws ExpressionErrorException     */    public function addCombination(string $combiner, NodeInterface $xpath, NodeInterface $combinedXpath): XPathExpr    {        if (!isset($this->combinationTranslators[$combiner])) {            throw new ExpressionErrorException(sprintf('Combiner ""%s"" not supported.', $combiner));        }        return $this->combinationTranslators[$combiner]($this->nodeToXPath($xpath), $this->nodeToXPath($combinedXpath));    }    /**     * @throws ExpressionErrorException     */    public function addFunction(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        if (!isset($this->functionTranslators[$function->getName()])) {            throw new ExpressionErrorException(sprintf('Function ""%s"" not supported.', $function->getName()));        }        return $this->functionTranslators[$function->getName()]($xpath, $function);    }    /**     * @throws ExpressionErrorException     */    public function addPseudoClass(XPathExpr $xpath, string $pseudoClass): XPathExpr    {        if (!isset($this->pseudoClassTranslators[$pseudoClass])) {            throw new ExpressionErrorException(sprintf('Pseudo-class ""%s"" not supported.', $pseudoClass));        }        return $this->pseudoClassTranslators[$pseudoClass]($xpath);    }    /**     * @throws ExpressionErrorException     */    public function addAttributeMatching(XPathExpr $xpath, string $operator, string $attribute, $value): XPathExpr    {        if (!isset($this->attributeMatchingTranslators[$operator])) {            throw new ExpressionErrorException(sprintf('Attribute matcher operator ""%s"" not supported.', $operator));        }        return $this->attributeMatchingTranslators[$operator]($xpath, $attribute, $value);    }    /**     * @return SelectorNode[]     */    private function parseSelectors(string $css): array    {        foreach ($this->shortcutParsers as $shortcut) {            $tokens = $shortcut->parse($css);            if (!empty($tokens)) {                return $tokens;            }        }        return $this->mainParser->parse($css);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
pagekit_pagekit_ExtensionTranslateCommand_892, Returns all files of an extension to extract translations.\\n\\n @param  string $path\\n @return array\\n,Vraća sve datoteke ekstenzije za izdvajanje prevoda,"    protected function getFiles($path, $extension)    {        $files = Finder::create()->files()->in($path);        if ($extension == ""system"") {            // add installer files            $files->in($this->container->path().'/app/installer');        }        return $files->name('*.{php,vue,js,html,twig}');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2167, Extracts the key from BITOP command.\n\n @param CommandInterface $command Command instance.\n\n @return string|null\n,Izdvaja ključ iz BITOP naredbe,"    protected function getKeyFromBitOp(CommandInterface $command)    {        $arguments = $command->getArguments();        if ($this->checkSameSlotForKeys(array_slice($arguments, 1, count($arguments)))) {            return $arguments[1];        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2170, Extracts the key from EVAL and EVALSHA commands.\\n\\n @param CommandInterface $command Command instance.\\n\\n @return string|null\\n,Izdvaja ključ iz naredbi EVAL i EVALSHA,"    protected function getKeyFromScriptingCommands(CommandInterface $command)    {        if ($command instanceof ScriptCommand) {            $keys = $command->getKeys();        } else {            $keys = array_slice($args = $command->getArguments(), 2, $args[1]);        }        if ($keys && $this->checkSameSlotForKeys($keys)) {            return $keys[0];        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_899, PHPWord settings class\\n\\n @since 0.8.0\\n,HPWord podešavanja klase,"class Settings{    /**     * Zip libraries     *     * @const string     */    const ZIPARCHIVE = 'ZipArchive';    const PCLZIP = 'PclZip';    const OLD_LIB = 'PhpOffice\\PhpWord\\Shared\\ZipArchive'; // @deprecated 0.11    /**     * PDF rendering libraries     *     * @const string     */    const PDF_RENDERER_DOMPDF = 'DomPDF';    const PDF_RENDERER_TCPDF = 'TCPDF';    const PDF_RENDERER_MPDF = 'MPDF';    /**     * Measurement units multiplication factor     *     * Applied to:     * - Section: margins, header/footer height, gutter, column spacing     * - Tab: position     * - Indentation: left, right, firstLine, hanging     * - Spacing: before, after     *     * @const string     */    const UNIT_TWIP = 'twip'; // = 1/20 point    const UNIT_CM = 'cm';    const UNIT_MM = 'mm';    const UNIT_INCH = 'inch';    const UNIT_POINT = 'point'; // = 1/72 inch    const UNIT_PICA = 'pica'; // = 1/6 inch = 12 points    /**     * Default font settings     *     * OOXML defined font size values in halfpoints, i.e. twice of what PhpWord     * use, and the conversion will be conducted during XML writing.     */    const DEFAULT_FONT_NAME = 'Arial';    const DEFAULT_FONT_SIZE = 10;    const DEFAULT_FONT_COLOR = '000000';    const DEFAULT_FONT_CONTENT_TYPE = 'default'; // default|eastAsia|cs    const DEFAULT_PAPER = 'A4';    /**     * Compatibility option for XMLWriter     *     * @var bool     */    private static $xmlWriterCompatibility = true;    /**     * Name of the class used for Zip file management     *     * @var string     */    private static $zipClass = self::ZIPARCHIVE;    /**     * Name of the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererName = null;    /**     * Directory Path to the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererPath = null;    /**     * Measurement unit     *     * @var int|float     */    private static $measurementUnit = self::UNIT_TWIP;    /**     * Default font name     *     * @var string     */    private static $defaultFontName = self::DEFAULT_FONT_NAME;    /**     * Default font size     * @var int     */    private static $defaultFontSize = self::DEFAULT_FONT_SIZE;    /**     * Default paper     * @var string     */    private static $defaultPaper = self::DEFAULT_PAPER;    /**     * The user defined temporary directory.     *     * @var string     */    private static $tempDir = '';    /**     * Enables built-in output escaping mechanism.     * Default value is `false` for backward compatibility with versions below 0.13.0.     *     * @var bool     */    private static $outputEscapingEnabled = false;    /**     * Return the compatibility option used by the XMLWriter     *     * @return bool Compatibility     */    public static function hasCompatibility()    {        return self::$xmlWriterCompatibility;    }    /**     * Set the compatibility option used by the XMLWriter     *     * This sets the setIndent and setIndentString for better compatibility     *     * @param bool $compatibility     * @return bool     */    public static function setCompatibility($compatibility)    {        $compatibility = (bool) $compatibility;        self::$xmlWriterCompatibility = $compatibility;        return true;    }    /**     * Get zip handler class     *     * @return string     */    public static function getZipClass()    {        return self::$zipClass;    }    /**     * Set zip handler class     *     * @param  string $zipClass     * @return bool     */    public static function setZipClass($zipClass)    {        if (in_array($zipClass, array(self::PCLZIP, self::ZIPARCHIVE, self::OLD_LIB))) {            self::$zipClass = $zipClass;            return true;        }        return false;    }    /**     * Set details of the external library for rendering PDF files     *     * @param string $libraryName     * @param string $libraryBaseDir     * @return bool Success or failure     */    public static function setPdfRenderer($libraryName, $libraryBaseDir)    {        if (!self::setPdfRendererName($libraryName)) {            return false;        }        return self::setPdfRendererPath($libraryBaseDir);    }    /**     * Return the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererName()    {        return self::$pdfRendererName;    }    /**     * Identify the external library to use for rendering PDF files     *     * @param string $libraryName     * @return bool     */    public static function setPdfRendererName($libraryName)    {        $pdfRenderers = array(self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_MPDF);        if (!in_array($libraryName, $pdfRenderers)) {            return false;        }        self::$pdfRendererName = $libraryName;        return true;    }    /**     * Return the directory path to the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererPath()    {        return self::$pdfRendererPath;    }    /**     * Location of external library to use for rendering PDF files     *     * @param string $libraryBaseDir Directory path to the library's base folder     * @return bool Success or failure     */    public static function setPdfRendererPath($libraryBaseDir)    {        if (false === file_exists($libraryBaseDir) || false === is_readable($libraryBaseDir)) {            return false;        }        self::$pdfRendererPath = $libraryBaseDir;        return true;    }    /**     * Get measurement unit     *     * @return string     */    public static function getMeasurementUnit()    {        return self::$measurementUnit;    }    /**     * Set measurement unit     *     * @param string $value     * @return bool     */    public static function setMeasurementUnit($value)    {        $units = array(self::UNIT_TWIP, self::UNIT_CM, self::UNIT_MM, self::UNIT_INCH,            self::UNIT_POINT, self::UNIT_PICA, );        if (!in_array($value, $units)) {            return false;        }        self::$measurementUnit = $value;        return true;    }    /**     * Sets the user defined path to temporary directory.     *     * @since 0.12.0     *     * @param string $tempDir The user defined path to temporary directory     */    public static function setTempDir($tempDir)    {        self::$tempDir = $tempDir;    }    /**     * Returns path to temporary directory.     *     * @since 0.12.0     *     * @return string     */    public static function getTempDir()    {        if (!empty(self::$tempDir)) {            $tempDir = self::$tempDir;        } else {            $tempDir = sys_get_temp_dir();        }        return $tempDir;    }    /**     * @since 0.13.0     *     * @return bool     */    public static function isOutputEscapingEnabled()    {        return self::$outputEscapingEnabled;    }    /**     * @since 0.13.0     *     * @param bool $outputEscapingEnabled     */    public static function setOutputEscapingEnabled($outputEscapingEnabled)    {        self::$outputEscapingEnabled = $outputEscapingEnabled;    }    /**     * Get default font name     *     * @return string     */    public static function getDefaultFontName()    {        return self::$defaultFontName;    }    /**     * Set default font name     *     * @param string $value     * @return bool     */    public static function setDefaultFontName($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultFontName = $value;            return true;        }        return false;    }    /**     * Get default font size     *     * @return int     */    public static function getDefaultFontSize()    {        return self::$defaultFontSize;    }    /**     * Set default font size     *     * @param int $value     * @return bool     */    public static function setDefaultFontSize($value)    {        $value = (int) $value;        if ($value > 0) {            self::$defaultFontSize = $value;            return true;        }        return false;    }    /**     * Load setting from phpword.yml or phpword.yml.dist     *     * @param string $filename     * @return array     */    public static function loadConfig($filename = null)    {        // Get config file        $configFile = null;        $configPath = __DIR__ . '/../../';        if ($filename !== null) {            $files = array($filename);        } else {            $files = array(""{$configPath}phpword.ini"", ""{$configPath}phpword.ini.dist"");        }        foreach ($files as $file) {            if (file_exists($file)) {                $configFile = realpath($file);                break;            }        }        // Parse config file        $config = array();        if ($configFile !== null) {            $config = @parse_ini_file($configFile);            if ($config === false) {                return $config;            }        }        // Set config value        foreach ($config as $key => $value) {            $method = ""set{$key}"";            if (method_exists(__CLASS__, $method)) {                self::$method($value);            }        }        return $config;    }    /**     * Get default paper     *     * @return string     */    public static function getDefaultPaper()    {        return self::$defaultPaper;    }    /**     * Set default paper     *     * @param string $value     * @return bool     */    public static function setDefaultPaper($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultPaper = $value;            return true;        }        return false;    }    /**     * Return the compatibility option used by the XMLWriter     *     * @deprecated 0.10.0     *     * @codeCoverageIgnore     */    public static function getCompatibility()    {        return self::hasCompatibility();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Driver_580, Returns clone of given core\n\n @return mixed\n,Vraća klon datog jezgra ,"    public function cloneCore($core)    {        $width = imagesx($core);        $height = imagesy($core);        $clone = imagecreatetruecolor($width, $height);        imagealphablending($clone, false);        imagesavealpha($clone, true);        $transparency = imagecolorallocatealpha($clone, 0, 0, 0, 127);        imagefill($clone, 0, 0, $transparency);                imagecopy($clone, $core, 0, 0, 0, 0, $width, $height);        return $clone;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Safe_179, Generate all the files in the output directory\n,Generišite sve datoteke u izlaznom direktorijumu,"    protected function generateFiles()    {        $includedHeaderFiles = $this->phalconH->generate();        $this->phalconC->generate($includedHeaderFiles);        $this->configM4->generate();        $this->configW32->generate();        copy($this->sourceDir . '/php_phalcon.h', $this->outputDir . '/php_phalcon.h');        $this->processKernelGlobals();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_BinaryFileResponse_8747, BinaryFileResponse represents an HTTP response delivering a file.\n\n @author Niklas Fiekas <niklas.fiekas@tu-clausthal.de>\n @author stealth35 <stealth35-php@live.fr>\n @author Igor Wiedler <igor@wiedler.ch>\n @author Jordan Alliot <jordan.alliot@gmail.com>\n @author Sergey Linnik <linniksa@gmail.com>\n,BinariFileResponse predstavlja HTTP odgovor,"class BinaryFileResponse extends Response{    protected static $trustXSendfileTypeHeader = false;    /**     * @var File     */    protected $file;    protected $offset = 0;    protected $maxlen = -1;    protected $deleteFileAfterSend = false;    /**     * @param \SplFileInfo|string $file               The file to stream     * @param int                 $status             The response status code     * @param array               $headers            An array of response headers     * @param bool                $public             Files are public by default     * @param string|null         $contentDisposition The type of Content-Disposition to set automatically with the filename     * @param bool                $autoEtag           Whether the ETag header should be automatically set     * @param bool                $autoLastModified   Whether the Last-Modified header should be automatically set     */    public function __construct($file, int $status = 200, array $headers = [], bool $public = true, string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)    {        parent::__construct(null, $status, $headers);        $this->setFile($file, $contentDisposition, $autoEtag, $autoLastModified);        if ($public) {            $this->setPublic();        }    }    /**     * @param \SplFileInfo|string $file               The file to stream     * @param int                 $status             The response status code     * @param array               $headers            An array of response headers     * @param bool                $public             Files are public by default     * @param string|null         $contentDisposition The type of Content-Disposition to set automatically with the filename     * @param bool                $autoEtag           Whether the ETag header should be automatically set     * @param bool                $autoLastModified   Whether the Last-Modified header should be automatically set     *     * @return static     *     * @deprecated since Symfony 5.2, use __construct() instead.     */    public static function create($file = null, int $status = 200, array $headers = [], bool $public = true, string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)    {        trigger_deprecation('symfony/http-foundation', '5.2', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($file, $status, $headers, $public, $contentDisposition, $autoEtag, $autoLastModified);    }    /**     * Sets the file to stream.     *     * @param \SplFileInfo|string $file The file to stream     *     * @return $this     *     * @throws FileException     */    public function setFile($file, string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)    {        if (!$file instanceof File) {            if ($file instanceof \SplFileInfo) {                $file = new File($file->getPathname());            } else {                $file = new File((string) $file);            }        }        if (!$file->isReadable()) {            throw new FileException('File must be readable.');        }        $this->file = $file;        if ($autoEtag) {            $this->setAutoEtag();        }        if ($autoLastModified) {            $this->setAutoLastModified();        }        if ($contentDisposition) {            $this->setContentDisposition($contentDisposition);        }        return $this;    }    /**     * Gets the file.     *     * @return File The file to stream     */    public function getFile()    {        return $this->file;    }    /**     * Automatically sets the Last-Modified header according the file modification date.     */    public function setAutoLastModified()    {        $this->setLastModified(\DateTime::createFromFormat('U', $this->file->getMTime()));        return $this;    }    /**     * Automatically sets the ETag header according to the checksum of the file.     */    public function setAutoEtag()    {        $this->setEtag(base64_encode(hash_file('sha256', $this->file->getPathname(), true)));        return $this;    }    /**     * Sets the Content-Disposition header with the given filename.     *     * @param string $disposition      ResponseHeaderBag::DISPOSITION_INLINE or ResponseHeaderBag::DISPOSITION_ATTACHMENT     * @param string $filename         Optionally use this UTF-8 encoded filename instead of the real name of the file     * @param string $filenameFallback A fallback filename, containing only ASCII characters. Defaults to an automatically encoded filename     *     * @return $this     */    public function setContentDisposition(string $disposition, string $filename = '', string $filenameFallback = '')    {        if ('' === $filename) {            $filename = $this->file->getFilename();        }        if ('' === $filenameFallback && (!preg_match('/^[\x20-\x7e]*$/', $filename) || false !== strpos($filename, '%'))) {            $encoding = mb_detect_encoding($filename, null, true) ?: '8bit';            for ($i = 0, $filenameLength = mb_strlen($filename, $encoding); $i < $filenameLength; ++$i) {                $char = mb_substr($filename, $i, 1, $encoding);                if ('%' === $char || \ord($char) < 32 || \ord($char) > 126) {                    $filenameFallback .= '_';                } else {                    $filenameFallback .= $char;                }            }        }        $dispositionHeader = $this->headers->makeDisposition($disposition, $filename, $filenameFallback);        $this->headers->set('Content-Disposition', $dispositionHeader);        return $this;    }    /**     * {@inheritdoc}     */    public function prepare(Request $request)    {        if (!$this->headers->has('Content-Type')) {            $this->headers->set('Content-Type', $this->file->getMimeType() ?: 'application/octet-stream');        }        if ('HTTP/1.0' !== $request->server->get('SERVER_PROTOCOL')) {            $this->setProtocolVersion('1.1');        }        $this->ensureIEOverSSLCompatibility($request);        $this->offset = 0;        $this->maxlen = -1;        if (false === $fileSize = $this->file->getSize()) {            return $this;        }        $this->headers->set('Content-Length', $fileSize);        if (!$this->headers->has('Accept-Ranges')) {            // Only accept ranges on safe HTTP methods            $this->headers->set('Accept-Ranges', $request->isMethodSafe() ? 'bytes' : 'none');        }        if (self::$trustXSendfileTypeHeader && $request->headers->has('X-Sendfile-Type')) {            // Use X-Sendfile, do not send any content.            $type = $request->headers->get('X-Sendfile-Type');            $path = $this->file->getRealPath();            // Fall back to scheme://path for stream wrapped locations.            if (false === $path) {                $path = $this->file->getPathname();            }            if ('x-accel-redirect' === strtolower($type)) {                // Do X-Accel-Mapping substitutions.                // @link https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/#x-accel-redirect                $parts = HeaderUtils::split($request->headers->get('X-Accel-Mapping', ''), ',=');                foreach ($parts as $part) {                    [$pathPrefix, $location] = $part;                    if (substr($path, 0, \strlen($pathPrefix)) === $pathPrefix) {                        $path = $location.substr($path, \strlen($pathPrefix));                        // Only set X-Accel-Redirect header if a valid URI can be produced                        // as nginx does not serve arbitrary file paths.                        $this->headers->set($type, $path);                        $this->maxlen = 0;                        break;                    }                }            } else {                $this->headers->set($type, $path);                $this->maxlen = 0;            }        } elseif ($request->headers->has('Range') && $request->isMethod('GET')) {            // Process the range headers.            if (!$request->headers->has('If-Range') || $this->hasValidIfRangeHeader($request->headers->get('If-Range'))) {                $range = $request->headers->get('Range');                if (0 === strpos($range, 'bytes=')) {                    [$start, $end] = explode('-', substr($range, 6), 2) + [0];                    $end = ('' === $end) ? $fileSize - 1 : (int) $end;                    if ('' === $start) {                        $start = $fileSize - $end;                        $end = $fileSize - 1;                    } else {                        $start = (int) $start;                    }                    if ($start <= $end) {                        $end = min($end, $fileSize - 1);                        if ($start < 0 || $start > $end) {                            $this->setStatusCode(416);                            $this->headers->set('Content-Range', sprintf('bytes */%s', $fileSize));                        } elseif ($end - $start < $fileSize - 1) {                            $this->maxlen = $end < $fileSize ? $end - $start + 1 : -1;                            $this->offset = $start;                            $this->setStatusCode(206);                            $this->headers->set('Content-Range', sprintf('bytes %s-%s/%s', $start, $end, $fileSize));                            $this->headers->set('Content-Length', $end - $start + 1);                        }                    }                }            }        }        return $this;    }    private function hasValidIfRangeHeader(?string $header): bool    {        if ($this->getEtag() === $header) {            return true;        }        if (null === $lastModified = $this->getLastModified()) {            return false;        }        return $lastModified->format('D, d M Y H:i:s').' GMT' === $header;    }    /**     * Sends the file.     *     * {@inheritdoc}     */    public function sendContent()    {        if (!$this->isSuccessful()) {            return parent::sendContent();        }        if (0 === $this->maxlen) {            return $this;        }        $out = fopen('php://output', 'w');        $file = fopen($this->file->getPathname(), 'r');        stream_copy_to_stream($file, $out, $this->maxlen, $this->offset);        fclose($out);        fclose($file);        if ($this->deleteFileAfterSend && is_file($this->file->getPathname())) {            unlink($this->file->getPathname());        }        return $this;    }    /**     * {@inheritdoc}     *     * @throws \LogicException when the content is not null     */    public function setContent(?string $content)    {        if (null !== $content) {            throw new \LogicException('The content cannot be set on a BinaryFileResponse instance.');        }        return $this;    }    /**     * {@inheritdoc}     */    public function getContent()    {        return false;    }    /**     * Trust X-Sendfile-Type header.     */    public static function trustXSendfileTypeHeader()    {        self::$trustXSendfileTypeHeader = true;    }    /**     * If this is set to true, the file will be unlinked after the request is sent     * Note: If the X-Sendfile header is used, the deleteFileAfterSend setting will not be used.     *     * @return $this     */    public function deleteFileAfterSend(bool $shouldDelete = true)    {        $this->deleteFileAfterSend = $shouldDelete;        return $this;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8916, Clones the current Response instance.\n,Klonira trenutnu instancu odgovora,"    public function sendHeaders()    {        // headers have already been sent by the developer        if (headers_sent()) {            return $this;        }        // headers        foreach ($this->headers->allPreserveCaseWithoutCookies() as $name => $values) {            $replace = 0 === strcasecmp($name, 'Content-Type');            foreach ($values as $value) {                header($name.': '.$value, $replace, $this->statusCode);            }        }        // cookies        foreach ($this->headers->getCookies() as $cookie) {            header('Set-Cookie: '.$cookie, false, $this->statusCode);        }        // status        header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText), true, $this->statusCode);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_ResponseHeaderBag_8965, ResponseHeaderBag is a container for Response HTTP headers.\n\n @author Fabien Potencier <fabien@symfony.com>\n,ResponseHeaderBag je kontejner za odgovor HTTP zaglavlja,"class ResponseHeaderBag extends HeaderBag{    public const COOKIES_FLAT = 'flat';    public const COOKIES_ARRAY = 'array';    public const DISPOSITION_ATTACHMENT = 'attachment';    public const DISPOSITION_INLINE = 'inline';    protected $computedCacheControl = [];    protected $cookies = [];    protected $headerNames = [];    public function __construct(array $headers = [])    {        parent::__construct($headers);        if (!isset($this->headers['cache-control'])) {            $this->set('Cache-Control', '');        }        /* RFC2616 - 14.18 says all Responses need to have a Date */        if (!isset($this->headers['date'])) {            $this->initDate();        }    }    /**     * Returns the headers, with original capitalizations.     *     * @return array An array of headers     */    public function allPreserveCase()    {        $headers = [];        foreach ($this->all() as $name => $value) {            $headers[$this->headerNames[$name] ?? $name] = $value;        }        return $headers;    }    public function allPreserveCaseWithoutCookies()    {        $headers = $this->allPreserveCase();        if (isset($this->headerNames['set-cookie'])) {            unset($headers[$this->headerNames['set-cookie']]);        }        return $headers;    }    /**     * {@inheritdoc}     */    public function replace(array $headers = [])    {        $this->headerNames = [];        parent::replace($headers);        if (!isset($this->headers['cache-control'])) {            $this->set('Cache-Control', '');        }        if (!isset($this->headers['date'])) {            $this->initDate();        }    }    /**     * {@inheritdoc}     */    public function all(string $key = null)    {        $headers = parent::all();        if (null !== $key) {            $key = strtr($key, self::UPPER, self::LOWER);            return 'set-cookie' !== $key ? $headers[$key] ?? [] : array_map('strval', $this->getCookies());        }        foreach ($this->getCookies() as $cookie) {            $headers['set-cookie'][] = (string) $cookie;        }        return $headers;    }    /**     * {@inheritdoc}     */    public function set(string $key, $values, bool $replace = true)    {        $uniqueKey = strtr($key, self::UPPER, self::LOWER);        if ('set-cookie' === $uniqueKey) {            if ($replace) {                $this->cookies = [];            }            foreach ((array) $values as $cookie) {                $this->setCookie(Cookie::fromString($cookie));            }            $this->headerNames[$uniqueKey] = $key;            return;        }        $this->headerNames[$uniqueKey] = $key;        parent::set($key, $values, $replace);        // ensure the cache-control header has sensible defaults        if (\in_array($uniqueKey, ['cache-control', 'etag', 'last-modified', 'expires'], true) && '' !== $computed = $this->computeCacheControlValue()) {            $this->headers['cache-control'] = [$computed];            $this->headerNames['cache-control'] = 'Cache-Control';            $this->computedCacheControl = $this->parseCacheControl($computed);        }    }    /**     * {@inheritdoc}     */    public function remove(string $key)    {        $uniqueKey = strtr($key, self::UPPER, self::LOWER);        unset($this->headerNames[$uniqueKey]);        if ('set-cookie' === $uniqueKey) {            $this->cookies = [];            return;        }        parent::remove($key);        if ('cache-control' === $uniqueKey) {            $this->computedCacheControl = [];        }        if ('date' === $uniqueKey) {            $this->initDate();        }    }    /**     * {@inheritdoc}     */    public function hasCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->computedCacheControl);    }    /**     * {@inheritdoc}     */    public function getCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->computedCacheControl) ? $this->computedCacheControl[$key] : null;    }    public function setCookie(Cookie $cookie)    {        $this->cookies[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie;        $this->headerNames['set-cookie'] = 'Set-Cookie';    }    /**     * Removes a cookie from the array, but does not unset it in the browser.     */    public function removeCookie(string $name, ?string $path = '/', string $domain = null)    {        if (null === $path) {            $path = '/';        }        unset($this->cookies[$domain][$path][$name]);        if (empty($this->cookies[$domain][$path])) {            unset($this->cookies[$domain][$path]);            if (empty($this->cookies[$domain])) {                unset($this->cookies[$domain]);            }        }        if (empty($this->cookies)) {            unset($this->headerNames['set-cookie']);        }    }    /**     * Returns an array with all cookies.     *     * @return Cookie[]     *     * @throws \InvalidArgumentException When the $format is invalid     */    public function getCookies(string $format = self::COOKIES_FLAT)    {        if (!\in_array($format, [self::COOKIES_FLAT, self::COOKIES_ARRAY])) {            throw new \InvalidArgumentException(sprintf('Format ""%s"" invalid (%s).', $format, implode(', ', [self::COOKIES_FLAT, self::COOKIES_ARRAY])));        }        if (self::COOKIES_ARRAY === $format) {            return $this->cookies;        }        $flattenedCookies = [];        foreach ($this->cookies as $path) {            foreach ($path as $cookies) {                foreach ($cookies as $cookie) {                    $flattenedCookies[] = $cookie;                }            }        }        return $flattenedCookies;    }    /**     * Clears a cookie in the browser.     */    public function clearCookie(string $name, ?string $path = '/', string $domain = null, bool $secure = false, bool $httpOnly = true, string $sameSite = null)    {        $this->setCookie(new Cookie($name, null, 1, $path, $domain, $secure, $httpOnly, false, $sameSite));    }    /**     * @see HeaderUtils::makeDisposition()     */    public function makeDisposition(string $disposition, string $filename, string $filenameFallback = '')    {        return HeaderUtils::makeDisposition($disposition, $filename, $filenameFallback);    }    /**     * Returns the calculated value of the cache-control header.     *     * This considers several other headers and calculates or modifies the     * cache-control header to a sensible, conservative value.     *     * @return string     */    protected function computeCacheControlValue()    {        if (!$this->cacheControl) {            if ($this->has('Last-Modified') || $this->has('Expires')) {                return 'private, must-revalidate'; // allows for heuristic expiration (RFC 7234 Section 4.2.2) in the case of ""Last-Modified""            }            // conservative by default            return 'no-cache, private';        }        $header = $this->getCacheControlHeader();        if (isset($this->cacheControl['public']) || isset($this->cacheControl['private'])) {            return $header;        }        // public if s-maxage is defined, private otherwise        if (!isset($this->cacheControl['s-maxage'])) {            return $header.', private';        }        return $header;    }    private function initDate(): void    {        $this->set('Date', gmdate('D, d M Y H:i:s').' GMT');    }}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_1288, Return a random message.\n @param array $messages\n @return $this\n,Vrati nasumičnu poruku,    public function randomReply(array $messages)    {        return $this->reply($messages[array_rand($messages)]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
typecho_typecho_HyperDown_1372, parseShtml\n\n @param array $lines\n @param mixed $value\n @param int $start\n @return string\n,Parsira html,"    private function parseSh(array $lines, $num, $start, $end)    {        $line = $this->markLine($start, $end) . $this->parseInline(trim($lines[0], '# '));        return preg_match(""/^\s*$/"", $line) ? '' : ""<h{$num}>{$line}</h{$num}>"";    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0
typecho_typecho_HyperDown_1375, parseMh\\n\\n @param array $lines\\n @param int $num\\n @param int $start\\n @param int $end\\n @return string\\n,parseMh,"    private function parseList(array $lines, $value, $start)    {        $html = '';        list($space, $type, $tab) = $value;        $rows = array();        $suffix = '';        $last = 0;        foreach ($lines as $key => $line) {            if (preg_match(""/^(\s{"" . $space . ""})((?:[0-9]+\.?)|\-|\+|\*)(\s+)(.*)$/i"", $line, $matches)) {                if ($type == 'ol' && $key == 0) {                    $start = intval($matches[2]);                    if ($start != 1) {                        $suffix = ' start=""' . $start . '""';                    }                }                $rows[] = [$matches[4]];                $last = count($rows) - 1;            } else {                $rows[$last][] = preg_replace(""/^\s{"" . ($tab + $space) . ""}/"", '', $line);            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Archive_2845, Class to work with archives\n\n @author      Magento Core Team <core@magentocommerce.com>\n,Klasa za rad sa arhivama,"class Archive{    /**     * Archiver is used for compress.     */    const DEFAULT_ARCHIVER = 'gz';    /**     * Default packer for directory.     */    const TAPE_ARCHIVER = 'tar';    /**     * Current archiver is used for compress.     *     * @var \Magento\Framework\Archive\Tar|\Magento\Framework\Archive\Gz|\Magento\Framework\Archive\Bz     */    protected $_archiver = null;    /**     * Accessible formats for compress.     *     * @var array     */    protected $_formats = [        'tar' => 'tar',        'gz' => 'gz',        'gzip' => 'gz',        'tgz' => 'tar.gz',        'tgzip' => 'tar.gz',        'bz' => 'bz',        'bzip' => 'bz',        'bzip2' => 'bz',        'bz2' => 'bz',        'tbz' => 'tar.bz',        'tbzip' => 'tar.bz',        'tbz2' => 'tar.bz',        'tbzip2' => 'tar.bz',    ];    /**     * Create object of current archiver by $extension.     *     * @param string $extension     * @return Tar|Gz|Bz     */    protected function _getArchiver($extension)    {        $extension = strtolower($extension);        $format = isset($this->_formats[$extension]) ? $this->_formats[$extension] : self::DEFAULT_ARCHIVER;        $class = '\\Magento\Framework\Archive\\' . ucfirst($format);        $this->_archiver = new $class();        return $this->_archiver;    }    /**     * Split current format to list of archivers.     *     * @param string $source     * @return string[]|string     */    protected function _getArchivers($source)    {        $ext = pathinfo($source, PATHINFO_EXTENSION);        if (!empty($this->_formats[$ext])) {            return explode('.', $this->_formats[$ext]);        }        return [];    }    /**     * Pack file or directory to archivers are parsed from extension.     *     * @param string $source     * @param string $destination     * @param boolean $skipRoot skip first level parent     * @return string Path to file     */    public function pack($source, $destination = 'packed.tgz', $skipRoot = false)    {        $archivers = $this->_getArchivers($destination);        $interimSource = '';        for ($i = 0, $count = count($archivers); $i < $count; $i++) {            if ($i == $count - 1) {                $packed = $destination;            } else {                $packed = dirname($destination) . '/~tmp-' . microtime(true) . $archivers[$i] . '.' . $archivers[$i];            }            $source = $this->_getArchiver($archivers[$i])->pack($source, $packed, $skipRoot);            if ($interimSource && $i < $count) {                unlink($interimSource);            }            $interimSource = $source;        }        return $source;    }    /**     * Unpack file from archivers are parsed from extension.     * If $tillTar == true unpack file from archivers till     * meet TAR archiver.     *     * @param string $source     * @param string $destination     * @param bool $tillTar     * @param bool $clearInterm     * @return string Path to file     */    public function unpack($source, $destination = '.', $tillTar = false, $clearInterm = true)    {        $archivers = $this->_getArchivers($source);        $interimSource = '';        for ($i = count($archivers) - 1; $i >= 0; $i--) {            if ($tillTar && $archivers[$i] == self::TAPE_ARCHIVER) {                break;            }            if ($i == 0) {                $packed = rtrim($destination, '/') . '/';            } else {                $packed = rtrim(                    $destination,                    '/'                ) . '/~tmp-' . microtime(                    true                ) . $archivers[$i - 1] . '.' . $archivers[$i - 1];            }            $source = $this->_getArchiver($archivers[$i])->unpack($source, $packed);            if ($clearInterm && $interimSource && $i >= 0) {                unlink($interimSource);            }            $interimSource = $source;        }        return $source;    }    /**     * Extract one file from TAR (Tape Archiver).     *     * @param string $file     * @param string $source     * @param string $destination     * @return string Path to file     */    public function extract($file, $source, $destination = '.')    {        $tarFile = $this->unpack($source, $destination, true);        $resFile = $this->_getArchiver(self::TAPE_ARCHIVER)->extract($file, $tarFile, $destination);        if (!$this->isTar($source)) {            unlink($tarFile);        }        return $resFile;    }    /**     * Check file is archive.     *     * @param string $file     * @return boolean     */    public function isArchive($file)    {        $archivers = $this->_getArchivers($file);        if (count($archivers)) {            return true;        }        return false;    }    /**     * Check file is TAR.     *     * @param string $file     * @return boolean     */    public function isTar($file)    {        $archivers = $this->_getArchivers($file);        if (count($archivers) == 1 && $archivers[0] == self::TAPE_ARCHIVER) {            return true;        }        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_IdenticalBinaryConstraint_2134, A binary safe string comparison.\n\n @author Chris Corbyn\n,Binarno sigurno poređenje nizova,"class IdenticalBinaryConstraint extends \PHPUnit\Framework\Constraint\Constraint{    protected $value;    public function __construct($value)    {        $this->value = $value;    }    /**     * Evaluates the constraint for parameter $other. Returns TRUE if the     * constraint is met, FALSE otherwise.     *     * @param mixed $other value or object to evaluate     */    public function matches($other): bool    {        $aHex = $this->asHexString($this->value);        $bHex = $this->asHexString($other);        return $aHex === $bHex;    }    /**     * Returns a string representation of the constraint.     */    public function toString(): string    {        return 'identical binary';    }    /**     * Get the given string of bytes as a stirng of Hexadecimal sequences.     *     * @param string $binary     *     * @return string     */    private function asHexString($binary)    {        $hex = '';        $bytes = unpack('H*', $binary);        foreach ($bytes as &$byte) {            $byte = strtoupper($byte);        }        return implode('', $bytes);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_IdenticalBinaryConstraint_239, Get the given string of bytes as a stirng of Hexadecimal sequences.\\n\\n @param string $binary\\n\\n @return string\\n,Dohvata dati niz bajtova kao string heksadecimalnih sekvenci,"    private function asHexString($binary)    {        $hex = '';        $bytes = unpack('H*', $binary);        foreach ($bytes as &$byte) {            $byte = strtoupper($byte);        }        return implode('', $bytes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
predis_predis_Autoloader_2121, Loads a class from a file using its fully qualified name.\\n\\n @param string $className Fully qualified name of a class.\\n,Učitava klasu iz datoteke koristeći potpuno kvalifikovano ime,"    public function autoload($className)    {        if (0 === strpos($className, $this->prefix)) {            $parts = explode('\\', substr($className, $this->prefixLength));            $filepath = $this->directory.DIRECTORY_SEPARATOR.implode(DIRECTORY_SEPARATOR, $parts).'.php';            if (is_file($filepath)) {                require $filepath;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_918, Constructs a file.\\n\\n @param string                   $path    The absolute path to the file to process.\\n @param \\\\PHP_CodeSniffer\\\\Ruleset $ruleset The ruleset used for the run.\\n @param \\\\PHP_CodeSniffer\\\\Config  $config  The config data for the run.\\n\\n @return void\\n,Izrađuje datoteku,"    public function __construct($path, Ruleset $ruleset, Config $config)    {        $this->path    = $path;        $this->ruleset = $ruleset;        $this->config  = $config;        $this->fixer   = new Fixer();        $parts     = explode('.', $path);        $extension = array_pop($parts);        if (isset($config->extensions[$extension]) === true) {            $this->tokenizerType = $config->extensions[$extension];        } else {            // Revert to default.            $this->tokenizerType = 'PHP';        }        $this->configCache['cache']           = $this->config->cache;        $this->configCache['sniffs']          = array_map('strtolower', $this->config->sniffs);        $this->configCache['exclude']         = array_map('strtolower', $this->config->exclude);        $this->configCache['errorSeverity']   = $this->config->errorSeverity;        $this->configCache['warningSeverity'] = $this->config->warningSeverity;        $this->configCache['recordErrors']    = $this->config->recordErrors;        $this->configCache['ignorePatterns']  = $this->ruleset->ignorePatterns;        $this->configCache['includePatterns'] = $this->ruleset->includePatterns;    }//end __construct()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_9679," Returns given value's item, if exists.\n\n @return AcceptHeaderItem|null\n",Vraća stavku date vrednosti ako postoji,"    public function get(string $value)    {        return $this->items[$value] ?? $this->items[explode('/', $value)[0].'/*'] ?? $this->items['*/*'] ?? $this->items['*'] ?? null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9843," Returns the prefix as encoded in the string when the string starts with\n the given prefix, null otherwise.\n","Vraća prefiks kodiran u stingu kada niz započinje sa datim prefiksom, u suprotnom ništa","    private function getUrlencodedPrefix(string $string, string $prefix): ?string    {        if (0 !== strpos(rawurldecode($string), $prefix)) {            return null;        }        $len = \strlen($prefix);        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {            return $match[0];        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1651, Checks whether the end of the header is in $buffer.\\\\n\\\\n @param string $buffer\\\\n\\\\n @return bool\\\\n,Proverava da li je kraj zaglavlja u $baffer,"    protected function isHeaderEnd($buffer)    {        return false !== \strpos($buffer, ""\r\n\r\n"");    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_966, Find the nearest block end position after $offset\n\n @param int $offset    Search position\n @param string  $blockType XML Block tag\n @return int -1 if block end not found\n,Pronađite najbliži krajnji položaj bloka nakon $offset,"    protected function findXmlBlockEnd($offset, $blockType)    {        $blockEndStart = strpos($this->tempDocumentMainPart, '</' . $blockType . '>', $offset);        // return position of end of tag if found, otherwise -1        return ($blockEndStart === false) ? -1 : $blockEndStart + 3 + strlen($blockType);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
symfony_http-foundation_IpUtils_8805," Compares two IPv6 addresses.\n In case a subnet is given, it checks if it contains the request IP.\n\n @author David Soria Parra <dsp at php dot net>\n\n @see https://github.com/dsp/v6tools\n\n @param string $ip IPv6 address or subnet in CIDR notation\n\n @return bool Whether the IP is valid\n\n @throws \\RuntimeException When IPV6 support is not enabled\n","Poredi dve IPv6 adrese. U slučaju davanja podmreže, ona proverava da li sadrži IP zahtev","    public static function checkIp6(?string $requestIp, string $ip)    {        $cacheKey = $requestIp.'-'.$ip;        if (isset(self::$checkedIps[$cacheKey])) {            return self::$checkedIps[$cacheKey];        }        if (!((\extension_loaded('sockets') && \defined('AF_INET6')) || @inet_pton('::1'))) {            throw new \RuntimeException('Unable to check Ipv6. Check that PHP was not compiled with option ""disable-ipv6"".');        }        if (false !== strpos($ip, '/')) {            [$address, $netmask] = explode('/', $ip, 2);            if ('0' === $netmask) {                return (bool) unpack('n*', @inet_pton($address));            }            if ($netmask < 1 || $netmask > 128) {                return self::$checkedIps[$cacheKey] = false;            }        } else {            $address = $ip;            $netmask = 128;        }        $bytesAddr = unpack('n*', @inet_pton($address));        $bytesTest = unpack('n*', @inet_pton($requestIp));        if (!$bytesAddr || !$bytesTest) {            return self::$checkedIps[$cacheKey] = false;        }        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {            $left = $netmask - 16 * ($i - 1);            $left = ($left <= 16) ? $left : 16;            $mask = ~(0xffff >> $left) & 0xffff;            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {                return self::$checkedIps[$cacheKey] = false;            }        }        return self::$checkedIps[$cacheKey] = true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
markrogoyski_math-php_ChiSquared_3079, Median - closed form approximation\n\n             /    2 \\Â³\n median â‰ˆ k | 1 - -  |\n             \\    k /\n\n @return float\n,Medijana - aproksimacija zatvorenog oblika,    public function median(): float    {        $k          = $this->k;        $âŸ®1Â âˆ’Â 2ï¼9kâŸ¯ = 1 - (2 / (9 * $k));        return $k * $âŸ®1Â âˆ’Â 2ï¼9kâŸ¯ ** 3;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
symfony_http-kernel_CacheWarmer_3109, Abstract cache warmer that knows how to write a file to the cache.\n\n @author Fabien Potencier <fabien@symfony.com>\n,Apstraktni grejač keš memorije koji zna kako da upiše datoteku u keš memoriju,class ChainCacheClearer implements CacheClearerInterface{    private $clearers;    public function __construct(iterable $clearers = [])    {        $this->clearers = $clearers;    }    /**     * {@inheritdoc}     */    public function clear(string $cacheDir)    {        foreach ($this->clearers as $clearer) {            $clearer->clear($cacheDir);        }    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
googleapis_google-api-php-client_Verify_673, Retrieve and cache a certificates file.\n\n @param $url string location\n @throws \\Google\\Exception\n @return array certificates\n,Preuzmite i keširajte datoteku sertifikata,"  private function retrieveCertsFromLocation($url)  {    // If we're retrieving a local file, just grab it.    if (0 !== strpos($url, 'http')) {      if (!$file = file_get_contents($url)) {        throw new GoogleException(            ""Failed to retrieve verification certificates: '"" .            $url . ""'.""        );      }      return json_decode($file, true);    }    $response = $this->http->get($url);    if ($response->getStatusCode() == 200) {      return json_decode((string) $response->getBody(), true);    }    throw new GoogleException(        sprintf(            'Failed to retrieve verification certificates: ""%s"".',            $response->getBody()->getContents()        ),        $response->getStatusCode()    );  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
pagekit_pagekit_ExtensionTranslateCommand_894, Writes the translation file for the given extension.\n\n @param array  $messages\n @param string $extension\n @param string $path\n,Piše datoteku prevoda za datu ekstenziju,"    protected function writeTranslationFile($messages, $extension, $path)    {        foreach ($messages as $domain => $strings) {            $data = $this->getHeader($extension, $domain);            foreach ($strings as $string) {                $string = str_replace('""', '\""', $string);                $data .= ""msgid \"""".$string.""\""\nmsgstr \""\""\n\n"";            }            $refFile = $path.'/'.$domain.'.pot';            if (!file_exists($refFile) || !($compare = preg_replace('/^""POT-Creation-Date: (.*)$/im', '', [file_get_contents($refFile), $data]) and $compare[0] === $compare[1])) {                file_put_contents($refFile, $data);            }        }    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0
phalcon_cphalcon_Safe_1568, Resolves headers in the php_phalcon.h file\n,Rešava zaglavlja u php_phalcon,"    protected function processKernelGlobals()    {        $lines = [];        foreach (file($this->outputDir . '/php_phalcon.h') as $line) {            if (preg_match('@^#include ""(kernel/.+)""@', $line, $matches)) {                $content = file_get_contents($this->sourceDir . DIRECTORY_SEPARATOR . $matches[1]);                $lines[] = $content . PHP_EOL;            } else {                $lines[] = $line;            }        }        file_put_contents($this->outputDir . '/php_phalcon.h', join('', $lines));    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
getgrav_grav_Composer_1482, Return the composer executable file path\\n\\n @return string\\n,Vrati putanju izvršne datoteke kompozera,"    public static function getComposerExecutor()    {        $executor = PHP_BINARY . ' ';        $composer = static::getComposerLocation();        if ($composer !== static::DEFAULT_PATH && is_executable($composer)) {            $file = fopen($composer, 'rb');            $firstLine = fgets($file);            fclose($file);            if (!preg_match('/^#!.+php/i', $firstLine)) {                $executor = '';            }        }        return $executor . $composer;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
squizlabs_PHP_CodeSniffer_Runner_913," Processes a single file, including checking and fixing.\\n\\n @param \\\\PHP_CodeSniffer\\\\Files\\\\File $file The file to be processed.\\n\\n @return void\\n @throws \\\\PHP_CodeSniffer\\\\Exceptions\\\\DeepExitException\\n","Obrađuje jednu datoteku, uključujući proveru i popravljanje","    public function processFile($file)    {        if (PHP_CODESNIFFER_VERBOSITY > 0) {            $startTime = microtime(true);            echo 'Processing '.basename($file->path).' ';            if (PHP_CODESNIFFER_VERBOSITY > 1) {                echo PHP_EOL;            }        }        try {            $file->process();            if (PHP_CODESNIFFER_VERBOSITY > 0) {                $timeTaken = ((microtime(true) - $startTime) * 1000);                if ($timeTaken < 1000) {                    $timeTaken = round($timeTaken);                    echo ""DONE in {$timeTaken}ms"";                } else {                    $timeTaken = round(($timeTaken / 1000), 2);                    echo ""DONE in $timeTaken secs"";                }                if (PHP_CODESNIFFER_CBF === true) {                    $errors = $file->getFixableCount();                    echo "" ($errors fixable violations)"".PHP_EOL;                } else {                    $errors   = $file->getErrorCount();                    $warnings = $file->getWarningCount();                    echo "" ($errors errors, $warnings warnings)"".PHP_EOL;                }            }        } catch (\Exception $e) {            $error = 'An error occurred during processing; checking has been aborted. The error message was: '.$e->getMessage();            $file->addErrorOnLine($error, 1, 'Internal.Exception');        }//end try        $this->reporter->cacheFileReport($file, $this->config);        if ($this->config->interactive === true) {            /*                Running interactively.                Print the error report for the current file and then wait for user input.            */            // Get current violations and then clear the list to make sure            // we only print violations for a single file each time.            $numErrors = null;            while ($numErrors !== 0) {                $numErrors = ($file->getErrorCount() + $file->getWarningCount());                if ($numErrors === 0) {                    continue;                }                $this->reporter->printReport('full');                echo '<ENTER> to recheck, [s] to skip or [q] to quit : ';                $input = fgets(STDIN);                $input = trim($input);                switch ($input) {                case 's':                    break(2);                case 'q':                    throw new DeepExitException('', 0);                default:                    // Repopulate the sniffs because some of them save their state                    // and only clear it when the file changes, but we are rechecking                    // the same file.                    $file->ruleset->populateTokenListeners();                    $file->reloadContent();                    $file->process();                    $this->reporter->cacheFileReport($file, $this->config);                    break;                }            }//end while        }//end if        // Clean up the file to save (a lot of) memory.        $file->cleanUp();    }//end processFile()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
phacility_phabricator_Figlet_519, Function loads one character in the internal array from file\\n\\n @param resource &$fp handle of font file\\n\\n @return mixed lines of the character or false if foef occured\\n @access private\\n,Funkcija učitava jedan znak u unutrašnjem nizu iz datoteke,"    function _char(&$fp)    {        $out = array();        for ($i = 0; $i < $this->height; $i++) {            if (feof($fp)) {                return false;            }            $line = rtrim(fgets($fp, 2048), ""\r\n"");            if (preg_match('/(.){1,2}$/', $line, $r)) {                $line = str_replace($r[1], '', $line);            }            $line .= ""\x00"";            $out[] = $line;        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
guzzle_guzzle_MessageFormatter_1408," Formats log messages using variable substitutions for requests, responses,\\n and other transactional data.\\n\\n The following variable substitutions are supported:\\n\\n - {request}:        Full HTTP request message\\n - {response}:       Full HTTP response message\\n - {ts}:             ISO 8601 date in GMT\\n - {date_iso_8601}   ISO 8601 date in GMT\\n - {date_common_log} Apache common log date using the configured timezone.\\n - {host}:           Host of the request\\n - {method}:         Method of the request\\n - {uri}:            URI of the request\\n - {version}:        Protocol version\\n - {target}:         Request target of the request (path + query + fragment)\\n - {hostname}:       Hostname of the machine that sent the request\\n - {code}:           Status code of the response (if available)\\n - {phrase}:         Reason phrase of the response  (if available)\\n - {error}:          Any error messages (if available)\\n - {req_header_ - {res_header_ - {req_headers}:    Request headers\\n - {res_headers}:    Response headers\\n - {req_body}:       Request body\\n - {res_body}:       Response body\\n\\n @final\\n","Formatira log poruke koristeći zamenu promenljivih za zahteve, odgovore, i druge podatke o transakcijama. Podržane su sledeće zamene promenljivih: \\ n \\ n - {zahtev}: Puna poruka HTTP zahteva \\ n - {response}: Potpuna HTTP poruka odgovora \\ n - {ts}: ISO 8601 datum u GMT \\ n - {date_iso_8601} ISO 8601 datum u GMT \\ n - {date_common_log} Apache zajednički datum evidencije pomoću konfigurisane vremenske zone. \\ n - {host}: Domaćin zahteva \\ n - {method}: Metod zahteva \\ n - {uri}: URI zahteva \\ n - {version}: Verzija protokola \\ n - {target}: Cilj zahteva (path + query + fragment) \\ n - {hostname}: Ime hosta mašine koja je poslala zahtev \\ n - {code}: Statusni odgovor odgovora (ako je dostupan) \ \ n - {phrase}: Fraza razloga odgovora (ako je dostupna) \\ n - {error}: Sve poruke o grešci (ako su dostupne) \\ n - {res_header_ - {res_header_ - {res_headers}: Zahtevanje zaglavlja \\ n - {res_headers}: Odgovor zaglavlja \\ n - {res_body}: Telo zahteva \\ n - {res_body}: Telo odgovora","class MessageFormatter implements MessageFormatterInterface{    /**     * Apache Common Log Format.     *     * @link https://httpd.apache.org/docs/2.4/logs.html#common     *     * @var string     */    public const CLF = ""{hostname} {req_header_User-Agent} - [{date_common_log}] \""{method} {target} HTTP/{version}\"" {code} {res_header_Content-Length}"";    public const DEBUG = "">>>>>>>>\n{request}\n<<<<<<<<\n{response}\n--------\n{error}"";    public const SHORT = '[{ts}] ""{method} {target} HTTP/{version}"" {code}';    /**     * @var string Template used to format log messages     */    private $template;    /**     * @param string $template Log message template     */    public function __construct(?string $template = self::CLF)    {        $this->template = $template ?: self::CLF;    }    /**     * Returns a formatted message string.     *     * @param RequestInterface       $request  Request that was sent     * @param ResponseInterface|null $response Response that was received     * @param \Throwable|null        $error    Exception that was received     */    public function format(RequestInterface $request, ?ResponseInterface $response = null, ?\Throwable $error = null): string    {        $cache = [];        /** @var string */        return \preg_replace_callback(            '/{\s*([A-Za-z_\-\.0-9]+)\s*}/',            function (array $matches) use ($request, $response, $error, &$cache) {                if (isset($cache[$matches[1]])) {                    return $cache[$matches[1]];                }                $result = '';                switch ($matches[1]) {                    case 'request':                        $result = Psr7\Message::toString($request);                        break;                    case 'response':                        $result = $response ? Psr7\Message::toString($response) : '';                        break;                    case 'req_headers':                        $result = \trim($request->getMethod()                                . ' ' . $request->getRequestTarget())                            . ' HTTP/' . $request->getProtocolVersion() . ""\r\n""                            . $this->headers($request);                        break;                    case 'res_headers':                        $result = $response ?                            \sprintf(                                'HTTP/%s %d %s',                                $response->getProtocolVersion(),                                $response->getStatusCode(),                                $response->getReasonPhrase()                            ) . ""\r\n"" . $this->headers($response)                            : 'NULL';                        break;                    case 'req_body':                        $result = $request->getBody()->__toString();                        break;                    case 'res_body':                        if (!$response instanceof ResponseInterface) {                            $result = 'NULL';                            break;                        }                        $body = $response->getBody();                        if (!$body->isSeekable()) {                            $result = 'RESPONSE_NOT_LOGGEABLE';                            break;                        }                        $result = $response->getBody()->__toString();                        break;                    case 'ts':                    case 'date_iso_8601':                        $result = \gmdate('c');                        break;                    case 'date_common_log':                        $result = \date('d/M/Y:H:i:s O');                        break;                    case 'method':                        $result = $request->getMethod();                        break;                    case 'version':                        $result = $request->getProtocolVersion();                        break;                    case 'uri':                    case 'url':                        $result = $request->getUri();                        break;                    case 'target':                        $result = $request->getRequestTarget();                        break;                    case 'req_version':                        $result = $request->getProtocolVersion();                        break;                    case 'res_version':                        $result = $response                            ? $response->getProtocolVersion()                            : 'NULL';                        break;                    case 'host':                        $result = $request->getHeaderLine('Host');                        break;                    case 'hostname':                        $result = \gethostname();                        break;                    case 'code':                        $result = $response ? $response->getStatusCode() : 'NULL';                        break;                    case 'phrase':                        $result = $response ? $response->getReasonPhrase() : 'NULL';                        break;                    case 'error':                        $result = $error ? $error->getMessage() : 'NULL';                        break;                    default:                        // handle prefixed dynamic headers                        if (\strpos($matches[1], 'req_header_') === 0) {                            $result = $request->getHeaderLine(\substr($matches[1], 11));                        } elseif (\strpos($matches[1], 'res_header_') === 0) {                            $result = $response                                ? $response->getHeaderLine(\substr($matches[1], 11))                                : 'NULL';                        }                }                $cache[$matches[1]] = $result;                return $result;            },            $this->template        );    }    /**     * Get headers from message as string     */    private function headers(MessageInterface $message): string    {        $result = '';        foreach ($message->getHeaders() as $name => $values) {            $result .= $name . ': ' . \implode(', ', $values) . ""\r\n"";        }        return \trim($result);    }}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LeastSquares_3612," SStot - The total Sum Squares\n\n the sum, over all observations, of the squared differences of\n each observation from the overall mean.\n https://en.wikipedia.org/wiki/Total_sum_of_squares\n\n For Simple Linear Regression\n SStot = âˆ‘(yáµ¢ - È³)Â²\n\n For Regression through a point\n SStot = âˆ‘yáµ¢Â²\n\n @return float\n\n @throws Exception\\BadDataException\n",SStot - Ukupni kvadrati sume \ n \ n zbroj kvadratnih razlika \ n svakog posmatranja od ukupne srednje vrednosti za sva posmatranja. \ N https://en.wikipedia.org/wiki/Total_sum_of_squares\n\n Za jednostavnu linearnu regresiju\n SStot = âˆ‘(yáµ¢ - È³)Â²\n\n Za regresiju kroz tečku\n SStot = âˆ‘yáµ¢Â²\n\n ,    public function sumOfSquaresTotal(): float    {        return $this->sumOfSquaresResidual() + $this->sumOfSquaresRegression();    },0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_48," Queries and returns metric data in an array.\\n\\n If multiple sites were requested in {@link build()} or {@link factory()} the result will\\n be indexed by site ID.\\n\\n If multiple periods were requested in {@link build()} or {@link factory()} the result will\\n be indexed by period.\\n\\n The site ID index is always first, so if multiple sites & periods were requested, the result\\n will be indexed by site ID first, then period.\\n\\n @param string|array $names One or more archive names, eg, `'nb_visits'`, `'Referrers_distinctKeywords'`,\\n                            etc.\\n @return false|integer|array `false` if there is no data to return, a single numeric value if we're not querying\\n                             for multiple sites/periods, or an array if multiple sites, periods or names are\\n                             queried for.\\n","Pravi upite i vraća metričke podatke u nizu. Ako je u {@link build()} ili {@link factory()} zatraženo više veb lokacija, rezultat će biti indeksiran prema ID-u lokacije. Ako je u {@link build()} ili {@link factory()} zatraženo više tačaka, rezultat će biti indeksiran po tačkama. Indeks ID-a mesta je uvek prvi, pa ako je zatraženo više lokacija i perioda, rezultat će se prvo indeksirati pomoću ID-a lokacije, a zatim tačke","    public function getNumeric($names)    {        $data = $this->get($names, 'numeric');        $resultIndices = $this->getResultIndices();        $result = $data->getIndexedArray($resultIndices);        // if only one metric is returned, just return it as a numeric value        if (empty($resultIndices)            && count($result) <= 1            && (!is_array($names) || count($names) === 1)        ) {            $result = (float)reset($result); // convert to float in case $result is empty        }        return $result;    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_54, Gets the IDs of the archives we're querying for and stores them in $this->archives.\\n This function will launch the archiving process for each period/site/plugin if\\n metrics/reports have not been calculated/archived already.\\n\\n @param array $archiveGroups @see getArchiveGroupOfReport\\n @param array $plugins List of plugin names to archive.\\n,Dobija ID-ove arhiva za koje tražimo i skladišti ih u $this->archives. Ova funkcija će pokrenuti postupak arhiviranja za svaki period/site/plugin ako metrike/izveštaji nisu već izračunate/arhivirane,"    private function cacheArchiveIdsAfterLaunching($archiveGroups, $plugins)    {        $today = Date::today();        foreach ($this->params->getPeriods() as $period) {            $twoDaysBeforePeriod = $period->getDateStart()->subDay(2);            $twoDaysAfterPeriod = $period->getDateEnd()->addDay(2);            foreach ($this->params->getIdSites() as $idSite) {                $site = new Site($idSite);                if (Common::getRequestVar('skipArchiveSegmentToday', 0, 'int')                    && self::shouldSkipArchiveIfSkippingSegmentArchiveForToday($site, $period, $this->params->getSegment())                ) {                    Log::debug(""Skipping archive %s for %s as segment today is disabled"", $period->getLabel(), $period->getPrettyString());                    continue;                }                // if the END of the period is BEFORE the website creation date                // we already know there are no stats for this period                // we add one day to make sure we don't miss the day of the website creation                if ($twoDaysAfterPeriod->isEarlier($site->getCreationDate())) {                    Log::debug(""Archive site %s, %s (%s) skipped, archive is before the website was created."",                        $idSite, $period->getLabel(), $period->getPrettyString());                    continue;                }                // if the starting date is in the future we know there is no visiidsite = ?t                if ($twoDaysBeforePeriod->isLater($today)) {                    Log::debug(""Archive site %s, %s (%s) skipped, archive is after today."",                        $idSite, $period->getLabel(), $period->getPrettyString());                    continue;                }                $this->prepareArchive($archiveGroups, $site, $period);            }        }    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_788," Returns archive IDs for the sites, periods and archive names that are being\n queried. This function will use the idarchive cache if it has the right data,\n query archive tables for IDs w/o launching archiving, or launch archiving and\n get the idarchive from ArchiveProcessor instances.\n\n @param string $archiveNames\n @return array\n","Prikazuje ID-ove arhive za lokacije, periode i imena arhiva za koja se vrši upit. Ova funkcija će koristiti keširanje idarchive ako ima prave podatke, šalje upite ka arhiviranim tabelama za ID-ove bez pokretanja arhiviranja ili sa pokrenutanjem arhiviranja i dobijanja idarchive iz instanci ArchiveProcessor-a","    private function getArchiveIds($archiveNames)    {        $plugins = $this->getRequestedPlugins($archiveNames);        // figure out which archives haven't been processed (if an archive has been processed,        // then we have the archive IDs in $this->idarchives)        $doneFlags     = array();        $archiveGroups = array();        foreach (array_merge($plugins, ['all']) as $plugin) {            $doneFlag = $this->getDoneStringForPlugin($plugin, $this->params->getIdSites());            $doneFlags[$doneFlag] = true;            if (!isset($this->idarchives[$doneFlag])) {                $archiveGroup = $this->getArchiveGroupOfPlugin($plugin);                if ($archiveGroup === self::ARCHIVE_ALL_PLUGINS_FLAG) {                    $archiveGroup = reset($plugins);                }                $archiveGroups[] = $archiveGroup;            }            $doneFlag = Rules::getDoneFlagArchiveContainsOnePlugin($this->params->getSegment(), $plugin);            $doneFlags[$doneFlag] = true;        }        $globalDoneFlag = Rules::getDoneFlagArchiveContainsAllPlugins($this->params->getSegment());        $doneFlags[$globalDoneFlag] = true;        $archiveGroups = array_unique($archiveGroups);        // cache id archives for plugins we haven't processed yet        if (!empty($archiveGroups)) {            if (Rules::isArchivingEnabledFor($this->params->getIdSites(), $this->params->getSegment(), $this->getPeriodLabel())                && !$this->forceFetchingWithoutLaunchingArchiving            ) {                $this->cacheArchiveIdsAfterLaunching($archiveGroups, $plugins);            } else {                $this->cacheArchiveIdsWithoutLaunching($plugins);            }        }        $idArchivesByMonth = $this->getIdArchivesByMonth($doneFlags);        return $idArchivesByMonth;    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_AbstractDoctrineExtension_1827, Register the alias for this mapping driver.\n\n Aliases can be used in the Query languages of all the Doctrine object managers to simplify writing tasks.\n,Registrujte pseudonim za ovaj drajver za mapiranje. Aliasi se mogu koristiti u jezicima upita svih Doctrine menadžera objekata radi pojednostavljenja zadataka pisanja,"    protected function registerMappingDrivers(array $objectManager, ContainerBuilder $container)    {        // configure metadata driver for each bundle based on the type of mapping files found        if ($container->hasDefinition($this->getObjectManagerElementName($objectManager['name'].'_metadata_driver'))) {            $chainDriverDef = $container->getDefinition($this->getObjectManagerElementName($objectManager['name'].'_metadata_driver'));        } else {            $chainDriverDef = new Definition($this->getMetadataDriverClass('driver_chain'));            $chainDriverDef->setPublic(false);        }        foreach ($this->drivers as $driverType => $driverPaths) {            $mappingService = $this->getObjectManagerElementName($objectManager['name'].'_'.$driverType.'_metadata_driver');            if ($container->hasDefinition($mappingService)) {                $mappingDriverDef = $container->getDefinition($mappingService);                $args = $mappingDriverDef->getArguments();                if ('annotation' == $driverType) {                    $args[1] = array_merge(array_values($driverPaths), $args[1]);                } else {                    $args[0] = array_merge(array_values($driverPaths), $args[0]);                }                $mappingDriverDef->setArguments($args);            } elseif ('attribute' === $driverType) {                $mappingDriverDef = new Definition($this->getMetadataDriverClass($driverType), [                    array_values($driverPaths),                ]);            } elseif ('annotation' == $driverType) {                $mappingDriverDef = new Definition($this->getMetadataDriverClass($driverType), [                    new Reference($this->getObjectManagerElementName('metadata.annotation_reader')),                    array_values($driverPaths),                ]);            } else {                $mappingDriverDef = new Definition($this->getMetadataDriverClass($driverType), [                    array_values($driverPaths),                ]);            }            $mappingDriverDef->setPublic(false);            if (false !== strpos($mappingDriverDef->getClass(), 'yml') || false !== strpos($mappingDriverDef->getClass(), 'xml')) {                $mappingDriverDef->setArguments([array_flip($driverPaths)]);                $mappingDriverDef->addMethodCall('setGlobalBasename', ['mapping']);            }            $container->setDefinition($mappingService, $mappingDriverDef);            foreach ($driverPaths as $prefix => $driverPath) {                $chainDriverDef->addMethodCall('addDriver', [new Reference($mappingService), $prefix]);            }        }        $container->setDefinition($this->getObjectManagerElementName($objectManager['name'].'_metadata_driver'), $chainDriverDef);    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_symfony_DoctrineDataCollector_1820, Sanitizes a param.\\n\\n The return value is an array with the sanitized value and a boolean\\n indicating if the original value was kept (allowing to use the sanitized\\n value to explain the query).\\n,Sanitizira parametar. Povratna vrednost je niz sa saniranom vrednošću i logičkom bojom koji pokazuje da li je izvorna vrednost zadržana (omogućavajući upotrebu sanirane vrednosti za objašnjenje upita),"class DoctrineValidationPass implements CompilerPassInterface{    private $managerType;    public function __construct(string $managerType)    {        $this->managerType = $managerType;    }    /**     * {@inheritdoc}     */    public function process(ContainerBuilder $container)    {        $this->updateValidatorMappingFiles($container, 'xml', 'xml');        $this->updateValidatorMappingFiles($container, 'yaml', 'yml');    }    /**     * Gets the validation mapping files for the format and extends them with     * files matching a doctrine search pattern (Resources/config/validation.orm.xml).     */    private function updateValidatorMappingFiles(ContainerBuilder $container, string $mapping, string $extension)    {        if (!$container->hasParameter('validator.mapping.loader.'.$mapping.'_files_loader.mapping_files')) {            return;        }        $files = $container->getParameter('validator.mapping.loader.'.$mapping.'_files_loader.mapping_files');        $validationPath = '/config/validation.'.$this->managerType.'.'.$extension;        foreach ($container->getParameter('kernel.bundles_metadata') as $bundle) {            if ($container->fileExists($file = $bundle['path'].'/Resources'.$validationPath) || $container->fileExists($file = $bundle['path'].$validationPath)) {                $files[] = $file;            }        }        $container->setParameter('validator.mapping.loader.'.$mapping.'_files_loader.mapping_files', $files);    }}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
firefly-iii_firefly-iii_User_743, Class User.\n\n @property int                                                                  $id\n @property string                                                               $email\n @property bool                                                                 $isAdmin\n @property bool                                                                 $has2FA\n @property array                                                                $prefs\n @property string                                                               $password\n @property string                                                               $mfa_secret\n @property Collection                                                           $roles\n @property string                                                               $blocked_code\n @property bool                                                                 $blocked\n @property Carbon|null                                                          $created_at\n @property Carbon|null                                                          $updated_at\n @property string|null                                                          $remember_token\n @property string|null                                                          $reset\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Account[]              $accounts\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Attachment[]           $attachments\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|AvailableBudget[]      $availableBudgets\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Bill[]                 $bills\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Budget[]               $budgets\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Category[]             $categories\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Client[]               $clients\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|CurrencyExchangeRate[] $currencyExchangeRates\n @property-read DatabaseNotificationCollection|DatabaseNotification[]           $notifications\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|PiggyBank[]            $piggyBanks\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Preference[]           $preferences\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Recurrence[]           $recurrences\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|RuleGroup[]            $ruleGroups\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Rule[]                 $rules\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Tag[]                  $tags\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Token[]                $tokens\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|TransactionGroup[]     $transactionGroups\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|TransactionJournal[]   $transactionJournals\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Transaction[]          $transactions\n @method static Builder|User newModelQuery()\n @method static Builder|User newQuery()\n @method static Builder|User query()\n @method static Builder|User whereBlocked($value)\n @method static Builder|User whereBlockedCode($value)\n @method static Builder|User whereCreatedAt($value)\n @method static Builder|User whereEmail($value)\n @method static Builder|User whereId($value)\n @method static Builder|User wherePassword($value)\n @method static Builder|User whereRememberToken($value)\n @method static Builder|User whereReset($value)\n @method static Builder|User whereUpdatedAt($value)\n @mixin Eloquent\n @property string|null                                                          $objectguid\n @property-read int|null                                                        $accounts_count\n @property-read int|null                                                        $attachments_count\n @property-read int|null                                                        $available_budgets_count\n @property-read int|null                                                        $bills_count\n @property-read int|null                                                        $budgets_count\n @property-read int|null                                                        $categories_count\n @property-read int|null                                                        $clients_count\n @property-read int|null                                                        $currency_exchange_rates_count\n @property-read int|null                                                        $notifications_count\n @property-read int|null                                                        $piggy_banks_count\n @property-read int|null                                                        $preferences_count\n @property-read int|null                                                        $recurrences_count\n @property-read int|null                                                        $roles_count\n @property-read int|null                                                        $rule_groups_count\n @property-read int|null                                                        $rules_count\n @property-read int|null                                                        $tags_count\n @property-read int|null                                                        $tokens_count\n @property-read int|null                                                        $transaction_groups_count\n @property-read int|null                                                        $transaction_journals_count\n @property-read int|null                                                        $transactions_count\n @method static \\Illuminate\\Database\\Eloquent\\Builder|\\FireflyIII\\User whereMfaSecret($value)\n @method static \\Illuminate\\Database\\Eloquent\\Builder|\\FireflyIII\\User whereObjectguid($value)\n @property string|null                                                          $provider\n @method static \\Illuminate\\Database\\Eloquent\\Builder|\\FireflyIII\\User whereProvider($value)\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|ObjectGroup[] $objectGroups\n @property-read int|null $object_groups_count\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Webhook[] $webhooks\n @property-read int|null $webhooks_count\n,Klasa korisnik (User),"class User extends Authenticatable{    use Notifiable, HasApiTokens;    /**     * The attributes that should be casted to native types.     *     * @var array     */    protected $casts        = [            'created_at' => 'datetime',            'updated_at' => 'datetime',            'blocked'    => 'boolean',        ];    /**     * The attributes that are mass assignable.     *     * @var array     */    protected $fillable = ['email', 'password', 'blocked', 'blocked_code'];    /**     * The attributes excluded from the model's JSON form.     *     * @var array     */    protected $hidden = ['password', 'remember_token'];    /**     * The database table used by the model.     *     * @var string     */    protected $table = 'users';    /**     * @param string $value     *     * @return User     * @throws NotFoundHttpException     */    public static function routeBinder(string $value): User    {        if (auth()->check()) {            $userId = (int)$value;            $user   = self::find($userId);            if (null !== $user) {                return $user;            }        }        throw new NotFoundHttpException;    }    /**     * @codeCoverageIgnore     * Link to accounts.     *     * @return HasMany     */    public function accounts(): HasMany    {        return $this->hasMany(Account::class);    }    /**     * @codeCoverageIgnore     * Link to attachments     *     * @return HasMany     */    public function attachments(): HasMany    {        return $this->hasMany(Attachment::class);    }    /**     * @codeCoverageIgnore     *     * Link to webhooks     *     * @return HasMany     */    public function webhooks(): HasMany    {        return $this->hasMany(Webhook::class);    }    /**     * @param string $role     *     * @return bool     */    public function hasRole(string $role): bool    {        return $this->roles()->where('name', $role)->count() === 1;    }    /**     * @codeCoverageIgnore     * Link to available budgets     *     * @return HasMany     */    public function availableBudgets(): HasMany    {        return $this->hasMany(AvailableBudget::class);    }    /**     * @codeCoverageIgnore     * Link to bills.     *     * @return HasMany     */    public function bills(): HasMany    {        return $this->hasMany(Bill::class);    }    /**     * @codeCoverageIgnore     * Link to budgets.     *     * @return HasMany     */    public function budgets(): HasMany    {        return $this->hasMany(Budget::class);    }    /**     * @codeCoverageIgnore     * Link to object groups.     *     * @return HasMany     */    public function objectGroups(): HasMany    {        return $this->hasMany(ObjectGroup::class);    }    /**     * @codeCoverageIgnore     * Link to categories     *     * @return HasMany     */    public function categories(): HasMany    {        return $this->hasMany(Category::class);    }    /**     * @codeCoverageIgnore     * Link to currency exchange rates     *     * @return HasMany     */    public function currencyExchangeRates(): HasMany    {        return $this->hasMany(CurrencyExchangeRate::class);    }    /**     * @codeCoverageIgnore     * Generates access token.     *     * @return string     * @throws Exception     */    public function generateAccessToken(): string    {        $bytes = random_bytes(16);        return bin2hex($bytes);    }    /**     * @codeCoverageIgnore     * Link to piggy banks.     *     * @return HasManyThrough     */    public function piggyBanks(): HasManyThrough    {        return $this->hasManyThrough(PiggyBank::class, Account::class);    }    /**     * @codeCoverageIgnore     * Link to preferences.     *     * @return HasMany     */    public function preferences(): HasMany    {        return $this->hasMany(Preference::class);    }    /**     * @codeCoverageIgnore     * Link to recurring transactions.     *     * @return HasMany     */    public function recurrences(): HasMany    {        return $this->hasMany(Recurrence::class);    }    /**     * @codeCoverageIgnore     * Link to roles.     *     * @return BelongsToMany     */    public function roles(): BelongsToMany    {        return $this->belongsToMany(Role::class);    }    /**     * @codeCoverageIgnore     * Link to rule groups.     *     * @return HasMany     */    public function ruleGroups(): HasMany    {        return $this->hasMany(RuleGroup::class);    }    /**     * @codeCoverageIgnore     * Link to rules.     *     * @return HasMany     */    public function rules(): HasMany    {        return $this->hasMany(Rule::class);    }    /**     * @codeCoverageIgnore     * Send the password reset notification.     *     * @param string $token     */    public function sendPasswordResetNotification($token): void    {        $ipAddress = Request::ip();        event(new RequestedNewPassword($this, $token, $ipAddress));    }    /**     * @codeCoverageIgnore     * Link to tags.     *     * @return HasMany     */    public function tags(): HasMany    {        return $this->hasMany(Tag::class);    }    /**     * @codeCoverageIgnore     * Link to transaction groups.     *     * @return HasMany     */    public function transactionGroups(): HasMany    {        return $this->hasMany(TransactionGroup::class);    }    /**     * @codeCoverageIgnore     * Link to transaction journals.     *     * @return HasMany     */    public function transactionJournals(): HasMany    {        return $this->hasMany(TransactionJournal::class);    }    /**     * @codeCoverageIgnore     * Link to transactions.     *     * @return HasManyThrough     */    public function transactions(): HasManyThrough    {        return $this->hasManyThrough(Transaction::class, TransactionJournal::class);    }}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_786, Returns Address ID for a given Supplier ID.\\\\\\\\n\\\\\\\\n @since 1.5.0\\\\\\\\n\\\\\\\\n @param int $id_supplier Supplier ID\\\\\\\\n\\\\\\\\n @return int $id_address Address ID\\\\\\\\n,Vraća ID adrese za dati ID dobavljača,    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    },3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_787, Check if the alias already exists.\\\\n\\\\n @param string $alias Alias of an address\\\\n @param int $id_address Address id\\\\n @param int $id_customer Customer id\\\\n\\\\n @return false|string|null Amount of aliases found\\\\n @todo: Find out if we shouldn't be returning an int instead? (breaking change)\\\\n,Proverite da li pseudonim već postoji,"    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
cakephp_cakephp_BaseAuthenticate_1176, Base Authentication class with common methods and properties.\\n,Osnovna klasa autentifikacije sa uobičajenim metodama i svojstvima,"abstract class BaseAuthenticate implements EventListenerInterface{    use InstanceConfigTrait;    use LocatorAwareTrait;    /**     * Default config for this object.     *     * - `fields` The fields to use to identify a user by.     * - `userModel` The alias for users table, defaults to Users.     * - `finder` The finder method to use to fetch user record. Defaults to 'all'.     *   You can set finder name as string or an array where key is finder name and value     *   is an array passed to `Table::find()` options.     *   E.g. ['finderName' => ['some_finder_option' => 'some_value']]     * - `passwordHasher` Password hasher class. Can be a string specifying class name     *    or an array containing `className` key, any other keys will be passed as     *    config to the class. Defaults to 'Default'.     *     * @var array     */    protected $_defaultConfig = [        'fields' => [            'username' => 'username',            'password' => 'password',        ],        'userModel' => 'Users',        'finder' => 'all',        'passwordHasher' => 'Default',    ];    /**     * A Component registry, used to get more components.     *     * @var \Cake\Controller\ComponentRegistry     */    protected $_registry;    /**     * Password hasher instance.     *     * @var \Cake\Auth\AbstractPasswordHasher|null     */    protected $_passwordHasher;    /**     * Whether or not the user authenticated by this class     * requires their password to be rehashed with another algorithm.     *     * @var bool     */    protected $_needsPasswordRehash = false;    /**     * Constructor     *     * @param \Cake\Controller\ComponentRegistry $registry The Component registry used on this request.     * @param array $config Array of config to use.     */    public function __construct(ComponentRegistry $registry, array $config = [])    {        $this->_registry = $registry;        $this->setConfig($config);    }    /**     * Find a user record using the username and password provided.     *     * Input passwords will be hashed even when a user doesn't exist. This     * helps mitigate timing attacks that are attempting to find valid usernames.     *     * @param string $username The username/identifier.     * @param string|null $password The password, if not provided password checking is skipped     *   and result of find is returned.     * @return array|false Either false on failure, or an array of user data.     */    protected function _findUser(string $username, ?string $password = null)    {        $result = $this->_query($username)->first();        if ($result === null) {            // Waste time hashing the password, to prevent            // timing side-channels. However, don't hash            // null passwords as authentication systems            // like digest auth don't use passwords            // and hashing *could* create a timing side-channel.            if ($password !== null) {                $hasher = $this->passwordHasher();                $hasher->hash($password);            }            return false;        }        $passwordField = $this->_config['fields']['password'];        if ($password !== null) {            $hasher = $this->passwordHasher();            $hashedPassword = $result->get($passwordField);            if ($hashedPassword === null || $hashedPassword === '') {                // Waste time hashing the password, to prevent                // timing side-channels to distinguish whether                // user has password or not.                $hasher->hash($password);                return false;            }            if (!$hasher->check($password, $hashedPassword)) {                return false;            }            $this->_needsPasswordRehash = $hasher->needsRehash($hashedPassword);            $result->unset($passwordField);        }        $hidden = $result->getHidden();        if ($password === null && in_array($passwordField, $hidden, true)) {            $key = array_search($passwordField, $hidden, true);            unset($hidden[$key]);            $result->setHidden($hidden);        }        return $result->toArray();    }    /**     * Get query object for fetching user from database.     *     * @param string $username The username/identifier.     * @return \Cake\ORM\Query     */    protected function _query(string $username): Query    {        $config = $this->_config;        $table = $this->getTableLocator()->get($config['userModel']);        $options = [            'conditions' => [$table->aliasField($config['fields']['username']) => $username],        ];        $finder = $config['finder'];        if (is_array($finder)) {            $options += current($finder);            $finder = key($finder);        }        if (!isset($options['username'])) {            $options['username'] = $username;        }        return $table->find($finder, $options);    }    /**     * Return password hasher object     *     * @return \Cake\Auth\AbstractPasswordHasher Password hasher instance     * @throws \RuntimeException If password hasher class not found or     *   it does not extend AbstractPasswordHasher     */    public function passwordHasher(): AbstractPasswordHasher    {        if ($this->_passwordHasher !== null) {            return $this->_passwordHasher;        }        $passwordHasher = $this->_config['passwordHasher'];        return $this->_passwordHasher = PasswordHasherFactory::build($passwordHasher);    }    /**     * Returns whether or not the password stored in the repository for the logged in user     * requires to be rehashed with another algorithm     *     * @return bool     */    public function needsPasswordRehash(): bool    {        return $this->_needsPasswordRehash;    }    /**     * Authenticate a user based on the request information.     *     * @param \Cake\Http\ServerRequest $request Request to get authentication information from.     * @param \Cake\Http\Response $response A response object that can have headers added.     * @return array|false Either false on failure, or an array of user data on success.     */    abstract public function authenticate(ServerRequest $request, Response $response);    /**     * Get a user based on information in the request. Primarily used by stateless authentication     * systems like basic and digest auth.     *     * @param \Cake\Http\ServerRequest $request Request object.     * @return array|false Either false or an array of user information     */    public function getUser(ServerRequest $request)    {        return false;    }    /**     * Handle unauthenticated access attempt. In implementation valid return values     * can be:     *     * - Null - No action taken, AuthComponent should return appropriate response.     * - Cake\Http\Response - A response object, which will cause AuthComponent to     *   simply return that response.     *     * @param \Cake\Http\ServerRequest $request A request object.     * @param \Cake\Http\Response $response A response object.     * @return \Cake\Http\Response|null|void     */    public function unauthenticated(ServerRequest $request, Response $response)    {    }    /**     * Returns a list of all events that this authenticate class will listen to.     *     * An authenticate class can listen to following events fired by AuthComponent:     *     * - `Auth.afterIdentify` - Fired after a user has been identified using one of     *   configured authenticate class. The callback function should have signature     *   like `afterIdentify(EventInterface $event, array $user)` when `$user` is the     *   identified user record.     *     * - `Auth.logout` - Fired when AuthComponent::logout() is called. The callback     *   function should have signature like `logout(EventInterface $event, array $user)`     *   where `$user` is the user about to be logged out.     *     * @return array List of events this class listens to. Defaults to `[]`.     */    public function implementedEvents(): array    {        return [];    }}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_1998, Add the debugger assets to the Grav Assets\\n\\n @return $this\\n,Dodaje debager u Grav Assets,"    public function addAssets()    {        if ($this->enabled) {            // Only add assets if Page is HTML            $page = $this->grav['page'];            if ($page->templateFormat() !== 'html') {                return $this;            }            /** @var Assets $assets */            $assets = $this->grav['assets'];            // Clockwork specific assets            if ($this->clockwork) {                $assets->addCss('/system/assets/debugger/clockwork.css', ['loading' => 'inline']);                $assets->addJs('/system/assets/debugger/clockwork.js', ['loading' => 'inline']);            }            // Debugbar specific assets            if ($this->debugbar) {                // Add jquery library                $assets->add('jquery', 101);                $this->renderer = $this->debugbar->getJavascriptRenderer();                $this->renderer->setIncludeVendors(false);                [$css_files, $js_files] = $this->renderer->getAssets(null, JavascriptRenderer::RELATIVE_URL);                foreach ((array)$css_files as $css) {                    $assets->addCss($css);                }                $assets->addCss('/system/assets/debugger/phpdebugbar.css', ['loading' => 'inline']);                foreach ((array)$js_files as $js) {                    $assets->addJs($js);                }            }        }        return $this;    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
humhub_humhub_AppDynamicAsset_2464, AppDynamicAsset provides assets which are included in the core layout.\n It similar to AppAsset but won't be compressed and combined.\n So it can handle dynamic assets (e.g. javascript locales)\n\n @since 1.2\n,"AppDynamicAsset pruža sredstva koja su uključena u osnovni izgled. Sličan je AppAsset-u, ali neće biti kompresovan i kombinovan. Dakle, može da obrađuje dinamička sredstva (npr. javascript lokalitete)",class AppDynamicAsset extends AssetBundle{    /**     * @inheritdoc     */    public $defer = false;    /**     * @inheritdoc     */    public $jsOptions = ['position' => View::POS_HEAD];    /**     * @inheritdoc     */    public $depends = [        JqueryTimeAgoLocaleAsset::class    ];},1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2874, Error processor\n\n @SuppressWarnings(PHPMD.TooManyFields)\n @SuppressWarnings(PHPMD.ExcessiveClassComplexity)\n phpcs:ignoreFile\n,Procesor grešaka,"class Processor{    const MAGE_ERRORS_LOCAL_XML = 'local.xml';    const MAGE_ERRORS_DESIGN_XML = 'design.xml';    const DEFAULT_SKIN = 'default';    const ERROR_DIR = 'pub/errors';    const NUMBER_SYMBOLS_IN_SUBDIR_NAME = 2;    /**     * Page title     *     * @var string     */    public $pageTitle;    /**     * Skin URL     *     * @var string     */    public $skinUrl;    /**     * Base URL     *     * @var string     */    public $baseUrl;    /**     * Post data     *     * @var array     */    public $postData;    /**     * Report data     *     * @var array     */    public $reportData;    /**     * Report action     *     * @var string     */    public $reportAction;    /**     * Report ID     *     * @var string     */    public $reportId;    /**     * Report file     *     * @var string     */    protected $_reportFile;    /**     * Show error message     *     * @var bool     */    public $showErrorMsg;    /**     * Show message after sending email     *     * @var bool     */    public $showSentMsg;    /**     * Show form for sending     *     * @var bool     */    public $showSendForm;    /**     * @var string     */    public $reportUrl;    /**     * Server script name     *     * @var string     */    protected $_scriptName;    /**     * Is root     *     * @var bool     */    protected $_root;    /**     * Internal config object     *     * @var \stdClass     */    protected $_config;    /**     * Http response     *     * @var Http     */    protected $_response;    /**     * JSON serializer     *     * @var Json     */    private $serializer;    /**     * @var Escaper     */    private $escaper;    /**     * @var DocumentRoot     */    private $documentRoot;    /**     * @param Http $response     * @param Json $serializer     * @param Escaper $escaper     * @param DocumentRoot|null $documentRoot     */    public function __construct(        Http $response,        Json $serializer = null,        Escaper $escaper = null,        DocumentRoot $documentRoot = null    ) {        $this->_response = $response;        $this->_errorDir  = __DIR__ . '/';        $this->_reportDir = dirname(dirname($this->_errorDir)) . '/var/report/';        $this->serializer = $serializer ?: ObjectManager::getInstance()->get(Json::class);        $this->escaper = $escaper ?: ObjectManager::getInstance()->get(Escaper::class);        $this->documentRoot = $documentRoot ?? ObjectManager::getInstance()->get(DocumentRoot::class);        if (!empty($_SERVER['SCRIPT_NAME'])) {            if (in_array(basename($_SERVER['SCRIPT_NAME'], '.php'), ['404', '503', 'report'])) {                $this->_scriptName = dirname($_SERVER['SCRIPT_NAME']);            } else {                $this->_scriptName = $_SERVER['SCRIPT_NAME'];            }        }        $this->_indexDir = $this->_getIndexDir();        $this->_root  = is_dir($this->_indexDir . 'app');        $this->_prepareConfig();        if (isset($_GET['skin'])) {            $this->_setSkin($_GET['skin']);        }        if (isset($_GET['id'])) {            $this->loadReport($_GET['id']);        }    }    /**     * Process no cache error     *     * @return \Magento\Framework\App\Response\Http     */    public function processNoCache()    {        $this->pageTitle = 'Error : cached config data is unavailable';        $this->_response->setBody($this->_renderPage('nocache.phtml'));        return $this->_response;    }    /**     * Process 404 error     *     * @return \Magento\Framework\App\Response\Http     */    public function process404()    {        $this->pageTitle = 'Error 404: Not Found';        $this->_response->setHttpResponseCode(404);        $this->_response->setBody($this->_renderPage('404.phtml'));        return $this->_response;    }    /**     * Process 503 error     *     * @return \Magento\Framework\App\Response\Http     */    public function process503()    {        $this->pageTitle = 'Error 503: Service Unavailable';        $this->_response->setHttpResponseCode(503);        $this->_response->setBody($this->_renderPage('503.phtml'));        return $this->_response;    }    /**     * Process report     *     * @return \Magento\Framework\App\Response\Http     */    public function processReport()    {        $this->pageTitle = 'There has been an error processing your request';        $this->_response->setHttpResponseCode(500);        $this->showErrorMsg = false;        $this->showSentMsg  = false;        $this->showSendForm = false;        $this->reportAction = $this->_config->action;        $this->_setReportUrl();        if ($this->reportAction == 'email') {            $this->showSendForm = true;            $this->sendReport();        }        $this->_response->setBody($this->_renderPage('report.phtml'));        return $this->_response;    }    /**     * Retrieve skin URL     *     * @return string     */    public function getViewFileUrl()    {        //The url needs to be updated base on Document root path.        $indexDir = str_replace('\\', '/', $this->_indexDir);        $errorDir = str_replace('\\', '/', $this->_errorDir);        $errorPathSuffix = $this->documentRoot->isPub() ? 'errors/' : 'pub/errors/';        $errorPath = strpos($errorDir, $indexDir) === 0 ?            str_replace($indexDir, '', $errorDir) : $errorPathSuffix;        return $this->getBaseUrl() . $errorPath . $this->_config->skin . '/';    }    /**     * Retrieve base host URL without path     *     * @return string     */    public function getHostUrl()    {        /**         * Define server http host         */        $host = $this->resolveHostName();        $isSecure = (!empty($_SERVER['HTTPS'])) && ($_SERVER['HTTPS'] !== 'off')            || isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && ($_SERVER['HTTP_X_FORWARDED_PROTO'] === 'https');        $url = ($isSecure ? 'https://' : 'http://') . $host;        $port = explode(':', $host);        if (isset($port[1]) && !in_array($port[1], [80, 443])            && !preg_match('/.*?\:[0-9]+$/', $url)        ) {            $url .= ':' . $port[1];        }        return  $url;    }    /**     * Resolve hostname     *     * @return string     */    private function resolveHostName() : string    {        if (!empty($_SERVER['HTTP_HOST'])) {            $host = $_SERVER['HTTP_HOST'];        } elseif (!empty($_SERVER['SERVER_NAME'])) {            $host = $_SERVER['SERVER_NAME'];        } else {            $host = 'localhost';        }        return $host;    }    /**     * Retrieve base URL     *     * @param bool $param     * @return string     */    public function getBaseUrl($param = false)    {        $path = $this->_scriptName;        if ($param && !$this->_root) {            $path = dirname($path);        }        $basePath = str_replace('\\', '/', dirname($path));        return $this->getHostUrl() . ('/' == $basePath ? '' : $basePath) . '/';    }    /**     * Retrieve client IP address     *     * @return string     */    protected function _getClientIp()    {        return (isset($_SERVER['REMOTE_ADDR'])) ? $_SERVER['REMOTE_ADDR'] : 'undefined';    }    /**     * Get index dir     *     * @return string     */    protected function _getIndexDir()    {        $documentRoot = '';        if (!empty($_SERVER['DOCUMENT_ROOT'])) {            $documentRoot = rtrim(realpath($_SERVER['DOCUMENT_ROOT']), '/');        }        return dirname($documentRoot . $this->_scriptName) . '/';    }    /**     * Prepare config data     *     * @return void     * @SuppressWarnings(PHPMD.CyclomaticComplexity)     * @SuppressWarnings(PHPMD.NPathComplexity)     */    protected function _prepareConfig()    {        $local  = $this->_loadXml(self::MAGE_ERRORS_LOCAL_XML);        $design = $this->_loadXml(self::MAGE_ERRORS_DESIGN_XML);        //initial settings        $config = new \stdClass();        $config->action         = '';        $config->subject        = 'Store Debug Information';        $config->email_address  = '';        $config->trash          = 'leave';        $config->skin           = self::DEFAULT_SKIN;        //combine xml data to one object        if ($design !== null && (string)$design->skin) {            $this->_setSkin((string)$design->skin, $config);        }        if ($local !== null) {            if ((string)$local->report->action) {                $config->action = $local->report->action;            }            if ((string)$local->report->subject) {                $config->subject = $local->report->subject;            }            if ((string)$local->report->email_address) {                $config->email_address = $local->report->email_address;            }            if ((string)$local->report->trash) {                $config->trash = $local->report->trash;            }            if ($local->report->dir_nesting_level) {                $config->dir_nesting_level = (int)$local->report->dir_nesting_level;            }            if ((string)$local->skin) {                $this->_setSkin((string)$local->skin, $config);            }        }        if ((string)$config->email_address == '' && (string)$config->action == 'email') {            $config->action = '';        }        $this->_config = $config;    }    /**     * Load xml file     *     * @param string $xmlFile     * @return \SimpleXMLElement     */    protected function _loadXml($xmlFile)    {        $configPath = $this->_getFilePath($xmlFile);        return ($configPath) ? simplexml_load_file($configPath) : null;    }    /**     * Render page     *     * @param string $template     * @return string     */    protected function _renderPage($template)    {        $baseTemplate = $this->_getTemplatePath('page.phtml');        $contentTemplate = $this->_getTemplatePath($template);        $html = '';        if ($baseTemplate && $contentTemplate) {            ob_start();            require_once $baseTemplate;            $html = ob_get_clean();        }        return $html;    }    /**     * Find file path     *     * @param string $file     * @param array $directories     * @return string     */    protected function _getFilePath($file, $directories = null)    {        if ($directories === null) {            $directories[] = $this->_errorDir;        }        foreach ($directories as $directory) {            if (file_exists($directory . $file)) {                return $directory . $file;            }        }    }    /**     * Find template path     *     * @param string $template     * @return string     */    protected function _getTemplatePath($template)    {        $directories[] = $this->_errorDir . $this->_config->skin . '/';        if ($this->_config->skin != self::DEFAULT_SKIN) {            $directories[] = $this->_errorDir . self::DEFAULT_SKIN . '/';        }        return $this->_getFilePath($template, $directories);    }    /**     * Set report data     *     * @param array $reportData     * @return void     */    protected function _setReportData($reportData)    {        $this->reportData = $reportData;        if (!isset($reportData['url'])) {            $this->reportData['url'] = '';        } else {            $this->reportData['url'] = $this->getHostUrl() . $reportData['url'];        }        if (isset($this->reportData['script_name'])) {            $this->_scriptName = $this->reportData['script_name'];        }    }    /**     * Create report     *     * @param array $reportData     * @return string     */    public function saveReport(array $reportData): string    {        $this->reportId = $reportData['report_id'];        $this->_reportFile = $this->getReportPath(            $this->getReportDirNestingLevel($this->reportId),            $this->reportId        );        $reportDirName = dirname($this->_reportFile);        if (!file_exists($reportDirName)) {            @mkdir($reportDirName, 0777, true);        }        $this->_setReportData($reportData);        @file_put_contents($this->_reportFile, $this->serializer->serialize($reportData). PHP_EOL);        if (isset($reportData['skin']) && self::DEFAULT_SKIN != $reportData['skin']) {            $this->_setSkin($reportData['skin']);        }        $this->_setReportUrl();        return $this->reportUrl;    }    /**     * Get report     *     * @param string $reportId     * @return void     */    public function loadReport($reportId)    {        try {            if (!$this->isReportIdValid($reportId)) {                throw new \RuntimeException(""Report Id is invalid"");            }            $reportFile = $this->findReportFile($reportId);            if (!is_readable($reportFile)) {                throw new \RuntimeException(""Report file cannot be read"");            }            $this->reportId = $reportId;            $this->_reportFile = $reportFile;            $this->_setReportData($this->serializer->unserialize(file_get_contents($this->_reportFile)));        } catch (\RuntimeException $e) {            $this->redirectToBaseUrl();        }    }    /**     * Searches for the report file and returns the path to it     *     * @param string $reportId     * @return string     * @throws \RuntimeException     */    private function findReportFile(string $reportId): string    {        $reportFile = $this->getReportPath(            $this->getReportDirNestingLevel($reportId),            $reportId        );        if (file_exists($reportFile)) {            return $reportFile;        }        $maxReportDirNestingLevel = $this->getMaxReportDirNestingLevel($reportId);        for ($i = 0; $i <= $maxReportDirNestingLevel; $i++) {            $reportFile = $this->getReportPath($i, $reportId);            if (file_exists($reportFile)) {                return $reportFile;            }        }        throw new \RuntimeException(""Report file not found"");    }    /**     * Redirect to a base url     * @return void     */    private function redirectToBaseUrl()    {        header(""Location: "" . $this->getBaseUrl());        die();    }    /**     * Checks report id     *     * @param string $reportId     * @return bool     */    private function isReportIdValid(string $reportId): bool    {        return (bool)preg_match('/[a-fA-F0-9]{64}/', $reportId);    }    /**     * Get path to reports     *     * @param integer $reportDirNestingLevel     * @param string $reportId     * @return string     */    private function getReportPath(int $reportDirNestingLevel, string $reportId): string    {        $reportDirPath = $this->_reportDir;        for ($i = 0, $j = 0; $j < $reportDirNestingLevel; $i += 2, $j++) {            $reportDirPath .= $reportId[$i] . $reportId[$i + 1] . '/';        }        return $reportDirPath . $reportId;    }    /**     * Returns nesting Level for the report files     *     * @var $reportId     * @return int     */    private function getReportDirNestingLevel(string $reportId): int    {        $envName = 'MAGE_ERROR_REPORT_DIR_NESTING_LEVEL';        $value = $_ENV[$envName] ?? getenv($envName);        if(false === $value && property_exists($this->_config, 'dir_nesting_level')) {            $value = $this->_config->dir_nesting_level;        }        $value = (int)$value;        $maxValue= $this->getMaxReportDirNestingLevel($reportId);        return 0 < $value && $maxValue >= $value ? $value : 0;    }    /**     * Returns maximum nesting level directories of report files     *     * @param string $reportId     * @return integer     */    private function getMaxReportDirNestingLevel(string $reportId): int    {        return (int)floor(strlen($reportId) / self::NUMBER_SYMBOLS_IN_SUBDIR_NAME);    }    /**     * Send report     *     * @return void     * @SuppressWarnings(PHPMD.CyclomaticComplexity)     * @SuppressWarnings(PHPMD.NPathComplexity)     */    public function sendReport()    {        $this->pageTitle = 'Error Submission Form';        $this->postData['firstName'] = (isset($_POST['firstname']))            ? trim($this->escaper->escapeHtml($_POST['firstname'])) : '';        $this->postData['lastName'] = (isset($_POST['lastname']))            ? trim($this->escaper->escapeHtml($_POST['lastname'])) : '';        $this->postData['email'] = (isset($_POST['email']))            ? trim($this->escaper->escapeHtml($_POST['email'])) : '';        $this->postData['telephone'] = (isset($_POST['telephone']))            ? trim($this->escaper->escapeHtml($_POST['telephone'])) : '';        $this->postData['comment'] = (isset($_POST['comment']))            ? trim($this->escaper->escapeHtml($_POST['comment'])) : '';        if (isset($_POST['submit'])) {            if ($this->_validate()) {                $msg  = ""URL: {$this->reportData['url']}\n""                    . ""IP Address: {$this->_getClientIp()}\n""                    . ""First Name: {$this->postData['firstName']}\n""                    . ""Last Name: {$this->postData['lastName']}\n""                    . ""Email Address: {$this->postData['email']}\n"";                if ($this->postData['telephone']) {                    $msg .= ""Telephone: {$this->postData['telephone']}\n"";                }                if ($this->postData['comment']) {                    $msg .= ""Comment: {$this->postData['comment']}\n"";                }                $subject = sprintf('%s [%s]', (string)$this->_config->subject, $this->reportId);                @mail((string)$this->_config->email_address, $subject, $msg);                $this->showSendForm = false;                $this->showSentMsg  = true;            } else {                $this->showErrorMsg = true;            }        } else {            $time = gmdate('Y-m-d H:i:s \G\M\T');            $msg = ""URL: {$this->reportData['url']}\n""                . ""IP Address: {$this->_getClientIp()}\n""                . ""Time: {$time}\n""                . ""Error:\n{$this->reportData[0]}\n\n""                . ""Trace:\n{$this->reportData[1]}"";            $subject = sprintf('%s [%s]', (string)$this->_config->subject, $this->reportId);            @mail((string)$this->_config->email_address, $subject, $msg);            if ($this->_config->trash == 'delete') {                @unlink($this->_reportFile);            }        }    }    /**     * Validate submitted post data     *     * @return bool     */    protected function _validate()    {        $email = preg_match(            '/^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,3})$/',            $this->postData['email']        );        return ($this->postData['firstName'] && $this->postData['lastName'] && $email);    }    /**     * Skin setter     *     * @param string $value     * @param \stdClass $config     * @return void     */    protected function _setSkin($value, \stdClass $config = null)    {        if (preg_match('/^[a-z0-9_]+$/i', $value) && is_dir($this->_errorDir . $value)) {            if (!$config) {                if ($this->_config) {                    $config = $this->_config;                }            }            if ($config) {                $config->skin = $value;            }        }    }    /**     * Set current report URL from current params     *     * @return void     */    protected function _setReportUrl()    {        if ($this->reportId && $this->_config && isset($this->_config->skin)) {            $this->reportUrl = ""{$this->getBaseUrl(true)}pub/errors/report.php?""                . http_build_query(['id' => $this->reportId, 'skin' => $this->_config->skin]);        }    }}",1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1354," Sets a value. If the key did not exist before it will be created.\\n\\n @param string $app app\\n @param string $key key\\n @param string|float|int $value value\\n @return bool True if the value was inserted or updated, false if the value was the same\\n",Postavlja vrednost. Ako ključ nije postojao pre nego što će biti stvoren,"public function setValue($app, $key, $value) {return $this->emittingCall(function (&$afterArray) use (&$app, &$key, &$value) {if (!$this->hasKey($app, $key)) {$inserted = (bool) $this->conn->insertIfNotExist('*PREFIX*appconfig', ['appid' => $app,'configkey' => $key,'configvalue' => $value,], ['appid','configkey',]);if ($inserted) {if (!isset($this->cache[$app])) {$this->cache[$app] = [];}$this->cache[$app][$key] = $value;return true;}}$sql = $this->conn->getQueryBuilder();$sql->update('appconfig')->set('configvalue', $sql->createParameter('configvalue'))->where($sql->expr()->eq('appid', $sql->createParameter('app')))->andWhere($sql->expr()->eq('configkey', $sql->createParameter('configkey')))->setParameter('configvalue', $value)->setParameter('app', $app)->setParameter('configkey', $key);/* * Only limit to the existing value for non-Oracle DBs: * http://docs.oracle.com/cd/E11882_01/server.112/e26088/conditions002.htm#i1033286 * > Large objects (LOBs) are not supported in comparison conditions. */if (!($this->conn instanceof \OC\DB\OracleConnection)) {// Only update the value when it is not the same$sql->andWhere($sql->expr()->neq('configvalue', $sql->createParameter('configvalue')))->setParameter('configvalue', $value);}if (isset($this->cache[$app], $this->cache[$app][$key])) {$afterArray['update'] = true;$afterArray['oldvalue'] = $this->cache[$app][$key];}$changedRow = (bool) $sql->execute();$this->cache[$app][$key] = $value;return $changedRow;}, [",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_8891, Prepares the path info.\n\n @return string path info\n,Priprema informacije o putanji,"    protected function preparePathInfo()    {        if (null === ($requestUri = $this->getRequestUri())) {            return '/';        }        // Remove the query string from REQUEST_URI        if (false !== $pos = strpos($requestUri, '?')) {            $requestUri = substr($requestUri, 0, $pos);        }        if ('' !== $requestUri && '/' !== $requestUri[0]) {            $requestUri = '/'.$requestUri;        }        if (null === ($baseUrl = $this->getBaseUrlReal())) {            return $requestUri;        }        $pathInfo = substr($requestUri, \strlen($baseUrl));        if (false === $pathInfo || '' === $pathInfo) {            // If substr() returns false then PATH_INFO is set to an empty string            return '/';        }        return (string) $pathInfo;    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_UrlHelper_8061, A helper service for manipulating URLs within and outside the request scope.\n\n @author Valentin Udaltsov <udaltsov.valentin@gmail.com>\n,Pomoćna usluga za manipulisanje URL-ovima unutar i izvan opsega zahteva,"final class UrlHelper{    private $requestStack;    private $requestContext;    public function __construct(RequestStack $requestStack, RequestContext $requestContext = null)    {        $this->requestStack = $requestStack;        $this->requestContext = $requestContext;    }    public function getAbsoluteUrl(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $this->getAbsoluteUrlFromContext($path);        }        if ('#' === $path[0]) {            $path = $request->getRequestUri().$path;        } elseif ('?' === $path[0]) {            $path = $request->getPathInfo().$path;        }        if (!$path || '/' !== $path[0]) {            $prefix = $request->getPathInfo();            $last = \strlen($prefix) - 1;            if ($last !== $pos = strrpos($prefix, '/')) {                $prefix = substr($prefix, 0, $pos).'/';            }            return $request->getUriForPath($prefix.$path);        }        return $request->getSchemeAndHttpHost().$path;    }    public function getRelativePath(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $path;        }        return $request->getRelativeUriForPath($path);    }    private function getAbsoluteUrlFromContext(string $path): string    {        if (null === $this->requestContext || '' === $host = $this->requestContext->getHost()) {            return $path;        }        $scheme = $this->requestContext->getScheme();        $port = '';        if ('http' === $scheme && 80 !== $this->requestContext->getHttpPort()) {            $port = ':'.$this->requestContext->getHttpPort();        } elseif ('https' === $scheme && 443 !== $this->requestContext->getHttpsPort()) {            $port = ':'.$this->requestContext->getHttpsPort();        }        if ('#' === $path[0]) {            $queryString = $this->requestContext->getQueryString();            $path = $this->requestContext->getPathInfo().($queryString ? '?'.$queryString : '').$path;        } elseif ('?' === $path[0]) {            $path = $this->requestContext->getPathInfo().$path;        }        if ('/' !== $path[0]) {            $path = rtrim($this->requestContext->getBaseUrl(), '/').'/'.$path;        }        return $scheme.'://'.$host.$port.$path;    }}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationControllerTest_2430, Test deleting an annotation.\n\n @dataProvider dataForEachAnnotations\n,Test brisanja anotacije,    public function getBuilderForAllByUser($userId)    {        return $this            ->getSortedQueryBuilderByUser($userId)        ;    },1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2419, Find last annotation for a given entry id. Used only for tests.\n\n @param int $entryId\n\n @return array\n,Pronađi poslednju napomenu za dati ID unosa. Koristi se samo za testove,"    public function removeAllByUserId($userId)    {        $this->getEntityManager()            ->createQuery('DELETE FROM Wallabag\AnnotationBundle\Entity\Annotation a WHERE a.user = :userId')            ->setParameter('userId', $userId)            ->execute();    }",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_444, Returns classname of given command name\\n\\n @param  string $name\\n @return string\\n,Vraća ime klase za dato imena naredbe,"    private function getCommandClassName($name)    {        $name = mb_convert_case($name[0], MB_CASE_UPPER, 'utf-8') . mb_substr($name, 1, mb_strlen($name));                $drivername = $this->getDriverName();        $classnameLocal = sprintf('\Intervention\Image\%s\Commands\%sCommand', $drivername, ucfirst($name));        $classnameGlobal = sprintf('\Intervention\Image\Commands\%sCommand', ucfirst($name));        if (class_exists($classnameLocal)) {            return $classnameLocal;        } elseif (class_exists($classnameGlobal)) {            return $classnameGlobal;        }        throw new NotSupportedException(            ""Command ({$name}) is not available for driver ({$drivername}).""        );    }",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_592, Calculates bounding box of current font setting\n\n @return Array\n,Izračunava granični okvir trenutne postavke fonta,"    public function getBoxSize()    {        $box = [];        if ($this->hasApplicableFontFile()) {            // imagettfbbox() converts numeric entities to their respective            // character. Preserve any originally double encoded entities to be            // represented as is.            // eg: &amp;#160; will render &#160; rather than its character.            $this->text = preg_replace('/&(#(?:x[a-fA-F0-9]+|[0-9]+);)/', '&#38;\1', $this->text);            $this->text = mb_encode_numericentity($this->text, array(0x0080, 0xffff, 0, 0xffff), 'UTF-8');            // get bounding box with angle 0            $box = imagettfbbox($this->getPointSize(), 0, $this->file, $this->text);            // rotate points manually            if ($this->angle != 0) {                $angle = pi() * 2 - $this->angle * pi() * 2 / 360;                for ($i=0; $i<4; $i++) {                    $x = $box[$i * 2];                    $y = $box[$i * 2 + 1];                    $box[$i * 2] = cos($angle) * $x - sin($angle) * $y;                    $box[$i * 2 + 1] = sin($angle) * $x + cos($angle) * $y;                }            }            $box['width'] = intval(abs($box[4] - $box[0]));            $box['height'] = intval(abs($box[5] - $box[1]));        } else {            // get current internal font size            $width = $this->getInternalFontWidth();            $height = $this->getInternalFontHeight();            if (strlen($this->text) == 0) {                // no text -> no boxsize                $box['width'] = 0;                $box['height'] = 0;            } else {                // calculate boxsize                $box['width'] = strlen($this->text) * $width;                $box['height'] = $height;            }        }        return $box;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_151, Wrap string values in quotes\\\\n\\\\n @param mixed $value\\\\n @return mixed\\\\n,Obmotajte vrednosti niza u navodnike,"    public static function wrapResult($value)    {        if (is_string($value)) {            //    Error values cannot be ""wrapped""            if (preg_match('/^'.self::CALCULATION_REGEXP_ERROR.'$/i', $value, $match)) {                //    Return Excel errors ""as is""                return $value;            }            //    Return strings wrapped in quotes            return '""'.$value.'""';        //    Convert numeric errors to NaN error        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {            return PHPExcel_Calculation_Functions::NaN();        }        return $value;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Eigenvalue_2614," Produces the Eigenvalues for square 2x2 - 4x4 matricies\n\n Given a matrix\n      [a b]\n A =  [c d]\n\n Find all Î» such that:\n      |A-IÎ»| = 0\n\n This is accomplished by finding the roots of the polyniomial that\n is produced when computing the determinant of the matrix. The determinant\n polynomial is calculated using polynomial arithmetic.\n\n @param NumericMatrix $A\n\n @return float[] of eigenvalues\n\n @throws Exception\\BadDataException if the matrix is not square\n @throws Exception\\BadDataException if the matrix is not 2x2, 3x3, or 4x4\n @throws Exception\\MathException\n",Izrađuje sopstvene vrednosti za kvadratne matrice 2x2 - 4x4 \ n \ n Dat je matrica [a b]\n A =  [c d]. Pronađi sve Î »takve da:  |A-IÎ»| = 0. To se postiže pronalaženjem korena poliniomija koji nastaje prilikom izračunavanja odrednice matrice. Odrednica polinom izračunava se pomoću polinomske aritmetike,"    public static function closedFormPolynomialRootMethod(NumericMatrix $A): array    {        self::checkMatrix($A);        $m = $A->getM();        if ($m < 2 || $m > 4) {            throw new Exception\BadDataException(""Matrix must be 2x2, 3x3, or 4x4. $m x $m given"");        }        // Convert the numerical matrix into an ObjectMatrix        $B_array = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $m; $j++) {                $B_array[$i][$j] = new Polynomial([$A[$i][$j]], 'Î»');            }        }        $B = MatrixFactory::create($B_array);        // Create a diagonal Matrix of lambda (IÎ»)        $Î»_poly    = new Polynomial([1, 0], 'Î»');        $zero_poly = new Polynomial([0], 'Î»');        $Î»_array   = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $m; $j++) {                $Î»_array[$i][$j] = ($i == $j)                    ? $Î»_poly                    : $zero_poly;            }        }        /** @var ObjectSquareMatrix $Î» */        $Î» = MatrixFactory::create($Î»_array);        /** @var ObjectSquareMatrix $âŸ®BÂ âˆ’Â Î»âŸ¯ Subtract IÎ» from B */        $âŸ®BÂ âˆ’Â Î»âŸ¯ = $B->subtract($Î»);        /** @var Polynomial $det The Eigenvalues are the roots of the determinant of this matrix */        $det = $âŸ®BÂ âˆ’Â Î»âŸ¯->det();        // Calculate the roots of the determinant.        $eigenvalues = $det->roots();        \usort($eigenvalues, function ($a, $b) {            return \abs($b) <=> \abs($a);        });        return $eigenvalues;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_BuilderHelpers_28, This class defines helpers used in the implementation of builders. Don't use it directly.\n\n @internal\n,Ova klasa definiše pomagače koji se koriste u implementaciji graditelja. Ne koristite ga direktno,"final class BuilderHelpers{    /**     * Normalizes a node: Converts builder objects to nodes.     *     * @param Node|Builder $node The node to normalize     *     * @return Node The normalized node     */    public static function normalizeNode($node) : Node {        if ($node instanceof Builder) {            return $node->getNode();        } elseif ($node instanceof Node) {            return $node;        }        throw new \LogicException('Expected node or builder object');    }    /**     * Normalizes a node to a statement.     *     * Expressions are wrapped in a Stmt\Expression node.     *     * @param Node|Builder $node The node to normalize     *     * @return Stmt The normalized statement node     */    public static function normalizeStmt($node) : Stmt {        $node = self::normalizeNode($node);        if ($node instanceof Stmt) {            return $node;        }        if ($node instanceof Expr) {            return new Stmt\Expression($node);        }        throw new \LogicException('Expected statement or expression node');    }    /**     * Normalizes strings to Identifier.     *     * @param string|Identifier $name The identifier to normalize     *     * @return Identifier The normalized identifier     */    public static function normalizeIdentifier($name) : Identifier {        if ($name instanceof Identifier) {            return $name;        }        if (\is_string($name)) {            return new Identifier($name);        }        throw new \LogicException('Expected string or instance of Node\Identifier');    }    /**     * Normalizes strings to Identifier, also allowing expressions.     *     * @param string|Identifier|Expr $name The identifier to normalize     *     * @return Identifier|Expr The normalized identifier or expression     */    public static function normalizeIdentifierOrExpr($name) {        if ($name instanceof Identifier || $name instanceof Expr) {            return $name;        }        if (\is_string($name)) {            return new Identifier($name);        }        throw new \LogicException('Expected string or instance of Node\Identifier or Node\Expr');    }    /**     * Normalizes a name: Converts string names to Name nodes.     *     * @param Name|string $name The name to normalize     *     * @return Name The normalized name     */    public static function normalizeName($name) : Name {        return self::normalizeNameCommon($name, false);    }    /**     * Normalizes a name: Converts string names to Name nodes, while also allowing expressions.     *     * @param Expr|Name|string $name The name to normalize     *     * @return Name|Expr The normalized name or expression     */    public static function normalizeNameOrExpr($name) {        return self::normalizeNameCommon($name, true);    }    /**     * Normalizes a name: Converts string names to Name nodes, optionally allowing expressions.     *     * @param Expr|Name|string $name      The name to normalize     * @param bool             $allowExpr Whether to also allow expressions     *     * @return Name|Expr The normalized name, or expression (if allowed)     */    private static function normalizeNameCommon($name, bool $allowExpr) {        if ($name instanceof Name) {            return $name;        } elseif (is_string($name)) {            if (!$name) {                throw new \LogicException('Name cannot be empty');            }            if ($name[0] === '\\') {                return new Name\FullyQualified(substr($name, 1));            } elseif (0 === strpos($name, 'namespace\\')) {                return new Name\Relative(substr($name, strlen('namespace\\')));            } else {                return new Name($name);            }        }        if ($allowExpr) {            if ($name instanceof Expr) {                return $name;            }            throw new \LogicException(                'Name must be a string or an instance of Node\Name or Node\Expr'            );        } else {            throw new \LogicException('Name must be a string or an instance of Node\Name');        }    }    /**     * Normalizes a type: Converts plain-text type names into proper AST representation.     *     * In particular, builtin types become Identifiers, custom types become Names and nullables     * are wrapped in NullableType nodes.     *     * @param string|Name|Identifier|NullableType|UnionType $type The type to normalize     *     * @return Name|Identifier|NullableType|UnionType The normalized type     */    public static function normalizeType($type) {        if (!is_string($type)) {            if (                !$type instanceof Name && !$type instanceof Identifier &&                !$type instanceof NullableType && !$type instanceof UnionType            ) {                throw new \LogicException(                    'Type must be a string, or an instance of Name, Identifier, NullableType or UnionType'                );            }            return $type;        }        $nullable = false;        if (strlen($type) > 0 && $type[0] === '?') {            $nullable = true;            $type = substr($type, 1);        }        $builtinTypes = [            'array', 'callable', 'string', 'int', 'float', 'bool', 'iterable', 'void', 'object', 'mixed'        ];        $lowerType = strtolower($type);        if (in_array($lowerType, $builtinTypes)) {            $type = new Identifier($lowerType);        } else {            $type = self::normalizeName($type);        }        if ($nullable && (string) $type === 'void') {            throw new \LogicException('void type cannot be nullable');        }        if ($nullable && (string) $type === 'mixed') {            throw new \LogicException('mixed type cannot be nullable');        }        return $nullable ? new NullableType($type) : $type;    }    /**     * Normalizes a value: Converts nulls, booleans, integers,     * floats, strings and arrays into their respective nodes     *     * @param Node\Expr|bool|null|int|float|string|array $value The value to normalize     *     * @return Expr The normalized value     */    public static function normalizeValue($value) : Expr {        if ($value instanceof Node\Expr) {            return $value;        } elseif (is_null($value)) {            return new Expr\ConstFetch(                new Name('null')            );        } elseif (is_bool($value)) {            return new Expr\ConstFetch(                new Name($value ? 'true' : 'false')            );        } elseif (is_int($value)) {            return new Scalar\LNumber($value);        } elseif (is_float($value)) {            return new Scalar\DNumber($value);        } elseif (is_string($value)) {            return new Scalar\String_($value);        } elseif (is_array($value)) {            $items = [];            $lastKey = -1;            foreach ($value as $itemKey => $itemValue) {                // for consecutive, numeric keys don't generate keys                if (null !== $lastKey && ++$lastKey === $itemKey) {                    $items[] = new Expr\ArrayItem(                        self::normalizeValue($itemValue)                    );                } else {                    $lastKey = null;                    $items[] = new Expr\ArrayItem(                        self::normalizeValue($itemValue),                        self::normalizeValue($itemKey)                    );                }            }            return new Expr\Array_($items);        } else {            throw new \LogicException('Invalid value');        }    }    /**     * Normalizes a doc comment: Converts plain strings to PhpParser\Comment\Doc.     *     * @param Comment\Doc|string $docComment The doc comment to normalize     *     * @return Comment\Doc The normalized doc comment     */    public static function normalizeDocComment($docComment) : Comment\Doc {        if ($docComment instanceof Comment\Doc) {            return $docComment;        } elseif (is_string($docComment)) {            return new Comment\Doc($docComment);        } else {            throw new \LogicException('Doc comment must be a string or an instance of PhpParser\Comment\Doc');        }    }    /**     * Adds a modifier and returns new modifier bitmask.     *     * @param int $modifiers Existing modifiers     * @param int $modifier  Modifier to set     *     * @return int New modifiers     */    public static function addModifier(int $modifiers, int $modifier) : int {        Stmt\Class_::verifyModifier($modifiers, $modifier);        return $modifiers | $modifier;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_FeatureSet_1941, Sets the calculator to use in this environment\\n,Podešava kalkulator za upotrebu u ovom okruženju,    public function setCalculator(CalculatorInterface $calculator): void    {        $this->calculator = $calculator;        $this->numberConverter = $this->buildNumberConverter($calculator);        $this->timeConverter = $this->buildTimeConverter($calculator);        if (isset($this->timeProvider)) {            $this->timeGenerator = $this->buildTimeGenerator($this->timeProvider);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_FeatureSet_1952, Returns a time converter configured for this environment\n,Vraća pretvarač vremena konfigurisan za ovo okruženje,"    private function buildTimeConverter(CalculatorInterface $calculator): TimeConverterInterface    {        $genericConverter = new GenericTimeConverter($calculator);        if ($this->is64BitSystem()) {            return new PhpTimeConverter($calculator, $genericConverter);        }        return $genericConverter;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidTest_2049, Tests that generated UUID's using timestamp last COMB are sequential\\n,Testovi koji su generisali UUID koristeći vremensku oznaku poslednji COMB su sekvencijalni,"    public function testUuid4TimestampLastComb(): void    {        $mock = $this->getMockBuilder(RandomGeneratorInterface::class)->getMock();        $mock->expects($this->any())            ->method('generate')            ->willReturnCallback(function ($length) {                // Makes first fields of UUIDs equal                return hex2bin(str_pad('', $length * 2, '0'));            });        $factory = new UuidFactory();        $generator = new CombGenerator($mock, $factory->getNumberConverter());        $codec = new TimestampLastCombCodec($factory->getUuidBuilder());        $factory->setRandomGenerator($generator);        $factory->setCodec($codec);        $previous = $factory->uuid4();        for ($i = 0; $i < 1000; $i++) {            usleep(100);            $uuid = $factory->uuid4();            $this->assertGreaterThan($previous->toString(), $uuid->toString());            $previous = $uuid;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_Uuid_1959, Re-constructs the object from its serialized form\n\n @param string $serialized The serialized PHP string to unserialize into\n     a UuidInterface instance\n\n @phpcsSuppress SlevomatCodingStandard.TypeHints.ParameterTypeHint.MissingNativeTypeHint\n,Ponovo konstruiše objekat iz njegovog serializovanog oblika,    public function unserialize($serialized): void    {        if (strlen($serialized) === 16) {            /** @var Uuid $uuid */            $uuid = self::getFactory()->fromBytes($serialized);        } else {            /** @var Uuid $uuid */            $uuid = self::getFactory()->fromString($serialized);        }        $this->codec = $uuid->codec;        $this->numberConverter = $uuid->numberConverter;        $this->fields = $uuid->fields;        $this->timeConverter = $uuid->timeConverter;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_FilenameFilterIterator_414," FilenameFilterIterator filters files by patterns (a regexp, a glob, or a string).\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n","FilenameFilterIterator filtrira datoteke prema obrascima (regularni izraz, glob ili string)","class FilenameFilterIterator extends MultiplePcreFilterIterator{    /**     * Filters the iterator values.     *     * @return bool true if the value should be kept, false otherwise     */    public function accept()    {        return $this->isAccepted($this->current()->getFilename());    }    /**     * Converts glob to regexp.     *     * PCRE patterns are left unchanged.     * Glob strings are transformed with Glob::toRegex().     *     * @param string $str Pattern: glob or regexp     *     * @return string regexp corresponding to a given glob or regexp     */    protected function toRegex(string $str)    {        return $this->isRegex($str) ? $str : Glob::toRegex($str);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_Extension_3224, Adds annotated classes to the class cache.\n\n @param array $annotatedClasses An array of class patterns\n,Dodaje označene klase u keš klasu,"class HttpKernelBrowser extends AbstractBrowser{    protected $kernel;    private $catchExceptions = true;    /**     * @param array $server The server parameters (equivalent of $_SERVER)     */    public function __construct(HttpKernelInterface $kernel, array $server = [], History $history = null, CookieJar $cookieJar = null)    {        // These class properties must be set before calling the parent constructor, as it may depend on it.        $this->kernel = $kernel;        $this->followRedirects = false;        parent::__construct($server, $history, $cookieJar);    }    /**     * Sets whether to catch exceptions when the kernel is handling a request.     */    public function catchExceptions(bool $catchExceptions)    {        $this->catchExceptions = $catchExceptions;    }    /**     * Makes a request.     *     * @return Response A Response instance     */    protected function doRequest($request)    {        $response = $this->kernel->handle($request, HttpKernelInterface::MAIN_REQUEST, $this->catchExceptions);        if ($this->kernel instanceof TerminableInterface) {            $this->kernel->terminate($request, $response);        }        return $response;    }    /**     * Returns the script to execute when the request must be insulated.     *     * @return string     */    protected function getScript($request)    {        $kernel = var_export(serialize($this->kernel), true);        $request = var_export(serialize($request), true);        $errorReporting = error_reporting();        $requires = '';        foreach (get_declared_classes() as $class) {            if (0 === strpos($class, 'ComposerAutoloaderInit')) {                $r = new \ReflectionClass($class);                $file = \dirname($r->getFileName(), 2).'/autoload.php';                if (file_exists($file)) {                    $requires .= 'require_once '.var_export($file, true)."";\n"";                }            }        }        if (!$requires) {            throw new \RuntimeException('Composer autoloader not found.');        }        $code = <<<EOF<?phperror_reporting($errorReporting);$requires\$kernel = unserialize($kernel);\$request = unserialize($request);EOF;        return $code.$this->getHandleScript();    }    protected function getHandleScript()    {        return <<<'EOF'$response = $kernel->handle($request);if ($kernel instanceof Symfony\Component\HttpKernel\TerminableInterface) {    $kernel->terminate($request, $response);}echo serialize($response);EOF;    }    /**     * Converts the BrowserKit request to a HttpKernel request.     *     * @return Request A Request instance     */    protected function filterRequest(DomRequest $request)    {        $httpRequest = Request::create($request->getUri(), $request->getMethod(), $request->getParameters(), $request->getCookies(), $request->getFiles(), $server = $request->getServer(), $request->getContent());        if (!isset($server['HTTP_ACCEPT'])) {            $httpRequest->headers->remove('Accept');        }        foreach ($this->filterFiles($httpRequest->files->all()) as $key => $value) {            $httpRequest->files->set($key, $value);        }        return $httpRequest;    }    /**     * Filters an array of files.     *     * This method created test instances of UploadedFile so that the move()     * method can be called on those instances.     *     * If the size of a file is greater than the allowed size (from php.ini) then     * an invalid UploadedFile is returned with an error set to UPLOAD_ERR_INI_SIZE.     *     * @see UploadedFile     *     * @return array An array with all uploaded files marked as already moved     */    protected function filterFiles(array $files)    {        $filtered = [];        foreach ($files as $key => $value) {            if (\is_array($value)) {                $filtered[$key] = $this->filterFiles($value);            } elseif ($value instanceof UploadedFile) {                if ($value->isValid() && $value->getSize() > UploadedFile::getMaxFilesize()) {                    $filtered[$key] = new UploadedFile(                        '',                        $value->getClientOriginalName(),                        $value->getClientMimeType(),                        \UPLOAD_ERR_INI_SIZE,                        true                    );                } else {                    $filtered[$key] = new UploadedFile(                        $value->getPathname(),                        $value->getClientOriginalName(),                        $value->getClientMimeType(),                        $value->getError(),                        true                    );                }            }        }        return $filtered;    }    /**     * Converts the HttpKernel response to a BrowserKit response.     *     * @return DomResponse A DomResponse instance     */    protected function filterResponse($response)    {        // this is needed to support StreamedResponse        ob_start();        $response->sendContent();        $content = ob_get_clean();        return new DomResponse($content, $response->getStatusCode(), $response->headers->all());    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_HttpKernelBrowser_3027, Makes a request.\n\n @return Response A Response instance\n,Podnosi zahtev,"class HttpKernel implements HttpKernelInterface, TerminableInterface{    protected $dispatcher;    protected $resolver;    protected $requestStack;    private $argumentResolver;    public function __construct(EventDispatcherInterface $dispatcher, ControllerResolverInterface $resolver, RequestStack $requestStack = null, ArgumentResolverInterface $argumentResolver = null)    {        $this->dispatcher = $dispatcher;        $this->resolver = $resolver;        $this->requestStack = $requestStack ?? new RequestStack();        $this->argumentResolver = $argumentResolver;        if (null === $this->argumentResolver) {            $this->argumentResolver = new ArgumentResolver();        }    }    /**     * {@inheritdoc}     */    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true)    {        $request->headers->set('X-Php-Ob-Level', (string) ob_get_level());        try {            return $this->handleRaw($request, $type);        } catch (\Exception $e) {            if ($e instanceof RequestExceptionInterface) {                $e = new BadRequestHttpException($e->getMessage(), $e);            }            if (false === $catch) {                $this->finishRequest($request, $type);                throw $e;            }            return $this->handleThrowable($e, $request, $type);        }    }    /**     * {@inheritdoc}     */    public function terminate(Request $request, Response $response)    {        $this->dispatcher->dispatch(new TerminateEvent($this, $request, $response), KernelEvents::TERMINATE);    }    /**     * @internal     */    public function terminateWithException(\Throwable $exception, Request $request = null)    {        if (!$request = $request ?: $this->requestStack->getMainRequest()) {            throw $exception;        }        $response = $this->handleThrowable($exception, $request, self::MAIN_REQUEST);        $response->sendHeaders();        $response->sendContent();        $this->terminate($request, $response);    }    /**     * Handles a request to convert it to a response.     *     * Exceptions are not caught.     *     * @throws \LogicException       If one of the listener does not behave as expected     * @throws NotFoundHttpException When controller cannot be found     */    private function handleRaw(Request $request, int $type = self::MAIN_REQUEST): Response    {        $this->requestStack->push($request);        // request        $event = new RequestEvent($this, $request, $type);        $this->dispatcher->dispatch($event, KernelEvents::REQUEST);        if ($event->hasResponse()) {            return $this->filterResponse($event->getResponse(), $request, $type);        }        // load controller        if (false === $controller = $this->resolver->getController($request)) {            throw new NotFoundHttpException(sprintf('Unable to find the controller for path ""%s"". The route is wrongly configured.', $request->getPathInfo()));        }        $event = new ControllerEvent($this, $controller, $request, $type);        $this->dispatcher->dispatch($event, KernelEvents::CONTROLLER);        $controller = $event->getController();        // controller arguments        $arguments = $this->argumentResolver->getArguments($request, $controller);        $event = new ControllerArgumentsEvent($this, $controller, $arguments, $request, $type);        $this->dispatcher->dispatch($event, KernelEvents::CONTROLLER_ARGUMENTS);        $controller = $event->getController();        $arguments = $event->getArguments();        // call controller        $response = $controller(...$arguments);        // view        if (!$response instanceof Response) {            $event = new ViewEvent($this, $request, $type, $response);            $this->dispatcher->dispatch($event, KernelEvents::VIEW);            if ($event->hasResponse()) {                $response = $event->getResponse();            } else {                $msg = sprintf('The controller must return a ""Symfony\Component\HttpFoundation\Response"" object but it returned %s.', $this->varToString($response));                // the user may have forgotten to return something                if (null === $response) {                    $msg .= ' Did you forget to add a return statement somewhere in your controller?';                }                throw new ControllerDoesNotReturnResponseException($msg, $controller, __FILE__, __LINE__ - 17);            }        }        return $this->filterResponse($response, $request, $type);    }    /**     * Filters a response object.     *     * @throws \RuntimeException if the passed object is not a Response instance     */    private function filterResponse(Response $response, Request $request, int $type): Response    {        $event = new ResponseEvent($this, $request, $type, $response);        $this->dispatcher->dispatch($event, KernelEvents::RESPONSE);        $this->finishRequest($request, $type);        return $event->getResponse();    }    /**     * Publishes the finish request event, then pop the request from the stack.     *     * Note that the order of the operations is important here, otherwise     * operations such as {@link RequestStack::getParentRequest()} can lead to     * weird results.     */    private function finishRequest(Request $request, int $type)    {        $this->dispatcher->dispatch(new FinishRequestEvent($this, $request, $type), KernelEvents::FINISH_REQUEST);        $this->requestStack->pop();    }    /**     * Handles a throwable by trying to convert it to a Response.     *     * @throws \Exception     */    private function handleThrowable(\Throwable $e, Request $request, int $type): Response    {        $event = new ExceptionEvent($this, $request, $type, $e);        $this->dispatcher->dispatch($event, KernelEvents::EXCEPTION);        // a listener might have replaced the exception        $e = $event->getThrowable();        if (!$event->hasResponse()) {            $this->finishRequest($request, $type);            throw $e;        }        $response = $event->getResponse();        // the developer asked for a specific status code        if (!$event->isAllowingCustomResponseCode() && !$response->isClientError() && !$response->isServerError() && !$response->isRedirect()) {            // ensure that we actually have an error response            if ($e instanceof HttpExceptionInterface) {                // keep the HTTP status code and headers                $response->setStatusCode($e->getStatusCode());                $response->headers->add($e->getHeaders());            } else {                $response->setStatusCode(500);            }        }        try {            return $this->filterResponse($response, $request, $type);        } catch (\Exception $e) {            return $response;        }    }    /**     * Returns a human-readable string for the specified variable.     */    private function varToString($var): string    {        if (\is_object($var)) {            return sprintf('an object of type %s', \get_class($var));        }        if (\is_array($var)) {            $a = [];            foreach ($var as $k => $v) {                $a[] = sprintf('%s => ...', $k);            }            return sprintf('an array ([%s])', mb_substr(implode(', ', $a), 0, 255));        }        if (\is_resource($var)) {            return sprintf('a resource (%s)', get_resource_type($var));        }        if (null === $var) {            return 'null';        }        if (false === $var) {            return 'a boolean value (false)';        }        if (true === $var) {            return 'a boolean value (true)';        }        if (\is_string($var)) {            return sprintf('a string (""%s%s"")', mb_substr($var, 0, 255), mb_strlen($var) > 255 ? '...' : '');        }        if (is_numeric($var)) {            return sprintf('a number (%s)', (string) $var);        }        return (string) $var;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractCloner_9220, Casts an object to an array representation.\n\n @param bool $isNested True if the object is nested in the dumped structure\n\n @return array The object casted as array\n,,"    protected function utf8Encode(?string $s)    {        if (null === $s || preg_match('//u', $s)) {            return $s;        }        if (!\function_exists('iconv')) {            throw new \RuntimeException('Unable to convert a non-UTF-8 string to UTF-8: required function iconv() does not exist. You should install ext-iconv or symfony/polyfill-iconv.');        }        if (false !== $c = @iconv($this->charset, 'UTF-8', $s)) {            return $c;        }        if ('CP1252' !== $this->charset && false !== $c = @iconv('CP1252', 'UTF-8', $s)) {            return $c;        }        return iconv('CP850', 'UTF-8', $s);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractDumper_8336," Sets the indentation pad string.\n\n @param string $pad A string that will be prepended to dumped lines, repeated by nesting level\n\n @return string The previous indent pad\n",,"abstract class AbstractDumper implements DataDumperInterface, DumperInterface{    public const DUMP_LIGHT_ARRAY = 1;    public const DUMP_STRING_LENGTH = 2;    public const DUMP_COMMA_SEPARATOR = 4;    public const DUMP_TRAILING_COMMA = 8;    public static $defaultOutput = 'php://output';    protected $line = '';    protected $lineDumper;    protected $outputStream;    protected $decimalPoint; // This is locale dependent    protected $indentPad = '  ';    protected $flags;    private $charset = '';    /**     * @param callable|resource|string|null $output  A line dumper callable, an opened stream or an output path, defaults to static::$defaultOutput     * @param string|null                   $charset The default character encoding to use for non-UTF8 strings     * @param int                           $flags   A bit field of static::DUMP_* constants to fine tune dumps representation     */    public function __construct($output = null, string $charset = null, int $flags = 0)    {        $this->flags = $flags;        $this->setCharset($charset ?: ini_get('php.output_encoding') ?: ini_get('default_charset') ?: 'UTF-8');        $this->decimalPoint = localeconv();        $this->decimalPoint = $this->decimalPoint['decimal_point'];        $this->setOutput($output ?: static::$defaultOutput);        if (!$output && \is_string(static::$defaultOutput)) {            static::$defaultOutput = $this->outputStream;        }    }    /**     * Sets the output destination of the dumps.     *     * @param callable|resource|string $output A line dumper callable, an opened stream or an output path     *     * @return callable|resource|string The previous output destination     */    public function setOutput($output)    {        $prev = null !== $this->outputStream ? $this->outputStream : $this->lineDumper;        if (\is_callable($output)) {            $this->outputStream = null;            $this->lineDumper = $output;        } else {            if (\is_string($output)) {                $output = fopen($output, 'w');            }            $this->outputStream = $output;            $this->lineDumper = [$this, 'echoLine'];        }        return $prev;    }    /**     * Sets the default character encoding to use for non-UTF8 strings.     *     * @return string The previous charset     */    public function setCharset(string $charset)    {        $prev = $this->charset;        $charset = strtoupper($charset);        $charset = null === $charset || 'UTF-8' === $charset || 'UTF8' === $charset ? 'CP1252' : $charset;        $this->charset = $charset;        return $prev;    }    /**     * Sets the indentation pad string.     *     * @param string $pad A string that will be prepended to dumped lines, repeated by nesting level     *     * @return string The previous indent pad     */    public function setIndentPad(string $pad)    {        $prev = $this->indentPad;        $this->indentPad = $pad;        return $prev;    }    /**     * Dumps a Data object.     *     * @param callable|resource|string|true|null $output A line dumper callable, an opened stream, an output path or true to return the dump     *     * @return string|null The dump as string when $output is true     */    public function dump(Data $data, $output = null)    {        $this->decimalPoint = localeconv();        $this->decimalPoint = $this->decimalPoint['decimal_point'];        if ($locale = $this->flags & (self::DUMP_COMMA_SEPARATOR | self::DUMP_TRAILING_COMMA) ? setlocale(\LC_NUMERIC, 0) : null) {            setlocale(\LC_NUMERIC, 'C');        }        if ($returnDump = true === $output) {            $output = fopen('php://memory', 'r+');        }        if ($output) {            $prevOutput = $this->setOutput($output);        }        try {            $data->dump($this);            $this->dumpLine(-1);            if ($returnDump) {                $result = stream_get_contents($output, -1, 0);                fclose($output);                return $result;            }        } finally {            if ($output) {                $this->setOutput($prevOutput);            }            if ($locale) {                setlocale(\LC_NUMERIC, $locale);            }        }        return null;    }    /**     * Dumps the current line.     *     * @param int $depth The recursive depth in the dumped structure for the line being dumped,     *                   or -1 to signal the end-of-dump to the line dumper callable     */    protected function dumpLine(int $depth)    {        ($this->lineDumper)($this->line, $depth, $this->indentPad);        $this->line = '';    }    /**     * Generic line dumper callback.     */    protected function echoLine(string $line, int $depth, string $indentPad)    {        if (-1 !== $depth) {            fwrite($this->outputStream, str_repeat($indentPad, $depth).$line.""\n"");        }    }    /**     * Converts a non-UTF-8 string to UTF-8.     *     * @return string|null The string converted to UTF-8     */    protected function utf8Encode(?string $s)    {        if (null === $s || preg_match('//u', $s)) {            return $s;        }        if (!\function_exists('iconv')) {            throw new \RuntimeException('Unable to convert a non-UTF-8 string to UTF-8: required function iconv() does not exist. You should install ext-iconv or symfony/polyfill-iconv.');        }        if (false !== $c = @iconv($this->charset, 'UTF-8', $s)) {            return $c;        }        if ('CP1252' !== $this->charset && false !== $c = @iconv('CP1252', 'UTF-8', $s)) {            return $c;        }        return iconv('CP850', 'UTF-8', $s);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
tennc_webshell_Ani-Shell_1003, Get the directory size\n @param directory $directory\n @return integer\n,Uzmite veličinu direktorijuma,"function shell($cmd){if (!empty($cmd)){  $fp = popen($cmd,""r"");  {    $result = """";    while(!feof($fp)){$result.=fread($fp,1024);}    pclose($fp);  }  $ret = $result;  $ret = convert_cyr_string($ret,""d"",""w"");}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_oauth2-server_AuthorizationServer_3455, Return an access token response.\n\n @param ServerRequestInterface $request\n @param ResponseInterface      $response\n\n @throws OAuthServerException\n\n @return ResponseInterface\n,Vraća odgovor tokena pristupa,    private function convertSingleRecordAudToString($aud)    {        return \is_array($aud) && \count($aud) === 1 ? $aud[0] : $aud;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_Promise_717," It's a success, so resolve the handlers in the queue.\n","Uspešno je prošlo, razrešava hendlere u redu","            Utils::queue()->add(static function () use ($id, $value, $handlers) {                foreach ($handlers as $handler) {                    self::callHandler($id, $value, $handler);                }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_468," Set a return value, or sequential queue of return values\\\\n\\\\n @param mixed ...$args\\\\n @return self\\\\n",Postavite povratnu vrednost ili sekvencijalni red povratnih vrednosti,"    public function andReturns(...$args)    {        return call_user_func_array([$this, 'andReturn'], $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_470, Set a sequential queue of return values with an array\n\n @param array $values\n @return self\n,Postavite sekvencijalni red povratnih vrednosti pomoću niza,"    public function andReturnValues(array $values)    {        call_user_func_array(array($this, 'andReturn'), $values);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Autoloader_1549, Add autoloader to autoloaders queue\\n,Dodajte autoloader u red autoloadera,"    public function register()    {        spl_autoload_register(array($this, 'autoload'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1199, Add support for deep cloning\n\n @return void\n,,    public function __clone()    {        if (null !== $this->queue) {            $this->queue = clone $this->queue;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_476, Register values to be set to a public property each time this expectation occurs\\\\\\\\n\\\\\\\\n @param string $name\\\\\\\\n @param array ...$values\\\\\\\\n @return self\\\\\\\\n,Registrujte vrednosti koje će biti postavljene na javno svojstvo svaki put kada se ovo očekuje,"    public function andSet($name, ...$values)    {        $this->_setQueue[$name] = $values;        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Runner_911, Performs the run.\n\n @return int The number of errors and warnings found.\n @throws \\PHP_CodeSniffer\\Exceptions\\DeepExitException\n @throws \\PHP_CodeSniffer\\Exceptions\\RuntimeException\n,Izvodi pokretanje,"    private function run()    {        // The class that manages all reporters for the run.        $this->reporter = new Reporter($this->config);        // Include bootstrap files.        foreach ($this->config->bootstrap as $bootstrap) {            include $bootstrap;        }        if ($this->config->stdin === true) {            $fileContents = $this->config->stdinContent;            if ($fileContents === null) {                $handle = fopen('php://stdin', 'r');                stream_set_blocking($handle, true);                $fileContents = stream_get_contents($handle);                fclose($handle);            }            $todo  = new FileList($this->config, $this->ruleset);            $dummy = new DummyFile($fileContents, $this->ruleset, $this->config);            $todo->addFile($dummy->path, $dummy);        } else {            if (empty($this->config->files) === true) {                $error  = 'ERROR: You must supply at least one file or directory to process.'.PHP_EOL.PHP_EOL;                $error .= $this->config->printShortUsage(true);                throw new DeepExitException($error, 3);            }            if (PHP_CODESNIFFER_VERBOSITY > 0) {                echo 'Creating file list... ';            }            $todo = new FileList($this->config, $this->ruleset);            if (PHP_CODESNIFFER_VERBOSITY > 0) {                $numFiles = count($todo);                echo ""DONE ($numFiles files in queue)"".PHP_EOL;            }            if ($this->config->cache === true) {                if (PHP_CODESNIFFER_VERBOSITY > 0) {                    echo 'Loading cache... ';                }                Cache::load($this->ruleset, $this->config);                if (PHP_CODESNIFFER_VERBOSITY > 0) {                    $size = Cache::getSize();                    echo ""DONE ($size files in cache)"".PHP_EOL;                }            }        }//end if        // Turn all sniff errors into exceptions.        set_error_handler([$this, 'handleErrors']);        // If verbosity is too high, turn off parallelism so the        // debug output is clean.        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $this->config->parallel = 1;        }        // If the PCNTL extension isn't installed, we can't fork.        if (function_exists('pcntl_fork') === false) {            $this->config->parallel = 1;        }        $lastDir  = '';        $numFiles = count($todo);        if ($this->config->parallel === 1) {            // Running normally.            $numProcessed = 0;            foreach ($todo as $path => $file) {                if ($file->ignored === false) {                    $currDir = dirname($path);                    if ($lastDir !== $currDir) {                        if (PHP_CODESNIFFER_VERBOSITY > 0) {                            echo 'Changing into directory '.Common::stripBasepath($currDir, $this->config->basepath).PHP_EOL;                        }                        $lastDir = $currDir;                    }                    $this->processFile($file);                } else if (PHP_CODESNIFFER_VERBOSITY > 0) {                    echo 'Skipping '.basename($file->path).PHP_EOL;                }                $numProcessed++;                $this->printProgress($file, $numFiles, $numProcessed);            }        } else {            // Batching and forking.            $childProcs  = [];            $numPerBatch = ceil($numFiles / $this->config->parallel);            for ($batch = 0; $batch < $this->config->parallel; $batch++) {                $startAt = ($batch * $numPerBatch);                if ($startAt >= $numFiles) {                    break;                }                $endAt = ($startAt + $numPerBatch);                if ($endAt > $numFiles) {                    $endAt = $numFiles;                }                $childOutFilename = tempnam(sys_get_temp_dir(), 'phpcs-child');                $pid = pcntl_fork();                if ($pid === -1) {                    throw new RuntimeException('Failed to create child process');                } else if ($pid !== 0) {                    $childProcs[] = [                        'pid' => $pid,                        'out' => $childOutFilename,                    ];                } else {                    // Move forward to the start of the batch.                    $todo->rewind();                    for ($i = 0; $i < $startAt; $i++) {                        $todo->next();                    }                    // Reset the reporter to make sure only figures from this                    // file batch are recorded.                    $this->reporter->totalFiles    = 0;                    $this->reporter->totalErrors   = 0;                    $this->reporter->totalWarnings = 0;                    $this->reporter->totalFixable  = 0;                    $this->reporter->totalFixed    = 0;                    // Process the files.                    $pathsProcessed = [];                    ob_start();                    for ($i = $startAt; $i < $endAt; $i++) {                        $path = $todo->key();                        $file = $todo->current();                        if ($file->ignored === true) {                            $todo->next();                            continue;                        }                        $currDir = dirname($path);                        if ($lastDir !== $currDir) {                            if (PHP_CODESNIFFER_VERBOSITY > 0) {                                echo 'Changing into directory '.Common::stripBasepath($currDir, $this->config->basepath).PHP_EOL;                            }                            $lastDir = $currDir;                        }                        $this->processFile($file);                        $pathsProcessed[] = $path;                        $todo->next();                    }//end for                    $debugOutput = ob_get_contents();                    ob_end_clean();                    // Write information about the run to the filesystem                    // so it can be picked up by the main process.                    $childOutput = [                        'totalFiles'    => $this->reporter->totalFiles,                        'totalErrors'   => $this->reporter->totalErrors,                        'totalWarnings' => $this->reporter->totalWarnings,                        'totalFixable'  => $this->reporter->totalFixable,                        'totalFixed'    => $this->reporter->totalFixed,                    ];                    $output  = '<'.'?php'.""\n"".' $childOutput = ';                    $output .= var_export($childOutput, true);                    $output .= "";\n\$debugOutput = "";                    $output .= var_export($debugOutput, true);                    if ($this->config->cache === true) {                        $childCache = [];                        foreach ($pathsProcessed as $path) {                            $childCache[$path] = Cache::get($path);                        }                        $output .= "";\n\$childCache = "";                        $output .= var_export($childCache, true);                    }                    $output .= "";\n?"".'>';                    file_put_contents($childOutFilename, $output);                    exit($pid);                }//end if            }//end for            $success = $this->processChildProcs($childProcs);            if ($success === false) {                throw new RuntimeException('One or more child processes failed to run');            }        }//end if        restore_error_handler();        if (PHP_CODESNIFFER_VERBOSITY === 0            && $this->config->interactive === false            && $this->config->showProgress === true        ) {            echo PHP_EOL.PHP_EOL;        }        if ($this->config->cache === true) {            Cache::save();        }        $ignoreWarnings = Config::getConfigData('ignore_warnings_on_exit');        $ignoreErrors   = Config::getConfigData('ignore_errors_on_exit');        $return = ($this->reporter->totalErrors + $this->reporter->totalWarnings);        if ($ignoreErrors !== null) {            $ignoreErrors = (bool) $ignoreErrors;            if ($ignoreErrors === true) {                $return -= $this->reporter->totalErrors;            }        }        if ($ignoreWarnings !== null) {            $ignoreWarnings = (bool) $ignoreWarnings;            if ($ignoreWarnings === true) {                $return -= $this->reporter->totalWarnings;            }        }        return $return;    }//end run()",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_Stub_9244, Represents the main properties of a PHP variable.\n\n @author Nicolas Grekas <p@tchwork.com>\n,Predstavlja glavna svojstva PHP promenljive,"    protected function doClone($var)    {        $len = 1;                       // Length of $queue        $pos = 0;                       // Number of cloned items past the minimum depth        $refsCounter = 0;               // Hard references counter        $queue = [[$var]];    // This breadth-first queue is the return value        $hardRefs = [];            // Map of original zval ids to stub objects        $objRefs = [];             // Map of original object handles to their stub object counterpart        $objects = [];             // Keep a ref to objects to ensure their handle cannot be reused while cloning        $resRefs = [];             // Map of original resource handles to their stub object counterpart        $values = [];              // Map of stub objects' ids to original values        $maxItems = $this->maxItems;        $maxString = $this->maxString;        $minDepth = $this->minDepth;        $currentDepth = 0;              // Current tree depth        $currentDepthFinalIndex = 0;    // Final $queue index for current tree depth        $minimumDepthReached = 0 === $minDepth; // Becomes true when minimum tree depth has been reached        $cookie = (object) [];          // Unique object used to detect hard references        $a = null;                      // Array cast for nested structures        $stub = null;                   // Stub capturing the main properties of an original item value                                        // or null if the original value is used directly        if (!$gid = self::$gid) {            $gid = self::$gid = md5(random_bytes(6)); // Unique string used to detect the special $GLOBALS variable        }        $arrayStub = new Stub();        $arrayStub->type = Stub::TYPE_ARRAY;        $fromObjCast = false;        for ($i = 0; $i < $len; ++$i) {            // Detect when we move on to the next tree depth            if ($i > $currentDepthFinalIndex) {                ++$currentDepth;                $currentDepthFinalIndex = $len - 1;                if ($currentDepth >= $minDepth) {                    $minimumDepthReached = true;                }            }            $refs = $vals = $queue[$i];            foreach ($vals as $k => $v) {                // $v is the original value or a stub object in case of hard references                if (\PHP_VERSION_ID >= 70400) {                    $zvalIsRef = null !== \ReflectionReference::fromArrayElement($vals, $k);                } else {                    $refs[$k] = $cookie;                    $zvalIsRef = $vals[$k] === $cookie;                }                if ($zvalIsRef) {                    $vals[$k] = &$stub;         // Break hard references to make $queue completely                    unset($stub);               // independent from the original structure                    if ($v instanceof Stub && isset($hardRefs[spl_object_id($v)])) {                        $vals[$k] = $refs[$k] = $v;                        if ($v->value instanceof Stub && (Stub::TYPE_OBJECT === $v->value->type || Stub::TYPE_RESOURCE === $v->value->type)) {                            ++$v->value->refCount;                        }                        ++$v->refCount;                        continue;                    }                    $refs[$k] = $vals[$k] = new Stub();                    $refs[$k]->value = $v;                    $h = spl_object_id($refs[$k]);                    $hardRefs[$h] = &$refs[$k];                    $values[$h] = $v;                    $vals[$k]->handle = ++$refsCounter;                }                // Create $stub when the original value $v can not be used directly                // If $v is a nested structure, put that structure in array $a                switch (true) {                    case null === $v:                    case \is_bool($v):                    case \is_int($v):                    case \is_float($v):                        continue 2;                    case \is_string($v):                        if ('' === $v) {                            continue 2;                        }                        if (!preg_match('//u', $v)) {                            $stub = new Stub();                            $stub->type = Stub::TYPE_STRING;                            $stub->class = Stub::STRING_BINARY;                            if (0 <= $maxString && 0 < $cut = \strlen($v) - $maxString) {                                $stub->cut = $cut;                                $stub->value = substr($v, 0, -$cut);                            } else {                                $stub->value = $v;                            }                        } elseif (0 <= $maxString && isset($v[1 + ($maxString >> 2)]) && 0 < $cut = mb_strlen($v, 'UTF-8') - $maxString) {                            $stub = new Stub();                            $stub->type = Stub::TYPE_STRING;                            $stub->class = Stub::STRING_UTF8;                            $stub->cut = $cut;                            $stub->value = mb_substr($v, 0, $maxString, 'UTF-8');                        } else {                            continue 2;                        }                        $a = null;                        break;                    case \is_array($v):                        if (!$v) {                            continue 2;                        }                        $stub = $arrayStub;                        $stub->class = Stub::ARRAY_INDEXED;                        $j = -1;                        foreach ($v as $gk => $gv) {                            if ($gk !== ++$j) {                                $stub->class = Stub::ARRAY_ASSOC;                                break;                            }                        }                        $a = $v;                        if (Stub::ARRAY_ASSOC === $stub->class) {                            // Copies of $GLOBALS have very strange behavior,                            // let's detect them with some black magic                            if (\PHP_VERSION_ID < 80100 && ($a[$gid] = true) && isset($v[$gid])) {                                unset($v[$gid]);                                $a = [];                                foreach ($v as $gk => &$gv) {                                    if ($v === $gv) {                                        unset($v);                                        $v = new Stub();                                        $v->value = [$v->cut = \count($gv), Stub::TYPE_ARRAY => 0];                                        $v->handle = -1;                                        $gv = &$hardRefs[spl_object_id($v)];                                        $gv = $v;                                    }                                    $a[$gk] = &$gv;                                }                                unset($gv);                            } else {                                $a = $v;                            }                        }                        break;                    case \is_object($v):                        if (empty($objRefs[$h = spl_object_id($v)])) {                            $stub = new Stub();                            $stub->type = Stub::TYPE_OBJECT;                            $stub->class = \get_class($v);                            $stub->value = $v;                            $stub->handle = $h;                            $a = $this->castObject($stub, 0 < $i);                            if ($v !== $stub->value) {                                if (Stub::TYPE_OBJECT !== $stub->type || null === $stub->value) {                                    break;                                }                                $stub->handle = $h = spl_object_id($stub->value);                            }                            $stub->value = null;                            if (0 <= $maxItems && $maxItems <= $pos && $minimumDepthReached) {                                $stub->cut = \count($a);                                $a = null;                            }                        }                        if (empty($objRefs[$h])) {                            $objRefs[$h] = $stub;                            $objects[] = $v;                        } else {                            $stub = $objRefs[$h];                            ++$stub->refCount;                            $a = null;                        }                        break;                    default: // resource                        if (empty($resRefs[$h = (int) $v])) {                            $stub = new Stub();                            $stub->type = Stub::TYPE_RESOURCE;                            if ('Unknown' === $stub->class = @get_resource_type($v)) {                                $stub->class = 'Closed';                            }                            $stub->value = $v;                            $stub->handle = $h;                            $a = $this->castResource($stub, 0 < $i);                            $stub->value = null;                            if (0 <= $maxItems && $maxItems <= $pos && $minimumDepthReached) {                                $stub->cut = \count($a);                                $a = null;                            }                        }                        if (empty($resRefs[$h])) {                            $resRefs[$h] = $stub;                        } else {                            $stub = $resRefs[$h];                            ++$stub->refCount;                            $a = null;                        }                        break;                }                if ($a) {                    if (!$minimumDepthReached || 0 > $maxItems) {                        $queue[$len] = $a;                        $stub->position = $len++;                    } elseif ($pos < $maxItems) {                        if ($maxItems < $pos += \count($a)) {                            $a = \array_slice($a, 0, $maxItems - $pos, true);                            if ($stub->cut >= 0) {                                $stub->cut += $pos - $maxItems;                            }                        }                        $queue[$len] = $a;                        $stub->position = $len++;                    } elseif ($stub->cut >= 0) {                        $stub->cut += \count($a);                        $stub->position = 0;                    }                }                if ($arrayStub === $stub) {                    if ($arrayStub->cut) {                        $stub = [$arrayStub->cut, $arrayStub->class => $arrayStub->position];                        $arrayStub->cut = 0;                    } elseif (isset(self::$arrayCache[$arrayStub->class][$arrayStub->position])) {                        $stub = self::$arrayCache[$arrayStub->class][$arrayStub->position];                    } else {                        self::$arrayCache[$arrayStub->class][$arrayStub->position] = $stub = [$arrayStub->class => $arrayStub->position];                    }                }                if ($zvalIsRef) {                    $refs[$k]->value = $stub;                } else {                    $vals[$k] = $stub;                }            }            if ($fromObjCast) {                $fromObjCast = false;                $refs = $vals;                $vals = [];                $j = -1;                foreach ($queue[$i] as $k => $v) {                    foreach ([$k => true] as $gk => $gv) {                    }                    if ($gk !== $k) {                        $vals = (object) $vals;                        $vals->{$k} = $refs[++$j];                        $vals = (array) $vals;                    } else {                        $vals[$k] = $refs[++$j];                    }                }            }            $queue[$i] = $vals;        }        foreach ($values as $h => $v) {            $hardRefs[$h] = $v;        }        return $queue;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
woocommerce_woocommerce_class-wc-autoloader_1797, Include a class file.\n\n @param  string $path File path.\n @return bool Successful or not.\n,,public function dispatch_queue() {if ( ! empty( $this->data ) ) {$this->close_http_connection();$this->save()->dispatch();},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3492," Compute the P-th percentile of a list of numbers\\n\\n Linear interpolation between closest ranks method - Second variant, C = 1\\n P-th percentile (0 <= P <= 100) of a list of N ordered values (sorted from least to greatest)\\n Similar method used in NumPy and Excel\\n https://en.wikipedia.org/wiki/Percentile#Second_variant.2C_.7F.27.22.60UNIQ--postMath-00000043-QINU.60.22.27.7F\\n\\n      P\\n x - --- (N - 1) + 1\\n     100\\n\\n P = percentile\\n N = number of elements in list\\n\\n Î½(x) = Î½â‚“ + xï¼…1(Î½â‚“â‚Šâ‚ - Î½â‚“)\\n\\n âŒŠxâŒ‹  = integer part of x\\n xï¼…1 = fraction part of x\\n Î½â‚“   = number in position x in sorted list of numbers\\n Î½â‚“â‚Šâ‚ = number in position x + 1 in sorted list of number\\n\\n @param float[] $numbers\\n @param float   $P percentile to calculate\\n\\n @return float in list corresponding to P percentile\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if $P percentile is not between 0 and 100\\n","Izračunajte P-ti percentil liste brojeva. Metoda linearne interpolacije između najbližih rangova - Druga varijanta, C = 1 , P-ti percentil (0 <= P <= 100) liste N uređenih vrednosti (poređanih od najmanje do najveće). Slična metoda korišćena u NumPy i Excel","    public static function percentile(array $numbers, float $P): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the P-th percentile of an empty list of numbers');        }        if ($P < 0 || $P > 100) {            throw new Exception\OutOfBoundsException('Percentile P must be between 0 and 100.');        }        $N = \count($numbers);        if ($N === 1) {            return \array_shift($numbers);        }        \sort($numbers);        if ($P == 100) {            return  $numbers[$N - 1];        }        $x    = ($P / 100) * ($N - 1) + 1;        $âŒŠxâŒ‹  = \intval($x);        $xï¼…1 = $x - $âŒŠxâŒ‹;        $Î½â‚“   = $numbers[$âŒŠxâŒ‹ - 1];        $Î½â‚“â‚Šâ‚ = $numbers[$âŒŠxâŒ‹];        return $Î½â‚“ + $xï¼…1 * ($Î½â‚“â‚Šâ‚ - $Î½â‚“);    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ProcessedReport_238," API metadata are sorted by category/name,\\n with a little tweak to replicate the standard Piwik category ordering\\n\\n @param array $a\\n @param array $b\\n @return int\\n",,"    public function sortReports($a, $b)    {        return $this->reportsProvider->compareCategories($a['category'], $a['subcategory'], $a['order'], $b['category'], $b['subcategory'], $b['order']);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1630, Adds a file path to the watcher list queue which will be sent\\n to the master process after each request.\\n\\n @param string $path\\n,,    public function registerFile($path)    {        if ($this->isDebug()) {            $this->watchedFiles[] = $path;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_366, Reverses the sorting.\\n\\n @return $this\\n,Obrće sortiranje,    public function reverseSorting()    {        $this->reverseSorting = true;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Pool_1417," Sends an iterator of requests concurrently using a capped pool size.\\n\\n The pool will read from an iterator until it is cancelled or until the\\n iterator is consumed. When a request is yielded, the request is sent after\\n applying the ""request_options"" request options (if provided in the ctor).\\n\\n When a function is yielded by the iterator, the function is provided the\\n ""request_options"" array that should be merged on top of any existing\\n options, and the function MUST then return a wait-able promise.\\n\\n @final\\n","Istovremeno šalje iterator zahteva koristeći ograničenu veličinu pool-a. Pool će čitati iz iteratora dok se ne otkaže ili dok se iterator ne potroši. Kada se dobije zahtev, zahtev se šalje nakon primene ""request_options"" (ako je predviđeno u ctor-u). Kada iterator daje funkciju, funkciji se daje ""request_options"" niz koji treba spojiti povrh svih postojećih opcija, a funkcija MORA zatim vratiti obećanje na čekanje","class Pool implements PromisorInterface{    /**     * @var EachPromise     */    private $each;    /**     * @param ClientInterface $client   Client used to send the requests.     * @param array|\Iterator $requests Requests or functions that return     *                                  requests to send concurrently.     * @param array           $config   Associative array of options     *                                  - concurrency: (int) Maximum number of requests to send concurrently     *                                  - options: Array of request options to apply to each request.     *                                  - fulfilled: (callable) Function to invoke when a request completes.     *                                  - rejected: (callable) Function to invoke when a request is rejected.     */    public function __construct(ClientInterface $client, $requests, array $config = [])    {        if (!isset($config['concurrency'])) {            $config['concurrency'] = 25;        }        if (isset($config['options'])) {            $opts = $config['options'];            unset($config['options']);        } else {            $opts = [];        }        $iterable = P\Create::iterFor($requests);        $requests = static function () use ($iterable, $client, $opts) {            foreach ($iterable as $key => $rfn) {                if ($rfn instanceof RequestInterface) {                    yield $key => $client->sendAsync($rfn, $opts);                } elseif (\is_callable($rfn)) {                    yield $key => $rfn($opts);                } else {                    throw new \InvalidArgumentException('Each value yielded by the iterator must be a Psr7\Http\Message\RequestInterface or a callable that returns a promise that fulfills with a Psr7\Message\Http\ResponseInterface object.');                }            }        };        $this->each = new EachPromise($requests(), $config);    }    /**     * Get promise     */    public function promise(): PromiseInterface    {        return $this->each->promise();    }    /**     * Sends multiple requests concurrently and returns an array of responses     * and exceptions that uses the same ordering as the provided requests.     *     * IMPORTANT: This method keeps every request and response in memory, and     * as such, is NOT recommended when sending a large number or an     * indeterminate number of requests concurrently.     *     * @param ClientInterface $client   Client used to send the requests     * @param array|\Iterator $requests Requests to send concurrently.     * @param array           $options  Passes through the options available in     *                                  {@see \GuzzleHttp\Pool::__construct}     *     * @return array Returns an array containing the response or an exception     *               in the same order that the requests were sent.     *     * @throws \InvalidArgumentException if the event format is incorrect.     */    public static function batch(ClientInterface $client, $requests, array $options = []): array    {        $res = [];        self::cmpCallback($options, 'fulfilled', $res);        self::cmpCallback($options, 'rejected', $res);        $pool = new static($client, $requests, $options);        $pool->promise()->wait();        \ksort($res);        return $res;    }    /**     * Execute callback(s)     */    private static function cmpCallback(array &$options, string $name, array &$results): void    {        if (!isset($options[$name])) {            $options[$name] = static function ($v, $k) use (&$results) {                $results[$k] = $v;            };        } else {            $currentFn = $options[$name];            $options[$name] = static function ($v, $k) use (&$results, $currentFn) {                $currentFn($v, $k);                $results[$k] = $v;            };        }    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_FactoryGenerator_2307, Controls the process of extracting @factory doctags\n and generating factory method files.\n\n Uses File_Iterator to scan for PHP files.\n,Kontroliše postupak izdvajanja @factory doktaga i generisanja datoteka fabričkih metoda. Koristi File_Iterator za skeniranje PHP datoteka,"class FactoryGenerator{    /**     * Path to the Hamcrest PHP files to process.     *     * @var string     */    private $path;    /**     * @var array of FactoryFile     */    private $factoryFiles;    public function __construct($path)    {        $this->path = $path;        $this->factoryFiles = array();    }    public function addFactoryFile(FactoryFile $factoryFile)    {        $this->factoryFiles[] = $factoryFile;    }    public function generate()    {        $classes = $this->getClassesWithFactoryMethods();        foreach ($classes as $class) {            foreach ($class->getMethods() as $method) {                foreach ($method->getCalls() as $call) {                    foreach ($this->factoryFiles as $file) {                        $file->addCall($call);                    }                }            }        }    }    public function write()    {        foreach ($this->factoryFiles as $file) {            $file->build();            $file->write();        }    }    public function getClassesWithFactoryMethods()    {        $classes = array();        $files = $this->getSortedFiles();        foreach ($files as $file) {            $class = $this->getFactoryClass($file);            if ($class !== null) {                $classes[] = $class;            }        }        return $classes;    }    public function getSortedFiles()    {        $iter = $this->getFileIterator();        $files = array();        foreach ($iter as $file) {            $files[] = $file;        }        sort($files, SORT_STRING);        return $files;    }    private function getFileIterator()    {        $factoryClass = class_exists('File_Iterator_Factory') ? 'File_Iterator_Factory' : 'SebastianBergmann\FileIterator\Factory';        $factory = new $factoryClass();        return $factory->getFileIterator($this->path, '.php');    }    public function getFactoryClass($file)    {        $name = $this->getFactoryClassName($file);        if ($name !== null) {            require_once $file;            if (class_exists($name)) {                $class = new FactoryClass(substr($file, strpos($file, 'Hamcrest/')), new ReflectionClass($name));                if ($class->isFactory()) {                    return $class;                }            }        }        return null;    }    public function getFactoryClassName($file)    {        $content = file_get_contents($file);        if (preg_match('/namespace\s+(.+);/', $content, $namespace)            && preg_match('/\n\s*class\s+(\w+)\s+extends\b/', $content, $className)            && preg_match('/@factory\b/', $content)        ) {            return $namespace[1] . '\\' . $className[1];        }        return null;    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_DecisionTree_821, This will return an array including an importance value for\n each column in the given dataset. The importance values are\n normalized and their total makes 1.<br/>\n,Ovo će vratiti niz koji sadrži vrednost važnosti za svaku kolonu u datom skupu podataka. Vrednosti važnosti su normalizovane i njihov ukupan iznos iznosi 1,"    public function getFeatureImportances(): array    {        if ($this->featureImportances !== null) {            return $this->featureImportances;        }        $sampleCount = count($this->samples);        $this->featureImportances = [];        foreach ($this->columnNames as $column => $columnName) {            $nodes = $this->getSplitNodesByColumn($column, $this->tree);            $importance = 0;            foreach ($nodes as $node) {                $importance += $node->getNodeImpurityDecrease($sampleCount);            }            $this->featureImportances[$columnName] = $importance;        }        // Normalize & sort the importances        $total = array_sum($this->featureImportances);        if ($total > 0) {            array_walk($this->featureImportances, function (&$importance) use ($total): void {                $importance /= $total;            });            arsort($this->featureImportances);        }        return $this->featureImportances;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Algebra_2491," Get factors of an integer\n The decomposition of a composite number into a product of smaller integers.\n https://en.wikipedia.org/wiki/Integer_factorization\n\n Algorithm:\n - special case: if x is 0, return [\\INF]\n - let x be |x|\n - push on 1 as a factor\n - prime factorize x\n - build sets of prime powers from primes\n - push on the product of each set\n\n @param  int $x\n @return array of factors\n\n @throws Exception\\OutOfBoundsException if n is < 1\n",Dobitijanje faktora celog broja. Razlaganje kompozitnog broja u proizvod manjih celih brojeva,"    public static function factors(int $x): array    {        // 0 has infinite factors        if ($x === 0) {            return [\INF];        }        $x       = \abs($x);        $factors = [1];        // Prime factorize x        $primes = Integer::primeFactorization($x);        // Prime powers from primes        $sets       = [];        $current    = [];        $map        = [];        $exponents  = \array_count_values($primes);        $limit      = 1;        $count      = 0;        foreach ($exponents as $prime => $exponent) {            $map[]        = $prime;            $sets[$prime] = [1, $prime];            $primePower   = $prime;            for ($n = 2; $n <= $exponent; ++$n) {                $primePower *= $prime;                $sets[$prime][$n] = $primePower;            }            $limit *= \count($sets[$prime]);            if ($count === 0) { // Skip 1 on the first prime                $current[] = \next($sets[$prime]);            } else {                $current[] = 1;            }            ++$count;        }        // Multiply distinct prime powers together        for ($i = 1; $i < $limit; ++$i) {            $factors[] = \array_product($current);            for ($i2 = 0; $i2 < $count; ++$i2) {                $current[$i2] = \next($sets[$map[$i2]]);                if ($current[$i2] !== false) {                    break;                }                $current[$i2] = \reset($sets[$map[$i2]]);            }        }        \sort($factors);        return $factors;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3490," Quartiles - Exclusive method\\n Three points that divide the data set into four equal groups, each group comprising a quarter of the data.\\n https://en.wikipedia.org/wiki/Quartile\\n\\n 0% is smallest number\\n Q1 (25%) is first quartile (lower quartile, 25th percentile)\\n Q2 (50%) is second quartile (median, 50th percentile)\\n Q3 (75%) is third quartile (upper quartile, 75th percentile)\\n 100% is largest number\\n interquartile_range is the difference between the upper and lower quartiles. (IQR = Qâ‚ƒ - Qâ‚)\\n\\n Method used\\n  - Use the median to divide the ordered data set into two halves.\\n   - If there are an odd number of data points in the original ordered data set, do not include the median\\n     (the central value in the ordered list) in either half.\\n   - If there are an even number of data points in the original ordered data set,\\n     split this data set exactly in half.\\n  - The lower quartile value is the median of the lower half of the data.\\n    The upper quartile value is the median of the upper half of the data.\\n\\n This rule is employed by the TI-83 calculator boxplot and ""1-Var Stats"" functions.\\n This is the most basic method that is commonly taught in math textbooks.\\n\\n @param float[] $numbers\\n\\n @return array (0%, Q1, Q2, Q3, 100%, IQR)\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n","Kvartili - Ekskluzivna metoda. Tri tačke koje skup podataka dele na četiri jednake grupe, a svaka grupa čini četvrtinu podataka","    public static function quartilesExclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        if (\count($numbers) === 1) {            $number = \array_pop($numbers);            return [                '0%'   => $number,                'Q1'   => $number,                'Q2'   => $number,                'Q3'   => $number,                '100%' => $number,                'IQR'  => 0,            ];        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3491," Quartiles - Inclusive method (R method)\n Three points that divide the data set into four equal groups, each group comprising a quarter of the data.\n https://en.wikipedia.org/wiki/Quartile\n\n 0% is smallest number\n Q1 (25%) is first quartile (lower quartile, 25th percentile)\n Q2 (50%) is second quartile (median, 50th percentile)\n Q3 (75%) is third quartile (upper quartile, 75th percentile)\n 100% is largest number\n interquartile_range is the difference between the upper and lower quartiles. (IQR = Qâ‚ƒ - Qâ‚)\n\n Method used\n  - Use the median to divide the ordered data set into two halves.\n   - If there are an odd number of data points in the original ordered data set,\n     include the median (the central value in the ordered list) in both halves.\n   - If there are an even number of data points in the original ordered data set,\n     split this data set exactly in half.\n  - The lower quartile value is the median of the lower half of the data.\n    The upper quartile value is the median of the upper half of the data.\n\n The values found by this method are also known as ""Tukey\'s hinges"".\n This is the method that the programming language R uses by default.\n\n @param float[] $numbers\n\n @return array (0%, Q1, Q2, Q3, 100%, IQR)\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n","Kvartili - Inkluzivna metoda (metoda R). Tri tačke koje skup podataka dele u četiri jednake grupe, a svaka grupa čini četvrtinu podataka","    public static function quartilesInclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);            // Add median to both halves            $median = Average::median($numbers);            \array_push($lower_half, $median);            \array_unshift($upper_half, $median);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_FivePointFormula_3006," Five Point Formula\n\n In numerical analysis, the five point formula is used for approximating\n the derivative of a function at a point in its domain.\n\n We can either directly supply a set of inputs and their corresponding outputs\n for said function, or if we explicitly know the function, we can define it as a\n callback function and then generate a set of points by evaluating that function\n at 5 points between a start and end point.\n","Formula sa pet tačaka. U numeričkoj analizi, formula sa pet tačaka koristi se za aproksimaciju izvoda funkcije u tački u njenom domenu. Možemo ili direktno da dostavimo skup ulaza i njihove odgovarajuće izlaze za pomenutu funkciju, ili ako eksplicitno znamo funkciju, možemo je definisati kao funkciju povratnog poziva, a zatim generisati skup tačaka procenom te funkcije u 5 tačaka između početne i krajnje tačke","class FivePointFormula extends NumericalDifferentiation{    /**     * Use the Five Point Formula to approximate the derivative of a function at     * our $target. Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose derivative we are     * approximating.     *     * The Five Point Formula requires we supply 5 points that are evenly spaced     * apart, and that our target equals the x-components of one of our 5 points.     *     * Example: differentiation(2, function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Five Point Formula:     *     *   - If the 3rd point is our $target, use the Midpoint Formula:     *     *              1                                         hâ´     *     fâ€²(xâ‚€) = - [f(xâ‚€-2h)-8f(xâ‚€-h)+8f(xâ‚€+h)-f(xâ‚€+2h)] - - fâ½âµâ¾(Î¶â‚)     *             12h                                        30     *     *         where Î¶â‚ lies between xâ‚€ - 2h and xâ‚€ + 2h     *     *   - If the 1st or 5th point is our $target, use the Endpoint Formula:     *   - Note that when the 3rd point is our $target, we use a negative h.     *     *              1                                                        hâ´     *     fâ€²(xâ‚€) = - [-25f(xâ‚€)+48f(xâ‚€+h)-36f(xâ‚€+2h)+16f(xâ‚€+3h)-3f(xâ‚€+4h)] + - fâ½âµâ¾(Î¶â‚€)     *             12h                                                       5     *     *         where Î¶â‚€ lies between xâ‚€ and xâ‚€ + 4h     *     * @param float          $target  The value at which we are approximating the derivative     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4], [4,5], [5,6]].     *                                Example callback: function($x) {return $x**2;}     * @param number         ...$args The arguments of our callback function: start,     *                                end, and n. Example: approximate($number, $source, 0, 8, 5).     *                                If $source is a set of points, do not input any     *                               $args. Example: approximate($source).     *     * @return float                 The approximation of f'($target), i.e. the derivative     *                               of our input at our target point     *     * @throws Exception\BadDataException     */    public static function differentiate(float $target, $source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input, sort points, make sure spacing is constant, and make        // sure our target is contained in an interval supplied by our $source        self::validate($points, $degree = 5);        $sorted = self::sort($points);        self::isSpacingConstant($sorted);        self::isTargetInPoints($target, $sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $h = ($sorted[4][$x] - $sorted[0][$x]) / 4;        /*         * If the 3rd point is our $target, use the Midpoint Formula:         *         *              1                                         hâ´         *     fâ€²(xâ‚€) = - [f(xâ‚€-2h)-8f(xâ‚€-h)+8f(xâ‚€+h)-f(xâ‚€+2h)] - - fâ½âµâ¾(Î¶â‚)         *             12h                                        30         *         *         where Î¶â‚ lies between xâ‚€ - 2h and xâ‚€ + 2h         */        if ($sorted[2][$x] == $target) {            $fâŸ®xâ‚€â§¿2hâŸ¯    = $sorted[0][$y];            $fâŸ®xâ‚€â§¿hâŸ¯     = $sorted[1][$y];            $fâŸ®xâ‚€â§¾hâŸ¯     = $sorted[3][$y];            $fâŸ®xâ‚€â§¾2hâŸ¯    = $sorted[4][$y];            $derivative = ($fâŸ®xâ‚€â§¿2hâŸ¯ - 8 * $fâŸ®xâ‚€â§¿hâŸ¯ + 8 * $fâŸ®xâ‚€â§¾hâŸ¯ - $fâŸ®xâ‚€â§¾2hâŸ¯) / (12 * $h);            return $derivative;        }        /*         * If the 1st or 5th point is our $target, use the Endpoint Formula:         * Note that when the 3rd point is our $target, we use a negative h.         *         *              1                                                        hâ´         *     fâ€²(xâ‚€) = - [-25f(xâ‚€)+48f(xâ‚€+h)-36f(xâ‚€+2h)+16f(xâ‚€+3h)-3f(xâ‚€+4h)] + - fâ½âµâ¾(Î¶â‚€)         *             12h                                                       5         *         *         where Î¶â‚€ lies between xâ‚€ and xâ‚€ + 4h         */        if ($sorted[0][$x] == $target) {  // The 1st point is our $target            $fâŸ®xâ‚€âŸ¯    = $sorted[0][$y];            $fâŸ®xâ‚€â§¾hâŸ¯  = $sorted[1][$y];            $fâŸ®xâ‚€â§¾2hâŸ¯ = $sorted[2][$y];            $fâŸ®xâ‚€â§¾3hâŸ¯ = $sorted[3][$y];            $fâŸ®xâ‚€â§¾4hâŸ¯ = $sorted[4][$y];        } else {                          // The 5th point is our $target, use negative h            $h = -$h;            $fâŸ®xâ‚€âŸ¯    = $sorted[4][$y];            $fâŸ®xâ‚€â§¾hâŸ¯  = $sorted[3][$y];            $fâŸ®xâ‚€â§¾2hâŸ¯ = $sorted[2][$y];            $fâŸ®xâ‚€â§¾3hâŸ¯ = $sorted[1][$y];            $fâŸ®xâ‚€â§¾4hâŸ¯ = $sorted[0][$y];        }        $derivative = (-25 * $fâŸ®xâ‚€âŸ¯ + 48 * $fâŸ®xâ‚€â§¾hâŸ¯ - 36 * $fâŸ®xâ‚€â§¾2hâŸ¯ + 16 * $fâŸ®xâ‚€â§¾3hâŸ¯ - 3 * $fâŸ®xâ‚€â§¾4hâŸ¯) / (12 * $h);        return $derivative;    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Interpolation_2987, Base class for interpolation techniques.\n,Osnovna klasa za tehnike interpolacije,"abstract class Interpolation{    /** @var int Index of x */    protected const X = 0;    /** @var int Index of y */    protected const Y = 1;    /**     * Determine where the input $source argument is a callback function, a set     * of arrays, or neither. If $source is a callback function, run it through     * the functionToPoints() method with the input $args, and set $points to     * output array. If $source is a set of arrays, simply set $points to     * $source. If $source is neither, throw an Exception.     *     * @todo  Add method to verify function is continuous on our interval     * @todo  Add method to verify input arguments are valid.     *        Verify $start and $end are numbers, $end > $start, and $points is an integer > 1     *     * @param callable|array $source The source of our approximation. Should be either a callback function or a set of arrays.     * @param array          $args   The arguments of our callback function: start, end, and n.     *                               Example: [0, 8, 5]. If $source is a set of arrays, $args will default to [].     *     * @return array     *     * @throws Exception\BadDataException if $source is not callable or a set of arrays     */    public static function getPoints($source, array $args = []): array    {        // Guard clause - source must be callable or array of points        if (!(\is_callable($source) || \is_array($source))) {            throw new Exception\BadDataException('Input source is incorrect. You need to input either a callback function or a set of arrays');        }        // Source is already an array: nothing to do        if (\is_array($source)) {            return $source;        }        // Construct points from callable function        $function = $source;        $start    = $args[0];        $end      = $args[1];        $n        = $args[2];        return self::functionToPoints($function, $start, $end, $n);    }    /**     * Evaluate our callback function at n evenly spaced points on the interval     * between start and end     *     * @param  callable $function f(x) callback function     * @param  float    $start    the start of the interval     * @param  float    $end      the end of the interval     * @param  int      $n        the number of function evaluations     *     * @return array     */    protected static function functionToPoints(callable $function, float $start, float $end, int $n): array    {        $points = [];        $h      = ($end - $start) / ($n - 1);        for ($i = 0; $i < $n; $i++) {            $xáµ¢         = $start + $i * $h;            $fâŸ®xáµ¢âŸ¯       = $function($xáµ¢);            $points[$i] = [$xáµ¢, $fâŸ®xáµ¢âŸ¯];        }        return $points;    }    /**     * Validate that there are enough input arrays (points), that each point array     * has precisely two numbers, and that no two points share the same first number     * (x-component)     *     * @param  array $points Array of arrays (points)     * @param  int   $degree The minimum number of input arrays     *     * @throws Exception\BadDataException if there are less than two points     * @throws Exception\BadDataException if any point does not contain two numbers     * @throws Exception\BadDataException if two points share the same first number (x-component)     */    public static function validate(array $points, int $degree = 2)    {        if (\count($points) < $degree) {            throw new Exception\BadDataException('You need to have at least $degree sets of coordinates (arrays) for this technique');        }        $x_coordinates = [];        foreach ($points as $point) {            if (\count($point) !== 2) {                throw new Exception\BadDataException('Each array needs to have have precisely two numbers, an x- and y-component');            }            $x_component = $point[self::X];            if (\in_array($x_component, $x_coordinates)) {                throw new Exception\BadDataException('Not a function. Your input array contains more than one coordinate with the same x-component.');            }            $x_coordinates[] = $x_component;        }    }    /**     * Sorts our coordinates (arrays) by their x-component (first number) such     * that consecutive coordinates have an increasing x-component.     *     * @param  array $points     *     * @return array[]     */    protected static function sort(array $points): array    {        \usort($points, function (array $a, array $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MidpointRule_3020," Midpoint rule\\n\\n In numerical analysis, the Midpoint rule is a technique for approximating\\n the definite integral of a function.\\n\\n The Midpoint rule belongs to the closed Newton-Cotes formulas, a group of\\n methods for numerical integration which approximate the integral of a function.\\n We can either directly supply a set of inputs and their corresponding outputs\\n for said function, or if we explicitly know the function, we can define it as a\\n callback function and then generate a set of points by evaluating that function\\n at n points between a start and end point. We then use these values to\\n interpolate a Lagrange polynomial. Finally, we integrate the Lagrange\\n polynomial to approximate the integral of our original function.\\n\\n https://en.wikipedia.org/wiki/Rectangle_method\\n http://www.efunda.com/math/num_integration/num_int_newton.cfm\\n","Pravilo srednje tačke. U numeričkoj analizi, pravilo srednje tačke je tehnika aproksimacije određenog integrala funkcije. Pravilo srednje tačke pripada zatvorenim Newton-Cotes-ovim formulama, grupi metoda za numeričku integraciju kojima se približava integral funkcije. Možemo ili direktno dostaviti skup ulaza i njihovih odgovarajućih izlaza za navedenu funkciju, ili ako funkciju eksplicitno znamo, možemo definisati to je kao funkcija povratnog poziva, a zatim generiše skup tačaka procenom te funkcije u n tačaka između početne i krajnje tačke. Zatim koristimo ove vrednosti za interpolaciju Lagrangeovog polinoma. Na kraju, integrišemo Lagrangeov polinom da bismo približili integral naše originalne funkcije","class MidpointRule extends NumericalIntegration{    /**     * Use the Midpoint rule to approximate the definite integral of a     * function f(x). Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose definite integral we     * are approximating.     *     * The bounds of the definite integral to which we are approximating is     * determined by the our inputs.     *     * Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite     * integral of the function that produces these coordinates with a lower     * bound of 0, and an upper bound of 10.     *     * Example: approximate(function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Midpoint Rule:     *     * xn        â¿â»Â¹ xáµ¢â‚Šâ‚     * âˆ« f(x)dx = âˆ‘   âˆ« f(x)dx     * xâ‚        â±â¼Â¹  xáµ¢     *     *            â¿   h     *          = âˆ‘   - [f(xáµ¢)+f(xáµ¢â‚Šâ‚)] + O(hÂ³fâ€³(x))     *           â±â¼Â¹  2     *     *  where h = xáµ¢â‚Šâ‚ - xáµ¢     *  note: this implementation does not compute the error term.     * @param callable|array $source The source of our approximation. Should be either     *                               a callback function or a set of arrays. Each array     *                               (point) contains precisely two numbers, an x and y.     *                               Example array: [[1,2], [2,3], [3,4]].     *                               Example callback: function($x) {return $x**2;}     * @param number        ...$args The arguments of our callback function: start,     *                               end, and n. Example: approximate($source, 0, 8, 5).     *                               If $source is a set of points, do not input any     *                               $args. Example: approximate($source).     *     * @return float                 The approximation to the integral of f(x)     *     * @throws Exception\BadDataException     */    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         *   â¿   h         * = âˆ‘   - [f(xáµ¢)+f(xáµ¢â‚Šâ‚)] + O(hÂ³fâ€³(x))         *  â±â¼Â¹  2         * where h = xáµ¢â‚Šâ‚ - xáµ¢         */        for ($i = 0; $i < $steps; $i++) {            $xáµ¢             = $sorted[$i][$x];            $xáµ¢â‚Šâ‚           = $sorted[$i + 1][$x];            $fâŸ®xáµ¢âŸ¯           = $sorted[$i][$y];     // yáµ¢            $fâŸ®xáµ¢â‚Šâ‚âŸ¯         = $sorted[$i + 1][$y];   // yáµ¢â‚Šâ‚            $midpoint       = ($fâŸ®xáµ¢âŸ¯ + $fâŸ®xáµ¢â‚Šâ‚âŸ¯) / 2;            $h              = $xáµ¢â‚Šâ‚ - $xáµ¢;            $approximation += $h * $midpoint;        }        return $approximation;    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NaturalCubicSpline_2992," Natural Cubic Spline Interpolating Polynomial\\n\\n In numerical analysis, cubic splines are used for polynomial\\n interpolation.\\n\\n A cubic spline is a spline constructed of piecewise third-order polynomials\\n which pass through a set of m control points."" In the case of the natural\\n cubic spline, the second derivative of each polynomial is set to zero at the\\n endpoints of each interval of the piecewise function.\\n\\n Cubic spline interpolation belongs to a collection of techniques that\\n interpolate a function or a set of values, producing a continuous polynomial.\\n In the case of the cubic spline, a piecewise function (polynomial) is produced.\\n We can either directly supply a set of inputs and their corresponding outputs\\n for said function, or if we explicitly know the function, we can define it as\\n a callback function and then generate a set of points by evaluating that\\n function at n points between a start and end point. We then use these values\\n to interpolate our piecewise polynomial.\\n\\n https://en.wikipedia.org/wiki/Spline_interpolation\\n http://mathworld.wolfram.com/CubicSpline.html\\n","Prirodni kubni splaj interpolirajući polinom. U numeričkoj analizi, kubni splajnovi se koriste za polinomsku interpolaciju. Kubični splajn je splajn izgrađen od komadnih polinoma trećeg reda koji prolaze kroz skup od m kontrolnih tačaka. ""U slučaju prirodnog kubnog splajna, drugi izvod svakog polinoma postavljen je na nulu na krajnjim tačkama svakog intervala komadne funkcije. Kubična splajna interpolacija pripada kolekciji tehnika koje interpoliraju funkciju ili skup vrednosti stvarajući neprekidni polinom. U slučaju kubnog splajna proizvodi se komadna funkcija (polinom). Možemo ili direktno dostaviti skup ulaza i njihove odgovarajuće izlaze \\ n za pomenutu funkciju, ili ako funkciju eksplicitno znamo, možemo je definisati kao funkciju povratnog poziva, a zatim generisati skup tačaka procenjujući da funkcioniše u n tačaka između početne i krajnje tačke. Zatim koristimo ove vrednosti za interpoliranje našeg komadastog polinoma","class NaturalCubicSpline extends Interpolation{    /**     * Interpolate     *     * @param callable|array $source The source of our approximation. Should be either     *                           a callback function or a set of arrays. Each array     *                           (point) contains precisely two numbers, an x and y.     *                           Example array: [[1,2], [2,3], [3,4]].     *                           Example callback: function($x) {return $x**2;}     * @param number   ...$args  The arguments of our callback function: start,     *                           end, and n. Example: approximate($source, 0, 8, 5).     *                           If $source is a set of points, do not input any     *                           $args. Example: approximate($source).     *     * @return Piecewise         The interpolating (piecewise) polynomial, as an     *                           instance of Piecewise.     *     * @throws Exception\BadDataException     */    public static function interpolate($source, ...$args): Piecewise    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 1);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n     = \count($sorted);        $k     = $n - 1;        $h     = [];        $a     = [];        $Î¼     = [0];        $z     = [0];        $z[$k] = 0;        $c     = [];        $c[$k] = 0;        $poly  = [];        $int   = [];        for ($i = 0; $i < $k; $i++) {            $xáµ¢     = $sorted[$i][$x];            $xáµ¢â‚Šâ‚   = $sorted[$i + 1][$x];            $a[$i]  = $sorted[$i][$y];            $h[$i]  = $xáµ¢â‚Šâ‚ - $xáµ¢;            if ($i == 0) {                continue;            }            $xáµ¢â‚‹â‚   = $sorted[$i - 1][$x];            $fâŸ®xáµ¢âŸ¯   = $sorted[$i][$y];    // yáµ¢            $fâŸ®xáµ¢â‚Šâ‚âŸ¯ = $sorted[$i + 1][$y];  // yáµ¢â‚Šâ‚            $fâŸ®xáµ¢â‚‹â‚âŸ¯ = $sorted[$i - 1][$y];  // yáµ¢â‚‹â‚            $Î±      = (3 / $h[$i]) * ($fâŸ®xáµ¢â‚Šâ‚âŸ¯ - $fâŸ®xáµ¢âŸ¯) - (3 / $h[$i - 1]) * ($fâŸ®xáµ¢âŸ¯ - $fâŸ®xáµ¢â‚‹â‚âŸ¯);            $l      = 2 * ($xáµ¢â‚Šâ‚ - $xáµ¢â‚‹â‚) - $h[$i - 1] * $Î¼[$i - 1];            $Î¼[$i]  = $h[$i] / $l;            $z[$i]  = ($Î± - $h[$i - 1] * $z[$i - 1]) / $l;        }        for ($i = $k - 1; $i >= 0; $i--) {            $xáµ¢       = $sorted[$i][$x];            $xáµ¢â‚Šâ‚     = $sorted[$i + 1][$x];            $fâŸ®xáµ¢âŸ¯     = $sorted[$i][$y];    // yáµ¢            $fâŸ®xáµ¢â‚Šâ‚âŸ¯   = $sorted[$i + 1][$y];  // yáµ¢â‚Šâ‚            $c[$i]    = $z[$i] - $Î¼[$i] * $c[$i + 1];            $b[$i]    = ($fâŸ®xáµ¢â‚Šâ‚âŸ¯ - $fâŸ®xáµ¢âŸ¯) / $h[$i] - $h[$i] * ($c[$i + 1] + 2 * $c[$i]) / 3;            $d[$i]    = ($c[$i + 1] - $c[$i]) / (3 * $h[$i]);            $poly[$i] = new Polynomial([                $d[$i],                $c[$i] - 3 * $d[$i] * $xáµ¢,                $b[$i] - 2 * $c[$i] * $xáµ¢ + 3 * $d[$i] * ($xáµ¢ ** 2),                $a[$i] - $b[$i] * $xáµ¢ + $c[$i] * ($xáµ¢ ** 2) - $d[$i] * ($xáµ¢ ** 3)            ]);            if ($i == 0) {                $int[$i] = [$xáµ¢, $xáµ¢â‚Šâ‚];            } else {                $int[$i] = [$xáµ¢, $xáµ¢â‚Šâ‚, true, false];            }        }        $piecewise = new Piecewise($int, $poly);        return $piecewise;    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NevillesMethod_2994," Nevilles Method\\n\\n In numerical analysis, Nevilles Method is an interpolation technique that\\n uses Lagrange polynomials of lower powers recursively in order to compute\\n Lagrange polynomials of higher powers.\\n\\n Nevilles Method belongs to a collection of techniques that interpolate a\\n function or a set of values to approximate a function at a target point.\\n We can either directly supply a set of inputs and their corresponding outputs\\n for said function, or if we explicitly know the function, we can define it as\\n a callback function and then generate a set of points by evaluating that\\n function at n points between a start and end point. We then use these values\\n to interpolate Lagrange polynomials recursively at our target point.\\n\\n http://www2.math.ou.edu/~npetrov/neville.pdf\\n","Nevilles-ova metoda. U numeričkoj analizi, Nevilles-ova metoda je tehnika interpolacije koja koristi Lagranžove polinome nižih stepena rekurzivno kako bi izračunala Lagranžove polinome viših stepena. Nevilles-ova metoda pripada kolekciji tehnika koje interpoliraju funkciju ili skup vrednosti za približavanje funkcije u ciljnoj tački. Možemo ili direktno dostaviti skup ulaza i njihove odgovarajuće izlaze za pomenutu funkciju, ili ako eksplicitno znamo funkciju, možemo je definisati kao funkciju povratnog poziva, a zatim generisati skup tačaka procenjujući tu funkciju u n tačaka između početne i krajnje tačke. Zatim koristimo ove vrednosti za interpolaciju Lagranžovih polinoma rekurzivno u našu ciljnu tačku","class NevillesMethod extends Interpolation{    /**     * Interpolate     *     * @param float          $target  The point at which we are interpolation     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4]].     *                                Example callback: function($x) {return $x**2;}     * @param float[]        ...$args The arguments of our callback function: start,     *                                end, and n. Example: approximate($source, 0, 8, 5).     *                                If $source is a set of points, do not input any     *                                $args. Example: approximate($source).     *     * @return float                  The interpolated value at our target     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     */    public static function interpolate(float $target, $source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n = \count($sorted);        $Q = [];        // Build our 0th-degree Lagrange polynomials: Qâ‚áµ¢â‚Žâ‚â‚€â‚Ž = yáµ¢ for all i < n        for ($i = 0; $i < $n; $i++) {            $Q[$i][0] = new Polynomial([$sorted[$i][$y]]); // yáµ¢        }        // Recursively generate our (n-1)th-degree Lagrange polynomial at $target        for ($i = 1; $i < $n; $i++) {            for ($j = 1; $j <= $i; $j++) {                $xáµ¢â‚‹â±¼        = $sorted[$i - $j][$x];                $xáµ¢          = $sorted[$i][$x];                $Qâ‚áµ¢â‚Žâ‚â±¼â‚‹â‚â‚Ž   = $Q[$i][$j - 1]($target);                $Qâ‚áµ¢â‚‹â‚â‚Žâ‚â±¼â‚‹â‚â‚Ž = $Q[$i - 1][$j - 1]($target);                $Q[$i][$j]   = LagrangePolynomial::interpolate([[$xáµ¢â‚‹â±¼,$Qâ‚áµ¢â‚‹â‚â‚Žâ‚â±¼â‚‹â‚â‚Ž],[$xáµ¢,$Qâ‚áµ¢â‚Žâ‚â±¼â‚‹â‚â‚Ž]]);            }        }        // Return our (n-1)th-degree Lagrange polynomial evaluated at $target        return $Q[$n - 1][$n - 1]($target);    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericalIntegration_3022," Base class for numerical integration techniques.\n\n Numerical integration techniques are used to approximate the value of\n an indefinite integral.\n\n This class gives each technique a set of common tools, and requires each\n technique to define an approximate() method to approximate an indefinite\n integral.\n",Osnovna klasa za tehnike numeričke integracije. Tehnike numeričke integracije koriste se za približavanje vrednosti neodređenog integrala. Ova klasa svakoj tehnici daje skup uobičajenih alata i zahteva da svaka tehnika odredi n approximate() metoda za približavanje neodređenog integrala,"abstract class NumericalIntegration{    /** @var int Index of x */    protected const X = 0;    /** @var int Index of y */    protected const Y = 1;    abstract public static function approximate($source, ...$args);    /**     * Determine where the input $source argument is a callback function, a set     * of arrays, or neither. If $source is a callback function, run it through     * the functionToPoints() method with the input $args, and set $points to     * output array. If $source is a set of arrays, simply set $points to     * $source. If $source is neither, throw an Exception.     *     * @todo  Add method to verify function is continuous on our interval     * @todo  Add method to verify input arguments are valid.     *        Verify $start and $end are numbers, $end > $start, and $points is an integer > 1     *     * @param  callable|array  $source The source of our approximation. Should be either     *                                 a callback function or a set of arrays.     * @param  array           $args   The arguments of our callback function: start,     *                                 end, and n. Example: [0, 8, 5]. If $source is a     *                                 set of arrays, $args will default to [].     *     * @return array     *     * @throws Exception\BadDataException if $source is not callable or a set of arrays     */    public static function getPoints($source, array $args = []): array    {        // Guard clause - source must be callable or array of points        if (!(\is_callable($source) || \is_array($source))) {            throw new Exception\BadDataException('Input source is incorrect. You need to input either a callback function or a set of arrays');        }        // Source is already an array: nothing to do        if (\is_array($source)) {            return $source;        }        // Construct points from callable function        $function = $source;        $start    = $args[0];        $end      = $args[1];        $n        = $args[2];        return self::functionToPoints($function, $start, $end, $n);    }    /**     * Evaluate our callback function at n evenly spaced points on the interval between start and end     *     * @param  callable $function f(x) callback function     * @param  float    $start    the start of the interval     * @param  float    $end      the end of the interval     * @param  int      $n        the number of function evaluations     *     * @return array     */    protected static function functionToPoints(callable $function, float $start, float $end, int $n): array    {        $points = [];        $h      = ($end - $start) / ($n - 1);        for ($i = 0; $i < $n; $i++) {            $xáµ¢         = $start + $i * $h;            $fâŸ®xáµ¢âŸ¯       = $function($xáµ¢);            $points[$i] = [$xáµ¢, $fâŸ®xáµ¢âŸ¯];        }        return $points;    }    /**     * Validate that there are enough input arrays (points), that each point array     * has precisely two numbers, and that no two points share the same first number     * (x-component)     *     * @param  array $points Array of arrays (points)     * @param  int   $degree The minimum number of input arrays     *     * @throws Exception\BadDataException if there are less than two points     * @throws Exception\BadDataException if any point does not contain two numbers     * @throws Exception\BadDataException if two points share the same first number (x-component)     */    public static function validate(array $points, int $degree = 2)    {        if (\count($points) < $degree) {            throw new Exception\BadDataException(""You need to have at least $degree sets of coordinates (arrays) for this technique"");        }        $x_coordinates = [];        foreach ($points as $point) {            if (\count($point) !== 2) {                throw new Exception\BadDataException('Each array needs to have have precisely two numbers, an x- and y-component');            }            $x_component = $point[self::X];            if (\in_array($x_component, $x_coordinates)) {                throw new Exception\BadDataException('Not a function. Your input array contains more than one coordinate with the same x-component.');            }            $x_coordinates[] = $x_component;        }    }    /**     * Sorts our coordinates (arrays) by their x-component (first number) such     * that consecutive coordinates have an increasing x-component.     *     * @param  array[] $points     *     * @return array[]     */    protected static function sort(array $points): array    {        \usort($points, function ($a, $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2158, Common class implementing the logic needed to support clustering strategies.\\n\\n @author Daniele Alessandri <suppakilla@gmail.com>\\n,,"abstract class ClusterStrategy implements StrategyInterface{    protected $commands;    /**     *     */    public function __construct()    {        $this->commands = $this->getDefaultCommands();    }    /**     * Returns the default map of supported commands with their handlers.     *     * @return array     */    protected function getDefaultCommands()    {        $getKeyFromFirstArgument = array($this, 'getKeyFromFirstArgument');        $getKeyFromAllArguments = array($this, 'getKeyFromAllArguments');        return array(            /* commands operating on the key space */            'EXISTS' => $getKeyFromAllArguments,            'DEL' => $getKeyFromAllArguments,            'TYPE' => $getKeyFromFirstArgument,            'EXPIRE' => $getKeyFromFirstArgument,            'EXPIREAT' => $getKeyFromFirstArgument,            'PERSIST' => $getKeyFromFirstArgument,            'PEXPIRE' => $getKeyFromFirstArgument,            'PEXPIREAT' => $getKeyFromFirstArgument,            'TTL' => $getKeyFromFirstArgument,            'PTTL' => $getKeyFromFirstArgument,            'SORT' => array($this, 'getKeyFromSortCommand'),            'DUMP' => $getKeyFromFirstArgument,            'RESTORE' => $getKeyFromFirstArgument,            /* commands operating on string values */            'APPEND' => $getKeyFromFirstArgument,            'DECR' => $getKeyFromFirstArgument,            'DECRBY' => $getKeyFromFirstArgument,            'GET' => $getKeyFromFirstArgument,            'GETBIT' => $getKeyFromFirstArgument,            'MGET' => $getKeyFromAllArguments,            'SET' => $getKeyFromFirstArgument,            'GETRANGE' => $getKeyFromFirstArgument,            'GETSET' => $getKeyFromFirstArgument,            'INCR' => $getKeyFromFirstArgument,            'INCRBY' => $getKeyFromFirstArgument,            'INCRBYFLOAT' => $getKeyFromFirstArgument,            'SETBIT' => $getKeyFromFirstArgument,            'SETEX' => $getKeyFromFirstArgument,            'MSET' => array($this, 'getKeyFromInterleavedArguments'),            'MSETNX' => array($this, 'getKeyFromInterleavedArguments'),            'SETNX' => $getKeyFromFirstArgument,            'SETRANGE' => $getKeyFromFirstArgument,            'STRLEN' => $getKeyFromFirstArgument,            'SUBSTR' => $getKeyFromFirstArgument,            'BITOP' => array($this, 'getKeyFromBitOp'),            'BITCOUNT' => $getKeyFromFirstArgument,            'BITFIELD' => $getKeyFromFirstArgument,            /* commands operating on lists */            'LINSERT' => $getKeyFromFirstArgument,            'LINDEX' => $getKeyFromFirstArgument,            'LLEN' => $getKeyFromFirstArgument,            'LPOP' => $getKeyFromFirstArgument,            'RPOP' => $getKeyFromFirstArgument,            'RPOPLPUSH' => $getKeyFromAllArguments,            'BLPOP' => array($this, 'getKeyFromBlockingListCommands'),            'BRPOP' => array($this, 'getKeyFromBlockingListCommands'),            'BRPOPLPUSH' => array($this, 'getKeyFromBlockingListCommands'),            'LPUSH' => $getKeyFromFirstArgument,            'LPUSHX' => $getKeyFromFirstArgument,            'RPUSH' => $getKeyFromFirstArgument,            'RPUSHX' => $getKeyFromFirstArgument,            'LRANGE' => $getKeyFromFirstArgument,            'LREM' => $getKeyFromFirstArgument,            'LSET' => $getKeyFromFirstArgument,            'LTRIM' => $getKeyFromFirstArgument,            /* commands operating on sets */            'SADD' => $getKeyFromFirstArgument,            'SCARD' => $getKeyFromFirstArgument,            'SDIFF' => $getKeyFromAllArguments,            'SDIFFSTORE' => $getKeyFromAllArguments,            'SINTER' => $getKeyFromAllArguments,            'SINTERSTORE' => $getKeyFromAllArguments,            'SUNION' => $getKeyFromAllArguments,            'SUNIONSTORE' => $getKeyFromAllArguments,            'SISMEMBER' => $getKeyFromFirstArgument,            'SMEMBERS' => $getKeyFromFirstArgument,            'SSCAN' => $getKeyFromFirstArgument,            'SPOP' => $getKeyFromFirstArgument,            'SRANDMEMBER' => $getKeyFromFirstArgument,            'SREM' => $getKeyFromFirstArgument,            /* commands operating on sorted sets */            'ZADD' => $getKeyFromFirstArgument,            'ZCARD' => $getKeyFromFirstArgument,            'ZCOUNT' => $getKeyFromFirstArgument,            'ZINCRBY' => $getKeyFromFirstArgument,            'ZINTERSTORE' => array($this, 'getKeyFromZsetAggregationCommands'),            'ZRANGE' => $getKeyFromFirstArgument,            'ZRANGEBYSCORE' => $getKeyFromFirstArgument,            'ZRANK' => $getKeyFromFirstArgument,            'ZREM' => $getKeyFromFirstArgument,            'ZREMRANGEBYRANK' => $getKeyFromFirstArgument,            'ZREMRANGEBYSCORE' => $getKeyFromFirstArgument,            'ZREVRANGE' => $getKeyFromFirstArgument,            'ZREVRANGEBYSCORE' => $getKeyFromFirstArgument,            'ZREVRANK' => $getKeyFromFirstArgument,            'ZSCORE' => $getKeyFromFirstArgument,            'ZUNIONSTORE' => array($this, 'getKeyFromZsetAggregationCommands'),            'ZSCAN' => $getKeyFromFirstArgument,            'ZLEXCOUNT' => $getKeyFromFirstArgument,            'ZRANGEBYLEX' => $getKeyFromFirstArgument,            'ZREMRANGEBYLEX' => $getKeyFromFirstArgument,            'ZREVRANGEBYLEX' => $getKeyFromFirstArgument,            /* commands operating on hashes */            'HDEL' => $getKeyFromFirstArgument,            'HEXISTS' => $getKeyFromFirstArgument,            'HGET' => $getKeyFromFirstArgument,            'HGETALL' => $getKeyFromFirstArgument,            'HMGET' => $getKeyFromFirstArgument,            'HMSET' => $getKeyFromFirstArgument,            'HINCRBY' => $getKeyFromFirstArgument,            'HINCRBYFLOAT' => $getKeyFromFirstArgument,            'HKEYS' => $getKeyFromFirstArgument,            'HLEN' => $getKeyFromFirstArgument,            'HSET' => $getKeyFromFirstArgument,            'HSETNX' => $getKeyFromFirstArgument,            'HVALS' => $getKeyFromFirstArgument,            'HSCAN' => $getKeyFromFirstArgument,            'HSTRLEN' => $getKeyFromFirstArgument,            /* commands operating on HyperLogLog */            'PFADD' => $getKeyFromFirstArgument,            'PFCOUNT' => $getKeyFromAllArguments,            'PFMERGE' => $getKeyFromAllArguments,            /* scripting */            'EVAL' => array($this, 'getKeyFromScriptingCommands'),            'EVALSHA' => array($this, 'getKeyFromScriptingCommands'),            /* commands performing geospatial operations */            'GEOADD' => $getKeyFromFirstArgument,            'GEOHASH' => $getKeyFromFirstArgument,            'GEOPOS' => $getKeyFromFirstArgument,            'GEODIST' => $getKeyFromFirstArgument,            'GEORADIUS' => array($this, 'getKeyFromGeoradiusCommands'),            'GEORADIUSBYMEMBER' => array($this, 'getKeyFromGeoradiusCommands'),        );    }    /**     * Returns the list of IDs for the supported commands.     *     * @return array     */    public function getSupportedCommands()    {        return array_keys($this->commands);    }    /**     * Sets an handler for the specified command ID.     *     * The signature of the callback must have a single parameter of type     * Predis\Command\CommandInterface.     *     * When the callback argument is omitted or NULL, the previously associated     * handler for the specified command ID is removed.     *     * @param string $commandID Command ID.     * @param mixed  $callback  A valid callable object, or NULL to unset the handler.     *     * @throws \InvalidArgumentException     */    public function setCommandHandler($commandID, $callback = null)    {        $commandID = strtoupper($commandID);        if (!isset($callback)) {            unset($this->commands[$commandID]);            return;        }        if (!is_callable($callback)) {            throw new \InvalidArgumentException(                'The argument must be a callable object or NULL.'            );        }        $this->commands[$commandID] = $callback;    }    /**     * Extracts the key from the first argument of a command instance.     *     * @param CommandInterface $command Command instance.     *     * @return string     */    protected function getKeyFromFirstArgument(CommandInterface $command)    {        return $command->getArgument(0);    }    /**     * Extracts the key from a command with multiple keys only when all keys in     * the arguments array produce the same hash.     *     * @param CommandInterface $command Command instance.     *     * @return string|null     */    protected function getKeyFromAllArguments(CommandInterface $command)    {        $arguments = $command->getArguments();        if ($this->checkSameSlotForKeys($arguments)) {            return $arguments[0];        }    }    /**     * Extracts the key from a command with multiple keys only when all keys in     * the arguments array produce the same hash.     *     * @param CommandInterface $command Command instance.     *     * @return string|null     */    protected function getKeyFromInterleavedArguments(CommandInterface $command)    {        $arguments = $command->getArguments();        $keys = array();        for ($i = 0; $i < count($arguments); $i += 2) {            $keys[] = $arguments[$i];        }        if ($this->checkSameSlotForKeys($keys)) {            return $arguments[0];        }    }    /**     * Extracts the key from SORT command.     *     * @param CommandInterface $command Command instance.     *     * @return string|null     */    protected function getKeyFromSortCommand(CommandInterface $command)    {        $arguments = $command->getArguments();        $firstKey = $arguments[0];        if (1 === $argc = count($arguments)) {            return $firstKey;        }        $keys = array($firstKey);        for ($i = 1; $i < $argc; ++$i) {            if (strtoupper($arguments[$i]) === 'STORE') {                $keys[] = $arguments[++$i];            }        }        if ($this->checkSameSlotForKeys($keys)) {            return $firstKey;        }    }    /**     * Extracts the key from BLPOP and BRPOP commands.     *     * @param CommandInterface $command Command instance.     *     * @return string|null     */    protected function getKeyFromBlockingListCommands(CommandInterface $command)    {        $arguments = $command->getArguments();        if ($this->checkSameSlotForKeys(array_slice($arguments, 0, count($arguments) - 1))) {            return $arguments[0];        }    }    /**     * Extracts the key from BITOP command.     *     * @param CommandInterface $command Command instance.     *     * @return string|null     */    protected function getKeyFromBitOp(CommandInterface $command)    {        $arguments = $command->getArguments();        if ($this->checkSameSlotForKeys(array_slice($arguments, 1, count($arguments)))) {            return $arguments[1];        }    }    /**     * Extracts the key from GEORADIUS and GEORADIUSBYMEMBER commands.     *     * @param CommandInterface $command Command instance.     *     * @return string|null     */    protected function getKeyFromGeoradiusCommands(CommandInterface $command)    {        $arguments = $command->getArguments();        $argc = count($arguments);        $startIndex = $command->getId() === 'GEORADIUS' ? 5 : 4;        if ($argc > $startIndex) {            $keys = array($arguments[0]);            for ($i = $startIndex; $i < $argc; ++$i) {                $argument = strtoupper($arguments[$i]);                if ($argument === 'STORE' || $argument === 'STOREDIST') {                    $keys[] = $arguments[++$i];                }            }            if ($this->checkSameSlotForKeys($keys)) {                return $arguments[0];            } else {                return;            }        }        return $arguments[0];    }    /**     * Extracts the key from ZINTERSTORE and ZUNIONSTORE commands.     *     * @param CommandInterface $command Command instance.     *     * @return string|null     */    protected function getKeyFromZsetAggregationCommands(CommandInterface $command)    {        $arguments = $command->getArguments();        $keys = array_merge(array($arguments[0]), array_slice($arguments, 2, $arguments[1]));        if ($this->checkSameSlotForKeys($keys)) {            return $arguments[0];        }    }    /**     * Extracts the key from EVAL and EVALSHA commands.     *     * @param CommandInterface $command Command instance.     *     * @return string|null     */    protected function getKeyFromScriptingCommands(CommandInterface $command)    {        if ($command instanceof ScriptCommand) {            $keys = $command->getKeys();        } else {            $keys = array_slice($args = $command->getArguments(), 2, $args[1]);        }        if ($keys && $this->checkSameSlotForKeys($keys)) {            return $keys[0];        }    }    /**     * {@inheritdoc}     */    public function getSlot(CommandInterface $command)    {        $slot = $command->getSlot();        if (!isset($slot) && isset($this->commands[$cmdID = $command->getId()])) {            $key = call_user_func($this->commands[$cmdID], $command);            if (isset($key)) {                $slot = $this->getSlotByKey($key);                $command->setSlot($slot);            }        }        return $slot;    }    /**     * Checks if the specified array of keys will generate the same hash.     *     * @param array $keys Array of keys.     *     * @return bool     */    protected function checkSameSlotForKeys(array $keys)    {        if (!$count = count($keys)) {            return false;        }        $currentSlot = $this->getSlotByKey($keys[0]);        for ($i = 1; $i < $count; ++$i) {            $nextSlot = $this->getSlotByKey($keys[$i]);            if ($currentSlot !== $nextSlot) {                return false;            }            $currentSlot = $nextSlot;        }        return true;    }    /**     * Returns only the hashable part of a key (delimited by ""{...}""), or the     * whole key if a key tag is not found in the string.     *     * @param string $key A key.     *     * @return string     */    protected function extractKeyTag($key)    {        if (false !== $start = strpos($key, '{')) {            if (false !== ($end = strpos($key, '}', $start)) && $end !== ++$start) {                $key = substr($key, $start, $end - $start);            }        }        return $key;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_DoubleComparator_2337, Compares doubles for equality.\\n,Upoređuje dve vrednosti da li su jednake,"class DoubleComparator extends NumericComparator{    /**     * Smallest value available in PHP.     *     * @var float     */    public const EPSILON = 0.0000000001;    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return (is_float($expected) || is_float($actual)) && is_numeric($expected) && is_numeric($actual);    }    /**     * Asserts that two values are equal.     *     * @param mixed $expected     First value to compare     * @param mixed $actual       Second value to compare     * @param float $delta        Allowed numerical distance between two values to consider them equal     * @param bool  $canonicalize Arrays are sorted before comparison when set to true     * @param bool  $ignoreCase   Case is ignored when set to true     *     * @throws ComparisonFailure     */    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false)/*: void*/    {        if ($delta == 0) {            $delta = self::EPSILON;        }        parent::assertEquals($expected, $actual, $delta, $canonicalize, $ignoreCase);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_880, Prints out the gathered config data.\\n\\n @param array $data The config data to print.\\n\\n @return void\\n,Štampa prikupljene podatke o konfiguraciji,"    public function printConfigData($data)    {        $max  = 0;        $keys = array_keys($data);        foreach ($keys as $key) {            $len = strlen($key);            if (strlen($key) > $max) {                $max = $len;            }        }        if ($max === 0) {            return;        }        $max += 2;        ksort($data);        foreach ($data as $name => $value) {            echo str_pad($name.': ', $max).$value.PHP_EOL;        }    }//end printConfigData()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Reporter_900, Generate summary information to be used during report generation.\n\n @param \\PHP_CodeSniffer\\Files\\File $phpcsFile The file that has been processed.\n\n @return array\n,Generišite sažete informacije koje će se koristiti tokom generisanja izveštaja,"    public function prepareFileReport(File $phpcsFile)    {        $report = [            'filename' => Common::stripBasepath($phpcsFile->getFilename(), $this->config->basepath),            'errors'   => $phpcsFile->getErrorCount(),            'warnings' => $phpcsFile->getWarningCount(),            'fixable'  => $phpcsFile->getFixableCount(),            'messages' => [],        ];        if ($report['errors'] === 0 && $report['warnings'] === 0) {            // Prefect score!            return $report;        }        if ($this->config->recordErrors === false) {            $message  = 'Errors are not being recorded but this report requires error messages. ';            $message .= 'This report will not show the correct information.';            $report['messages'][1][1] = [                [                    'message'  => $message,                    'source'   => 'Internal.RecordErrors',                    'severity' => 5,                    'fixable'  => false,                    'type'     => 'ERROR',                ],            ];            return $report;        }        $errors = [];        // Merge errors and warnings.        foreach ($phpcsFile->getErrors() as $line => $lineErrors) {            foreach ($lineErrors as $column => $colErrors) {                $newErrors = [];                foreach ($colErrors as $data) {                    $newErrors[] = [                        'message'  => $data['message'],                        'source'   => $data['source'],                        'severity' => $data['severity'],                        'fixable'  => $data['fixable'],                        'type'     => 'ERROR',                    ];                }                $errors[$line][$column] = $newErrors;            }            ksort($errors[$line]);        }//end foreach        foreach ($phpcsFile->getWarnings() as $line => $lineWarnings) {            foreach ($lineWarnings as $column => $colWarnings) {                $newWarnings = [];                foreach ($colWarnings as $data) {                    $newWarnings[] = [                        'message'  => $data['message'],                        'source'   => $data['source'],                        'severity' => $data['severity'],                        'fixable'  => $data['fixable'],                        'type'     => 'WARNING',                    ];                }                if (isset($errors[$line]) === false) {                    $errors[$line] = [];                }                if (isset($errors[$line][$column]) === true) {                    $errors[$line][$column] = array_merge(                        $newWarnings,                        $errors[$line][$column]                    );                } else {                    $errors[$line][$column] = $newWarnings;                }            }//end foreach            ksort($errors[$line]);        }//end foreach        ksort($errors);        $report['messages'] = $errors;        return $report;    }//end prepareFileReport()",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Ruleset_902, Prints a report showing the sniffs contained in a standard.\n\n @return void\n,Štampa izveštaj koji prikazuje njuškanja (sniffs) sadržana u standardu,"    public function explain()    {        $sniffs = array_keys($this->sniffCodes);        sort($sniffs);        ob_start();        $lastStandard = null;        $lastCount    = '';        $sniffCount   = count($sniffs);        // Add a dummy entry to the end so we loop        // one last time and clear the output buffer.        $sniffs[] = '';        echo PHP_EOL.""The $this->name standard contains $sniffCount sniffs"".PHP_EOL;        ob_start();        foreach ($sniffs as $i => $sniff) {            if ($i === $sniffCount) {                $currentStandard = null;            } else {                $currentStandard = substr($sniff, 0, strpos($sniff, '.'));                if ($lastStandard === null) {                    $lastStandard = $currentStandard;                }            }            if ($currentStandard !== $lastStandard) {                $sniffList = ob_get_contents();                ob_end_clean();                echo PHP_EOL.$lastStandard.' ('.$lastCount.' sniff';                if ($lastCount > 1) {                    echo 's';                }                echo ')'.PHP_EOL;                echo str_repeat('-', (strlen($lastStandard.$lastCount) + 10));                echo PHP_EOL;                echo $sniffList;                $lastStandard = $currentStandard;                $lastCount    = 0;                if ($currentStandard === null) {                    break;                }                ob_start();            }//end if            echo '  '.$sniff.PHP_EOL;            $lastCount++;        }//end foreach    }//end explain()",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_FileBag_7860," Fixes a malformed PHP $_FILES array.\n\n PHP has a bug that the format of the $_FILES array differs, depending on\n whether the uploaded file fields had normal field names or array-like\n field names (""normal"" vs. ""parent[child]"").\n\n This method fixes the array to look like the ""normal"" $_FILES array.\n\n It\'s safe to pass an already converted array, in which case this method\n just returns the original array unmodified.\n\n @param array $data\n\n @return array\n","Ispravlja pogrešno oblikovan PHP $ _FILES niz. PHP ima grešku u tome što se format niza $ _FILES razlikuje, u zavisnosti od toga da li su otpremljena polja datoteka imala normalna imena polja ili imena polja poput (""normal"" vs. ""parent[child]""). Ovaj metod popravlja niz tako da izgleda kao ""normalni"" niz $ _FILES. Sigurno je proslediti već pretvoreni niz, u tom slučaju ovaj metod samo vraća originalni niz neizmenjen","    protected function fixPhpFilesArray($data)    {        $keys = array_keys($data);        sort($keys);        if (self::FILE_KEYS != $keys || !isset($data['name']) || !\is_array($data['name'])) {            return $data;        }        $files = $data;        foreach (self::FILE_KEYS as $k) {            unset($files[$k]);        }        foreach ($data['name'] as $key => $name) {            $files[$key] = $this->fixPhpFilesArray([                'error' => $data['error'][$key],                'name' => $name,                'type' => $data['type'][$key],                'tmp_name' => $data['tmp_name'][$key],                'size' => $data['size'][$key],            ]);        }        return $files;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_NodeTraverser_10135, Traverses a node and calls the registered visitors.\n,Prelazi čvor i poziva registrovane posetioce,"    public function traverse(Node $node): Node    {        ksort($this->visitors);        foreach ($this->visitors as $visitors) {            foreach ($visitors as $visitor) {                $node = $this->traverseForVisitor($visitor, $node);            }        }        return $node;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_6966, Get global event-loop instance.\n\n @return EventInterface\n,Nabavite globalnu instancu petlje događaja,"    protected static function formatStatusData($statistics_file)    {        static $total_request_cache = array();        if (!\is_readable($statistics_file)) {            return '';        }        $info = \file($statistics_file, \FILE_IGNORE_NEW_LINES);        if (!$info) {            return '';        }        $status_str = '';        $current_total_request = array();        $worker_info = \unserialize($info[0]);        \ksort($worker_info, SORT_NUMERIC);        unset($info[0]);        $data_waiting_sort = array();        $read_process_status = false;        $total_requests = 0;        $total_qps = 0;        $total_connections = 0;        $total_fails = 0;        $total_memory = 0;        $total_timers = 0;        $maxLen1 = static::$_maxSocketNameLength;        $maxLen2 = static::$_maxWorkerNameLength;        foreach($info as $key => $value) {            if (!$read_process_status) {                $status_str .= $value . ""\n"";                if (\preg_match('/^pid.*?memory.*?listening/', $value)) {                    $read_process_status = true;                }                continue;            }            if(\preg_match('/^[0-9]+/', $value, $pid_math)) {                $pid = $pid_math[0];                $data_waiting_sort[$pid] = $value;                if(\preg_match('/^\S+?\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?/', $value, $match)) {                    $total_memory += \intval(\str_ireplace('M','',$match[1]));                    $maxLen1 = \max($maxLen1,\strlen($match[2]));                    $maxLen2 = \max($maxLen2,\strlen($match[3]));                    $total_connections += \intval($match[4]);                    $total_fails += \intval($match[5]);                    $total_timers += \intval($match[6]);                    $current_total_request[$pid] = $match[7];                    $total_requests += \intval($match[7]);                }            }        }        foreach($worker_info as $pid => $info) {            if (!isset($data_waiting_sort[$pid])) {                $status_str .= ""$pid\t"" . \str_pad('N/A', 7) . "" ""                    . \str_pad($info['listen'], static::$_maxSocketNameLength) . "" ""                    . \str_pad($info['name'], static::$_maxWorkerNameLength) . "" ""                    . \str_pad('N/A', 11) . "" "" . \str_pad('N/A', 9) . "" ""                    . \str_pad('N/A', 7) . "" "" . \str_pad('N/A', 13) . "" N/A    [busy] \n"";                continue;            }            //$qps = isset($total_request_cache[$pid]) ? $current_total_request[$pid]            if (!isset($total_request_cache[$pid]) || !isset($current_total_request[$pid])) {                $qps = 0;            } else {                $qps = $current_total_request[$pid] - $total_request_cache[$pid];                $total_qps += $qps;            }            $status_str .= $data_waiting_sort[$pid]. "" "" . \str_pad($qps, 6) ."" [idle]\n"";        }        $total_request_cache = $current_total_request;        $status_str .= ""----------------------------------------------PROCESS STATUS---------------------------------------------------\n"";        $status_str .= ""Summary\t"" . \str_pad($total_memory.'M', 7) . "" ""            . \str_pad('-', $maxLen1) . "" ""            . \str_pad('-', $maxLen2) . "" ""            . \str_pad($total_connections, 11) . "" "" . \str_pad($total_fails, 9) . "" ""            . \str_pad($total_timers, 7) . "" "" . \str_pad($total_requests, 13) . "" ""            . \str_pad($total_qps,6)."" [Summary] \n"";        return $status_str;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_BaseYii_991, Returns a string representing the current version of the Yii framework.\\\\n @return string the version of Yii framework\\\\n,Prikazuje niz koji predstavlja trenutnu verziju Iii okvira,"    public static function setAlias($alias, $path)    {        if (strncmp($alias, '@', 1)) {            $alias = '@' . $alias;        }        $pos = strpos($alias, '/');        $root = $pos === false ? $alias : substr($alias, 0, $pos);        if ($path !== null) {            $path = strncmp($path, '@', 1) ? rtrim($path, '\\/') : static::getAlias($path);            if (!isset(static::$aliases[$root])) {                if ($pos === false) {                    static::$aliases[$root] = $path;                } else {                    static::$aliases[$root] = [$alias => $path];                }            } elseif (is_string(static::$aliases[$root])) {                if ($pos === false) {                    static::$aliases[$root] = $path;                } else {                    static::$aliases[$root] = [                        $alias => $path,                        $root => static::$aliases[$root],                    ];                }            } else {                static::$aliases[$root][$alias] = $path;                krsort(static::$aliases[$root]);            }        } elseif (isset(static::$aliases[$root])) {            if (is_array(static::$aliases[$root])) {                unset(static::$aliases[$root][$alias]);            } elseif ($pos === false) {                unset(static::$aliases[$root]);            }        }    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_PhpDocController_965, Markdown aware fix of whitespace issues in doc comments.\\n @param array $lines\\n,Ispravljanje problema sa praznim prostorom u komentarima dokumenata,"class ReleaseController extends Controller{    public $defaultAction = 'release';    /**     * @var string base path to use for releases.     */    public $basePath;    /**     * @var bool whether to make actual changes. If true, it will run without changing or pushing anything.     */    public $dryRun = false;    /**     * @var bool whether to fetch latest tags.     */    public $update = false;    /**     * @var string override the default version. e.g. for major or patch releases.     */    public $version;    public function options($actionID)    {        $options = ['basePath'];        if ($actionID === 'release') {            $options[] = 'dryRun';            $options[] = 'version';        } elseif ($actionID === 'sort-changelog') {            $options[] = 'version';        } elseif ($actionID === 'info') {            $options[] = 'update';        }        return array_merge(parent::options($actionID), $options);    }    public function beforeAction($action)    {        if (!$this->interactive) {            throw new Exception('Sorry, but releases should be run interactively to ensure you actually verify what you are doing ;)');        }        if ($this->basePath === null) {            $this->basePath = \dirname(\dirname(__DIR__));        }        $this->basePath = rtrim($this->basePath, '\\/');        return parent::beforeAction($action);    }    /**     * Shows information about current framework and extension versions.     */    public function actionInfo()    {        $items = [            'framework',            'app-basic',            'app-advanced',        ];        $extensionPath = ""{$this->basePath}/extensions"";        foreach (scandir($extensionPath) as $extension) {            if (ctype_alpha($extension) && is_dir($extensionPath . '/' . $extension)) {                $items[] = $extension;            }        }        if ($this->update) {            foreach ($items as $item) {                $this->stdout(""fetching tags for $item..."");                if ($item === 'framework') {                    $this->gitFetchTags((string)$this->basePath);                } elseif (strncmp('app-', $item, 4) === 0) {                    $this->gitFetchTags(""{$this->basePath}/apps/"" . substr($item, 4));                } else {                    $this->gitFetchTags(""{$this->basePath}/extensions/$item"");                }                $this->stdout(""done.\n"", Console::FG_GREEN, Console::BOLD);            }        } else {            $this->stdout(""\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n"");        }        $versions = $this->getCurrentVersions($items);        $nextVersions = $this->getNextVersions($versions, self::PATCH);        // print version table        $w = $this->minWidth(array_keys($versions));        $this->stdout(str_repeat(' ', $w + 2) . ""Current Version  Next Version\n"", Console::BOLD);        foreach ($versions as $ext => $version) {            $this->stdout($ext . str_repeat(' ', $w + 3 - mb_strlen($ext)) . $version . '');            $this->stdout(str_repeat(' ', 17 - mb_strlen($version)) . $nextVersions[$ext] . ""\n"");        }    }    private function minWidth($a)    {        $w = 1;        foreach ($a as $s) {            if (($l = mb_strlen($s)) > $w) {                $w = $l;            }        }        return $w;    }    /**     * Automation tool for making Yii framework and official extension releases.     *     * Usage:     *     * To make a release, make sure your git is clean (no uncommitted changes) and run the following command in     * the yii dev repo root:     *     * ```     * ./build/build release framework     * ```     *     * or     *     * ```     * ./build/build release redis,bootstrap,apidoc     * ```     *     * You may use the `--dryRun` switch to test the command without changing or pushing anything:     *     * ```     * ./build/build release redis --dryRun     * ```     *     * The command will guide you through the complete release process including changing of files,     * committing and pushing them. Each git command must be confirmed and can be skipped individually.     * You may adjust changes in a separate shell or your IDE while the command is waiting for confirmation.     *     * @param array $what what do you want to release? this can either be:     *     * - an extension name such as `redis` or `bootstrap`,     * - an application indicated by prefix `app-`, e.g. `app-basic`,     * - or `framework` if you want to release a new version of the framework itself.     *     * @return int     */    public function actionRelease(array $what)    {        if (\count($what) > 1) {            $this->stdout(""Currently only one simultaneous release is supported.\n"");            return 1;        }        $this->stdout(""This is the Yii release manager\n\n"", Console::BOLD);        if ($this->dryRun) {            $this->stdout(""Running in \""dry-run\"" mode, nothing will actually be changed.\n\n"", Console::BOLD, Console::FG_GREEN);        }        $this->validateWhat($what);        $versions = $this->getCurrentVersions($what);        if ($this->version !== null) {            // if a version is explicitly given            $newVersions = [];            foreach ($versions as $k => $v) {                $newVersions[$k] = $this->version;            }        } else {            // otherwise get next patch or minor            $newVersions = $this->getNextVersions($versions, self::PATCH);        }        $this->stdout(""You are about to prepare a new release for the following things:\n\n"");        $this->printWhat($what, $newVersions, $versions);        $this->stdout(""\n"");        $this->stdout(""Before you make a release briefly go over the changes and check if you spot obvious mistakes:\n\n"", Console::BOLD);        $gitDir = reset($what) === 'framework' ? 'framework/' : '';        $gitVersion = $versions[reset($what)];        if (strncmp('app-', reset($what), 4) !== 0) {            $this->stdout(""- no accidentally added CHANGELOG lines for other versions than this one?\n\n    git diff $gitVersion.. ${gitDir}CHANGELOG.md\n\n"");            $this->stdout(""- are all new `@since` tags for this release version?\n"");        }        $this->stdout(""- other issues with code changes?\n\n    git diff -w $gitVersion.. ${gitDir}\n\n"");        $travisUrl = reset($what) === 'framework' ? '' : '-' . reset($what);        $this->stdout(""- are unit tests passing on travis? https://travis-ci.com/yiisoft/yii2$travisUrl/builds\n"");        $this->stdout(""- also make sure the milestone on github is complete and no issues or PRs are left open.\n\n"");        $this->printWhatUrls($what, $versions);        $this->stdout(""\n"");        if (!$this->confirm('When you continue, this tool will run cleanup jobs and update the changelog as well as other files (locally). Continue?', false)) {            $this->stdout(""Canceled.\n"");            return 1;        }        foreach ($what as $ext) {            if ($ext === 'framework') {                $this->releaseFramework(""{$this->basePath}/framework"", $newVersions['framework']);            } elseif (strncmp('app-', $ext, 4) === 0) {                $this->releaseApplication(substr($ext, 4), ""{$this->basePath}/apps/"" . substr($ext, 4), $newVersions[$ext]);            } else {                $this->releaseExtension($ext, ""{$this->basePath}/extensions/$ext"", $newVersions[$ext]);            }        }        return 0;    }    /**     * This will generate application packages for download page.     *     * Usage:     *     * ```     * ./build/build release/package app-basic     * ```     *     * @param array $what what do you want to package? this can either be:     *     * - an application indicated by prefix `app-`, e.g. `app-basic`,     *     * @return int     */    public function actionPackage(array $what)    {        $this->validateWhat($what, ['app']);        $versions = $this->getCurrentVersions($what);        $this->stdout(""You are about to generate packages for the following things:\n\n"");        foreach ($what as $ext) {            if (strncmp('app-', $ext, 4) === 0) {                $this->stdout(' - ');                $this->stdout(substr($ext, 4), Console::FG_RED);                $this->stdout(' application version ');            } elseif ($ext === 'framework') {                $this->stdout(' - Yii Framework version ');            } else {                $this->stdout(' - ');                $this->stdout($ext, Console::FG_RED);                $this->stdout(' extension version ');            }            $this->stdout($versions[$ext], Console::BOLD);            $this->stdout(""\n"");        }        $this->stdout(""\n"");        $packagePath = ""{$this->basePath}/packages"";        $this->stdout(""Packages will be stored in $packagePath\n\n"");        if (!$this->confirm('Continue?', false)) {            $this->stdout(""Canceled.\n"");            return 1;        }        foreach ($what as $ext) {            if ($ext === 'framework') {                throw new Exception('Can not package framework.');            } elseif (strncmp('app-', $ext, 4) === 0) {                $this->packageApplication(substr($ext, 4), $versions[$ext], $packagePath);            } else {                throw new Exception('Can not package extension.');            }        }        $this->stdout(""\ndone. verify the versions composer installed above and push it to github!\n\n"");        return 0;    }    /**     * Sorts CHANGELOG for framework or extension.     *     * @param array $what what do you want to resort changelog for? this can either be:     *     * - an extension name such as `redis` or `bootstrap`,     * - or `framework` if you want to release a new version of the framework itself.     */    public function actionSortChangelog(array $what)    {        if (\count($what) > 1) {            $this->stdout(""Currently only one simultaneous release is supported.\n"");            return 1;        }        $this->validateWhat($what, ['framework', 'ext'], false);        $version = $this->version ?: array_values($this->getNextVersions($this->getCurrentVersions($what), self::PATCH))[0];        $this->stdout('sorting CHANGELOG of ');        $this->stdout(reset($what), Console::BOLD);        $this->stdout(' for version ');        $this->stdout($version, Console::BOLD);        $this->stdout('...');        $this->resortChangelogs($what, $version);        $this->stdout(""done.\n"", Console::BOLD, Console::FG_GREEN);    }    protected function printWhat(array $what, $newVersions, $versions)    {        foreach ($what as $ext) {            if (strncmp('app-', $ext, 4) === 0) {                $this->stdout(' - ');                $this->stdout(substr($ext, 4), Console::FG_RED);                $this->stdout(' application version ');            } elseif ($ext === 'framework') {                $this->stdout(' - Yii Framework version ');            } else {                $this->stdout(' - ');                $this->stdout($ext, Console::FG_RED);                $this->stdout(' extension version ');            }            $this->stdout($newVersions[$ext], Console::BOLD);            $this->stdout("", last release was {$versions[$ext]}\n"");        }    }    protected function printWhatUrls(array $what, $oldVersions)    {        foreach ($what as $ext) {            if ($ext === 'framework') {                $this->stdout(""framework:    https://github.com/yiisoft/yii2-framework/compare/{$oldVersions[$ext]}...master\n"");                $this->stdout(""app-basic:    https://github.com/yiisoft/yii2-app-basic/compare/{$oldVersions[$ext]}...master\n"");                $this->stdout(""app-advanced: https://github.com/yiisoft/yii2-app-advanced/compare/{$oldVersions[$ext]}...master\n"");            } else {                $this->stdout($ext, Console::FG_RED);                $this->stdout("": https://github.com/yiisoft/yii2-$ext/compare/{$oldVersions[$ext]}...master\n"");            }        }    }    /**     * @param array $what list of items     * @param array $limit list of things to allow, or empty to allow any, can be `app`, `framework`, `extension`     * @param bool $ensureGitClean     * @throws \yii\base\Exception     */    protected function validateWhat(array $what, $limit = [], $ensureGitClean = true)    {        foreach ($what as $w) {            if (strncmp('app-', $w, 4) === 0) {                if (!empty($limit) && !\in_array('app', $limit)) {                    throw new Exception('Only the following types are allowed: ' . implode(', ', $limit) . ""\n"");                }                if (!is_dir($appPath = ""{$this->basePath}/apps/"" . substr($w, 4))) {                    throw new Exception(""Application path does not exist: \""{$appPath}\""\n"");                }                if ($ensureGitClean) {                    $this->ensureGitClean($appPath);                }            } elseif ($w === 'framework') {                if (!empty($limit) && !\in_array('framework', $limit)) {                    throw new Exception('Only the following types are allowed: ' . implode(', ', $limit) . ""\n"");                }                if (!is_dir($fwPath = ""{$this->basePath}/framework"")) {                    throw new Exception(""Framework path does not exist: \""{$this->basePath}/framework\""\n"");                }                if ($ensureGitClean) {                    $this->ensureGitClean($fwPath);                }            } else {                if (!empty($limit) && !\in_array('ext', $limit)) {                    throw new Exception('Only the following types are allowed: ' . implode(', ', $limit) . ""\n"");                }                if (!is_dir($extPath = ""{$this->basePath}/extensions/$w"")) {                    throw new Exception(""Extension path for \""$w\"" does not exist: \""{$this->basePath}/extensions/$w\""\n"");                }                if ($ensureGitClean) {                    $this->ensureGitClean($extPath);                }            }",0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Utf8Controller_985, Equivalent for ord() just for unicode.\\n\\n http://stackoverflow.com/a/10333324/1106908\\n\\n @param $c\\n @return bool|int\\n,Ekvivalent za ord () samo za unicode http://stackoverflow.com/a/10333324/1106908,"class YiiConfig extends Config{    /**     * {@inheritdoc}     */    public function __construct($name = 'yii-cs-config')    {        parent::__construct($name);        $this->setRiskyAllowed(true);        $this->setRules([            '@PSR2' => true,            'array_syntax' => [                'syntax' => 'short',            ],            'binary_operator_spaces' => [                'align_double_arrow' => false,                'align_equals' => false,            ],            'blank_line_after_opening_tag' => true,            'cast_spaces' => true,            'concat_space' => [                'spacing' => 'one',            ],            'dir_constant' => true,            'ereg_to_preg' => true,            'function_typehint_space' => true,            'hash_to_slash_comment' => true,            'include' => true,            'heredoc_to_nowdoc' => true,            'is_null' => [                'use_yoda_style' => false,            ],            'linebreak_after_opening_tag' => true,            'lowercase_cast' => true,            'magic_constant_casing' => true,//            'mb_str_functions' => true, // needs more discussion//            'method_separation' => true, // conflicts with current Yii style with double line between properties and methods            'modernize_types_casting' => true,            'native_function_casing' => true,            'new_with_braces' => true,            'no_alias_functions' => true,            'no_blank_lines_after_class_opening' => true,            'no_blank_lines_after_phpdoc' => true,            'no_empty_comment' => true,            'no_empty_phpdoc' => true,            'no_empty_statement' => true,            'no_extra_consecutive_blank_lines' => [                'tokens' => [                    'break',                    'continue',//                    'extra', // conflicts with current Yii style with double line between properties and methods                    'return',                    'throw',                    'use',                    'use_trait',//                    'curly_brace_block', // breaks namespaces blocks                    'parenthesis_brace_block',                    'square_brace_block',                ],            ],            'no_leading_import_slash' => true,            'no_leading_namespace_whitespace' => true,            'no_mixed_echo_print' => true,            'no_multiline_whitespace_around_double_arrow' => true,            'no_multiline_whitespace_before_semicolons' => true,            'no_php4_constructor' => true,            'no_short_bool_cast' => true,            'no_singleline_whitespace_before_semicolons' => true,            'no_spaces_around_offset' => true,            'no_trailing_comma_in_list_call' => true,            'no_trailing_comma_in_singleline_array' => true,            'no_unneeded_control_parentheses' => true,            'no_unused_imports' => true,            'no_useless_else' => true,            'no_useless_return' => true,            'no_whitespace_before_comma_in_array' => true,            'no_whitespace_in_blank_line' => true,            'non_printable_character' => true,            'normalize_index_brace' => true,            'object_operator_without_whitespace' => true,//            'ordered_class_elements' => [ // needs more discussion//                'order' => [//                    'use_trait',//                    'constant_public',//                    'constant_protected',//                    'constant_private',//                    'property_public',//                    'property_protected',//                    'property_private',//                    'construct',//                    'destruct',//                    'magic',//                ],//            ],            'ordered_imports' => [                'sortAlgorithm' => 'alpha',                'importsOrder' => [                    'const',                    'function',                    'class',                ],            ],            'php_unit_construct' => true,            'php_unit_dedicate_assert' => true,            'php_unit_fqcn_annotation' => true,//            'php_unit_strict' => true, // needs more attention            'phpdoc_add_missing_param_annotation' => true,            'phpdoc_indent' => true,//            'phpdoc_inline_tag' => true, // see https://github.com/yiisoft/yii2/issues/11635            'phpdoc_no_access' => true,            'phpdoc_no_empty_return' => true,            'phpdoc_no_package' => true,            'phpdoc_no_useless_inheritdoc' => true,//            'phpdoc_order', // may be useful, but should be configurable: https://github.com/FriendsOfPHP/PHP-CS-Fixer/issues/1602            'phpdoc_return_self_reference' => true,            'phpdoc_scalar' => true,            'phpdoc_single_line_var_spacing' => true,            'phpdoc_summary' => true,//            'phpdoc_to_comment' => true, // breaks phpdoc for define('CONSTANT', $value);            'phpdoc_trim' => true,            'phpdoc_types' => true,            'phpdoc_var_without_name' => true,            'protected_to_private' => true,            'psr4' => true,            'self_accessor' => true,            'short_scalar_cast' => true,            'single_blank_line_before_namespace' => true,            'single_quote' => true,            'standardize_not_equals' => true,            'ternary_operator_spaces' => true,            'trailing_comma_in_multiline_array' => true,            'trim_array_spaces' => true,            'unary_operator_spaces' => true,            'whitespace_after_comma_in_array' => true,        ]);    }    /**     * Merge current rules config with provided list of rules.     *     * @param array $rules     * @return $this     * @see setRules()     * @see ArrayHelper::merge()     */    public function mergeRules(array $rules)    {        $this->setRules(ArrayHelper::merge($this->getRules(), $rules));        return $this;    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Correlation_3480, Ï„ - Kendall rank correlation coefficient (Kendall's tau)\\n\\n A statistic used to measure the ordinal association between two\\n measured quantities. It is a measure of rank correlation:\\n the similarity of the orderings of the data when ranked by each\\n of the quantities.\\n https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient\\n https://onlinecourses.science.psu.edu/stat509/node/158\\n\\n tau-a (no rank ties):\\n\\n        nc - nd\\n   Ï„ = ----------\\n       n(n - 1)/2\\n\\n   Where\\n     nc: number of concordant pairs\\n     nd: number of discordant pairs\\n\\n tau-b (rank ties exist):\\n\\n                 nc - nd\\n   Ï„ = -----------------------------\\n       âˆš(nc + nd + Xâ‚€)(nc + nd + Yâ‚€)\\n\\n   Where\\n     Xâ‚€: number of pairs tied only on the X variable\\n     Yâ‚€: number of pairs tied only on the Y variable\\n\\n @param array $X values for random variable X\\n @param array $Y values for random variable Y\\n\\n @todo Implement with algorithm faster than O(nÂ²)\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if both random variables do not have the same number of elements\\n,,"    public static function kendallsTau(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('Both random variables must have the same number of elements');        }        $n = \count($X);        // Match X and Y pairs and sort by X rank        $xy = \array_map(            function ($x, $y) {                return [$x, $y];            },            $X,            $Y        );        \usort($xy, function ($a, $b) {            return $a[0] <=> $b[0];        });        // Initialize counters        $nc      = 0;  // concordant pairs        $nd      = 0;  // discordant pairs        $ties_x  = 0;  // ties xáµ¢ = xâ±¼        $ties_y  = 0;  // ties yáµ¢ = yâ±¼        $ties_xy = 0;  // ties xáµ¢ = xâ±¼ and yáµ¢ = yâ±¼        // Tally concordant, discordant, and tied pairs        for ($i = 0; $i < $n; $i++) {            for ($j = $i + 1; $j < $n; $j++) {                // xáµ¢ = xâ±¼ and yáµ¢ = yâ±¼ -- neither concordant or discordant                if ($xy[$i][self::X] == $xy[$j][self::X] && $xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_xy++;                // xáµ¢ = xâ±¼ -- neither concordant or discordant                } elseif ($xy[$i][self::X] == $xy[$j][self::X]) {                    $ties_x++;                // yáµ¢ = yâ±¼ -- neither concordant or discordant                } elseif ($xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_y++;                // xáµ¢ < xâ±¼ and yáµ¢ < yâ±¼ -- concordant                } elseif ($xy[$i][self::X] < $xy[$j][self::X] && $xy[$i][self::Y] < $xy[$j][self::Y]) {                    $nc++;                // xáµ¢ > xâ±¼ and yáµ¢ < yâ±¼ or  xáµ¢ < xâ±¼ and yáµ¢ > yâ±¼ -- discordant                } else {                    $nd++;                }            }        }        // Numerator: (number of concordant pairs) - (number of discordant pairs)        $âŸ®ncÂ âˆ’Â ndâŸ¯ = $nc - $nd;        /* tau-a (no rank ties):         *         *        nc - nd         *   Ï„ = ----------         *       n(n - 1)/2         */        if ($ties_x == 0 && $ties_y == 0) {            return $âŸ®ncÂ âˆ’Â ndâŸ¯ / (($n * ($n - 1)) / 2);        }        /* tau-b (rank ties exist):         *         *                 nc - nd         *   Ï„ = -----------------------------         *       âˆš(nc + nd + Xâ‚€)(nc + nd + Yâ‚€)         */        return $âŸ®ncÂ âˆ’Â ndâŸ¯ / \sqrt(($nc + $nd + $ties_x) * ($nc + $nd + $ties_y));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_BackupCommand_657, Saves a backups of current state of image core\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Čuva rezervne kopije trenutnog stanja jezgra slike,"    public function execute($image)    {        $backupName = $this->argument(0)->value();        // clone current image resource        $clone = clone $image;        $image->setBackup($clone->getCore(), $backupName);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessorTest_1026, Template can be saved in temporary location.\n\n @covers ::save\n @covers ::zip\n @test\n,Predložak se može sačuvati na privremenoj lokaciji,"    final public function testTemplateCanBeSavedInTemporaryLocation()    {        $templateFqfn = __DIR__ . '/_files/templates/with_table_macros.docx';        $templateProcessor = new TemplateProcessor($templateFqfn);        $xslDomDocument = new \DOMDocument();        $xslDomDocument->load(__DIR__ . '/_files/xsl/remove_tables_by_needle.xsl');        foreach (array('${employee.', '${scoreboard.', '${reference.') as $needle) {            $templateProcessor->applyXslStyleSheet($xslDomDocument, array('needle' => $needle));        }        $embeddingText = 'The quick Brown Fox jumped over the lazy^H^H^H^Htired unitTester';        $templateProcessor->zip()->AddFromString('word/embeddings/fox.bin', $embeddingText);        $documentFqfn = $templateProcessor->save();        $this->assertNotEmpty($documentFqfn, 'FQFN of the saved document is empty.');        $this->assertFileExists($documentFqfn, ""The saved document \""{$documentFqfn}\"" doesn't exist."");        $templateZip = new \ZipArchive();        $templateZip->open($templateFqfn);        $templateHeaderXml = $templateZip->getFromName('word/header1.xml');        $templateMainPartXml = $templateZip->getFromName('word/document.xml');        $templateFooterXml = $templateZip->getFromName('word/footer1.xml');        if (false === $templateZip->close()) {            throw new \Exception(""Could not close zip file \""{$templateZip}\""."");        }        $documentZip = new \ZipArchive();        $documentZip->open($documentFqfn);        $documentHeaderXml = $documentZip->getFromName('word/header1.xml');        $documentMainPartXml = $documentZip->getFromName('word/document.xml');        $documentFooterXml = $documentZip->getFromName('word/footer1.xml');        $documentEmbedding = $documentZip->getFromName('word/embeddings/fox.bin');        if (false === $documentZip->close()) {            throw new \Exception(""Could not close zip file \""{$documentZip}\""."");        }        $this->assertNotEquals($templateHeaderXml, $documentHeaderXml);        $this->assertNotEquals($templateMainPartXml, $documentMainPartXml);        $this->assertNotEquals($templateFooterXml, $documentFooterXml);        $this->assertEquals($embeddingText, $documentEmbedding);        return $documentFqfn;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_949, Saves the result document.\n\n @throws \\PhpOffice\\PhpWord\\Exception\\Exception\n\n @return string\n,Čuva rezultujući dokument,"    public function save()    {        foreach ($this->tempDocumentHeaders as $index => $xml) {            $this->savePartWithRels($this->getHeaderName($index), $xml);        }        $this->savePartWithRels($this->getMainPartName(), $this->tempDocumentMainPart);        $this->savePartWithRels($this->getSettingsPartName(), $this->tempDocumentSettingsPart);        foreach ($this->tempDocumentFooters as $index => $xml) {            $this->savePartWithRels($this->getFooterName($index), $xml);        }        $this->zipClass->addFromString($this->getDocumentContentTypesName(), $this->tempDocumentContentTypes);        // Close zip file        if (false === $this->zipClass->close()) {            throw new Exception('Could not close zip file.'); // @codeCoverageIgnore        }        return $this->tempDocumentFilename;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_161, Get a list of all implemented functions as an array of function objects\\\\n\\\\n @return    array of PHPExcel_Calculation_Function\\\\n,Nabavite listu svih implementiranih funkcija kao niz objekata funkcije,"    public function listFunctions()    {        $returnValue = array();        foreach (self::$PHPExcelFunctions as $functionName => $function) {            if ($function['functionCall'] != 'PHPExcel_Calculation_Functions::DUMMY') {                $returnValue[$functionName] = new PHPExcel_Calculation_Function(                    $function['category'],                    $functionName,                    $function['functionCall']                );            }        }        return $returnValue;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_163, Get a list of implemented Excel function names\\n\\n @return    array\\n,Nabavite listu implementiranih imena Excel funkcija,    public function listFunctionNames()    {        $returnValue = array();        foreach (self::$PHPExcelFunctions as $functionName => $function) {            if ($function['functionCall'] != 'PHPExcel_Calculation_Functions::DUMMY') {                $returnValue[] = $functionName;            }        }        return $returnValue;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AdminAttributesGroupsController_873, Overrides parent to delete items from sublist.\\n\\n @return mixed\\n,Zamenjuje nadređenog za brisanje stavki sa podspisa,    public function processBulkDelete()    {        // If we are deleting attributes instead of attribute_groups        if (Tools::getIsset('attributeBox')) {            $this->className = 'Attribute';            $this->table = 'attribute';            $this->boxes = Tools::getValue($this->table . 'Box');        }        $result = parent::processBulkDelete();        // Restore vars        $this->className = 'AttributeGroup';        $this->table = 'attribute_group';        return $result;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_1262, Set a fallback message to use if no listener matches.\n\n @param callable $callback\n,Podesite rezervnu poruku koja će se koristiti ako se nijedan listener ne podudara,    public function fallback($callback)    {        $this->fallbackMessage = $callback;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_Language_364, Get the list of the known languages.\\n\\n @return array\\n,Dođite do liste poznatih jezika,    public static function all()    {        if (!static::$languagesNames) {            static::$languagesNames = require __DIR__.'/List/languages.php';        }        return static::$languagesNames;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_376, Embeds a file inside the PDF\n\n @param string $filepath path to the file to store inside the PDF\n @param string $embeddedFilename the filename displayed in the list of embedded files\n @param string $description a description in the list of embedded files\n,Ugrađuje datoteku u PDF,"    public function addEmbeddedFile(string $filepath, string $embeddedFilename, string $description): void    {        $this->numObj++;        $this->o_embedded_file_dictionary(            $this->numObj,            'new',            [                'filepath' => $filepath,                'filename' => $embeddedFilename,                'description' => $description            ]        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Client_633, Returns the list of scopes requested by the client\\\\n @return array the list of scopes\\\\n\\\\n,Vraća listu opsega koje zahteva klijent,  public function getScopes()  {     return $this->requestedScopes;  },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3439, Calculate the median average of a list of numbers\\n\\n @param float[] $numbers\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if kth-smallest k is out of bounds\\n,Izračunajte srednji prosek liste brojeva,"    public static function median(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median of an empty list of numbers');        }        if (\count($numbers) === 1) {            return \array_pop($numbers);        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // For odd number of numbers, take the middle indexed number        if (\count($numbers) % 2 == 1) {            $middle_index = \intdiv(\count($numbers), 2);            return self::kthSmallest($numbers, $middle_index);        }        // For even number of items, take the mean of the middle two indexed numbers        $left_middle_index  = \intdiv(\count($numbers), 2) - 1;        $left_median        = self::kthSmallest($numbers, $left_middle_index);        $right_middle_index = $left_middle_index + 1;        $right_median       = self::kthSmallest($numbers, $right_middle_index);        return self::mean([ $left_median, $right_median ]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3465," Get a report of all the averages over a list of numbers\n Includes mean, median mode, geometric mean, harmonic mean, quardratic mean\n\n @param array $numbers\n\n @return array [ mean, median, mode, geometric_mean, harmonic_mean,\n                 contraharmonic_mean, quadratic_mean, trimean, iqm, cubic_mean ]\n\n @throws Exception\\BadDataException\n @throws Exception\\OutOfBoundsException\n","Dohvatite izveštaj o svim prosecima preko liste brojeva. Uključuje srednju vrednost, medijanu, geometrijsku sredinu, harmoničnu sredinu, kvadratnu sredinu","    public static function describe(array $numbers): array    {        return [            'mean'                => self::mean($numbers),            'median'              => self::median($numbers),            'mode'                => self::mode($numbers),            'geometric_mean'      => self::geometricMean($numbers),            'harmonic_mean'       => self::harmonicMean($numbers),            'contraharmonic_mean' => self::contraharmonicMean($numbers),            'quadratic_mean'      => self::quadraticMean($numbers),            'trimean'             => self::trimean($numbers),            'iqm'                 => self::iqm($numbers),            'cubic_mean'          => self::cubicMean($numbers),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Expectation_447, Return a string with the method name and arguments formatted\\\\\\\\n\\\\\\\\n @param string $name Name of the expected method\\\\\\\\n @param array $args List of arguments to the method\\\\\\\\n @return string\\\\\\\\n,Vrati niz sa formatiranim imenom metode i argumentima,"    public function __toString()    {        return \Mockery::formatArgs($this->_name, $this->_expectedArgs);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericDiagonalMatrix_2704, Diagonal matrix\\n Elements along the main diagonal are the only non-zero elements (may also be zero).\\n The off-diagonal elements are all zero\\n,Dijagonalna matrica. Elementi duž glavne dijagonale su jedini elementi koji nisu nula (mogu biti i nula). Svi elementi izvan dijagonale su nula,"class NumericDiagonalMatrix extends NumericSquareMatrix{    /**     * Constructor     *     * @param array $A     */    public function __construct(array $A)    {        parent::__construct($A);        if (!parent::isLowerTriangular() || !parent::isUpperTriangular()) {            throw new MatrixException('Trying to construct DiagonalMatrix with non-diagonal elements: ' . \print_r($this->A, true));        }    }    /**     * Diagonal matrix must be symmetric     * @inheritDoc     */    public function isSymmetric(): bool    {        return true;    }    /**     * Diagonal matrix must be lower triangular     * @inheritDoc     */    public function isLowerTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be upper triangular     * @inheritDoc     */    public function isUpperTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be triangular     * @inheritDoc     */    public function isTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be diagonal     * @inheritDoc     */    public function isDiagonal(): bool    {        return true;    }}",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Hypergeometric_3242," Mode of the distribution\\n\\n         _              _\\n        | (n + 1)(K + 1) |       | (n + 1)(K + 1) |\\n mode = | -------------- | - 1,  | -------------- |\\n        |    (N + 2)     |       |_    (N + 2)   _|\\n\\n @return float[]\\n","Način distribucije   | (n + 1)(K + 1) |       | (n + 1)(K + 1) |\\n mode = | -------------- | - 1,  | -------------- |\\n        |    (N + 2)     |       |_    (N + 2)   ","    public function mode(): array    {        $N = $this->N;        $K = $this->K;        $n = $this->n;        return [            \ceil((($n + 1) * ($K + 1)) / ($N + 2)) - 1,            \floor((($n + 1) * ($K + 1)) / ($N + 2)),        ];    }",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_7397, Check connection is successfully established or faild.\n\n @param resource $socket\n @return void\n,Proverite da li je veza uspešno uspostavljena ili nije uspela,    public function cancelReconnect()    {        if ($this->_reconnectTimer) {            Timer::del($this->_reconnectTimer);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7009, Parse local socket address.\n\n @throws Exception\n,Analizirajte adresu lokalnog soketa,"    public function run()    {        //Update process state.        static::$_status = static::STATUS_RUNNING;        // Register shutdown function for checking errors.        \register_shutdown_function(array(""\\Workerman\\Worker"", 'checkErrors'));        // Set autoload root path.        Autoloader::setRootPath($this->_autoloadRootPath);        // Create a global event loop.        if (!static::$globalEvent) {            $event_loop_class = static::getEventLoopName();            static::$globalEvent = new $event_loop_class;            $this->resumeAccept();        }        // Reinstall signal.        static::reinstallSignal();        // Init Timer.        Timer::init(static::$globalEvent);        // Set an empty onMessage callback.        if (empty($this->onMessage)) {            $this->onMessage = function () {};        }        \restore_error_handler();        // Try to emit onWorkerStart callback.        if ($this->onWorkerStart) {            try {                \call_user_func($this->onWorkerStart, $this);            } catch (\Exception $e) {                static::log($e);                // Avoid rapid infinite loop exit.                sleep(1);                exit(250);            } catch (\Error $e) {                static::log($e);                // Avoid rapid infinite loop exit.                sleep(1);                exit(250);            }        }        // Main loop.        static::$globalEvent->loop();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_1742," ExceptionHandler converts an exception to a Response object.\\n\\n It is mostly useful in debug mode to replace the default PHP/XDebug\\n output with something prettier and more useful.\\n\\n As this class is mainly used during Kernel boot, where nothing is yet\\n available, the Response content is always HTML.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n @author Nicolas Grekas <p@tchwork.com>\\n\\n @final since Symfony 4.3\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\ErrorHandler instead.\\n","ExceptionHandler pretvara izuzetak u objekat Response. U režimu otklanjanja grešaka uglavnom je korisno zameniti podrazumevani PHP/XSDebug izlaz nečim lepšim i korisnijim. Kako se ova klasa uglavnom koristi tokom pokretanja kernela, gde još uvek ništa nije dostupno, sadržaj odgovora je uvek HTML","class ExceptionHandler{    private const GHOST_ADDONS = [        '02-14' => self::GHOST_HEART,        '02-29' => self::GHOST_PLUS,        '10-18' => self::GHOST_GIFT,    ];    private const GHOST_GIFT = 'M124.005 5.36c.396-.715 1.119-1.648-.124-1.873-.346-.177-.692-.492-1.038-.141-.769.303-1.435.728-.627 1.523.36.514.685 1.634 1.092 1.758.242-.417.47-.842.697-1.266zm-1.699 1.977c-.706-1.26-1.274-2.612-2.138-3.774-1.051-1.123-3.122-.622-3.593.825-.625 1.431.724 3.14 2.251 2.96 1.159.02 2.324.072 3.48-.011zm5.867.043c1.502-.202 2.365-2.092 1.51-3.347-.757-1.34-2.937-1.387-3.698-.025-.659 1.1-1.23 2.25-1.835 3.38 1.336.077 2.686.06 4.023-.008zm2.487 1.611c.512-.45 2.494-.981.993-1.409-.372-.105-.805-.59-1.14-.457-.726.902-1.842 1.432-3.007 1.376-.228.075-1.391-.114-1.077.1.822.47 1.623.979 2.474 1.395.595-.317 1.173-.667 1.757-1.005zm-11.696.255l1.314-.765c-1.338-.066-2.87.127-3.881-.95-.285-.319-.559-.684-.954-.282-.473.326-1.929.66-.808 1.058.976.576 1.945 1.167 2.946 1.701.476-.223.926-.503 1.383-.762zm6.416 2.846c.567-.456 1.942-.89 1.987-1.38-1.282-.737-2.527-1.56-3.87-2.183-.461-.175-.835.094-1.207.328-1.1.654-2.225 1.267-3.288 1.978 1.39.86 2.798 1.695 4.219 2.504.725-.407 1.44-.83 2.16-1.247zm5.692 1.423l1.765-1.114c-.005-1.244.015-2.488-.019-3.732a77.306 77.306 0 0 0-3.51 2.084c-.126 1.282-.062 2.586-.034 3.876.607-.358 1.2-.741 1.798-1.114zm-13.804-.784c.06-1.06.19-2.269-1.09-2.583-.807-.376-1.926-1.341-2.548-1.332-.02 1.195-.01 2.39-.011 3.585 1.192.744 2.364 1.524 3.582 2.226.119-.616.041-1.269.067-1.896zm8.541 4.105l2.117-1.336c-.003-1.284.05-2.57-.008-3.853-.776.223-1.662.91-2.48 1.337l-1.834 1.075c.012 1.37-.033 2.744.044 4.113.732-.427 1.443-.887 2.161-1.336zm-2.957-.72v-2.057c-1.416-.828-2.828-1.664-4.25-2.482-.078 1.311-.033 2.627-.045 3.94 1.416.887 2.817 1.798 4.25 2.655.057-.683.036-1.372.045-2.057zm8.255 2.755l1.731-1.153c-.024-1.218.06-2.453-.062-3.658-1.2.685-2.358 1.464-3.537 2.195.028 1.261-.058 2.536.072 3.786.609-.373 1.2-.777 1.796-1.17zm-13.851-.683l-.014-1.916c-1.193-.746-2.37-1.517-3.58-2.234-.076 1.224-.033 2.453-.044 3.679 1.203.796 2.392 1.614 3.61 2.385.048-.636.024-1.276.028-1.914zm8.584 4.199l2.102-1.396c-.002-1.298.024-2.596-.01-3.893-1.427.88-2.843 1.775-4.25 2.686-.158 1.253-.055 2.545-.056 3.811.437.266 1.553-.912 2.214-1.208zm-2.988-.556c-.085-.894.365-2.154-.773-2.5-1.146-.727-2.288-1.46-3.45-2.163-.17 1.228.008 2.508-.122 3.751a79.399 79.399 0 0 0 4.278 2.885c.117-.641.044-1.32.067-1.973zm-4.872-.236l-5.087-3.396c.002-3.493-.047-6.988.015-10.48.85-.524 1.753-.954 2.627-1.434-.564-1.616.25-3.58 1.887-4.184 1.372-.563 3.025-.055 3.9 1.13l1.906-.978 1.916.987c.915-1.086 2.483-1.706 3.842-1.097 1.631.573 2.52 2.532 1.936 4.145.88.497 1.837.886 2.644 1.492.036 3.473 0 6.946-.003 10.419-3.374 2.233-6.693 4.55-10.122 6.699-.997 0-1.858-1.083-2.783-1.522a735.316 735.316 0 0 1-2.678-1.781z';    private const GHOST_HEART = 'M125.914 8.305c3.036-8.71 14.933 0 0 11.2-14.932-11.2-3.036-19.91 0-11.2z';    private const GHOST_PLUS = 'M111.368 8.97h7.324V1.645h7.512v7.323h7.324v7.513h-7.324v7.323h-7.512v-7.323h-7.324z';    private $debug;    private $charset;    private $handler;    private $caughtBuffer;    private $caughtLength;    private $fileLinkFormat;    public function __construct(bool $debug = true, string $charset = null, $fileLinkFormat = null)    {        $this->debug = $debug;        $this->charset = $charset ?: ini_get('default_charset') ?: 'UTF-8';        $this->fileLinkFormat = $fileLinkFormat;    }    /**     * Registers the exception handler.     *     * @param bool        $debug          Enable/disable debug mode, where the stack trace is displayed     * @param string|null $charset        The charset used by exception messages     * @param string|null $fileLinkFormat The IDE link template     *     * @return static     */    public static function register($debug = true, $charset = null, $fileLinkFormat = null)    {        $handler = new static($debug, $charset, $fileLinkFormat);        $prev = set_exception_handler([$handler, 'handle']);        if (\is_array($prev) && $prev[0] instanceof ErrorHandler) {            restore_exception_handler();            $prev[0]->setExceptionHandler([$handler, 'handle']);        }        return $handler;    }    /**     * Sets a user exception handler.     *     * @param callable $handler An handler that will be called on Exception     *     * @return callable|null The previous exception handler if any     */    public function setHandler(callable $handler = null)    {        $old = $this->handler;        $this->handler = $handler;        return $old;    }    /**     * Sets the format for links to source files.     *     * @param string|FileLinkFormatter $fileLinkFormat The format for links to source files     *     * @return string The previous file link format     */    public function setFileLinkFormat($fileLinkFormat)    {        $old = $this->fileLinkFormat;        $this->fileLinkFormat = $fileLinkFormat;        return $old;    }    /**     * Sends a response for the given Exception.     *     * To be as fail-safe as possible, the exception is first handled     * by our simple exception handler, then by the user exception handler.     * The latter takes precedence and any output from the former is cancelled,     * if and only if nothing bad happens in this handling path.     */    public function handle(\Exception $exception)    {        if (null === $this->handler || $exception instanceof OutOfMemoryException) {            $this->sendPhpResponse($exception);            return;        }        $caughtLength = $this->caughtLength = 0;        ob_start(function ($buffer) {            $this->caughtBuffer = $buffer;            return '';        });        $this->sendPhpResponse($exception);        while (null === $this->caughtBuffer && ob_end_flush()) {            // Empty loop, everything is in the condition        }        if (isset($this->caughtBuffer[0])) {            ob_start(function ($buffer) {                if ($this->caughtLength) {                    // use substr_replace() instead of substr() for mbstring overloading resistance                    $cleanBuffer = substr_replace($buffer, '', 0, $this->caughtLength);                    if (isset($cleanBuffer[0])) {                        $buffer = $cleanBuffer;                    }                }                return $buffer;            });            echo $this->caughtBuffer;            $caughtLength = ob_get_length();        }        $this->caughtBuffer = null;        try {            ($this->handler)($exception);            $this->caughtLength = $caughtLength;        } catch (\Exception $e) {            if (!$caughtLength) {                // All handlers failed. Let PHP handle that now.                throw $exception;            }        }    }    /**     * Sends the error associated with the given Exception as a plain PHP response.     *     * This method uses plain PHP functions like header() and echo to output     * the response.     *     * @param \Throwable|FlattenException $exception A \Throwable or FlattenException instance     */    public function sendPhpResponse($exception)    {        if ($exception instanceof \Throwable) {            $exception = FlattenException::createFromThrowable($exception);        }        if (!headers_sent()) {            header(sprintf('HTTP/1.0 %s', $exception->getStatusCode()));            foreach ($exception->getHeaders() as $name => $value) {                header($name.': '.$value, false);            }            header('Content-Type: text/html; charset='.$this->charset);        }        echo $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the full HTML content associated with the given exception.     *     * @param \Exception|FlattenException $exception An \Exception or FlattenException instance     *     * @return string The HTML content as a string     */    public function getHtml($exception)    {        if (!$exception instanceof FlattenException) {            $exception = FlattenException::create($exception);        }        return $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the HTML content associated with the given exception.     *     * @return string The content as a string     */    public function getContent(FlattenException $exception)    {        switch ($exception->getStatusCode()) {            case 404:                $title = 'Sorry, the page you are looking for could not be found.';                break;            default:                $title = $this->debug ? $this->escapeHtml($exception->getMessage()) : 'Whoops, looks like something went wrong.';        }        if (!$this->debug) {            return <<<EOF                <div class=""container"">                    <h1>$title</h1>                </div>EOF;        }        $content = '';        try {            $count = \count($exception->getAllPrevious());            $total = $count + 1;            foreach ($exception->toArray() as $position => $e) {                $ind = $count - $position + 1;                $class = $this->formatClass($e['class']);                $message = nl2br($this->escapeHtml($e['message']));                $content .= sprintf(<<<'EOF'                    <div class=""trace trace-as-html"">                        <table class=""trace-details"">                            <thead class=""trace-head""><tr><th>                                <h3 class=""trace-class"">                                    <span class=""text-muted"">(%d/%d)</span>                                    <span class=""exception_title"">%s</span>                                </h3>                                <p class=""break-long-words trace-message"">%s</p>                            </th></tr></thead>                            <tbody>EOF                    , $ind, $total, $class, $message);                foreach ($e['trace'] as $trace) {                    $content .= '<tr><td>';                    if ($trace['function']) {                        $content .= sprintf('at <span class=""trace-class"">%s</span><span class=""trace-type"">%s</span><span class=""trace-method"">%s</span>', $this->formatClass($trace['class']), $trace['type'], $trace['function']);                        if (isset($trace['args'])) {                            $content .= sprintf('(<span class=""trace-arguments"">%s</span>)', $this->formatArgs($trace['args']));                        }                    }                    if (isset($trace['file']) && isset($trace['line'])) {                        $content .= $this->formatPath($trace['file'], $trace['line']);                    }                    $content .= ""</td></tr>\n"";                }                $content .= ""</tbody>\n</table>\n</div>\n"";            }        } catch (\Exception $e) {            // something nasty happened and we cannot throw an exception anymore            if ($this->debug) {                $e = FlattenException::create($e);                $title = sprintf('Exception thrown when handling an exception (%s: %s)', $e->getClass(), $this->escapeHtml($e->getMessage()));            } else {                $title = 'Whoops, looks like something went wrong.';            }        }        $symfonyGhostImageContents = $this->getSymfonyGhostAsSvg();        return <<<EOF            <div class=""exception-summary"">                <div class=""container"">                    <div class=""exception-message-wrapper"">                        <h1 class=""break-long-words exception-message"">$title</h1>                        <div class=""exception-illustration hidden-xs-down"">$symfonyGhostImageContents</div>                    </div>                </div>            </div>            <div class=""container"">                $content            </div>EOF;    }    /**     * Gets the stylesheet associated with the given exception.     *     * @return string The stylesheet as a string     */    public function getStylesheet(FlattenException $exception)    {        if (!$this->debug) {            return <<<'EOF'                body { background-color: #fff; color: #222; font: 16px/1.5 -apple-system, BlinkMacSystemFont, ""Segoe UI"", Roboto, ""Helvetica Neue"", Arial, sans-serif; margin: 0; }                .container { margin: 30px; max-width: 600px; }                h1 { color: #dc3545; font-size: 24px; }EOF;        }        return <<<'EOF'            body { background-color: #F9F9F9; color: #222; font: 14px/1.4 Helvetica, Arial, sans-serif; margin: 0; padding-bottom: 45px; }            a { cursor: pointer; text-decoration: none; }            a:hover { text-decoration: underline; }            abbr[title] { border-bottom: none; cursor: help; text-decoration: none; }            code, pre { font: 13px/1.5 Consolas, Monaco, Menlo, ""Ubuntu Mono"", ""Liberation Mono"", monospace; }            table, tr, th, td { background: #FFF; border-collapse: collapse; vertical-align: top; }            table { background: #FFF; border: 1px solid #E0E0E0; box-shadow: 0px 0px 1px rgba(128, 128, 128, .2); margin: 1em 0; width: 100%; }            table th, table td { border: solid #E0E0E0; border-width: 1px 0; padding: 8px 10px; }            table th { background-color: #E0E0E0; font-weight: bold; text-align: left; }            .hidden-xs-down { display: none; }            .block { display: block; }            .break-long-words { -ms-word-break: break-all; word-break: break-all; word-break: break-word; -webkit-hyphens: auto; -moz-hyphens: auto; hyphens: auto; }            .text-muted { color: #999; }            .container { max-width: 1024px; margin: 0 auto; padding: 0 15px; }            .container::after { content: """"; display: table; clear: both; }            .exception-summary { background: #B0413E; border-bottom: 2px solid rgba(0, 0, 0, 0.1); border-top: 1px solid rgba(0, 0, 0, .3); flex: 0 0 auto; margin-bottom: 30px; }            .exception-message-wrapper { display: flex; align-items: center; min-height: 70px; }            .exception-message { flex-grow: 1; padding: 30px 0; }            .exception-message, .exception-message a { color: #FFF; font-size: 21px; font-weight: 400; margin: 0; }            .exception-message.long { font-size: 18px; }            .exception-message a { border-bottom: 1px solid rgba(255, 255, 255, 0.5); font-size: inherit; text-decoration: none; }            .exception-message a:hover { border-bottom-color: #ffffff; }            .exception-illustration { flex-basis: 111px; flex-shrink: 0; height: 66px; margin-left: 15px; opacity: .7; }            .trace + .trace { margin-top: 30px; }            .trace-head .trace-class { color: #222; font-size: 18px; font-weight: bold; line-height: 1.3; margin: 0; position: relative; }            .trace-message { font-size: 14px; font-weight: normal; margin: .5em 0 0; }            .trace-file-path, .trace-file-path a { color: #222; margin-top: 3px; font-size: 13px; }            .trace-class { color: #B0413E; }            .trace-type { padding: 0 2px; }            .trace-method { color: #B0413E; font-weight: bold; }            .trace-arguments { color: #777; font-weight: normal; padding-left: 2px; }            @media (min-width: 575px) {                .hidden-xs-down { display: initial; }            }EOF;    }    private function decorate(string $content, string $css): string    {        return <<<EOF<!DOCTYPE html><html>    <head>        <meta charset=""{$this->charset}"" />        <meta name=""robots"" content=""noindex,nofollow"" />        <style>$css</style>    </head>    <body>        $content    </body></html>EOF;    }    private function formatClass(string $class): string    {        $parts = explode('\\', $class);        return sprintf('<abbr title=""%s"">%s</abbr>', $class, array_pop($parts));    }    private function formatPath(string $path, int $line): string    {        $file = $this->escapeHtml(preg_match('#[^/\\\\]*+$#', $path, $file) ? $file[0] : $path);        $fmt = $this->fileLinkFormat ?: ini_get('xdebug.file_link_format') ?: get_cfg_var('xdebug.file_link_format');        if (!$fmt) {            return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');        }        if (\is_string($fmt)) {            $i = strpos($f = $fmt, '&', max(strrpos($f, '%f'), strrpos($f, '%l'))) ?: \strlen($f);            $fmt = [substr($f, 0, $i)] + preg_split('/&([^>]++)>/', substr($f, $i), -1, \PREG_SPLIT_DELIM_CAPTURE);            for ($i = 1; isset($fmt[$i]); ++$i) {                if (0 === strpos($path, $k = $fmt[$i++])) {                    $path = substr_replace($path, $fmt[$i], 0, \strlen($k));                    break;                }            }            $link = strtr($fmt[0], ['%f' => $path, '%l' => $line]);        } else {            try {                $link = $fmt->format($path, $line);            } catch (\Exception $e) {                return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');            }        }        return sprintf('<span class=""block trace-file-path"">in <a href=""%s"" title=""Go to source""><strong>%s</string>%s</a></span>', $this->escapeHtml($link), $file, 0 < $line ? ' line '.$line : '');    }    /**     * Formats an array as a string.     */    private function formatArgs(array $args): string    {        $result = [];        foreach ($args as $key => $item) {            if ('object' === $item[0]) {                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));            } elseif ('array' === $item[0]) {                $formattedValue = sprintf('<em>array</em>(%s)', \is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);            } elseif ('null' === $item[0]) {                $formattedValue = '<em>null</em>';            } elseif ('boolean' === $item[0]) {                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';            } elseif ('resource' === $item[0]) {                $formattedValue = '<em>resource</em>';            } else {                $formattedValue = str_replace(""\n"", '', $this->escapeHtml(var_export($item[1], true)));            }            $result[] = \is_int($key) ? $formattedValue : sprintf(""'%s' => %s"", $this->escapeHtml($key), $formattedValue);        }        return implode(', ', $result);    }    /**     * HTML-encodes a string.     */    private function escapeHtml(string $str): string    {        return htmlspecialchars($str, \ENT_COMPAT | \ENT_SUBSTITUTE, $this->charset);    }    private function getSymfonyGhostAsSvg(): string    {        return '<svg viewBox=""0 0 136 81"" xmlns=""http://www.w3.org/2000/svg"" fill-rule=""evenodd"" clip-rule=""evenodd"" stroke-linejoin=""round"" stroke-miterlimit=""1.4""><path d=""M92.4 20.4a23.2 23.2 0 0 1 9 1.9 23.7 23.7 0 0 1 5.2 3 24.3 24.3 0 0 1 3.4 3.4 24.8 24.8 0 0 1 5 9.4c.5 1.7.8 3.4 1 5.2v14.5h.4l.5.2a7.4 7.4 0 0 0 2.5.2l.2-.2.6-.8.8-1.3-.2-.1a5.5 5.5 0 0 1-.8-.3 5.6 5.6 0 0 1-2.3-1.8 5.7 5.7 0 0 1-.9-1.6 6.5 6.5 0 0 1-.2-2.8 7.3 7.3 0 0 1 .5-2l.3-.3.8-.9.3-.3c.2-.2.5-.3.8-.3H120.7c.2 0 .3-.1.4 0h.4l.2.1.3.2.2-.4.3-.4.1-.1 1.2-1 .3-.2.4-.1.4-.1h.3l1.5.1.4.1.8.5.1.2 1 1.1v.2H129.4l.4-.2 1.4-.5h1.1c.3 0 .7.2 1 .4.2 0 .3.2.5.3l.2.2.5.3.4.6.1.3.4 1.4.1.4v.6a7.8 7.8 0 0 1-.1.6 9.9 9.9 0 0 1-.8 2.4 7.8 7.8 0 0 1-3 3.3 6.4 6.4 0 0 1-1 .5 6.1 6.1 0 0 1-.6.2l-.7.1h-.1a23.4 23.4 0 0 1-.2 1.7 14.3 14.3 0 0 1-.6 2.1l-.8 2a9.2 9.2 0 0 1-.4.6l-.7 1a9.1 9.1 0 0 1-2.3 2.2c-.9.5-2 .6-3 .7l-1.4.1h-.5l-.4.1a15.8 15.8 0 0 1-2.8-.1v4.2a9.7 9.7 0 0 1-.7 3.5 9.6 9.6 0 0 1-1.7 2.8 9.3 9.3 0 0 1-3 2.3 9 9 0 0 1-5.4.7 9 9 0 0 1-3-1 9.4 9.4 0 0 1-2.7-2.5 10 10 0 0 1-1 1.2 9.3 9.3 0 0 1-2 1.3 9 9 0 0 1-2.4 1 9 9 0 0 1-6.5-1.1A9.4 9.4 0 0 1 85 77V77a10.9 10.9 0 0 1-.6.6 9.3 9.3 0 0 1-2.7 2 9 9 0 0 1-6 .8 9 9 0 0 1-2.4-1 9.3 9.3 0 0 1-2.3-1.7 9.6 9.6 0 0 1-1.8-2.8 9.7 9.7 0 0 1-.8-3.7v-4a18.5 18.5 0 0 1-2.9.2l-1.2-.1c-1.9-.3-3.7-1-5.1-2.1A8.2 8.2 0 0 1 58 64a10.2 10.2 0 0 1-.9-1.2 15.3 15.3 0 0 1-.7-1.3 20.8 20.8 0 0 1-1.9-6.2v-.2a6.5 6.5 0 0 1-1-.3 6.1 6.1 0 0 1-.6-.3 6.6 6.6 0 0 1-.9-.5 8.2 8.2 0 0 1-2.7-3.8 10 10 0 0 1-.3-1 10.3 10.3 0 0 1-.3-1.9V47v-.4l.1-.4.6-1.4.1-.2a2 2 0 0 1 .8-.8l.3-.2.3-.2a3.2 3.2 0 0 1 1.8-.5h.4l.3.2 1.4.6.2.2.4.3.3.4.7-.7.2-.2.4-.2.6-.2h2.1l.4.2.4.2.3.2.8 1 .2-.1h.1v-.1H63l1.1.1h.3l.8.5.3.4.7 1 .2.3.1.5a11 11 0 0 1 .2 1.5c0 .8 0 1.6-.3 2.3a6 6 0 0 1-.5 1.2 5.5 5.5 0 0 1-3.3 2.5 12.3 12.3 0 0 0 1.4 3h.1l.2.1 1 .2h1.5l.5-.2H67.8l.5-.2h.1V44v-.4a26.7 26.7 0 0 1 .3-2.3 24.7 24.7 0 0 1 5.7-12.5 24.2 24.2 0 0 1 3.5-3.3 23.7 23.7 0 0 1 4.9-3 23.2 23.2 0 0 1 5.6-1.7 23.7 23.7 0 0 1 4-.3zm-.3 2a21.2 21.2 0 0 0-8 1.7 21.6 21.6 0 0 0-4.8 2.7 22.2 22.2 0 0 0-3.2 3 22.7 22.7 0 0 0-5 9.2 23.4 23.4 0 0 0-.7 4.9v15.7l-.5.1a34.3 34.3 0 0 1-1.5.3h-.2l-.4.1h-.4l-.9.2a10 10 0 0 1-1.9 0c-.5 0-1-.2-1.5-.4a1.8 1.8 0 0 1-.3-.2 2 2 0 0 1-.3-.3 5.2 5.2 0 0 1-.1-.2 9 9 0 0 1-.6-.9 13.8 13.8 0 0 1-1-2 14.3 14.3 0 0 1-.6-2 14 14 0 0 1-.1-.8v-.2h.3a12.8 12.8 0 0 0 1.4-.2 4.4 4.4 0 0 0 .3 0 3.6 3.6 0 0 0 1.1-.7 3.4 3.4 0 0 0 1.2-1.7l.2-1.2a5.1 5.1 0 0 0 0-.8 7.2 7.2 0 0 0-.1-.8l-.7-1-1.2-.2-1 .7-.1 1.3a5 5 0 0 1 .1.4v.6a1 1 0 0 1 0 .3c-.1.3-.4.4-.7.5l-1.2.4v-.7A9.9 9.9 0 0 1 60 49l.3-.6v-.2l.1-.1v-1.6l-1-1.2h-1.5l-1 1.1v.4a5.3 5.3 0 0 0-.2.6 5.5 5.5 0 0 0 0 .5c0 .7 0 1.4.3 2 0 .4.2.8.4 1.2L57 51a9.5 9.5 0 0 1-1.1-.5h-.2a2 2 0 0 1-.4-.3c-.4-.4-.5-1-.6-1.6a5.6 5.6 0 0 1 0-.5v-.5-.5l-.6-1.5-1.4-.6-.9.3s-.2 0-.3.2a2 2 0 0 1-.1 0l-.6 1.4v.7a8.5 8.5 0 0 0 .5 2c.4 1.1 1 2.1 2 2.8a4.7 4.7 0 0 0 2.1.9h1a22.8 22.8 0 0 0 .1 1 18.1 18.1 0 0 0 .8 3.8 18.2 18.2 0 0 0 1.6 3.7l1 1.3c1 1 2.3 1.6 3.7 2a11.7 11.7 0 0 0 4.8 0h.4l.5-.2.5-.1.6-.2v6.6a8 8 0 0 0 .1 1.3 7.5 7.5 0 0 0 2.4 4.3 7.2 7.2 0 0 0 2.3 1.3 7 7 0 0 0 7-1.1 7.5 7.5 0 0 0 2-2.6A7.7 7.7 0 0 0 85 72V71a8.2 8.2 0 0 0 .2 1.3c0 .7.3 1.4.6 2a7.5 7.5 0 0 0 1.7 2.3 7.3 7.3 0 0 0 2.2 1.4 7.1 7.1 0 0 0 4.6.2 7.2 7.2 0 0 0 2.4-1.2 7.5 7.5 0 0 0 2.1-2.7 7.8 7.8 0 0 0 .7-2.4V71a9.3 9.3 0 0 0 .1.6 7.6 7.6 0 0 0 .6 2.5 7.5 7.5 0 0 0 2.4 3 7.1 7.1 0 0 0 7 .8 7.3 7.3 0 0 0 2.3-1.5 7.5 7.5 0 0 0 1.6-2.3 7.6 7.6 0 0 0 .5-2l.1-1.1v-6.7l.4.1a12.2 12.2 0 0 0 2 .5 11.1 11.1 0 0 0 2.5 0h.8l1.2-.1a9.5 9.5 0 0 0 1.4-.2l.9-.3a3.5 3.5 0 0 0 .6-.4l1.2-1.4a12.2 12.2 0 0 0 .8-1.2c0-.3.2-.5.3-.7a15.9 15.9 0 0 0 .7-2l.3-1.6v-1.3l.2-.9V54.6a15.5 15.5 0 0 0 1.8 0 4.5 4.5 0 0 0 1.4-.5 5.7 5.7 0 0 0 2.5-3.2 7.6 7.6 0 0 0 .4-1.5v-.3l-.4-1.4a5.2 5.2 0 0 1-.2-.1l-.4-.4a3.8 3.8 0 0 0-.2 0 1.4 1.4 0 0 0-.5-.2l-1.4.4-.7 1.3v.7a5.7 5.7 0 0 1-.1.8l-.7 1.4a1.9 1.9 0 0 1-.5.3h-.3a9.6 9.6 0 0 1-.8.3 8.8 8.8 0 0 1-.6 0l.2-.4.2-.5.2-.3v-.4l.1-.2V50l.1-1 .1-.6v-.6a4.8 4.8 0 0 0 0-.8v-.2l-1-1.1-1.5-.2-1.1 1-.2 1.4v.1l.2.4.2.3v.4l.1 1.1v.3l.1.5v.8a9.6 9.6 0 0 1-.8-.3l-.2-.1h-.3l-.8-.1h-.2a1.6 1.6 0 0 1-.2-.2.9.9 0 0 1-.2-.2 1 1 0 0 1-.1-.5l.2-.9v-1.2l-.9-.8h-1.2l-.8.9v.3a4.8 4.8 0 0 0-.3 2l.3.9a3.5 3.5 0 0 0 1.2 1.6l1 .5.8.2 1.4.1h.4l.2.1a12.1 12.1 0 0 1-1 2.6 13.2 13.2 0 0 1-.8 1.5 9.5 9.5 0 0 1-1 1.2l-.2.3a1.7 1.7 0 0 1-.4.3 2.4 2.4 0 0 1-.7.2h-2.5a7.8 7.8 0 0 1-.6-.2l-.7-.2h-.2a14.8 14.8 0 0 1-.6-.2 23.4 23.4 0 0 1-.4-.1l-.4-.1-.3-.1V43.9a34.6 34.6 0 0 0 0-.6 23.6 23.6 0 0 0-.4-3 22.7 22.7 0 0 0-1.5-4.7 22.6 22.6 0 0 0-4.6-6.7 21.9 21.9 0 0 0-6.9-4.7 21.2 21.2 0 0 0-8.1-1.8H92zm9.1 33.7l.3.1a1 1 0 0 1 .6.8v.4a8.4 8.4 0 0 1 0 .5 8.8 8.8 0 0 1-1.6 4.2l-1 1.3A10 10 0 0 1 95 66c-1.3.3-2.7.4-4 .3a10.4 10.4 0 0 1-2.7-.8 10 10 0 0 1-3.6-2.5 9.3 9.3 0 0 1-.8-1 9 9 0 0 1-.7-1.2 8.6 8.6 0 0 1-.8-3.4V57a1 1 0 0 1 .3-.6 1 1 0 0 1 1.3-.2 1 1 0 0 1 .4.8v.4a6.5 6.5 0 0 0 .5 2.2 7 7 0 0 0 2.1 2.8l1 .6c2.6 1.6 6 1.6 8.5 0a8 8 0 0 0 1.1-.6 7.6 7.6 0 0 0 1.2-1.2 7 7 0 0 0 1-1.7 6.5 6.5 0 0 0 .4-2.5 1 1 0 0 1 .7-1h.4zM30.7 43.7c-15.5 1-28.5-6-30.1-16.4C-1.2 15.7 11.6 4 29 1.3 46.6-1.7 62.3 5.5 64 17.1c1.6 10.4-8.7 21-23.7 25a31.2 31.2 0 0 0 0 .9v.3a19 19 0 0 0 .1 1l.1.4.1.9a4.7 4.7 0 0 0 .5 1l.7 1a9.2 9.2 0 0 0 1.2 1l1.5.8.6.8-.7.6-1.1.3a11.2 11.2 0 0 1-2.6.4 8.6 8.6 0 0 1-3-.5 8.5 8.5 0 0 1-1-.4 11.2 11.2 0 0 1-1.8-1.2 13.3 13.3 0 0 1-1-1 18 18 0 0 1-.7-.6l-.4-.4a23.4 23.4 0 0 1-1.3-1.8l-.1-.1-.3-.5V45l-.3-.6v-.7zM83.1 36c3.6 0 6.5 3.2 6.5 7.1 0 4-3 7.2-6.5 7.2S76.7 47 76.7 43 79.6 36 83 36zm18 0c3.6 0 6.5 3.2 6.5 7.1 0 4-2.9 7.2-6.4 7.2S94.7 47 94.7 43s3-7.1 6.5-7.1zm-18 6.1c2 0 3.5 1.6 3.5 3.6S85 49.2 83 49.2s-3.4-1.6-3.4-3.6S81.2 42 83 42zm17.9 0c1.9 0 3.4 1.6 3.4 3.6s-1.5 3.6-3.4 3.6c-2 0-3.5-1.6-3.5-3.6S99.1 42 101 42zM17 28c-.3 1.6-1.8 5-5.2 5.8-2.5.6-4.1-.8-4.5-2.6-.4-1.9.7-3.5 2.1-4.5A3.5 3.5 0 0 1 8 24.6c-.4-2 .8-3.7 3.2-4.2 1.9-.5 3.1.2 3.4 1.5.3 1.1-.5 2.2-1.8 2.5-.9.3-1.6 0-1.7-.6a1.4 1.4 0 0 1 0-.7s.3.2 1 0c.7-.1 1-.7.9-1.2-.2-.6-1-.8-1.8-.6-1 .2-2 1-1.7 2.6.3 1 .9 1.6 1.5 1.8l.7-.2c1-.2 1.5 0 1.6.5 0 .4-.2 1-1.2 1.2a3.3 3.3 0 0 1-1.5 0c-.9.7-1.6 1.9-1.3 3.2.3 1.3 1.3 2.2 3 1.8 2.5-.7 3.8-3.7 4.2-5-.3-.5-.6-1-.7-1.6-.1-.5.1-1 .9-1.2.4 0 .7.2.8.8a2.8 2.8 0 0 1 0 1l.7 1c.6-2 1.4-4 1.7-4 .6-.2 1.5.6 1.5.6-.8.7-1.7 2.4-2.3 4.2.8.6 1.6 1 2.1 1 .5-.1.8-.6 1-1.2-.3-2.2 1-4.3 2.3-4.6.7-.2 1.3.2 1.4.8.1.5 0 1.3-.9 1.7-.2-1-.6-1.3-1-1.3-.4.1-.7 1.4-.4 2.8.2 1 .7 1.5 1.3 1.4.8-.2 1.3-1.2 1.7-2.1-.3-2.1.9-4.2 2.2-4.5.7-.2 1.2.1 1.4 1 .4 1.4-1 2.8-2.2 3.4.3.7.7 1 1.3.9 1-.3 1.6-1.5 2-2.5l-.5-3v-.3s1.6-.3 1.8.6v.1c.2-.6.7-1.2 1.3-1.4.8-.1 1.5.6 1.7 1.6.5 2.2-.5 4.4-1.8 4.7H33a31.9 31.9 0 0 0 1 5.2c-.4.1-1.8.4-2-.4l-.5-5.6c-.5 1-1.3 2.2-2.5 2.4-1 .3-1.6-.3-2-1.1-.5 1-1.3 2.1-2.4 2.4-.8.2-1.5-.1-2-1-.3.8-.9 1.5-1.5 1.7-.7.1-1.5-.3-2.4-1-.3.8-.4 1.6-.4 2.2 0 0-.7 0-.8-.4-.1-.5 0-1.5.3-2.7a10.3 10.3 0 0 1-.7-.8zm38.2-17.8l.2.9c.5 1.9.4 4.4.8 6.4 0 .6-.4 3-1.4 3.3-.2 0-.3 0-.4-.4-.1-.7 0-1.6-.3-2.6-.2-1.1-.8-1.6-1.5-1.5-.8.2-1.3 1-1.6 2l-.1-.5c-.2-1-1.8-.6-1.8-.6a6.2 6.2 0 0 1 .4 1.3l.2 1c-.2.5-.6 1-1.2 1l-.2.1a7 7 0 0 0-.1-.8c-.3-1.1-1-2-1.6-1.8a.7.7 0 0 0-.4.3c-1.3.3-2.4 2-2.1 3.9-.2.9-.6 1.7-1 1.9-.5 0-.8-.5-1.1-1.8l-.1-1.2a4 4 0 0 0 0-1.7c0-.4-.4-.7-.8-.6-.7.2-.9 1.7-.5 3.8-.2 1-.6 2-1.3 2-.4.2-.8-.2-1-1l-.2-3c1.2-.5 2-1 1.8-1.7-.1-.5-.8-.7-.8-.7s0 .7-1 1.2l-.2-1.4c-.1-.6-.4-1-1.7-.6l.4 1 .2 1.5h-1v.8c0 .3.4.3 1 .2 0 1.3 0 2.7.2 3.6.3 1.4 1.2 2 2 1.7 1-.2 1.6-1.3 2-2.3.3 1.2 1 2 1.9 1.7.7-.2 1.2-1.1 1.6-2.2.4.8 1.1 1.1 2 1 1.2-.4 1.7-1.6 1.8-2.8h.2c.6-.2 1-.6 1.3-1 0 .8 0 1.5.2 2.1.1.5.3.7.6.6.5-.1 1-.9 1-.9a4 4 0 0 1-.3-1c-.3-1.3.3-3.6 1-3.7.2 0 .3.2.5.7v.8l.2 1.5v.7c.2.7.7 1.3 1.5 1 1.3-.2 2-2.6 2.1-3.9.3.2.6.2 1 .1-.6-2.2 0-6.1-.3-7.9-.1-.4-1-.5-1.7-.5h-.4zm-21.5 12c.4 0 .7.3 1 1.1.2 1.3-.3 2.6-.9 2.8-.2 0-.7 0-1-1.2v-.4c0-1.3.4-2 1-2.2zm-5.2 1c.3 0 .6.2.6.5.2.6-.3 1.3-1.2 2-.3-1.4.1-2.3.6-2.5zm18-.4c-.5.2-1-.4-1.2-1.2-.2-1 0-2.1.7-2.5v.5c.2.7.6 1.5 1.3 1.9 0 .7-.2 1.2-.7 1.3zm10-1.6c0 .5.4.7 1 .6.8-.2 1-1 .8-1.6 0-.5-.4-1-1-.8-.5.1-1 .9-.8 1.8zm-14.3-5.5c0-.4-.5-.7-1-.5-.8.2-1 1-.9 1.5.2.6.5 1 1 .8.5 0 1.1-1 1-1.8z"" fill=""#fff"" fill-opacity="".6""/>'.$this->addElementToGhost().'</svg>';    }    private function addElementToGhost(): string    {        if (!isset(self::GHOST_ADDONS[date('m-d')])) {            return '';        }        return '<path d=""'.self::GHOST_ADDONS[date('m-d')].'"" fill=""#fff"" fill-opacity=""0.6""></path>';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidFactory_1998," Returns an RFC 4122 variant Uuid, created from the provided bytes and version\\n\\n @param string $bytes The byte string to convert to a UUID\\n @param int $version The RFC 4122 version to apply to the UUID\\n\\n @return UuidInterface An instance of UuidInterface, created from the\\n     byte string and version\\n\\n @psalm-pure\\n","Vraća RFC 4122 Uuid varijantu, kreiranu od obezbeđenih bajtova i verzije","    private function uuidFromBytesAndVersion(string $bytes, int $version): UuidInterface    {        /** @var array $unpackedTime */        $unpackedTime = unpack('n*', substr($bytes, 6, 2));        $timeHi = (int) $unpackedTime[1];        $timeHiAndVersion = pack('n*', BinaryUtils::applyVersion($timeHi, $version));        /** @var array $unpackedClockSeq */        $unpackedClockSeq = unpack('n*', substr($bytes, 8, 2));        $clockSeqHi = (int) $unpackedClockSeq[1];        $clockSeqHiAndReserved = pack('n*', BinaryUtils::applyVariant($clockSeqHi));        $bytes = substr_replace($bytes, $timeHiAndVersion, 6, 2);        $bytes = substr_replace($bytes, $clockSeqHiAndReserved, 8, 2);        if ($this->isDefaultFeatureSet) {            return LazyUuidFromString::fromBytes($bytes);        }        return $this->uuid($bytes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_exporter_Exporter_1035, Exports a value into a single-line string.\n\n The output of this method is similar to the output of\n SebastianBergmann\\Exporter\\Exporter::export().\n\n Newlines are replaced by the visible string '\\n'.\n Contents of arrays and objects (if any) are replaced by '...'.\n,Eksportuje vrednost u jednoredni niz. Izlaz ove metode sličan je izlazu SebastianBergmann\\Exporter\\Exporter::export(). Novi redovi se zamenjuju vidljivim stringom '\\ n'. Sadržaj nizova i objekata (ako ih ima) zamenjuje se sa '...',"    public function shortenedExport(mixed $value): string    {        if (is_string($value)) {            $string = str_replace(""\n"", '', $this->export($value));            if (function_exists('mb_strlen') && function_exists('mb_substr') && mb_strlen($string) > 40) {                return mb_substr($string, 0, 30) . '...' . mb_substr($string, -7);            }            if (strlen($string) > 40) {                return substr($string, 0, 30) . '...' . substr($string, -7);            }            return $string;        }        if (is_object($value)) {            return sprintf(                '%s Object (%s)',                get_class($value),                count($this->toArray($value)) > 0 ? '...' : ''            );        }        if (is_array($value)) {            return sprintf(                'Array (%s)',                count($value) > 0 ? '...' : ''            );        }        return $this->export($value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Verify_671, Wrapper around Google Access Tokens which provides convenience functions\\\\\\\\n\\\\\\\\n,Omotač oko Google Access Tokena koji pruža pogodnosti,"class Verify{  const FEDERATED_SIGNON_CERT_URL = 'https://www.googleapis.com/oauth2/v3/certs';  const OAUTH2_ISSUER = 'accounts.google.com';  const OAUTH2_ISSUER_HTTPS = 'https://accounts.google.com';  /**   * @var ClientInterface The http client   */  private $http;  /**   * @var CacheItemPoolInterface cache class   */  private $cache;  /**   * Instantiates the class, but does not initiate the login flow, leaving it   * to the discretion of the caller.   */  public function __construct(      ClientInterface $http = null,      CacheItemPoolInterface $cache = null,      $jwt = null  ) {    if (null === $http) {      $http = new Client();    }    if (null === $cache) {      $cache = new MemoryCacheItemPool;    }    $this->http = $http;    $this->cache = $cache;    $this->jwt = $jwt ?: $this->getJwtService();  }  /**   * Verifies an id token and returns the authenticated apiLoginTicket.   * Throws an exception if the id token is not valid.   * The audience parameter can be used to control which id tokens are   * accepted.  By default, the id token must have been issued to this OAuth2 client.   *   * @param string $idToken the ID token in JWT format   * @param string $audience Optional. The audience to verify against JWt ""aud""   * @return array the token payload, if successful   */  public function verifyIdToken($idToken, $audience = null)  {    if (empty($idToken)) {      throw new LogicException('id_token cannot be null');    }    // set phpseclib constants if applicable    $this->setPhpsecConstants();    // Check signature    $certs = $this->getFederatedSignOnCerts();    foreach ($certs as $cert) {      try {        $payload = $this->jwt->decode(            $idToken,            $this->getPublicKey($cert),            array('RS256')        );        if (property_exists($payload, 'aud')) {          if ($audience && $payload->aud != $audience) {            return false;          }        }        // support HTTP and HTTPS issuers        // @see https://developers.google.com/identity/sign-in/web/backend-auth        $issuers = array(self::OAUTH2_ISSUER, self::OAUTH2_ISSUER_HTTPS);        if (!isset($payload->iss) || !in_array($payload->iss, $issuers)) {          return false;        }        return (array) $payload;      } catch (ExpiredException $e) {        return false;      } catch (ExpiredExceptionV3 $e) {        return false;      } catch (SignatureInvalidException $e) {        // continue      } catch (DomainException $e) {        // continue      }    }    return false;  }  private function getCache()  {    return $this->cache;  }  /**   * Retrieve and cache a certificates file.   *   * @param $url string location   * @throws \Google\Exception   * @return array certificates   */  private function retrieveCertsFromLocation($url)  {    // If we're retrieving a local file, just grab it.    if (0 !== strpos($url, 'http')) {      if (!$file = file_get_contents($url)) {        throw new GoogleException(            ""Failed to retrieve verification certificates: '"" .            $url . ""'.""        );      }      return json_decode($file, true);    }    $response = $this->http->get($url);    if ($response->getStatusCode() == 200) {      return json_decode((string) $response->getBody(), true);    }    throw new GoogleException(        sprintf(            'Failed to retrieve verification certificates: ""%s"".',            $response->getBody()->getContents()        ),        $response->getStatusCode()    );  }  // Gets federated sign-on certificates to use for verifying identity tokens.  // Returns certs as array structure, where keys are key ids, and values  // are PEM encoded certificates.  private function getFederatedSignOnCerts()  {    $certs = null;    if ($cache = $this->getCache()) {      $cacheItem = $cache->getItem('federated_signon_certs_v3');      $certs = $cacheItem->get();    }    if (!$certs) {      $certs = $this->retrieveCertsFromLocation(          self::FEDERATED_SIGNON_CERT_URL      );      if ($cache) {        $cacheItem->expiresAt(new DateTime('+1 hour'));        $cacheItem->set($certs);        $cache->save($cacheItem);      }    }    if (!isset($certs['keys'])) {      throw new InvalidArgumentException(          'federated sign-on certs expects ""keys"" to be set'      );    }    return $certs['keys'];  }  private function getJwtService()  {    $jwtClass = 'JWT';    if (class_exists('\Firebase\JWT\JWT')) {      $jwtClass = 'Firebase\JWT\JWT';    }    if (property_exists($jwtClass, 'leeway') && $jwtClass::$leeway < 1) {      // Ensures JWT leeway is at least 1      // @see https://github.com/google/google-api-php-client/issues/827      $jwtClass::$leeway = 1;    }    return new $jwtClass;  }  private function getPublicKey($cert)  {    $bigIntClass = $this->getBigIntClass();    $modulus = new $bigIntClass($this->jwt->urlsafeB64Decode($cert['n']), 256);    $exponent = new $bigIntClass($this->jwt->urlsafeB64Decode($cert['e']), 256);    $component = array('n' => $modulus, 'e' => $exponent);    if (class_exists('phpseclib3\Crypt\RSA\PublicKey')) {      /** @var PublicKey $loader */      $loader = PublicKeyLoader::load($component);      return $loader->toString('PKCS8');    }    $rsaClass = $this->getRsaClass();    $rsa = new $rsaClass();    $rsa->loadKey($component);    return $rsa->getPublicKey();  }  private function getRsaClass()  {    if (class_exists('phpseclib3\Crypt\RSA')) {      return 'phpseclib3\Crypt\RSA';    }    if (class_exists('phpseclib\Crypt\RSA')) {      return 'phpseclib\Crypt\RSA';    }    return 'Crypt_RSA';  }  private function getBigIntClass()  {    if (class_exists('phpseclib3\Math\BigInteger')) {      return 'phpseclib3\Math\BigInteger';    }    if (class_exists('phpseclib\Math\BigInteger')) {      return 'phpseclib\Math\BigInteger';    }    return 'Math_BigInteger';  }  private function getOpenSslConstant()  {    if (class_exists('phpseclib3\Crypt\AES')) {      return 'phpseclib3\Crypt\AES::ENGINE_OPENSSL';    }    if (class_exists('phpseclib\Crypt\RSA')) {      return 'phpseclib\Crypt\RSA::MODE_OPENSSL';    }    if (class_exists('Crypt_RSA')) {      return 'CRYPT_RSA_MODE_OPENSSL';    }    throw new Exception('Cannot find RSA class');  }  /**   * phpseclib calls ""phpinfo"" by default, which requires special   * whitelisting in the AppEngine VM environment. This function   * sets constants to bypass the need for phpseclib to check phpinfo   *   * @see phpseclib/Math/BigInteger   * @see https://github.com/GoogleCloudPlatform/getting-started-php/issues/85   */  private function setPhpsecConstants()  {    if (filter_var(getenv('GAE_VM'), FILTER_VALIDATE_BOOLEAN)) {      if (!defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {        define('MATH_BIGINTEGER_OPENSSL_ENABLED', true);      }      if (!defined('CRYPT_RSA_MODE')) {        define('CRYPT_RSA_MODE', constant($this->getOpenSslConstant()));      }    }  }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_96, Create a new PHPExcel with one Worksheet\\\\n,Napravite novi PHPExcel sa jednim radnim listom,    public function __construct()    {        $this->uniqueID = uniqid();        $this->calculationEngine = new PHPExcel_Calculation($this);        // Initialise worksheet collection and add one worksheet        $this->workSheetCollection = array();        $this->workSheetCollection[] = new PHPExcel_Worksheet($this);        $this->activeSheetIndex = 0;        // Create document properties        $this->properties = new PHPExcel_DocumentProperties();        // Create document security        $this->security = new PHPExcel_DocumentSecurity();        // Set named ranges        $this->namedRanges = array();        // Create the cellXf supervisor        $this->cellXfSupervisor = new PHPExcel_Style(true);        $this->cellXfSupervisor->bindParent($this);        // Create the default style        $this->addCellXf(new PHPExcel_Style);        $this->addCellStyleXf(new PHPExcel_Style);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LogNormal_3141, Log normal distribution - probability density function\\n\\n https://en.wikipedia.org/wiki/Log-normal_distribution\\n\\n                 (ln x - Î¼)Â²\\n         1     - ----------\\n pdf = ----- â„¯       2ÏƒÂ²\\n       xÏƒâˆš2Ï€\\n\\n @param  float $x > 0\\n\\n @return float\\n,Log Normalna raspodela - funkcija gustine verovatnoće,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        $Ï€ = \M_PI;        $xÏƒâˆš2Ï€      = $x * $Ïƒ * \sqrt(2 * $Ï€);        $âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² = \pow(\log($x) - $Î¼, 2);        $ÏƒÂ²         = $Ïƒ ** 2;        return (1 / $xÏƒâˆš2Ï€) * \exp(-($âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² / (2 * $ÏƒÂ²)));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1235," Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.\n Precalculation is, actually, the optimization being performed.\n",Kopira phalcon.c i optimizirajte ga tako što će zamijeniti određene stringove sa preračunanim heš vrijednostima. Preračunavanje je zapravo optimizacija koja se izvodi,"    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_8666, Set unix user and group for current process.\n\n @return void\n,Podesite unix korisnika i grupu za trenutni proces,"    protected static function monitorWorkersForWindows()    {        Timer::add(1, ""\\Workerman\\Worker::checkWorkerStatusForWindows"");        static::$globalEvent->loop();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ResponseCommand_558, Builds HTTP response from given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,,"    public function execute($image)    {        $format = $this->argument(0)->value();        $quality = $this->argument(1)->between(0, 100)->value();        $response = new Response($image, $format, $quality);        $this->setOutput($response->make());        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_DebugClassLoader_1727," Autoloader checking if the class is really defined in the file found.\n\n The ClassLoader will wrap all registered autoloaders\n and will throw an exception if a file is found but does\n not declare the class.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Christophe Coevoet <stof@notk.org>\n @author Nicolas Grekas <p@tchwork.com>\n @author Guilhem Niot <guilhem.niot@gmail.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\DebugClassLoader instead.\n","Automatsko učitavanje proverava da li je klasa zaista definisana u pronađenoj datoteci. ClassLoader će umotati sve registrovane automatske učitavače i izbaciće izuzetak ako je datoteka pronađena, ali ne deklariše klasu","class DebugClassLoader{    private $classLoader;    private $isFinder;    private $loaded = [];    private static $caseCheck;    private static $checkedClasses = [];    private static $final = [];    private static $finalMethods = [];    private static $deprecated = [];    private static $internal = [];    private static $internalMethods = [];    private static $annotatedParameters = [];    private static $darwinCache = ['/' => ['/', []]];    private static $method = [];    public function __construct(callable $classLoader)    {        $this->classLoader = $classLoader;        $this->isFinder = \is_array($classLoader) && method_exists($classLoader[0], 'findFile');        if (!isset(self::$caseCheck)) {            $file = file_exists(__FILE__) ? __FILE__ : rtrim(realpath('.'), \DIRECTORY_SEPARATOR);            $i = strrpos($file, \DIRECTORY_SEPARATOR);            $dir = substr($file, 0, 1 + $i);            $file = substr($file, 1 + $i);            $test = strtoupper($file) === $file ? strtolower($file) : strtoupper($file);            $test = realpath($dir.$test);            if (false === $test || false === $i) {                // filesystem is case sensitive                self::$caseCheck = 0;            } elseif (substr($test, -\strlen($file)) === $file) {                // filesystem is case insensitive and realpath() normalizes the case of characters                self::$caseCheck = 1;            } elseif (false !== stripos(\PHP_OS, 'darwin')) {                // on MacOSX, HFS+ is case insensitive but realpath() doesn't normalize the case of characters                self::$caseCheck = 2;            } else {                // filesystem case checks failed, fallback to disabling them                self::$caseCheck = 0;            }        }    }    /**     * Gets the wrapped class loader.     *     * @return callable The wrapped class loader     */    public function getClassLoader()    {        return $this->classLoader;    }    /**     * Wraps all autoloaders.     */    public static function enable()    {        // Ensures we don't hit https://bugs.php.net/42098        class_exists(\Symfony\Component\Debug\ErrorHandler::class);        class_exists(\Psr\Log\LogLevel::class);        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (!\is_array($function) || !$function[0] instanceof self) {                $function = [new static($function), 'loadClass'];            }            spl_autoload_register($function);        }    }    /**     * Disables the wrapping.     */    public static function disable()    {        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (\is_array($function) && $function[0] instanceof self) {                $function = $function[0]->getClassLoader();            }            spl_autoload_register($function);        }    }    /**     * @return string|null     */    public function findFile($class)    {        return $this->isFinder ? $this->classLoader[0]->findFile($class) ?: null : null;    }    /**     * Loads the given class or interface.     *     * @param string $class The name of the class     *     * @throws \RuntimeException     */    public function loadClass($class)    {        $e = error_reporting(error_reporting() | \E_PARSE | \E_ERROR | \E_CORE_ERROR | \E_COMPILE_ERROR);        try {            if ($this->isFinder && !isset($this->loaded[$class])) {                $this->loaded[$class] = true;                if (!$file = $this->classLoader[0]->findFile($class) ?: false) {                    // no-op                } elseif (\function_exists('opcache_is_script_cached') && @opcache_is_script_cached($file)) {                    include $file;                    return;                } elseif (false === include $file) {                    return;                }            } else {                ($this->classLoader)($class);                $file = false;            }        } finally {            error_reporting($e);        }        $this->checkClass($class, $file);    }    private function checkClass(string $class, string $file = null)    {        $exists = null === $file || class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);        if (null !== $file && $class && '\\' === $class[0]) {            $class = substr($class, 1);        }        if ($exists) {            if (isset(self::$checkedClasses[$class])) {                return;            }            self::$checkedClasses[$class] = true;            $refl = new \ReflectionClass($class);            if (null === $file && $refl->isInternal()) {                return;            }            $name = $refl->getName();            if ($name !== $class && 0 === strcasecmp($name, $class)) {                throw new \RuntimeException(sprintf('Case mismatch between loaded and declared class names: ""%s"" vs ""%s"".', $class, $name));            }            $deprecations = $this->checkAnnotations($refl, $name);            foreach ($deprecations as $message) {                @trigger_error($message, \E_USER_DEPRECATED);            }        }        if (!$file) {            return;        }        if (!$exists) {            if (false !== strpos($class, '/')) {                throw new \RuntimeException(sprintf('Trying to autoload a class with an invalid name ""%s"". Be careful that the namespace separator is ""\"" in PHP, not ""/"".', $class));            }            throw new \RuntimeException(sprintf('The autoloader expected class ""%s"" to be defined in file ""%s"". The file was found but the class was not in it, the class name or namespace probably has a typo.', $class, $file));        }        if (self::$caseCheck && $message = $this->checkCase($refl, $file, $class)) {            throw new \RuntimeException(sprintf('Case mismatch between class and real file names: ""%s"" vs ""%s"" in ""%s"".', $message[0], $message[1], $message[2]));        }    }    public function checkAnnotations(\ReflectionClass $refl, $class)    {        $deprecations = [];        // Don't trigger deprecations for classes in the same vendor        if (2 > $len = 1 + (strpos($class, '\\') ?: strpos($class, '_'))) {            $len = 0;            $ns = '';        } else {            $ns = str_replace('_', '\\', substr($class, 0, $len));        }        // Detect annotations on the class        if (false !== $doc = $refl->getDocComment()) {            foreach (['final', 'deprecated', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    self::${$annotation}[$class] = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                }            }            if ($refl->isInterface() && false !== strpos($doc, 'method') && preg_match_all('#\n \* @method\s+(static\s+)?+(?:[\w\|&\[\]\\\]+\s+)?(\w+(?:\s*\([^\)]*\))?)+(.+?([[:punct:]]\s*)?)?(?=\r?\n \*(?: @|/$|\r?\n))#', $doc, $notice, \PREG_SET_ORDER)) {                foreach ($notice as $method) {                    $static = '' !== $method[1];                    $name = $method[2];                    $description = $method[3] ?? null;                    if (false === strpos($name, '(')) {                        $name .= '()';                    }                    if (null !== $description) {                        $description = trim($description);                        if (!isset($method[4])) {                            $description .= '.';                        }                    }                    self::$method[$class][] = [$class, $name, $static, $description];                }            }        }        $parent = get_parent_class($class);        $parentAndOwnInterfaces = $this->getOwnInterfaces($class, $parent ?: null);        if ($parent) {            $parentAndOwnInterfaces[$parent] = $parent;            if (!isset(self::$checkedClasses[$parent])) {                $this->checkClass($parent);            }            if (isset(self::$final[$parent])) {                $deprecations[] = sprintf('The ""%s"" class is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $parent, self::$final[$parent], $class);            }        }        // Detect if the parent is annotated        foreach ($parentAndOwnInterfaces + class_uses($class, false) as $use) {            if (!isset(self::$checkedClasses[$use])) {                $this->checkClass($use);            }            if (isset(self::$deprecated[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len) && !isset(self::$deprecated[$class])) {                $type = class_exists($class, false) ? 'class' : (interface_exists($class, false) ? 'interface' : 'trait');                $verb = class_exists($use, false) || interface_exists($class, false) ? 'extends' : (interface_exists($use, false) ? 'implements' : 'uses');                $deprecations[] = sprintf('The ""%s"" %s %s ""%s"" that is deprecated%s.', $class, $type, $verb, $use, self::$deprecated[$use]);            }            if (isset(self::$internal[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len)) {                $deprecations[] = sprintf('The ""%s"" %s is considered internal%s. It may change without further notice. You should not use it from ""%s"".', $use, class_exists($use, false) ? 'class' : (interface_exists($use, false) ? 'interface' : 'trait'), self::$internal[$use], $class);            }            if (isset(self::$method[$use])) {                if ($refl->isAbstract()) {                    if (isset(self::$method[$class])) {                        self::$method[$class] = array_merge(self::$method[$class], self::$method[$use]);                    } else {                        self::$method[$class] = self::$method[$use];                    }                } elseif (!$refl->isInterface()) {                    $hasCall = $refl->hasMethod('__call');                    $hasStaticCall = $refl->hasMethod('__callStatic');                    foreach (self::$method[$use] as $method) {                        [$interface, $name, $static, $description] = $method;                        if ($static ? $hasStaticCall : $hasCall) {                            continue;                        }                        $realName = substr($name, 0, strpos($name, '('));                        if (!$refl->hasMethod($realName) || !($methodRefl = $refl->getMethod($realName))->isPublic() || ($static && !$methodRefl->isStatic()) || (!$static && $methodRefl->isStatic())) {                            $deprecations[] = sprintf('Class ""%s"" should implement method ""%s::%s""%s', $class, ($static ? 'static ' : '').$interface, $name, null == $description ? '.' : ': '.$description);                        }                    }                }            }        }        if (trait_exists($class)) {            return $deprecations;        }        // Inherit @final, @internal and @param annotations for methods        self::$finalMethods[$class] = [];        self::$internalMethods[$class] = [];        self::$annotatedParameters[$class] = [];        foreach ($parentAndOwnInterfaces as $use) {            foreach (['finalMethods', 'internalMethods', 'annotatedParameters'] as $property) {                if (isset(self::${$property}[$use])) {                    self::${$property}[$class] = self::${$property}[$class] ? self::${$property}[$use] + self::${$property}[$class] : self::${$property}[$use];                }            }        }        foreach ($refl->getMethods(\ReflectionMethod::IS_PUBLIC | \ReflectionMethod::IS_PROTECTED) as $method) {            if ($method->class !== $class) {                continue;            }            if ($parent && isset(self::$finalMethods[$parent][$method->name])) {                [$declaringClass, $message] = self::$finalMethods[$parent][$method->name];                $deprecations[] = sprintf('The ""%s::%s()"" method is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);            }            if (isset(self::$internalMethods[$class][$method->name])) {                [$declaringClass, $message] = self::$internalMethods[$class][$method->name];                if (strncmp($ns, $declaringClass, $len)) {                    $deprecations[] = sprintf('The ""%s::%s()"" method is considered internal%s. It may change without further notice. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);                }            }            // To read method annotations            $doc = $method->getDocComment();            if (isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }                foreach (self::$annotatedParameters[$class][$method->name] as $parameterName => $deprecation) {                    if (!isset($definedParameters[$parameterName]) && !($doc && preg_match(""/\\n\\s+\\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\\\${$parameterName}\\b/"", $doc))) {                        $deprecations[] = sprintf($deprecation, $class);                    }                }            }            if (!$doc) {                continue;            }            $finalOrInternal = false;            foreach (['final', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    $message = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                    self::${$annotation.'Methods'}[$class][$method->name] = [$class, $message];                    $finalOrInternal = true;                }            }            if ($finalOrInternal || $method->isConstructor() || false === strpos($doc, '@param') || StatelessInvocation::class === $class) {                continue;            }            if (!preg_match_all('#\n\s+\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\$([a-zA-Z0-9_\x7f-\xff]++)#', $doc, $matches, \PREG_SET_ORDER)) {                continue;            }            if (!isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }            }            foreach ($matches as [, $parameterType, $parameterName]) {                if (!isset($definedParameters[$parameterName])) {                    $parameterType = trim($parameterType);                    self::$annotatedParameters[$class][$method->name][$parameterName] = sprintf('The ""%%s::%s()"" method will require a new ""%s$%s"" argument in the next major version of its %s ""%s"", not defining it is deprecated.', $method->name, $parameterType ? $parameterType.' ' : '', $parameterName, interface_exists($class) ? 'interface' : 'parent class', $method->class);                }            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Safe_1568, Resolves headers in the php_phalcon.h file\\n,Rešava zaglavlja u datoteci php_phalcon.h,"    protected function processKernelGlobals()    {        $lines = [];        foreach (file($this->outputDir . '/php_phalcon.h') as $line) {            if (preg_match('@^#include ""(kernel/.+)""@', $line, $matches)) {                $content = file_get_contents($this->sourceDir . DIRECTORY_SEPARATOR . $matches[1]);                $lines[] = $content . PHP_EOL;            } else {                $lines[] = $line;            }        }        file_put_contents($this->outputDir . '/php_phalcon.h', join('', $lines));    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
