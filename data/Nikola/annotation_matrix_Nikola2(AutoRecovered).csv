pair_id,comment,Komentar,code,"upit
","pretvaranje int u string
","red sa prioritetom
","pretvaranje string u datum
","sortiranje string liste
","Äuvanje liste u datoteku
","postgresql konekcija
","konfuziona matrica
","postavljanje radnog direktorijuma
","grupisanje po izbrojanim podacima
","binomna raspodela
","aes Å¡ifrovanje
","linearna regresija
","vreme tolerisanja za prijem na soketu
","upisivanje u csv datoteku
","pretvaranje decimalnog u heksadecimalni broj
","izvoz podataka u excel
","dijagram rasejanja
","pretvaranje json u csv
","lepo ispiÅ¡i json
","zamena delova datoteke
","klasterizacija metodom k-srednjih vrednosti
","povezivanje na sql server
","html Å¡ifrovan string
","odreÄ‘ivanje proteklog vremena koriÅ¡Ä‡enjem Äasovnika
","parsiranje binarne datoteke u prilagoÄ‘enu klasu
","dohvatanje trenutne ip adrese
","pretvaranje int u bool
","isÄitavanje tekstualne datoteke liniju po liniju
","dohvatanje putanje izvrÅ¡avanja
","odprema json datoteke pomoÄ‡u HttpClient POST zahteva
","dohvatanje unutraÅ¡njeg svojstva html taga
","pretvaranje string u broj
","formatiranje datuma
","nepromenjivi (readonly) niz
","filtriranje niza
","mapa u json
","parsiranje json datoteke
","dohvati trenutnu vrednost posmatraÄa
","dohvati naziv za vrednost enumerisanog tipa podatka
","Å¡ifriraj url
","kreiraj kolaÄiÄ‡
","kako isprazniti niz
","kako dohvatiti danaÅ¡nji datum
","kako Å¡tiklirati checkbox
","inicijalizacija niza
","kako obrnuti string
","proÄitaj svojstva datoteke
","prekopiraj u klibord
","pretvaranje html stranice u pdf
","konverzija json u xml datoteku
","kako nasumiÄno izabrati broj
","normalna raspodela
","Nelder-Mead optimizacija
","hashset za odreÄ‘ivanje broja razliÄitih elemenata
","kako dohvatiti naziv tabele iz baze
","deserializacija json-a
","pronaÄ‘i int unutar stringa
","dohvatanje jedinstvenog identifikatora trenutnog procesa
","regex ne razlikuje velika i mala slova
","prilagoÄ‘eni http odgovor greÅ¡ke
","kako odrediti da li je string valida reÄ
","zamena http entiteta
","sakrij atribute datoteke
","sortiraj viÅ¡e nizova na osnovu redosleda drugih sortiranih nizova
","levenshteinova slicnost stringova
","kako dohvatiti html kod sa veb sajta
","baferisano Äitanje teksta ÄitaÄem fajlova
","aes Å¡ifrovanje u ctr naÄinu rada
","matrica mnoÅ¾enja
","Å¡tampanje rezimea modela
","jedinstveni elementi
","izvlaÄenje podataka iz sadrÅ¾aja html koda
","toplotna mapa iz 3d koordinata
","dohvatanje svih roditelja xml Ävora
","kako rekurzivno raspakovati zip datoteku
","podvuci tekst u label vidÅ¾etu
","raspakivanje velikih datoteka
","kopiranje putanje fajla
","dohvati opis http statusnog koda
","nasumiÄno izvuci x stavki iz liste
","konvertuj string datum u yyyymmdd format
","pretvoriti utc vreme u epohu
","sve permutacije liste
","izvuci geografsku Å¡irinu i duÅ¾inu iz datog unosa
","kako proveriti da je checkbox Å¡tikliran
","pretvoriti uint8 niz u sliku
","memoizacija na disk - persistentna memoizacija
","parsiranje argumenata komandne linije
","kako proÄitati sadrÅ¾aj iz .gz zapakovanog fajla
","slanje binarnih podataka preko seriske veze
","otpakovanje podataka iz tekstualne datoteke
","pozicije podstingova u stringu
","Äitanje elemenata iz html-a - <td>
","oduzimanje medijana iz svake kolone
","uklanjanja zaglavlja prilikom spajanja nekoliko datoteka
","parsiranje query stringa u url-u
","rangiranje fazi Älanova na osnovu stepena podudaranja
","izlaz u html datoteku
",kako efikasno proÄitati .csv datoteku
cakephp_cakephp_BaseAuthenticate_1177, Get query object for fetching user from database.\\\\n\\\\n @param string $username The username/identifier.\\\\n @return \\\\\\\\Cake\\\\\\\\ORM\\\\\\\\Query\\\\n,Dohvatanje objekta iz upita radi preuzimanja podataka o korisniku iz baze podataka,"    protected function _query(string $username): Query    {        $config = $this->_config;        $table = $this->getTableLocator()->get($config['userModel']);        $options = [            'conditions' => [$table->aliasField($config['fields']['username']) => $username],        ];        $finder = $config['finder'];        if (is_array($finder)) {            $options += current($finder);            $finder = key($finder);        }        if (!isset($options['username'])) {            $options['username'] = $username;        }        return $table->find($finder, $options);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Alias_810, Get all found aliases from DB with search query.\\n\\n @return string Comma separated aliases\\n,Dohvatanje svih pronađenih pseudonima iz baze podataka pomoću upita za pretragu,"    public function getAliases()    {        if (!Alias::isFeatureActive()) {            return '';        }        $aliases = Db::getInstance()->executeS('SELECT a.aliasFROM `' . _DB_PREFIX_ . 'alias` aWHERE `search` = \'' . pSQL($this->search) . '\'');        $aliases = array_map('implode', $aliases);        return implode(', ', $aliases);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2416, Retrieves all annotations for a user.\n\n @param int $userId\n\n @return QueryBuilder\n,Dohvata sve napomene za korisnika,"    public function findAnnotationsByPageId($entryId, $userId)    {        return $this->createQueryBuilder('a')            ->where('a.entry = :entryId')->setParameter('entryId', $entryId)            ->andwhere('a.user = :userId')->setParameter('userId', $userId)            ->getQuery()            ->getResult()        ;    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_7937, Generates a normalized URI (URL) for the Request.\n\n @return string A normalized URI (URL) for the Request\n\n @see getQueryString()\n,Generiše normalizovani URI (URL) za zahtev,    public function getUri()    {        if (null !== $qs = $this->getQueryString()) {            $qs = '?'.$qs;        }        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;    },2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_786, Returns Address ID for a given Supplier ID.\\n\\n @since 1.5.0\\n\\n @param int $id_supplier Supplier ID\\n\\n @return int $id_address Address ID\\n,Vraća ID adrese za dati ID dobavljača,    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    },3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_787, Check if the alias already exists.\\\\n\\\\n @param string $alias Alias of an address\\\\n @param int $id_address Address id\\\\n @param int $id_customer Customer id\\\\n\\\\n @return false|string|null Amount of aliases found\\\\n @todo: Find out if we shouldn't be returning an int instead? (breaking change)\\\\n,Proverava da li pseudonim već postoji,"    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Alias_812, This method is allow to know if a alias exist for AdminImportController.\\\\\\\\n\\\\\\\\n @param int $idAlias Alias ID\\\\\\\\n\\\\\\\\n @return bool\\\\\\\\n\\\\\\\\n @since 1.5.6.0\\\\\\\\n,Ovaj metod dozvoljava da se zna postoji li pseudonim za AdminImportController,"    public static function aliasExists($idAlias)    {        $sql = new DbQuery();        $sql->select('a.`id_alias`');        $sql->from('alias', 'a');        $sql->where('a.`id_alias` = ' . (int) $idAlias);        $row = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow($sql, false);        return isset($row['id_alias']);    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1205," This attempts to find media, other files, and download them\n\n @param string $path\n @return PageInterface|false\n","Ovo pokušava da pronađe medije, druge datoteke i preuzme ih","    public function fallbackUrl($path)    {        $this->fireEvent('onPageFallBackUrl');        /** @var Uri $uri */        $uri = $this['uri'];        /** @var Config $config */        $config = $this['config'];        $uri_extension = strtolower($uri->extension());        $fallback_types = $config->get('system.media.allowed_fallback_types', null);        $supported_types = $config->get('media.types');        // Check whitelist first, then ensure extension is a valid media type        if (!empty($fallback_types) && !in_array($uri_extension, $fallback_types, true)) {            return false;        }        if (!array_key_exists($uri_extension, $supported_types)) {            return false;        }        $path_parts = pathinfo($path);        /** @var Pages $pages */        $pages = $this['pages'];        $page = $pages->find($path_parts['dirname'], true);        if ($page) {            $media = $page->media()->all();            $parsed_url = parse_url(rawurldecode($uri->basename()));            $media_file = $parsed_url['path'];            // if this is a media object, try actions first            if (isset($media[$media_file])) {                /** @var Medium $medium */                $medium = $media[$media_file];                foreach ($uri->query(null, true) as $action => $params) {                    if (in_array($action, ImageMedium::$magic_actions, true)) {                        call_user_func_array([&$medium, $action], explode(',', $params));                    }                }                Utils::download($medium->path(), false);            }            // unsupported media type, try to download it...            if ($uri_extension) {                $extension = $uri_extension;            } else {                if (isset($path_parts['extension'])) {                    $extension = $path_parts['extension'];                } else {                    $extension = null;                }            }            if ($extension) {                $download = true;                if (in_array(ltrim($extension, '.'), $config->get('system.media.unsupported_inline_types', []), true)) {                    $download = false;                }                Utils::download($page->path() . DIRECTORY_SEPARATOR . $uri->basename(), $download);            }            // Nothing found            return false;        }        return $page;    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Client_9, Applies the array of request options to a request.\\n,Primenjuje niz zahteva za opcije na zahtev,"    private function applyOptions(RequestInterface $request, array &$options): RequestInterface    {        $modify = [            'set_headers' => [],        ];        if (isset($options['headers'])) {            $modify['set_headers'] = $options['headers'];            unset($options['headers']);        }        if (isset($options['form_params'])) {            if (isset($options['multipart'])) {                throw new InvalidArgumentException('You cannot use '                    . 'form_params and multipart at the same time. Use the '                    . 'form_params option if you want to send application/'                    . 'x-www-form-urlencoded requests, and the multipart '                    . 'option to send multipart/form-data requests.');            }            $options['body'] = \http_build_query($options['form_params'], '', '&');            unset($options['form_params']);            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'application/x-www-form-urlencoded';        }        if (isset($options['multipart'])) {            $options['body'] = new Psr7\MultipartStream($options['multipart']);            unset($options['multipart']);        }        if (isset($options['json'])) {            $options['body'] = Utils::jsonEncode($options['json']);            unset($options['json']);            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'application/json';        }        if (!empty($options['decode_content'])            && $options['decode_content'] !== true        ) {            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Accept-Encoding'], $options['_conditional']);            $modify['set_headers']['Accept-Encoding'] = $options['decode_content'];        }        if (isset($options['body'])) {            if (\is_array($options['body'])) {                throw $this->invalidBody();            }            $modify['body'] = Psr7\Utils::streamFor($options['body']);            unset($options['body']);        }        if (!empty($options['auth']) && \is_array($options['auth'])) {            $value = $options['auth'];            $type = isset($value[2]) ? \strtolower($value[2]) : 'basic';            switch ($type) {                case 'basic':                    // Ensure that we don't have the header in different case and set the new value.                    $modify['set_headers'] = Psr7\Utils::caselessRemove(['Authorization'], $modify['set_headers']);                    $modify['set_headers']['Authorization'] = 'Basic '                        . \base64_encode(""$value[0]:$value[1]"");                    break;                case 'digest':                    // @todo: Do not rely on curl                    $options['curl'][\CURLOPT_HTTPAUTH] = \CURLAUTH_DIGEST;                    $options['curl'][\CURLOPT_USERPWD] = ""$value[0]:$value[1]"";                    break;                case 'ntlm':                    $options['curl'][\CURLOPT_HTTPAUTH] = \CURLAUTH_NTLM;                    $options['curl'][\CURLOPT_USERPWD] = ""$value[0]:$value[1]"";                    break;            }        }        if (isset($options['query'])) {            $value = $options['query'];            if (\is_array($value)) {                $value = \http_build_query($value, '', '&', \PHP_QUERY_RFC3986);            }            if (!\is_string($value)) {                throw new InvalidArgumentException('query must be a string or array');            }            $modify['query'] = $value;            unset($options['query']);        }        // Ensure that sink is not an invalid value.        if (isset($options['sink'])) {            // TODO: Add more sink validation?            if (\is_bool($options['sink'])) {                throw new InvalidArgumentException('sink must not be a boolean');            }        }        $request = Psr7\Utils::modifyRequest($request, $modify);        if ($request->getBody() instanceof Psr7\MultipartStream) {            // Use a multipart/form-data POST if a Content-Type is not set.            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'multipart/form-data; boundary='                . $request->getBody()->getBoundary();        }        // Merge in conditional headers if they are not present.        if (isset($options['_conditional'])) {            // Build up the changes so it's in a single clone of the message.            $modify = [];            foreach ($options['_conditional'] as $k => $v) {                if (!$request->hasHeader($k)) {                    $modify['set_headers'][$k] = $v;                }            }            $request = Psr7\Utils::modifyRequest($request, $modify);            // Don't pass this internal value along to middleware/handlers.            unset($options['_conditional']);        }        return $request;    }",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_InvalidVisits_265, Adds one site and sends several invalid tracking requests. The result should be\\n one website with no visits.\\n,Dodaje jedan vebsajt i šalje nekoliko neva\ećih zahteva za praćenje. Rezultat bi trebalo da bude jedan vebsajt bez poseta,"class InvalidVisits extends Fixture{    public $idSite = 1;    public $dateTime = '2009-01-04 00:11:42';    public $trackInvalidRequests = true;    public function setUp(): void    {        $this->setUpWebsitesAndGoals();        $this->trackVisits();    }    public function tearDown(): void    {        // empty    }    private function setUpWebsitesAndGoals()    {        if (!self::siteCreated($idSite = 1)) {            self::createWebsite($this->dateTime);        }    }    private function trackVisits()    {        if (!$this->trackInvalidRequests) {            return;        }        $dateTime = $this->dateTime;        $idSite = $this->idSite;        API::getInstance()->setGlobalExcludedUserAgents('globalexcludeduseragent');        Cache::regenerateCacheWebsiteAttributes([1]);        // Trigger empty request        $trackerUrl = self::getTrackerUrl();        $response = Http::fetchRemoteFile($trackerUrl);        self::assertTrue(strpos($response, 'Keep full control of your data with the leading free') !== false, 'Piwik empty request response not correct: ' . $response);        $t = self::getTracker($idSite, $dateTime, $defaultInit = true);        // test GoogleBot UA visitor        $t->setUserAgent('Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)');        self::checkResponse($t->doTrackPageView('bot visit, please do not record'));        // Test IP Exclusion works with or without IP exclusion        foreach (array(false, true) as $enable) {            $excludedIp = '154.1.12.34';            API::getInstance()->updateSite($idSite, 'new site name', $url = array('http://site.com'), $ecommerce = 0, $ss = 1, $ss_kwd = '', $ss_cat = '', $excludedIp . ',1.2.3.4', $excludedQueryParameters = null, $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = 'excludeduseragentstring');            Cache::regenerateCacheWebsiteAttributes([1]);            // Enable IP Anonymization            $t->DEBUG_APPEND_URL = '&forceIpAnonymization=' . (int)$enable;            // test with excluded User Agent            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729) (excludeduseragentstring)');            $t->setIp('211.1.2.3');            self::checkResponse($t->doTrackPageView('visit from excluded User Agent'));            $t->setUserAgent('Mozilla/5.0 (Windows NT 6.1; rv:6.0) Gecko/20110814 Firefox/6.0 Google (+https://developers.google.com/+/web/snippet/)');            self::checkResponse($t->doTrackPageView('visit from excluded User Agent'));            // test w/ global excluded User Agent            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729) (globalexcludeduseragent)');            $t->setIp('211.1.2.3');            self::checkResponse($t->doTrackPageView('visit from global excluded User Agent'));            // test with excluded IP            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729)'); // restore normal user agent            $t->setIp($excludedIp);            self::checkResponse($t->doTrackPageView('visit from IP excluded'));            // test with global list of excluded IPs            $excludedIpBis = '145.5.3.4';            API::getInstance()->setGlobalExcludedIps($excludedIpBis);            Cache::regenerateCacheWebsiteAttributes([1]);            $t->setIp($excludedIpBis);            self::checkResponse($t->doTrackPageView('visit from IP globally excluded'));        }        // test unknown url exclusion works        $urls = array(""http://piwik.net"", ""http://my.stuff.com/"");        API::getInstance()->updateSite($idSite, $siteName = null, $urls, $ecommerce = null, $siteSearch = null,            $searchKeywordParameters = null, $searchCategoryParameters = null, $excludedIps = null, $excludedQueryParams = null,            $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = null,            $keepUrlFragments = null, $type = null, $settings = null, $excludeUnknownUrls = 1);        Cache::regenerateCacheWebsiteAttributes([1]);        $t->setIp(""125.4.5.6"");        $t->setUrl(""http://piwik.com/to/the/moon"");        $t->doTrackPageView(""ignored, not from piwik.net"");        $t->setUrl(""http://their.stuff.com/back/to/the/future"");        $t->doTrackPageView(""ignored, not from my.stuff.com"");        // undo exclude unknown urls change (important when multiple fixtures are setup together, as is done in OmniFixture)        API::getInstance()->updateSite($idSite, $siteName = null, $urls, $ecommerce = null, $siteSearch = null,            $searchKeywordParameters = null, $searchCategoryParameters = null, $excludedIps = null, $excludedQueryParams = null,            $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = null,            $keepUrlFragments = null, $type = null, $settings = null, $excludeUnknownUrls = 0);        Cache::regenerateCacheWebsiteAttributes([1]);        try {            @$t->setAttributionInfo(array());            self::fail();        } catch (Exception $e) {        }        try {            $t->setAttributionInfo(json_encode('test'));            self::fail();        } catch (Exception $e) {        }        $t->setAttributionInfo(json_encode(array()));    }}",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_RowEvolution_242," This class generates a Row evolution dataset, from input request\\n\\n",Ova klasa generiše niz podataka o evoluciji redova na osnovu unetog zahteva,"class RowEvolution{    private static $actionsUrlReports = array(        'getPageUrls',        'getPageUrlsFollowingSiteSearch',        'getEntryPageUrls',        'getExitPageUrls',        'getPageUrl'    );    public function getRowEvolution($idSite, $period, $date, $apiModule, $apiAction, $label = false, $segment = false, $column = false, $language = false, $apiParameters = array(), $legendAppendMetric = true, $labelUseAbsoluteUrl = true, $labelSeries = '')    {        // validation of requested $period & $date        if ($period == 'range') {            // load days in the range            $period = 'day';        }        if (!Period::isMultiplePeriod($date, $period)) {            throw new Exception(""Row evolutions can not be processed with this combination of \'date\' and \'period\' parameters."");        }        $label = DataTablePostProcessor::unsanitizeLabelParameter($label);        $labels = Piwik::getArrayFromApiParameter($label, $onlyUnique = empty($labelSeries));        $metadata = $this->getRowEvolutionMetaData($idSite, $period, $date, $apiModule, $apiAction, $language, $apiParameters);        $dataTable = $this->loadRowEvolutionDataFromAPI($metadata, $idSite, $period, $date, $apiModule, $apiAction, $labels, $segment, $apiParameters);        if (empty($dataTable->getDataTables())) {            return array();        }        if (empty($labels)) {            $labels = $this->getLabelsFromDataTable($dataTable, $labels);            $dataTable = $this->enrichRowAddMetadataLabelIndex($labels, $dataTable);        }        if (count($labels) != 1) {            $data = $this->getMultiRowEvolution(                $dataTable,                $metadata,                $apiModule,                $apiAction,                $labels,                $column,                $legendAppendMetric,                $labelUseAbsoluteUrl,                $labelSeries            );        } else {            $data = $this->getSingleRowEvolution(                $idSite,                $dataTable,                $metadata,                $apiModule,                $apiAction,                $labels[0],                $labelUseAbsoluteUrl            );        }        return $data;    }    /**     * @param array $labels     * @param DataTable\Map $dataTable     * @return mixed     */    protected function enrichRowAddMetadataLabelIndex($labels, $dataTable)    {        // set label index metadata        $labelsToIndex = array_flip($labels);        foreach ($dataTable->getDataTables() as $table) {            foreach ($table->getRows() as $row) {                $label = $row->getColumn('label');                if (isset($labelsToIndex[$label])) {                    $row->setMetadata(LabelFilter::FLAG_IS_ROW_EVOLUTION, $labelsToIndex[$label]);                }            }        }        return $dataTable;    }    /**     * @param DataTable\Map $dataTable     * @param array $labels     * @return array     */    protected function getLabelsFromDataTable($dataTable, $labels)    {        // if no labels specified, use all possible labels as list        foreach ($dataTable->getDataTables() as $table) {            $labels = array_merge($labels, $table->getColumn('label'));        }        $labels = array_values(array_unique($labels));        // if the filter_limit query param is set, treat it as a request to limit        // the number of labels used        $limit = Common::getRequestVar('filter_limit', false);        if ($limit != false            && $limit >= 0        ) {            $labels = array_slice($labels, 0, $limit);        }        return $labels;    }    /**     * Get row evolution for a single label     * @param DataTable\Map $dataTable     * @param array $metadata     * @param string $apiModule     * @param string $apiAction     * @param string $label     * @param bool $labelUseAbsoluteUrl     * @return array containing  report data, metadata, label, logo     */    private function getSingleRowEvolution($idSite, $dataTable, $metadata, $apiModule, $apiAction, $label, $labelUseAbsoluteUrl = true)    {        $metricNames = array_keys($metadata['metrics']);        $logo = $actualLabel = false;        $urlFound = false;        foreach ($dataTable->getDataTables() as $subTable) {            /** @var $subTable DataTable */            $subTable->applyQueuedFilters();            if ($subTable->getRowsCount() > 0) {                /** @var $row Row */                $row = $subTable->getFirstRow();                if (!$actualLabel) {                    $logo = $row->getMetadata('logo');                    $actualLabel = $this->getRowUrlForEvolutionLabel($row, $apiModule, $apiAction, $labelUseAbsoluteUrl);                    $urlFound = $actualLabel !== false;                    if (empty($actualLabel)) {                        $actualLabel = $row->getColumn('label');                    }                }                // remove all columns that are not in the available metrics.                // this removes the label as well (which is desired for two reasons: (1) it was passed                // in the request, (2) it would cause the evolution graph to show the label in the legend).                foreach ($row->getColumns() as $column => $value) {                    if (!in_array($column, $metricNames) && $column != 'label_html') {                        $row->deleteColumn($column);                    }                }                $row->deleteMetadata();            }        }        $this->enhanceRowEvolutionMetaData($metadata, $dataTable);        // if we have a recursive label and no url, use the path        if (!$urlFound) {            $actualLabel = $this->formatQueryLabelForDisplay($idSite, $apiModule, $apiAction, $label);        }        $return = array(            'label'      => SafeDecodeLabel::decodeLabelSafe($actualLabel),            'reportData' => $dataTable,            'metadata'   => $metadata        );        if (!empty($logo)) {            $return['logo'] = $logo;        }        return $return;    }    private function formatQueryLabelForDisplay($idSite, $apiModule, $apiAction, $label)    {        // rows with subtables do not contain URL metadata. this hack makes sure the label titles in row        // evolution popovers look like URLs.        if ($apiModule == 'Actions'            && in_array($apiAction, self::$actionsUrlReports)        ) {            $mainUrl = Site::getMainUrlFor($idSite);            $mainUrlHost = @parse_url($mainUrl, PHP_URL_HOST);            $replaceRegex = ""/\\s*"" . preg_quote(LabelFilter::SEPARATOR_RECURSIVE_LABEL) . ""\\s*/"";            $cleanLabel = preg_replace($replaceRegex, '/', $label);            $result = $mainUrlHost . '/' . $cleanLabel . '/';        } else {            $result = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        }        // remove @ terminal operator occurrences        return str_replace(LabelFilter::TERMINAL_OPERATOR, '', $result);    }    /**     * @param Row $row     * @param string $apiModule     * @param string $apiAction     * @param bool $labelUseAbsoluteUrl     * @return bool|string     */    private function getRowUrlForEvolutionLabel($row, $apiModule, $apiAction, $labelUseAbsoluteUrl)    {        $url = $row->getMetadata('url');        if ($url            && ($apiModule == 'Actions'                || ($apiModule == 'Referrers'                    && $apiAction == 'getWebsites'))            && $labelUseAbsoluteUrl        ) {            $actualLabel = preg_replace(';^http(s)?://(www.)?;i', '', $url);            return $actualLabel;        }        return false;    }    /**     * @param array $metadata see getRowEvolutionMetaData()     * @param int $idSite     * @param string $period     * @param string $date     * @param string $apiModule     * @param string $apiAction     * @param string|bool $label     * @param string|bool $segment     * @param array $apiParameters     * @throws Exception     * @return DataTable\Map|DataTable     */    private function loadRowEvolutionDataFromAPI($metadata, $idSite, $period, $date, $apiModule, $apiAction, $label, $segment, $apiParameters)    {        if (!is_array($label)) {            $label = array($label);        }        $label = array_map('rawurlencode', $label);        $parameters = array(            'method'                   => $apiModule . '.' . $apiAction,            'label'                    => $label,            'idSite'                   => $idSite,            'period'                   => $period,            'date'                     => $date,            'format'                   => 'original',            'serialize'                => '0',            'segment'                  => $segment,            // data for row evolution should NOT be limited            'filter_limit'             => -1,            // if more than one label is used, we add metadata to ensure we know which            // row corresponds with which label (since the labels can change, and rows            // can be sorted in a different order)            'labelFilterAddLabelIndex' => count($label) > 1 ? 1 : 0,        );        if (!empty($apiParameters) && is_array($apiParameters)) {            foreach ($apiParameters as $param => $value) {                $parameters[$param] = $value;            }        }        // add ""processed metrics"" like actions per visit or bounce rate        // note: some reports should not be filtered with AddColumnProcessedMetrics        // specifically, reports without the Metrics::INDEX_NB_VISITS metric such as Goals.getVisitsUntilConversion & Goal.getDaysToConversion        // this is because the AddColumnProcessedMetrics filter removes all datable rows lacking this metric        if (isset($metadata['metrics']['nb_visits'])) {            $parameters['filter_add_columns_when_show_all_columns'] = '0';        }        $url = Url::getQueryStringFromParameters($parameters);        $request = new Request($url);        try {            $dataTable = $request->process();        } catch (Exception $e) {            throw new Exception(""API returned an error: "" . $e->getMessage() . ""\n"");        }        return $dataTable;    }    /**     * For a given API report, returns a simpler version     * of the metadata (will return only the metrics and the dimension name)     * @param $idSite     * @param $period     * @param $date     * @param $apiModule     * @param $apiAction     * @param $language     * @param $apiParameters     * @throws Exception     * @return array     */    private function getRowEvolutionMetaData($idSite, $period, $date, $apiModule, $apiAction, $language, $apiParameters)    {        $reportMetadata = API::getInstance()->getMetadata($idSite, $apiModule, $apiAction, $apiParameters, $language,            $period, $date, $hideMetricsDoc = false, $showSubtableReports = true);        if (empty($reportMetadata)) {            throw new Exception(""Requested report $apiModule.$apiAction for Website id=$idSite ""                . ""not found in the list of available reports. \n"");        }        $reportMetadata = reset($reportMetadata);        $metrics = $reportMetadata['metrics'];        if (isset($reportMetadata['processedMetrics']) && is_array($reportMetadata['processedMetrics'])) {            $metrics = $metrics + $reportMetadata['processedMetrics'];        }        if (empty($reportMetadata['dimension'])) {            throw new Exception(sprintf('Reports like %s.%s which do not have a dimension are not supported by row evolution', $apiModule, $apiAction));        }        $dimension = $reportMetadata['dimension'];        return compact('metrics', 'dimension');    }    /**     * Given the Row evolution dataTable, and the associated metadata,     * enriches the metadata with min/max values, and % change between the first period and the last one     * @param array $metadata     * @param DataTable\Map $dataTable     */    private function enhanceRowEvolutionMetaData(&$metadata, $dataTable)    {        // prepare result array for metrics        $metricsResult = array();        foreach ($metadata['metrics'] as $metric => $name) {            $metricsResult[$metric] = array('name' => $name);            if (!empty($metadata['logos'][$metric])) {                $metricsResult[$metric]['logo'] = $metadata['logos'][$metric];            }        }        unset($metadata['logos']);        $subDataTables = $dataTable->getDataTables();        if (empty($subDataTables)) {            throw new \Exception(""Unexpected state: row evolution API call returned empty DataTable\\Map."");        }        $firstDataTable = reset($subDataTables);        $this->checkDataTableInstance($firstDataTable);        $firstDataTableRow = $firstDataTable->getFirstRow();        $lastDataTable = end($subDataTables);        $this->checkDataTableInstance($lastDataTable);        $lastDataTableRow = $lastDataTable->getFirstRow();        // Process min/max values        $firstNonZeroFound = array();        foreach ($subDataTables as $subDataTable) {            // $subDataTable is the report for one period, it has only one row            $firstRow = $subDataTable->getFirstRow();            foreach ($metadata['metrics'] as $metric => $label) {                $value = $firstRow ? floatval($firstRow->getColumn($metric)) : 0;                if ($value > 0) {                    $firstNonZeroFound[$metric] = true;                } else if (!isset($firstNonZeroFound[$metric])) {                    continue;                }                if (!isset($metricsResult[$metric]['min'])                    || $metricsResult[$metric]['min'] > $value                ) {                    $metricsResult[$metric]['min'] = $value;                }                if (!isset($metricsResult[$metric]['max'])                    || $metricsResult[$metric]['max'] < $value                ) {                    $metricsResult[$metric]['max'] = $value;                }            }        }        // Process % change between first/last values        foreach ($metadata['metrics'] as $metric => $label) {            $first = $firstDataTableRow ? floatval($firstDataTableRow->getColumn($metric)) : 0;            $last = $lastDataTableRow ? floatval($lastDataTableRow->getColumn($metric)) : 0;            // do not calculate evolution if the first value is 0 (to avoid divide-by-zero)            if ($first == 0) {                continue;            }            $change = CalculateEvolutionFilter::calculate($last, $first, $quotientPrecision = 0, true, true);            $metricsResult[$metric]['change'] = $change;        }        $metadata['metrics'] = $metricsResult;    }    /** Get row evolution for a multiple labels */    private function getMultiRowEvolution(DataTable\Map $dataTable, $metadata, $apiModule, $apiAction, $labels, $column,                                          $legendAppendMetric = true,                                          $labelUseAbsoluteUrl = true,                                          $labelSeries = '')    {        $labelSeries = explode(',', $labelSeries);        $labelSeries = array_filter($labelSeries, 'strlen');        $labelSeries = array_map('intval', $labelSeries);        if (!isset($metadata['metrics'][$column])) {            // invalid column => use the first one that's available            $metrics = array_keys($metadata['metrics']);            $column = reset($metrics);        }        // get the processed label and logo (if any) for every requested label        $actualLabels = $logos = array();        foreach ($labels as $labelIdx => $label) {            foreach ($dataTable->getDataTables() as $table) {                $labelRow = $this->getRowEvolutionRowFromLabelIdx($table, $labelIdx);                if ($labelRow) {                    $actualLabels[$labelIdx] = $this->getRowUrlForEvolutionLabel(                        $labelRow, $apiModule, $apiAction, $labelUseAbsoluteUrl);                    $prettyLabel = $labelRow->getColumn('label_html');                    if ($prettyLabel !== false) {                        $actualLabels[$labelIdx] = $prettyLabel;                    }                    $logos[$labelIdx] = $labelRow->getMetadata('logo');                    if (!empty($actualLabels[$labelIdx])) {                        break;                    }                }            }            if (empty($actualLabels[$labelIdx])) {                $cleanLabel = $this->cleanOriginalLabel($label);                $actualLabels[$labelIdx] = $cleanLabel;            }            if (isset($labelSeries[$labelIdx])) {                $labelSeriesIndex = $labelSeries[$labelIdx];                $actualLabels[$labelIdx] .= ' ' . DataComparisonFilter::getPrettyComparisonLabelFromSeriesIndex($labelSeriesIndex);            }        }        // convert rows to be array($column.'_'.$labelIdx => $value) as opposed to        // array('label' => $label, 'column' => $value).        $dataTableMulti = $dataTable->getEmptyClone();        foreach ($dataTable->getDataTables() as $tableLabel => $table) {            $newRow = new Row();            foreach ($labels as $labelIdx => $label) {                $row = $this->getRowEvolutionRowFromLabelIdx($table, $labelIdx);                $value = 0;                if ($row) {                    $value = $row->getColumn($column);                    $value = floatVal(str_replace(',', '.', $value));                }                if ($value == '') {                    $value = 0;                }                $newLabel = $column . '_' . (int)$labelIdx;                $newRow->addColumn($newLabel, $value);            }            $newTable = $table->getEmptyClone();            if (!empty($labels)) { // only add a row if the row has data (no labels === no data)                $newTable->addRow($newRow);            }            $dataTableMulti->addTable($newTable, $tableLabel);        }        // the available metrics for the report are returned as metadata / columns        $metadata['columns'] = $metadata['metrics'];        // metadata / metrics should document the rows that are compared        // this way, UI code can be reused        $metadata['metrics'] = array();        foreach ($actualLabels as $labelIndex => $label) {            if ($legendAppendMetric) {                $label .= ' (' . $metadata['columns'][$column] . ')';            }            $metricName = $column . '_' . $labelIndex;            $metadata['metrics'][$metricName] = $label;            if (!empty($logos[$labelIndex])) {                $metadata['logos'][$metricName] = $logos[$labelIndex];            }        }        $this->enhanceRowEvolutionMetaData($metadata, $dataTableMulti);        return array(            'column'     => $column,            'reportData' => $dataTableMulti,            'metadata'   => $metadata        );    }    /**     * Returns the row in a datatable by its LabelFilter::FLAG_IS_ROW_EVOLUTION metadata.     *     * @param DataTable $table     * @param int $labelIdx     * @return Row|false     */    private function getRowEvolutionRowFromLabelIdx($table, $labelIdx)    {        $labelIdx = (int)$labelIdx;        foreach ($table->getRows() as $row) {            if ($row->getMetadata(LabelFilter::FLAG_IS_ROW_EVOLUTION) === $labelIdx) {                return $row;            }        }        return false;    }    /**     * Returns a prettier, more comprehensible version of a row evolution label for display.     */    private function cleanOriginalLabel($label)    {        $label = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        $label = SafeDecodeLabel::decodeLabelSafe($label);        return $label;    }    private function checkDataTableInstance($lastDataTable)    {        if (!($lastDataTable instanceof DataTable)) {            throw new \Exception(""Unexpected state: row evolution returned DataTable\\Map w/ incorrect child table type: "" . get_class($lastDataTable));        }    }}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1354," Sets a value. If the key did not exist before it will be created.\\\\n\\\\n @param string $app app\\\\n @param string $key key\\\\n @param string|float|int $value value\\\\n @return bool True if the value was inserted or updated, false if the value was the same\\\\n",Postavlja vrednost. Ako ključ nije postojao pre nego što će biti kreiran,"public function setValue($app, $key, $value) {return $this->emittingCall(function (&$afterArray) use (&$app, &$key, &$value) {if (!$this->hasKey($app, $key)) {$inserted = (bool) $this->conn->insertIfNotExist('*PREFIX*appconfig', ['appid' => $app,'configkey' => $key,'configvalue' => $value,], ['appid','configkey',]);if ($inserted) {if (!isset($this->cache[$app])) {$this->cache[$app] = [];}$this->cache[$app][$key] = $value;return true;}}$sql = $this->conn->getQueryBuilder();$sql->update('appconfig')->set('configvalue', $sql->createParameter('configvalue'))->where($sql->expr()->eq('appid', $sql->createParameter('app')))->andWhere($sql->expr()->eq('configkey', $sql->createParameter('configkey')))->setParameter('configvalue', $value)->setParameter('app', $app)->setParameter('configkey', $key);/* * Only limit to the existing value for non-Oracle DBs: * http://docs.oracle.com/cd/E11882_01/server.112/e26088/conditions002.htm#i1033286 * > Large objects (LOBs) are not supported in comparison conditions. */if (!($this->conn instanceof \OC\DB\OracleConnection)) {// Only update the value when it is not the same$sql->andWhere($sql->expr()->neq('configvalue', $sql->createParameter('configvalue')))->setParameter('configvalue', $value);}if (isset($this->cache[$app], $this->cache[$app][$key])) {$afterArray['update'] = true;$afterArray['oldvalue'] = $this->cache[$app][$key];}$changedRow = (bool) $sql->execute();$this->cache[$app][$key] = $value;return $changedRow;}, [",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1355, Deletes a key\\\\n\\\\n @param string $app app\\\\n @param string $key key\\\\n @return boolean|null\\\\n,Briše ključ,"public function deleteKey($app, $key) {$this->emittingCall(function () use (&$app, &$key) {$this->loadConfigValues();$sql = $this->conn->getQueryBuilder();$sql->delete('appconfig')->where($sql->expr()->eq('appid', $sql->createParameter('app')))->andWhere($sql->expr()->eq('configkey', $sql->createParameter('configkey')))->setParameter('app', $app)->setParameter('configkey', $key);$sql->execute();unset($this->cache[$app][$key]);return true;}, [",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppConfig_1356, Remove app from appconfig\n\n @param string $app app\n @return boolean|null\n\n Removes all keys in appconfig belonging to the app.\n,Uklanja aplikaciju iz appconfig,"public function deleteApp($app) {$this->emittingCall(function () use (&$app) {$this->loadConfigValues();$sql = $this->conn->getQueryBuilder();$sql->delete('appconfig')->where($sql->expr()->eq('appid', $sql->createParameter('app')))->setParameter('app', $app);$sql->execute();unset($this->cache[$app]);return true;}, [",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swoft-cloud_swoft_DbSelector_3501, Class DbSelector\n\n @since 2.0\n\n @Bean()\n,Klasa DbSelector,"class DbSelector implements DbSelectorInterface{    /**     * @param Connection $connection     */    public function select(Connection $connection): void    {        $selectIndex  = (int)context()->getRequest()->query('id', 0);        $createDbName = $connection->getDb();        if ($selectIndex == 0) {            $selectIndex = '';        }        if ($createDbName == 'test2') {            $createDbName = 'test';        }        $dbName = sprintf('%s%s', $createDbName, (string)$selectIndex);        $connection->db($dbName);    }}",2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_UploadedFile_9948, Returns the maximum size of an uploaded file as configured in php.ini.\n\n @return int|float The maximum size of an uploaded file in bytes (returns float if size > PHP_INT_MAX)\n,Vraća maksimalnu veličinu učitane datoteke kako je konfigurisana u php.ini fajlu,"final class UrlHelper{    private $requestStack;    private $requestContext;    public function __construct(RequestStack $requestStack, RequestContext $requestContext = null)    {        $this->requestStack = $requestStack;        $this->requestContext = $requestContext;    }    public function getAbsoluteUrl(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $this->getAbsoluteUrlFromContext($path);        }        if ('#' === $path[0]) {            $path = $request->getRequestUri().$path;        } elseif ('?' === $path[0]) {            $path = $request->getPathInfo().$path;        }        if (!$path || '/' !== $path[0]) {            $prefix = $request->getPathInfo();            $last = \strlen($prefix) - 1;            if ($last !== $pos = strrpos($prefix, '/')) {                $prefix = substr($prefix, 0, $pos).'/';            }            return $request->getUriForPath($prefix.$path);        }        return $request->getSchemeAndHttpHost().$path;    }    public function getRelativePath(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $path;        }        return $request->getRelativeUriForPath($path);    }    private function getAbsoluteUrlFromContext(string $path): string    {        if (null === $this->requestContext || '' === $host = $this->requestContext->getHost()) {            return $path;        }        $scheme = $this->requestContext->getScheme();        $port = '';        if ('http' === $scheme && 80 !== $this->requestContext->getHttpPort()) {            $port = ':'.$this->requestContext->getHttpPort();        } elseif ('https' === $scheme && 443 !== $this->requestContext->getHttpsPort()) {            $port = ':'.$this->requestContext->getHttpsPort();        }        if ('#' === $path[0]) {            $queryString = $this->requestContext->getQueryString();            $path = $this->requestContext->getPathInfo().($queryString ? '?'.$queryString : '').$path;        } elseif ('?' === $path[0]) {            $path = $this->requestContext->getPathInfo().$path;        }        if ('/' !== $path[0]) {            $path = rtrim($this->requestContext->getBaseUrl(), '/').'/'.$path;        }        return $scheme.'://'.$host.$port.$path;    }}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-kernel_UriSigner_3083, Signs URIs.\n\n @author Fabien Potencier <fabien@symfony.com>\n,Potpisuje URI linkove,"    public function check(string $uri)    {        $url = parse_url($uri);        if (isset($url['query'])) {            parse_str($url['query'], $params);        } else {            $params = [];        }        if (empty($params[$this->parameter])) {            return false;        }        $hash = $params[$this->parameter];        unset($params[$this->parameter]);        return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2087, Get current url.\n\n @return string\n,Preuzmi trenutni url,"class Client extends BaseClient{    /**     * @var string     */    protected $baseUri = 'https://api.weixin.qq.com/cgi-bin/';    /**     * Allow media type.     *     * @var array     */    protected $allowTypes = ['image', 'voice', 'video', 'thumb'];    /**     * Upload image.     *     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadImage($path)    {        return $this->upload('image', $path);    }    /**     * Upload video.     *     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadVideo($path)    {        return $this->upload('video', $path);    }    /**     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadVoice($path)    {        return $this->upload('voice', $path);    }    /**     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadThumb($path)    {        return $this->upload('thumb', $path);    }    /**     * Upload temporary material.     *     * @param string $type     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function upload(string $type, string $path)    {        if (!file_exists($path) || !is_readable($path)) {            throw new InvalidArgumentException(sprintf(""File does not exist, or the file is unreadable: '%s'"", $path));        }        if (!in_array($type, $this->allowTypes, true)) {            throw new InvalidArgumentException(sprintf(""Unsupported media type: '%s'"", $type));        }        return $this->httpUpload('media/upload', ['media' => $path], ['type' => $type]);    }    /**     * @param string $path     * @param string $title     * @param string $description     *     * @return array|\EasyWeChat\Kernel\Support\Collection|object|\Psr\Http\Message\ResponseInterface|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadVideoForBroadcasting(string $path, string $title, string $description)    {        $response = $this->uploadVideo($path);        /** @var array $arrayResponse */        $arrayResponse = $this->detectAndCastResponseToType($response, 'array');        if (!empty($arrayResponse['media_id'])) {            return $this->createVideoForBroadcasting($arrayResponse['media_id'], $title, $description);        }        return $response;    }    /**     * @param string $mediaId     * @param string $title     * @param string $description     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function createVideoForBroadcasting(string $mediaId, string $title, string $description)    {        return $this->httpPostJson('media/uploadvideo', [            'media_id' => $mediaId,            'title' => $title,            'description' => $description,        ]);    }    /**     * Fetch item from WeChat server.     *     * @param string $mediaId     *     * @return \EasyWeChat\Kernel\Http\StreamResponse|\Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function get(string $mediaId)    {        $response = $this->requestRaw('media/get', 'GET', [            'query' => [                'media_id' => $mediaId,            ],        ]);        if (false !== stripos($response->getHeaderLine('Content-disposition'), 'attachment')) {            return StreamResponse::buildFromPsrResponse($response);        }        return $this->castResponseToType($response, $this->app['config']->get('response_type'));    }    /**     * @param string $mediaId     *     * @return array|\EasyWeChat\Kernel\Http\Response|\EasyWeChat\Kernel\Support\Collection|object|\Psr\Http\Message\ResponseInterface|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function getJssdkMedia(string $mediaId)    {        $response = $this->requestRaw('media/get/jssdk', 'GET', [            'query' => [                'media_id' => $mediaId,            ],        ]);        if (false !== stripos($response->getHeaderLine('Content-disposition'), 'attachment')) {            return StreamResponse::buildFromPsrResponse($response);        }        return $this->castResponseToType($response, $this->app['config']->get('response_type'));    }}",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2418, Find annotations for entry id.\\n\\n @param int $entryId\\n @param int $userId\\n\\n @return array\\n,Pronađite napomene za ID unos,"    public function findLastAnnotationByPageId($entryId, $userId)    {        return $this->createQueryBuilder('a')            ->where('a.entry = :entryId')->setParameter('entryId', $entryId)            ->andwhere('a.user = :userId')->setParameter('userId', $userId)            ->orderBy('a.id', 'DESC')            ->setMaxResults(1)            ->getQuery()            ->getOneOrNullResult();    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2419, Find last annotation for a given entry id. Used only for tests.\\n\\n @param int $entryId\\n\\n @return array\\n,Pronađi poslednju napomenu za dati ID unos. Koristi se samo za testove,"    public function findLastAnnotationByPageId($entryId, $userId)    {        return $this->createQueryBuilder('a')            ->where('a.entry = :entryId')->setParameter('entryId', $entryId)            ->andwhere('a.user = :userId')->setParameter('userId', $userId)            ->orderBy('a.id', 'DESC')            ->setMaxResults(1)            ->getQuery()            ->getOneOrNullResult();    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2419, Remove all annotations for a user id.\\n Used when a user want to reset all informations.\\n\\n @param int $userId\\n,Uklonite sve napomene za korisnički ID. Koristi se kada korisnik žželi da resetuje sve informacije,"    public function removeAllByUserId($userId)    {        $this->getEntityManager()            ->createQuery('DELETE FROM Wallabag\AnnotationBundle\Entity\Annotation a WHERE a.user = :userId')            ->setParameter('userId', $userId)            ->execute();    }",3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_AnnotationRepository_2421,Return a query builder to used by other getBuilderFor\\n @param int $userId\\n\\n @return QueryBuilder\\n,Vratite graditelj upita onom koji koristi drugi getBuilderFor,"    private function getSortedQueryBuilderByUser($userId)    {        return $this->createQueryBuilder('a')            ->leftJoin('a.user', 'u')            ->andWhere('u.id = :userId')->setParameter('userId', $userId)            ->orderBy('a.id', 'desc')        ;    }",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
woocommerce_woocommerce_class-wc-breadcrumb_1834, Add crumbs for a term.\n\n @param int    $term_id  Term ID.\n @param string $taxonomy Taxonomy.\n,Dodajte mrvice za pojam,"protected function search_trail() {if ( is_search() ) {/* translators: %s: search term */$this->add_crumb( sprintf( __( 'Search results for &ldquo;%s&rdquo;', 'woocommerce' ), get_search_query() ), remove_query_arg( 'paged' ) );}",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_144," This attempts to find media, other files, and download them\n\n @param string $path\n @return PageInterface|false\n","Ovo pokušava da pronađe medije, druge datoteke i preuzme ih","    public function fallbackUrl($path)    {        $this->fireEvent('onPageFallBackUrl');        /** @var Uri $uri */        $uri = $this['uri'];        /** @var Config $config */        $config = $this['config'];        $uri_extension = strtolower($uri->extension());        $fallback_types = $config->get('system.media.allowed_fallback_types', null);        $supported_types = $config->get('media.types');        // Check whitelist first, then ensure extension is a valid media type        if (!empty($fallback_types) && !in_array($uri_extension, $fallback_types, true)) {            return false;        }        if (!array_key_exists($uri_extension, $supported_types)) {            return false;        }        $path_parts = pathinfo($path);        /** @var Pages $pages */        $pages = $this['pages'];        $page = $pages->find($path_parts['dirname'], true);        if ($page) {            $media = $page->media()->all();            $parsed_url = parse_url(rawurldecode($uri->basename()));            $media_file = $parsed_url['path'];            // if this is a media object, try actions first            if (isset($media[$media_file])) {                /** @var Medium $medium */                $medium = $media[$media_file];                foreach ($uri->query(null, true) as $action => $params) {                    if (in_array($action, ImageMedium::$magic_actions, true)) {                        call_user_func_array([&$medium, $action], explode(',', $params));                    }                }                Utils::download($medium->path(), false);            }            // unsupported media type, try to download it...            if ($uri_extension) {                $extension = $uri_extension;            } else {                if (isset($path_parts['extension'])) {                    $extension = $path_parts['extension'];                } else {                    $extension = null;                }            }            if ($extension) {                $download = true;                if (in_array(ltrim($extension, '.'), $config->get('system.media.unsupported_inline_types', []), true)) {                    $download = false;                }                Utils::download($page->path() . DIRECTORY_SEPARATOR . $uri->basename(), $download);            }            // Nothing found            return false;        }        return $page;    }",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_444, Returns classname of given command name\n\n @param  string $name\n @return string\n,Vraća ime klase za ime date komande,"    private function getCommandClassName($name)    {        $name = mb_convert_case($name[0], MB_CASE_UPPER, 'utf-8') . mb_substr($name, 1, mb_strlen($name));                $drivername = $this->getDriverName();        $classnameLocal = sprintf('\Intervention\Image\%s\Commands\%sCommand', $drivername, ucfirst($name));        $classnameGlobal = sprintf('\Intervention\Image\Commands\%sCommand', ucfirst($name));        if (class_exists($classnameLocal)) {            return $classnameLocal;        } elseif (class_exists($classnameGlobal)) {            return $classnameGlobal;        }        throw new NotSupportedException(            ""Command ({$name}) is not available for driver ({$drivername}).""        );    }",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Input_363, Fetch the IP Address\n\n Determines and validates the visitor's IP address.\n\n @return\tstring\tIP address\n,Preuzimanje IP adrese. Određuje i potvrđuje IP adresu posetioca,"public function ip_address(){if ($this->ip_address !== FALSE){return $this->ip_address;}$proxy_ips = config_item('proxy_ips');if ( ! empty($proxy_ips) && ! is_array($proxy_ips)){$proxy_ips = explode(',', str_replace(' ', '', $proxy_ips));}$this->ip_address = $this->server('REMOTE_ADDR');if ($proxy_ips){foreach (array('HTTP_X_FORWARDED_FOR', 'HTTP_CLIENT_IP', 'HTTP_X_CLIENT_IP', 'HTTP_X_CLUSTER_CLIENT_IP') as $header){if (($spoof = $this->server($header)) !== NULL){// Some proxies typically list the whole chain of IP// addresses through which the client has reached us.// e.g. client_ip, proxy_ip1, proxy_ip2, etc.sscanf($spoof, '%[^,]', $spoof);if ( ! $this->valid_ip($spoof)){$spoof = NULL;}else{break;}}}if ($spoof){for ($i = 0, $c = count($proxy_ips); $i < $c; $i++){// Check if we have an IP address or a subnetif (strpos($proxy_ips[$i], '/') === FALSE){// An IP address (and not a subnet) is specified.// We can compare right away.if ($proxy_ips[$i] === $this->ip_address){$this->ip_address = $spoof;break;}continue;}// We have a subnet ... now the heavy lifting beginsisset($separator) OR $separator = $this->valid_ip($this->ip_address, 'ipv6') ? ':' : '.';// If the proxy entry doesn't match the IP protocol - skip itif (strpos($proxy_ips[$i], $separator) === FALSE){continue;}// Convert the REMOTE_ADDR IP address to binary, if neededif ( ! isset($ip, $sprintf)){if ($separator === ':'){// Make sure we're have the ""full"" IPv6 format$ip = explode(':',str_replace('::',str_repeat(':', 9 - substr_count($this->ip_address, ':')),$this->ip_address));for ($j = 0; $j < 8; $j++){$ip[$j] = intval($ip[$j], 16);}$sprintf = '%016b%016b%016b%016b%016b%016b%016b%016b';}else{$ip = explode('.', $this->ip_address);$sprintf = '%08b%08b%08b%08b';}$ip = vsprintf($sprintf, $ip);}// Split the netmask length off the network addresssscanf($proxy_ips[$i], '%[^/]/%d', $netaddr, $masklen);// Again, an IPv6 address is most likely in a compressed formif ($separator === ':'){$netaddr = explode(':', str_replace('::', str_repeat(':', 9 - substr_count($netaddr, ':')), $netaddr));for ($j = 0; $j < 8; $j++){$netaddr[$j] = intval($netaddr[$j], 16);}}else{$netaddr = explode('.', $netaddr);}// Convert to binary and finally compareif (strncmp($ip, vsprintf($sprintf, $netaddr), $masklen) === 0){$this->ip_address = $spoof;break;}}}}if ( ! $this->valid_ip($this->ip_address)){return $this->ip_address = '0.0.0.0';}return $this->ip_address;}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1130, The GravCache object is used throughout Grav to store and retrieve cached data.\\n It uses DoctrineCache library and supports a variety of caching mechanisms. Those include:\\n\\n APCu\\n RedisCache\\n MemCache\\n MemCacheD\\n FileSystem\\n,"Objekt GravCache koristi se u celom Grav-u za skladištenje i preuzimanje keširanih podataka. Koristi biblioteku DoctrineCache i podržava razne mehanizme keširanja. To uključuje: APCu, RedisCache, MemCache, MemCacheD, FileSistem","class Cache extends Getters{    /** @var string Cache key. */    protected $key;    /** @var int */    protected $lifetime;    /** @var int */    protected $now;    /** @var Config $config */    protected $config;    /** @var DoctrineCache\CacheProvider */    protected $driver;    /** @var CacheInterface */    protected $simpleCache;    /** @var string */    protected $driver_name;    /** @var string */    protected $driver_setting;    /** @var bool */    protected $enabled;    /** @var string */    protected $cache_dir;    protected static $standard_remove = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'cache://images',        'asset://',    ];    protected static $standard_remove_no_images = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'asset://',    ];    protected static $all_remove = [        'cache://',        'cache://images',        'asset://',        'tmp://'    ];    protected static $assets_remove = [        'asset://'    ];    protected static $images_remove = [        'cache://images'    ];    protected static $cache_remove = [        'cache://'    ];    protected static $tmp_remove = [        'tmp://'    ];    /**     * Constructor     *     * @param Grav $grav     */    public function __construct(Grav $grav)    {        $this->init($grav);    }    /**     * Initialization that sets a base key and the driver based on configuration settings     *     * @param  Grav $grav     * @return void     */    public function init(Grav $grav)    {        $this->config = $grav['config'];        $this->now = time();        if (null === $this->enabled) {            $this->enabled = (bool)$this->config->get('system.cache.enabled');        }        /** @var Uri $uri */        $uri = $grav['uri'];        $prefix = $this->config->get('system.cache.prefix');        $uniqueness = substr(md5($uri->rootUrl(true) . $this->config->key() . GRAV_VERSION), 2, 8);        // Cache key allows us to invalidate all cache on configuration changes.        $this->key = ($prefix ? $prefix : 'g') . '-' . $uniqueness;        $this->cache_dir = $grav['locator']->findResource('cache://doctrine/' . $uniqueness, true, true);        $this->driver_setting = $this->config->get('system.cache.driver');        $this->driver = $this->getCacheDriver();        $this->driver->setNamespace($this->key);        /** @var EventDispatcher $dispatcher */        $dispatcher = Grav::instance()['events'];        $dispatcher->addListener('onSchedulerInitialized', [$this, 'onSchedulerInitialized']);    }    /**     * @return CacheInterface     */    public function getSimpleCache()    {        if (null === $this->simpleCache) {            $cache = new \Grav\Framework\Cache\Adapter\DoctrineCache($this->driver, '', $this->getLifetime());            // Disable cache key validation.            $cache->setValidation(false);            $this->simpleCache = $cache;        }        return $this->simpleCache;    }    /**     * Deletes the old out of date file-based caches     *     * @return int     */    public function purgeOldCache()    {        $cache_dir = dirname($this->cache_dir);        $current = basename($this->cache_dir);        $count = 0;        foreach (new DirectoryIterator($cache_dir) as $file) {            $dir = $file->getBasename();            if ($dir === $current || $file->isDot() || $file->isFile()) {                continue;            }            Folder::delete($file->getPathname());            $count++;        }        return $count;    }    /**     * Public accessor to set the enabled state of the cache     *     * @param bool|int $enabled     * @return void     */    public function setEnabled($enabled)    {        $this->enabled = (bool)$enabled;    }    /**     * Returns the current enabled state     *     * @return bool     */    public function getEnabled()    {        return $this->enabled;    }    /**     * Get cache state     *     * @return string     */    public function getCacheStatus()    {        return 'Cache: [' . ($this->enabled ? 'true' : 'false') . '] Setting: [' . $this->driver_setting . '] Driver: [' . $this->driver_name . ']';    }    /**     * Automatically picks the cache mechanism to use.  If you pick one manually it will use that     * If there is no config option for $driver in the config, or it's set to 'auto', it will     * pick the best option based on which cache extensions are installed.     *     * @return DoctrineCache\CacheProvider  The cache driver to use     */    public function getCacheDriver()    {        $setting = $this->driver_setting;        $driver_name = 'file';        // CLI compatibility requires a non-volatile cache driver        if ($this->config->get('system.cache.cli_compatibility') && (            $setting === 'auto' || $this->isVolatileDriver($setting))) {            $setting = $driver_name;        }        if (!$setting || $setting === 'auto') {            if (extension_loaded('apcu')) {                $driver_name = 'apcu';            } elseif (extension_loaded('wincache')) {                $driver_name = 'wincache';            }        } else {            $driver_name = $setting;        }        $this->driver_name = $driver_name;        switch ($driver_name) {            case 'apc':            case 'apcu':                $driver = new DoctrineCache\ApcuCache();                break;            case 'wincache':                $driver = new DoctrineCache\WinCacheCache();                break;            case 'memcache':                if (extension_loaded('memcache')) {                    $memcache = new \Memcache();                    $memcache->connect(                        $this->config->get('system.cache.memcache.server', 'localhost'),                        $this->config->get('system.cache.memcache.port', 11211)                    );                    $driver = new DoctrineCache\MemcacheCache();                    $driver->setMemcache($memcache);                } else {                    throw new LogicException('Memcache PHP extension has not been installed');                }                break;            case 'memcached':                if (extension_loaded('memcached')) {                    $memcached = new \Memcached();                    $memcached->addServer(                        $this->config->get('system.cache.memcached.server', 'localhost'),                        $this->config->get('system.cache.memcached.port', 11211)                    );                    $driver = new DoctrineCache\MemcachedCache();                    $driver->setMemcached($memcached);                } else {                    throw new LogicException('Memcached PHP extension has not been installed');                }                break;            case 'redis':                if (extension_loaded('redis')) {                    $redis = new \Redis();                    $socket = $this->config->get('system.cache.redis.socket', false);                    $password = $this->config->get('system.cache.redis.password', false);                    $databaseId = $this->config->get('system.cache.redis.database', 0);                    if ($socket) {                        $redis->connect($socket);                    } else {                        $redis->connect(                            $this->config->get('system.cache.redis.server', 'localhost'),                            $this->config->get('system.cache.redis.port', 6379)                        );                    }                    // Authenticate with password if set                    if ($password && !$redis->auth($password)) {                        throw new \RedisException('Redis authentication failed');                    }                    // Select alternate ( !=0 ) database ID if set                    if ($databaseId && !$redis->select($databaseId)) {                        throw new \RedisException('Could not select alternate Redis database ID');                    }                    $driver = new DoctrineCache\RedisCache();                    $driver->setRedis($redis);                } else {                    throw new LogicException('Redis PHP extension has not been installed');                }                break;            default:                $driver = new DoctrineCache\FilesystemCache($this->cache_dir);                break;        }        return $driver;    }    /**     * Gets a cached entry if it exists based on an id. If it does not exist, it returns false     *     * @param  string $id the id of the cached entry     * @return mixed|bool     returns the cached entry, can be any type, or false if doesn't exist     */    public function fetch($id)    {        if ($this->enabled) {            return $this->driver->fetch($id);        }        return false;    }    /**     * Stores a new cached entry.     *     * @param  string       $id       the id of the cached entry     * @param  array|object|int $data     the data for the cached entry to store     * @param  int|null     $lifetime the lifetime to store the entry in seconds     */    public function save($id, $data, $lifetime = null)    {        if ($this->enabled) {            if ($lifetime === null) {                $lifetime = $this->getLifetime();            }            $this->driver->save($id, $data, $lifetime);        }    }    /**     * Deletes an item in the cache based on the id     *     * @param string $id    the id of the cached data entry     * @return bool         true if the item was deleted successfully     */    public function delete($id)    {        if ($this->enabled) {            return $this->driver->delete($id);        }        return false;    }    /**     * Deletes all cache     *     * @return bool     */    public function deleteAll()    {        if ($this->enabled) {            return $this->driver->deleteAll();        }        return false;    }    /**     * Returns a boolean state of whether or not the item exists in the cache based on id key     *     * @param string $id    the id of the cached data entry     * @return bool         true if the cached items exists     */    public function contains($id)    {        if ($this->enabled) {            return $this->driver->contains(($id));        }        return false;    }    /**     * Getter method to get the cache key     *     * @return string     */    public function getKey()    {        return $this->key;    }    /**     * Setter method to set key (Advanced)     *     * @param string $key     * @return void     */    public function setKey($key)    {        $this->key = $key;        $this->driver->setNamespace($this->key);    }    /**     * Helper method to clear all Grav caches     *     * @param string $remove standard|all|assets-only|images-only|cache-only     * @return array     */    public static function clearCache($remove = 'standard')    {        $locator = Grav::instance()['locator'];        $output = [];        $user_config = USER_DIR . 'config/system.yaml';        switch ($remove) {            case 'all':                $remove_paths = self::$all_remove;                break;            case 'assets-only':                $remove_paths = self::$assets_remove;                break;            case 'images-only':                $remove_paths = self::$images_remove;                break;            case 'cache-only':                $remove_paths = self::$cache_remove;                break;            case 'tmp-only':                $remove_paths = self::$tmp_remove;                break;            case 'invalidate':                $remove_paths = [];                break;            default:                if (Grav::instance()['config']->get('system.cache.clear_images_by_default')) {                    $remove_paths = self::$standard_remove;                } else {                    $remove_paths = self::$standard_remove_no_images;                }        }        // Delete entries in the doctrine cache if required        if (in_array($remove, ['all', 'standard'])) {            $cache = Grav::instance()['cache'];            $cache->driver->deleteAll();        }        // Clearing cache event to add paths to clear        Grav::instance()->fireEvent('onBeforeCacheClear', new Event(['remove' => $remove, 'paths' => &$remove_paths]));        foreach ($remove_paths as $stream) {            // Convert stream to a real path            try {                $path = $locator->findResource($stream, true, true);                if ($path === false) {                    continue;                }                $anything = false;                $files = glob($path . '/*');                if (is_array($files)) {                    foreach ($files as $file) {                        if (is_link($file)) {                            $output[] = '<yellow>Skipping symlink:  </yellow>' . $file;                        } elseif (is_file($file)) {                            if (@unlink($file)) {                                $anything = true;                            }                        } elseif (is_dir($file)) {                            if (Folder::delete($file, false)) {                                $anything = true;                            }                        }                    }                }                if ($anything) {                    $output[] = '<red>Cleared:  </red>' . $path . '/*';                }            } catch (Exception $e) {                // stream not found or another error while deleting files.                $output[] = '<red>ERROR: </red>' . $e->getMessage();            }        }        $output[] = '';        if (($remove === 'all' || $remove === 'standard') && file_exists($user_config)) {            touch($user_config);            $output[] = '<red>Touched: </red>' . $user_config;            $output[] = '';        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }        Grav::instance()->fireEvent('onAfterCacheClear', new Event(['remove' => $remove, 'output' => &$output]));        return $output;    }    /**     * @return void     */    public static function invalidateCache()    {        $user_config = USER_DIR . 'config/system.yaml';        if (file_exists($user_config)) {            touch($user_config);        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }    }    /**     * Set the cache lifetime programmatically     *     * @param int $future timestamp     * @return void     */    public function setLifetime($future)    {        if (!$future) {            return;        }        $interval = (int)($future - $this->now);        if ($interval > 0 && $interval < $this->getLifetime()) {            $this->lifetime = $interval;        }    }    /**     * Retrieve the cache lifetime (in seconds)     *     * @return int     */    public function getLifetime()    {        if ($this->lifetime === null) {            $this->lifetime = (int)($this->config->get('system.cache.lifetime') ?: 604800); // 1 week default        }        return $this->lifetime;    }    /**     * Returns the current driver name     *     * @return string     */    public function getDriverName()    {        return $this->driver_name;    }    /**     * Returns the current driver setting     *     * @return string     */    public function getDriverSetting()    {        return $this->driver_setting;    }    /**     * is this driver a volatile driver in that it resides in PHP process memory     *     * @param string $setting     * @return bool     */    public function isVolatileDriver($setting)    {        if (in_array($setting, ['apc', 'apcu', 'xcache', 'wincache'])) {            return true;        }        return false;    }    /**     * Static function to call as a scheduled Job to purge old Doctrine files     *     * @param bool $echo     *     * @return string|void     */    public static function purgeJob($echo = false)    {        /** @var Cache $cache */        $cache = Grav::instance()['cache'];        $deleted_folders = $cache->purgeOldCache();        $msg = 'Purged ' . $deleted_folders . ' old cache folders...';        if ($echo) {            echo $msg;        } else {            return $msg;        }    }    /**     * Static function to call as a scheduled Job to clear Grav cache     *     * @param string $type     * @return void     */    public static function clearJob($type)    {        $result = static::clearCache($type);        static::invalidateCache();        echo strip_tags(implode(""\n"", $result));    }    /**     * @param Event $event     * @return void     */    public function onSchedulerInitialized(Event $event)    {        /** @var Scheduler $scheduler */        $scheduler = $event['scheduler'];        $config = Grav::instance()['config'];        // File Cache Purge        $at = $config->get('system.cache.purge_at');        $name = 'cache-purge';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::purgeJob', [true], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');        // Cache Clear        $at = $config->get('system.cache.clear_at');        $clear_type = $config->get('system.cache.clear_job_type');        $name = 'cache-clear';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::clearJob', [$clear_type], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');    }}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_654," This class defines attributes, valid values, and usage which is generated\\\\n from a given json schema.\\\\n http://tools.ietf.org/html/draft-zyp-json-schema-03#section-5\\\\n\\\\n","Ova klasa definiše atribute, važeće vrednosti i upotrebu koja se generiše iz date json šeme","class Model implements \ArrayAccess{  /**   * If you need to specify a NULL JSON value, use Google\Model::NULL_VALUE   * instead - it will be replaced when converting to JSON with a real null.   */  const NULL_VALUE = ""{}gapi-php-null"";  protected $internal_gapi_mappings = array();  protected $modelData = array();  protected $processed = array();  /**   * Polymorphic - accepts a variable number of arguments dependent   * on the type of the model subclass.   */  final public function __construct()  {    if (func_num_args() == 1 && is_array(func_get_arg(0))) {      // Initialize the model with the array's contents.      $array = func_get_arg(0);      $this->mapTypes($array);    }    $this->gapiInit();  }  /**   * Getter that handles passthrough access to the data array, and lazy object creation.   * @param string $key Property name.   * @return mixed The value if any, or null.   */  public function __get($key)  {    $keyType = $this->keyType($key);    $keyDataType = $this->dataType($key);    if ($keyType && !isset($this->processed[$key])) {      if (isset($this->modelData[$key])) {        $val = $this->modelData[$key];      } elseif ($keyDataType == 'array' || $keyDataType == 'map') {        $val = array();      } else {        $val = null;      }      if ($this->isAssociativeArray($val)) {        if ($keyDataType && 'map' == $keyDataType) {          foreach ($val as $arrayKey => $arrayItem) {              $this->modelData[$key][$arrayKey] =                new $keyType($arrayItem);          }        } else {          $this->modelData[$key] = new $keyType($val);        }      } else if (is_array($val)) {        $arrayObject = array();        foreach ($val as $arrayIndex => $arrayItem) {          $arrayObject[$arrayIndex] = new $keyType($arrayItem);        }        $this->modelData[$key] = $arrayObject;      }      $this->processed[$key] = true;    }    return isset($this->modelData[$key]) ? $this->modelData[$key] : null;  }  /**   * Initialize this object's properties from an array.   *   * @param array $array Used to seed this object's properties.   * @return void   */  protected function mapTypes($array)  {    // Hard initialise simple types, lazy load more complex ones.    foreach ($array as $key => $val) {      if ($keyType = $this->keyType($key)) {        $dataType = $this->dataType($key);        if ($dataType == 'array' || $dataType == 'map') {          $this->$key = array();          foreach ($val as $itemKey => $itemVal) {            if ($itemVal instanceof $keyType) {              $this->{$key}[$itemKey] = $itemVal;            } else {              $this->{$key}[$itemKey] = new $keyType($itemVal);            }          }        } elseif ($val instanceof $keyType) {          $this->$key = $val;        } else {          $this->$key = new $keyType($val);        }        unset($array[$key]);      } elseif (property_exists($this, $key)) {          $this->$key = $val;          unset($array[$key]);      } elseif (property_exists($this, $camelKey = $this->camelCase($key))) {          // This checks if property exists as camelCase, leaving it in array as snake_case          // in case of backwards compatibility issues.          $this->$camelKey = $val;      }    }    $this->modelData = $array;  }  /**   * Blank initialiser to be used in subclasses to do  post-construction initialisation - this   * avoids the need for subclasses to have to implement the variadics handling in their   * constructors.   */  protected function gapiInit()  {    return;  }  /**   * Create a simplified object suitable for straightforward   * conversion to JSON. This is relatively expensive   * due to the usage of reflection, but shouldn't be called   * a whole lot, and is the most straightforward way to filter.   */  public function toSimpleObject()  {    $object = new stdClass();    // Process all other data.    foreach ($this->modelData as $key => $val) {      $result = $this->getSimpleValue($val);      if ($result !== null) {        $object->$key = $this->nullPlaceholderCheck($result);      }    }    // Process all public properties.    $reflect = new ReflectionObject($this);    $props = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);    foreach ($props as $member) {      $name = $member->getName();      $result = $this->getSimpleValue($this->$name);      if ($result !== null) {        $name = $this->getMappedName($name);        $object->$name = $this->nullPlaceholderCheck($result);      }    }    return $object;  }  /**   * Handle different types of values, primarily   * other objects and map and array data types.   */  private function getSimpleValue($value)  {    if ($value instanceof Model) {      return $value->toSimpleObject();    } else if (is_array($value)) {      $return = array();      foreach ($value as $key => $a_value) {        $a_value = $this->getSimpleValue($a_value);        if ($a_value !== null) {          $key = $this->getMappedName($key);          $return[$key] = $this->nullPlaceholderCheck($a_value);        }      }      return $return;    }    return $value;  }  /**   * Check whether the value is the null placeholder and return true null.   */  private function nullPlaceholderCheck($value)  {    if ($value === self::NULL_VALUE) {      return null;    }    return $value;  }  /**   * If there is an internal name mapping, use that.   */  private function getMappedName($key)  {    if (isset($this->internal_gapi_mappings, $this->internal_gapi_mappings[$key])) {      $key = $this->internal_gapi_mappings[$key];    }    return $key;  }  /**   * Returns true only if the array is associative.   * @param array $array   * @return bool True if the array is associative.   */  protected function isAssociativeArray($array)  {    if (!is_array($array)) {      return false;    }    $keys = array_keys($array);    foreach ($keys as $key) {      if (is_string($key)) {        return true;      }    }    return false;  }  /**   * Verify if $obj is an array.   * @throws \Google\Exception Thrown if $obj isn't an array.   * @param array $obj Items that should be validated.   * @param string $method Method expecting an array as an argument.   */  public function assertIsArray($obj, $method)  {    if ($obj && !is_array($obj)) {      throw new GoogleException(          ""Incorrect parameter type passed to $method(). Expected an array.""      );    }  }  public function offsetExists($offset)  {    return isset($this->$offset) || isset($this->modelData[$offset]);  }  public function offsetGet($offset)  {    return isset($this->$offset) ?        $this->$offset :        $this->__get($offset);  }  public function offsetSet($offset, $value)  {    if (property_exists($this, $offset)) {      $this->$offset = $value;    } else {      $this->modelData[$offset] = $value;      $this->processed[$offset] = true;    }  }  public function offsetUnset($offset)  {    unset($this->modelData[$offset]);  }  protected function keyType($key)  {    $keyType = $key . ""Type"";    // ensure keyType is a valid class    if (property_exists($this, $keyType) && class_exists($this->$keyType)) {      return $this->$keyType;    }  }  protected function dataType($key)  {    $dataType = $key . ""DataType"";    if (property_exists($this, $dataType)) {      return $this->$dataType;    }  }  public function __isset($key)  {    return isset($this->modelData[$key]);  }  public function __unset($key)  {    unset($this->modelData[$key]);  }  /**   * Convert a string to camelCase   * @param  string $value   * @return string   */  private function camelCase($value)  {    $value = ucwords(str_replace(array('-', '_'), ' ', $value));    $value = str_replace(' ', '', $value);    $value[0] = strtolower($value[0]);    return $value;  }}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1637, Handle a redirected request from master.\n\n @param ServerRequestInterface $request\n @return ResponseInterface\n,Obrađuje preusmereni zahtev od mastera,"    protected function handleRequest(ServerRequestInterface $request)    {        if ($this->getStaticDirectory()) {            $staticResponse = $this->serveStatic($request);            if ($staticResponse instanceof ResponseInterface) {                return $staticResponse;            }        }        if ($bridge = $this->getBridge()) {            try {                $response = $bridge->handle($request);            } catch (\Throwable $t) {                \error_log(                    'An exception was thrown by the bridge. Forcing restart of the worker. The exception was: ' .                    (string)$t                );                $response = new Response(500, [], 'Unexpected error');                @\ob_end_clean();                $this->shutdown();            }            $this->sendCurrentFiles();        } else {            $response = new Response(404, [], 'No Bridge defined');        }        if (\headers_sent()) {            //when a script sent headers the cgi process needs to die because the second request            //trying to send headers again will fail (headers already sent fatal). Its best to not even            //try to send headers because this break the whole approach of php-pm using php-cgi.            \error_log(                'Headers have been sent, but not redirected to client. Forcing restart of the worker. ' .                'Make sure your application does not send headers on its own.'            );            $this->shutdown();        }        $this->sendMessage($this->controller, 'stats', ['memory_usage' => \round(\memory_get_peak_usage(true)/1048576, 2)]); // Convert memory usage to MB        return $response;    }",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ClassNotFoundFatalErrorHandler_1769," ErrorHandler for classes that do not exist.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\FatalErrorHandler\\\\ClassNotFoundFatalErrorHandler instead.\\n",ErrorHandler za klase koje ne postoje,"class ClassNotFoundFatalErrorHandler implements FatalErrorHandlerInterface{    /**     * {@inheritdoc}     */    public function handleError(array $error, FatalErrorException $exception)    {        if (!preg_match('/^(Class|Interface|Trait) [\'""]([^\'""]+)[\'""] not found$/', $error['message'], $matches)) {            return null;        }        $typeName = strtolower($matches[1]);        $fullyQualifiedClassName = $matches[2];        if (false !== $namespaceSeparatorIndex = strrpos($fullyQualifiedClassName, '\\')) {            $className = substr($fullyQualifiedClassName, $namespaceSeparatorIndex + 1);            $namespacePrefix = substr($fullyQualifiedClassName, 0, $namespaceSeparatorIndex);            $message = sprintf('Attempted to load %s ""%s"" from namespace ""%s"".', $typeName, $className, $namespacePrefix);            $tail = ' for another namespace?';        } else {            $className = $fullyQualifiedClassName;            $message = sprintf('Attempted to load %s ""%s"" from the global namespace.', $typeName, $className);            $tail = '?';        }        if ($candidates = $this->getClassCandidates($className)) {            $tail = array_pop($candidates).'""?';            if ($candidates) {                $tail = ' for e.g. ""'.implode('"", ""', $candidates).'"" or ""'.$tail;            } else {                $tail = ' for ""'.$tail;            }        }        $message .= ""\nDid you forget a \""use\"" statement"".$tail;        return new ClassNotFoundException($message, $exception);    }    /**     * Tries to guess the full namespace for a given class name.     *     * By default, it looks for PSR-0 and PSR-4 classes registered via a Symfony or a Composer     * autoloader (that should cover all common cases).     *     * @param string $class A class name (without its namespace)     *     * @return array An array of possible fully qualified class names     */    private function getClassCandidates(string $class): array    {        if (!\is_array($functions = spl_autoload_functions())) {            return [];        }        // find Symfony and Composer autoloaders        $classes = [];        foreach ($functions as $function) {            if (!\is_array($function)) {                continue;            }            // get class loaders wrapped by DebugClassLoader            if ($function[0] instanceof DebugClassLoader) {                $function = $function[0]->getClassLoader();                if (!\is_array($function)) {                    continue;                }            }            if ($function[0] instanceof ComposerClassLoader || $function[0] instanceof SymfonyClassLoader) {                foreach ($function[0]->getPrefixes() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }            if ($function[0] instanceof ComposerClassLoader) {                foreach ($function[0]->getPrefixesPsr4() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }        }        return array_unique($classes);    }    private function findClassInPath(string $path, string $class, string $prefix): array    {        if (!$path = realpath($path.'/'.strtr($prefix, '\\_', '//')) ?: realpath($path.'/'.\dirname(strtr($prefix, '\\_', '//'))) ?: realpath($path)) {            return [];        }        $classes = [];        $filename = $class.'.php';        foreach (new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS), \RecursiveIteratorIterator::LEAVES_ONLY) as $file) {            if ($filename == $file->getFileName() && $class = $this->convertFileToClass($path, $file->getPathName(), $prefix)) {                $classes[] = $class;            }        }        return $classes;    }    private function convertFileToClass(string $path, string $file, string $prefix): ?string    {        $candidates = [            // namespaced class            $namespacedClass = str_replace([$path.\DIRECTORY_SEPARATOR, '.php', '/'], ['', '', '\\'], $file),            // namespaced class (with target dir)            $prefix.$namespacedClass,            // namespaced class (with target dir and separator)            $prefix.'\\'.$namespacedClass,            // PEAR class            str_replace('\\', '_', $namespacedClass),            // PEAR class (with target dir)            str_replace('\\', '_', $prefix.$namespacedClass),            // PEAR class (with target dir and separator)            str_replace('\\', '_', $prefix.'\\'.$namespacedClass),        ];        if ($prefix) {            $candidates = array_filter($candidates, function ($candidate) use ($prefix) { return 0 === strpos($candidate, $prefix); });        }        // We cannot use the autoloader here as most of them use require; but if the class        // is not found, the new autoloader call will require the file again leading to a        // ""cannot redeclare class"" error.        foreach ($candidates as $candidate) {            if ($this->classExists($candidate)) {                return $candidate;            }        }        try {            require_once $file;        } catch (\Throwable $e) {            return null;        }        foreach ($candidates as $candidate) {            if ($this->classExists($candidate)) {                return $candidate;            }        }        return null;    }    private function classExists(string $class): bool    {        return class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);    }}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_FileBag_9727, Converts uploaded files to UploadedFile instances.\n\n @param array|UploadedFile $file A (multi-dimensional) array of uploaded file information\n\n @return UploadedFile[]|UploadedFile|null A (multi-dimensional) array of UploadedFile instances\n,Pretvara otpremljene datoteke u UploadedFile instance ,"    protected function convertFileInformation($file)    {        if ($file instanceof UploadedFile) {            return $file;        }        if (\is_array($file)) {            $file = $this->fixPhpFilesArray($file);            $keys = array_keys($file);            sort($keys);            if (self::FILE_KEYS == $keys) {                if (\UPLOAD_ERR_NO_FILE == $file['error']) {                    $file = null;                } else {                    $file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['error'], false);                }            } else {                $file = array_map([$this, 'convertFileInformation'], $file);                if (array_keys($keys) === $keys) {                    $file = array_filter($file);                }            }        }        return $file;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_ParameterBag_8812, ParameterBag is a container for key/value pairs.\n\n @author Fabien Potencier <fabien@symfony.com>\n,ParameterBag je kontejner za parove ključ/vrijednost,"class ParameterBag implements \IteratorAggregate, \Countable{    /**     * Parameter storage.     */    protected $parameters;    public function __construct(array $parameters = [])    {        $this->parameters = $parameters;    }    /**     * Returns the parameters.     *     * @param string|null $key The name of the parameter to return or null to get them all     *     * @return array An array of parameters     */    public function all(/*string $key = null*/)    {        $key = \func_num_args() > 0 ? func_get_arg(0) : null;        if (null === $key) {            return $this->parameters;        }        if (!\is_array($value = $this->parameters[$key] ?? [])) {            throw new BadRequestException(sprintf('Unexpected value for parameter ""%s"": expecting ""array"", got ""%s"".', $key, get_debug_type($value)));        }        return $value;    }    /**     * Returns the parameter keys.     *     * @return array An array of parameter keys     */    public function keys()    {        return array_keys($this->parameters);    }    /**     * Replaces the current parameters by a new set.     */    public function replace(array $parameters = [])    {        $this->parameters = $parameters;    }    /**     * Adds parameters.     */    public function add(array $parameters = [])    {        $this->parameters = array_replace($this->parameters, $parameters);    }    /**     * Returns a parameter by name.     *     * @param mixed $default The default value if the parameter key does not exist     *     * @return mixed     */    public function get(string $key, $default = null)    {        return \array_key_exists($key, $this->parameters) ? $this->parameters[$key] : $default;    }    /**     * Sets a parameter by name.     *     * @param mixed $value The value     */    public function set(string $key, $value)    {        $this->parameters[$key] = $value;    }    /**     * Returns true if the parameter is defined.     *     * @return bool true if the parameter exists, false otherwise     */    public function has(string $key)    {        return \array_key_exists($key, $this->parameters);    }    /**     * Removes a parameter.     */    public function remove(string $key)    {        unset($this->parameters[$key]);    }    /**     * Returns the alphabetic characters of the parameter value.     *     * @return string The filtered value     */    public function getAlpha(string $key, string $default = '')    {        return preg_replace('/[^[:alpha:]]/', '', $this->get($key, $default));    }    /**     * Returns the alphabetic characters and digits of the parameter value.     *     * @return string The filtered value     */    public function getAlnum(string $key, string $default = '')    {        return preg_replace('/[^[:alnum:]]/', '', $this->get($key, $default));    }    /**     * Returns the digits of the parameter value.     *     * @return string The filtered value     */    public function getDigits(string $key, string $default = '')    {        // we need to remove - and + because they're allowed in the filter        return str_replace(['-', '+'], '', $this->filter($key, $default, \FILTER_SANITIZE_NUMBER_INT));    }    /**     * Returns the parameter value converted to integer.     *     * @return int The filtered value     */    public function getInt(string $key, int $default = 0)    {        return (int) $this->get($key, $default);    }    /**     * Returns the parameter value converted to boolean.     *     * @return bool The filtered value     */    public function getBoolean(string $key, bool $default = false)    {        return $this->filter($key, $default, \FILTER_VALIDATE_BOOLEAN);    }    /**     * Filter key.     *     * @param mixed $default Default = null     * @param int   $filter  FILTER_* constant     * @param mixed $options Filter options     *     * @see https://php.net/filter-var     *     * @return mixed     */    public function filter(string $key, $default = null, int $filter = \FILTER_DEFAULT, $options = [])    {        $value = $this->get($key, $default);        // Always turn $options into an array - this allows filter_var option shortcuts.        if (!\is_array($options) && $options) {            $options = ['flags' => $options];        }        // Add a convenience check for arrays.        if (\is_array($value) && !isset($options['flags'])) {            $options['flags'] = \FILTER_REQUIRE_ARRAY;        }        if ((\FILTER_CALLBACK & $filter) && !(($options['options'] ?? null) instanceof \Closure)) {            trigger_deprecation('symfony/http-foundation', '5.2', 'Not passing a Closure together with FILTER_CALLBACK to ""%s()"" is deprecated. Wrap your filter in a closure instead.', __METHOD__);            // throw new \InvalidArgumentException(sprintf('A Closure must be passed to ""%s()"" when FILTER_CALLBACK is used, ""%s"" given.', __METHOD__, get_debug_type($options['options'] ?? null)));        }        return filter_var($value, $filter, $options);    }    /**     * Returns an iterator for parameters.     *     * @return \ArrayIterator An \ArrayIterator instance     */    public function getIterator()    {        return new \ArrayIterator($this->parameters);    }    /**     * Returns the number of parameters.     *     * @return int The number of parameters     */    public function count()    {        return \count($this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
twigphp_Twig_Compiler_9130, Adds a quoted string to the compiled code.\n\n @return $this\n,Dodaje citirani niz kompajliranom kodu,"class Environment{    public const VERSION = '3.3.3-DEV';    public const VERSION_ID = 30303;    public const MAJOR_VERSION = 3;    public const MINOR_VERSION = 3;    public const RELEASE_VERSION = 3;    public const EXTRA_VERSION = 'DEV';    private $charset;    private $loader;    private $debug;    private $autoReload;    private $cache;    private $lexer;    private $parser;    private $compiler;    private $globals = [];    private $resolvedGlobals;    private $loadedTemplates;    private $strictVariables;    private $templateClassPrefix = '__TwigTemplate_';    private $originalCache;    private $extensionSet;    private $runtimeLoaders = [];    private $runtimes = [];    private $optionsHash;    /**     * Constructor.     *     * Available options:     *     *  * debug: When set to true, it automatically set ""auto_reload"" to true as     *           well (default to false).     *     *  * charset: The charset used by the templates (default to UTF-8).     *     *  * cache: An absolute path where to store the compiled templates,     *           a \Twig\Cache\CacheInterface implementation,     *           or false to disable compilation cache (default).     *     *  * auto_reload: Whether to reload the template if the original source changed.     *                 If you don't provide the auto_reload option, it will be     *                 determined automatically based on the debug value.     *     *  * strict_variables: Whether to ignore invalid variables in templates     *                      (default to false).     *     *  * autoescape: Whether to enable auto-escaping (default to html):     *                  * false: disable auto-escaping     *                  * html, js: set the autoescaping to one of the supported strategies     *                  * name: set the autoescaping strategy based on the template name extension     *                  * PHP callback: a PHP callback that returns an escaping strategy based on the template ""name""     *     *  * optimizations: A flag that indicates which optimizations to apply     *                   (default to -1 which means that all optimizations are enabled;     *                   set it to 0 to disable).     */    public function __construct(LoaderInterface $loader, $options = [])    {        $this->setLoader($loader);        $options = array_merge([            'debug' => false,            'charset' => 'UTF-8',            'strict_variables' => false,            'autoescape' => 'html',            'cache' => false,            'auto_reload' => null,            'optimizations' => -1,        ], $options);        $this->debug = (bool) $options['debug'];        $this->setCharset($options['charset'] ?? 'UTF-8');        $this->autoReload = null === $options['auto_reload'] ? $this->debug : (bool) $options['auto_reload'];        $this->strictVariables = (bool) $options['strict_variables'];        $this->setCache($options['cache']);        $this->extensionSet = new ExtensionSet();        $this->addExtension(new CoreExtension());        $this->addExtension(new EscaperExtension($options['autoescape']));        $this->addExtension(new OptimizerExtension($options['optimizations']));    }    /**     * Enables debugging mode.     */    public function enableDebug()    {        $this->debug = true;        $this->updateOptionsHash();    }    /**     * Disables debugging mode.     */    public function disableDebug()    {        $this->debug = false;        $this->updateOptionsHash();    }    /**     * Checks if debug mode is enabled.     *     * @return bool true if debug mode is enabled, false otherwise     */    public function isDebug()    {        return $this->debug;    }    /**     * Enables the auto_reload option.     */    public function enableAutoReload()    {        $this->autoReload = true;    }    /**     * Disables the auto_reload option.     */    public function disableAutoReload()    {        $this->autoReload = false;    }    /**     * Checks if the auto_reload option is enabled.     *     * @return bool true if auto_reload is enabled, false otherwise     */    public function isAutoReload()    {        return $this->autoReload;    }    /**     * Enables the strict_variables option.     */    public function enableStrictVariables()    {        $this->strictVariables = true;        $this->updateOptionsHash();    }    /**     * Disables the strict_variables option.     */    public function disableStrictVariables()    {        $this->strictVariables = false;        $this->updateOptionsHash();    }    /**     * Checks if the strict_variables option is enabled.     *     * @return bool true if strict_variables is enabled, false otherwise     */    public function isStrictVariables()    {        return $this->strictVariables;    }    /**     * Gets the current cache implementation.     *     * @param bool $original Whether to return the original cache option or the real cache instance     *     * @return CacheInterface|string|false A Twig\Cache\CacheInterface implementation,     *                                     an absolute path to the compiled templates,     *                                     or false to disable cache     */    public function getCache($original = true)    {        return $original ? $this->originalCache : $this->cache;    }    /**     * Sets the current cache implementation.     *     * @param CacheInterface|string|false $cache A Twig\Cache\CacheInterface implementation,     *                                           an absolute path to the compiled templates,     *                                           or false to disable cache     */    public function setCache($cache)    {        if (\is_string($cache)) {            $this->originalCache = $cache;            $this->cache = new FilesystemCache($cache);        } elseif (false === $cache) {            $this->originalCache = $cache;            $this->cache = new NullCache();        } elseif ($cache instanceof CacheInterface) {            $this->originalCache = $this->cache = $cache;        } else {            throw new \LogicException('Cache can only be a string, false, or a \Twig\Cache\CacheInterface implementation.');        }    }    /**     * Gets the template class associated with the given string.     *     * The generated template class is based on the following parameters:     *     *  * The cache key for the given template;     *  * The currently enabled extensions;     *  * Whether the Twig C extension is available or not;     *  * PHP version;     *  * Twig version;     *  * Options with what environment was created.     *     * @param string   $name  The name for which to calculate the template class name     * @param int|null $index The index if it is an embedded template     *     * @internal     */    public function getTemplateClass(string $name, int $index = null): string    {        $key = $this->getLoader()->getCacheKey($name).$this->optionsHash;        return $this->templateClassPrefix.hash('sha256', $key).(null === $index ? '' : '___'.$index);    }    /**     * Renders a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws SyntaxError  When an error occurred during compilation     * @throws RuntimeError When an error occurred during rendering     */    public function render($name, array $context = []): string    {        return $this->load($name)->render($context);    }    /**     * Displays a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws SyntaxError  When an error occurred during compilation     * @throws RuntimeError When an error occurred during rendering     */    public function display($name, array $context = []): void    {        $this->load($name)->display($context);    }    /**     * Loads a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws RuntimeError When a previously generated cache is corrupted     * @throws SyntaxError  When an error occurred during compilation     */    public function load($name): TemplateWrapper    {        if ($name instanceof TemplateWrapper) {            return $name;        }        return new TemplateWrapper($this, $this->loadTemplate($this->getTemplateClass($name), $name));    }    /**     * Loads a template internal representation.     *     * This method is for internal use only and should never be called     * directly.     *     * @param string $name  The template name     * @param int    $index The index if it is an embedded template     *     * @throws LoaderError  When the template cannot be found     * @throws RuntimeError When a previously generated cache is corrupted     * @throws SyntaxError  When an error occurred during compilation     *     * @internal     */    public function loadTemplate(string $cls, string $name, int $index = null): Template    {        $mainCls = $cls;        if (null !== $index) {            $cls .= '___'.$index;        }        if (isset($this->loadedTemplates[$cls])) {            return $this->loadedTemplates[$cls];        }        if (!class_exists($cls, false)) {            $key = $this->cache->generateKey($name, $mainCls);            if (!$this->isAutoReload() || $this->isTemplateFresh($name, $this->cache->getTimestamp($key))) {                $this->cache->load($key);            }            $source = null;            if (!class_exists($cls, false)) {                $source = $this->getLoader()->getSourceContext($name);                $content = $this->compileSource($source);                $this->cache->write($key, $content);                $this->cache->load($key);                if (!class_exists($mainCls, false)) {                    /* Last line of defense if either $this->bcWriteCacheFile was used,                     * $this->cache is implemented as a no-op or we have a race condition                     * where the cache was cleared between the above calls to write to and load from                     * the cache.                     */                    eval('?>'.$content);                }                if (!class_exists($cls, false)) {                    throw new RuntimeError(sprintf('Failed to load Twig template ""%s"", index ""%s"": cache might be corrupted.', $name, $index), -1, $source);                }            }        }        $this->extensionSet->initRuntime();        return $this->loadedTemplates[$cls] = new $cls($this);    }    /**     * Creates a template from source.     *     * This method should not be used as a generic way to load templates.     *     * @param string $template The template source     * @param string $name     An optional name of the template to be used in error messages     *     * @throws LoaderError When the template cannot be found     * @throws SyntaxError When an error occurred during compilation     */    public function createTemplate(string $template, string $name = null): TemplateWrapper    {        $hash = hash('sha256', $template, false);        if (null !== $name) {            $name = sprintf('%s (string template %s)', $name, $hash);        } else {            $name = sprintf('__string_template__%s', $hash);        }        $loader = new ChainLoader([            new ArrayLoader([$name => $template]),            $current = $this->getLoader(),        ]);        $this->setLoader($loader);        try {            return new TemplateWrapper($this, $this->loadTemplate($this->getTemplateClass($name), $name));        } finally {            $this->setLoader($current);        }    }    /**     * Returns true if the template is still fresh.     *     * Besides checking the loader for freshness information,     * this method also checks if the enabled extensions have     * not changed.     *     * @param int $time The last modification time of the cached template     */    public function isTemplateFresh(string $name, int $time): bool    {        return $this->extensionSet->getLastModified() <= $time && $this->getLoader()->isFresh($name, $time);    }    /**     * Tries to load a template consecutively from an array.     *     * Similar to load() but it also accepts instances of \Twig\Template and     * \Twig\TemplateWrapper, and an array of templates where each is tried to be loaded.     *     * @param string|TemplateWrapper|array $names A template or an array of templates to try consecutively     *     * @throws LoaderError When none of the templates can be found     * @throws SyntaxError When an error occurred during compilation     */    public function resolveTemplate($names): TemplateWrapper    {        if (!\is_array($names)) {            return $this->load($names);        }        foreach ($names as $name) {            try {                return $this->load($name);            } catch (LoaderError $e) {            }        }        throw new LoaderError(sprintf('Unable to find one of the following templates: ""%s"".', implode('"", ""', $names)));    }    public function setLexer(Lexer $lexer)    {        $this->lexer = $lexer;    }    /**     * @throws SyntaxError When the code is syntactically wrong     */    public function tokenize(Source $source): TokenStream    {        if (null === $this->lexer) {            $this->lexer = new Lexer($this);        }        return $this->lexer->tokenize($source);    }    public function setParser(Parser $parser)    {        $this->parser = $parser;    }    /**     * Converts a token stream to a node tree.     *     * @throws SyntaxError When the token stream is syntactically or semantically wrong     */    public function parse(TokenStream $stream): ModuleNode    {        if (null === $this->parser) {            $this->parser = new Parser($this);        }        return $this->parser->parse($stream);    }    public function setCompiler(Compiler $compiler)    {        $this->compiler = $compiler;    }    /**     * Compiles a node and returns the PHP code.     */    public function compile(Node $node): string    {        if (null === $this->compiler) {            $this->compiler = new Compiler($this);        }        return $this->compiler->compile($node)->getSource();    }    /**     * Compiles a template source code.     *     * @throws SyntaxError When there was an error during tokenizing, parsing or compiling     */    public function compileSource(Source $source): string    {        try {            return $this->compile($this->parse($this->tokenize($source)));        } catch (Error $e) {            $e->setSourceContext($source);            throw $e;        } catch (\Exception $e) {            throw new SyntaxError(sprintf('An exception has been thrown during the compilation of a template (""%s"").', $e->getMessage()), -1, $source, $e);        }    }    public function setLoader(LoaderInterface $loader)    {        $this->loader = $loader;    }    public function getLoader(): LoaderInterface    {        return $this->loader;    }    public function setCharset(string $charset)    {        if ('UTF8' === $charset = null === $charset ? null : strtoupper($charset)) {            // iconv on Windows requires ""UTF-8"" instead of ""UTF8""            $charset = 'UTF-8';        }        $this->charset = $charset;    }    public function getCharset(): string    {        return $this->charset;    }    public function hasExtension(string $class): bool    {        return $this->extensionSet->hasExtension($class);    }    public function addRuntimeLoader(RuntimeLoaderInterface $loader)    {        $this->runtimeLoaders[] = $loader;    }    public function getExtension(string $class): ExtensionInterface    {        return $this->extensionSet->getExtension($class);    }    /**     * Returns the runtime implementation of a Twig element (filter/function/tag/test).     *     * @param string $class A runtime class name     *     * @return object The runtime implementation     *     * @throws RuntimeError When the template cannot be found     */    public function getRuntime(string $class)    {        if (isset($this->runtimes[$class])) {            return $this->runtimes[$class];        }        foreach ($this->runtimeLoaders as $loader) {            if (null !== $runtime = $loader->load($class)) {                return $this->runtimes[$class] = $runtime;            }        }        throw new RuntimeError(sprintf('Unable to load the ""%s"" runtime.', $class));    }    public function addExtension(ExtensionInterface $extension)    {        $this->extensionSet->addExtension($extension);        $this->updateOptionsHash();    }    /**     * @param ExtensionInterface[] $extensions An array of extensions     */    public function setExtensions(array $extensions)    {        $this->extensionSet->setExtensions($extensions);        $this->updateOptionsHash();    }    /**     * @return ExtensionInterface[] An array of extensions (keys are for internal usage only and should not be relied on)     */    public function getExtensions(): array    {        return $this->extensionSet->getExtensions();    }    public function addTokenParser(TokenParserInterface $parser)    {        $this->extensionSet->addTokenParser($parser);    }    /**     * @return TokenParserInterface[]     *     * @internal     */    public function getTokenParsers(): array    {        return $this->extensionSet->getTokenParsers();    }    /**     * @internal     */    public function getTokenParser(string $name): ?TokenParserInterface    {        return $this->extensionSet->getTokenParser($name);    }    public function registerUndefinedTokenParserCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedTokenParserCallback($callable);    }    public function addNodeVisitor(NodeVisitorInterface $visitor)    {        $this->extensionSet->addNodeVisitor($visitor);    }    /**     * @return NodeVisitorInterface[]     *     * @internal     */    public function getNodeVisitors(): array    {        return $this->extensionSet->getNodeVisitors();    }    public function addFilter(TwigFilter $filter)    {        $this->extensionSet->addFilter($filter);    }    /**     * @internal     */    public function getFilter(string $name): ?TwigFilter    {        return $this->extensionSet->getFilter($name);    }    public function registerUndefinedFilterCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedFilterCallback($callable);    }    /**     * Gets the registered Filters.     *     * Be warned that this method cannot return filters defined with registerUndefinedFilterCallback.     *     * @return TwigFilter[]     *     * @see registerUndefinedFilterCallback     *     * @internal     */    public function getFilters(): array    {        return $this->extensionSet->getFilters();    }    public function addTest(TwigTest $test)    {        $this->extensionSet->addTest($test);    }    /**     * @return TwigTest[]     *     * @internal     */    public function getTests(): array    {        return $this->extensionSet->getTests();    }    /**     * @internal     */    public function getTest(string $name): ?TwigTest    {        return $this->extensionSet->getTest($name);    }    public function addFunction(TwigFunction $function)    {        $this->extensionSet->addFunction($function);    }    /**     * @internal     */    public function getFunction(string $name): ?TwigFunction    {        return $this->extensionSet->getFunction($name);    }    public function registerUndefinedFunctionCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedFunctionCallback($callable);    }    /**     * Gets registered functions.     *     * Be warned that this method cannot return functions defined with registerUndefinedFunctionCallback.     *     * @return TwigFunction[]     *     * @see registerUndefinedFunctionCallback     *     * @internal     */    public function getFunctions(): array    {        return $this->extensionSet->getFunctions();    }    /**     * Registers a Global.     *     * New globals can be added before compiling or rendering a template;     * but after, you can only update existing globals.     *     * @param mixed $value The global value     */    public function addGlobal(string $name, $value)    {        if ($this->extensionSet->isInitialized() && !\array_key_exists($name, $this->getGlobals())) {            throw new \LogicException(sprintf('Unable to add global ""%s"" as the runtime or the extensions have already been initialized.', $name));        }        if (null !== $this->resolvedGlobals) {            $this->resolvedGlobals[$name] = $value;        } else {            $this->globals[$name] = $value;        }    }    /**     * @internal     */    public function getGlobals(): array    {        if ($this->extensionSet->isInitialized()) {            if (null === $this->resolvedGlobals) {                $this->resolvedGlobals = array_merge($this->extensionSet->getGlobals(), $this->globals);            }            return $this->resolvedGlobals;        }        return array_merge($this->extensionSet->getGlobals(), $this->globals);    }    public function mergeGlobals(array $context): array    {        // we don't use array_merge as the context being generally        // bigger than globals, this code is faster.        foreach ($this->getGlobals() as $key => $value) {            if (!\array_key_exists($key, $context)) {                $context[$key] = $value;            }        }        return $context;    }    /**     * @internal     */    public function getUnaryOperators(): array    {        return $this->extensionSet->getUnaryOperators();    }    /**     * @internal     */    public function getBinaryOperators(): array    {        return $this->extensionSet->getBinaryOperators();    }    private function updateOptionsHash(): void    {        $this->optionsHash = implode(':', [            $this->extensionSet->getSignature(),            \PHP_MAJOR_VERSION,            \PHP_MINOR_VERSION,            self::VERSION,            (int) $this->debug,            (int) $this->strictVariables,        ]);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1197, Does the queue have an item with the given priority?\n\n @param  int $priority\n @return bool\n,Da li red ima stavku sa datim prioritetom?,    public function hasPriority($priority)    {        foreach ($this->items as $item) {            if ($item['priority'] === $priority) {                return true;            }        }        return false;    },0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_promises_FulfilledPromise_710, A promise that has been fulfilled.\\\\\\\\n\\\\\\\\n Thenning off of this promise will invoke the onFulfilled callback\\\\\\\\n immediately and ignore other callbacks.\\\\\\\\n,Obećanje koje je ispunjeno. Isključivanje ovog obećanja odmah će pozvati onFulfished povratni poziv i zanemariti druge povratne pozive,"class FulfilledPromise implements PromiseInterface{    private $value;    public function __construct($value)    {        if (is_object($value) && method_exists($value, 'then')) {            throw new \InvalidArgumentException(                'You cannot create a FulfilledPromise with a promise.'            );        }        $this->value = $value;    }    public function then(        callable $onFulfilled = null,        callable $onRejected = null    ) {        // Return itself if there is no onFulfilled function.        if (!$onFulfilled) {            return $this;        }        $queue = Utils::queue();        $p = new Promise([$queue, 'run']);        $value = $this->value;        $queue->add(static function () use ($p, $value, $onFulfilled) {            if (Is::pending($p)) {                try {                    $p->resolve($onFulfilled($value));                } catch (\Throwable $e) {                    $p->reject($e);                } catch (\Exception $e) {                    $p->reject($e);                }            }        });        return $p;    }    public function otherwise(callable $onRejected)    {        return $this->then(null, $onRejected);    }    public function wait($unwrap = true, $defaultDelivery = null)    {        return $unwrap ? $this->value : null;    }    public function getState()    {        return self::FULFILLED;    }    public function resolve($value)    {        if ($value !== $this->value) {            throw new \LogicException(""Cannot resolve a fulfilled promise"");        }    }    public function reject($reason)    {        throw new \LogicException(""Cannot reject a fulfilled promise"");    }    public function cancel()    {        // pass    }}",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laravel_laravel_2019_08_19_000000_create_failed_jobs_table_13, Run the migrations.\\n\\n @return void\\n,Pokretanje migracija,"    public function up()    {        Schema::create('failed_jobs', function (Blueprint $table) {            $table->id();            $table->string('uuid')->unique();            $table->text('connection');            $table->text('queue');            $table->longText('payload');            $table->longText('exception');            $table->timestamp('failed_at')->useCurrent();        });    }",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_AbstractDumper_9251, Abstract mechanism for dumping a Data object.\n\n @author Nicolas Grekas <p@tchwork.com>\n,Apstraktni mehanizam za odbacivanje objekta podataka,"class AmqpCaster{    private const FLAGS = [        \AMQP_DURABLE => 'AMQP_DURABLE',        \AMQP_PASSIVE => 'AMQP_PASSIVE',        \AMQP_EXCLUSIVE => 'AMQP_EXCLUSIVE',        \AMQP_AUTODELETE => 'AMQP_AUTODELETE',        \AMQP_INTERNAL => 'AMQP_INTERNAL',        \AMQP_NOLOCAL => 'AMQP_NOLOCAL',        \AMQP_AUTOACK => 'AMQP_AUTOACK',        \AMQP_IFEMPTY => 'AMQP_IFEMPTY',        \AMQP_IFUNUSED => 'AMQP_IFUNUSED',        \AMQP_MANDATORY => 'AMQP_MANDATORY',        \AMQP_IMMEDIATE => 'AMQP_IMMEDIATE',        \AMQP_MULTIPLE => 'AMQP_MULTIPLE',        \AMQP_NOWAIT => 'AMQP_NOWAIT',        \AMQP_REQUEUE => 'AMQP_REQUEUE',    ];    private const EXCHANGE_TYPES = [        \AMQP_EX_TYPE_DIRECT => 'AMQP_EX_TYPE_DIRECT',        \AMQP_EX_TYPE_FANOUT => 'AMQP_EX_TYPE_FANOUT',        \AMQP_EX_TYPE_TOPIC => 'AMQP_EX_TYPE_TOPIC',        \AMQP_EX_TYPE_HEADERS => 'AMQP_EX_TYPE_HEADERS',    ];    public static function castConnection(\AMQPConnection $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'is_connected' => $c->isConnected(),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPConnection\x00login""])) {            return $a;        }        // BC layer in the amqp lib        if (method_exists($c, 'getReadTimeout')) {            $timeout = $c->getReadTimeout();        } else {            $timeout = $c->getTimeout();        }        $a += [            $prefix.'is_connected' => $c->isConnected(),            $prefix.'login' => $c->getLogin(),            $prefix.'password' => $c->getPassword(),            $prefix.'host' => $c->getHost(),            $prefix.'vhost' => $c->getVhost(),            $prefix.'port' => $c->getPort(),            $prefix.'read_timeout' => $timeout,        ];        return $a;    }    public static function castChannel(\AMQPChannel $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'is_connected' => $c->isConnected(),            $prefix.'channel_id' => $c->getChannelId(),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPChannel\x00connection""])) {            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'prefetch_size' => $c->getPrefetchSize(),            $prefix.'prefetch_count' => $c->getPrefetchCount(),        ];        return $a;    }    public static function castQueue(\AMQPQueue $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'flags' => self::extractFlags($c->getFlags()),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPQueue\x00name""])) {            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'channel' => $c->getChannel(),            $prefix.'name' => $c->getName(),            $prefix.'arguments' => $c->getArguments(),        ];        return $a;    }    public static function castExchange(\AMQPExchange $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'flags' => self::extractFlags($c->getFlags()),        ];        $type = isset(self::EXCHANGE_TYPES[$c->getType()]) ? new ConstStub(self::EXCHANGE_TYPES[$c->getType()], $c->getType()) : $c->getType();        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPExchange\x00name""])) {            $a[""\x00AMQPExchange\x00type""] = $type;            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'channel' => $c->getChannel(),            $prefix.'name' => $c->getName(),            $prefix.'type' => $type,            $prefix.'arguments' => $c->getArguments(),        ];        return $a;    }    public static function castEnvelope(\AMQPEnvelope $c, array $a, Stub $stub, bool $isNested, int $filter = 0)    {        $prefix = Caster::PREFIX_VIRTUAL;        $deliveryMode = new ConstStub($c->getDeliveryMode().(2 === $c->getDeliveryMode() ? ' (persistent)' : ' (non-persistent)'), $c->getDeliveryMode());        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPEnvelope\x00body""])) {            $a[""\0AMQPEnvelope\0delivery_mode""] = $deliveryMode;            return $a;        }        if (!($filter & Caster::EXCLUDE_VERBOSE)) {            $a += [$prefix.'body' => $c->getBody()];        }        $a += [            $prefix.'delivery_tag' => $c->getDeliveryTag(),            $prefix.'is_redelivery' => $c->isRedelivery(),            $prefix.'exchange_name' => $c->getExchangeName(),            $prefix.'routing_key' => $c->getRoutingKey(),            $prefix.'content_type' => $c->getContentType(),            $prefix.'content_encoding' => $c->getContentEncoding(),            $prefix.'headers' => $c->getHeaders(),            $prefix.'delivery_mode' => $deliveryMode,            $prefix.'priority' => $c->getPriority(),            $prefix.'correlation_id' => $c->getCorrelationId(),            $prefix.'reply_to' => $c->getReplyTo(),            $prefix.'expiration' => $c->getExpiration(),            $prefix.'message_id' => $c->getMessageId(),            $prefix.'timestamp' => $c->getTimeStamp(),            $prefix.'type' => $c->getType(),            $prefix.'user_id' => $c->getUserId(),            $prefix.'app_id' => $c->getAppId(),        ];        return $a;    }    private static function extractFlags(int $flags): ConstStub    {        $flagsArray = [];        foreach (self::FLAGS as $value => $name) {            if ($flags & $value) {                $flagsArray[] = $name;            }        }        if (!$flagsArray) {            $flagsArray = ['AMQP_NOPARAM'];        }        return new ConstStub(implode('|', $flagsArray), $flags);    }}",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7002, Write statistics data to disk.\n\n @return void\n,Zapisuje statističke podatke na disk,"    protected static function writeConnectionsStatisticsToStatusFile()    {        // For master process.        if (static::$_masterPid === \posix_getpid()) {            \file_put_contents(static::$_statisticsFile, ""--------------------------------------------------------------------- WORKERMAN CONNECTION STATUS --------------------------------------------------------------------------------\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile, ""PID      Worker          CID       Trans   Protocol        ipv4   ipv6   Recv-Q       Send-Q       Bytes-R      Bytes-W       Status         Local Address          Foreign Address\n"", \FILE_APPEND);            \chmod(static::$_statisticsFile, 0722);            foreach (static::getAllWorkerPids() as $worker_pid) {                \posix_kill($worker_pid, \SIGIO);            }            return;        }        // For child processes.        $bytes_format = function($bytes)        {            if($bytes > 1024*1024*1024*1024) {                return round($bytes/(1024*1024*1024*1024), 1).""TB"";            }            if($bytes > 1024*1024*1024) {                return round($bytes/(1024*1024*1024), 1).""GB"";            }            if($bytes > 1024*1024) {                return round($bytes/(1024*1024), 1).""MB"";            }            if($bytes > 1024) {                return round($bytes/(1024), 1).""KB"";            }            return $bytes.""B"";        };        $pid = \posix_getpid();        $str = '';        \reset(static::$_workers);        $current_worker = current(static::$_workers);        $default_worker_name = $current_worker->name;        /** @var \Workerman\Worker $worker */        foreach(TcpConnection::$connections as $connection) {            /** @var \Workerman\Connection\TcpConnection $connection */            $transport      = $connection->transport;            $ipv4           = $connection->isIpV4() ? ' 1' : ' 0';            $ipv6           = $connection->isIpV6() ? ' 1' : ' 0';            $recv_q         = $bytes_format($connection->getRecvBufferQueueSize());            $send_q         = $bytes_format($connection->getSendBufferQueueSize());            $local_address  = \trim($connection->getLocalAddress());            $remote_address = \trim($connection->getRemoteAddress());            $state          = $connection->getStatus(false);            $bytes_read     = $bytes_format($connection->bytesRead);            $bytes_written  = $bytes_format($connection->bytesWritten);            $id             = $connection->id;            $protocol       = $connection->protocol ? $connection->protocol : $connection->transport;            $pos            = \strrpos($protocol, '\\');            if ($pos) {                $protocol = \substr($protocol, $pos+1);            }            if (\strlen($protocol) > 15) {                $protocol = \substr($protocol, 0, 13) . '..';            }            $worker_name = isset($connection->worker) ? $connection->worker->name : $default_worker_name;            if (\strlen($worker_name) > 14) {                $worker_name = \substr($worker_name, 0, 12) . '..';            }            $str .= \str_pad($pid, 9) . \str_pad($worker_name, 16) .  \str_pad($id, 10) . \str_pad($transport, 8)                . \str_pad($protocol, 16) . \str_pad($ipv4, 7) . \str_pad($ipv6, 7) . \str_pad($recv_q, 13)                . \str_pad($send_q, 13) . \str_pad($bytes_read, 13) . \str_pad($bytes_written, 13) . ' '                . \str_pad($state, 14) . ' ' . \str_pad($local_address, 22) . ' ' . \str_pad($remote_address, 22) .""\n"";        }        if ($str) {            \file_put_contents(static::$_statisticsFile, $str, \FILE_APPEND);        }    }",0,0,2,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7372, check if child processes is really running\n,Proverite da li se podređeni procesi zaista izvode,"    protected static function writeConnectionsStatisticsToStatusFile()    {        // For master process.        if (static::$_masterPid === \posix_getpid()) {            \file_put_contents(static::$_statisticsFile, ""--------------------------------------------------------------------- WORKERMAN CONNECTION STATUS --------------------------------------------------------------------------------\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile, ""PID      Worker          CID       Trans   Protocol        ipv4   ipv6   Recv-Q       Send-Q       Bytes-R      Bytes-W       Status         Local Address          Foreign Address\n"", \FILE_APPEND);            \chmod(static::$_statisticsFile, 0722);            foreach (static::getAllWorkerPids() as $worker_pid) {                \posix_kill($worker_pid, \SIGIO);            }            return;        }        // For child processes.        $bytes_format = function($bytes)        {            if($bytes > 1024*1024*1024*1024) {                return round($bytes/(1024*1024*1024*1024), 1).""TB"";            }            if($bytes > 1024*1024*1024) {                return round($bytes/(1024*1024*1024), 1).""GB"";            }            if($bytes > 1024*1024) {                return round($bytes/(1024*1024), 1).""MB"";            }            if($bytes > 1024) {                return round($bytes/(1024), 1).""KB"";            }            return $bytes.""B"";        };        $pid = \posix_getpid();        $str = '';        \reset(static::$_workers);        $current_worker = current(static::$_workers);        $default_worker_name = $current_worker->name;        /** @var \Workerman\Worker $worker */        foreach(TcpConnection::$connections as $connection) {            /** @var \Workerman\Connection\TcpConnection $connection */            $transport      = $connection->transport;            $ipv4           = $connection->isIpV4() ? ' 1' : ' 0';            $ipv6           = $connection->isIpV6() ? ' 1' : ' 0';            $recv_q         = $bytes_format($connection->getRecvBufferQueueSize());            $send_q         = $bytes_format($connection->getSendBufferQueueSize());            $local_address  = \trim($connection->getLocalAddress());            $remote_address = \trim($connection->getRemoteAddress());            $state          = $connection->getStatus(false);            $bytes_read     = $bytes_format($connection->bytesRead);            $bytes_written  = $bytes_format($connection->bytesWritten);            $id             = $connection->id;            $protocol       = $connection->protocol ? $connection->protocol : $connection->transport;            $pos            = \strrpos($protocol, '\\');            if ($pos) {                $protocol = \substr($protocol, $pos+1);            }            if (\strlen($protocol) > 15) {                $protocol = \substr($protocol, 0, 13) . '..';            }            $worker_name = isset($connection->worker) ? $connection->worker->name : $default_worker_name;            if (\strlen($worker_name) > 14) {                $worker_name = \substr($worker_name, 0, 12) . '..';            }            $str .= \str_pad($pid, 9) . \str_pad($worker_name, 16) .  \str_pad($id, 10) . \str_pad($transport, 8)                . \str_pad($protocol, 16) . \str_pad($ipv4, 7) . \str_pad($ipv6, 7) . \str_pad($recv_q, 13)                . \str_pad($send_q, 13) . \str_pad($bytes_read, 13) . \str_pad($bytes_written, 13) . ' '                . \str_pad($state, 14) . ' ' . \str_pad($local_address, 22) . ' ' . \str_pad($remote_address, 22) .""\n"";        }        if ($str) {            \file_put_contents(static::$_statisticsFile, $str, \FILE_APPEND);        }    }",0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7771, Stop current worker instance.\n\n @return void\n,Zaustavite trenutnu radnu instancu,"class Worker{    /**     * Version.     *     * @var string     */    const VERSION = '4.0.19';    /**     * Status starting.     *     * @var int     */    const STATUS_STARTING = 1;    /**     * Status running.     *     * @var int     */    const STATUS_RUNNING = 2;    /**     * Status shutdown.     *     * @var int     */    const STATUS_SHUTDOWN = 4;    /**     * Status reloading.     *     * @var int     */    const STATUS_RELOADING = 8;    /**     * After sending the restart command to the child process KILL_WORKER_TIMER_TIME seconds,     * if the process is still living then forced to kill.     *     * @var int     */    const KILL_WORKER_TIMER_TIME = 2;    /**     * Default backlog. Backlog is the maximum length of the queue of pending connections.     *     * @var int     */    const DEFAULT_BACKLOG = 102400;    /**     * Max udp package size.     *     * @var int     */    const MAX_UDP_PACKAGE_SIZE = 65535;    /**     * The safe distance for columns adjacent     *     * @var int     */    const UI_SAFE_LENGTH = 4;    /**     * Worker id.     *     * @var int     */    public $id = 0;    /**     * Name of the worker processes.     *     * @var string     */    public $name = 'none';    /**     * Number of worker processes.     *     * @var int     */    public $count = 1;    /**     * Unix user of processes, needs appropriate privileges (usually root).     *     * @var string     */    public $user = '';    /**     * Unix group of processes, needs appropriate privileges (usually root).     *     * @var string     */    public $group = '';    /**     * reloadable.     *     * @var bool     */    public $reloadable = true;    /**     * reuse port.     *     * @var bool     */    public $reusePort = false;    /**     * Emitted when worker processes start.     *     * @var callable     */    public $onWorkerStart = null;    /**     * Emitted when a socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when data is received.     *     * @var callable     */    public $onMessage = null;    /**     * Emitted when the other end of the socket sends a FIN packet.     *     * @var callable     */    public $onClose = null;    /**     * Emitted when an error occurs with connection.     *     * @var callable     */    public $onError = null;    /**     * Emitted when the send buffer becomes full.     *     * @var callable     */    public $onBufferFull = null;    /**     * Emitted when the send buffer becomes empty.     *     * @var callable     */    public $onBufferDrain = null;    /**     * Emitted when worker processes stoped.     *     * @var callable     */    public $onWorkerStop = null;    /**     * Emitted when worker processes get reload signal.     *     * @var callable     */    public $onWorkerReload = null;    /**     * Transport layer protocol.     *     * @var string     */    public $transport = 'tcp';    /**     * Store all connections of clients.     *     * @var array     */    public $connections = array();    /**     * Application layer protocol.     *     * @var string     */    public $protocol = null;    /**     * Root path for autoload.     *     * @var string     */    protected $_autoloadRootPath = '';    /**     * Pause accept new connections or not.     *     * @var bool     */    protected $_pauseAccept = true;    /**     * Is worker stopping ?     * @var bool     */    public $stopping = false;    /**     * Daemonize.     *     * @var bool     */    public static $daemonize = false;    /**     * Stdout file.     *     * @var string     */    public static $stdoutFile = '/dev/null';    /**     * The file to store master process PID.     *     * @var string     */    public static $pidFile = '';    /**     * Log file.     *     * @var mixed     */    public static $logFile = '';    /**     * Global event loop.     *     * @var EventInterface     */    public static $globalEvent = null;    /**     * Emitted when the master process get reload signal.     *     * @var callable     */    public static $onMasterReload = null;    /**     * Emitted when the master process terminated.     *     * @var callable     */    public static $onMasterStop = null;    /**     * EventLoopClass     *     * @var string     */    public static $eventLoopClass = '';    /**     * Process title     *     * @var string     */    public static $processTitle = 'WorkerMan';    /**     * The PID of master process.     *     * @var int     */    protected static $_masterPid = 0;    /**     * Listening socket.     *     * @var resource     */    protected $_mainSocket = null;    /**     * Socket name. The format is like this http://0.0.0.0:80 .     *     * @var string     */    protected $_socketName = '';    /** parse from _socketName avoid parse again in master or worker     * LocalSocket The format is like tcp://0.0.0.0:8080     * @var string     */    protected $_localSocket=null;    /**     * Context of socket.     *     * @var resource     */    protected $_context = null;    /**     * All worker instances.     *     * @var Worker[]     */    protected static $_workers = array();    /**     * All worker processes pid.     * The format is like this [worker_id=>[pid=>pid, pid=>pid, ..], ..]     *     * @var array     */    protected static $_pidMap = array();    /**     * All worker processes waiting for restart.     * The format is like this [pid=>pid, pid=>pid].     *     * @var array     */    protected static $_pidsToRestart = array();    /**     * Mapping from PID to worker process ID.     * The format is like this [worker_id=>[0=>$pid, 1=>$pid, ..], ..].     *     * @var array     */    protected static $_idMap = array();    /**     * Current status.     *     * @var int     */    protected static $_status = self::STATUS_STARTING;    /**     * Maximum length of the worker names.     *     * @var int     */    protected static $_maxWorkerNameLength = 12;    /**     * Maximum length of the socket names.     *     * @var int     */    protected static $_maxSocketNameLength = 12;    /**     * Maximum length of the process user names.     *     * @var int     */    protected static $_maxUserNameLength = 12;    /**     * Maximum length of the Proto names.     *     * @var int     */    protected static $_maxProtoNameLength = 4;    /**     * Maximum length of the Processes names.     *     * @var int     */    protected static $_maxProcessesNameLength = 9;    /**     * Maximum length of the Status names.     *     * @var int     */    protected static $_maxStatusNameLength = 1;    /**     * The file to store status info of current worker process.     *     * @var string     */    protected static $_statisticsFile = '';    /**     * Start file.     *     * @var string     */    protected static $_startFile = '';    /**     * OS.     *     * @var string     */    protected static $_OS = \OS_TYPE_LINUX;    /**     * Processes for windows.     *     * @var array     */    protected static $_processForWindows = array();    /**     * Status info of current worker process.     *     * @var array     */    protected static $_globalStatistics = array(        'start_timestamp'  => 0,        'worker_exit_info' => array()    );    /**     * Available event loops.     *     * @var array     */    protected static $_availableEventLoops = array(        'event'    => '\Workerman\Events\Event',        'libevent' => '\Workerman\Events\Libevent'    );    /**     * PHP built-in protocols.     *     * @var array     */    protected static $_builtinTransports = array(        'tcp'   => 'tcp',        'udp'   => 'udp',        'unix'  => 'unix',        'ssl'   => 'tcp'    );    /**     * PHP built-in error types.     *     * @var array     */    protected static $_errorType = array(        \E_ERROR             => 'E_ERROR',             // 1        \E_WARNING           => 'E_WARNING',           // 2        \E_PARSE             => 'E_PARSE',             // 4        \E_NOTICE            => 'E_NOTICE',            // 8        \E_CORE_ERROR        => 'E_CORE_ERROR',        // 16        \E_CORE_WARNING      => 'E_CORE_WARNING',      // 32        \E_COMPILE_ERROR     => 'E_COMPILE_ERROR',     // 64        \E_COMPILE_WARNING   => 'E_COMPILE_WARNING',   // 128        \E_USER_ERROR        => 'E_USER_ERROR',        // 256        \E_USER_WARNING      => 'E_USER_WARNING',      // 512        \E_USER_NOTICE       => 'E_USER_NOTICE',       // 1024        \E_STRICT            => 'E_STRICT',            // 2048        \E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR', // 4096        \E_DEPRECATED        => 'E_DEPRECATED',        // 8192        \E_USER_DEPRECATED   => 'E_USER_DEPRECATED'   // 16384    );    /**     * Graceful stop or not.     *     * @var bool     */    protected static $_gracefulStop = false;    /**     * Standard output stream     * @var resource     */    protected static $_outputStream = null;    /**     * If $outputStream support decorated     * @var bool     */    protected static $_outputDecorated = null;    /**     * Run all worker instances.     *     * @return void     */    public static function runAll()    {        static::checkSapiEnv();        static::init();        static::parseCommand();        static::daemonize();        static::initWorkers();        static::installSignal();        static::saveMasterPid();        static::displayUI();        static::forkWorkers();        static::resetStd();        static::monitorWorkers();    }    /**     * Check sapi.     *     * @return void     */    protected static function checkSapiEnv()    {        // Only for cli.        if (\PHP_SAPI !== 'cli') {            exit(""Only run in command line mode \n"");        }        if (\DIRECTORY_SEPARATOR === '\\') {            self::$_OS = \OS_TYPE_WINDOWS;        }    }    /**     * Init.     *     * @return void     */    protected static function init()    {        \set_error_handler(function($code, $msg, $file, $line){            Worker::safeEcho(""$msg in file $file on line $line\n"");        });        // Start file.        $backtrace        = \debug_backtrace();        static::$_startFile = $backtrace[\count($backtrace) - 1]['file'];        $unique_prefix = \str_replace('/', '_', static::$_startFile);        // Pid file.        if (empty(static::$pidFile)) {            static::$pidFile = __DIR__ . ""/../$unique_prefix.pid"";        }        // Log file.        if (empty(static::$logFile)) {            static::$logFile = __DIR__ . '/../workerman.log';        }        $log_file = (string)static::$logFile;        if (!\is_file($log_file)) {            \touch($log_file);            \chmod($log_file, 0622);        }        // State.        static::$_status = static::STATUS_STARTING;        // For statistics.        static::$_globalStatistics['start_timestamp'] = \time();        // Process title.        static::setProcessTitle(static::$processTitle . ': master process  start_file=' . static::$_startFile);        // Init data for worker id.        static::initId();        // Timer init.        Timer::init();    }    /**     * Lock.     *     * @return void     */    protected static function lock()    {        $fd = \fopen(static::$_startFile, 'r');        if ($fd && !flock($fd, LOCK_EX)) {            static::log('Workerman['.static::$_startFile.'] already running.');            exit;        }    }    /**     * Unlock.     *     * @return void     */    protected static function unlock()    {        $fd = \fopen(static::$_startFile, 'r');        $fd && flock($fd, \LOCK_UN);    }    /**     * Init All worker instances.     *     * @return void     */    protected static function initWorkers()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        static::$_statisticsFile = __DIR__ . '/../workerman-' .posix_getpid().'.status';        foreach (static::$_workers as $worker) {            // Worker name.            if (empty($worker->name)) {                $worker->name = 'none';            }            // Get unix user of the worker process.            if (empty($worker->user)) {                $worker->user = static::getCurrentUser();            } else {                if (\posix_getuid() !== 0 && $worker->user !== static::getCurrentUser()) {                    static::log('Warning: You must have the root privileges to change uid and gid.');                }            }            // Socket name.            $worker->socket = $worker->getSocketName();            // Status name.            $worker->status = '<g> [OK] </g>';            // Get column mapping for UI            foreach(static::getUiColumns() as $column_name => $prop){                !isset($worker->{$prop}) && $worker->{$prop} = 'NNNN';                $prop_length = \strlen($worker->{$prop});                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                static::$$key = \max(static::$$key, $prop_length);            }            // Listen.            if (!$worker->reusePort) {                $worker->listen();            }        }    }    /**     * Reload all worker instances.     *     * @return void     */    public static function reloadAllWorkers()    {        static::init();        static::initWorkers();        static::displayUI();        static::$_status = static::STATUS_RELOADING;    }    /**     * Get all worker instances.     *     * @return array     */    public static function getAllWorkers()    {        return static::$_workers;    }    /**     * Get global event-loop instance.     *     * @return EventInterface     */    public static function getEventLoop()    {        return static::$globalEvent;    }    /**     * Get main socket resource     * @return resource     */    public function getMainSocket(){        return $this->_mainSocket;    }    /**     * Init idMap.     * return void     */    protected static function initId()    {        foreach (static::$_workers as $worker_id => $worker) {            $new_id_map = array();            $worker->count = $worker->count < 1 ? 1 : $worker->count;            for($key = 0; $key < $worker->count; $key++) {                $new_id_map[$key] = isset(static::$_idMap[$worker_id][$key]) ? static::$_idMap[$worker_id][$key] : 0;            }            static::$_idMap[$worker_id] = $new_id_map;        }    }    /**     * Get unix user of current porcess.     *     * @return string     */    protected static function getCurrentUser()    {        $user_info = \posix_getpwuid(\posix_getuid());        return $user_info['name'];    }    /**     * Display staring UI.     *     * @return void     */    protected static function displayUI()    {        global $argv;        if (\in_array('-q', $argv)) {            return;        }        if (static::$_OS !== \OS_TYPE_LINUX) {            static::safeEcho(""----------------------- WORKERMAN -----------------------------\r\n"");            static::safeEcho('Workerman version:'. static::VERSION. '          PHP version:'. \PHP_VERSION. ""\r\n"");            static::safeEcho(""------------------------ WORKERS -------------------------------\r\n"");            static::safeEcho(""worker               listen                              processes status\r\n"");            return;        }        //show version        $line_version = 'Workerman version:' . static::VERSION . \str_pad('PHP version:', 22, ' ', \STR_PAD_LEFT) . \PHP_VERSION . \PHP_EOL;        !\defined('LINE_VERSIOIN_LENGTH') && \define('LINE_VERSIOIN_LENGTH', \strlen($line_version));        $total_length = static::getSingleLineTotalLength();        $line_one = '<n>' . \str_pad('<w> WORKERMAN </w>', $total_length + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . '</n>'. \PHP_EOL;        $line_two = \str_pad('<w> WORKERS </w>' , $total_length  + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . \PHP_EOL;        static::safeEcho($line_one . $line_version . $line_two);        //Show title        $title = '';        foreach(static::getUiColumns() as $column_name => $prop){            $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';            //just keep compatible with listen name            $column_name === 'socket' && $column_name = 'listen';            $title.= ""<w>{$column_name}</w>""  .  \str_pad('', static::$$key + static::UI_SAFE_LENGTH - \strlen($column_name));        }        $title && static::safeEcho($title . \PHP_EOL);        //Show content        foreach (static::$_workers as $worker) {            $content = '';            foreach(static::getUiColumns() as $column_name => $prop){                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                \preg_match_all(""/(<n>|<\/n>|<w>|<\/w>|<g>|<\/g>)/is"", $worker->{$prop}, $matches);                $place_holder_length = !empty($matches) ? \strlen(\implode('', $matches[0])) : 0;                $content .= \str_pad($worker->{$prop}, static::$$key + static::UI_SAFE_LENGTH + $place_holder_length);            }            $content && static::safeEcho($content . \PHP_EOL);        }        //Show last line        $line_last = \str_pad('', static::getSingleLineTotalLength(), '-') . \PHP_EOL;        !empty($content) && static::safeEcho($line_last);        if (static::$daemonize) {            foreach ($argv as $index => $value) {                if ($value == '-d') {                    unset($argv[$index]);                } elseif ($value == 'start' || $value == 'restart') {                    $argv[$index] = 'stop';                }            }            static::safeEcho(""Input \""php "".implode(' ', $argv).""\"" to stop. Start success.\n\n"");        } else {            static::safeEcho(""Press Ctrl+C to stop. Start success.\n"");        }    }    /**     * Get UI columns to be shown in terminal     *     * 1. $column_map: array('ui_column_name' => 'clas_property_name')     * 2. Consider move into configuration in future     *     * @return array     */    public static function getUiColumns()    {        return array(            'proto'     =>  'transport',            'user'      =>  'user',            'worker'    =>  'name',            'socket'    =>  'socket',            'processes' =>  'count',            'status'    =>  'status',        );    }    /**     * Get single line total length for ui     *     * @return int     */    public static function getSingleLineTotalLength()    {        $total_length = 0;        foreach(static::getUiColumns() as $column_name => $prop){            $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';            $total_length += static::$$key + static::UI_SAFE_LENGTH;        }        //keep beauty when show less colums        !\defined('LINE_VERSIOIN_LENGTH') && \define('LINE_VERSIOIN_LENGTH', 0);        $total_length <= LINE_VERSIOIN_LENGTH && $total_length = LINE_VERSIOIN_LENGTH;        return $total_length;    }    /**     * Parse command.     *     * @return void     */    protected static function parseCommand()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        global $argv;        // Check argv;        $start_file = $argv[0];        $usage = ""Usage: php yourfile <command> [mode]\nCommands: \nstart\t\tStart worker in DEBUG mode.\n\t\tUse mode -d to start in DAEMON mode.\nstop\t\tStop worker.\n\t\tUse mode -g to stop gracefully.\nrestart\t\tRestart workers.\n\t\tUse mode -d to start in DAEMON mode.\n\t\tUse mode -g to stop gracefully.\nreload\t\tReload codes.\n\t\tUse mode -g to reload gracefully.\nstatus\t\tGet worker status.\n\t\tUse mode -d to show live status.\nconnections\tGet worker connections.\n"";        $available_commands = array(            'start',            'stop',            'restart',            'reload',            'status',            'connections',        );        $available_mode = array(            '-d',            '-g'        );        $command = $mode = '';        foreach ($argv as $value) {            if (\in_array($value, $available_commands)) {                $command = $value;            } elseif (\in_array($value, $available_mode)) {                $mode = $value;            }        }        if (!$command) {            exit($usage);        }        // Start command.        $mode_str = '';        if ($command === 'start') {            if ($mode === '-d' || static::$daemonize) {                $mode_str = 'in DAEMON mode';            } else {                $mode_str = 'in DEBUG mode';            }        }        static::log(""Workerman[$start_file] $command $mode_str"");        // Get master process PID.        $master_pid      = \is_file(static::$pidFile) ? (int)\file_get_contents(static::$pidFile) : 0;        // Master is still alive?        if (static::checkMasterIsAlive($master_pid)) {            if ($command === 'start') {                static::log(""Workerman[$start_file] already running"");                exit;            }        } elseif ($command !== 'start' && $command !== 'restart') {            static::log(""Workerman[$start_file] not run"");            exit;        }        $statistics_file =  __DIR__ . ""/../workerman-$master_pid.status"";        // execute command.        switch ($command) {            case 'start':                if ($mode === '-d') {                    static::$daemonize = true;                }                break;            case 'status':                while (1) {                    if (\is_file($statistics_file)) {                        @\unlink($statistics_file);                    }                    // Master process will send SIGUSR2 signal to all child processes.                    \posix_kill($master_pid, SIGUSR2);                    // Sleep 1 second.                    \sleep(1);                    // Clear terminal.                    if ($mode === '-d') {                        static::safeEcho(""\33[H\33[2J\33(B\33[m"", true);                    }                    // Echo status data.                    static::safeEcho(static::formatStatusData($statistics_file));                    if ($mode !== '-d') {                        exit(0);                    }                    static::safeEcho(""\nPress Ctrl+C to quit.\n\n"");                }                exit(0);            case 'connections':                if (\is_file($statistics_file) && \is_writable($statistics_file)) {                    \unlink($statistics_file);                }                // Master process will send SIGIO signal to all child processes.                \posix_kill($master_pid, SIGIO);                // Waiting amoment.                \usleep(500000);                // Display statisitcs data from a disk file.                if(\is_readable($statistics_file)) {                    \readfile($statistics_file);                }                exit(0);            case 'restart':            case 'stop':                if ($mode === '-g') {                    static::$_gracefulStop = true;                    $sig = \SIGHUP;                    static::log(""Workerman[$start_file] is gracefully stopping ..."");                } else {                    static::$_gracefulStop = false;                    $sig = \SIGINT;                    static::log(""Workerman[$start_file] is stopping ..."");                }                // Send stop signal to master process.                $master_pid && \posix_kill($master_pid, $sig);                // Timeout.                $timeout    = 5;                $start_time = \time();                // Check master process is still alive?                while (1) {                    $master_is_alive = $master_pid && \posix_kill((int) $master_pid, 0);                    if ($master_is_alive) {                        // Timeout?                        if (!static::$_gracefulStop && \time() - $start_time >= $timeout) {                            static::log(""Workerman[$start_file] stop fail"");                            exit;                        }                        // Waiting amoment.                        \usleep(10000);                        continue;                    }                    // Stop success.                    static::log(""Workerman[$start_file] stop success"");                    if ($command === 'stop') {                        exit(0);                    }                    if ($mode === '-d') {                        static::$daemonize = true;                    }                    break;                }                break;            case 'reload':                if($mode === '-g'){                    $sig = \SIGQUIT;                }else{                    $sig = \SIGUSR1;                }                \posix_kill($master_pid, $sig);                exit;            default :                if (isset($command)) {                    static::safeEcho('Unknown command: ' . $command . ""\n"");                }                exit($usage);        }    }    /**     * Format status data.     *     * @param $statistics_file     * @return string     */    protected static function formatStatusData($statistics_file)    {        static $total_request_cache = array();        if (!\is_readable($statistics_file)) {            return '';        }        $info = \file($statistics_file, \FILE_IGNORE_NEW_LINES);        if (!$info) {            return '';        }        $status_str = '';        $current_total_request = array();        $worker_info = \unserialize($info[0]);        \ksort($worker_info, SORT_NUMERIC);        unset($info[0]);        $data_waiting_sort = array();        $read_process_status = false;        $total_requests = 0;        $total_qps = 0;        $total_connections = 0;        $total_fails = 0;        $total_memory = 0;        $total_timers = 0;        $maxLen1 = static::$_maxSocketNameLength;        $maxLen2 = static::$_maxWorkerNameLength;        foreach($info as $key => $value) {            if (!$read_process_status) {                $status_str .= $value . ""\n"";                if (\preg_match('/^pid.*?memory.*?listening/', $value)) {                    $read_process_status = true;                }                continue;            }            if(\preg_match('/^[0-9]+/', $value, $pid_math)) {                $pid = $pid_math[0];                $data_waiting_sort[$pid] = $value;                if(\preg_match('/^\S+?\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?/', $value, $match)) {                    $total_memory += \intval(\str_ireplace('M','',$match[1]));                    $maxLen1 = \max($maxLen1,\strlen($match[2]));                    $maxLen2 = \max($maxLen2,\strlen($match[3]));                    $total_connections += \intval($match[4]);                    $total_fails += \intval($match[5]);                    $total_timers += \intval($match[6]);                    $current_total_request[$pid] = $match[7];                    $total_requests += \intval($match[7]);                }            }        }        foreach($worker_info as $pid => $info) {            if (!isset($data_waiting_sort[$pid])) {                $status_str .= ""$pid\t"" . \str_pad('N/A', 7) . "" ""                    . \str_pad($info['listen'], static::$_maxSocketNameLength) . "" ""                    . \str_pad($info['name'], static::$_maxWorkerNameLength) . "" ""                    . \str_pad('N/A', 11) . "" "" . \str_pad('N/A', 9) . "" ""                    . \str_pad('N/A', 7) . "" "" . \str_pad('N/A', 13) . "" N/A    [busy] \n"";                continue;            }            //$qps = isset($total_request_cache[$pid]) ? $current_total_request[$pid]            if (!isset($total_request_cache[$pid]) || !isset($current_total_request[$pid])) {                $qps = 0;            } else {                $qps = $current_total_request[$pid] - $total_request_cache[$pid];                $total_qps += $qps;            }            $status_str .= $data_waiting_sort[$pid]. "" "" . \str_pad($qps, 6) ."" [idle]\n"";        }        $total_request_cache = $current_total_request;        $status_str .= ""----------------------------------------------PROCESS STATUS---------------------------------------------------\n"";        $status_str .= ""Summary\t"" . \str_pad($total_memory.'M', 7) . "" ""            . \str_pad('-', $maxLen1) . "" ""            . \str_pad('-', $maxLen2) . "" ""            . \str_pad($total_connections, 11) . "" "" . \str_pad($total_fails, 9) . "" ""            . \str_pad($total_timers, 7) . "" "" . \str_pad($total_requests, 13) . "" ""            . \str_pad($total_qps,6)."" [Summary] \n"";        return $status_str;    }    /**     * Install signal handler.     *     * @return void     */    protected static function installSignal()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        $signalHandler = '\Workerman\Worker::signalHandler';        // stop        \pcntl_signal(\SIGINT, $signalHandler, false);        // stop        \pcntl_signal(\SIGTERM, $signalHandler, false);        // graceful stop        \pcntl_signal(\SIGHUP, $signalHandler, false);        // reload        \pcntl_signal(\SIGUSR1, $signalHandler, false);        // graceful reload        \pcntl_signal(\SIGQUIT, $signalHandler, false);        // status        \pcntl_signal(\SIGUSR2, $signalHandler, false);        // connection status        \pcntl_signal(\SIGIO, $signalHandler, false);        // ignore        \pcntl_signal(\SIGPIPE, \SIG_IGN, false);    }    /**     * Reinstall signal handler.     *     * @return void     */    protected static function reinstallSignal()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        $signalHandler = '\Workerman\Worker::signalHandler';        // uninstall stop signal handler        \pcntl_signal(\SIGINT, \SIG_IGN, false);        // uninstall stop signal handler        \pcntl_signal(\SIGTERM, \SIG_IGN, false);        // uninstall graceful stop signal handler        \pcntl_signal(\SIGHUP, \SIG_IGN, false);        // uninstall reload signal handler        \pcntl_signal(\SIGUSR1, \SIG_IGN, false);        // uninstall graceful reload signal handler        \pcntl_signal(\SIGQUIT, \SIG_IGN, false);        // uninstall status signal handler        \pcntl_signal(\SIGUSR2, \SIG_IGN, false);        // uninstall connections status signal handler        \pcntl_signal(\SIGIO, \SIG_IGN, false);        // reinstall stop signal handler        static::$globalEvent->add(\SIGINT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful stop signal handler        static::$globalEvent->add(\SIGHUP, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall reload signal handler        static::$globalEvent->add(\SIGUSR1, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful reload signal handler        static::$globalEvent->add(\SIGQUIT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall status signal handler        static::$globalEvent->add(\SIGUSR2, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall connection status signal handler        static::$globalEvent->add(\SIGIO, EventInterface::EV_SIGNAL, $signalHandler);    }    /**     * Signal handler.     *     * @param int $signal     */    public static function signalHandler($signal)    {        switch ($signal) {            // Stop.            case \SIGINT:            case \SIGTERM:                static::$_gracefulStop = false;                static::stopAll();                break;            // Graceful stop.            case \SIGHUP:                static::$_gracefulStop = true;                static::stopAll();                break;            // Reload.            case \SIGQUIT:            case \SIGUSR1:                static::$_gracefulStop = $signal === \SIGQUIT;                static::$_pidsToRestart = static::getAllWorkerPids();                static::reload();                break;            // Show status.            case \SIGUSR2:                static::writeStatisticsToStatusFile();                break;            // Show connection status.            case \SIGIO:                static::writeConnectionsStatisticsToStatusFile();                break;        }    }    /**     * Run as deamon mode.     *     * @throws Exception     */    protected static function daemonize()    {        if (!static::$daemonize || static::$_OS !== \OS_TYPE_LINUX) {            return;        }        \umask(0);        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception('Fork fail');        } elseif ($pid > 0) {            exit(0);        }        if (-1 === \posix_setsid()) {            throw new Exception(""Setsid fail"");        }        // Fork again avoid SVR4 system regain the control of terminal.        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception(""Fork fail"");        } elseif (0 !== $pid) {            exit(0);        }    }    /**     * Redirect sta",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1080, Finder allows to build rules to find files and directories.\n\n It is a thin wrapper around several specialized iterator classes.\n\n All rules may be invoked several times.\n\n All methods return the current Finder object to allow chaining:\n\n     $finder = Finder::create()->files()->name('\n @author Fabien Potencier <fabien@symfony.com>\n,Finder omogućava izgradnju pravila za pronalaženje datoteka i direktorija. To je tanki omotač oko nekoliko specijalizovanih klasa iteratora. Sva pravila se mogu pozivati nekoliko puta. Sve metode vraćaju trenutni objekt Finder-a u dozvoliti ulančavanje,"class Finder implements \IteratorAggregate, \Countable{    public const IGNORE_VCS_FILES = 1;    public const IGNORE_DOT_FILES = 2;    public const IGNORE_VCS_IGNORED_FILES = 4;    private $mode = 0;    private $names = [];    private $notNames = [];    private $exclude = [];    private $filters = [];    private $depths = [];    private $sizes = [];    private $followLinks = false;    private $reverseSorting = false;    private $sort = false;    private $ignore = 0;    private $dirs = [];    private $dates = [];    private $iterators = [];    private $contains = [];    private $notContains = [];    private $paths = [];    private $notPaths = [];    private $ignoreUnreadableDirs = false;    private static $vcsPatterns = ['.svn', '_svn', 'CVS', '_darcs', '.arch-params', '.monotone', '.bzr', '.git', '.hg'];    public function __construct()    {        $this->ignore = static::IGNORE_VCS_FILES | static::IGNORE_DOT_FILES;    }    /**     * Creates a new Finder.     *     * @return static     */    public static function create()    {        return new static();    }    /**     * Restricts the matching to directories only.     *     * @return $this     */    public function directories()    {        $this->mode = Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES;        return $this;    }    /**     * Restricts the matching to files only.     *     * @return $this     */    public function files()    {        $this->mode = Iterator\FileTypeFilterIterator::ONLY_FILES;        return $this;    }    /**     * Adds tests for the directory depth.     *     * Usage:     *     *     $finder->depth('> 1') // the Finder will start matching at level 1.     *     $finder->depth('< 3') // the Finder will descend at most 3 levels of directories below the starting point.     *     $finder->depth(['>= 1', '< 3'])     *     * @param string|int|string[]|int[] $levels The depth level expression or an array of depth levels     *     * @return $this     *     * @see DepthRangeFilterIterator     * @see NumberComparator     */    public function depth($levels)    {        foreach ((array) $levels as $level) {            $this->depths[] = new Comparator\NumberComparator($level);        }        return $this;    }    /**     * Adds tests for file dates (last modified).     *     * The date must be something that strtotime() is able to parse:     *     *     $finder->date('since yesterday');     *     $finder->date('until 2 days ago');     *     $finder->date('> now - 2 hours');     *     $finder->date('>= 2005-10-15');     *     $finder->date(['>= 2005-10-15', '<= 2006-05-27']);     *     * @param string|string[] $dates A date range string or an array of date ranges     *     * @return $this     *     * @see strtotime     * @see DateRangeFilterIterator     * @see DateComparator     */    public function date($dates)    {        foreach ((array) $dates as $date) {            $this->dates[] = new Comparator\DateComparator($date);        }        return $this;    }    /**     * Adds rules that files must match.     *     * You can use patterns (delimited with / sign), globs or simple strings.     *     *     $finder->name('*.php')     *     $finder->name('/\.php$/') // same as above     *     $finder->name('test.php')     *     $finder->name(['test.py', 'test.php'])     *     * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function name($patterns)    {        $this->names = array_merge($this->names, (array) $patterns);        return $this;    }    /**     * Adds rules that files must not match.     *     * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function notName($patterns)    {        $this->notNames = array_merge($this->notNames, (array) $patterns);        return $this;    }    /**     * Adds tests that file contents must match.     *     * Strings or PCRE patterns can be used:     *     *     $finder->contains('Lorem ipsum')     *     $finder->contains('/Lorem ipsum/i')     *     $finder->contains(['dolor', '/ipsum/i'])     *     * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns     *     * @return $this     *     * @see FilecontentFilterIterator     */    public function contains($patterns)    {        $this->contains = array_merge($this->contains, (array) $patterns);        return $this;    }    /**     * Adds tests that file contents must not match.     *     * Strings or PCRE patterns can be used:     *     *     $finder->notContains('Lorem ipsum')     *     $finder->notContains('/Lorem ipsum/i')     *     $finder->notContains(['lorem', '/dolor/i'])     *     * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns     *     * @return $this     *     * @see FilecontentFilterIterator     */    public function notContains($patterns)    {        $this->notContains = array_merge($this->notContains, (array) $patterns);        return $this;    }    /**     * Adds rules that filenames must match.     *     * You can use patterns (delimited with / sign) or simple strings.     *     *     $finder->path('some/special/dir')     *     $finder->path('/some\/special\/dir/') // same as above     *     $finder->path(['some dir', 'another/dir'])     *     * Use only / as dirname separator.     *     * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function path($patterns)    {        $this->paths = array_merge($this->paths, (array) $patterns);        return $this;    }    /**     * Adds rules that filenames must not match.     *     * You can use patterns (delimited with / sign) or simple strings.     *     *     $finder->notPath('some/special/dir')     *     $finder->notPath('/some\/special\/dir/') // same as above     *     $finder->notPath(['some/file.txt', 'another/file.log'])     *     * Use only / as dirname separator.     *     * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function notPath($patterns)    {        $this->notPaths = array_merge($this->notPaths, (array) $patterns);        return $this;    }    /**     * Adds tests for file sizes.     *     *     $finder->size('> 10K');     *     $finder->size('<= 1Ki');     *     $finder->size(4);     *     $finder->size(['> 10K', '< 20K'])     *     * @param string|int|string[]|int[] $sizes A size range string or an integer or an array of size ranges     *     * @return $this     *     * @see SizeRangeFilterIterator     * @see NumberComparator     */    public function size($sizes)    {        foreach ((array) $sizes as $size) {            $this->sizes[] = new Comparator\NumberComparator($size);        }        return $this;    }    /**     * Excludes directories.     *     * Directories passed as argument must be relative to the ones defined with the `in()` method. For example:     *     *     $finder->in(__DIR__)->exclude('ruby');     *     * @param string|array $dirs A directory path or an array of directories     *     * @return $this     *     * @see ExcludeDirectoryFilterIterator     */    public function exclude($dirs)    {        $this->exclude = array_merge($this->exclude, (array) $dirs);        return $this;    }    /**     * Excludes ""hidden"" directories and files (starting with a dot).     *     * This option is enabled by default.     *     * @return $this     *     * @see ExcludeDirectoryFilterIterator     */    public function ignoreDotFiles(bool $ignoreDotFiles)    {        if ($ignoreDotFiles) {            $this->ignore |= static::IGNORE_DOT_FILES;        } else {            $this->ignore &= ~static::IGNORE_DOT_FILES;        }        return $this;    }    /**     * Forces the finder to ignore version control directories.     *     * This option is enabled by default.     *     * @return $this     *     * @see ExcludeDirectoryFilterIterator     */    public function ignoreVCS(bool $ignoreVCS)    {        if ($ignoreVCS) {            $this->ignore |= static::IGNORE_VCS_FILES;        } else {            $this->ignore &= ~static::IGNORE_VCS_FILES;        }        return $this;    }    /**     * Forces Finder to obey .gitignore and ignore files based on rules listed there.     *     * This option is disabled by default.     *     * @return $this     */    public function ignoreVCSIgnored(bool $ignoreVCSIgnored)    {        if ($ignoreVCSIgnored) {            $this->ignore |= static::IGNORE_VCS_IGNORED_FILES;        } else {            $this->ignore &= ~static::IGNORE_VCS_IGNORED_FILES;        }        return $this;    }    /**     * Adds VCS patterns.     *     * @see ignoreVCS()     *     * @param string|string[] $pattern VCS patterns to ignore     */    public static function addVCSPattern($pattern)    {        foreach ((array) $pattern as $p) {            self::$vcsPatterns[] = $p;        }        self::$vcsPatterns = array_unique(self::$vcsPatterns);    }    /**     * Sorts files and directories by an anonymous function.     *     * The anonymous function receives two \SplFileInfo instances to compare.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sort(\Closure $closure)    {        $this->sort = $closure;        return $this;    }    /**     * Sorts files and directories by name.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByName(bool $useNaturalSort = false)    {        $this->sort = $useNaturalSort ? Iterator\SortableIterator::SORT_BY_NAME_NATURAL : Iterator\SortableIterator::SORT_BY_NAME;        return $this;    }    /**     * Sorts files and directories by type (directories before files), then by name.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByType()    {        $this->sort = Iterator\SortableIterator::SORT_BY_TYPE;        return $this;    }    /**     * Sorts files and directories by the last accessed time.     *     * This is the time that the file was last accessed, read or written to.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByAccessedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_ACCESSED_TIME;        return $this;    }    /**     * Reverses the sorting.     *     * @return $this     */    public function reverseSorting()    {        $this->reverseSorting = true;        return $this;    }    /**     * Sorts files and directories by the last inode changed time.     *     * This is the time that the inode information was last modified (permissions, owner, group or other metadata).     *     * On Windows, since inode is not available, changed time is actually the file creation time.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByChangedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_CHANGED_TIME;        return $this;    }    /**     * Sorts files and directories by the last modified time.     *     * This is the last time the actual contents of the file were last modified.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByModifiedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_MODIFIED_TIME;        return $this;    }    /**     * Filters the iterator with an anonymous function.     *     * The anonymous function receives a \SplFileInfo and must return false     * to remove files.     *     * @return $this     *     * @see CustomFilterIterator     */    public function filter(\Closure $closure)    {        $this->filters[] = $closure;        return $this;    }    /**     * Forces the following of symlinks.     *     * @return $this     */    public function followLinks()    {        $this->followLinks = true;        return $this;    }    /**     * Tells finder to ignore unreadable directories.     *     * By default, scanning unreadable directories content throws an AccessDeniedException.     *     * @return $this     */    public function ignoreUnreadableDirs(bool $ignore = true)    {        $this->ignoreUnreadableDirs = $ignore;        return $this;    }    /**     * Searches files and directories which match defined rules.     *     * @param string|string[] $dirs A directory path or an array of directories     *     * @return $this     *     * @throws DirectoryNotFoundException if one of the directories does not exist     */    public function in($dirs)    {        $resolvedDirs = [];        foreach ((array) $dirs as $dir) {            if (is_dir($dir)) {                $resolvedDirs[] = $this->normalizeDir($dir);            } elseif ($glob = glob($dir, (\defined('GLOB_BRACE') ? \GLOB_BRACE : 0) | \GLOB_ONLYDIR | \GLOB_NOSORT)) {                sort($glob);                $resolvedDirs = array_merge($resolvedDirs, array_map([$this, 'normalizeDir'], $glob));            } else {                throw new DirectoryNotFoundException(sprintf('The ""%s"" directory does not exist.', $dir));            }        }        $this->dirs = array_merge($this->dirs, $resolvedDirs);        return $this;    }    /**     * Returns an Iterator for the current Finder configuration.     *     * This method implements the IteratorAggregate interface.     *     * @return \Iterator|SplFileInfo[] An iterator     *     * @throws \LogicException if the in() method has not been called     */    public function getIterator()    {        if (0 === \count($this->dirs) && 0 === \count($this->iterators)) {            throw new \LogicException('You must call one of in() or append() methods before iterating over a Finder.');        }        if (1 === \count($this->dirs) && 0 === \count($this->iterators)) {            $iterator = $this->searchInDirectory($this->dirs[0]);            if ($this->sort || $this->reverseSorting) {                $iterator = (new Iterator\SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();            }            return $iterator;        }        $iterator = new \AppendIterator();        foreach ($this->dirs as $dir) {            $iterator->append(new \IteratorIterator(new LazyIterator(function () use ($dir) {                return $this->searchInDirectory($dir);            })));        }        foreach ($this->iterators as $it) {            $iterator->append($it);        }        if ($this->sort || $this->reverseSorting) {            $iterator = (new Iterator\SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();        }        return $iterator;    }    /**     * Appends an existing set of files/directories to the finder.     *     * The set can be another Finder, an Iterator, an IteratorAggregate, or even a plain array.     *     * @return $this     *     * @throws \InvalidArgumentException when the given argument is not iterable     */    public function append(iterable $iterator)    {        if ($iterator instanceof \IteratorAggregate) {            $this->iterators[] = $iterator->getIterator();        } elseif ($iterator instanceof \Iterator) {            $this->iterators[] = $iterator;        } elseif ($iterator instanceof \Traversable || \is_array($iterator)) {            $it = new \ArrayIterator();            foreach ($iterator as $file) {                $file = $file instanceof \SplFileInfo ? $file : new \SplFileInfo($file);                $it[$file->getPathname()] = $file;            }            $this->iterators[] = $it;        } else {            throw new \InvalidArgumentException('Finder::append() method wrong argument type.');        }        return $this;    }    /**     * Check if any results were found.     *     * @return bool     */    public function hasResults()    {        foreach ($this->getIterator() as $_) {            return true;        }        return false;    }    /**     * Counts all the results collected by the iterators.     *     * @return int     */    public function count()    {        return iterator_count($this->getIterator());    }    private function searchInDirectory(string $dir): \Iterator    {        $exclude = $this->exclude;        $notPaths = $this->notPaths;        if (static::IGNORE_VCS_FILES === (static::IGNORE_VCS_FILES & $this->ignore)) {            $exclude = array_merge($exclude, self::$vcsPatterns);        }        if (static::IGNORE_DOT_FILES === (static::IGNORE_DOT_FILES & $this->ignore)) {            $notPaths[] = '#(^|/)\..+(/|$)#';        }        if (static::IGNORE_VCS_IGNORED_FILES === (static::IGNORE_VCS_IGNORED_FILES & $this->ignore)) {            $gitignoreFilePath = sprintf('%s/.gitignore', $dir);            if (!is_readable($gitignoreFilePath)) {                throw new \RuntimeException(sprintf('The ""ignoreVCSIgnored"" option cannot be used by the Finder as the ""%s"" file is not readable.', $gitignoreFilePath));            }            $notPaths = array_merge($notPaths, [Gitignore::toRegex(file_get_contents($gitignoreFilePath))]);        }        $minDepth = 0;        $maxDepth = \PHP_INT_MAX;        foreach ($this->depths as $comparator) {            switch ($comparator->getOperator()) {                case '>':                    $minDepth = $comparator->getTarget() + 1;                    break;                case '>=':                    $minDepth = $comparator->getTarget();                    break;                case '<':                    $maxDepth = $comparator->getTarget() - 1;                    break;                case '<=':                    $maxDepth = $comparator->getTarget();                    break;                default:                    $minDepth = $maxDepth = $comparator->getTarget();            }        }        $flags = \RecursiveDirectoryIterator::SKIP_DOTS;        if ($this->followLinks) {            $flags |= \RecursiveDirectoryIterator::FOLLOW_SYMLINKS;        }        $iterator = new Iterator\RecursiveDirectoryIterator($dir, $flags, $this->ignoreUnreadableDirs);        if ($exclude) {            $iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $exclude);        }        $iterator = new \RecursiveIteratorIterator($iterator, \RecursiveIteratorIterator::SELF_FIRST);        if ($minDepth > 0 || $maxDepth < \PHP_INT_MAX) {            $iterator = new Iterator\DepthRangeFilterIterator($iterator, $minDepth, $maxDepth);        }        if ($this->mode) {            $iterator = new Iterator\FileTypeFilterIterator($iterator, $this->mode);        }        if ($this->names || $this->notNames) {            $iterator = new Iterator\FilenameFilterIterator($iterator, $this->names, $this->notNames);        }        if ($this->contains || $this->notContains) {            $iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);        }        if ($this->sizes) {            $iterator = new Iterator\SizeRangeFilterIterator($iterator, $this->sizes);        }        if ($this->dates) {            $iterator = new Iterator\DateRangeFilterIterator($iterator, $this->dates);        }        if ($this->filters) {            $iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);        }        if ($this->paths || $notPaths) {            $iterator = new Iterator\PathFilterIterator($iterator, $this->paths, $notPaths);        }        return $iterator;    }    /**     * Normalizes given directory names by removing trailing slashes.     *     * Excluding: (s)ftp:// or ssh2.(s)ftp:// wrapper     */    private function normalizeDir(string $dir): string    {        if ('/' === $dir) {            return $dir;        }        $dir = rtrim($dir, '/'.\DIRECTORY_SEPARATOR);        if (preg_match('#^(ssh2\.)?s?ftp://#', $dir)) {            $dir .= '/';        }        return $dir;    }}",0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3492," Compute the P-th percentile of a list of numbers\\n\\n Linear interpolation between closest ranks method - Second variant, C = 1\\n P-th percentile (0 <= P <= 100) of a list of N ordered values (sorted from least to greatest)\\n Similar method used in NumPy and Excel\\n https://en.wikipedia.org/wiki/Percentile#Second_variant.2C_.7F.27.22.60UNIQ--postMath-00000043-QINU.60.22.27.7F\\n\\n      P\\n x - --- (N - 1) + 1\\n     100\\n\\n P = percentile\\n N = number of elements in list\\n\\n Î½(x) = Î½â‚“ + xï¼…1(Î½â‚“â‚Šâ‚ - Î½â‚“)\\n\\n âŒŠxâŒ‹  = integer part of x\\n xï¼…1 = fraction part of x\\n Î½â‚“   = number in position x in sorted list of numbers\\n Î½â‚“â‚Šâ‚ = number in position x + 1 in sorted list of number\\n\\n @param float[] $numbers\\n @param float   $P percentile to calculate\\n\\n @return float in list corresponding to P percentile\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if $P percentile is not between 0 and 100\\n","Izračunajte P-ti percentil iz liste brojeva . Metoda linearne interpolacije između najbližih rangova - Druga varijanta, C = 1. P-ti percentil (0 <= P <= 100) liste N uređenih vrednosti (poređanih od najmanje do najveće). Slična metoda korišćena u NumPi i Excel-u","    public static function percentile(array $numbers, float $P): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the P-th percentile of an empty list of numbers');        }        if ($P < 0 || $P > 100) {            throw new Exception\OutOfBoundsException('Percentile P must be between 0 and 100.');        }        $N = \count($numbers);        if ($N === 1) {            return \array_shift($numbers);        }        \sort($numbers);        if ($P == 100) {            return  $numbers[$N - 1];        }        $x    = ($P / 100) * ($N - 1) + 1;        $âŒŠxâŒ‹  = \intval($x);        $xï¼…1 = $x - $âŒŠxâŒ‹;        $Î½â‚“   = $numbers[$âŒŠxâŒ‹ - 1];        $Î½â‚“â‚Šâ‚ = $numbers[$âŒŠxâŒ‹];        return $Î½â‚“ + $xï¼…1 * ($Î½â‚“â‚Šâ‚ - $Î½â‚“);    }",0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericalIntegration_3024, Sorts our coordinates (arrays) by their x-component (first number) such\n that consecutive coordinates have an increasing x-component.\n\n @param  array[] $points\n\n @return array[]\n,Sortira naše koordinate (nizove) prema njihovim k-komponentama (prvi broj) tako da uzastopne koordinate imaju rastuću k-komponentu,"    protected static function sort(array $points): array    {        \usort($points, function ($a, $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }",0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_9684, Sorts items by descending quality.\n,Sortira stavke prema opadajućem kvalitetu,"    private function sort(): void    {        if (!$this->sorted) {            uasort($this->items, function (AcceptHeaderItem $a, AcceptHeaderItem $b) {                $qA = $a->getQuality();                $qB = $b->getQuality();                if ($qA === $qB) {                    return $a->getIndex() > $b->getIndex() ? 1 : -1;                }                return $qA > $qB ? -1 : 1;            });            $this->sorted = true;        }    }",0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_MaxCharacter_2067, This function returns\n the character which is\n repeated maximum no. of\n times in the given string.\n\n @param string $string\n @return string\n,Ova funkcija vraća znak koji je ponovljen maksimum br. puta u datom nizu,function maxCharacter(string $string){    if (empty($string)) {        throw new \Exception('Please pass a non-empty string value');    }    $characterCountTable = []; // A variable to maintain the character counts    $string              = strtolower($string); // For case-insensitive checking    $characters          = str_split($string); // Splitting the string to a Character Array.    foreach ($characters as $character) {        $currentCharacterCount = 1;        if (isset($characterCountTable[$character])) {            $currentCharacterCount = $characterCountTable[$character] + 1;        }        $characterCountTable[$character] = $currentCharacterCount;    }    arsort($characterCountTable);    return array_keys($characterCountTable)[0];},0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_9683, Returns first item.\n\n @return AcceptHeaderItem|null\n,Vraća prvu stavku,    public function first()    {        $this->sort();        return !empty($this->items) ? reset($this->items) : null;    },0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3491," Quartiles - Inclusive method (R method)\n Three points that divide the data set into four equal groups, each group comprising a quarter of the data.\n https://en.wikipedia.org/wiki/Quartile\n\n 0% is smallest number\n Q1 (25%) is first quartile (lower quartile, 25th percentile)\n Q2 (50%) is second quartile (median, 50th percentile)\n Q3 (75%) is third quartile (upper quartile, 75th percentile)\n 100% is largest number\n interquartile_range is the difference between the upper and lower quartiles. (IQR = Qâ‚ƒ - Qâ‚)\n\n Method used\n  - Use the median to divide the ordered data set into two halves.\n   - If there are an odd number of data points in the original ordered data set,\n     include the median (the central value in the ordered list) in both halves.\n   - If there are an even number of data points in the original ordered data set,\n     split this data set exactly in half.\n  - The lower quartile value is the median of the lower half of the data.\n    The upper quartile value is the median of the upper half of the data.\n\n The values found by this method are also known as ""Tukey\'s hinges"".\n This is the method that the programming language R uses by default.\n\n @param float[] $numbers\n\n @return array (0%, Q1, Q2, Q3, 100%, IQR)\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n","Kvartili - Inkluzivna metoda (R metoda).Tri tačke koje skup podataka dele na četiri jednake grupe, a svaka grupa čini četvrtinu podataka https://en.vikipedia.org/viki/Kuartile\n\n 0% je najmanji broj K1 (25%) je prvi kvartil (donji kvartil, 25. percentil), K2 (50%) je drugi kvartil (medijana, 50. percentil), K3 (75%) je treći kvartil (gornji) kvartil, 75. percentil) , 100% je najveći broj. Interquartile_range je razlika između gornjeg i donjeg kvartila. (IKR = Ka‚ƒ - Ka ‚). Korišćena metoda - Koristiti medijanu da podeli poređani skup podataka na dve polovine. Ako u originalnim uređenim podacima postoji neparan broj tačaka podataka skupa, uključite medijanu (centralnu vrednost na uređenoj listi) u obe polovine. Ako u originalnom uređenom skupu podataka postoji paran broj tačaka podataka, podelite ovaj skup podataka tačno na pola. Vrednost donjeg kvartila je medijana donje polovine podataka.Vrednost gornjeg kvartila je srednja vrednost gornje polovine podataka. Vrednosti pronađene ovom metodom poznate su i kao „Tukey\'s hinges"". Ovo je metoda koju programski jezik R podrazumevano koristi","    public static function quartilesInclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);            // Add median to both halves            $median = Average::median($numbers);            \array_push($lower_half, $median);            \array_unshift($upper_half, $median);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }",0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_EigenTransformerBase_898, Calculates eigenValues and eigenVectors of the given matrix. Returns\n top eigenVectors along with the largest eigenValues. The total explained variance\n of these eigenVectors will be no less than desired $totalVariance value\n,Izračunava eigenValues i eigenVectors date matrice. Vraća top eigenVectors zajedno sa najvećim eigenValues. Ukupna objašnjena varijansa ovih eigenVectors neće biti manja od željene $totalVariance vrednosti,    protected function eigenDecomposition(array $matrix): void    {        $eig = new EigenvalueDecomposition($matrix);        $eigVals = $eig->getRealEigenvalues();        $eigVects = $eig->getEigenvectors();        $totalEigVal = array_sum($eigVals);        // Sort eigenvalues in descending order        arsort($eigVals);        $explainedVar = 0.0;        $vectors = [];        $values = [];        foreach ($eigVals as $i => $eigVal) {            $explainedVar += $eigVal / $totalEigVal;            $vectors[] = $eigVects[$i];            $values[] = $eigVal;            if ($this->numFeatures !== null) {                if (count($vectors) == $this->numFeatures) {                    break;                }            } else {                if ($explainedVar >= $this->totalVariance) {                    break;                }            }        }        $this->eigValues = $values;        $this->eigVectors = $vectors;    },0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_SimpsonsRule_3028," Use Simpson's Rule to approximate the definite integral of a\n function f(x). Our input can support either a set of arrays, or a callback\n function with arguments (to produce a set of arrays). Each array in our\n input contains two numbers which correspond to coordinates (x, y) or\n equivalently, (x, f(x)), of the function f(x) whose definite integral we\n are approximating.\n\n Note: Simpson's method requires that we have an even number of\n subintervals (we must supply an odd number of points) and also that the\n size of each subinterval is equal (spacing between each point is equal).\n\n The bounds of the definite integral to which we are approximating is\n determined by the our inputs.\n\n Example: approximate([0, 10], [5, 5], [10, 7]) will approximate the definite\n integral of the function that produces these coordinates with a lower\n bound of 0, and an upper bound of 10.\n\n Example: approximate(function($x) {return $x a set of arrays by evaluating the callback at 5 evenly spaced points\n between 0 and 4. Then, this array will be used in our approximation.\n\n Simpson's Rule:\n\n xn        â¿â»Â¹ xáµ¢â‚Šâ‚\n âˆ« f(x)dx = âˆ‘   âˆ« f(x)dx\n xâ‚        â±â¼Â¹  xáµ¢\n\n         â½â¿â»Â¹â¾/Â² h\n          = âˆ‘    - [fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯ + 4fâŸ®xâ‚‚áµ¢âŸ¯ + fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯] + O(hâµfâ—(x))\n           â±â¼Â¹   3\n where h = (xn - xâ‚) / (n - 1)\n\n @param callable|array $source  The source of our approximation. Should be either\n                                a callback function or a set of arrays. Each array\n                                (point) contains precisely two numbers, an x and y.\n                                Example array: [[1,2], [2,3], [3,4]].\n                                Example callback: function($x) {return $x @param number         ...$args The arguments of our callback function: start,\n                                end, and n. Example: approximate($source, 0, 8, 5).\n                                If $source is a set of points, do not input any\n                                $args. Example: approximate($source).\n\n @return float                  The approximation to the integral of f(x)\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n","Koristite Simpsonovo pravilo za približavanje konačnog integrala funkcije f(x). Naš ulaz može podržati ili skup nizova, ili funkciju povratnog poziva sa argumentima (da bi se dobio niz nizova). Svaki niz u našem ulazu sadrži dva broja koji odgovaraju koordinatama (x, i) ili ekvivalentno, (x, f (x)), funkcije f(x) čiji konačni integral aproksimiramo. Napomena: Simpsonova metoda zahteva da imamo paran broj podintervala (moramo dostaviti neparan broj tačaka) i da je veličina svakog podintervala jednaka (razmak između svake tačke je jednak). Granice definitivnog integrala kojem se približavamo određuju naši unosi. Primer: approximate([0, 10], [5, 5], [10, 7]) će približite konačni integral funkcije koja daje ove koordinate sa donjom granicom 0, a gornjom granicom 10. Primer: approximate(funkcija ($x) {vrati $x skup nizova procenjujući povratni poziv u 5 ravnomerno raspoređenih tačaka između 0 i 4. Zatim će se ovaj niz koristiti u našoj aproksimaciji","    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 3);        Validation::isSubintervalsMultiple($points, $m = 2);        $sorted = self::sort($points);        Validation::isSpacingConstant($sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $subintervals  = $n - 1;        $a             = $sorted[0][$x];        $b             = $sorted[$n - 1][$x];        $h             = ($b - $a) / $subintervals;        $approximation = 0;        /*         * Summation         * â½â¿â»Â¹â¾/Â² h         *    âˆ‘    - [fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯ + 4fâŸ®xâ‚‚áµ¢âŸ¯ + fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯] + O(hâµfâ—(x))         *   â±â¼Â¹   3         *  where h = (xn - xâ‚) / (n - 1)         */        for ($i = 1; $i < ($subintervals / 2) + 1; $i++) {            $xâ‚‚áµ¢â‚‹â‚          = $sorted[(2 * $i) - 2][$x];            $xâ‚‚áµ¢            = $sorted[(2 * $i) - 1][$x];            $xâ‚‚áµ¢â‚Šâ‚          = $sorted[(2 * $i)][$x];            $fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯        = $sorted[(2 * $i) - 2][$y];  // yâ‚‚áµ¢â‚‹â‚            $fâŸ®xâ‚‚áµ¢âŸ¯          = $sorted[(2 * $i) - 1][$y];  // yâ‚‚áµ¢            $fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯        = $sorted[(2 * $i)][$y];    // yâ‚‚áµ¢â‚Šâ‚            $lagrange       = LagrangePolynomial::interpolate([[$xâ‚‚áµ¢â‚‹â‚, $fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯], [$xâ‚‚áµ¢, $fâŸ®xâ‚‚áµ¢âŸ¯], [$xâ‚‚áµ¢â‚Šâ‚, $fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xâ‚‚áµ¢â‚Šâ‚) - $integral($xâ‚‚áµ¢â‚‹â‚); // definite integral of lagrange polynomial        }        return $approximation;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_TrapezoidalRule_3032," Use the Trapezoidal Rule to approximate the definite integral of a\\n function f(x). Our input can support either a set of arrays, or a callback\\n function with arguments (to produce a set of arrays). Each array in our\\n input contains two numbers which correspond to coordinates (x, y) or\\n equivalently, (x, f(x)), of the function f(x) whose definite integral we\\n are approximating.\\n\\n The bounds of the definite integral to which we are approximating is\\n determined by the our inputs.\\n\\n Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite\\n integral of the function that produces these coordinates with a lower\\n bound of 0, and an upper bound of 10.\\n\\n Example: approximate(function($x) {return $x a set of arrays by evaluating the callback at 5 evenly spaced points\\n between 0 and 4. Then, this array will be used in our approximation.\\n\\n Trapezoidal Rule:\\n\\n xn        â¿â»Â¹ xáµ¢â‚Šâ‚\\n âˆ« f(x)dx = âˆ‘   âˆ« f(x)dx\\n xâ‚        â±â¼Â¹  xáµ¢\\n\\n           â¿â»Â¹  h\\n          = âˆ‘   - [f(xáµ¢â‚Šâ‚) + f(xáµ¢)] + O(hÂ³fâ€³(x))\\n           â±â¼Â¹  2\\n\\n  where h = xáµ¢â‚Šâ‚ - xáµ¢\\n  note: this implementation does not compute the error term.\\n @param callable|array $source The source of our approximation. Should be either\\n                               a callback function or a set of arrays. Each array\\n                               (point) contains precisely two numbers, an x and y.\\n                               Example array: [[1,2], [2,3], [3,4]].\\n                               Example callback: function($x) {return $x @param number        ...$args The arguments of our callback function: start,\\n                               end, and n. Example: approximate($source, 0, 8, 5).\\n                               If $source is a set of points, do not input any\\n                               $args. Example: approximate($source).\\n\\n @return float                The approximation to the integral of f(x)\\n\\n @throws Exception\\\\BadDataException\\n @throws \\\\MathPHP\\\\Exception\\\\IncorrectTypeException\\n","Koristite trapezoidno pravilo za približavanje konačnog integrala funkcije f(x). Naš ulaz može podržati ili skup nizova, ili funkciju povratnog poziva sa argumentima (za stvaranje niza nizova). Svaki niz u našem ulazu sadrži dva broja koji odgovaraju koordinatama (x, i) ili ekvivalentno, (x, f(x)), funkcije f(x) čiji konačni integral aproksimiramo. Granice konačnog integrala kojem se približavamo određene su našim ulazima. Primer: approximate([0, 10], [3, 5] , [10, 7]) približiće konačni integral funkcije koja proizvodi ove koordinate sa donjom granicom 0, a gornjom granicom 10. Primer: approximate(funkcija ($x) {vrati $x skup nizova procenom povratnog poziva u 5 ravnomerno raspoređenih tačaka između 0 i 4. Tada će se ovaj niz koristiti u našoj aproksimaciji","    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         * â¿â»Â¹  h         *  âˆ‘   - [f(xáµ¢â‚Šâ‚) + f(xáµ¢)]         * â±â¼Â¹  2         *  where h = xáµ¢â‚Šâ‚ - xáµ¢         */        for ($i = 0; $i < $steps; $i++) {            $xáµ¢             = $sorted[$i][$x];            $xáµ¢â‚Šâ‚           = $sorted[$i + 1][$x];            $fâŸ®xáµ¢âŸ¯           = $sorted[$i][$y];    // yáµ¢            $fâŸ®xáµ¢â‚Šâ‚âŸ¯         = $sorted[$i + 1][$y];  // yáµ¢â‚Šâ‚            $lagrange       = LagrangePolynomial::interpolate([[$xáµ¢, $fâŸ®xáµ¢âŸ¯], [$xáµ¢â‚Šâ‚, $fâŸ®xáµ¢â‚Šâ‚âŸ¯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xáµ¢â‚Šâ‚) - $integral($xáµ¢); // definite integral of lagrange polynomial        }        return $approximation;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_ReleaseController_980, Ensure sorting of the changelog lines.\\n @param string[] $changelog\\n @return string[]\\n,Obezbedite sortiranje redova dnevnika promena,"abstract class TestCase extends \PHPUnit\Framework\TestCase{    public static $params;    /**     * Clean up after test case.     */    public static function tearDownAfterClass()    {        parent::tearDownAfterClass();        $logger = Yii::getLogger();        $logger->flush();    }    /**     * Returns a test configuration param from /data/config.php.     * @param string $name params name     * @param mixed $default default value to use when param is not set.     * @return mixed  the value of the configuration param     */    public static function getParam($name, $default = null)    {        if (static::$params === null) {            static::$params = require __DIR__ . '/data/config.php';        }        return isset(static::$params[$name]) ? static::$params[$name] : $default;    }    /**     * Clean up after test.     * By default the application created with [[mockApplication]] will be destroyed.     */    protected function tearDown()    {        parent::tearDown();        $this->destroyApplication();    }    /**     * Populates Yii::$app with a new application     * The application will be destroyed on tearDown() automatically.     * @param array $config The application configuration, if needed     * @param string $appClass name of the application class to create     */    protected function mockApplication($config = [], $appClass = '\yii\console\Application')    {        new $appClass(ArrayHelper::merge([            'id' => 'testapp',            'basePath' => __DIR__,            'vendorPath' => $this->getVendorPath(),        ], $config));    }    protected function mockWebApplication($config = [], $appClass = '\yii\web\Application')    {        new $appClass(ArrayHelper::merge([            'id' => 'testapp',            'basePath' => __DIR__,            'vendorPath' => $this->getVendorPath(),            'aliases' => [                '@bower' => '@vendor/bower-asset',                '@npm' => '@vendor/npm-asset',            ],            'components' => [                'request' => [                    'cookieValidationKey' => 'wefJDF8sfdsfSDefwqdxj9oq',                    'scriptFile' => __DIR__ . '/index.php',                    'scriptUrl' => '/index.php',                ],            ],        ], $config));    }    protected function getVendorPath()    {        $vendor = dirname(dirname(__DIR__)) . '/vendor';        if (!is_dir($vendor)) {            $vendor = dirname(dirname(dirname(dirname(__DIR__))));        }        return $vendor;    }    /**     * Destroys application in Yii::$app by setting it to null.     */    protected function destroyApplication()    {        if (\Yii::$app && \Yii::$app->has('session', true)) {            \Yii::$app->session->close();        }        \Yii::$app = null;    }    /**     * Asserting two strings equality ignoring line endings.     * @param string $expected     * @param string $actual     * @param string $message     */    protected function assertEqualsWithoutLE($expected, $actual, $message = '')    {        $expected = str_replace(""\r\n"", ""\n"", $expected);        $actual = str_replace(""\r\n"", ""\n"", $actual);        $this->assertEquals($expected, $actual, $message);    }    /**     * Asserts that a haystack contains a needle ignoring line endings.     *     * @param mixed $needle     * @param mixed $haystack     * @param string $message     */    protected function assertContainsWithoutLE($needle, $haystack, $message = '')    {        $needle = str_replace(""\r\n"", ""\n"", $needle);        $haystack = str_replace(""\r\n"", ""\n"", $haystack);        $this->assertContains($needle, $haystack, $message);    }    /**     * Invokes a inaccessible method.     * @param $object     * @param $method     * @param array $args     * @param bool $revoke whether to make method inaccessible after execution     * @return mixed     * @since 2.0.11     */    protected function invokeMethod($object, $method, $args = [], $revoke = true)    {        $reflection = new \ReflectionObject($object);        $method = $reflection->getMethod($method);        $method->setAccessible(true);        $result = $method->invokeArgs($object, $args);        if ($revoke) {            $method->setAccessible(false);        }        return $result;    }    /**     * Sets an inaccessible object property to a designated value.     * @param $object     * @param $propertyName     * @param $value     * @param bool $revoke whether to make property inaccessible after setting     * @since 2.0.11     */    protected function setInaccessibleProperty($object, $propertyName, $value, $revoke = true)    {        $class = new \ReflectionClass($object);        while (!$class->hasProperty($propertyName)) {            $class = $class->getParentClass();        }        $property = $class->getProperty($propertyName);        $property->setAccessible(true);        $property->setValue($object, $value);        if ($revoke) {            $property->setAccessible(false);        }    }    /**     * Gets an inaccessible object property.     * @param $object     * @param $propertyName     * @param bool $revoke whether to make property inaccessible after getting     * @return mixed     */    protected function getInaccessibleProperty($object, $propertyName, $revoke = true)    {        $class = new \ReflectionClass($object);        while (!$class->hasProperty($propertyName)) {            $class = $class->getParentClass();        }        $property = $class->getProperty($propertyName);        $property->setAccessible(true);        $result = $property->getValue($object);        if ($revoke) {            $property->setAccessible(false);        }        return $result;    }    /**     * Asserts that value is one of expected values.     *     * @param mixed $actual     * @param array $expected     * @param string $message     */    public function assertIsOneOf($actual, array $expected, $message = '')    {        self::assertThat($actual, new IsOneOfAssert($expected), $message);    }    /**     * Changes db component config     * @param $db     */    protected function switchDbConnection($db)    {        $databases = $this->getParam('databases');        if (isset($databases[$db])) {            $database = $databases[$db];            Yii::$app->db->close();            Yii::$app->db->dsn = isset($database['dsn']) ? $database['dsn'] : null;            Yii::$app->db->username = isset($database['username']) ? $database['username'] : null;            Yii::$app->db->password = isset($database['password']) ? $database['password'] : null;        }    }}",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3436, Statistical averages\n,Statistički proseci,"class Average{    /**************************************************************************     * Averages of a list of numbers     **************************************************************************/    /**     * Calculate the mean average of a list of numbers     *     *     âˆ‘âŸ®xáµ¢âŸ¯     * xÌ„ = -----     *       n     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function mean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the average of an empty list of numbers');        }        return \array_sum($numbers) / \count($numbers);    }    /**     * Calculate the weighted mean average of a list of numbers     * https://en.wikipedia.org/wiki/Weighted_arithmetic_mean     *     *     âˆ‘âŸ®xáµ¢wáµ¢âŸ¯     * xÌ„ = -----     *      âˆ‘âŸ®wáµ¢âŸ¯     *     * @param float[] $numbers     * @param float[] $weights     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\BadDataException if the number of numbers and weights are not equal     */    public static function weightedMean(array $numbers, array $weights): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the weightedMean of an empty list of numbers');        }        if (empty($weights)) {            return Average::mean($numbers);        }        if (\count($numbers) !== \count($weights)) {            throw new Exception\BadDataException('Numbers and weights must have the same number of elements.');        }        $âˆ‘âŸ®xáµ¢wáµ¢âŸ¯ = \array_sum(\array_map(            function ($xáµ¢, $wáµ¢) {                return $xáµ¢ * $wáµ¢;            },            $numbers,            $weights        ));        $âˆ‘âŸ®wáµ¢âŸ¯ = \array_sum($weights);        return $âˆ‘âŸ®xáµ¢wáµ¢âŸ¯ / $âˆ‘âŸ®wáµ¢âŸ¯;    }    /**     * Calculate the median average of a list of numbers     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if kth-smallest k is out of bounds     */    public static function median(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median of an empty list of numbers');        }        if (\count($numbers) === 1) {            return \array_pop($numbers);        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // For odd number of numbers, take the middle indexed number        if (\count($numbers) % 2 == 1) {            $middle_index = \intdiv(\count($numbers), 2);            return self::kthSmallest($numbers, $middle_index);        }        // For even number of items, take the mean of the middle two indexed numbers        $left_middle_index  = \intdiv(\count($numbers), 2) - 1;        $left_median        = self::kthSmallest($numbers, $left_middle_index);        $right_middle_index = $left_middle_index + 1;        $right_median       = self::kthSmallest($numbers, $right_middle_index);        return self::mean([ $left_median, $right_median ]);    }    /**     * Return the kth smallest value in an array     * Uses a linear-time algorithm: O(n) time in worst case.     *     * if $a = [1,2,3,4,6,7]     *     * kthSmallest($a, 4) = 6     *     * Algorithm:     *  1) If n is small, just sort and return     *  2) Otherwise, group into 5-element subsets and mind the median     *  3) Find the median of the medians     *  4) Find L and U sets     *     - L is numbers lower than the median of medians     *     - U is numbers higher than the median of medians     *  5) Recursive step     *     - if k is the median of medians, return that     *     - Otherwise, recursively search in smaller group.     *     * @param float[] $numbers     * @param int    $k zero indexed - must be less than n (count of $numbers)     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if k â‰¥ n     */    public static function kthSmallest(array $numbers, int $k): float    {        $n = \count($numbers);        if ($n === 0) {            throw new Exception\BadDataException('Cannot find the k-th smallest of an empty list of numbers');        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException('k cannot be greater than or equal to the count of numbers');        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // If the array is 5 elements or smaller, use quicksort and return the element of interest.        if ($n <= 5) {            \sort($numbers);            return $numbers[$k];        }        // Otherwise, we are going to slice $numbers into 5-element slices and find the median of each.        $num_slices = \ceil($n / 5);        $median_array = [];        for ($i = 0; $i < $num_slices; $i++) {            $median_array[] = self::median(\array_slice($numbers, 5 * $i, 5));        }        // Then we find the median of the medians.        $median_of_medians = self::median($median_array);        // Next we walk the array and separate it into values that are greater than or less than this ""median of medians"".        $lower_upper   = self::splitAtValue($numbers, $median_of_medians);        $lower_number = \count($lower_upper['lower']);        $equal_number = $lower_upper['equal'];        // Lastly, we find which group of values our value of interest is in, and find it in the smaller array.        if ($k < $lower_number) {            return self::kthSmallest($lower_upper['lower'], $k);        } elseif ($k < ($lower_number + $equal_number)) {            return $median_of_medians;        } else {            return self::kthSmallest($lower_upper['upper'], $k - $lower_number - $equal_number);        }    }    /**     * Given an array and a value, separate the array into two groups,     * those values which are greater than the value, and those that are less     * than the value. Also, tell how many times the value appears in the array.     *     * @param float[] $numbers     * @param float   $value     *     * @return array     */    private static function splitAtValue(array $numbers, float $value): array    {        $lower        = [];        $upper        = [];        $number_equal = 0;        foreach ($numbers as $number) {            if ($number < $value) {                $lower[] = $number;            } elseif ($number > $value) {                $upper[] = $number;            } else {                $number_equal++;            }        }        return [            'lower' => $lower,            'upper' => $upper,            'equal' => $number_equal,        ];    }    /**     * Calculate the mode average of a list of numbers     * If multiple modes (bimodal, trimodal, etc.), all modes will be returned.     * Always returns an array, even if only one mode.     *     * @param float[] $numbers     *     * @return float[] of mode(s)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function mode(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the mode of an empty list of numbers');        }        // Count how many times each number occurs.        // Determine the max any number occurs.        // Find all numbers that occur max times.        $number_strings = \array_map('\strval', $numbers);        $number_counts  = \array_count_values($number_strings);        $max            = \max($number_counts);        $modes          = array();        foreach ($number_counts as $number => $count) {            if ($count === $max) {                $modes[] = $number;            }        }        // Cast back to numbers        return \array_map('\floatval', $modes);    }    /**     * Geometric mean     * A type of mean which indicates the central tendency or typical value of a set of numbers     * by using the product of their values (as opposed to the arithmetic mean which uses their sum).     * https://en.wikipedia.org/wiki/Geometric_mean     *                    __________     * Geometric mean = â¿âˆšaâ‚€aâ‚aâ‚‚ â‹¯     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function geometricMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the geometric mean of an empty list of numbers');        }        $n       = \count($numbers);        $aâ‚€aâ‚aâ‚‚â‹¯ = \array_reduce(            $numbers,            function ($carry, $a) {                return $carry * $a;            },            1        );        $â¿âˆšaâ‚€aâ‚aâ‚‚â‹¯ = \pow($aâ‚€aâ‚aâ‚‚â‹¯, 1 / $n);        return $â¿âˆšaâ‚€aâ‚aâ‚‚â‹¯;    }    /**     * Harmonic mean (subcontrary mean)     * The harmonic mean can be expressed as the reciprocal of the arithmetic mean of the reciprocals.     * Appropriate for situations when the average of rates is desired.     * https://en.wikipedia.org/wiki/Harmonic_mean     *     *     *        n     * H = ------     *      n  1     *      âˆ‘  -     *     â±â¼Â¹ xáµ¢     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\BadDataException if there are negative numbers     */    public static function harmonicMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the harmonic mean of an empty list of numbers');        }        $negativeValues = \array_filter(            $numbers,            function ($x) {                return $x < 0;            }        );        if (!empty($negativeValues)) {            throw new Exception\BadDataException('Harmonic mean cannot be computed for negative values.');        }        $n      = \count($numbers);        $âˆ‘1ï¼xáµ¢ = \array_sum(Map\Single::reciprocal($numbers));        return $n / $âˆ‘1ï¼xáµ¢;    }    /**     * Contraharmonic mean     * A function complementary to the harmonic mean.     * A special case of the Lehmer mean, Lâ‚‚(x), where p = 2.     * https://en.wikipedia.org/wiki/Contraharmonic_mean     *     * @param  float[] $numbers     *     * @return float     */    public static function contraharmonicMean(array $numbers): float    {        $p = 2;        return self::lehmerMean($numbers, $p);    }    /**     * Root mean square (quadratic mean)     * The square root of the arithmetic mean of the squares of a set of numbers.     * https://en.wikipedia.org/wiki/Root_mean_square     *           ___________     *          /xâ‚+Â²xâ‚‚Â²+ â‹¯     * x rms = / -----------     *        âˆš       n     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function rootMeanSquare(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the root mean square of an empty list of numbers');        }        $n = \count($numbers);        $xâ‚Â²ï¼‹xâ‚‚Â²ï¼‹â‹¯ = \array_sum(\array_map(            function ($x) {                return $x ** 2;            },            $numbers        ));        return \sqrt($xâ‚Â²ï¼‹xâ‚‚Â²ï¼‹â‹¯ / $n);    }    /**     * Quadradic mean (root mean square)     * Convenience function for rootMeanSquare     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quadraticMean(array $numbers): float    {        return self::rootMeanSquare($numbers);    }    /**     * Trimean (TM, or Tukey's trimean)     * A measure of a probability distribution's location defined as     * a weighted average of the distribution's median and its two quartiles.     * https://en.wikipedia.org/wiki/Trimean     *     *      Qâ‚ + 2Qâ‚‚ + Qâ‚ƒ     * TM = -------------     *            4     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function trimean(array $numbers): float    {        $quartiles = Descriptive::quartiles($numbers);        $Qâ‚        = $quartiles['Q1'];        $Qâ‚‚        = $quartiles['Q2'];        $Qâ‚ƒ        = $quartiles['Q3'];        return ($Qâ‚ + 2 * $Qâ‚‚ + $Qâ‚ƒ) / 4;    }    /**     * Interquartile mean (IQM)     * A measure of central tendency based on the truncated mean of the interquartile range.     * Only the data in the second and third quartiles is used (as in the interquartile range),     * and the lowest 25% and the highest 25% of the scores are discarded.     * https://en.wikipedia.org/wiki/Interquartile_mean     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\OutOfBoundsException     */    public static function interquartileMean(array $numbers): float    {        return self::truncatedMean($numbers, 25);    }    /**     * IQM (Interquartile mean)     * Convenience function for interquartileMean     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\OutOfBoundsException     */    public static function iqm(array $numbers): float    {        return self::truncatedMean($numbers, 25);    }    /**     * Cubic mean     * https://en.wikipedia.org/wiki/Cubic_mean     *              _________     *             / 1  n     * x cubic = Â³/  -  âˆ‘ xáµ¢Â³     *           âˆš   n â±â¼Â¹     *     * @param array $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function cubicMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the cubic mean of an empty list of numbers');        }        $n    = \count($numbers);        $âˆ‘xáµ¢Â³ = \array_sum(Map\Single::cube($numbers));        return \pow($âˆ‘xáµ¢Â³ / $n, 1 / 3);    }    /**     * Truncated mean (trimmed mean)     * The mean after discarding given parts of a probability distribution or sample     * at the high and low end, and typically discarding an equal amount of both.     * This number of points to be discarded is given as a percentage of the total number of points.     * https://en.wikipedia.org/wiki/Truncated_mean     *     * Trim count = floor( (trim percent / 100) * sample size )     *     * For example: [8, 3, 7, 1, 3, 9] with a trim of 20%     * First sort the list: [1, 3, 3, 7, 8, 9]     * Sample size = 6     * Then determine trim count: floot(20/100 * 6 ) = 1     * Trim the list by removing 1 from each end: [3, 3, 7, 8]     * Finally, find the mean: 5.2     *     * @param float[] $numbers     * @param int     $trim_percent Percent between 0-99     *     * @return float     *     * @throws Exception\OutOfBoundsException if trim percent is not between 0 and 99     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function truncatedMean(array $numbers, int $trim_percent): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the truncated mean of an empty list of numbers');        }        if ($trim_percent < 0 || $trim_percent > 99) {            throw new Exception\OutOfBoundsException('Trim percent must be between 0 and 99.');        }        $n          = \count($numbers);        $trim_count = \floor($n * ($trim_percent / 100));        \sort($numbers);        for ($i = 1; $i <= $trim_count; $i++) {            \array_shift($numbers);            \array_pop($numbers);        }        return self::mean($numbers);    }    /**     * Lehmer mean     * https://en.wikipedia.org/wiki/Lehmer_mean     *     *          âˆ‘xáµ¢áµ–     * Lp(x) = ------     *         âˆ‘xáµ¢áµ–â»Â¹     *     * Special cases:     *  L-âˆž(x) is the min(x)     *  Lâ‚€(x) is the harmonic mean     *  LÂ½(xâ‚€, xâ‚) is the geometric mean if computed against two numbers     *  Lâ‚(x) is the arithmetic mean     *  Lâ‚‚(x) is the contraharmonic mean     *  Lâˆž(x) is the max(x)     *     * @param  float[] $numbers     * @param  float   $p     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function lehmerMean(array $numbers, $p): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the lehmer mean of an empty list of numbers');        }        // Special cases for infinite p        if ($p == -\INF) {            return \min($numbers);        }        if ($p == \INF) {            return \max($numbers);        }        // Standard case for non-infinite p        $âˆ‘xáµ¢áµ–   = \array_sum(Map\Single::pow($numbers, $p));        $âˆ‘xáµ¢áµ–â»Â¹ = \array_sum(Map\Single::pow($numbers, $p - 1));        return $âˆ‘xáµ¢áµ– / $âˆ‘xáµ¢áµ–â»Â¹;    }    /**     * Generalized mean (power mean, HÃ¶lder mean)     * https://en.wikipedia.org/wiki/Generalized_mean     *     *          / 1  n    \ 1/p     * Mp(x) = |  -  âˆ‘ xáµ¢áµ–|     *          \ n â±â¼Â¹   /     *     * Special cases:     *  M-âˆž(x) is \min(x)     *  Mâ‚‹â‚(x) is the harmonic mean     *  Mâ‚€(x) is the geometric mean     *  Mâ‚(x) is the arithmetic mean     *  Mâ‚‚(x) is the quadratic mean     *  Mâ‚ƒ(x) is the cubic mean     *  Mâˆž(x) is max(X)     *     * @param  float[] $numbers     * @param  float   $p     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function generalizedMean(array $numbers, float $p): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the generalized mean of an empty list of numbers');        }        // Special cases for infinite p        if ($p == -\INF) {            return \min($numbers);        }        if ($p == \INF) {            return \max($numbers);        }        // Special case for p = 0 (geometric mean)        if ($p == 0) {            return self::geometricMean($numbers);        }        // Standard case for non-infinite p        $n    = \count($numbers);        $âˆ‘xáµ¢áµ– = \array_sum(Map\Single::pow($numbers, $p));        return \pow($âˆ‘xáµ¢áµ– / $n, 1 / $p);    }    /**     * Power mean (generalized mean)     * Convenience method for generalizedMean     *     * @param  float[] $numbers     * @param  float $p     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function powerMean(array $numbers, float $p): float    {        return self::generalizedMean($numbers, $p);    }    /**************************************************************************     * Moving averages (list of numbers)     **************************************************************************/    /**     * Simple n-point moving average SMA     * The unweighted mean of the previous n data.     *     * First calculate initial average:     *  â¿â»Â¹     *   âˆ‘ xáµ¢     *  áµ¢â‚Œâ‚€     *     * To calculating successive values, a new value comes into the sum and an old value drops out:     *  SMAtoday = SMAyesterday + NewNumber/N - DropNumber/N     *     * @param  float[] $numbers     * @param  int     $n       n-point moving average     *     * @return float[] of averages for each n-point time period     */    public static function simpleMovingAverage(array $numbers, int $n): array    {        $m   = \count($numbers);        $SMA = [];        // Counters        $new       = $n; // New value comes into the sum        $drop      = 0;  // Old value drops out        $yesterday = 0;  // Yesterday's SMA        // Base case: initial average        $SMA[] = \array_sum(\array_slice($numbers, 0, $n)) / $n;        // Calculating successive values: New value comes in; old value drops out        while ($new < $m) {            $SMA[] = $SMA[$yesterday] + ($numbers[$new] / $n) - ($numbers[$drop] / $n);            $drop++;            $yesterday++;            $new++;        }        return $SMA;    }    /**     * Cumulative moving average (CMA)     *     * Base case for initial average:     *         xâ‚€     *  CMAâ‚€ = --     *         1     *     * Standard case:     *         xáµ¢ + (i * CMAáµ¢â‚‹â‚)     *  CMAáµ¢ = -----------------     *              i + 1     *     * @param  float[] $numbers     *     * @return float[] of cumulative averages     */    public static function cumulativeMovingAverage(array $numbers): array    {        $m   = \count($numbers);        $CMA = [];        // Base case: first average is just itself        $CMA[] = $numbers[0];        for ($i = 1; $i < $m; $i++) {            $CMA[] = (($numbers[$i]) + ($CMA[$i - 1] * $i)) / ($i + 1);        }        return $CMA;    }    /**     * Weighted n-point moving average (WMA)     *     * Similar to simple n-point moving average,     * however, each n-point has a weight associated with it,     * and instead of dividing by n, we divide by the sum of the weights.     *     * Each weighted average = âˆ‘(weighted values) / âˆ‘(weights)     *     * @param  array  $numbers     * @param  int    $n       n-point moving average     * @param  array  $weights Weights for each n points     *     * @return array of averages     *     * @throws Exception\BadDataException if number of weights is not equal to number of n-points     */    public static function weightedMovingAverage(array $numbers, int $n, array $weights): array    {        if (\count($weights) !== $n) {            throw new Exception\BadDataException('Number of weights must equal number of n-points');        }        $m   = \count($numbers);        $âˆ‘w  = \array_sum($weights);        $WMA = [];        for ($i = 0; $i <= $m - $n; $i++) {            $âˆ‘wp   = \array_sum(Map\Multi::multiply(\array_slice($numbers, $i, $n), $weights));            $WMA[] = $âˆ‘wp / $âˆ‘w;        }        return $WMA;    }    /**     * Exponential moving average (EMA)     *     * The start of the EPA is seeded with the first data point.     * Then each day after that:     *  EMAtoday = Î±â‹…xtoday + (1-Î±)EMAyesterday     *     *   where     *    Î±: coefficient that represents the degree of weighting decrease, a constant smoothing factor between 0 and 1.     *     * @param array  $numbers     * @param int    $n       Length of the EPA     *     * @return array of exponential moving averages     */    public static function exponentialMovingAverage(array $numbers, int $n): array    {        $m   = \count($numbers);        $Î±   = 2 / ($n + 1);        $EMA = [];        // Start off by seeding with the first data point        $EMA[] = $numbers[0];        // Each day after: EMAtoday = Î±â‹…xtoday + (1-Î±)EMAyesterday        for ($i = 1; $i < $m; $i++) {            $EMA[] = ($Î± * $numbers[$i]) + ((1 - $Î±) * $EMA[$i - 1]);        }        return $EMA;    }    /**************************************************************************     * Averages of two numbers     **************************************************************************/    /**     * Arithmetic-Geometric mean     *     * First, compute the arithmetic and geometric means of x and y, calling them aâ‚ and gâ‚ respectively.     * Then, use iteration, with aâ‚ taking the place of x and gâ‚ taking the place of y.     * Both a and g will converge to the same mean.     * https://en.wikipedia.org/wiki/Arithmetic%E2%80%93geometric_mean     *     * x and y â‰¥ 0     * If x or y = 0, then agm = 0     * If x or y < 0, then NaN     *     * @param  float $x     * @param  float $y     *     * @return float     */    public static function arithmeticGeometricMean(float $x, float $y): float    {        // x or y < 0 = NaN        if ($x < 0 || $y < 0) {            return \NAN;        }        // x or y zero = 0        if ($x == 0 || $y == 0) {            return 0;        }        // Standard case x and y > 0        [$a, $g] = [$x, $y];        for ($i = 0; $i <= 10; $i++) {            [$a, $g] = [self::mean([$a, $g]), self::geometricMean([$a, $g])];        }        return $a;    }    /**     * Convenience method for arithmeticGeometricMean     *     * @param  float $x     * @param  float $y     *     * @return float     */    public static function agm(float $x, float $y): float    {        return self::arithmeticGeometricMean($x, $y);    }    /**     * Logarithmic mean     * A function of two non-negative numbers which is equal to their     * difference divided by the logarithm of their quotient.     *     * https://en.wikipedia.org/wiki/Logarithmic_mean     *     *  Mlm(x, y) = 0 if x = 0 or y = 0     *              x if x = y     *  otherwise:     *                y - x     *             -----------     *             ln y - ln x     *     * @param  float $x     * @param  float $y     *     * @return float     */    public static function logarithmicMean(float $x, float $y): float    {        if ($x == 0 || $y == 0) {            return 0;        }        if ($x == $y) {            return $x;        }        return ($y - $x) / (\log($y) - \log($x));    }    /**     * Heronian mean     * https://en.wikipedia.org/wiki/Heronian_mean     *            __     * H = â…“(A + âˆšAB + B)     *     * @param  float $A     * @param  float $B     *     * @return float     */    public static function heronianMean(float $A, float $B): float    {        return 1 / 3 * ($A + \sqrt($A * $B) + $B);    }    /**     * Identric mean     * https://en.wikipedia.org/wiki/Identric_mean     *                 ____     *          1     / xË£     * I(x,y) = - Ë£â»Ê¸/  --     *          â„¯   âˆš   yÊ¸     *     * @param  float $x     * @param  float $y     *     * @return float     *     * @throws Exception\OutOfBoundsException if x or y is â‰¤ 0     */    public static function identricMean(float $x, float $y): float    {        // x and y must be positive        if ($x <= 0 || $y <= 0) {            throw new Exception\OutOfBoundsException('x and y must be positive real numbers.');        }        // Special case: x if x = y        if ($x == $y) {            return $x;        }        // Standard case        $â„¯  = \M_E;        $xË£ = $x ** $x;        $yÊ¸ = $y ** $y;        return 1 / $â„¯ * \pow($xË£ / $yÊ¸, 1 / ($x - $y));    }    /**     * Get a report of all the averages over a list of numbers     * Includes mean, median mode, geometric mean, harmonic mean, quardratic mean     *     * @param array $numbers     *     * @return array [ mean, median, mode, geometric_mean, harmonic_mean,     *                 contraharmonic_mean, quadratic_mean, trimean, iqm, cubic_mean ]     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function describe(array $numbers): array    {        return [            'mean'                => self::mean($numbers),            'median'              => self::median($numbers),            'mode'                => self::mode($numbers),            'geometric_mean'      => self::geometricMean($numbers),            'harmonic_mean'       => self::harmonicMean($numbers),            'contraharmonic_mean' => self::contraharmonicMean($numbers),            'quadratic_mean'      => self::quadraticMean($numbers),            'trimean'             => self::trimean($numbers),            'iqm'                 => self::iqm($numbers),            'cubic_mean'          => self::cubicMean($numbers),        ];    }}",0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RegularGridInterpolator_3003," Find the indicies and norm distances for search point\\n\\n @param float[] $xi 1-dimensional array ( search point = [x,y,z ....] )\\n\\n @return array[] (indices in grid for search point, normDistances for search point)\\n",Pronađite indekse i normativne udaljenosti za tačku pretraživanja,"    private function findIndices($xi): array    {        $indices       = [];  // Find relevant edges between which xi are situated        $normDistances = [];  // Compute distance to lower edge in unity units        // Iterate through dimensions x-y-z-...>        // $grid - 1nd array, example all x values (or all y..)        // $x float, search point: x or y or z...        foreach (Iter::zip($xi, $this->grid) as [$x, $grid]) {            $gridSize = \count($grid);                       // Column count            $i        = Search::sorted($grid, $x) - 1;  // Min match index            if ($i < 0) {                $i = 0;            }            if ($i > $gridSize - 2) {                $i = $gridSize - 2;            }            $indices[]       = $i;            $lessValue       = $grid[$i];            $greaterValue    = $grid[$i + 1];            $normDistances[] = ($x - $lessValue) / ($greaterValue - $lessValue);        }        return [$indices, $normDistances];    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_BaseYii_998, Configures an object with the initial property values.\\n @param object $object the object to be configured\\n @param array $properties the property initial values given in terms of name-value pairs.\\n @return object the object itself\\n,Konfiguriše objekat sa početnim vrednostima svojstava,"class ClassmapController extends Controller{    public $defaultAction = 'create';    /**     * Creates a class map for the core Yii classes.     * @param string $root    the root path of Yii framework. Defaults to YII2_PATH.     * @param string $mapFile the file to contain the class map. Defaults to YII2_PATH . '/classes.php'.     */    public function actionCreate($root = null, $mapFile = null)    {        if ($root === null) {            $root = YII2_PATH;        }        $root = FileHelper::normalizePath($root);        if ($mapFile === null) {            $mapFile = YII2_PATH . '/classes.php';        }        $options = [            'filter' => function ($path) {                if (is_file($path)) {                    $file = basename($path);                    if ($file[0] < 'A' || $file[0] > 'Z') {                        return false;                    }                }                return null;            },            'only' => ['*.php'],            'except' => [                '/Yii.php',                '/BaseYii.php',                '/console/',                '/requirements/',            ],        ];        $files = FileHelper::findFiles($root, $options);        $map = [];        foreach ($files as $file) {            if (strpos($file, $root) !== 0) {                throw new Exception(""Something wrong: $file\n"");            }            $path = str_replace('\\', '/', substr($file, \strlen($root)));            $map[$path] = ""  'yii"" . substr(str_replace('/', '\\', $path), 0, -4) . ""' => YII2_PATH . '$path',"";        }        ksort($map);        $map = implode(""\n"", $map);        $output = <<<EOD<?php/** * Yii core class map. * * This file is automatically generated by the ""build classmap"" command under the ""build"" folder. * Do not modify it directly. * * @link http://www.yiiframework.com/ * @copyright Copyright (c) 2008 Yii Software LLC * @license http://www.yiiframework.com/license/ */return [$map];EOD;        if (is_file($mapFile) && file_get_contents($mapFile) === $output) {            echo ""Nothing changed.\n"";        } else {            file_put_contents($mapFile, $output);            echo ""Class map saved in $mapFile\n"";        }    }}",0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_ReleaseController_979, Extract changelog content for a specific version.\\n @param string $file\\n @param string $version\\n @return array\\n,Izdvoja sadržaj changelog-a  za određenu verziju,"    protected function resortChangelog($changelog)    {        // cleanup whitespace        foreach ($changelog as $i => $line) {            $changelog[$i] = rtrim($line);        }        $changelog = array_filter($changelog);        $i = 0;        ArrayHelper::multisort($changelog, function ($line) use (&$i) {            if (preg_match('/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/', $line, $m)) {                $o = ['Bug' => 'C', 'Enh' => 'D', 'Chg' => 'E', 'New' => 'F'];                return $o[$m[1]] . ' ' . (!empty($m[2]) ? $m[2] : 'AAAA' . $i++);            }            return 'B' . $i++;        }, SORT_ASC, SORT_NATURAL);        // re-add leading and trailing lines        array_unshift($changelog, '');        $changelog[] = '';        $changelog[] = '';        return $changelog;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Debugger_1486, Initialize the debugger\\n\\n @return $this\\n @throws DebugBarException\\n,Inicijalizacija debagera,"    public function init()    {        if ($this->initialized) {            return $this;        }        $this->grav = Grav::instance();        $this->config = $this->grav['config'];        // Enable/disable debugger based on configuration.        $this->enabled = (bool)$this->config->get('system.debugger.enabled');        $this->censored = (bool)$this->config->get('system.debugger.censored', false);        if ($this->enabled) {            $this->initialized = true;            $clockwork = $debugbar = null;            switch ($this->config->get('system.debugger.provider', 'debugbar')) {                case 'clockwork':                    $this->clockwork = $clockwork = new Clockwork();                    break;                default:                    $this->debugbar = $debugbar = new DebugBar();            }            $plugins_config = (array)$this->config->get('plugins');            ksort($plugins_config);            if ($clockwork) {                $log = $this->grav['log'];                $clockwork->setStorage(new FileStorage('cache://clockwork'));                if (extension_loaded('xdebug')) {                    $clockwork->addDataSource(new XdebugDataSource());                }                if ($log instanceof Logger) {                    $clockwork->addDataSource(new MonologDataSource($log));                }                $timeline = $clockwork->timeline();                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Server');                    $event->finalize($this->requestTime, GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Loading');                    $event->finalize(GRAV_REQUEST_TIME, $this->currentTime);                }                $event = $timeline->event('Site Setup');                $event->finalize($this->currentTime, microtime(true));            }            if ($this->censored) {                $censored = ['CENSORED' => true];            }            if ($debugbar) {                $debugbar->addCollector(new PhpInfoCollector());                $debugbar->addCollector(new MessagesCollector());                if (!$this->censored) {                    $debugbar->addCollector(new RequestDataCollector());                }                $debugbar->addCollector(new TimeDataCollector($this->requestTime));                $debugbar->addCollector(new MemoryCollector());                $debugbar->addCollector(new ExceptionsCollector());                $debugbar->addCollector(new ConfigCollector($censored ?? (array)$this->config->get('system'), 'Config'));                $debugbar->addCollector(new ConfigCollector($censored ?? $plugins_config, 'Plugins'));                $debugbar->addCollector(new ConfigCollector($this->config->get('streams.schemes'), 'Streams'));                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Server', $debugbar['time']->getRequestStartTime(), GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Loading', GRAV_REQUEST_TIME, $this->currentTime);                }                $debugbar['time']->addMeasure('Site Setup', $this->currentTime, microtime(true));            }            $this->addMessage('Grav v' . GRAV_VERSION . ' - PHP ' . PHP_VERSION);            $this->config->debug();            if ($clockwork) {                $clockwork->info('System Configuration', $censored ?? $this->config->get('system'));                $clockwork->info('Plugins Configuration', $censored ?? $plugins_config);                $clockwork->info('Streams', $this->config->get('streams.schemes'));            }        }        return $this;    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Correlation_3480, Ï„ - Kendall rank correlation coefficient (Kendall's tau)\\n\\n A statistic used to measure the ordinal association between two\\n measured quantities. It is a measure of rank correlation:\\n the similarity of the orderings of the data when ranked by each\\n of the quantities.\\n https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient\\n https://onlinecourses.science.psu.edu/stat509/node/158\\n\\n tau-a (no rank ties):\\n\\n        nc - nd\\n   Ï„ = ----------\\n       n(n - 1)/2\\n\\n   Where\\n     nc: number of concordant pairs\\n     nd: number of discordant pairs\\n\\n tau-b (rank ties exist):\\n\\n                 nc - nd\\n   Ï„ = -----------------------------\\n       âˆš(nc + nd + Xâ‚€)(nc + nd + Yâ‚€)\\n\\n   Where\\n     Xâ‚€: number of pairs tied only on the X variable\\n     Yâ‚€: number of pairs tied only on the Y variable\\n\\n @param array $X values for random variable X\\n @param array $Y values for random variable Y\\n\\n @todo Implement with algorithm faster than O(nÂ²)\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if both random variables do not have the same number of elements\\n,Kendallov koeficijent korelacije ranga (Kendallov tau) Statistika koja se koristi za merenje redne povezanosti između dve izmerene veličine. To je mera korelacije ranga: sličnost redosleda podataka kada ih rangira svaka količina,"    public static function kendallsTau(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('Both random variables must have the same number of elements');        }        $n = \count($X);        // Match X and Y pairs and sort by X rank        $xy = \array_map(            function ($x, $y) {                return [$x, $y];            },            $X,            $Y        );        \usort($xy, function ($a, $b) {            return $a[0] <=> $b[0];        });        // Initialize counters        $nc      = 0;  // concordant pairs        $nd      = 0;  // discordant pairs        $ties_x  = 0;  // ties xáµ¢ = xâ±¼        $ties_y  = 0;  // ties yáµ¢ = yâ±¼        $ties_xy = 0;  // ties xáµ¢ = xâ±¼ and yáµ¢ = yâ±¼        // Tally concordant, discordant, and tied pairs        for ($i = 0; $i < $n; $i++) {            for ($j = $i + 1; $j < $n; $j++) {                // xáµ¢ = xâ±¼ and yáµ¢ = yâ±¼ -- neither concordant or discordant                if ($xy[$i][self::X] == $xy[$j][self::X] && $xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_xy++;                // xáµ¢ = xâ±¼ -- neither concordant or discordant                } elseif ($xy[$i][self::X] == $xy[$j][self::X]) {                    $ties_x++;                // yáµ¢ = yâ±¼ -- neither concordant or discordant                } elseif ($xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_y++;                // xáµ¢ < xâ±¼ and yáµ¢ < yâ±¼ -- concordant                } elseif ($xy[$i][self::X] < $xy[$j][self::X] && $xy[$i][self::Y] < $xy[$j][self::Y]) {                    $nc++;                // xáµ¢ > xâ±¼ and yáµ¢ < yâ±¼ or  xáµ¢ < xâ±¼ and yáµ¢ > yâ±¼ -- discordant                } else {                    $nd++;                }            }        }        // Numerator: (number of concordant pairs) - (number of discordant pairs)        $âŸ®ncÂ âˆ’Â ndâŸ¯ = $nc - $nd;        /* tau-a (no rank ties):         *         *        nc - nd         *   Ï„ = ----------         *       n(n - 1)/2         */        if ($ties_x == 0 && $ties_y == 0) {            return $âŸ®ncÂ âˆ’Â ndâŸ¯ / (($n * ($n - 1)) / 2);        }        /* tau-b (rank ties exist):         *         *                 nc - nd         *   Ï„ = -----------------------------         *       âˆš(nc + nd + Xâ‚€)(nc + nd + Yâ‚€)         */        return $âŸ®ncÂ âˆ’Â ndâŸ¯ / \sqrt(($nc + $nd + $ties_x) * ($nc + $nd + $ties_y));    }",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_CorsController_1436, WhiteLists a domain for CORS\n\n @NoAdminRequired\n @NoSubadminRequired\n\n @param string $domain The domain to whitelist\n @return JSONResponse\n, WhiteLists domen za CORS,"public function addDomain($domain) {if ($this->isValidUrl($domain)) {$userId = $this->userId;$domains = \json_decode($this->config->getUserValue($userId, 'core', 'domains', '[]'), true);$domains = \array_filter($domains);\array_push($domains, $domain);// In case same domain is added$domains = \array_unique($domains);// Store as comma separated string$domainsString = \json_encode($domains);$this->config->setUserValue($userId, 'core', 'domains', $domainsString);$this->logger->debug(""The domain {$domain} has been white-listed."", ['app' => $this->appName]);return new JSONResponse([ 'domains' => $domains]);} else {$errorMsg = $this->l10n->t(""Invalid url '%s'. Urls should be set up like 'http://www.example.com' or 'https://www.example.com'"", \strip_tags($domain));return new JSONResponse([ 'message' => $errorMsg ]);}",0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_InstalledVersions_2524," Returns a list of all package names which are present, either by being installed, replaced or provided\n\n @return string[]\n @psalm-return list<string>\n","Prikazuje listu svih prisutnih imena paketa, bilo instaliranjem, zamenom ili pružanjem","    public static function getInstalledPackages()    {        $packages = array();        foreach (self::getInstalled() as $installed) {            $packages[] = array_keys($installed['versions']);        }        if (1 === \count($packages)) {            return $packages[0];        }        return array_keys(array_flip(\call_user_func_array('array_merge', $packages)));    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_FrameCollection_8407, Exposes a fluent interface for dealing with an ordered list\n of stack-trace frames.\n,Izlaže tečan interfejs koji se bavi uređenom listom stack-trace frejmova,"class FrameCollection implements ArrayAccess, IteratorAggregate, Serializable, Countable{    /**     * @var array[]     */    private $frames;    /**     * @param array $frames     */    public function __construct(array $frames)    {        $this->frames = array_map(function ($frame) {            return new Frame($frame);        }, $frames);    }    /**     * Filters frames using a callable, returns the same FrameCollection     *     * @param  callable        $callable     * @return FrameCollection     */    public function filter($callable)    {        $this->frames = array_values(array_filter($this->frames, $callable));        return $this;    }    /**     * Map the collection of frames     *     * @param  callable        $callable     * @return FrameCollection     */    public function map($callable)    {        // Contain the map within a higher-order callable        // that enforces type-correctness for the $callable        $this->frames = array_map(function ($frame) use ($callable) {            $frame = call_user_func($callable, $frame);            if (!$frame instanceof Frame) {                throw new UnexpectedValueException(                    ""Callable to "" . __CLASS__ . ""::map must return a Frame object""                );            }            return $frame;        }, $this->frames);        return $this;    }    /**     * Returns an array with all frames, does not affect     * the internal array.     *     * @todo   If this gets any more complex than this,     *         have getIterator use this method.     * @see    FrameCollection::getIterator     * @return array     */    public function getArray()    {        return $this->frames;    }    /**     * @see IteratorAggregate::getIterator     * @return ArrayIterator     */    public function getIterator()    {        return new ArrayIterator($this->frames);    }    /**     * @see ArrayAccess::offsetExists     * @param int $offset     */    public function offsetExists($offset)    {        return isset($this->frames[$offset]);    }    /**     * @see ArrayAccess::offsetGet     * @param int $offset     */    public function offsetGet($offset)    {        return $this->frames[$offset];    }    /**     * @see ArrayAccess::offsetSet     * @param int $offset     */    public function offsetSet($offset, $value)    {        throw new \Exception(__CLASS__ . ' is read only');    }    /**     * @see ArrayAccess::offsetUnset     * @param int $offset     */    public function offsetUnset($offset)    {        throw new \Exception(__CLASS__ . ' is read only');    }    /**     * @see Countable::count     * @return int     */    public function count()    {        return count($this->frames);    }    /**     * Count the frames that belongs to the application.     *     * @return int     */    public function countIsApplication()    {        return count(array_filter($this->frames, function (Frame $f) {            return $f->isApplication();        }));    }    /**     * @see Serializable::serialize     * @return string     */    public function serialize()    {        return serialize($this->frames);    }    /**     * @see Serializable::unserialize     * @param string $serializedFrames     */    public function unserialize($serializedFrames)    {        $this->frames = unserialize($serializedFrames);    }    /**     * @param Frame[] $frames Array of Frame instances, usually from $e->getPrevious()     */    public function prependFrames(array $frames)    {        $this->frames = array_merge($frames, $this->frames);    }    /**     * Gets the innermost part of stack trace that is not the same as that of outer exception     *     * @param  FrameCollection $parentFrames Outer exception frames to compare tail against     * @return Frame[]     */    public function topDiff(FrameCollection $parentFrames)    {        $diff = $this->frames;        $parentFrames = $parentFrames->getArray();        $p = count($parentFrames)-1;        for ($i = count($diff)-1; $i >= 0 && $p >= 0; $i--) {            /** @var Frame $tailFrame */            $tailFrame = $diff[$i];            if ($tailFrame->equals($parentFrames[$p])) {                unset($diff[$i]);            }            $p--;        }        return $diff;    }}",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_API_961," Given a segment, will return a list of the most used values for this particular segment.\n @param $segmentName\n @param $idSite\n @throws \\Exception\n @return array\n",Dati segment vratiće listu najčešće korišćenih vrednosti za ovaj određeni segment,"    public function getSuggestedValuesForSegment($segmentName, $idSite)    {        if (empty(Config::getInstance()->General['enable_segment_suggested_values'])) {            return array();        }        Piwik::checkUserHasViewAccess($idSite);        $maxSuggestionsToReturn = 30;        $segment = $this->findSegment($segmentName, $idSite);        // if segment has suggested values callback then return result from it instead        $suggestedValuesCallbackRequiresTable = false;        if (!empty($segment['suggestedValuesApi']) && is_string($segment['suggestedValuesApi']) && !Rules::isBrowserTriggerEnabled()) {            $now = Date::now()->setTimezone(Site::getTimezoneFor($idSite));            if (self::$_autoSuggestLookBack != 60) {                // in Auto suggest tests we need to assume now is in 2018...                // we do - 20 to make sure the year is still correct otherwise could end up being 2017-12-31 and the recorded visits are over several days in the tests we make sure to select the last day a visit was recorded                $now = $now->subDay(self::$_autoSuggestLookBack - 20);            }            // we want to avoid launching the archiver should browser archiving be enabled as this can be very slow... we then rather            // use the live api.            $period = 'year';            $date = $now->toString();            if ($now->toString('m') == '01') {                if (Rules::isArchivingDisabledFor(array($idSite), new Segment('', array($idSite)), 'range')) {                    $date = $now->subYear(1)->toString(); // use previous year data to avoid using range                } else {                    $period = 'range';                    $date = $now->subMonth(1)->toString() . ',' . $now->addDay(1)->toString();                }            }            $apiParts = explode('.', $segment['suggestedValuesApi']);            $meta = $this->getMetadata($idSite, $apiParts[0], $apiParts[1]);            $flat = !empty($meta[0]['actionToLoadSubTables']) && $meta[0]['actionToLoadSubTables'] == $apiParts[1];            $table = Request::processRequest($segment['suggestedValuesApi'], array(                'idSite' => $idSite,                'period' => $period,                'date' => $date,                'segment' => '',                'filter_offset' => 0,                'flat' => (int) $flat,                'filter_limit' => $maxSuggestionsToReturn            ));            if ($table && $table instanceof DataTable && $table->getRowsCount()) {                $values = [];                foreach ($table->getRowsWithoutSummaryRow() as $row) {                    $segment = $row->getMetadata('segment');                    $remove = array(                        $segmentName . Segment\SegmentExpression::MATCH_EQUAL,                        $segmentName . Segment\SegmentExpression::MATCH_STARTS_WITH                    );                    // we don't look at row columns since this could include rows that won't work eg Other summary rows. etc                    // and it is generally not reliable.                    if (!empty($segment) && preg_match('/^' . implode('|',$remove) . '/', $segment)) {                        $values[] = urldecode(urldecode(str_replace($remove, '', $segment)));                    }                }                $values = array_slice($values, 0, $maxSuggestionsToReturn);                $values = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $values);                return $values;            }        }        if (isset($segment['suggestedValuesCallback'])) {            $suggestedValuesCallbackRequiresTable = $this->doesSuggestedValuesCallbackNeedData(                $segment['suggestedValuesCallback']);            if (!$suggestedValuesCallbackRequiresTable) {                return call_user_func($segment['suggestedValuesCallback'], $idSite, $maxSuggestionsToReturn);            }        }        // if period=range is disabled, do not proceed        if (!Period\Factory::isPeriodEnabledForAPI('range')) {            return array();        }        if (!empty($segment['unionOfSegments'])) {            $values = array();            foreach ($segment['unionOfSegments'] as $unionSegmentName) {                $unionSegment = $this->findSegment($unionSegmentName, $idSite, $_showAllSegments = true);                try {                    $result = $this->getSuggestedValuesForSegmentName($idSite, $unionSegment, $maxSuggestionsToReturn);                    if (!empty($result)) {                        $values = array_merge($result, $values);                    }                } catch (\Exception $e) {                    // we ignore if there was no data found for $unionSegmentName                }            }            if (empty($values)) {                throw new \Exception(""There was no data to suggest for $segmentName"");            }        } else {            $values = $this->getSuggestedValuesForSegmentName($idSite, $segment, $maxSuggestionsToReturn);        }        $values = $this->getMostFrequentValues($values);        $values = array_slice($values, 0, $maxSuggestionsToReturn);        $values = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $values);        return $values;    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_786, Returns the list of plugins that archive the given reports.\n\n @param array $archiveNames\n @return array\n,Prikazuje listu dodataka koji arhiviraju date izveštaje,    private function getRequestedPlugins($archiveNames)    {        $result = array();        foreach ($archiveNames as $name) {            $result[] = self::getPluginForReport($name);        }        return array_unique($result);    },0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_FileList_955, Retrieve the filtered file list as an array.\n\n @return array\n,Dohvatite filtriranu listu datoteka kao niz,"    public function getList()    {        $fileList = [];        foreach ($this->fileIterator as $file) {            $fileList[] = str_replace($this->rootPath, '', $file);        }        return $fileList;    }//end getList()",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9832, Gets a list of languages acceptable by the client browser.\n\n @return array Languages ordered in the user browser preferences\n,,"    public function getLanguages()    {        if (null !== $this->languages) {            return $this->languages;        }        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();        $this->languages = [];        foreach ($languages as $lang => $acceptHeaderItem) {            if (false !== strpos($lang, '-')) {                $codes = explode('-', $lang);                if ('i' === $codes[0]) {                    // Language not listed in ISO 639 that are not variants                    // of any listed language, which can be registered with the                    // i-prefix, such as i-cherokee                    if (\count($codes) > 1) {                        $lang = $codes[1];                    }                } else {                    for ($i = 0, $max = \count($codes); $i < $max; ++$i) {                        if (0 === $i) {                            $lang = strtolower($codes[0]);                        } else {                            $lang .= '_'.strtoupper($codes[$i]);                        }                    }                }            }            $this->languages[] = $lang;        }        return $this->languages;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_var-dumper_ArgsStub_9204, Represents a list of function arguments.\n\n @author Nicolas Grekas <p@tchwork.com>\n,Predstavlja listu argumenata funkcije,"final class CliContextProvider implements ContextProviderInterface{    public function getContext(): ?array    {        if ('cli' !== \PHP_SAPI) {            return null;        }        return [            'command_line' => $commandLine = implode(' ', $_SERVER['argv'] ?? []),            'identifier' => hash('crc32b', $commandLine.$_SERVER['REQUEST_TIME_FLOAT']),        ];    }}",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_DevController_956, Get a list of subdirectories for directory specified.\n @param string $dir directory to read\n\n @return array list of subdirectories\n,Dobija listu jezika prihvatljivih za klijentski pregledač,"    protected function listSubDirs($dir)    {        $list = [];        $handle = opendir($dir);        if ($handle === false) {            throw new InvalidParamException(""Unable to open directory: $dir"");        }        while (($file = readdir($handle)) !== false) {            if ($file === '.' || $file === '..') {                continue;            }            // ignore hidden directories            if (strpos($file, '.') === 0) {                continue;            }            if (is_dir(""$dir/$file"")) {                $list[] = ""$dir/$file"";            }        }        closedir($handle);        return $list;    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_CachedObjectStorageFactory_132, Return the list of all available cache storage methods\\n\\n @return string[]\\n,Vratite listu svih dostupnih metoda keš memorije,"    public static function getCacheStorageMethods()    {        $activeMethods = array();        foreach (self::$storageMethods as $storageMethod) {            $cacheStorageClass = 'PHPExcel_CachedObjectStorage_' . $storageMethod;            if (call_user_func(array($cacheStorageClass, 'cacheMethodIsAvailable'))) {                $activeMethods[] = $storageMethod;            }        }        return $activeMethods;    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_198, Get postgresql db options\n,Dohvatite postgresql db opcije,"    function getOptionsPostgresql(): array    {        return [            'host'     => env('DATA_POSTGRES_HOST'),            'username' => env('DATA_POSTGRES_USER'),            'password' => env('DATA_POSTGRES_PASS'),            'port'     => env('DATA_POSTGRES_PORT'),            'dbname'   => env('DATA_POSTGRES_NAME'),            'schema'   => env('DATA_POSTGRES_SCHEMA'),        ];    }",0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_200, Get sqlite db options\n,Dohvatite sqlite db opcije,"    function getOptionsSqlite(): array    {        return [            'dbname' => codecept_root_dir(env('DATA_SQLITE_NAME')),        ];    }",0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_functions_2095, Get mysql db options\n,Dohvatite mzsql db opcije,"    function getOptionsMysql(): array    {        return [            'host'     => env('DATA_MYSQL_HOST'),            'username' => env('DATA_MYSQL_USER'),            'password' => env('DATA_MYSQL_PASS'),            'dbname'   => env('DATA_MYSQL_NAME'),            'port'     => env('DATA_MYSQL_PORT'),            'charset'  => env('DATA_MYSQL_CHARSET'),        ];    }",0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_MatrixFactory_2688, Matrix factory to create matrices of all types.\n Use factory instead of instantiating individual Matrix classes.\n,Fabrika matrica za stvaranje matrica svih tipova. Koristitite fabriku umesto instanciranja pojedinačnih klasa matrica,"class MatrixFactory{    /**     * Factory method     *     * @param  number[][] $A 2-dimensional array of Matrix data     * @param float|null $Îµ Optional error tolerance     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public static function create(array $A, ?float $Îµ = null): Matrix    {        self::checkParams($A);        $matrix_type = self::determineMatrixType($A);        switch ($matrix_type) {            case 'numeric':            case 'numeric_square':                return self::createNumeric($A, $Îµ);            case 'complex':                return new ComplexMatrix($A);            case 'object':                return new ObjectMatrix($A);            case 'object_square':                return new ObjectSquareMatrix($A);        }        throw new Exception\IncorrectTypeException('Unknown matrix type: ' . print_r($A, true));    }    /**     * @param number[][] $A     * @param float|null $Îµ Optional error tolerance     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     */    public static function createNumeric(array $A, ?float $Îµ = null): NumericMatrix    {        $m = \count($A);        $n = \count($A[0]);        if ($m === $n) {            $A = new NumericSquareMatrix($A);            $A->setError($Îµ);            return $A;        }        $A = new NumericMatrix($A);        $A->setError($Îµ);        return $A;    }    /**     * Factory method to create a matrix from an array of Vectors     *     * Example:     *        [1]       [4]        [7]       [8]     *   Xâ‚ = [2]  Xâ‚‚ = [2]   Xâ‚ƒ = [8]  Xâ‚„ = [4]     *        [1]       [13]       [1]       [5]     *     *       [1  4 7 8]     *   R = [2  2 8 4]     *       [1 13 1 5]     *     * @param  Vector[] $A array of Vectors     * @param float|null $Îµ Optional error tolerance     *     * @return Matrix     *     * @throws Exception\MatrixException if the Vectors are not all the same length     * @throws Exception\IncorrectTypeException     * @throws Exception\BadDataException     */    public static function createFromVectors(array $A, ?float $Îµ = null): NumericMatrix    {        // Check that all vectors are the same length        $m = $A[0]->getN();        $n = \count($A);        for ($j = 1; $j < $n; $j++) {            if ($A[$j]->getN() !== $m) {                throw new Exception\MatrixException('Vectors being combined into matrix have different lengths');            }        }        // Concatenate all the vectors        $R = [];        foreach ($A as $V) {            $R[] = $V->getVector();        }        // Transpose to create matrix from the vector columns        return (self::createNumeric($R, $Îµ))->transpose();    }    /**     * Column vector (column matrix)     * m Ã— 1 matrix consisting of a single column of m elements.     *     *     [xâ‚]     * x = [xâ‚‚]     *     [â‹® ]     *     [xm]     *     * @param array $A m Ã— 1 vector representing the matrix     *     * @return Matrix     */    public static function createFromColumnVector(array $A): Matrix    {        foreach ($A as $item) {            if (\is_array($item)) {                throw new Exception\BadDataException('Column vector data must be a one-dimensional array');            }        }        $R = [];        foreach ($A as $value) {            $R[] = [$value];        }        return self::create($R);    }    /**     * Row vector (row matrix)     * 1 Ã— n matrix consisting of a single row of n elements.     *     * x = [xâ‚ xâ‚‚ â‹¯ xn]     *     * @param array $A 1 Ã— n vector representing the matrix     *     * @return Matrix     */    public static function createFromRowVector(array $A): Matrix    {        foreach ($A as $item) {            if (\is_array($item)) {                throw new Exception\BadDataException('Row vector data must be a one-dimensional array');            }        }        $R = [$A];        return self::create($R);    }    /**     * Factory method     *     * @param  array[] $A 2-dimensional array of Matrix data     *     * @return FunctionMatrix     */    public static function createFunctionMatrix(array $A): FunctionMatrix    {        self::checkParams($A);        if (!is_callable($A[0][0])) {            throw new Exception\BadDataException('FunctionMatrix must be made of functions - got ' . gettype($A[0][0]));        }        return new FunctionMatrix($A);    }    /**************************************************************************     * SPECIAL MATRICES - Not created from an array of arrays     *  - identity     *  - exchange     *  - downshiftPermutation     *  - upshiftPermutation     *  - zero     *  - one     *  - eye     *  - diagonal     *  - hilbert     *  - vandermonde     *  - givens     **************************************************************************/    /**     * Identity matrix - n x n matrix with ones in the diagonal     *     * Example:     *  n = 3;     *     *      [1 0 0]     *  A = [0 1 0]     *      [0 0 1]     *     * @param int   $n size of matrix     *     * @return NumericSquareMatrix     *     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function identity(int $n): NumericSquareMatrix    {        if ($n < 0) {            throw new Exception\OutOfBoundsException(""n must be â‰¥ 0. n = $n"");        }        $R = [];        for ($i = 0; $i < $n; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $i == $j ? 1 : 0;            }        }        return new NumericSquareMatrix($R);    }    /**     * Exchange matrix - n x n matrix with ones in the reverse diagonal     * Row-reversed, or column-reversed version of the identity matrix.     * https://en.wikipedia.org/wiki/Exchange_matrix     *     * Example:     *  n = 3;     *     *      [0 0 1]     *  A = [0 1 0]     *      [1 0 0]     *     * @param int $n size of matrix     *     * @return NumericSquareMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function exchange(int $n): NumericSquareMatrix    {        if ($n < 0) {            throw new Exception\OutOfBoundsException(""n must be â‰¥ 0. n = $n"");        }        $R = [];        $one = $n - 1;        for ($i = 0; $i < $n; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $j == $one ? 1 : 0;            }            $one--;        }        return new NumericSquareMatrix($R);    }    /**     * Downshift permutation matrix     * Pushes the components of a vector down one notch with wraparound     *     *       [0, 0, 0, 1] [xâ‚]   [xâ‚„]     *       [1, 0, 0, 0] [xâ‚‚]   [xâ‚]     * Dâ‚„x = [0, 1, 0, 0] [xâ‚ƒ] = [xâ‚‚]     *       [0, 0, 1, 0] [xâ‚„]   [xâ‚ƒ]     *     * @param  int $n     *     * @return NumericSquareMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function downshiftPermutation(int $n): NumericSquareMatrix    {        $I = self::identity($n)->getMatrix();        $bottom_row = \array_pop($I);        \array_unshift($I, $bottom_row);        return new NumericSquareMatrix($I);    }    /**     * Upshift permutation matrix - Dáµ€     * Pushes the components of a vector up one notch with wraparound     *     * @param  int $n     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     */    public static function upshiftPermutation(int $n): Matrix    {        return self::downshiftPermutation($n)->transpose();    }    /**     * Zero matrix - m x n matrix with all elements being zeros     *     * Example:     *  m = 3; n = 3     *     *      [0 0 0]     *  A = [0 0 0]     *      [0 0 0]     *     * @param int $m rows     * @param int $n columns     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m < 1 or n < 1     */    public static function zero(int $m, int $n): NumericMatrix    {        if ($m < 1 || $n < 1) {            throw new Exception\OutOfBoundsException(""m and n must be > 0. m = $m, n = $n"");        }        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 0;            }        }        return self::createNumeric($R);    }    /**     * Ones matrix - m x n matrix with all elements being ones     *     * Example:     *  m = 3; n = 3     *     *      [1 1 1]     *  A = [1 1 1]     *      [1 1 1]     *     * @param int $m rows     * @param int $n columns     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m or n < 1     */    public static function one(int $m, int $n): NumericMatrix    {        if ($m < 1 || $n < 1) {            throw new Exception\OutOfBoundsException(""m and n must be > 0. m = $m, n = $n"");        }        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 1;            }        }        return self::createNumeric($R);    }    /**     * Eye matrix - ones on the k diagonal and zeros everywhere else.     * Diagonal can start at any column.     * Option to set the diagonal to any number.     *     * Example:     *  m = 3; n = 3; k = 1; x = 1 (3x3 matrix with 1s on the kth (1) diagonal)     *     *      [0 1 0]     *  A = [0 0 1]     *      [0 0 0]     *     * @param int        $m number of rows     * @param int        $n number of columns     * @param int        $k Diagonal to fill with xs     * @param float|null $x (optional; default 1)     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m, n, or k are < 0; if k >= n     */    public static function eye(int $m, int $n, int $k, float $x = null): NumericMatrix    {        if ($n < 0 || $m < 0 || $k < 0) {            throw new Exception\OutOfBoundsException(""m, n and k must be â‰¥ 0. m = $m, n = $n, k = $k"");        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException(""k must be < n. k = $k, n = $n"");        }        $x = $x ?? 1;        $R = (self::zero($m, $n))->getMatrix();        for ($i = 0; $i < $m; $i++) {            if (($k + $i) < $n) {                $R[$i][$k + $i] = $x;            }        }        return self::createNumeric($R);    }    /**     * A Diagonal Matrix is constructed from a single-row array.     * The elements of this array are placed on the diagonal of a square matrix.     *     * Example:     *  D = [1, 2, 3]     *     *     [1 0 0]     * A = [0 2 0]     *     [0 0 3]     *     * @param array $D elements of the diagonal     *     * @return NumericDiagonalMatrix     *     * @throws Exception\MatrixException     */    public static function diagonal(array $D): NumericDiagonalMatrix    {        $m = \count($D);        $A = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $m; $j++) {                if ($i == $j) {                    $A[$i][$j] = $D[$i];                } else {                    $A[$i][$j] = 0;                }            }        }        return new NumericDiagonalMatrix($A);    }    /**     * Hilbert matrix - a square matrix with entries being the unit fractions     * https://en.wikipedia.org/wiki/Hilbert_matrix     *     *           1     * Hij = ---------     *       i + j - 1     *     * Example: n = 5     *     *     [1 Â½ â…“ Â¼ â…•]     *     [Â½ â…“ Â¼ â…• â…™]     * H = [â…“ Â¼ â…• â…™ â…]     *     [Â¼ â…• â…™ â… â…›]     *     [â…• â…™ â… â…› â…‘]     *     * @param int $n     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException     */    public static function hilbert(int $n): NumericMatrix    {        if ($n < 1) {            throw new Exception\OutOfBoundsException(""n must be > 0. m = $n"");        }        $H = [];        for ($i = 1; $i <= $n; $i++) {            for ($j = 1; $j <= $n; $j++) {                $H[$i - 1][$j - 1] = 1 / ($i + $j - 1);            }        }        return new NumericSquareMatrix($H);    }    /**     * Create the Vandermonde Matrix from a simple array.     *     * @param array $M (Î±â‚, Î±â‚‚, Î±â‚ƒ â‹¯ Î±m)     * @param int   $n     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public static function vandermonde(array $M, int $n): NumericMatrix    {        $A = [];        foreach ($M as $row => $Î±) {            for ($i = 0; $i < $n; $i++) {                $A[$row][$i] = $Î± ** $i;            }        }        return self::createNumeric($A);    }   /**    * Construct a Givens rotation matrix    *    *               [  1 â‹¯ 0 â‹¯ 0 â‹¯ 0  ]    *               [  â‹® â‹± â‹®   â‹®   â‹®   ]    *               [  0 â‹¯ c â‹¯-s â‹¯ 0  ]    * G (ð’¾,ð’¿,Î¸) =   [  â‹®   â‹®  â‹± â‹®  â‹®  ]    *               [  0 â‹¯ s â‹¯ c â‹¯ 0  ]    *               [  â‹®    â‹®   â‹® â‹± â‹® ]    *               [  0 â‹¯ 0 â‹¯ 0 â‹¯ 1 ]    *    * https://en.wikipedia.org/wiki/Givens_rotation    *    * @param int   $m The row in G in which the top of the rotation lies    * @param int   $n The column in G in which the left of the rotation lies    * @param float $angle The angle to use in the trigonometric functions    * @param int   $size The total number of rows in G    *    * @return NumericMatrix    *    * @throws Exception\BadDataException    * @throws Exception\MathException    * @throws Exception\OutOfBoundsException    */    public static function givens(int $m, int $n, float $angle, int $size): NumericMatrix    {        if ($m >= $size || $n >= $size || $m < 0 || $n < 0) {            throw new Exception\OutOfBoundsException(""m and n must be within the matrix"");        }        $G         = MatrixFactory::identity($size)->getMatrix();        $G[$m][$m] = \cos($angle);        $G[$n][$n] = \cos($angle);        $G[$m][$n] = -1 * \sin($angle);        $G[$n][$m] = \sin($angle);        return self::createNumeric($G);    }    /**     * Create a Matrix of random numbers     *     * @param int $m   number of rows     * @param int $n   number of columns     * @param int $min lower bound for the random number (optional - default: 0)     * @param int $max upper bound for the random number (optional - default: 20)     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     */    public static function random(int $m, int $n, int $min = 0, int $max = 20): NumericMatrix    {        $A = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $A[$i][$j] = \rand($min, $max);            }        }        return self::createNumeric($A);    }    /* ************************************************************************     * PRIVATE HELPER METHODS     * ***********************************************************************/    /**     * Check input parameters     *     * @param  array    $A     *     * @throws Exception\BadDataException if array data not provided for matrix creation     * @throws Exception\MatrixException if any row has a different column count     */    private static function checkParams(array $A): void    {        if (empty($A)) {            throw new Exception\BadDataException('Array data not provided for Matrix creation');        }        if (isset($A[0]) && \is_array($A[0])) {            $column_count = \count($A[0]);            foreach ($A as $i => $row) {                if (\count($row) !== $column_count) {                    throw new Exception\MatrixException(""Row $i has a different column count: "" . \count($row) . ""; was expecting $column_count."");                }            }        }    }    /**     * Determine what type of matrix to create     *     * @param  array[] $A 2-dimensional array of Matrix data     *     * @return string indicating what matrix type to create     */    private static function determineMatrixType(array $A): string    {        $m = \count($A);        $n = \count($A[0]);        // Object (closure) matrices        if (\is_object($A[0][0])) {            if ($A[0][0] instanceof Complex) {                return 'complex';            }            return $m === $n                ? 'object_square'                : 'object';        }        // Numeric matrix        if (\is_numeric($A[0][0])) {            return $m === $n                ? 'numeric_square'                : 'numeric';        }        // Unknown or bad data        return 'unknown';    }}",0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Eigenvector_2617, Find the zero columns\n\n @param  NumericMatrix $M\n\n @return array\n,Pronađite nulte kolone,"    private static function findZeroColumns(NumericMatrix $M): array    {        $m = $M->getM();        $zero_columns = [];        for ($i = 0; $i < $M->getN(); $i++) {            if ($M->getColumn($i) == \array_fill(0, $m, 0)) {                $zero_columns[] = $i;            }        }        return $zero_columns;    }",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2631," Returns the elements on the diagonal of a square matrix as an array\n     [1 2 3]\n A = [4 5 6]\n     [7 8 9]\n\n getDiagonalElements($A) = [1, 5, 9]\n\n @return array\n",Vraća elemente na dijagonali kvadratne matrice kao niz,"    public function getDiagonalElements(): array    {        $diagonal = [];        for ($i = 0; $i < \min($this->m, $this->n); $i++) {            $diagonal[] = $this->A[$i][$i];        }        return $diagonal;    }",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2633," Returns the elements on the subdiagonal of a square matrix as an array\n     [1 2 3]\n A = [4 5 6]\n     [7 8 9]\n\n getSubdiagonalElements($A) = [4, 8]\n\n http://mathworld.wolfram.com/Subdiagonal.html\n\n @return array\n",Vraća elemente na poddijagonali kvadratne matrice kao niz,    public function getSubdiagonalElements(): array    {        $subdiagonal = [];        if ($this->isSquare()) {            for ($i = 1; $i < $this->m; $i++) {                $subdiagonal[] = $this->A[$i][$i - 1];            }        }        return $subdiagonal;    },0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1490, Returns PTY state.\\n\\n @return bool\\n,Vraća PTI stanje,"    public function getWorkingDirectory()    {        if (null === $this->cwd) {            // getcwd() will return false if any one of the parent directories does not have            // the readable or search mode set, even if the current directory does            return getcwd() ?: null;        }        return $this->cwd;    }",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1485, Get the local PsySH config file.\n\n Searches for a project specific config file `.psysh.php` in the current\n working directory.\n\n @return string\n,Dohvatanje lokalne datoteke za konfiguraciju PsiSH. Pretražuje konfiguracionu datoteku specifičnu za projekat `.psish.php` u trenutnom radnom direktorijumu,    public function getLocalConfigFile()    {        $localConfig = \getcwd().'/.psysh.php';        if (@\is_file($localConfig)) {            return $localConfig;        }    },0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_ProcessFailedExceptionTest_1552, Tests ProcessFailedException throws exception if the process was successful.\\\\n,Testovi ProcessFailedException bacaju izuzetak ako je proces bio uspešan,"    public function testDisabledOutputInFailedExceptionDoesNotPopulateOutput()    {        $cmd = 'php';        $exitCode = 1;        $exitText = 'General error';        $workingDirectory = getcwd();        $process = $this->getMockBuilder(Process::class)->setMethods(['isSuccessful', 'isOutputDisabled', 'getExitCode', 'getExitCodeText', 'getOutput', 'getErrorOutput', 'getWorkingDirectory'])->setConstructorArgs([[$cmd]])->getMock();        $process->expects($this->once())            ->method('isSuccessful')            ->willReturn(false);        $process->expects($this->never())            ->method('getOutput');        $process->expects($this->never())            ->method('getErrorOutput');        $process->expects($this->once())            ->method('getExitCode')            ->willReturn($exitCode);        $process->expects($this->once())            ->method('getExitCodeText')            ->willReturn($exitText);        $process->expects($this->once())            ->method('isOutputDisabled')            ->willReturn(true);        $process->expects($this->once())            ->method('getWorkingDirectory')            ->willReturn($workingDirectory);        $exception = new ProcessFailedException($process);        $this->assertEquals(            ""The command \""$cmd\"" failed.\n\nExit Code: $exitCode($exitText)\n\nWorking directory: {$workingDirectory}"",            str_replace(""'php'"", 'php', $exception->getMessage())        );    }",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_871, Processes a long (--example) command line argument.\\n\\n @param string $arg The command line argument.\\n @param int    $pos The position of the argument on the command line.\\n\\n @return void\\n @throws \\\\PHP_CodeSniffer\\\\Exceptions\\\\DeepExitException\\n,Obrađuje dugi (--primer) argument gomandne linije,"    public function processLongArgument($arg, $pos)    {        switch ($arg) {        case 'help':            ob_start();            $this->printUsage();            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'version':            $output  = 'PHP_CodeSniffer version '.self::VERSION.' ('.self::STABILITY.') ';            $output .= 'by Squiz (http://www.squiz.net)'.PHP_EOL;            throw new DeepExitException($output, 0);        case 'colors':            if (isset(self::$overriddenDefaults['colors']) === true) {                break;            }            $this->colors = true;            self::$overriddenDefaults['colors'] = true;            break;        case 'no-colors':            if (isset(self::$overriddenDefaults['colors']) === true) {                break;            }            $this->colors = false;            self::$overriddenDefaults['colors'] = true;            break;        case 'cache':            if (isset(self::$overriddenDefaults['cache']) === true) {                break;            }            if (defined('PHP_CODESNIFFER_IN_TESTS') === false) {                $this->cache = true;                self::$overriddenDefaults['cache'] = true;            }            break;        case 'no-cache':            if (isset(self::$overriddenDefaults['cache']) === true) {                break;            }            $this->cache = false;            self::$overriddenDefaults['cache'] = true;            break;        case 'ignore-annotations':            if (isset(self::$overriddenDefaults['annotations']) === true) {                break;            }            $this->annotations = false;            self::$overriddenDefaults['annotations'] = true;            break;        case 'config-set':            if (isset($this->cliArgs[($pos + 1)]) === false                || isset($this->cliArgs[($pos + 2)]) === false            ) {                $error  = 'ERROR: Setting a config option requires a name and value'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $key     = $this->cliArgs[($pos + 1)];            $value   = $this->cliArgs[($pos + 2)];            $current = self::getConfigData($key);            try {                $this->setConfigData($key, $value);            } catch (\Exception $e) {                throw new DeepExitException($e->getMessage().PHP_EOL, 3);            }            $output = 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            if ($current === null) {                $output .= ""Config value \""$key\"" added successfully"".PHP_EOL;            } else {                $output .= ""Config value \""$key\"" updated successfully; old value was \""$current\"""".PHP_EOL;            }            throw new DeepExitException($output, 0);        case 'config-delete':            if (isset($this->cliArgs[($pos + 1)]) === false) {                $error  = 'ERROR: Deleting a config option requires the name of the option'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $output = 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            $key     = $this->cliArgs[($pos + 1)];            $current = self::getConfigData($key);            if ($current === null) {                $output .= ""Config value \""$key\"" has not been set"".PHP_EOL;            } else {                try {                    $this->setConfigData($key, null);                } catch (\Exception $e) {                    throw new DeepExitException($e->getMessage().PHP_EOL, 3);                }                $output .= ""Config value \""$key\"" removed successfully; old value was \""$current\"""".PHP_EOL;            }            throw new DeepExitException($output, 0);        case 'config-show':            ob_start();            $data = self::getAllConfigData();            echo 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            $this->printConfigData($data);            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'runtime-set':            if (isset($this->cliArgs[($pos + 1)]) === false                || isset($this->cliArgs[($pos + 2)]) === false            ) {                $error  = 'ERROR: Setting a runtime config option requires a name and value'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $key   = $this->cliArgs[($pos + 1)];            $value = $this->cliArgs[($pos + 2)];            $this->cliArgs[($pos + 1)] = '';            $this->cliArgs[($pos + 2)] = '';            self::setConfigData($key, $value, true);            if (isset(self::$overriddenDefaults['runtime-set']) === false) {                self::$overriddenDefaults['runtime-set'] = [];            }            self::$overriddenDefaults['runtime-set'][$key] = true;            break;        default:            if (substr($arg, 0, 7) === 'sniffs=') {                if (isset(self::$overriddenDefaults['sniffs']) === true) {                    break;                }                $sniffs = explode(',', substr($arg, 7));                foreach ($sniffs as $sniff) {                    if (substr_count($sniff, '.') !== 2) {                        $error  = 'ERROR: The specified sniff code ""'.$sniff.'"" is invalid'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                }                $this->sniffs = $sniffs;                self::$overriddenDefaults['sniffs'] = true;            } else if (substr($arg, 0, 8) === 'exclude=') {                if (isset(self::$overriddenDefaults['exclude']) === true) {                    break;                }                $sniffs = explode(',', substr($arg, 8));                foreach ($sniffs as $sniff) {                    if (substr_count($sniff, '.') !== 2) {                        $error  = 'ERROR: The specified sniff code ""'.$sniff.'"" is invalid'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                }                $this->exclude = $sniffs;                self::$overriddenDefaults['exclude'] = true;            } else if (defined('PHP_CODESNIFFER_IN_TESTS') === false                && substr($arg, 0, 6) === 'cache='            ) {                if ((isset(self::$overriddenDefaults['cache']) === true                    && $this->cache === false)                    || isset(self::$overriddenDefaults['cacheFile']) === true                ) {                    break;                }                // Turn caching on.                $this->cache = true;                self::$overriddenDefaults['cache'] = true;                $this->cacheFile = Util\Common::realpath(substr($arg, 6));                // It may not exist and return false instead.                if ($this->cacheFile === false) {                    $this->cacheFile = substr($arg, 6);                    $dir = dirname($this->cacheFile);                    if (is_dir($dir) === false) {                        $error  = 'ERROR: The specified cache file path ""'.$this->cacheFile.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    if ($dir === '.') {                        // Passed cache file is a file in the current directory.                        $this->cacheFile = getcwd().'/'.basename($this->cacheFile);                    } else {                        if ($dir[0] === '/') {                            // An absolute path.                            $dir = Util\Common::realpath($dir);                        } else {                            $dir = Util\Common::realpath(getcwd().'/'.$dir);                        }                        if ($dir !== false) {                            // Cache file path is relative.                            $this->cacheFile = $dir.'/'.basename($this->cacheFile);                        }                    }                }//end if                self::$overriddenDefaults['cacheFile'] = true;                if (is_dir($this->cacheFile) === true) {                    $error  = 'ERROR: The specified cache file path ""'.$this->cacheFile.'"" is a directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if (substr($arg, 0, 10) === 'bootstrap=') {                $files     = explode(',', substr($arg, 10));                $bootstrap = [];                foreach ($files as $file) {                    $path = Util\Common::realpath($file);                    if ($path === false) {                        $error  = 'ERROR: The specified bootstrap file ""'.$file.'"" does not exist'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    $bootstrap[] = $path;                }                $this->bootstrap = array_merge($this->bootstrap, $bootstrap);                self::$overriddenDefaults['bootstrap'] = true;            } else if (substr($arg, 0, 10) === 'file-list=') {                $fileList = substr($arg, 10);                $path     = Util\Common::realpath($fileList);                if ($path === false) {                    $error  = 'ERROR: The specified file list ""'.$fileList.'"" does not exist'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }                $files = file($path);                foreach ($files as $inputFile) {                    $inputFile = trim($inputFile);                    // Skip empty lines.                    if ($inputFile === '') {                        continue;                    }                    $this->processFilePath($inputFile);                }            } else if (substr($arg, 0, 11) === 'stdin-path=') {                if (isset(self::$overriddenDefaults['stdinPath']) === true) {                    break;                }                $this->stdinPath = Util\Common::realpath(substr($arg, 11));                // It may not exist and return false instead, so use whatever they gave us.                if ($this->stdinPath === false) {                    $this->stdinPath = trim(substr($arg, 11));                }                self::$overriddenDefaults['stdinPath'] = true;            } else if (PHP_CODESNIFFER_CBF === false && substr($arg, 0, 12) === 'report-file=') {                if (isset(self::$overriddenDefaults['reportFile']) === true) {                    break;                }                $this->reportFile = Util\Common::realpath(substr($arg, 12));                // It may not exist and return false instead.                if ($this->reportFile === false) {                    $this->reportFile = substr($arg, 12);                    $dir = Util\Common::realpath(dirname($this->reportFile));                    if (is_dir($dir) === false) {                        $error  = 'ERROR: The specified report file path ""'.$this->reportFile.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    $this->reportFile = $dir.'/'.basename($this->reportFile);                }//end if                self::$overriddenDefaults['reportFile'] = true;                if (is_dir($this->reportFile) === true) {                    $error  = 'ERROR: The specified report file path ""'.$this->reportFile.'"" is a directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if (substr($arg, 0, 13) === 'report-width=') {                if (isset(self::$overriddenDefaults['reportWidth']) === true) {                    break;                }                $this->reportWidth = substr($arg, 13);                self::$overriddenDefaults['reportWidth'] = true;            } else if (substr($arg, 0, 9) === 'basepath=') {                if (isset(self::$overriddenDefaults['basepath']) === true) {                    break;                }                self::$overriddenDefaults['basepath'] = true;                if (substr($arg, 9) === '') {                    $this->basepath = null;                    break;                }                $this->basepath = Util\Common::realpath(substr($arg, 9));                // It may not exist and return false instead.                if ($this->basepath === false) {                    $this->basepath = substr($arg, 9);                }                if (is_dir($this->basepath) === false) {                    $error  = 'ERROR: The specified basepath ""'.$this->basepath.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if ((substr($arg, 0, 7) === 'report=' || substr($arg, 0, 7) === 'report-')) {                $reports = [];                if ($arg[6] === '-') {                    // This is a report with file output.                    $split = strpos($arg, '=');                    if ($split === false) {                        $report = substr($arg, 7);                        $output = null;                    } else {                        $report = substr($arg, 7, ($split - 7));                        $output = substr($arg, ($split + 1));                        if ($output === false) {                            $output = null;                        } else {                            $dir = Util\Common::realpath(dirname($output));                            if (is_dir($dir) === false) {                                $error  = 'ERROR: The specified '.$report.' report file path ""'.$output.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                                $error .= $this->printShortUsage(true);                                throw new DeepExitException($error, 3);                            }                            $output = $dir.'/'.basename($output);                            if (is_dir($output) === true) {                                $error  = 'ERROR: The specified '.$report.' report file path ""'.$output.'"" is a directory'.PHP_EOL.PHP_EOL;                                $error .= $this->printShortUsage(true);                                throw new DeepExitException($error, 3);                            }                        }//end if                    }//end if                    $reports[$report] = $output;                } else {                    // This is a single report.                    if (isset(self::$overriddenDefaults['reports']) === true) {                        break;                    }                    $reportNames = explode(',', substr($arg, 7));                    foreach ($reportNames as $report) {                        $reports[$report] = null;                    }                }//end if                // Remove the default value so the CLI value overrides it.                if (isset(self::$overriddenDefaults['reports']) === false) {                    $this->reports = $reports;                } else {                    $this->reports = array_merge($this->reports, $reports);                }                self::$overriddenDefaults['reports'] = true;            } else if (substr($arg, 0, 7) === 'filter=') {                if (isset(self::$overriddenDefaults['filter']) === true) {                    break;                }                $this->filter = substr($arg, 7);                self::$overriddenDefaults['filter'] = true;            } else if (substr($arg, 0, 9) === 'standard=') {                $standards = trim(substr($arg, 9));                if ($standards !== '') {                    $this->standards = explode(',', $standards);                }                self::$overriddenDefaults['standards'] = true;            } else if (substr($arg, 0, 11) === 'extensions=') {                if (isset(self::$overriddenDefaults['extensions']) === true) {                    break;                }                $extensions    = explode(',', substr($arg, 11));                $newExtensions = [];                foreach ($extensions as $ext) {                    $slash = strpos($ext, '/');                    if ($slash !== false) {                        // They specified the tokenizer too.                        list($ext, $tokenizer) = explode('/', $ext);                        $newExtensions[$ext]   = strtoupper($tokenizer);                        continue;                    }                    if (isset($this->extensions[$ext]) === true) {                        $newExtensions[$ext] = $this->extensions[$ext];                    } else {                        $newExtensions[$ext] = 'PHP';                    }                }                $this->extensions = $newExtensions;                self::$overriddenDefaults['extensions'] = true;            } else if (substr($arg, 0, 7) === 'suffix=') {                if (isset(self::$overriddenDefaults['suffix']) === true) {                    break;                }                $this->suffix = substr($arg, 7);                self::$overriddenDefaults['suffix'] = true;            } else if (substr($arg, 0, 9) === 'parallel=') {                if (isset(self::$overriddenDefaults['parallel']) === true) {                    break;                }                $this->parallel = max((int) substr($arg, 9), 1);                self::$overriddenDefaults['parallel'] = true;            } else if (substr($arg, 0, 9) === 'severity=') {                $this->errorSeverity   = (int) substr($arg, 9);                $this->warningSeverity = $this->errorSeverity;                if (isset(self::$overriddenDefaults['errorSeverity']) === false) {                    self::$overriddenDefaults['errorSeverity'] = true;                }                if (isset(self::$overriddenDefaults['warningSeverity']) === false) {                    self::$overriddenDefaults['warningSeverity'] = true;                }            } else if (substr($arg, 0, 15) === 'error-severity=') {                if (isset(self::$overriddenDefaults['errorSeverity']) === true) {                    break;                }                $this->errorSeverity = (int) substr($arg, 15);                self::$overriddenDefaults['errorSeverity'] = true;            } else if (substr($arg, 0, 17) === 'warning-severity=') {                if (isset(self::$overriddenDefaults['warningSeverity']) === true) {                    break;                }                $this->warningSeverity = (int) substr($arg, 17);                self::$overriddenDefaults['warningSeverity'] = true;            } else if (substr($arg, 0, 7) === 'ignore=') {                if (isset(self::$overriddenDefaults['ignored']) === true) {                    break;                }                // Split the ignore string on commas, unless the comma is escaped                // using 1 or 3 slashes (\, or \\\,).                $patterns = preg_split(                    '/(?<=(?<!\\\\)\\\\\\\\),|(?<!\\\\),/',                    substr($arg, 7)                );                $ignored = [];                foreach ($patterns as $pattern) {                    $pattern = trim($pattern);                    if ($pattern === '') {                        continue;                    }                    $ignored[$pattern] = 'absolute';                }                $this->ignored = $ignored;                self::$overriddenDefaults['ignored'] = true;            } else if (substr($arg, 0, 10) === 'generator='                && PHP_CODESNIFFER_CBF === false            ) {                if (isset(self::$overriddenDefaults['generator']) === true) {                    break;                }                $this->generator = substr($arg, 10);                self::$overriddenDefaults['generator'] = true;            } else if (substr($arg, 0, 9) === 'encoding=') {                if (isset(self::$overriddenDefaults['encoding']) === true) {                    break;                }                $this->encoding = strtolower(substr($arg, 9));                self::$overriddenDefaults['encoding'] = true;            } else if (substr($arg, 0, 10) === 'tab-width=') {                if (isset(self::$overriddenDefaults['tabWidth']) === true) {                    break;                }                $this->tabWidth = (int) substr($arg, 10);                self::$overriddenDefaults['tabWidth'] = true;            } else {                if ($this->dieOnUnknownArg === false) {                    $eqPos = strpos($arg, '=');                    try {                        if ($eqPos === false) {                            $this->values[$arg] = $arg;                        } else {                            $value = substr($arg, ($eqPos + 1));                            $arg   = substr($arg, 0, $eqPos);                            $this->values[$arg] = $value;                        }                    } catch (RuntimeException $e) {                        // Value is not valid, so just ignore it.                    }                } else {                    $this->processUnknownArgument('--'.$arg, $pos);                }            }//end if            break;        }//end switch    }//end processLongArgument()",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_837, Get values of current AttributeGroup instance for the webservice.\\\\\\\\n\\\\\\\\n @return array|false|mysqli_result|PDOStatement|resource|null\\\\\\\\n,Dohvatanje vrednosti trenutne instance AttributeGroup za veb servis,"    public function getWsProductOptionValues()    {        $result = Db::getInstance()->executeS(            'SELECT a.id_attribute AS idFROM `' . _DB_PREFIX_ . 'attribute` a' . Shop::addSqlAssociation('attribute', 'a') . 'WHERE a.id_attribute_group = ' . (int) $this->id        );        return $result;    }",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_840, Get the highest AttributeGroup position.\\\\n\\\\n @return int $position Position\\\\n,Dohvatanje najviše pozicije AttributeGroup-e,    public static function getHigherPosition()    {        $sql = 'SELECT MAX(`position`)FROM `' . _DB_PREFIX_ . 'attribute_group`';        $position = Db::getInstance()->getValue($sql);        return (is_numeric($position)) ? $position : -1;    },1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attribute_826, Return true if the Attribute is a color.\n\n @return bool Color is the attribute type\n,Vrati tačno ako je atribut boja,    public function isColorAttribute()    {        if (!Db::getInstance()->getRow('SELECT `group_type`FROM `' . _DB_PREFIX_ . 'attribute_group`WHERE `id_attribute_group` = (SELECT `id_attribute_group`FROM `' . _DB_PREFIX_ . 'attribute`WHERE `id_attribute` = ' . (int) $this->id . ')AND group_type = \'color\'')) {            return false;        }        return Db::getInstance()->numRows();    },1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attribute_825, Check if the given name is an Attribute within the given AttributeGroup.\\n\\n @param int $idAttributeGroup AttributeGroup\\n @param string $name Attribute name\\n @param int $idLang Language ID\\n\\n @return array|bool\\n,Proverite da li je dato ime atribut unutar date AttributeGroup,"    public static function isAttribute($idAttributeGroup, $name, $idLang)    {        if (!Combination::isFeatureActive()) {            return [];        }        $result = Db::getInstance()->getValue('SELECT COUNT(*)FROM `' . _DB_PREFIX_ . 'attribute_group` agLEFT JOIN `' . _DB_PREFIX_ . 'attribute_group_lang` aglON (ag.`id_attribute_group` = agl.`id_attribute_group` AND agl.`id_lang` = ' . (int) $idLang . ')LEFT JOIN `' . _DB_PREFIX_ . 'attribute` aON a.`id_attribute_group` = ag.`id_attribute_group`LEFT JOIN `' . _DB_PREFIX_ . 'attribute_lang` alON (a.`id_attribute` = al.`id_attribute` AND al.`id_lang` = ' . (int) $idLang . ')' . Shop::addSqlAssociation('attribute_group', 'ag') . '' . Shop::addSqlAssociation('attribute', 'a') . 'WHERE al.`name` = \'' . pSQL($name) . '\' AND ag.`id_attribute_group` = ' . (int) $idAttributeGroup . 'ORDER BY agl.`name` ASC, a.`position` ASC');        return (int) $result > 0;    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attribute_828, Move an attribute inside its group.\n\n @param bool $direction Up (1) or Down (0)\n @param int $position Current position of the attribute\n\n @return bool Update result\n,Premestite atribut unutar njegove grupe,"    public function updatePosition($direction, $position)    {        if (!$idAttributeGroup = (int) Tools::getValue('id_attribute_group')) {            $idAttributeGroup = (int) $this->id_attribute_group;        }        $sql = 'SELECT a.`id_attribute`, a.`position`, a.`id_attribute_group`FROM `' . _DB_PREFIX_ . 'attribute` aWHERE a.`id_attribute_group` = ' . (int) $idAttributeGroup . 'ORDER BY a.`position` ASC';        if (!$res = Db::getInstance()->executeS($sql)) {            return false;        }        foreach ($res as $attribute) {            if ((int) $attribute['id_attribute'] == (int) $this->id) {                $movedAttribute = $attribute;            }        }        if (!isset($movedAttribute) || !isset($position)) {            return false;        }        // < and > statements rather than BETWEEN operator        // since BETWEEN is treated differently according to databases        $res1 = Db::getInstance()->execute(            'UPDATE `' . _DB_PREFIX_ . 'attribute`SET `position`= `position` ' . ($direction ? '- 1' : '+ 1') . 'WHERE `position`' . ($direction                ? '> ' . (int) $movedAttribute['position'] . ' AND `position` <= ' . (int) $position                : '< ' . (int) $movedAttribute['position'] . ' AND `position` >= ' . (int) $position) . 'AND `id_attribute_group`=' . (int) $movedAttribute['id_attribute_group']        );        $res2 = Db::getInstance()->execute(            'UPDATE `' . _DB_PREFIX_ . 'attribute`SET `position` = ' . (int) $position . 'WHERE `id_attribute` = ' . (int) $movedAttribute['id_attribute'] . 'AND `id_attribute_group`=' . (int) $movedAttribute['id_attribute_group']        );        return $res1 && $res2;    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_832, Deletes current AttributeGroup from database.\n\n @return bool True if delete was successful\n\n @throws PrestaShopException\n,Briše trenutnu AttributeGroup-u iz baze podataka,"    public function delete()    {        if (!$this->hasMultishopEntries() || Shop::getContext() == Shop::CONTEXT_ALL) {            /* Select children in order to find linked combinations */            $attributeIds = Db::getInstance()->executeS(                'SELECT `id_attribute`FROM `' . _DB_PREFIX_ . 'attribute`WHERE `id_attribute_group` = ' . (int) $this->id            );            if ($attributeIds === false) {                return false;            }            /* Removing attributes to the found combinations */            $toRemove = [];            foreach ($attributeIds as $attribute) {                $toRemove[] = (int) $attribute['id_attribute'];            }            if (!empty($toRemove) && Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'product_attribute_combination`WHERE `id_attribute`IN (' . implode(', ', $toRemove) . ')') === false) {                return false;            }            /* Remove combinations if they do not possess attributes anymore */            if (!AttributeGroup::cleanDeadCombinations()) {                return false;            }            /* Also delete related attributes */            if (count($toRemove)) {                if (!Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_lang`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_shop`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute` WHERE `id_attribute_group` = ' . (int) $this->id)) {                    return false;                }            }            $this->cleanPositions();        }        $return = parent::delete();        if ($return) {            Hook::exec('actionAttributeGroupDelete', ['id_attribute_group' => $this->id]);        }        return $return;    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attribute_829, get highest position.\n\n Get the highest attribute position from a group attribute\n\n @param int $idAttributeGroup AttributeGroup ID\n\n @return int $position Position\n @todo: Shouldn't this be called getHighestPosition instead?\n,Dobiti najvišu poziciju.  Dobiti najvišu poziciju atributa iz grupe atributa,    public static function getHigherPosition($idAttributeGroup)    {        $sql = 'SELECT MAX(`position`)FROM `' . _DB_PREFIX_ . 'attribute`WHERE id_attribute_group = ' . (int) $idAttributeGroup;        $position = Db::getInstance()->getValue($sql);        return (is_numeric($position)) ? $position : -1;    },1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_782, Check if Address is used (at least one order placed).\\\\n\\\\n @return int Order count for this Address\\\\n,Proverite da li se koristi adresa (bar jedna narudžbina postavljena).,    public function isUsed()    {        if ((int) $this->id <= 0) {            return false;        }        $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT COUNT(`id_order`) AS usedFROM `' . _DB_PREFIX_ . 'orders`WHERE `id_address_delivery` = ' . (int) $this->id . 'OR `id_address_invoice` = ' . (int) $this->id);        return $result > 0 ? (int) $result : false;    },1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_783, Get Country and State of this Address.\\\\n\\\\n @param int $id_address Address ID\\\\n\\\\n @return array\\\\n,Dohvata državu i adresu udržavi,"    public static function getCountryAndState($id_address)    {        if (isset(self::$_idCountries[$id_address])) {            return self::$_idCountries[$id_address];        }        if ($id_address) {            $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT `id_country`, `id_state`, `vat_number`, `postcode` FROM `' . _DB_PREFIX_ . 'address`WHERE `id_address` = ' . (int) $id_address);        } else {            $result = false;        }        self::$_idCountries[$id_address] = $result;        return $result;    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_780, Check if the Country is active for a given address.\n\n @param int $id_address Address ID for which we want to get the Country status\n\n @return int Country status\n,Proverite da li je država aktivna za datu adresu,"    public static function isCountryActiveById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        $cache_id = 'Address::isCountryActiveById_' . (int) $id_address;        if (!Cache::isStored($cache_id)) {            $result = (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT c.`active`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`WHERE a.`id_address` = ' . (int) $id_address);            Cache::store($cache_id, $result);            return $result;        }        return Cache::retrieve($cache_id);    }",1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NegativeBinomial_3244, Negative binomial distribution (Pascal distribution)\n https://en.wikipedia.org/wiki/Negative_binomial_distribution\n,Negativna binomna raspodela (Paskalova raspodela),"class NegativeBinomial extends Discrete{    /**     * Distribution parameter bounds limits     * r âˆˆ [0,âˆž)     * p âˆˆ [0,1]     * @var array     */    public const PARAMETER_LIMITS = [        'r' => '[0,âˆž)',        'p' => '[0,1]',    ];    /**     * Distribution support bounds limits     * x âˆˆ [0,âˆž)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '[0,âˆž)',    ];    /** @var int number of successful events */    protected $r;    /** @var float probability of success on an individual trial */    protected $p;    /**     * Constructor     *     * @param  int   $r number of failures until the experiment is stopped     * @param  float $p probability of success on an individual trial     */    public function __construct(int $r, float $p)    {        parent::__construct($r, $p);    }    /**     * Probability mass function     *     *               / x + r - 1 \     * b(k; r, p) = |             | (1 - p)Ë£ pÊ³     *               \     x     /     *     *     *            = â‚“â‚Šáµ£â‚‹â‚Câ‚“ (1 - p)Ë£ pÊ³     *     * @param  int $x number of successes     *     * @return float     *     * @throws MathException     */    public function pmf(int $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $r = $this->r;        $p = $this->p;        $â‚“â‚Šáµ£â‚‹â‚Câ‚“ = Combinatorics::combinations($x + $r - 1, $x);        $âŸ®1Â âˆ’Â pâŸ¯Ë£ = \pow(1 - $p, $x);        $pÊ³      = \pow($p, $r);        return $â‚“â‚Šáµ£â‚‹â‚Câ‚“ * $âŸ®1Â âˆ’Â pâŸ¯Ë£ * $pÊ³;    }    /**     * Cumulative distribution function (lower cumulative distribution)     *     *               â‚“     * P(x; r, p) =  Î£ pmf(k, r, p)     *              áµâ¼â°     *     * @param int $x number of successes     *     * @return float     *     * @throws MathException     */    public function cdf(int $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        return \array_sum(            \array_map(                [$this, 'pmf'],                \range(0, $x)            )        );    }    /**     * Mean of the distribution     *     *       pr     * Î¼ = -----     *     1 - p     *     * @return float     */    public function mean(): float    {        return ($this->p * $this->r) / (1 - $this->p);    }    /**     * Mode of the distribution     *     *        | p(r - 1) |     * mode = | -------- |  for r > 1     *        |_  1 - p _|     *     * mode = 0             for r â‰¤ 1     *     * @return float     */    public function mode(): float    {        if ($this->r <= 1) {            return 0;        }        $r = $this->r;        $p = $this->p;        return \floor(($p * ($r - 1)) / (1 - $p));    }    /**     * Variance of the distribution     *     *         pr     * ÏƒÂ² = --------     *      (1 - p)Â²     *     * @return float     */    public function variance(): float    {        return ($this->p * $this->r) / (1 - $this->p) ** 2;    }}",0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Combinatorics_3052, Central Binomial Coefficient\\n\\n (2n)   (2n)!\\n (  ) = ----- for n â‰¥ 0\\n (n )   (n!)Â²\\n\\n https://en.wikipedia.org/wiki/Central_binomial_coefficient\\n\\n @param  int $n\\n\\n @return float number\\n\\n @throws Exception\\\\OutOfBoundsException if n < 0\\n,Centralni binomni koeficijent,    public static function centralBinomialCoefficient(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute negative central binomial coefficient.');        }        $âŸ®2nâŸ¯ï¼ = self::factorial(2 * $n);        $âŸ®nï¼âŸ¯Â² = (self::factorial($n)) ** 2;        return $âŸ®2nâŸ¯ï¼ / $âŸ®nï¼âŸ¯Â²;    },0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3220," PMF multiplication method\n\n Evaluate binomial probabilities using a method that avoids unnecessary overflow and underflow\n Catherine Loader: http://octave.1599824.n4.nabble.com/attachment/3829107/0/loader2000Fast.pdf\n\n               x             x   n-x\n              __  n - x + i __   __\n p(x; n, p) = ||  --------- || p ||  (1 - p)\n              â±â¼Â¹     i     â±â¼Â¹  â±â¼Â¹\n\n @param int   $r number of successful events\n @param int   $n number of events\n @param float $p probability of success\n\n @return float\n",PMF metoda množenja. Procenite binomne verovatnoće pomoću metode koja izbegava nepotrebno prelivanje i podlivanje,"    private function multiplicationMethod(int $r, int $n, float $p): float    {        if (2 * $r > $n) {            return $this->multiplicationMethod($n - $r, $n, 1 - $p);        }        [$jâ‚€, $jâ‚, $jâ‚‚] = [0, 0, 0];        $f = 1;        while (($jâ‚€ < $r) | ($jâ‚ < $r) | ($jâ‚‚ < $n - $r)) {            if (($jâ‚€ < $r) && ($f < 1)) {                $jâ‚€++;                $f *= ($n - $r + $jâ‚€) / $jâ‚€;            } elseif ($jâ‚ < $r) {                $jâ‚++;                $f *= $p;            } else {                $jâ‚‚++;                $f *= 1 - $p;            }        }        return $f;    }",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Hypergeometric_3240," Cumulative distribution function\n\n           (  n  )(  N - n  )      _                           _\n           (k + 1)(K - k - 1)     | 1, k + 1 - K, k + 1 - n      |\n cdf = 1 - ------------------ â‚ƒFâ‚‚ |                          ; 1 |\n                  (N)             | k + 2, N + k + 2 - K - n     |\n                  (K)             |_                            _|\n\n N is the population size,\n K is the number of success states in the population,\n n is the number of draws,\n k is the number of observed successes,\n (a)\n (b) is a binomial coefficient.\n â‚ƒFâ‚‚ is the generalized hypergeometric function\n\n N âˆˆ {0, 1, 2, ...}\n K âˆˆ {0, 1, 2, ..., N}\n n âˆˆ {0, 1, 2, ..., N}\n k âˆˆ {max(0, n + K - N), ..., min(n, K)}\n\n @param  int $k number of observed successes\n\n @return float\n",Funkcija raspodele,"    public function cdf(int $k): float    {        Support::checkLimits($this->support_limit, ['k' => $k]);        $N = $this->N;        $K = $this->K;        $n = $this->n;        $nCâŸ®kÂ ï¼‹Â 1âŸ¯         = Combinatorics::combinations($n, $k + 1);        $âŸ®NÂ âˆ’Â nâŸ¯CâŸ®KÂ âˆ’Â kÂ âˆ’Â 1âŸ¯ = Combinatorics::combinations(($N - $n), ($K - $k - 1));        $NCK              = Combinatorics::combinations($N, $K);        $â‚ƒFâ‚‚ = Special::generalizedHypergeometric(3, 2, 1, $k + 1 - $K, $k + 1 - $n, $k + 2, $N + $k + 2 - $K - $n, 1);        return (($nCâŸ®kÂ ï¼‹Â 1âŸ¯ * $âŸ®NÂ âˆ’Â nâŸ¯CâŸ®KÂ âˆ’Â kÂ âˆ’Â 1âŸ¯) / $NCK) * $â‚ƒFâ‚‚;    }",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Continuous_3086, Produce a random number with a particular distribution\n\n @return number\n\n @throws \\Exception\n,"Napravite slučajni broj sa određenom raspodelom
","    public function rand()    {        return $this->inverse(\random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX);    }",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Common_338, Is HTTPS?\n\n Determines if the application is accessed via an encrypted\n (HTTPS) connection.\n\n @return\tbool\n,Da li je HTTPS?  Određuje da li se aplikaciji pristupa preko šifrovane (HTTPS) veze,function is_https(){if ( ! empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off'){return TRUE;}elseif (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) === 'https'){return TRUE;}elseif ( ! empty($_SERVER['HTTP_FRONT_END_HTTPS']) && strtolower($_SERVER['HTTP_FRONT_END_HTTPS']) !== 'off'){return TRUE;}return FALSE;},0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Linear_3576," Simple linear regression - least squares method\n\n A model with a single explanatory variable.\n Fits a straight line through the set of n points in such a way that makes\n the sum of squared residuals of the model (that is, vertical distances\n between the points of the data set and the fitted line) as small as possible.\n https://en.wikipedia.org/wiki/Simple_linear_regression\n\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\n Find the equation y = mx + b\n\n      _ _   __\n      x y - xy\n m = _________\n      _     __\n     (x)Â² - xÂ²\n\n     _    _\n b = y - mx\n","Jednostavna linearna regresija - metoda najmanjih kvadrata. Model sa jednom objašnjenom promenljivom. Uklapa pravu liniju kroz skup od n tačaka na takav načinkoji pravi da zabir kvadratnih reziduala modela (tj. , vertikalne udaljenosti između tačaka skupa podataka i prave koja fituje podatke) bude što je moguće manji","class Linear extends ParametricRegression{    use Methods\LeastSquares;    use Models\LinearModel;    /**     * Average of x     * @var number     */    private $xbar;    /**     * Average of y     * @var number     */    private $ybar;    /**     * Sum of squared deviations of x     * @var number     */    private $SSx;    /**     * Sum of squares residuals     * @var number     */    private $SSres;    /**     * Calculates the regression parameters.     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     * @throws Exception\MathException     */    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs)->getColumn(0);    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_WeightedLinear_3603," Weighted linear regression - least squares method\n\n A model with a single explanatory variable.\n Fits a straight line through the set of n points in such a way that makes\n the sum of squared residuals of the model (that is, vertical distances\n between the points of the data set and the fitted line) as small as possible.\n https://en.wikipedia.org/wiki/Simple_linear_regression\n\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\n Find the equation y = mx + b\n\n","Ponderisana linearna regresija - metoda najmanjih kvadrata. Model sa jednom promenljivom objašnjenja. Uklapa se prava linija kroz skup od n tačaka na takav način da zbir kvadratnih reziduala modela (tj. , vertikalne udaljenosti između tačaka skupa podataka i ugrađene prave) bude što je moguće manji","class WeightedLinear extends ParametricRegression{    use Models\LinearModel;    use Methods\WeightedLeastSquares;    /**     * Array of weights     * @var array     */    private $ws;    /**     * @param array $points     * @param array $ws     Weights     */    public function __construct(array $points, array $ws)    {        $this->ws = $ws;        parent::__construct($points);    }    /**     * Calculates the regression parameters.     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     */    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs, $this->ws)->getColumn(0);    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PowerLaw_3590, Calculate the regression parameters by least squares on linearized data\\n ln(y) = ln(A) + B\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\MathException\\n,Izračunava parametre regresije po metodi najmanjih kvadrata na linearizovanim podacima  ln(i) = ln(A) + B,"    public function calculate(): void    {        // Linearize the relationship by taking the log of both sides.        $xâ€™ = \array_map('\log', $this->xs);        $yâ€™ = \array_map('\log', $this->ys);        // Perform Least Squares Fit        $linearized_parameters = $this->leastSquares($yâ€™, $xâ€™)->getColumn(0);        // Translate the linearized parameters back.        $this->a = \exp($linearized_parameters[0]);        $this->b = $linearized_parameters[1];        $this->parameters = [$this->a, $this->b];    }",0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LinearModel_3634, Get regression equation (y = mx + b)\n\n @param array $params\n\n @return string\n,Dobijanje regresione jednačine (y = mx + b),"    public function getModelEquation(array $params): string    {        return \sprintf('y = %fx + %f', $params[self::$M], $params[self::$B]);    }",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LinearModel_3633," Get regression parameters (coefficients)\\n m = slope\\n b = y intercept\\n\\n @param array $params\\n\\n @return array [ m => number, b => number ]\\n",Dobijanje regresionih parametara (koeficijenata) m = nagib  b = y presek,"    public function getModelParameters(array $params): array    {        return [            'm' => $params[self::$M],            'b' => $params[self::$B],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PowerModel_3640, Get regression equation (y = axáµ‡) in format y = ax^b\\n\\n @param array $params\\n\\n @return string\\n,Dobijanje regresione jednačine (y = axáµ‡) u formatu y = ax^b,"    public function getModelEquation(array $params): string    {        return \sprintf('y = %fx^%f', $params[self::$A], $params[self::$B]);    }",0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Regression_3593," Constructor - Prepares the data arrays for regression analysis\\n\\n @param array $points [ [x, y], [x, y], ... ]\\n",Konstruktor - Priprema nizove podataka za regresionu analizu,"    public function __construct(array $points)    {        $this->points = $points;        $this->n      = \count($points);        // Get list of x points and y points.        // This will be fine for linear or polynomial regression, where there is only one x,        // but if expanding to multiple linear, the format will have to change.        $this->xs = \array_map(function ($point) {            return $point[0];        }, $points);        $this->ys = \array_map(function ($point) {            return $point[1];        }, $points);    }",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_9648, Try to emit onError callback.\n\n @param int    $code\n @param string $msg\n @return void\n,Pokušava da emitujete onError povratni poziv,"    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncUdpConnection_7027, Connect.\n\n @return void\n,Konekcija,"class AsyncUdpConnection extends UdpConnection{    /**     * Emitted when socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when socket connection closed.     *     * @var callable     */    public $onClose = null;    /**     * Connected or not.     *     * @var bool     */    protected $connected = false;    /**     * Context option.     *     * @var array     */    protected $_contextOption = null;    /**     * Construct.     *     * @param string $remote_address     * @throws Exception     */    public function __construct($remote_address, $context_option = null)    {        // Get the application layer communication protocol and listening address.        list($scheme, $address) = \explode(':', $remote_address, 2);        // Check application layer protocol class.        if ($scheme !== 'udp') {            $scheme         = \ucfirst($scheme);            $this->protocol = '\\Protocols\\' . $scheme;            if (!\class_exists($this->protocol)) {                $this->protocol = ""\\Workerman\\Protocols\\$scheme"";                if (!\class_exists($this->protocol)) {                    throw new Exception(""class \\Protocols\\$scheme not exist"");                }            }        }                $this->_remoteAddress = \substr($address, 2);        $this->_contextOption = $context_option;    }        /**     * For udp package.     *     * @param resource $socket     * @return bool     */    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }    /**     * Sends data on the connection.     *     * @param string $send_buffer     * @param bool   $raw     * @return void|boolean     */    public function send($send_buffer, $raw = false)    {        if (false === $raw && $this->protocol) {            $parser      = $this->protocol;            $send_buffer = $parser::encode($send_buffer, $this);            if ($send_buffer === '') {                return;            }        }        if ($this->connected === false) {            $this->connect();        }        return \strlen($send_buffer) === \stream_socket_sendto($this->_socket, $send_buffer, 0);    }            /**     * Close connection.     *     * @param mixed $data     * @param bool $raw     *     * @return bool     */    public function close($data = null, $raw = false)    {        if ($data !== null) {            $this->send($data, $raw);        }        Worker::$globalEvent->del($this->_socket, EventInterface::EV_READ);        \fclose($this->_socket);        $this->connected = false;        // Try to emit onClose callback.        if ($this->onClose) {            try {                \call_user_func($this->onClose, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        $this->onConnect = $this->onMessage = $this->onClose = null;        return true;    }    /**     * Connect.     *     * @return void     */    public function connect()    {        if ($this->connected === true) {            return;        }        if ($this->_contextOption) {            $context = \stream_context_create($this->_contextOption);            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg,                30, \STREAM_CLIENT_CONNECT, $context);        } else {            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg);        }        if (!$this->_socket) {            Worker::safeEcho(new \Exception($errmsg));            return;        }                \stream_set_blocking($this->_socket, false);                if ($this->onMessage) {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));        }        $this->connected = true;        // Try to emit onConnect callback.        if ($this->onConnect) {            try {                \call_user_func($this->onConnect, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncUdpConnection_7782, AsyncTcpConnection.\n,Asinhrona Tcp konekcija,"class AsyncUdpConnection extends UdpConnection{    /**     * Emitted when socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when socket connection closed.     *     * @var callable     */    public $onClose = null;    /**     * Connected or not.     *     * @var bool     */    protected $connected = false;    /**     * Context option.     *     * @var array     */    protected $_contextOption = null;    /**     * Construct.     *     * @param string $remote_address     * @throws Exception     */    public function __construct($remote_address, $context_option = null)    {        // Get the application layer communication protocol and listening address.        list($scheme, $address) = \explode(':', $remote_address, 2);        // Check application layer protocol class.        if ($scheme !== 'udp') {            $scheme         = \ucfirst($scheme);            $this->protocol = '\\Protocols\\' . $scheme;            if (!\class_exists($this->protocol)) {                $this->protocol = ""\\Workerman\\Protocols\\$scheme"";                if (!\class_exists($this->protocol)) {                    throw new Exception(""class \\Protocols\\$scheme not exist"");                }            }        }                $this->_remoteAddress = \substr($address, 2);        $this->_contextOption = $context_option;    }        /**     * For udp package.     *     * @param resource $socket     * @return bool     */    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }    /**     * Sends data on the connection.     *     * @param string $send_buffer     * @param bool   $raw     * @return void|boolean     */    public function send($send_buffer, $raw = false)    {        if (false === $raw && $this->protocol) {            $parser      = $this->protocol;            $send_buffer = $parser::encode($send_buffer, $this);            if ($send_buffer === '') {                return;            }        }        if ($this->connected === false) {            $this->connect();        }        return \strlen($send_buffer) === \stream_socket_sendto($this->_socket, $send_buffer, 0);    }            /**     * Close connection.     *     * @param mixed $data     * @param bool $raw     *     * @return bool     */    public function close($data = null, $raw = false)    {        if ($data !== null) {            $this->send($data, $raw);        }        Worker::$globalEvent->del($this->_socket, EventInterface::EV_READ);        \fclose($this->_socket);        $this->connected = false;        // Try to emit onClose callback.        if ($this->onClose) {            try {                \call_user_func($this->onClose, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        $this->onConnect = $this->onMessage = $this->onClose = null;        return true;    }    /**     * Connect.     *     * @return void     */    public function connect()    {        if ($this->connected === true) {            return;        }        if ($this->_contextOption) {            $context = \stream_context_create($this->_contextOption);            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg,                30, \STREAM_CLIENT_CONNECT, $context);        } else {            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg);        }        if (!$this->_socket) {            Worker::safeEcho(new \Exception($errmsg));            return;        }                \stream_set_blocking($this->_socket, false);                if ($this->onMessage) {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));        }        $this->connected = true;        // Try to emit onConnect callback.        if ($this->onConnect) {            try {                \call_user_func($this->onConnect, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7015, Accept a connection.\n\n @param resource $socket\n @return void\n,Prihvatanje konekcije,"    public function acceptUdpConnection($socket)    {        \set_error_handler(function(){});        $recv_buffer = \stream_socket_recvfrom($socket, static::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        \restore_error_handler();        if (false === $recv_buffer || empty($remote_address)) {            return false;        }        // UdpConnection.        $connection           = new UdpConnection($socket, $remote_address);        $connection->protocol = $this->protocol;        if ($this->onMessage) {            try {                if ($this->protocol !== null) {                    /** @var \Workerman\Protocols\ProtocolInterface $parser */                    $parser = $this->protocol;                    if ($parser && \method_exists($parser, 'input')) {                        while ($recv_buffer !== '') {                            $len = $parser::input($recv_buffer, $connection);                            if ($len === 0)                                return true;                            $package = \substr($recv_buffer, 0, $len);                            $recv_buffer = \substr($recv_buffer, $len);                            $data = $parser::decode($package, $connection);                            if ($data === false)                                continue;                            \call_user_func($this->onMessage, $connection, $data);                        }                    } else {                        $data = $parser::decode($recv_buffer, $connection);                        // Discard bad packets.                        if ($data === false)                            return true;                        \call_user_func($this->onMessage, $connection, $data);                    }                } else {                    \call_user_func($this->onMessage, $connection, $recv_buffer);                }                ++ConnectionInterface::$statistics['total_request'];            } catch (\Exception $e) {                static::log($e);                exit(250);            } catch (\Error $e) {                static::log($e);                exit(250);            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncTcpConnection_7022, Get remote URI.\n\n @return string\n,Dohvatanje udaljenog URI-ja,"    public function checkConnection()    {        // Remove EV_EXPECT for windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->del($this->_socket, EventInterface::EV_EXCEPT);        }        // Remove write listener.        Worker::$globalEvent->del($this->_socket, EventInterface::EV_WRITE);        if ($this->_status !== self::STATUS_CONNECTING) {            return;        }        // Check socket state.        if ($address = \stream_socket_get_name($this->_socket, true)) {            // Nonblocking.            \stream_set_blocking($this->_socket, false);            // Compatible with hhvm            if (\function_exists('stream_set_read_buffer')) {                \stream_set_read_buffer($this->_socket, 0);            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && $this->transport === 'tcp') {                $raw_socket = \socket_import_stream($this->_socket);                \socket_set_option($raw_socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($raw_socket, \SOL_TCP, \TCP_NODELAY, 1);            }            // SSL handshake.            if ($this->transport === 'ssl') {                $this->_sslHandshakeCompleted = $this->doSslHandshake($this->_socket);                if ($this->_sslHandshakeCompleted === false) {                    return;                }            } else {                // There are some data waiting to send.                if ($this->_sendBuffer) {                    Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'baseWrite'));                }            }            // Register a listener waiting read event.            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));            $this->_status                = self::STATUS_ESTABLISHED;            $this->_remoteAddress         = $address;            // Try to emit onConnect callback.            if ($this->onConnect) {                try {                    \call_user_func($this->onConnect, $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }            // Try to emit protocol::onConnect            if ($this->protocol && \method_exists($this->protocol, 'onConnect')) {                try {                    \call_user_func(array($this->protocol, 'onConnect'), $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }        } else {            // Connection failed.            $this->emitError(\WORKERMAN_CONNECT_FAIL, 'connect ' . $this->_remoteAddress . ' fail after ' . round(\microtime(true) - $this->_connectStartTime, 4) . ' seconds');            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7003, Write statistics data to disk.\n\n @return void\n,Upisivanje statističkih podataka na disk,"    public function listen()    {        if (!$this->_socketName) {            return;        }        // Autoload.        Autoloader::setRootPath($this->_autoloadRootPath);        if (!$this->_mainSocket) {            $local_socket = $this->parseSocketAddress();            // Flag.            $flags = $this->transport === 'udp' ? \STREAM_SERVER_BIND : \STREAM_SERVER_BIND | \STREAM_SERVER_LISTEN;            $errno = 0;            $errmsg = '';            // SO_REUSEPORT.            if ($this->reusePort) {                \stream_context_set_option($this->_context, 'socket', 'so_reuseport', 1);            }            // Create an Internet or Unix domain server socket.            $this->_mainSocket = \stream_socket_server($local_socket, $errno, $errmsg, $flags, $this->_context);            if (!$this->_mainSocket) {                throw new Exception($errmsg);            }            if ($this->transport === 'ssl') {                \stream_socket_enable_crypto($this->_mainSocket, false);            } elseif ($this->transport === 'unix') {                $socket_file = \substr($local_socket, 7);                if ($this->user) {                    \chown($socket_file, $this->user);                }                if ($this->group) {                    \chgrp($socket_file, $this->group);                }            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && static::$_builtinTransports[$this->transport] === 'tcp') {                \set_error_handler(function(){});                $socket = \socket_import_stream($this->_mainSocket);                \socket_set_option($socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($socket, \SOL_TCP, \TCP_NODELAY, 1);                \restore_error_handler();            }            // Non blocking.            \stream_set_blocking($this->_mainSocket, false);        }        $this->resumeAccept();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_ProcessSlave_1633, Attempt a connection through the unix socket until it succeeds.\\\\n This is a workaround for an issue where the (hardcoded) 1s socket timeout is triggered due to a busy socket.\\\\n,Pokušaj konekcije kroz unik soket sve dok ne uspe. Ovo je rešenje za problem kod koga se pokreće (tvrdo kodirano) 1s soketa isticanje vremena zbog zauzetog soketa,"    private function tryConnect()    {        try {            $this->doConnect();        } catch (\RuntimeException $ex) {            // Failed to connect to the controller, there was probably a timeout accessing the socket...            $this->loop->addTimer(1, function () {                $this->tryConnect();            });        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_AsyncUdpConnection_7026, For udp package.\n\n @param resource $socket\n @return bool\n,Za udp paket,"    public function connect()    {        if ($this->connected === true) {            return;        }        if ($this->_contextOption) {            $context = \stream_context_create($this->_contextOption);            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg,                30, \STREAM_CLIENT_CONNECT, $context);        } else {            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg);        }        if (!$this->_socket) {            Worker::safeEcho(new \Exception($errmsg));            return;        }                \stream_set_blocking($this->_socket, false);                if ($this->onMessage) {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));        }        $this->connected = true;        // Try to emit onConnect callback.        if ($this->onConnect) {            try {                \call_user_func($this->onConnect, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_7769, Get socket name.\n\n @return string\n,Dohvatiti ime soketa,"    public function stop()    {        // Try to emit onWorkerStop callback.        if ($this->onWorkerStop) {            try {                \call_user_func($this->onWorkerStop, $this);            } catch (\Exception $e) {                static::log($e);                exit(250);            } catch (\Error $e) {                static::log($e);                exit(250);            }        }        // Remove listener for server socket.        $this->unlisten();        // Close all connections for the worker.        if (!static::$_gracefulStop) {            foreach ($this->connections as $connection) {                $connection->close();            }        }        // Clear callback.        $this->onMessage = $this->onClose = $this->onError = $this->onBufferDrain = $this->onBufferFull = null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_Process_1497," Performs a check between the timeout definition and the time the process started.\\n\\n In case you run a background process (with the start method), you should\\n trigger this method regularly to ensure the process timeout\\n\\n @throws ProcessTimedOutException In case the timeout was reached\\n","Obavlja proveru između definicije vremenskog ograničenja i vremena pokretanja procesa. U slučaju da pokrenete pozadinski proces (sa metodom pokretanja), trebali biste redovno pokretati ovu metodu kako biste osigurali vremensko ograničenje procesa
","    public static function isPtySupported()    {        static $result;        if (null !== $result) {            return $result;        }        if ('\\' === \DIRECTORY_SEPARATOR) {            return $result = false;        }        return $result = (bool) @proc_open('echo 1 >/dev/null', [['pty'], ['pty'], ['pty']], $pipes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_HexadecimalToDecimal_2055, This function converts the\n submitted Decimal Number to\n Hexadecimal Number.\n\n @param string $decimalNumber\n @return string\n,Ova funkcija pretvara poslati decimalni broj u heksadecimalni broj,"function decimalToHex($decimalNumber){    $hexDigits = [];    // Mapping for HexaDecimal Digits after 9    $hexDigitMappings = [        10 => 'A',        11 => 'B',        12 => 'C',        13 => 'D',        14 => 'E',        15 => 'F',    ];    if (!is_numeric($decimalNumber)) {        throw new \Exception('Please pass a valid Decimal Number for Converting it to a Hexadecimal Number.');    }    while ($decimalNumber > 0) {        $remainder = ($decimalNumber % 16);        $decimalNumber /= 16;        if (empty($hexDigits) && 0 === $remainder) {            continue;        }        $hexDigits[] = $remainder;    }    $hexDigits = array_reverse($hexDigits);    foreach ($hexDigits as $index => $digit) {        if ($digit > 9) {            $hexDigits[$index] = $hexDigitMappings[$digit];        }    }    $hexNumber = ltrim(implode('', $hexDigits), '0'); // Connecting all the digits and removing leading zeroes.    return $hexNumber;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10278," Returns true if the string contains only hexadecimal chars, false\n otherwise.\n\n @return bool Whether or not $str contains only hexadecimal chars\n","Vraća true ako niz sadrži samo heksadecimalne znakove, false u suprotnom",    public function isHexadecimal()    {        return $this->matchesPattern('^[[:xdigit:]]*$');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Loader_378," Prepare variables for _ci_vars, to be later extract()-ed inside views\\n\\n Converts objects to associative arrays and filters-out internal\\n variable names (i.e. keys prefixed with '_ci_').\\n\\n @param\\tmixed\\t$vars\\n @return\\tarray\\n","Pripremite promenljive za _ci_vars, koje će kasnije biti ekstrahovane unutar view-a. Pretvara objekte u asocijativne nizove i filtrira unutrašnja imena promenljivih (npr. ključevi sa prefiksom '_ci_')","protected function _ci_prepare_view_vars($vars){if ( ! is_array($vars)){$vars = is_object($vars)? get_object_vars($vars): array();}foreach (array_keys($vars) as $key){if (strncmp($key, '_ci_', 4) === 0){unset($vars[$key]);}}return $vars;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_665, Convert a string to camelCase\\n @param  string $value\\n @return string\\n,Pretvorite niz u camelCase,"  private function camelCase($value)  {    $value = ucwords(str_replace(array('-', '_'), ' ', $value));    $value = str_replace(' ', '', $value);    $value[0] = strtolower($value[0]);    return $value;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Util_1553," Normalize file path, convert all slashes to Linux-style and get rid of '..', '.'.\\n\\n @param string $filePath\\n @return string|null\\n","Normalizirajte putanju do datoteke, pretvorite sve kose crte u Linuk stil i oslobodite se „..“, „.“","    public static function normalize(string $filePath): ?string    {        $filePath = realpath($filePath);        if ($filePath === false) {            return null;        }        return str_replace('\\', DIRECTORY_SEPARATOR, $filePath);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_1742," ExceptionHandler converts an exception to a Response object.\\n\\n It is mostly useful in debug mode to replace the default PHP/XDebug\\n output with something prettier and more useful.\\n\\n As this class is mainly used during Kernel boot, where nothing is yet\\n available, the Response content is always HTML.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n @author Nicolas Grekas <p@tchwork.com>\\n\\n @final since Symfony 4.3\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\ErrorHandler instead.\\n","ExceptionHandler pretvara izuzetak u Response objekat. Najčešće se koristi u debug modu kao zamena podrazumevanog PHP/XDebug izlaz nečim lepšim i korisnijim. Kako se ova klasa uglavnom koristi tokom pokretanja kernela, gde još ništa nije dostupno, sadržaj odgovora je uvek HTML","class ExceptionHandler{    private const GHOST_ADDONS = [        '02-14' => self::GHOST_HEART,        '02-29' => self::GHOST_PLUS,        '10-18' => self::GHOST_GIFT,    ];    private const GHOST_GIFT = 'M124.005 5.36c.396-.715 1.119-1.648-.124-1.873-.346-.177-.692-.492-1.038-.141-.769.303-1.435.728-.627 1.523.36.514.685 1.634 1.092 1.758.242-.417.47-.842.697-1.266zm-1.699 1.977c-.706-1.26-1.274-2.612-2.138-3.774-1.051-1.123-3.122-.622-3.593.825-.625 1.431.724 3.14 2.251 2.96 1.159.02 2.324.072 3.48-.011zm5.867.043c1.502-.202 2.365-2.092 1.51-3.347-.757-1.34-2.937-1.387-3.698-.025-.659 1.1-1.23 2.25-1.835 3.38 1.336.077 2.686.06 4.023-.008zm2.487 1.611c.512-.45 2.494-.981.993-1.409-.372-.105-.805-.59-1.14-.457-.726.902-1.842 1.432-3.007 1.376-.228.075-1.391-.114-1.077.1.822.47 1.623.979 2.474 1.395.595-.317 1.173-.667 1.757-1.005zm-11.696.255l1.314-.765c-1.338-.066-2.87.127-3.881-.95-.285-.319-.559-.684-.954-.282-.473.326-1.929.66-.808 1.058.976.576 1.945 1.167 2.946 1.701.476-.223.926-.503 1.383-.762zm6.416 2.846c.567-.456 1.942-.89 1.987-1.38-1.282-.737-2.527-1.56-3.87-2.183-.461-.175-.835.094-1.207.328-1.1.654-2.225 1.267-3.288 1.978 1.39.86 2.798 1.695 4.219 2.504.725-.407 1.44-.83 2.16-1.247zm5.692 1.423l1.765-1.114c-.005-1.244.015-2.488-.019-3.732a77.306 77.306 0 0 0-3.51 2.084c-.126 1.282-.062 2.586-.034 3.876.607-.358 1.2-.741 1.798-1.114zm-13.804-.784c.06-1.06.19-2.269-1.09-2.583-.807-.376-1.926-1.341-2.548-1.332-.02 1.195-.01 2.39-.011 3.585 1.192.744 2.364 1.524 3.582 2.226.119-.616.041-1.269.067-1.896zm8.541 4.105l2.117-1.336c-.003-1.284.05-2.57-.008-3.853-.776.223-1.662.91-2.48 1.337l-1.834 1.075c.012 1.37-.033 2.744.044 4.113.732-.427 1.443-.887 2.161-1.336zm-2.957-.72v-2.057c-1.416-.828-2.828-1.664-4.25-2.482-.078 1.311-.033 2.627-.045 3.94 1.416.887 2.817 1.798 4.25 2.655.057-.683.036-1.372.045-2.057zm8.255 2.755l1.731-1.153c-.024-1.218.06-2.453-.062-3.658-1.2.685-2.358 1.464-3.537 2.195.028 1.261-.058 2.536.072 3.786.609-.373 1.2-.777 1.796-1.17zm-13.851-.683l-.014-1.916c-1.193-.746-2.37-1.517-3.58-2.234-.076 1.224-.033 2.453-.044 3.679 1.203.796 2.392 1.614 3.61 2.385.048-.636.024-1.276.028-1.914zm8.584 4.199l2.102-1.396c-.002-1.298.024-2.596-.01-3.893-1.427.88-2.843 1.775-4.25 2.686-.158 1.253-.055 2.545-.056 3.811.437.266 1.553-.912 2.214-1.208zm-2.988-.556c-.085-.894.365-2.154-.773-2.5-1.146-.727-2.288-1.46-3.45-2.163-.17 1.228.008 2.508-.122 3.751a79.399 79.399 0 0 0 4.278 2.885c.117-.641.044-1.32.067-1.973zm-4.872-.236l-5.087-3.396c.002-3.493-.047-6.988.015-10.48.85-.524 1.753-.954 2.627-1.434-.564-1.616.25-3.58 1.887-4.184 1.372-.563 3.025-.055 3.9 1.13l1.906-.978 1.916.987c.915-1.086 2.483-1.706 3.842-1.097 1.631.573 2.52 2.532 1.936 4.145.88.497 1.837.886 2.644 1.492.036 3.473 0 6.946-.003 10.419-3.374 2.233-6.693 4.55-10.122 6.699-.997 0-1.858-1.083-2.783-1.522a735.316 735.316 0 0 1-2.678-1.781z';    private const GHOST_HEART = 'M125.914 8.305c3.036-8.71 14.933 0 0 11.2-14.932-11.2-3.036-19.91 0-11.2z';    private const GHOST_PLUS = 'M111.368 8.97h7.324V1.645h7.512v7.323h7.324v7.513h-7.324v7.323h-7.512v-7.323h-7.324z';    private $debug;    private $charset;    private $handler;    private $caughtBuffer;    private $caughtLength;    private $fileLinkFormat;    public function __construct(bool $debug = true, string $charset = null, $fileLinkFormat = null)    {        $this->debug = $debug;        $this->charset = $charset ?: ini_get('default_charset') ?: 'UTF-8';        $this->fileLinkFormat = $fileLinkFormat;    }    /**     * Registers the exception handler.     *     * @param bool        $debug          Enable/disable debug mode, where the stack trace is displayed     * @param string|null $charset        The charset used by exception messages     * @param string|null $fileLinkFormat The IDE link template     *     * @return static     */    public static function register($debug = true, $charset = null, $fileLinkFormat = null)    {        $handler = new static($debug, $charset, $fileLinkFormat);        $prev = set_exception_handler([$handler, 'handle']);        if (\is_array($prev) && $prev[0] instanceof ErrorHandler) {            restore_exception_handler();            $prev[0]->setExceptionHandler([$handler, 'handle']);        }        return $handler;    }    /**     * Sets a user exception handler.     *     * @param callable $handler An handler that will be called on Exception     *     * @return callable|null The previous exception handler if any     */    public function setHandler(callable $handler = null)    {        $old = $this->handler;        $this->handler = $handler;        return $old;    }    /**     * Sets the format for links to source files.     *     * @param string|FileLinkFormatter $fileLinkFormat The format for links to source files     *     * @return string The previous file link format     */    public function setFileLinkFormat($fileLinkFormat)    {        $old = $this->fileLinkFormat;        $this->fileLinkFormat = $fileLinkFormat;        return $old;    }    /**     * Sends a response for the given Exception.     *     * To be as fail-safe as possible, the exception is first handled     * by our simple exception handler, then by the user exception handler.     * The latter takes precedence and any output from the former is cancelled,     * if and only if nothing bad happens in this handling path.     */    public function handle(\Exception $exception)    {        if (null === $this->handler || $exception instanceof OutOfMemoryException) {            $this->sendPhpResponse($exception);            return;        }        $caughtLength = $this->caughtLength = 0;        ob_start(function ($buffer) {            $this->caughtBuffer = $buffer;            return '';        });        $this->sendPhpResponse($exception);        while (null === $this->caughtBuffer && ob_end_flush()) {            // Empty loop, everything is in the condition        }        if (isset($this->caughtBuffer[0])) {            ob_start(function ($buffer) {                if ($this->caughtLength) {                    // use substr_replace() instead of substr() for mbstring overloading resistance                    $cleanBuffer = substr_replace($buffer, '', 0, $this->caughtLength);                    if (isset($cleanBuffer[0])) {                        $buffer = $cleanBuffer;                    }                }                return $buffer;            });            echo $this->caughtBuffer;            $caughtLength = ob_get_length();        }        $this->caughtBuffer = null;        try {            ($this->handler)($exception);            $this->caughtLength = $caughtLength;        } catch (\Exception $e) {            if (!$caughtLength) {                // All handlers failed. Let PHP handle that now.                throw $exception;            }        }    }    /**     * Sends the error associated with the given Exception as a plain PHP response.     *     * This method uses plain PHP functions like header() and echo to output     * the response.     *     * @param \Throwable|FlattenException $exception A \Throwable or FlattenException instance     */    public function sendPhpResponse($exception)    {        if ($exception instanceof \Throwable) {            $exception = FlattenException::createFromThrowable($exception);        }        if (!headers_sent()) {            header(sprintf('HTTP/1.0 %s', $exception->getStatusCode()));            foreach ($exception->getHeaders() as $name => $value) {                header($name.': '.$value, false);            }            header('Content-Type: text/html; charset='.$this->charset);        }        echo $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the full HTML content associated with the given exception.     *     * @param \Exception|FlattenException $exception An \Exception or FlattenException instance     *     * @return string The HTML content as a string     */    public function getHtml($exception)    {        if (!$exception instanceof FlattenException) {            $exception = FlattenException::create($exception);        }        return $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the HTML content associated with the given exception.     *     * @return string The content as a string     */    public function getContent(FlattenException $exception)    {        switch ($exception->getStatusCode()) {            case 404:                $title = 'Sorry, the page you are looking for could not be found.';                break;            default:                $title = $this->debug ? $this->escapeHtml($exception->getMessage()) : 'Whoops, looks like something went wrong.';        }        if (!$this->debug) {            return <<<EOF                <div class=""container"">                    <h1>$title</h1>                </div>EOF;        }        $content = '';        try {            $count = \count($exception->getAllPrevious());            $total = $count + 1;            foreach ($exception->toArray() as $position => $e) {                $ind = $count - $position + 1;                $class = $this->formatClass($e['class']);                $message = nl2br($this->escapeHtml($e['message']));                $content .= sprintf(<<<'EOF'                    <div class=""trace trace-as-html"">                        <table class=""trace-details"">                            <thead class=""trace-head""><tr><th>                                <h3 class=""trace-class"">                                    <span class=""text-muted"">(%d/%d)</span>                                    <span class=""exception_title"">%s</span>                                </h3>                                <p class=""break-long-words trace-message"">%s</p>                            </th></tr></thead>                            <tbody>EOF                    , $ind, $total, $class, $message);                foreach ($e['trace'] as $trace) {                    $content .= '<tr><td>';                    if ($trace['function']) {                        $content .= sprintf('at <span class=""trace-class"">%s</span><span class=""trace-type"">%s</span><span class=""trace-method"">%s</span>', $this->formatClass($trace['class']), $trace['type'], $trace['function']);                        if (isset($trace['args'])) {                            $content .= sprintf('(<span class=""trace-arguments"">%s</span>)', $this->formatArgs($trace['args']));                        }                    }                    if (isset($trace['file']) && isset($trace['line'])) {                        $content .= $this->formatPath($trace['file'], $trace['line']);                    }                    $content .= ""</td></tr>\n"";                }                $content .= ""</tbody>\n</table>\n</div>\n"";            }        } catch (\Exception $e) {            // something nasty happened and we cannot throw an exception anymore            if ($this->debug) {                $e = FlattenException::create($e);                $title = sprintf('Exception thrown when handling an exception (%s: %s)', $e->getClass(), $this->escapeHtml($e->getMessage()));            } else {                $title = 'Whoops, looks like something went wrong.';            }        }        $symfonyGhostImageContents = $this->getSymfonyGhostAsSvg();        return <<<EOF            <div class=""exception-summary"">                <div class=""container"">                    <div class=""exception-message-wrapper"">                        <h1 class=""break-long-words exception-message"">$title</h1>                        <div class=""exception-illustration hidden-xs-down"">$symfonyGhostImageContents</div>                    </div>                </div>            </div>            <div class=""container"">                $content            </div>EOF;    }    /**     * Gets the stylesheet associated with the given exception.     *     * @return string The stylesheet as a string     */    public function getStylesheet(FlattenException $exception)    {        if (!$this->debug) {            return <<<'EOF'                body { background-color: #fff; color: #222; font: 16px/1.5 -apple-system, BlinkMacSystemFont, ""Segoe UI"", Roboto, ""Helvetica Neue"", Arial, sans-serif; margin: 0; }                .container { margin: 30px; max-width: 600px; }                h1 { color: #dc3545; font-size: 24px; }EOF;        }        return <<<'EOF'            body { background-color: #F9F9F9; color: #222; font: 14px/1.4 Helvetica, Arial, sans-serif; margin: 0; padding-bottom: 45px; }            a { cursor: pointer; text-decoration: none; }            a:hover { text-decoration: underline; }            abbr[title] { border-bottom: none; cursor: help; text-decoration: none; }            code, pre { font: 13px/1.5 Consolas, Monaco, Menlo, ""Ubuntu Mono"", ""Liberation Mono"", monospace; }            table, tr, th, td { background: #FFF; border-collapse: collapse; vertical-align: top; }            table { background: #FFF; border: 1px solid #E0E0E0; box-shadow: 0px 0px 1px rgba(128, 128, 128, .2); margin: 1em 0; width: 100%; }            table th, table td { border: solid #E0E0E0; border-width: 1px 0; padding: 8px 10px; }            table th { background-color: #E0E0E0; font-weight: bold; text-align: left; }            .hidden-xs-down { display: none; }            .block { display: block; }            .break-long-words { -ms-word-break: break-all; word-break: break-all; word-break: break-word; -webkit-hyphens: auto; -moz-hyphens: auto; hyphens: auto; }            .text-muted { color: #999; }            .container { max-width: 1024px; margin: 0 auto; padding: 0 15px; }            .container::after { content: """"; display: table; clear: both; }            .exception-summary { background: #B0413E; border-bottom: 2px solid rgba(0, 0, 0, 0.1); border-top: 1px solid rgba(0, 0, 0, .3); flex: 0 0 auto; margin-bottom: 30px; }            .exception-message-wrapper { display: flex; align-items: center; min-height: 70px; }            .exception-message { flex-grow: 1; padding: 30px 0; }            .exception-message, .exception-message a { color: #FFF; font-size: 21px; font-weight: 400; margin: 0; }            .exception-message.long { font-size: 18px; }            .exception-message a { border-bottom: 1px solid rgba(255, 255, 255, 0.5); font-size: inherit; text-decoration: none; }            .exception-message a:hover { border-bottom-color: #ffffff; }            .exception-illustration { flex-basis: 111px; flex-shrink: 0; height: 66px; margin-left: 15px; opacity: .7; }            .trace + .trace { margin-top: 30px; }            .trace-head .trace-class { color: #222; font-size: 18px; font-weight: bold; line-height: 1.3; margin: 0; position: relative; }            .trace-message { font-size: 14px; font-weight: normal; margin: .5em 0 0; }            .trace-file-path, .trace-file-path a { color: #222; margin-top: 3px; font-size: 13px; }            .trace-class { color: #B0413E; }            .trace-type { padding: 0 2px; }            .trace-method { color: #B0413E; font-weight: bold; }            .trace-arguments { color: #777; font-weight: normal; padding-left: 2px; }            @media (min-width: 575px) {                .hidden-xs-down { display: initial; }            }EOF;    }    private function decorate(string $content, string $css): string    {        return <<<EOF<!DOCTYPE html><html>    <head>        <meta charset=""{$this->charset}"" />        <meta name=""robots"" content=""noindex,nofollow"" />        <style>$css</style>    </head>    <body>        $content    </body></html>EOF;    }    private function formatClass(string $class): string    {        $parts = explode('\\', $class);        return sprintf('<abbr title=""%s"">%s</abbr>', $class, array_pop($parts));    }    private function formatPath(string $path, int $line): string    {        $file = $this->escapeHtml(preg_match('#[^/\\\\]*+$#', $path, $file) ? $file[0] : $path);        $fmt = $this->fileLinkFormat ?: ini_get('xdebug.file_link_format') ?: get_cfg_var('xdebug.file_link_format');        if (!$fmt) {            return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');        }        if (\is_string($fmt)) {            $i = strpos($f = $fmt, '&', max(strrpos($f, '%f'), strrpos($f, '%l'))) ?: \strlen($f);            $fmt = [substr($f, 0, $i)] + preg_split('/&([^>]++)>/', substr($f, $i), -1, \PREG_SPLIT_DELIM_CAPTURE);            for ($i = 1; isset($fmt[$i]); ++$i) {                if (0 === strpos($path, $k = $fmt[$i++])) {                    $path = substr_replace($path, $fmt[$i], 0, \strlen($k));                    break;                }            }            $link = strtr($fmt[0], ['%f' => $path, '%l' => $line]);        } else {            try {                $link = $fmt->format($path, $line);            } catch (\Exception $e) {                return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');            }        }        return sprintf('<span class=""block trace-file-path"">in <a href=""%s"" title=""Go to source""><strong>%s</string>%s</a></span>', $this->escapeHtml($link), $file, 0 < $line ? ' line '.$line : '');    }    /**     * Formats an array as a string.     */    private function formatArgs(array $args): string    {        $result = [];        foreach ($args as $key => $item) {            if ('object' === $item[0]) {                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));            } elseif ('array' === $item[0]) {                $formattedValue = sprintf('<em>array</em>(%s)', \is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);            } elseif ('null' === $item[0]) {                $formattedValue = '<em>null</em>';            } elseif ('boolean' === $item[0]) {                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';            } elseif ('resource' === $item[0]) {                $formattedValue = '<em>resource</em>';            } else {                $formattedValue = str_replace(""\n"", '', $this->escapeHtml(var_export($item[1], true)));            }            $result[] = \is_int($key) ? $formattedValue : sprintf(""'%s' => %s"", $this->escapeHtml($key), $formattedValue);        }        return implode(', ', $result);    }    /**     * HTML-encodes a string.     */    private function escapeHtml(string $str): string    {        return htmlspecialchars($str, \ENT_COMPAT | \ENT_SUBSTITUTE, $this->charset);    }    private function getSymfonyGhostAsSvg(): string    {        return '<svg viewBox=""0 0 136 81"" xmlns=""http://www.w3.org/2000/svg"" fill-rule=""evenodd"" clip-rule=""evenodd"" stroke-linejoin=""round"" stroke-miterlimit=""1.4""><path d=""M92.4 20.4a23.2 23.2 0 0 1 9 1.9 23.7 23.7 0 0 1 5.2 3 24.3 24.3 0 0 1 3.4 3.4 24.8 24.8 0 0 1 5 9.4c.5 1.7.8 3.4 1 5.2v14.5h.4l.5.2a7.4 7.4 0 0 0 2.5.2l.2-.2.6-.8.8-1.3-.2-.1a5.5 5.5 0 0 1-.8-.3 5.6 5.6 0 0 1-2.3-1.8 5.7 5.7 0 0 1-.9-1.6 6.5 6.5 0 0 1-.2-2.8 7.3 7.3 0 0 1 .5-2l.3-.3.8-.9.3-.3c.2-.2.5-.3.8-.3H120.7c.2 0 .3-.1.4 0h.4l.2.1.3.2.2-.4.3-.4.1-.1 1.2-1 .3-.2.4-.1.4-.1h.3l1.5.1.4.1.8.5.1.2 1 1.1v.2H129.4l.4-.2 1.4-.5h1.1c.3 0 .7.2 1 .4.2 0 .3.2.5.3l.2.2.5.3.4.6.1.3.4 1.4.1.4v.6a7.8 7.8 0 0 1-.1.6 9.9 9.9 0 0 1-.8 2.4 7.8 7.8 0 0 1-3 3.3 6.4 6.4 0 0 1-1 .5 6.1 6.1 0 0 1-.6.2l-.7.1h-.1a23.4 23.4 0 0 1-.2 1.7 14.3 14.3 0 0 1-.6 2.1l-.8 2a9.2 9.2 0 0 1-.4.6l-.7 1a9.1 9.1 0 0 1-2.3 2.2c-.9.5-2 .6-3 .7l-1.4.1h-.5l-.4.1a15.8 15.8 0 0 1-2.8-.1v4.2a9.7 9.7 0 0 1-.7 3.5 9.6 9.6 0 0 1-1.7 2.8 9.3 9.3 0 0 1-3 2.3 9 9 0 0 1-5.4.7 9 9 0 0 1-3-1 9.4 9.4 0 0 1-2.7-2.5 10 10 0 0 1-1 1.2 9.3 9.3 0 0 1-2 1.3 9 9 0 0 1-2.4 1 9 9 0 0 1-6.5-1.1A9.4 9.4 0 0 1 85 77V77a10.9 10.9 0 0 1-.6.6 9.3 9.3 0 0 1-2.7 2 9 9 0 0 1-6 .8 9 9 0 0 1-2.4-1 9.3 9.3 0 0 1-2.3-1.7 9.6 9.6 0 0 1-1.8-2.8 9.7 9.7 0 0 1-.8-3.7v-4a18.5 18.5 0 0 1-2.9.2l-1.2-.1c-1.9-.3-3.7-1-5.1-2.1A8.2 8.2 0 0 1 58 64a10.2 10.2 0 0 1-.9-1.2 15.3 15.3 0 0 1-.7-1.3 20.8 20.8 0 0 1-1.9-6.2v-.2a6.5 6.5 0 0 1-1-.3 6.1 6.1 0 0 1-.6-.3 6.6 6.6 0 0 1-.9-.5 8.2 8.2 0 0 1-2.7-3.8 10 10 0 0 1-.3-1 10.3 10.3 0 0 1-.3-1.9V47v-.4l.1-.4.6-1.4.1-.2a2 2 0 0 1 .8-.8l.3-.2.3-.2a3.2 3.2 0 0 1 1.8-.5h.4l.3.2 1.4.6.2.2.4.3.3.4.7-.7.2-.2.4-.2.6-.2h2.1l.4.2.4.2.3.2.8 1 .2-.1h.1v-.1H63l1.1.1h.3l.8.5.3.4.7 1 .2.3.1.5a11 11 0 0 1 .2 1.5c0 .8 0 1.6-.3 2.3a6 6 0 0 1-.5 1.2 5.5 5.5 0 0 1-3.3 2.5 12.3 12.3 0 0 0 1.4 3h.1l.2.1 1 .2h1.5l.5-.2H67.8l.5-.2h.1V44v-.4a26.7 26.7 0 0 1 .3-2.3 24.7 24.7 0 0 1 5.7-12.5 24.2 24.2 0 0 1 3.5-3.3 23.7 23.7 0 0 1 4.9-3 23.2 23.2 0 0 1 5.6-1.7 23.7 23.7 0 0 1 4-.3zm-.3 2a21.2 21.2 0 0 0-8 1.7 21.6 21.6 0 0 0-4.8 2.7 22.2 22.2 0 0 0-3.2 3 22.7 22.7 0 0 0-5 9.2 23.4 23.4 0 0 0-.7 4.9v15.7l-.5.1a34.3 34.3 0 0 1-1.5.3h-.2l-.4.1h-.4l-.9.2a10 10 0 0 1-1.9 0c-.5 0-1-.2-1.5-.4a1.8 1.8 0 0 1-.3-.2 2 2 0 0 1-.3-.3 5.2 5.2 0 0 1-.1-.2 9 9 0 0 1-.6-.9 13.8 13.8 0 0 1-1-2 14.3 14.3 0 0 1-.6-2 14 14 0 0 1-.1-.8v-.2h.3a12.8 12.8 0 0 0 1.4-.2 4.4 4.4 0 0 0 .3 0 3.6 3.6 0 0 0 1.1-.7 3.4 3.4 0 0 0 1.2-1.7l.2-1.2a5.1 5.1 0 0 0 0-.8 7.2 7.2 0 0 0-.1-.8l-.7-1-1.2-.2-1 .7-.1 1.3a5 5 0 0 1 .1.4v.6a1 1 0 0 1 0 .3c-.1.3-.4.4-.7.5l-1.2.4v-.7A9.9 9.9 0 0 1 60 49l.3-.6v-.2l.1-.1v-1.6l-1-1.2h-1.5l-1 1.1v.4a5.3 5.3 0 0 0-.2.6 5.5 5.5 0 0 0 0 .5c0 .7 0 1.4.3 2 0 .4.2.8.4 1.2L57 51a9.5 9.5 0 0 1-1.1-.5h-.2a2 2 0 0 1-.4-.3c-.4-.4-.5-1-.6-1.6a5.6 5.6 0 0 1 0-.5v-.5-.5l-.6-1.5-1.4-.6-.9.3s-.2 0-.3.2a2 2 0 0 1-.1 0l-.6 1.4v.7a8.5 8.5 0 0 0 .5 2c.4 1.1 1 2.1 2 2.8a4.7 4.7 0 0 0 2.1.9h1a22.8 22.8 0 0 0 .1 1 18.1 18.1 0 0 0 .8 3.8 18.2 18.2 0 0 0 1.6 3.7l1 1.3c1 1 2.3 1.6 3.7 2a11.7 11.7 0 0 0 4.8 0h.4l.5-.2.5-.1.6-.2v6.6a8 8 0 0 0 .1 1.3 7.5 7.5 0 0 0 2.4 4.3 7.2 7.2 0 0 0 2.3 1.3 7 7 0 0 0 7-1.1 7.5 7.5 0 0 0 2-2.6A7.7 7.7 0 0 0 85 72V71a8.2 8.2 0 0 0 .2 1.3c0 .7.3 1.4.6 2a7.5 7.5 0 0 0 1.7 2.3 7.3 7.3 0 0 0 2.2 1.4 7.1 7.1 0 0 0 4.6.2 7.2 7.2 0 0 0 2.4-1.2 7.5 7.5 0 0 0 2.1-2.7 7.8 7.8 0 0 0 .7-2.4V71a9.3 9.3 0 0 0 .1.6 7.6 7.6 0 0 0 .6 2.5 7.5 7.5 0 0 0 2.4 3 7.1 7.1 0 0 0 7 .8 7.3 7.3 0 0 0 2.3-1.5 7.5 7.5 0 0 0 1.6-2.3 7.6 7.6 0 0 0 .5-2l.1-1.1v-6.7l.4.1a12.2 12.2 0 0 0 2 .5 11.1 11.1 0 0 0 2.5 0h.8l1.2-.1a9.5 9.5 0 0 0 1.4-.2l.9-.3a3.5 3.5 0 0 0 .6-.4l1.2-1.4a12.2 12.2 0 0 0 .8-1.2c0-.3.2-.5.3-.7a15.9 15.9 0 0 0 .7-2l.3-1.6v-1.3l.2-.9V54.6a15.5 15.5 0 0 0 1.8 0 4.5 4.5 0 0 0 1.4-.5 5.7 5.7 0 0 0 2.5-3.2 7.6 7.6 0 0 0 .4-1.5v-.3l-.4-1.4a5.2 5.2 0 0 1-.2-.1l-.4-.4a3.8 3.8 0 0 0-.2 0 1.4 1.4 0 0 0-.5-.2l-1.4.4-.7 1.3v.7a5.7 5.7 0 0 1-.1.8l-.7 1.4a1.9 1.9 0 0 1-.5.3h-.3a9.6 9.6 0 0 1-.8.3 8.8 8.8 0 0 1-.6 0l.2-.4.2-.5.2-.3v-.4l.1-.2V50l.1-1 .1-.6v-.6a4.8 4.8 0 0 0 0-.8v-.2l-1-1.1-1.5-.2-1.1 1-.2 1.4v.1l.2.4.2.3v.4l.1 1.1v.3l.1.5v.8a9.6 9.6 0 0 1-.8-.3l-.2-.1h-.3l-.8-.1h-.2a1.6 1.6 0 0 1-.2-.2.9.9 0 0 1-.2-.2 1 1 0 0 1-.1-.5l.2-.9v-1.2l-.9-.8h-1.2l-.8.9v.3a4.8 4.8 0 0 0-.3 2l.3.9a3.5 3.5 0 0 0 1.2 1.6l1 .5.8.2 1.4.1h.4l.2.1a12.1 12.1 0 0 1-1 2.6 13.2 13.2 0 0 1-.8 1.5 9.5 9.5 0 0 1-1 1.2l-.2.3a1.7 1.7 0 0 1-.4.3 2.4 2.4 0 0 1-.7.2h-2.5a7.8 7.8 0 0 1-.6-.2l-.7-.2h-.2a14.8 14.8 0 0 1-.6-.2 23.4 23.4 0 0 1-.4-.1l-.4-.1-.3-.1V43.9a34.6 34.6 0 0 0 0-.6 23.6 23.6 0 0 0-.4-3 22.7 22.7 0 0 0-1.5-4.7 22.6 22.6 0 0 0-4.6-6.7 21.9 21.9 0 0 0-6.9-4.7 21.2 21.2 0 0 0-8.1-1.8H92zm9.1 33.7l.3.1a1 1 0 0 1 .6.8v.4a8.4 8.4 0 0 1 0 .5 8.8 8.8 0 0 1-1.6 4.2l-1 1.3A10 10 0 0 1 95 66c-1.3.3-2.7.4-4 .3a10.4 10.4 0 0 1-2.7-.8 10 10 0 0 1-3.6-2.5 9.3 9.3 0 0 1-.8-1 9 9 0 0 1-.7-1.2 8.6 8.6 0 0 1-.8-3.4V57a1 1 0 0 1 .3-.6 1 1 0 0 1 1.3-.2 1 1 0 0 1 .4.8v.4a6.5 6.5 0 0 0 .5 2.2 7 7 0 0 0 2.1 2.8l1 .6c2.6 1.6 6 1.6 8.5 0a8 8 0 0 0 1.1-.6 7.6 7.6 0 0 0 1.2-1.2 7 7 0 0 0 1-1.7 6.5 6.5 0 0 0 .4-2.5 1 1 0 0 1 .7-1h.4zM30.7 43.7c-15.5 1-28.5-6-30.1-16.4C-1.2 15.7 11.6 4 29 1.3 46.6-1.7 62.3 5.5 64 17.1c1.6 10.4-8.7 21-23.7 25a31.2 31.2 0 0 0 0 .9v.3a19 19 0 0 0 .1 1l.1.4.1.9a4.7 4.7 0 0 0 .5 1l.7 1a9.2 9.2 0 0 0 1.2 1l1.5.8.6.8-.7.6-1.1.3a11.2 11.2 0 0 1-2.6.4 8.6 8.6 0 0 1-3-.5 8.5 8.5 0 0 1-1-.4 11.2 11.2 0 0 1-1.8-1.2 13.3 13.3 0 0 1-1-1 18 18 0 0 1-.7-.6l-.4-.4a23.4 23.4 0 0 1-1.3-1.8l-.1-.1-.3-.5V45l-.3-.6v-.7zM83.1 36c3.6 0 6.5 3.2 6.5 7.1 0 4-3 7.2-6.5 7.2S76.7 47 76.7 43 79.6 36 83 36zm18 0c3.6 0 6.5 3.2 6.5 7.1 0 4-2.9 7.2-6.4 7.2S94.7 47 94.7 43s3-7.1 6.5-7.1zm-18 6.1c2 0 3.5 1.6 3.5 3.6S85 49.2 83 49.2s-3.4-1.6-3.4-3.6S81.2 42 83 42zm17.9 0c1.9 0 3.4 1.6 3.4 3.6s-1.5 3.6-3.4 3.6c-2 0-3.5-1.6-3.5-3.6S99.1 42 101 42zM17 28c-.3 1.6-1.8 5-5.2 5.8-2.5.6-4.1-.8-4.5-2.6-.4-1.9.7-3.5 2.1-4.5A3.5 3.5 0 0 1 8 24.6c-.4-2 .8-3.7 3.2-4.2 1.9-.5 3.1.2 3.4 1.5.3 1.1-.5 2.2-1.8 2.5-.9.3-1.6 0-1.7-.6a1.4 1.4 0 0 1 0-.7s.3.2 1 0c.7-.1 1-.7.9-1.2-.2-.6-1-.8-1.8-.6-1 .2-2 1-1.7 2.6.3 1 .9 1.6 1.5 1.8l.7-.2c1-.2 1.5 0 1.6.5 0 .4-.2 1-1.2 1.2a3.3 3.3 0 0 1-1.5 0c-.9.7-1.6 1.9-1.3 3.2.3 1.3 1.3 2.2 3 1.8 2.5-.7 3.8-3.7 4.2-5-.3-.5-.6-1-.7-1.6-.1-.5.1-1 .9-1.2.4 0 .7.2.8.8a2.8 2.8 0 0 1 0 1l.7 1c.6-2 1.4-4 1.7-4 .6-.2 1.5.6 1.5.6-.8.7-1.7 2.4-2.3 4.2.8.6 1.6 1 2.1 1 .5-.1.8-.6 1-1.2-.3-2.2 1-4.3 2.3-4.6.7-.2 1.3.2 1.4.8.1.5 0 1.3-.9 1.7-.2-1-.6-1.3-1-1.3-.4.1-.7 1.4-.4 2.8.2 1 .7 1.5 1.3 1.4.8-.2 1.3-1.2 1.7-2.1-.3-2.1.9-4.2 2.2-4.5.7-.2 1.2.1 1.4 1 .4 1.4-1 2.8-2.2 3.4.3.7.7 1 1.3.9 1-.3 1.6-1.5 2-2.5l-.5-3v-.3s1.6-.3 1.8.6v.1c.2-.6.7-1.2 1.3-1.4.8-.1 1.5.6 1.7 1.6.5 2.2-.5 4.4-1.8 4.7H33a31.9 31.9 0 0 0 1 5.2c-.4.1-1.8.4-2-.4l-.5-5.6c-.5 1-1.3 2.2-2.5 2.4-1 .3-1.6-.3-2-1.1-.5 1-1.3 2.1-2.4 2.4-.8.2-1.5-.1-2-1-.3.8-.9 1.5-1.5 1.7-.7.1-1.5-.3-2.4-1-.3.8-.4 1.6-.4 2.2 0 0-.7 0-.8-.4-.1-.5 0-1.5.3-2.7a10.3 10.3 0 0 1-.7-.8zm38.2-17.8l.2.9c.5 1.9.4 4.4.8 6.4 0 .6-.4 3-1.4 3.3-.2 0-.3 0-.4-.4-.1-.7 0-1.6-.3-2.6-.2-1.1-.8-1.6-1.5-1.5-.8.2-1.3 1-1.6 2l-.1-.5c-.2-1-1.8-.6-1.8-.6a6.2 6.2 0 0 1 .4 1.3l.2 1c-.2.5-.6 1-1.2 1l-.2.1a7 7 0 0 0-.1-.8c-.3-1.1-1-2-1.6-1.8a.7.7 0 0 0-.4.3c-1.3.3-2.4 2-2.1 3.9-.2.9-.6 1.7-1 1.9-.5 0-.8-.5-1.1-1.8l-.1-1.2a4 4 0 0 0 0-1.7c0-.4-.4-.7-.8-.6-.7.2-.9 1.7-.5 3.8-.2 1-.6 2-1.3 2-.4.2-.8-.2-1-1l-.2-3c1.2-.5 2-1 1.8-1.7-.1-.5-.8-.7-.8-.7s0 .7-1 1.2l-.2-1.4c-.1-.6-.4-1-1.7-.6l.4 1 .2 1.5h-1v.8c0 .3.4.3 1 .2 0 1.3 0 2.7.2 3.6.3 1.4 1.2 2 2 1.7 1-.2 1.6-1.3 2-2.3.3 1.2 1 2 1.9 1.7.7-.2 1.2-1.1 1.6-2.2.4.8 1.1 1.1 2 1 1.2-.4 1.7-1.6 1.8-2.8h.2c.6-.2 1-.6 1.3-1 0 .8 0 1.5.2 2.1.1.5.3.7.6.6.5-.1 1-.9 1-.9a4 4 0 0 1-.3-1c-.3-1.3.3-3.6 1-3.7.2 0 .3.2.5.7v.8l.2 1.5v.7c.2.7.7 1.3 1.5 1 1.3-.2 2-2.6 2.1-3.9.3.2.6.2 1 .1-.6-2.2 0-6.1-.3-7.9-.1-.4-1-.5-1.7-.5h-.4zm-21.5 12c.4 0 .7.3 1 1.1.2 1.3-.3 2.6-.9 2.8-.2 0-.7 0-1-1.2v-.4c0-1.3.4-2 1-2.2zm-5.2 1c.3 0 .6.2.6.5.2.6-.3 1.3-1.2 2-.3-1.4.1-2.3.6-2.5zm18-.4c-.5.2-1-.4-1.2-1.2-.2-1 0-2.1.7-2.5v.5c.2.7.6 1.5 1.3 1.9 0 .7-.2 1.2-.7 1.3zm10-1.6c0 .5.4.7 1 .6.8-.2 1-1 .8-1.6 0-.5-.4-1-1-.8-.5.1-1 .9-.8 1.8zm-14.3-5.5c0-.4-.5-.7-1-.5-.8.2-1 1-.9 1.5.2.6.5 1 1 .8.5 0 1.1-1 1-1.8z"" fill=""#fff"" fill-opacity="".6""/>'.$this->addElementToGhost().'</svg>';    }    private function addElementToGhost(): string    {        if (!isset(self::GHOST_ADDONS[date('m-d')])) {            return '';        }        return '<path d=""'.self::GHOST_ADDONS[date('m-d')].'"" fill=""#fff"" fill-opacity=""0.6""></path>';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ramsey_uuid_UuidFactory_1998," Returns an RFC 4122 variant Uuid, created from the provided bytes and version\\n\\n @param string $bytes The byte string to convert to a UUID\\n @param int $version The RFC 4122 version to apply to the UUID\\n\\n @return UuidInterface An instance of UuidInterface, created from the\\n     byte string and version\\n\\n @psalm-pure\\n","Vraća RFC 4122 varijantu Uuid, kreiranu od ponuđenih bajtova i verzije","    private function uuidFromBytesAndVersion(string $bytes, int $version): UuidInterface    {        /** @var array $unpackedTime */        $unpackedTime = unpack('n*', substr($bytes, 6, 2));        $timeHi = (int) $unpackedTime[1];        $timeHiAndVersion = pack('n*', BinaryUtils::applyVersion($timeHi, $version));        /** @var array $unpackedClockSeq */        $unpackedClockSeq = unpack('n*', substr($bytes, 8, 2));        $clockSeqHi = (int) $unpackedClockSeq[1];        $clockSeqHiAndReserved = pack('n*', BinaryUtils::applyVariant($clockSeqHi));        $bytes = substr_replace($bytes, $timeHiAndVersion, 6, 2);        $bytes = substr_replace($bytes, $clockSeqHiAndReserved, 8, 2);        if ($this->isDefaultFeatureSet) {            return LazyUuidFromString::fromBytes($bytes);        }        return $this->uuid($bytes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_exporter_Exporter_1035, Exports a value into a single-line string.\n\n The output of this method is similar to the output of\n SebastianBergmann\\Exporter\\Exporter::export().\n\n Newlines are replaced by the visible string '\\n'.\n Contents of arrays and objects (if any) are replaced by '...'.\n,Izvozi vrednost u jednoredni niz. Izlaz ove metode sličan je izlazu SebastianBergmann\\Exporter\\Exporter::export(). Novi redovi se zamenjuju vidljivim stringom '\\ n'. Sadržaj nizova i objekata (ako ih ima) zamenjuje se sa '...',"    public function shortenedExport(mixed $value): string    {        if (is_string($value)) {            $string = str_replace(""\n"", '', $this->export($value));            if (function_exists('mb_strlen') && function_exists('mb_substr') && mb_strlen($string) > 40) {                return mb_substr($string, 0, 30) . '...' . mb_substr($string, -7);            }            if (strlen($string) > 40) {                return substr($string, 0, 30) . '...' . substr($string, -7);            }            return $string;        }        if (is_object($value)) {            return sprintf(                '%s Object (%s)',                get_class($value),                count($this->toArray($value)) > 0 ? '...' : ''            );        }        if (is_array($value)) {            return sprintf(                'Array (%s)',                count($value) > 0 ? '...' : ''            );        }        return $this->export($value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LOESS_3573, LOESS - Locally Weighted Scatterplot Smoothing (Local regression)\\n\\n A non-parametric method for fitting a smooth curve between two variables.\\n https://en.wikipedia.org/wiki/Local_regression\\n,LOESS - Lokalno ponderisano ujednačavanje dijagrama rasejavanja (lokalna regresija). Neparametarska metoda za uklapanje glatke krive između dve promenljive,"class LOESS extends NonParametricRegression{    use Methods\WeightedLeastSquares;    /**     * Smoothness parameter     * @var number     */    protected $Î±;    /**     * Order of the polynomial fit     * @var int     */    protected $Î»;    /**     * Number of points considered in the local regression     * @var int     */    protected $number_of_points;    /**     * @param array $points [ [x, y], [x, y], ... ]     * @param float $Î±      Smoothness parameter (bandwidth)     *                       Determines how much of the data is used to fit each local polynomial     *                       ((Î» + 1) / n, 1]     * @param int    $Î»      Order of the polynomial to fit     *     * @throws Exception\OutOfBoundsException if Î± is â‰¤ Î» + 1 or > 1     */    public function __construct($points, float $Î±, int $Î»)    {        $this->Î± = $Î±;        $this->Î» = $Î»;        parent::__construct($points);        // Î± âˆˆ ((Î» + 1) / n, 1]        if (($Î± <= ($Î» + 1) / $this->n) || $Î± > 1) {            throw new Exception\OutOfBoundsException('Smoothness parameter Î± must be between ' . ($Î» + 1) / $this->n . "" and 1; given $Î±"");        }        // Number of points considered in the local regression        $this->number_of_points = \min((int) \ceil($this->Î± * $this->n), $this->n);    }    /**     * Evaluate for x     * Use the smoothness parameter Î± to determine the subset of data to consider for     * local regression. Perform a weighted least squares regression and evaluate x.     *     * @param  float $x     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\VectorException     */    public function evaluate(float $x): float    {        $Î± = $this->Î±;        $Î» = $this->Î»;        // The number of points considered in the local regression        $Î”x    = Single::abs(Single::subtract($this->xs, $x));        $Î±áµ—Ê°Î”x = Average::kthSmallest($Î”x, $this->number_of_points - 1);        $arg   = Single::min(Single::divide($Î”x, $Î±áµ—Ê°Î”x * \max($Î±, 1)), 1);        // Kernel function: tricube = (1-argÂ³)Â³        $tricube = Single::cube(Single::multiply(Single::subtract(Single::cube($arg), 1), -1));        $weights = $tricube;        // Local Regression Parameters        $parameters = $this->leastSquares($this->ys, $this->xs, $weights, $Î»);        $X          = MatrixFactory::vandermonde([$x], $Î» + 1);        return $X->multiply($parameters)[0][0];    }}",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_947, Replace a block.\n\n @param string $blockname\n @param string $replacement\n,Zamena bloka,"    public function replaceBlock($blockname, $replacement)    {        $matches = array();        preg_match(            '/(<\?xml.*)(<w:p.*>\${' . $blockname . '}<\/w:.*?p>)(.*)(<w:p.*\${\/' . $blockname . '}<\/w:.*?p>)/is',            $this->tempDocumentMainPart,            $matches        );        if (isset($matches[3])) {            $this->tempDocumentMainPart = str_replace(                $matches[2] . $matches[3] . $matches[4],                $replacement,                $this->tempDocumentMainPart            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
erusev_parsedown_Parsedown_1872, Replace occurrences $regexp with $Elements in $text. Return an array of\n elements representing the replacement.\n,Zamenite pojave $regexp sa $Elements u $text. Vrati niz elemenata koji predstavljaju zamenu,"    protected static function pregReplaceElements($regexp, $Elements, $text)    {        $newElements = array();        while (preg_match($regexp, $text, $matches, PREG_OFFSET_CAPTURE))        {            $offset = $matches[0][1];            $before = substr($text, 0, $offset);            $after = substr($text, $offset + strlen($matches[0][0]));            $newElements[] = array('text' => $before);            foreach ($Elements as $Element)            {                $newElements[] = $Element;            }            $text = $after;        }        $newElements[] = array('text' => $text);        return $newElements;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Fixer_889, Replace the entire contents of a token.\\n\\n @param int    $stackPtr The position of the token in the token stack.\\n @param string $content  The new content of the token.\\n\\n @return bool If the change was accepted.\\n,Zamenite celokupan sadržaj tokena,"    public function replaceToken($stackPtr, $content)    {        if ($this->inConflict === true) {            return false;        }        if ($this->inChangeset === false            && isset($this->fixedTokens[$stackPtr]) === true        ) {            $indent = ""\t"";            if (empty($this->changeset) === false) {                $indent .= ""\t"";            }            if (PHP_CODESNIFFER_VERBOSITY > 1) {                @ob_end_clean();                echo ""$indent* token $stackPtr has already been modified, skipping *"".PHP_EOL;                ob_start();            }            return false;        }        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $bt = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);            if ($bt[1]['class'] === 'PHP_CodeSniffer\Fixer') {                $sniff = $bt[2]['class'];                $line  = $bt[1]['line'];            } else {                $sniff = $bt[1]['class'];                $line  = $bt[0]['line'];            }            $sniff = Util\Common::getSniffCode($sniff);            $tokens     = $this->currentFile->getTokens();            $type       = $tokens[$stackPtr]['type'];            $tokenLine  = $tokens[$stackPtr]['line'];            $oldContent = Common::prepareForOutput($this->tokens[$stackPtr]);            $newContent = Common::prepareForOutput($content);            if (trim($this->tokens[$stackPtr]) === '' && isset($this->tokens[($stackPtr + 1)]) === true) {                // Add some context for whitespace only changes.                $append      = Common::prepareForOutput($this->tokens[($stackPtr + 1)]);                $oldContent .= $append;                $newContent .= $append;            }        }//end if        if ($this->inChangeset === true) {            $this->changeset[$stackPtr] = $content;            if (PHP_CODESNIFFER_VERBOSITY > 1) {                @ob_end_clean();                echo ""\t\tQ: $sniff:$line replaced token $stackPtr ($type on line $tokenLine) \""$oldContent\"" => \""$newContent\"""".PHP_EOL;                ob_start();            }            return true;        }        if (isset($this->oldTokenValues[$stackPtr]) === false) {            $this->oldTokenValues[$stackPtr] = [                'curr' => $content,                'prev' => $this->tokens[$stackPtr],                'loop' => $this->loops,            ];        } else {            if ($this->oldTokenValues[$stackPtr]['prev'] === $content                && $this->oldTokenValues[$stackPtr]['loop'] === ($this->loops - 1)            ) {                if (PHP_CODESNIFFER_VERBOSITY > 1) {                    $indent = ""\t"";                    if (empty($this->changeset) === false) {                        $indent .= ""\t"";                    }                    $loop = $this->oldTokenValues[$stackPtr]['loop'];                    @ob_end_clean();                    echo ""$indent**** $sniff:$line has possible conflict with another sniff on loop $loop; caused by the following change ****"".PHP_EOL;                    echo ""$indent**** replaced token $stackPtr ($type on line $tokenLine) \""$oldContent\"" => \""$newContent\"" ****"".PHP_EOL;                }                if ($this->oldTokenValues[$stackPtr]['loop'] >= ($this->loops - 1)) {                    $this->inConflict = true;                    if (PHP_CODESNIFFER_VERBOSITY > 1) {                        echo ""$indent**** ignoring all changes until next loop ****"".PHP_EOL;                    }                }                if (PHP_CODESNIFFER_VERBOSITY > 1) {                    ob_start();                }                return false;            }//end if            $this->oldTokenValues[$stackPtr]['prev'] = $this->oldTokenValues[$stackPtr]['curr'];            $this->oldTokenValues[$stackPtr]['curr'] = $content;            $this->oldTokenValues[$stackPtr]['loop'] = $this->loops;        }//end if        $this->fixedTokens[$stackPtr] = $this->tokens[$stackPtr];        $this->tokens[$stackPtr]      = $content;        $this->numFixes++;        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $indent = ""\t"";            if (empty($this->changeset) === false) {                $indent .= ""\tA: "";            }            if (ob_get_level() > 0) {                ob_end_clean();            }            echo ""$indent$sniff:$line replaced token $stackPtr ($type on line $tokenLine) \""$oldContent\"" => \""$newContent\"""".PHP_EOL;            ob_start();        }        return true;    }//end replaceToken()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1547, Get a PHP manual database connection.\n\n @return \\PDO\n,Kreiranje PHP ručnog povezivanja sa bazom podataka,"    public function getManualDb()    {        if (!isset($this->manualDb)) {            $dbFile = $this->getManualDbFile();            if (\is_file($dbFile)) {                try {                    $this->manualDb = new \PDO('sqlite:'.$dbFile);                } catch (\PDOException $e) {                    if ($e->getMessage() === 'could not find driver') {                        throw new RuntimeException('SQLite PDO driver not found', 0, $e);                    } else {                        throw $e;                    }                }            }        }        return $this->manualDb;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_RedisCache_581, Redis <http://redis.io> cache backend\\n Requires phpredis native extension <https://github.com/phpredis/phpredis#installation>.\\n,Redis <http://redis.io> ke[iran bekend. Zahteva izvorni dodatak phpredis <https://github.com/phpredis/phpredis#installation>,"class RedisCache implements CacheInterface{    const KEY_PREFIX = 'botman:cache:';    /** @var Redis */    private $redis;    private $host;    private $port;    private $auth;    /**     * RedisCache constructor.     * @param $host     * @param $port     * @param $auth     */    public function __construct($host = '127.0.0.1', $port = 6379, $auth = null)    {        if (! class_exists('Redis')) {            throw new RuntimeException('phpredis extension is required for RedisCache');        }        $this->host = $host;        $this->port = $port;        $this->auth = $auth;        $this->connect();    }    /**     * Determine if an item exists in the cache.     *     * @param  string $key     * @return bool     */    public function has($key)    {        /*         * Version >= 4.0 of phpredis returns an integer instead of bool         */        $check = $this->redis->exists($this->decorateKey($key));        if (is_bool($check)) {            return $check;        }        return $check > 0;    }    /**     * Retrieve an item from the cache by key.     *     * @param  string $key     * @param  mixed $default     * @return mixed     */    public function get($key, $default = null)    {        return $this->redis->get($this->decorateKey($key)) ?: $default;    }    /**     * Retrieve an item from the cache and delete it.     *     * @param  string $key     * @param  mixed $default     * @return mixed     */    public function pull($key, $default = null)    {        $redisKey = $this->decorateKey($key);        $r = $this->redis->multi()            ->get($redisKey)            ->del($redisKey)            ->exec();        return $r[0] ?: $default;    }    /**     * Store an item in the cache.     *     * @param  string $key     * @param  mixed $value     * @param  \DateTime|int $minutes     * @return void     */    public function put($key, $value, $minutes)    {        if ($minutes instanceof \Datetime) {            $seconds = $minutes->getTimestamp() - time();        } else {            $seconds = $minutes * 60;        }        $this->redis->setex($this->decorateKey($key), $seconds, $value);    }    /**     * Namespace botman keys in redis.     *     * @param $key     * @return string     */    private function decorateKey($key)    {        return self::KEY_PREFIX.$key;    }    private function connect()    {        $this->redis = new Redis();        $this->redis->connect($this->host, $this->port);        if ($this->auth !== null) {            $this->redis->auth($this->auth);        }        if (function_exists('igbinary_serialize') && defined('Redis::SERIALIZER_IGBINARY')) {            $this->redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_IGBINARY);        } else {            $this->redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);        }    }    public function __wakeup()    {        $this->connect();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_HeaderUtils_7879," Encodes a string as a quoted string, if necessary.\n\n If a string contains characters not allowed by the ""token"" construct in\n the HTTP specification, it is backslash-escaped and enclosed in quotes\n to match the ""quoted-string"" construct.\n","Ako je potrebno, kodira niz kao citirani niz. Ako niz sadrži znakove koji nisu dozvoljeni ""token"" konstrukcijom u HTTP specifikaciji, stavlja se kosa crta u navodnike da bi se podudarao sa "" citiranim stringom"" konstrukcija","    public static function quote(string $s): string    {        if (preg_match('/^[a-z0-9!#$%&\'*.^_`|~-]+$/i', $s)) {            return $s;        }        return '""'.addcslashes($s, '""\\""').'""';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_Tag_760, Get a full URL to start a tag name and value search for this tag's values.\n,Dohvata URL do početka imena taga i pretražuje po vrednosti taj taga,    public function valueUrl(): string    {        return url('/search?term=%5B' . urlencode($this->name) .'%3D' . urlencode($this->value) . '%5D');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_2259, Formats an array as a string.\\n,Formatira niz kao string,"    private function formatArgs(array $args): string    {        $result = [];        foreach ($args as $key => $item) {            if ('object' === $item[0]) {                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));            } elseif ('array' === $item[0]) {                $formattedValue = sprintf('<em>array</em>(%s)', \is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);            } elseif ('null' === $item[0]) {                $formattedValue = '<em>null</em>';            } elseif ('boolean' === $item[0]) {                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';            } elseif ('resource' === $item[0]) {                $formattedValue = '<em>resource</em>';            } else {                $formattedValue = str_replace(""\n"", '', $this->escapeHtml(var_export($item[1], true)));            }            $result[] = \is_int($key) ? $formattedValue : sprintf(""'%s' => %s"", $this->escapeHtml($key), $formattedValue);        }        return implode(', ', $result);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_PhpExecutableFinderTest_1550, tests find() with the env var PHP_PATH.\\\\n,Testira find () sa env var PHP_PATH,"class PhpExecutableFinder{    private $executableFinder;    public function __construct()    {        $this->executableFinder = new ExecutableFinder();    }    /**     * Finds The PHP executable.     *     * @return string|false The PHP executable path or false if it cannot be found     */    public function find(bool $includeArgs = true)    {        if ($php = getenv('PHP_BINARY')) {            if (!is_executable($php)) {                $command = '\\' === \DIRECTORY_SEPARATOR ? 'where' : 'command -v';                if ($php = strtok(exec($command.' '.escapeshellarg($php)), \PHP_EOL)) {                    if (!is_executable($php)) {                        return false;                    }                } else {                    return false;                }            }            return $php;        }        $args = $this->findArguments();        $args = $includeArgs && $args ? ' '.implode(' ', $args) : '';        // PHP_BINARY return the current sapi executable        if (\PHP_BINARY && \in_array(\PHP_SAPI, ['cgi-fcgi', 'cli', 'cli-server', 'phpdbg'], true)) {            return \PHP_BINARY.$args;        }        if ($php = getenv('PHP_PATH')) {            if (!@is_executable($php)) {                return false;            }            return $php;        }        if ($php = getenv('PHP_PEAR_PHP_BIN')) {            if (@is_executable($php)) {                return $php;            }        }        if (@is_executable($php = \PHP_BINDIR.('\\' === \DIRECTORY_SEPARATOR ? '\\php.exe' : '/php'))) {            return $php;        }        $dirs = [\PHP_BINDIR];        if ('\\' === \DIRECTORY_SEPARATOR) {            $dirs[] = 'C:\xampp\php\\';        }        return $this->executableFinder->find('php', false, $dirs);    }    /**     * Finds the PHP executable arguments.     *     * @return array The PHP executable arguments     */    public function findArguments()    {        $arguments = [];        if ('phpdbg' === \PHP_SAPI) {            $arguments[] = '-qrr';        }        return $arguments;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_process_PhpExecutableFinder_1452, An executable finder specifically designed for the PHP executable.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Johannes M. Schmitt <schmittjoh@gmail.com>\n,Izvršni pretraživač posebno dizajniran za PHP izvršnu datoteku,"class PhpExecutableFinder{    private $executableFinder;    public function __construct()    {        $this->executableFinder = new ExecutableFinder();    }    /**     * Finds The PHP executable.     *     * @return string|false The PHP executable path or false if it cannot be found     */    public function find(bool $includeArgs = true)    {        if ($php = getenv('PHP_BINARY')) {            if (!is_executable($php)) {                $command = '\\' === \DIRECTORY_SEPARATOR ? 'where' : 'command -v';                if ($php = strtok(exec($command.' '.escapeshellarg($php)), \PHP_EOL)) {                    if (!is_executable($php)) {                        return false;                    }                } else {                    return false;                }            }            return $php;        }        $args = $this->findArguments();        $args = $includeArgs && $args ? ' '.implode(' ', $args) : '';        // PHP_BINARY return the current sapi executable        if (\PHP_BINARY && \in_array(\PHP_SAPI, ['cgi-fcgi', 'cli', 'cli-server', 'phpdbg'], true)) {            return \PHP_BINARY.$args;        }        if ($php = getenv('PHP_PATH')) {            if (!@is_executable($php)) {                return false;            }            return $php;        }        if ($php = getenv('PHP_PEAR_PHP_BIN')) {            if (@is_executable($php)) {                return $php;            }        }        if (@is_executable($php = \PHP_BINDIR.('\\' === \DIRECTORY_SEPARATOR ? '\\php.exe' : '/php'))) {            return $php;        }        $dirs = [\PHP_BINDIR];        if ('\\' === \DIRECTORY_SEPARATOR) {            $dirs[] = 'C:\xampp\php\\';        }        return $this->executableFinder->find('php', false, $dirs);    }    /**     * Finds the PHP executable arguments.     *     * @return array The PHP executable arguments     */    public function findArguments()    {        $arguments = [];        if ('phpdbg' === \PHP_SAPI) {            $arguments[] = '-qrr';        }        return $arguments;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Composer_1153, Class Composer\n @package Grav\\Common\n, Class Composer,"class Composer{    /** @const Default composer location */    const DEFAULT_PATH = 'bin/composer.phar';    /**     * Returns the location of composer.     *     * @return string     */    public static function getComposerLocation()    {        if (!function_exists('shell_exec') || stripos(PHP_OS, 'win') === 0) {            return self::DEFAULT_PATH;        }        // check for global composer install        $path = trim((string)shell_exec('command -v composer'));        // fall back to grav bundled composer        if (!$path || !preg_match('/(composer|composer\.phar)$/', $path)) {            $path = self::DEFAULT_PATH;        }        return $path;    }    /**     * Return the composer executable file path     *     * @return string     */    public static function getComposerExecutor()    {        $executor = PHP_BINARY . ' ';        $composer = static::getComposerLocation();        if ($composer !== static::DEFAULT_PATH && is_executable($composer)) {            $file = fopen($composer, 'rb');            $firstLine = fgets($file);            fclose($file);            if (!preg_match('/^#!.+php/i', $firstLine)) {                $executor = '';            }        }        return $executor . $composer;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
owncloud_core_AppHelper_1360, Gets the content of an URL by using CURL or a fallback if it is not\\n installed\\n @param string $url the url that should be fetched\\n @return string the content of the webpage\\n @deprecated 8.1.0 Use \\\\OCP\\\\IServerContainer::getHTTPClientService\\n,Dobija sadržaj URL-a pomoću CURL ili otpozivanja (fallback) ako nije instaliran,public function getUrlContent($url) {try {$client = \OC::$server->getHTTPClientService()->newClient();$response = $client->get($url);return $response->getBody();} catch (\Exception $e) {return false;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_VerifyTest_694, Most of the logic for ID token validation is in AuthTest -\n this is just a general check to ensure we verify a valid\n id token if one exists.\n,Većina logike za proveru ID tokena je u AuthTest delu ovo je samo opšta provera kako bismo bili sigurni da verifikujemo važeći ID token ako postoji,"  public function testLeewayIsUnchangedWhenPassingInJwt()  {    $this->checkToken();    $jwt = $this->getJwtService();    // set arbitrary leeway so we can check this later    $jwt::$leeway = $leeway = 1.5;    $client = $this->getClient();    $token = $client->getAccessToken();    if ($client->isAccessTokenExpired()) {      $token = $client->fetchAccessTokenWithRefreshToken();    }    $segments = explode('.', $token['id_token']);    $this->assertCount(3, $segments);    // Extract the client ID in this case as it wont be set on the test client.    $data = json_decode($jwt->urlSafeB64Decode($segments[1]));    $verify = new Google_AccessToken_Verify($client->getHttpClient(), null, $jwt);    $payload = $verify->verifyIdToken($token['id_token'], $data->aud);    // verify the leeway is set as it was    $this->assertEquals($leeway, $jwt::$leeway);  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_165, Returns an element if its id is found\\n\\n @param    string  Element id to find\\n @return   HTML_QuickForm2_Node|null\\n,Vraća element ako je pronađen njegov id,    public function getElementById($id)    {        foreach ($this->getRecursiveIterator() as $element) {            if ($id == $element->getId()) {                return $element;            }        }        return null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_Iban_928, Calculates mod97 on a numeric string\n\n @param string $number Numeric string\n @return int\n,Izračunava mod97 na numeričkom nizu,"    public static function mod97($number)    {        $checksum = (int)$number[0];        for ($i = 1, $size = strlen($number); $i < $size; $i++) {            $checksum = (10 * $checksum + (int) $number[$i]) % 97;        }        return $checksum;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Frame_593, Return the border box of the frame\n\n @return array\n,Vratite granični okvir frame-a,"    public function get_border_box()    {        $style = $this->_style;        $cb = $this->_containing_block;        $x = $this->_position[""x""] + (float)$style->length_in_pt($style->margin_left, $cb[""w""]);        $y = $this->_position[""y""] + (float)$style->length_in_pt($style->margin_top, $cb[""w""]);        $w = $style->length_in_pt(            [                $style->border_left_width,                $style->padding_left,                $style->width,                $style->padding_right,                $style->border_right_width            ],            $cb[""w""]);        $h = $style->length_in_pt(            [                $style->border_top_width,                $style->padding_top,                $style->padding_bottom,                $style->border_bottom_width,                $style->length_in_pt($style->height, $cb[""h""])            ],            $cb[""w""]);        return [0 => $x, ""x"" => $x,            1 => $y, ""y"" => $y,            2 => $w, ""w"" => $w,            3 => $h, ""h"" => $h];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Browser_1454, Get the current major version identifier\n\n @return int the browser major version identifier\n,Dohvata trenutni identifikator glavne verzije,"    public function getVersion()    {        $version = explode('.', $this->getLongVersion());        return (int)$version[0];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonPeriod_317, Format the date period as ISO 8601.\\n\\n @return string\\n,Formatirajte datumski period kao ISO 8601,"    public function toIso8601String()    {        $parts = [];        if ($this->recurrences !== null) {            $parts[] = 'R'.$this->recurrences;        }        $parts[] = $this->startDate->toIso8601String();        $parts[] = $this->dateInterval->spec();        if ($this->endDate !== null) {            $parts[] = $this->endDate->toIso8601String();        }        return implode('/', $parts);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_9885, Returns the Date header as a DateTime instance.\n\n @throws \\RuntimeException When the header is not parseable\n\n @final\n,Vraća zaglavlje datuma kao instancu DateTime,"    public function setDate(\DateTimeInterface $date): object    {        if ($date instanceof \DateTime) {            $date = \DateTimeImmutable::createFromMutable($date);        }        $date = $date->setTimezone(new \DateTimeZone('UTC'));        $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT');        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Cache_2474, Reads/writes to a filesystem cache\n\n @author Jordi Boggiano <j.boggiano@seld.be>\n,Čita/piše u fajl sistem keš memoriju,"class Cache{    private static $cacheCollected = null;    private $io;    private $root;    private $enabled = true;    private $allowlist;    private $filesystem;    private $readOnly;    /**     * @param IOInterface $io     * @param string      $cacheDir   location of the cache     * @param string      $allowlist  List of characters that are allowed in path names (used in a regex character class)     * @param Filesystem  $filesystem optional filesystem instance     * @param bool        $readOnly   whether the cache is in readOnly mode     */    public function __construct(IOInterface $io, $cacheDir, $allowlist = 'a-z0-9.', Filesystem $filesystem = null, $readOnly = false)    {        $this->io = $io;        $this->root = rtrim($cacheDir, '/\\') . '/';        $this->allowlist = $allowlist;        $this->filesystem = $filesystem ?: new Filesystem();        $this->readOnly = (bool) $readOnly;        if (!self::isUsable($cacheDir)) {            $this->enabled = false;            return;        }        if (            (!is_dir($this->root) && !Silencer::call('mkdir', $this->root, 0777, true))            || !is_writable($this->root)        ) {            $this->io->writeError('<warning>Cannot create cache directory ' . $this->root . ', or directory is not writable. Proceeding without cache</warning>');            $this->enabled = false;        }    }    /**     * @param bool $readOnly     */    public function setReadOnly($readOnly)    {        $this->readOnly = (bool) $readOnly;    }    /**     * @return bool     */    public function isReadOnly()    {        return $this->readOnly;    }    public static function isUsable($path)    {        return !preg_match('{(^|[\\\\/])(\$null|nul|NUL|/dev/null)([\\\\/]|$)}', $path);    }    public function isEnabled()    {        return $this->enabled;    }    public function getRoot()    {        return $this->root;    }    public function read($file)    {        if ($this->enabled) {            $file = preg_replace('{[^'.$this->allowlist.']}i', '-', $file);            if (file_exists($this->root . $file)) {                $this->io->writeError('Reading '.$this->root . $file.' from cache', true, IOInterface::DEBUG);                return file_get_contents($this->root . $file);            }        }        return false;    }    public function write($file, $contents)    {        if ($this->enabled && !$this->readOnly) {            $file = preg_replace('{[^'.$this->allowlist.']}i', '-', $file);            $this->io->writeError('Writing '.$this->root . $file.' into cache', true, IOInterface::DEBUG);            $tempFileName = $this->root . $file . uniqid('.', true) . '.tmp';            try {                return file_put_contents($tempFileName, $contents) !== false && rename($tempFileName, $this->root . $file);            } catch (\ErrorException $e) {                $this->io->writeError('<warning>Failed to write into cache: '.$e->getMessage().'</warning>', true, IOInterface::DEBUG);                if (preg_match('{^file_put_contents\(\): Only ([0-9]+) of ([0-9]+) bytes written}', $e->getMessage(), $m)) {                    // Remove partial file.                    unlink($tempFileName);                    $message = sprintf(                        '<warning>Writing %1$s into cache failed after %2$u of %3$u bytes written, only %4$u bytes of free space available</warning>',                        $tempFileName,                        $m[1],                        $m[2],                        @disk_free_space(dirname($tempFileName))                    );                    $this->io->writeError($message);                    return false;                }                throw $e;            }        }        return false;    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_FrameCollection_9359," Filters frames using a callable, returns the same FrameCollection\n\n @param  callable        $callable\n @return FrameCollection\n","Filtrira frejmove koristeći pozivnu promenjivu, vraća isti FrameCollection","    public function filter($callable)    {        $this->frames = array_values(array_filter($this->frames, $callable));        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_589, Filter function to access internal integer font values\\\\n\\\\n @return int\\\\n,Funkcija filtriranja za pristup unutrašnjim celobrojnim font vrednostima,"    private function getInternalFont()    {        $internalfont = is_null($this->file) ? 1 : $this->file;        $internalfont = is_numeric($internalfont) ? $internalfont : false;        if ( ! in_array($internalfont, [1, 2, 3, 4, 5])) {            throw new NotSupportedException(                sprintf('Internal GD font (%s) not available. Use only 1-5.', $internalfont)            );        }        return intval($internalfont);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1558, Return filters for processing lines from safe universal phalcon.c\n\n @return array\n,Vraća filtere za linije za obradu iz sigurnog univerzalnog phalcon.c,"    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_ExcludeDirectoryFilterIterator_1141," Filters the iterator values.\n\n @return bool True if the value should be kept, false otherwise\n",Filtrira vrednosti iteratora,"    public function accept()    {        if ($this->isRecursive && isset($this->excludedDirs[$this->getFilename()]) && $this->isDir()) {            return false;        }        if ($this->excludedPattern) {            $path = $this->isDir() ? $this->current()->getRelativePathname() : $this->current()->getRelativePath();            $path = str_replace('\\', '/', $path);            return !preg_match($this->excludedPattern, $path);        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_8732, Filters items on their value using given regex.\n\n @return self\n,Filtrira stavke prema njihovoj vrednosti pomoću datog regularnog izraza,"    public function filter(string $pattern)    {        return new self(array_filter($this->items, function (AcceptHeaderItem $item) use ($pattern) {            return preg_match($pattern, $item->getValue());        }));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_ActivityService_742, Filters out similar activity.\n @param Activity[] $activities\n @return array\n,Filtrira slične aktivnosti,    protected function filterSimilar(iterable $activities): array    {        $newActivity = [];        $previousItem = null;        foreach ($activities as $activityItem) {            if (!$previousItem || !$activityItem->isSimilarTo($previousItem)) {                $newActivity[] = $activityItem;            }            $previousItem = $activityItem;        }        return $newActivity;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonPeriod_278, Parse given ISO 8601 string into an array of arguments.\\n\\n @SuppressWarnings(PHPMD.ElseExpression)\\n\\n @param string $iso\\n\\n @return array\\n,Analizirajte dati ISO 8601 string u niz argumenata,"    protected static function parseIso8601($iso)    {        $result = [];        $interval = null;        $start = null;        $end = null;        foreach (explode('/', $iso) as $key => $part) {            if ($key === 0 && preg_match('/^R([0-9]*)$/', $part, $match)) {                $parsed = \strlen($match[1]) ? (int) $match[1] : null;            } elseif ($interval === null && $parsed = CarbonInterval::make($part)) {                $interval = $part;            } elseif ($start === null && $parsed = Carbon::make($part)) {                $start = $part;            } elseif ($end === null && $parsed = Carbon::make(static::addMissingParts($start ?? '', $part))) {                $end = $part;            } else {                throw new InvalidPeriodParameterException(""Invalid ISO 8601 specification: $iso."");            }            $result[] = $parsed;        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_generate-api-docs_2099, Read the file and parse it\n,Pročitajte datoteku i raščlanite,"function processDocument(string $file): array{    $return   = [];    $contents = file_get_contents($file);    $parse    = zephir_parse_file($contents, '(eval code)');    foreach ($parse as $item) {        $type = $item['type'] ?? '';        if ('namespace' === $type) {            $return['namespace'] = $item['name'];            continue;        }        if ('comment' === $type) {            $return['comment'] = getDocblockMethod($item['value']);            continue;        }        if ('use' === $type) {            $uses    = $return['uses'] ?? [];            $aliases = $item['aliases'];            foreach ($aliases as $alias) {                $uses[] = $alias['name'];            }            $return['uses'] = $uses;        }        if ('class' === $type || 'interface' === $type) {            $signature = '';            if (1 === ($item['final'] ?? 0)) {                $signature .= ' Final';            }            if (1 === ($item['abstract'] ?? 0)) {                $signature .= ' Abstract';            }            $signature           .= ('class' === $type) ? ' Class ' : ' Interface ';            $signature           .= $return['namespace'] . '\\' . $item['name'];            $return['signature'] = ltrim($signature);            //$return['signature'] = ltrim(str_replace('Phalcon\\', '', $signature));            $return['extends'] = $item['extends'] ?? '';            if (true === is_array($return['extends'])) {                $return['extends'] = $return['extends'][0]['value'];            }            $implements = $item['implements'] ?? [];            if (count($implements) > 0) {                foreach ($implements as $implement) {                    $return['implements'][] = $implement['value'];                }            }            $definition           = $item['definition'] ?? [];            $return['constants']  = parseConstants($definition);            $return['properties'] = parseProperties($definition);            $return['methods']    = parseMethods($definition);        }    }    return $return;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_Container_439, Get current ordered number\\\\\\\\n\\\\\\\\n @return int\\\\\\\\n,Dobijte trenutni naručeni broj,    public function mockery_getCurrentOrder()    {        return $this->_currentOrder;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2087, Get current url.\\n\\n @return string\\n,Preuzmi trenutni url,    public function getUrl(): string    {        if ($this->url) {            return $this->url;        }        return Support\current_url();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AdminAccessController_861," Get the current profile id.\n\n @return int the $_GET['profile'] if valid, else 1 (the first profile id)\n",Preuzmi trenutni profil,    public function getCurrentProfileId()    {        return (isset($_GET['id_profile']) && !empty($_GET['id_profile']) && is_numeric($_GET['id_profile'])) ? (int) $_GET['id_profile'] : 1;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_453, Processes and returns encoded image as data-url string\n\n @return string\n,Obrađuje i vraća kodiranu sliku kao data-url string,"    protected function processDataUrl()    {        $mime = $this->image->mime ? $this->image->mime : 'image/png';        return sprintf('data:%s;base64,%s',            $mime,            base64_encode($this->process($this->image, $mime, $this->quality))        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Cookie_7839, Creates a cookie copy with a new value.\n\n @return static\n,Stvara kopiju kolačića sa novom vrednošću,    public function withValue(?string $value): self    {        $cookie = clone $this;        $cookie->value = $value;        return $cookie;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Cookie_9709, Creates a cookie copy with a new path on the server in which the cookie will be available on.\n\n @return static\n,Stvara kopiju kolačića sa novom putanjom na serveru na kojem će kolačić biti dostupan,    public function withPath(string $path): self    {        $cookie = clone $this;        $cookie->path = '' === $path ? '/' : $path;        return $cookie;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Cookie_9711, Returns the cookie as a string.\n\n @return string The cookie\n,Vraća kolačić kao string,"    public function __toString()    {        if ($this->isRaw()) {            $str = $this->getName();        } else {            $str = str_replace(self::RESERVED_CHARS_FROM, self::RESERVED_CHARS_TO, $this->getName());        }        $str .= '=';        if ('' === (string) $this->getValue()) {            $str .= 'deleted; expires='.gmdate('D, d-M-Y H:i:s T', time() - 31536001).'; Max-Age=0';        } else {            $str .= $this->isRaw() ? $this->getValue() : rawurlencode($this->getValue());            if (0 !== $this->getExpiresTime()) {                $str .= '; expires='.gmdate('D, d-M-Y H:i:s T', $this->getExpiresTime()).'; Max-Age='.$this->getMaxAge();            }        }        if ($this->getPath()) {            $str .= '; path='.$this->getPath();        }        if ($this->getDomain()) {            $str .= '; domain='.$this->getDomain();        }        if (true === $this->isSecure()) {            $str .= '; secure';        }        if (true === $this->isHttpOnly()) {            $str .= '; httponly';        }        if (null !== $this->getSameSite()) {            $str .= '; samesite='.$this->getSameSite();        }        return $str;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_Middleware_1084, Middleware that adds cookies to requests.\n\n The options array must be set to a CookieJarInterface in order to use\n cookies. This is typically handled for you by a client.\n\n @return callable Returns a function that accepts the next handler.\n,Međuprogrami koji dodaju kolačiće zahtevima. Niz opcija mora biti postavljeno na CookieJarInterface da bi se koristilo kolačiće. Ovo za vas obično rešava klijent,"    public static function cookies(): callable    {        return static function (callable $handler): callable {            return static function ($request, array $options) use ($handler) {                if (empty($options['cookies'])) {                    return $handler($request, $options);                } elseif (!($options['cookies'] instanceof CookieJarInterface)) {                    throw new \InvalidArgumentException('cookies must be an instance of GuzzleHttp\Cookie\CookieJarInterface');                }                $cookieJar = $options['cookies'];                $request = $cookieJar->withCookieHeader($request);                return $handler($request, $options)                    ->then(                        static function (ResponseInterface $response) use ($cookieJar, $request): ResponseInterface {                            $cookieJar->extractCookies($request, $response);                            return $response;                        }                    );            };        };    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3410, Remove an element from the set\\n Does nothing if the element does not exist in the set.\\n\\n @param  mixed $x\\n\\n @return Set (this set)\\n,Uklonite element iz skupa. Ne radi ništa ako element ne postoji u skupu,    public function remove($x): Set    {        unset($this->A[$this->getKey($x)]);        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3411, Remove elements from the set\n Does nothing if the element does not exist in the set.\n\n @param  array $x\n\n @return Set (this set)\n,Ukloni elemente iz skupa. Ne čini ništa ako element ne postoji u skupu,    public function removeMulti(array $x): Set    {        foreach ($x as $member) {            unset($this->A[$this->getKey($member)]);        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Frame_7485," Unserializes the frame data, while also preserving\n any existing comment data.\n\n @see Serializable::unserialize\n @param string $serializedFrame\n","Neserijalizuje podatke okvira, istovremeno zadržavajući sve postojeće podatke komentara",    public function unserialize($serializedFrame)    {        $frame = unserialize($serializedFrame);        if (!empty($frame['_comments'])) {            $this->comments = $frame['_comments'];            unset($frame['_comments']);        }        $this->frame = $frame;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_FrameCollection_7120, Gets the innermost part of stack trace that is not the same as that of outer exception\n\n @param  FrameCollection $parentFrames Outer exception frames to compare tail against\n @return Frame[]\n,Dobiva unutrašnji deo traga steka koji nije isti kao onaj spoljnog izuzetka,    public function topDiff(FrameCollection $parentFrames)    {        $diff = $this->frames;        $parentFrames = $parentFrames->getArray();        $p = count($parentFrames)-1;        for ($i = count($diff)-1; $i >= 0 && $p >= 0; $i--) {            /** @var Frame $tailFrame */            $tailFrame = $diff[$i];            if ($tailFrame->equals($parentFrames[$p])) {                unset($diff[$i]);            }            $p--;        }        return $diff;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_RowEvolution_983," Given the Row evolution dataTable, and the associated metadata,\n enriches the metadata with min/max values, and % change between the first period and the last one\n @param array $metadata\n @param DataTable\\Map $dataTable\n","S datim redom dataTable i povezanim metapodacima, obogaćuje metapodatke min/max vrednostima i % promena između prvog i poslednjeg perioda","    private function enhanceRowEvolutionMetaData(&$metadata, $dataTable)    {        // prepare result array for metrics        $metricsResult = array();        foreach ($metadata['metrics'] as $metric => $name) {            $metricsResult[$metric] = array('name' => $name);            if (!empty($metadata['logos'][$metric])) {                $metricsResult[$metric]['logo'] = $metadata['logos'][$metric];            }        }        unset($metadata['logos']);        $subDataTables = $dataTable->getDataTables();        if (empty($subDataTables)) {            throw new \Exception(""Unexpected state: row evolution API call returned empty DataTable\\Map."");        }        $firstDataTable = reset($subDataTables);        $this->checkDataTableInstance($firstDataTable);        $firstDataTableRow = $firstDataTable->getFirstRow();        $lastDataTable = end($subDataTables);        $this->checkDataTableInstance($lastDataTable);        $lastDataTableRow = $lastDataTable->getFirstRow();        // Process min/max values        $firstNonZeroFound = array();        foreach ($subDataTables as $subDataTable) {            // $subDataTable is the report for one period, it has only one row            $firstRow = $subDataTable->getFirstRow();            foreach ($metadata['metrics'] as $metric => $label) {                $value = $firstRow ? floatval($firstRow->getColumn($metric)) : 0;                if ($value > 0) {                    $firstNonZeroFound[$metric] = true;                } else if (!isset($firstNonZeroFound[$metric])) {                    continue;                }                if (!isset($metricsResult[$metric]['min'])                    || $metricsResult[$metric]['min'] > $value                ) {                    $metricsResult[$metric]['min'] = $value;                }                if (!isset($metricsResult[$metric]['max'])                    || $metricsResult[$metric]['max'] < $value                ) {                    $metricsResult[$metric]['max'] = $value;                }            }        }        // Process % change between first/last values        foreach ($metadata['metrics'] as $metric => $label) {            $first = $firstDataTableRow ? floatval($firstDataTableRow->getColumn($metric)) : 0;            $last = $lastDataTableRow ? floatval($lastDataTableRow->getColumn($metric)) : 0;            // do not calculate evolution if the first value is 0 (to avoid divide-by-zero)            if ($first == 0) {                continue;            }            $change = CalculateEvolutionFilter::calculate($last, $first, $quotientPrecision = 0, true, true);            $metricsResult[$metric]['change'] = $change;        }        $metadata['metrics'] = $metricsResult;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_657, Initialize this object's properties from an array.\\\\\\\\n\\\\\\\\n @param array $array Used to seed this object's properties.\\\\\\\\n @return void\\\\\\\\n,Inicijalizuje svojstva objekta iz niza,"  protected function mapTypes($array)  {    // Hard initialise simple types, lazy load more complex ones.    foreach ($array as $key => $val) {      if ($keyType = $this->keyType($key)) {        $dataType = $this->dataType($key);        if ($dataType == 'array' || $dataType == 'map') {          $this->$key = array();          foreach ($val as $itemKey => $itemVal) {            if ($itemVal instanceof $keyType) {              $this->{$key}[$itemKey] = $itemVal;            } else {              $this->{$key}[$itemKey] = new $keyType($itemVal);            }          }        } elseif ($val instanceof $keyType) {          $this->$key = $val;        } else {          $this->$key = new $keyType($val);        }        unset($array[$key]);      } elseif (property_exists($this, $key)) {          $this->$key = $val;          unset($array[$key]);      } elseif (property_exists($this, $camelKey = $this->camelCase($key))) {          // This checks if property exists as camelCase, leaving it in array as snake_case          // in case of backwards compatibility issues.          $this->$camelKey = $val;      }    }    $this->modelData = $array;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Config_865, Unset the value of an inaccessible property.\n\n @param string $name The name of the property.\n\n @return void\n,"Poništite vrednost nepristupačnog svojstva
",    public function __unset($name)    {        $this->settings[$name] = null;    }//end __unset(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_SymfonyRequirements_2453, This class specifies all requirements and optional recommendations that\n are necessary to run the Symfony Standard Edition.\n\n @author Tobias Schultze <http://tobion.de>\n @author Fabien Potencier <fabien@symfony.com>\n,Ova klasa navodi sve zahteve i opcionalne preporuke koji su potrebni za pokretanje Symfony Standard Edition,"class SymfonyRequirements extends RequirementCollection{    const LEGACY_REQUIRED_PHP_VERSION = '5.3.3';    const REQUIRED_PHP_VERSION = '5.5.9';    /**     * Constructor that initializes the requirements.     */    public function __construct()    {        /* mandatory requirements follow */        $installedPhpVersion = PHP_VERSION;        $requiredPhpVersion = $this->getPhpRequiredVersion();        $this->addRecommendation(            $requiredPhpVersion,            'Vendors should be installed in order to check all requirements.',            'Run the <code>composer install</code> command.',            'Run the ""composer install"" command.'        );        if (false !== $requiredPhpVersion) {            $this->addRequirement(                version_compare($installedPhpVersion, $requiredPhpVersion, '>='),                sprintf('PHP version must be at least %s (%s installed)', $requiredPhpVersion, $installedPhpVersion),                sprintf('You are running PHP version ""<strong>%s</strong>"", but Symfony needs at least PHP ""<strong>%s</strong>"" to run.                Before using Symfony, upgrade your PHP installation, preferably to the latest version.',                    $installedPhpVersion, $requiredPhpVersion),                sprintf('Install PHP %s or newer (installed version is %s)', $requiredPhpVersion, $installedPhpVersion)            );        }        $this->addRequirement(            version_compare($installedPhpVersion, '5.3.16', '!='),            'PHP version must not be 5.3.16 as Symfony won\'t work properly with it',            'Install PHP 5.3.17 or newer (or downgrade to an earlier PHP version)'        );        $this->addRequirement(            is_dir(__DIR__.'/../vendor/composer'),            'Vendor libraries must be installed',            'Vendor libraries are missing. Install composer following instructions from <a href=""http://getcomposer.org/"">http://getcomposer.org/</a>. '.                'Then run ""<strong>php composer.phar install</strong>"" to install them.'        );        $cacheDir = is_dir(__DIR__.'/../var/cache') ? __DIR__.'/../var/cache' : __DIR__.'/cache';        $this->addRequirement(            is_writable($cacheDir),            'app/cache/ or var/cache/ directory must be writable',            'Change the permissions of either ""<strong>app/cache/</strong>"" or  ""<strong>var/cache/</strong>"" directory so that the web server can write into it.'        );        $logsDir = is_dir(__DIR__.'/../var/logs') ? __DIR__.'/../var/logs' : __DIR__.'/logs';        $this->addRequirement(            is_writable($logsDir),            'app/logs/ or var/logs/ directory must be writable',            'Change the permissions of either ""<strong>app/logs/</strong>"" or  ""<strong>var/logs/</strong>"" directory so that the web server can write into it.'        );        if (version_compare($installedPhpVersion, '7.0.0', '<')) {            $this->addPhpIniRequirement(                'date.timezone', true, false,                'date.timezone setting must be set',                'Set the ""<strong>date.timezone</strong>"" setting in php.ini<a href=""#phpini"">*</a> (like Europe/Paris).'            );        }        if (false !== $requiredPhpVersion && version_compare($installedPhpVersion, $requiredPhpVersion, '>=')) {            $this->addRequirement(                in_array(@date_default_timezone_get(), DateTimeZone::listIdentifiers(), true),                sprintf('Configured default timezone ""%s"" must be supported by your installation of PHP', @date_default_timezone_get()),                'Your default timezone is not supported by PHP. Check for typos in your <strong>php.ini</strong> file and have a look at the list of deprecated timezones at <a href=""http://php.net/manual/en/timezones.others.php"">http://php.net/manual/en/timezones.others.php</a>.'            );        }        $this->addRequirement(            function_exists('iconv'),            'iconv() must be available',            'Install and enable the <strong>iconv</strong> extension.'        );        $this->addRequirement(            function_exists('json_encode'),            'json_encode() must be available',            'Install and enable the <strong>JSON</strong> extension.'        );        $this->addRequirement(            function_exists('session_start'),            'session_start() must be available',            'Install and enable the <strong>session</strong> extension.'        );        $this->addRequirement(            function_exists('ctype_alpha'),            'ctype_alpha() must be available',            'Install and enable the <strong>ctype</strong> extension.'        );        $this->addRequirement(            function_exists('token_get_all'),            'token_get_all() must be available',            'Install and enable the <strong>Tokenizer</strong> extension.'        );        $this->addRequirement(            function_exists('simplexml_import_dom'),            'simplexml_import_dom() must be available',            'Install and enable the <strong>SimpleXML</strong> extension.'        );        if (function_exists('apc_store') && ini_get('apc.enabled')) {            if (version_compare($installedPhpVersion, '5.4.0', '>=')) {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.1.13', '>='),                    'APC version must be at least 3.1.13 when using PHP 5.4',                    'Upgrade your <strong>APC</strong> extension (3.1.13+).'                );            } else {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.0.17', '>='),                    'APC version must be at least 3.0.17',                    'Upgrade your <strong>APC</strong> extension (3.0.17+).'                );            }        }        $this->addPhpIniRequirement('detect_unicode', false);        if (extension_loaded('suhosin')) {            $this->addPhpIniRequirement(                'suhosin.executor.include.whitelist',                create_function('$cfgValue', 'return false !== stripos($cfgValue, ""phar"");'),                false,                'suhosin.executor.include.whitelist must be configured correctly in php.ini',                'Add ""<strong>phar</strong>"" to <strong>suhosin.executor.include.whitelist</strong> in php.ini<a href=""#phpini"">*</a>.'            );        }        if (extension_loaded('xdebug')) {            $this->addPhpIniRequirement(                'xdebug.show_exception_trace', false, true            );            $this->addPhpIniRequirement(                'xdebug.scream', false, true            );            $this->addPhpIniRecommendation(                'xdebug.max_nesting_level',                create_function('$cfgValue', 'return $cfgValue > 100;'),                true,                'xdebug.max_nesting_level should be above 100 in php.ini',                'Set ""<strong>xdebug.max_nesting_level</strong>"" to e.g. ""<strong>250</strong>"" in php.ini<a href=""#phpini"">*</a> to stop Xdebug\'s infinite recursion protection erroneously throwing a fatal error in your project.'            );        }        $pcreVersion = defined('PCRE_VERSION') ? (float) PCRE_VERSION : null;        $this->addRequirement(            null !== $pcreVersion,            'PCRE extension must be available',            'Install the <strong>PCRE</strong> extension (version 8.0+).'        );        if (extension_loaded('mbstring')) {            $this->addPhpIniRequirement(                'mbstring.func_overload',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'string functions should not be overloaded',                'Set ""<strong>mbstring.func_overload</strong>"" to <strong>0</strong> in php.ini<a href=""#phpini"">*</a> to disable function overloading by the mbstring extension.'            );        }        /* optional recommendations follow */        if (file_exists(__DIR__.'/../vendor/composer')) {            require_once __DIR__.'/../vendor/autoload.php';            try {                $r = new ReflectionClass('Sensio\Bundle\DistributionBundle\SensioDistributionBundle');                $contents = file_get_contents(dirname($r->getFileName()).'/Resources/skeleton/app/SymfonyRequirements.php');            } catch (ReflectionException $e) {                $contents = '';            }            $this->addRecommendation(                file_get_contents(__FILE__) === $contents,                'Requirements file should be up-to-date',                'Your requirements file is outdated. Run composer install and re-check your configuration.'            );        }        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.4', '>='),            'You should use at least PHP 5.3.4 due to PHP bug #52083 in earlier versions',            'Your project might malfunction randomly due to PHP bug #52083 (""Notice: Trying to get property of non-object""). Install PHP 5.3.4 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.8', '>='),            'When using annotations you should have at least PHP 5.3.8 due to PHP bug #55156',            'Install PHP 5.3.8 or newer if your project uses annotations.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.0', '!='),            'You should not use PHP 5.4.0 due to the PHP bug #61453',            'Your project might not work properly due to the PHP bug #61453 (""Cannot dump definitions which have method calls""). Install PHP 5.4.1 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.11', '>='),            'When using the logout handler from the Symfony Security Component, you should have at least PHP 5.4.11 due to PHP bug #63379 (as a workaround, you can also set invalidate_session to false in the security logout handler configuration)',            'Install PHP 5.4.11 or newer if your project uses the logout handler from the Symfony Security Component.'        );        $this->addRecommendation(            (version_compare($installedPhpVersion, '5.3.18', '>=') && version_compare($installedPhpVersion, '5.4.0', '<'))            ||            version_compare($installedPhpVersion, '5.4.8', '>='),            'You should use PHP 5.3.18+ or PHP 5.4.8+ to always get nice error messages for fatal errors in the development environment due to PHP bug #61767/#60909',            'Install PHP 5.3.18+ or PHP 5.4.8+ if you want nice error messages for all fatal errors in the development environment.'        );        if (null !== $pcreVersion) {            $this->addRecommendation(                $pcreVersion >= 8.0,                sprintf('PCRE extension should be at least version 8.0 (%s installed)', $pcreVersion),                '<strong>PCRE 8.0+</strong> is preconfigured in PHP since 5.3.2 but you are using an outdated version of it. Symfony probably works anyway but it is recommended to upgrade your PCRE extension.'            );        }        $this->addRecommendation(            class_exists('DomDocument'),            'PHP-DOM and PHP-XML modules should be installed',            'Install and enable the <strong>PHP-DOM</strong> and the <strong>PHP-XML</strong> modules.'        );        $this->addRecommendation(            function_exists('mb_strlen'),            'mb_strlen() should be available',            'Install and enable the <strong>mbstring</strong> extension.'        );        $this->addRecommendation(            function_exists('utf8_decode'),            'utf8_decode() should be available',            'Install and enable the <strong>XML</strong> extension.'        );        $this->addRecommendation(            function_exists('filter_var'),            'filter_var() should be available',            'Install and enable the <strong>filter</strong> extension.'        );        if (!defined('PHP_WINDOWS_VERSION_BUILD')) {            $this->addRecommendation(                function_exists('posix_isatty'),                'posix_isatty() should be available',                'Install and enable the <strong>php_posix</strong> extension (used to colorize the CLI output).'            );        }        $this->addRecommendation(            extension_loaded('intl'),            'intl extension should be available',            'Install and enable the <strong>intl</strong> extension (used for validators).'        );        if (extension_loaded('intl')) {            // in some WAMP server installations, new Collator() returns null            $this->addRecommendation(                null !== new Collator('fr_FR'),                'intl extension should be correctly configured',                'The intl extension does not behave properly. This problem is typical on PHP 5.3.X x64 WIN builds.'            );            // check for compatible ICU versions (only done when you have the intl extension)            if (defined('INTL_ICU_VERSION')) {                $version = INTL_ICU_VERSION;            } else {                $reflector = new ReflectionExtension('intl');                ob_start();                $reflector->info();                $output = strip_tags(ob_get_clean());                preg_match('/^ICU version +(?:=> )?(.*)$/m', $output, $matches);                $version = $matches[1];            }            $this->addRecommendation(                version_compare($version, '4.0', '>='),                'intl ICU version should be at least 4+',                'Upgrade your <strong>intl</strong> extension with a newer ICU version (4+).'            );            if (class_exists('Symfony\Component\Intl\Intl')) {                $this->addRecommendation(                    \Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion(),                    sprintf('intl ICU version installed on your system is outdated (%s) and does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                    'To get the latest internationalization data upgrade the ICU system package and the intl PHP extension.'                );                if (\Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion()) {                    $this->addRecommendation(                        \Symfony\Component\Intl\Intl::getIcuDataVersion() === \Symfony\Component\Intl\Intl::getIcuVersion(),                        sprintf('intl ICU version installed on your system (%s) does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                        'To avoid internationalization data inconsistencies upgrade the symfony/intl component.'                    );                }            }            $this->addPhpIniRecommendation(                'intl.error_level',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'intl.error_level should be 0 in php.ini',                'Set ""<strong>intl.error_level</strong>"" to ""<strong>0</strong>"" in php.ini<a href=""#phpini"">*</a> to inhibit the messages when an error occurs in ICU functions.'            );        }        $accelerator =            (extension_loaded('eaccelerator') && ini_get('eaccelerator.enable'))            ||            (extension_loaded('apc') && ini_get('apc.enabled'))            ||            (extension_loaded('Zend Optimizer+') && ini_get('zend_optimizerplus.enable'))            ||            (extension_loaded('Zend OPcache') && ini_get('opcache.enable'))            ||            (extension_loaded('xcache') && ini_get('xcache.cacher'))            ||            (extension_loaded('wincache') && ini_get('wincache.ocenabled'))        ;        $this->addRecommendation(            $accelerator,            'a PHP accelerator should be installed',            'Install and/or enable a <strong>PHP accelerator</strong> (highly recommended).'        );        if ('WIN' === strtoupper(substr(PHP_OS, 0, 3))) {            $this->addRecommendation(                $this->getRealpathCacheSize() >= 5 * 1024 * 1024,                'realpath_cache_size should be at least 5M in php.ini',                'Setting ""<strong>realpath_cache_size</strong>"" to e.g. ""<strong>5242880</strong>"" or ""<strong>5M</strong>"" in php.ini<a href=""#phpini"">*</a> may improve performance on Windows significantly in some cases.'            );        }        $this->addPhpIniRecommendation('short_open_tag', false);        $this->addPhpIniRecommendation('magic_quotes_gpc', false, true);        $this->addPhpIniRecommendation('register_globals', false, true);        $this->addPhpIniRecommendation('session.auto_start', false);        $this->addRecommendation(            class_exists('PDO'),            'PDO should be installed',            'Install <strong>PDO</strong> (mandatory for Doctrine).'        );        if (class_exists('PDO')) {            $drivers = PDO::getAvailableDrivers();            $this->addRecommendation(                count($drivers) > 0,                sprintf('PDO should have some drivers installed (currently available: %s)', count($drivers) ? implode(', ', $drivers) : 'none'),                'Install <strong>PDO drivers</strong> (mandatory for Doctrine).'            );        }    }    /**     * Loads realpath_cache_size from php.ini and converts it to int.     *     * (e.g. 16k is converted to 16384 int)     *     * @return int     */    protected function getRealpathCacheSize()    {        $size = ini_get('realpath_cache_size');        $size = trim($size);        $unit = '';        if (!ctype_digit($size)) {            $unit = strtolower(substr($size, -1, 1));            $size = (int) substr($size, 0, -1);        }        switch ($unit) {            case 'g':                return $size * 1024 * 1024 * 1024;            case 'm':                return $size * 1024 * 1024;            case 'k':                return $size * 1024;            default:                return (int) $size;        }    }    /**     * Defines PHP required version from Symfony version.     *     * @return string|false The PHP required version or false if it could not be guessed     */    protected function getPhpRequiredVersion()    {        if (!file_exists($path = __DIR__.'/../composer.lock')) {            return false;        }        $composerLock = json_decode(file_get_contents($path), true);        foreach ($composerLock['packages'] as $package) {            $name = $package['name'];            if ('symfony/symfony' !== $name && 'symfony/http-kernel' !== $name) {                continue;            }            return (int) $package['version'][1] > 2 ? self::REQUIRED_PHP_VERSION : self::LEGACY_REQUIRED_PHP_VERSION;        }        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
wallabag_wallabag_SymfonyRequirements_2446, Returns both requirements and recommendations.\n\n @return Requirement[]\n,Vraća i zahteve i preporuke,"class SymfonyRequirements extends RequirementCollection{    const LEGACY_REQUIRED_PHP_VERSION = '5.3.3';    const REQUIRED_PHP_VERSION = '5.5.9';    /**     * Constructor that initializes the requirements.     */    public function __construct()    {        /* mandatory requirements follow */        $installedPhpVersion = PHP_VERSION;        $requiredPhpVersion = $this->getPhpRequiredVersion();        $this->addRecommendation(            $requiredPhpVersion,            'Vendors should be installed in order to check all requirements.',            'Run the <code>composer install</code> command.',            'Run the ""composer install"" command.'        );        if (false !== $requiredPhpVersion) {            $this->addRequirement(                version_compare($installedPhpVersion, $requiredPhpVersion, '>='),                sprintf('PHP version must be at least %s (%s installed)', $requiredPhpVersion, $installedPhpVersion),                sprintf('You are running PHP version ""<strong>%s</strong>"", but Symfony needs at least PHP ""<strong>%s</strong>"" to run.                Before using Symfony, upgrade your PHP installation, preferably to the latest version.',                    $installedPhpVersion, $requiredPhpVersion),                sprintf('Install PHP %s or newer (installed version is %s)', $requiredPhpVersion, $installedPhpVersion)            );        }        $this->addRequirement(            version_compare($installedPhpVersion, '5.3.16', '!='),            'PHP version must not be 5.3.16 as Symfony won\'t work properly with it',            'Install PHP 5.3.17 or newer (or downgrade to an earlier PHP version)'        );        $this->addRequirement(            is_dir(__DIR__.'/../vendor/composer'),            'Vendor libraries must be installed',            'Vendor libraries are missing. Install composer following instructions from <a href=""http://getcomposer.org/"">http://getcomposer.org/</a>. '.                'Then run ""<strong>php composer.phar install</strong>"" to install them.'        );        $cacheDir = is_dir(__DIR__.'/../var/cache') ? __DIR__.'/../var/cache' : __DIR__.'/cache';        $this->addRequirement(            is_writable($cacheDir),            'app/cache/ or var/cache/ directory must be writable',            'Change the permissions of either ""<strong>app/cache/</strong>"" or  ""<strong>var/cache/</strong>"" directory so that the web server can write into it.'        );        $logsDir = is_dir(__DIR__.'/../var/logs') ? __DIR__.'/../var/logs' : __DIR__.'/logs';        $this->addRequirement(            is_writable($logsDir),            'app/logs/ or var/logs/ directory must be writable',            'Change the permissions of either ""<strong>app/logs/</strong>"" or  ""<strong>var/logs/</strong>"" directory so that the web server can write into it.'        );        if (version_compare($installedPhpVersion, '7.0.0', '<')) {            $this->addPhpIniRequirement(                'date.timezone', true, false,                'date.timezone setting must be set',                'Set the ""<strong>date.timezone</strong>"" setting in php.ini<a href=""#phpini"">*</a> (like Europe/Paris).'            );        }        if (false !== $requiredPhpVersion && version_compare($installedPhpVersion, $requiredPhpVersion, '>=')) {            $this->addRequirement(                in_array(@date_default_timezone_get(), DateTimeZone::listIdentifiers(), true),                sprintf('Configured default timezone ""%s"" must be supported by your installation of PHP', @date_default_timezone_get()),                'Your default timezone is not supported by PHP. Check for typos in your <strong>php.ini</strong> file and have a look at the list of deprecated timezones at <a href=""http://php.net/manual/en/timezones.others.php"">http://php.net/manual/en/timezones.others.php</a>.'            );        }        $this->addRequirement(            function_exists('iconv'),            'iconv() must be available',            'Install and enable the <strong>iconv</strong> extension.'        );        $this->addRequirement(            function_exists('json_encode'),            'json_encode() must be available',            'Install and enable the <strong>JSON</strong> extension.'        );        $this->addRequirement(            function_exists('session_start'),            'session_start() must be available',            'Install and enable the <strong>session</strong> extension.'        );        $this->addRequirement(            function_exists('ctype_alpha'),            'ctype_alpha() must be available',            'Install and enable the <strong>ctype</strong> extension.'        );        $this->addRequirement(            function_exists('token_get_all'),            'token_get_all() must be available',            'Install and enable the <strong>Tokenizer</strong> extension.'        );        $this->addRequirement(            function_exists('simplexml_import_dom'),            'simplexml_import_dom() must be available',            'Install and enable the <strong>SimpleXML</strong> extension.'        );        if (function_exists('apc_store') && ini_get('apc.enabled')) {            if (version_compare($installedPhpVersion, '5.4.0', '>=')) {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.1.13', '>='),                    'APC version must be at least 3.1.13 when using PHP 5.4',                    'Upgrade your <strong>APC</strong> extension (3.1.13+).'                );            } else {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.0.17', '>='),                    'APC version must be at least 3.0.17',                    'Upgrade your <strong>APC</strong> extension (3.0.17+).'                );            }        }        $this->addPhpIniRequirement('detect_unicode', false);        if (extension_loaded('suhosin')) {            $this->addPhpIniRequirement(                'suhosin.executor.include.whitelist',                create_function('$cfgValue', 'return false !== stripos($cfgValue, ""phar"");'),                false,                'suhosin.executor.include.whitelist must be configured correctly in php.ini',                'Add ""<strong>phar</strong>"" to <strong>suhosin.executor.include.whitelist</strong> in php.ini<a href=""#phpini"">*</a>.'            );        }        if (extension_loaded('xdebug')) {            $this->addPhpIniRequirement(                'xdebug.show_exception_trace', false, true            );            $this->addPhpIniRequirement(                'xdebug.scream', false, true            );            $this->addPhpIniRecommendation(                'xdebug.max_nesting_level',                create_function('$cfgValue', 'return $cfgValue > 100;'),                true,                'xdebug.max_nesting_level should be above 100 in php.ini',                'Set ""<strong>xdebug.max_nesting_level</strong>"" to e.g. ""<strong>250</strong>"" in php.ini<a href=""#phpini"">*</a> to stop Xdebug\'s infinite recursion protection erroneously throwing a fatal error in your project.'            );        }        $pcreVersion = defined('PCRE_VERSION') ? (float) PCRE_VERSION : null;        $this->addRequirement(            null !== $pcreVersion,            'PCRE extension must be available',            'Install the <strong>PCRE</strong> extension (version 8.0+).'        );        if (extension_loaded('mbstring')) {            $this->addPhpIniRequirement(                'mbstring.func_overload',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'string functions should not be overloaded',                'Set ""<strong>mbstring.func_overload</strong>"" to <strong>0</strong> in php.ini<a href=""#phpini"">*</a> to disable function overloading by the mbstring extension.'            );        }        /* optional recommendations follow */        if (file_exists(__DIR__.'/../vendor/composer')) {            require_once __DIR__.'/../vendor/autoload.php';            try {                $r = new ReflectionClass('Sensio\Bundle\DistributionBundle\SensioDistributionBundle');                $contents = file_get_contents(dirname($r->getFileName()).'/Resources/skeleton/app/SymfonyRequirements.php');            } catch (ReflectionException $e) {                $contents = '';            }            $this->addRecommendation(                file_get_contents(__FILE__) === $contents,                'Requirements file should be up-to-date',                'Your requirements file is outdated. Run composer install and re-check your configuration.'            );        }        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.4', '>='),            'You should use at least PHP 5.3.4 due to PHP bug #52083 in earlier versions',            'Your project might malfunction randomly due to PHP bug #52083 (""Notice: Trying to get property of non-object""). Install PHP 5.3.4 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.8', '>='),            'When using annotations you should have at least PHP 5.3.8 due to PHP bug #55156',            'Install PHP 5.3.8 or newer if your project uses annotations.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.0', '!='),            'You should not use PHP 5.4.0 due to the PHP bug #61453',            'Your project might not work properly due to the PHP bug #61453 (""Cannot dump definitions which have method calls""). Install PHP 5.4.1 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.11', '>='),            'When using the logout handler from the Symfony Security Component, you should have at least PHP 5.4.11 due to PHP bug #63379 (as a workaround, you can also set invalidate_session to false in the security logout handler configuration)',            'Install PHP 5.4.11 or newer if your project uses the logout handler from the Symfony Security Component.'        );        $this->addRecommendation(            (version_compare($installedPhpVersion, '5.3.18', '>=') && version_compare($installedPhpVersion, '5.4.0', '<'))            ||            version_compare($installedPhpVersion, '5.4.8', '>='),            'You should use PHP 5.3.18+ or PHP 5.4.8+ to always get nice error messages for fatal errors in the development environment due to PHP bug #61767/#60909',            'Install PHP 5.3.18+ or PHP 5.4.8+ if you want nice error messages for all fatal errors in the development environment.'        );        if (null !== $pcreVersion) {            $this->addRecommendation(                $pcreVersion >= 8.0,                sprintf('PCRE extension should be at least version 8.0 (%s installed)', $pcreVersion),                '<strong>PCRE 8.0+</strong> is preconfigured in PHP since 5.3.2 but you are using an outdated version of it. Symfony probably works anyway but it is recommended to upgrade your PCRE extension.'            );        }        $this->addRecommendation(            class_exists('DomDocument'),            'PHP-DOM and PHP-XML modules should be installed',            'Install and enable the <strong>PHP-DOM</strong> and the <strong>PHP-XML</strong> modules.'        );        $this->addRecommendation(            function_exists('mb_strlen'),            'mb_strlen() should be available',            'Install and enable the <strong>mbstring</strong> extension.'        );        $this->addRecommendation(            function_exists('utf8_decode'),            'utf8_decode() should be available',            'Install and enable the <strong>XML</strong> extension.'        );        $this->addRecommendation(            function_exists('filter_var'),            'filter_var() should be available',            'Install and enable the <strong>filter</strong> extension.'        );        if (!defined('PHP_WINDOWS_VERSION_BUILD')) {            $this->addRecommendation(                function_exists('posix_isatty'),                'posix_isatty() should be available',                'Install and enable the <strong>php_posix</strong> extension (used to colorize the CLI output).'            );        }        $this->addRecommendation(            extension_loaded('intl'),            'intl extension should be available',            'Install and enable the <strong>intl</strong> extension (used for validators).'        );        if (extension_loaded('intl')) {            // in some WAMP server installations, new Collator() returns null            $this->addRecommendation(                null !== new Collator('fr_FR'),                'intl extension should be correctly configured',                'The intl extension does not behave properly. This problem is typical on PHP 5.3.X x64 WIN builds.'            );            // check for compatible ICU versions (only done when you have the intl extension)            if (defined('INTL_ICU_VERSION')) {                $version = INTL_ICU_VERSION;            } else {                $reflector = new ReflectionExtension('intl');                ob_start();                $reflector->info();                $output = strip_tags(ob_get_clean());                preg_match('/^ICU version +(?:=> )?(.*)$/m', $output, $matches);                $version = $matches[1];            }            $this->addRecommendation(                version_compare($version, '4.0', '>='),                'intl ICU version should be at least 4+',                'Upgrade your <strong>intl</strong> extension with a newer ICU version (4+).'            );            if (class_exists('Symfony\Component\Intl\Intl')) {                $this->addRecommendation(                    \Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion(),                    sprintf('intl ICU version installed on your system is outdated (%s) and does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                    'To get the latest internationalization data upgrade the ICU system package and the intl PHP extension.'                );                if (\Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion()) {                    $this->addRecommendation(                        \Symfony\Component\Intl\Intl::getIcuDataVersion() === \Symfony\Component\Intl\Intl::getIcuVersion(),                        sprintf('intl ICU version installed on your system (%s) does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                        'To avoid internationalization data inconsistencies upgrade the symfony/intl component.'                    );                }            }            $this->addPhpIniRecommendation(                'intl.error_level',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'intl.error_level should be 0 in php.ini',                'Set ""<strong>intl.error_level</strong>"" to ""<strong>0</strong>"" in php.ini<a href=""#phpini"">*</a> to inhibit the messages when an error occurs in ICU functions.'            );        }        $accelerator =            (extension_loaded('eaccelerator') && ini_get('eaccelerator.enable'))            ||            (extension_loaded('apc') && ini_get('apc.enabled'))            ||            (extension_loaded('Zend Optimizer+') && ini_get('zend_optimizerplus.enable'))            ||            (extension_loaded('Zend OPcache') && ini_get('opcache.enable'))            ||            (extension_loaded('xcache') && ini_get('xcache.cacher'))            ||            (extension_loaded('wincache') && ini_get('wincache.ocenabled'))        ;        $this->addRecommendation(            $accelerator,            'a PHP accelerator should be installed',            'Install and/or enable a <strong>PHP accelerator</strong> (highly recommended).'        );        if ('WIN' === strtoupper(substr(PHP_OS, 0, 3))) {            $this->addRecommendation(                $this->getRealpathCacheSize() >= 5 * 1024 * 1024,                'realpath_cache_size should be at least 5M in php.ini',                'Setting ""<strong>realpath_cache_size</strong>"" to e.g. ""<strong>5242880</strong>"" or ""<strong>5M</strong>"" in php.ini<a href=""#phpini"">*</a> may improve performance on Windows significantly in some cases.'            );        }        $this->addPhpIniRecommendation('short_open_tag', false);        $this->addPhpIniRecommendation('magic_quotes_gpc', false, true);        $this->addPhpIniRecommendation('register_globals', false, true);        $this->addPhpIniRecommendation('session.auto_start', false);        $this->addRecommendation(            class_exists('PDO'),            'PDO should be installed',            'Install <strong>PDO</strong> (mandatory for Doctrine).'        );        if (class_exists('PDO')) {            $drivers = PDO::getAvailableDrivers();            $this->addRecommendation(                count($drivers) > 0,                sprintf('PDO should have some drivers installed (currently available: %s)', count($drivers) ? implode(', ', $drivers) : 'none'),                'Install <strong>PDO drivers</strong> (mandatory for Doctrine).'            );        }    }    /**     * Loads realpath_cache_size from php.ini and converts it to int.     *     * (e.g. 16k is converted to 16384 int)     *     * @return int     */    protected function getRealpathCacheSize()    {        $size = ini_get('realpath_cache_size');        $size = trim($size);        $unit = '';        if (!ctype_digit($size)) {            $unit = strtolower(substr($size, -1, 1));            $size = (int) substr($size, 0, -1);        }        switch ($unit) {            case 'g':                return $size * 1024 * 1024 * 1024;            case 'm':                return $size * 1024 * 1024;            case 'k':                return $size * 1024;            default:                return (int) $size;        }    }    /**     * Defines PHP required version from Symfony version.     *     * @return string|false The PHP required version or false if it could not be guessed     */    protected function getPhpRequiredVersion()    {        if (!file_exists($path = __DIR__.'/../composer.lock')) {            return false;        }        $composerLock = json_decode(file_get_contents($path), true);        foreach ($composerLock['packages'] as $package) {            $name = $package['name'];            if ('symfony/symfony' !== $name && 'symfony/http-kernel' !== $name) {                continue;            }            return (int) $package['version'][1] > 2 ? self::REQUIRED_PHP_VERSION : self::LEGACY_REQUIRED_PHP_VERSION;        }        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_DateTimeComparator_2334, Compares DateTimeInterface instances for equality.\n,Upoređuje instance DateTimeInterface radi jednakosti,"class DateTimeComparator extends ObjectComparator{    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return ($expected instanceof DateTime || $expected instanceof DateTimeInterface) &&               ($actual instanceof DateTime || $actual instanceof DateTimeInterface);    }    /**     * Asserts that two values are equal.     *     * @param mixed $expected     First value to compare     * @param mixed $actual       Second value to compare     * @param float $delta        Allowed numerical distance between two values to consider them equal     * @param bool  $canonicalize Arrays are sorted before comparison when set to true     * @param bool  $ignoreCase   Case is ignored when set to true     * @param array $processed    List of already processed elements (used to prevent infinite recursion)     *     * @throws ComparisonFailure     * @throws Exception     */    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false, array &$processed = [])/*: void*/    {        /** @var DateTimeInterface $expected */        /** @var DateTimeInterface $actual */        $absDelta = abs($delta);        $delta    = new DateInterval(sprintf('PT%dS', $absDelta));        $delta->f = $absDelta - floor($absDelta);        $actualClone = (clone $actual)            ->setTimezone(new DateTimeZone('UTC'));        $expectedLower = (clone $expected)            ->setTimezone(new DateTimeZone('UTC'))            ->sub($delta);        $expectedUpper = (clone $expected)            ->setTimezone(new DateTimeZone('UTC'))            ->add($delta);        if ($actualClone < $expectedLower || $actualClone > $expectedUpper) {            throw new ComparisonFailure(                $expected,                $actual,                $this->dateTimeToString($expected),                $this->dateTimeToString($actual),                false,                'Failed asserting that two DateTime objects are equal.'            );        }    }    /**     * Returns an ISO 8601 formatted string representation of a datetime or     * 'Invalid DateTimeInterface object' if the provided DateTimeInterface was not properly     * initialized.     */    private function dateTimeToString(DateTimeInterface $datetime): string    {        $string = $datetime->format('Y-m-d\TH:i:s.uO');        return $string ?: 'Invalid DateTimeInterface object';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phpspec_prophecy_ArgumentsWildcard_2935, Initializes wildcard.\n\n @param array $arguments Array of argument tokens or values\n,Inicijalizacija wildcard-a,    public function __construct(array $arguments)    {        foreach ($arguments as $argument) {            if (!$argument instanceof Token\TokenInterface) {                $argument = new Token\ExactValueToken($argument);            }            $this->tokens[] = $argument;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
woocommerce_woocommerce_RestockRefundedItemsAdjuster_1935, Class to adjust or initialize the restock refunded items.\n,Klasa za prilagođavanje ili inicijalizaciju vraćenih stavki,public static function initialize( $mockable_classes ) {if ( ! is_array( $mockable_classes ) || empty( $mockable_classes ) ) {throw new \Exception( 'StaticMockerHack::initialize:: $mockable_classes must be a non-empty associative array of class name => array of class methods.' );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2546, Create a random ArbitraryInteger\\n\\n @param int $bytes\\n\\n @return Number\\\\ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n,Napravite slučajni ArbitrarInteger broj,"    public static function rand(int $bytes): Number\ArbitraryInteger    {        if ($bytes <= 0) {            throw new Exception\BadParameterException('Cannot produce a random number with zero or negative bytes.');        }        return Number\ArbitraryInteger::fromBinary(\random_bytes($bytes), \mt_rand(0, 1) === 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_KernelDensityEstimation_3533, Default bandwidth for when one is not provided.\\n Uses the normal distribution approximation bandwidth estimator.\\n https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\\n\\n             â…•\\n      / 4Ïƒâµ \\\\\\n h = |  ---  |\\n      \\\\ 3n  /\\n\\n\\n @return float\\n\\n @throws Exception\\\\OutOfBoundsException\\n,Podrazumevana širina opsega kada nije obezbeđena. Koristi procenjivač širine opsega aproksimacije normalne distribucije,    private function getDefaultBandwidth(): float    {        $ï¼”Ïƒâµ = 4 * Descriptive::standardDeviation($this->data) ** 5;        $ï¼“n  = 3 * $this->n;        $â…•    = 0.2;        return ($ï¼”Ïƒâµ / $ï¼“n) ** $â…•;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_LogNormal_3141, Log normal distribution - probability density function\\n\\n https://en.wikipedia.org/wiki/Log-normal_distribution\\n\\n                 (ln x - Î¼)Â²\\n         1     - ----------\\n pdf = ----- â„¯       2ÏƒÂ²\\n       xÏƒâˆš2Ï€\\n\\n @param  float $x > 0\\n\\n @return float\\n,Logaritamska Normalna raspodela  - funkcija gustine verovatnoće,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        $Ï€ = \M_PI;        $xÏƒâˆš2Ï€      = $x * $Ïƒ * \sqrt(2 * $Ï€);        $âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² = \pow(\log($x) - $Î¼, 2);        $ÏƒÂ²         = $Ïƒ ** 2;        return (1 / $xÏƒâˆš2Ï€) * \exp(-($âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² / (2 * $ÏƒÂ²)));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3284, Normal distribution\n https://en.wikipedia.org/wiki/Multivariate_normal_distribution\n,Normalna raspodela,"class Normal{    /** @var array location */    protected $Î¼;    /** @var NumericMatrix covariance matrix */    protected $âˆ‘;    /**     * Constructor     *     * @param array         $Î¼ âˆˆ Ráµ   location     * @param NumericMatrix $âˆ‘ âˆˆ RáµË£áµ covariance matrix     *     * @throws Exception\BadDataException if the covariance matrix does not have the same number of rows and columns as number of elements in Î¼     * @throws Exception\BadDataException if the covariance matrix is not positive definite     */    public function __construct(array $Î¼, NumericMatrix $âˆ‘)    {        $k = \count($Î¼);        if ($âˆ‘->getM() !== $k || $âˆ‘->getN() !== $k) {            throw new Exception\BadDataException(                'Covariance matrix âˆ‘ must have the the same number of rows and columns as there are X elements. ' .                ""X has $k elements. Covariance matrix âˆ‘ has "" . $âˆ‘->getM() . ' rows and ' . $âˆ‘->getN() . ' columns.'            );        }        if (!$âˆ‘->isPositiveDefinite()) {            throw new Exception\BadDataException(""Covariance matrix âˆ‘ is not positive definite:\n$âˆ‘"");        }        $this->Î¼ = $Î¼;        $this->âˆ‘ = $âˆ‘;    }    /**     * Probability density function     *     *                 exp(âˆ’Â½(x âˆ’Â Î¼)áµ€âˆ‘â»Â¹(xÂ âˆ’Â Î¼))     * fx(xâ‚,...,xk) = -------------------------     *                        âˆš(2Ï€)áµâ”‚âˆ‘â”‚     *     * x is a real k-dimensional column vector     * Î¼ is a real k-dimensinoal column vector of means     * â”‚âˆ‘â”‚ â‰¡ det(âˆ‘)     *     * @param array  $X âˆˆ Ráµ   k-dimensional random vector     *     * @return float density     *     * @throws Exception\BadDataException if X and Î¼ do not have the same number of elements     */    public function pdf(array $X): float    {        $k = \count($X);        $Î¼ = $this->Î¼;        $âˆ‘ = $this->âˆ‘;        if (\count($Î¼) !== $k) {            throw new Exception\BadDataException(""X and Î¼ must have the same number of elements. X has $k and Î¼ has "" . \count($Î¼));        }        $Ï€ = \M_PI;        $â”‚âˆ‘â”‚      = $âˆ‘->det();        $âˆšâŸ®2Ï€âŸ¯áµâ”‚âˆ‘â”‚ = \sqrt((2 * $Ï€) ** $k * $â”‚âˆ‘â”‚);        $Î”       = Map\Multi::subtract($X, $Î¼);        $âŸ®xÂ âˆ’Â Î¼âŸ¯  = new Vector($Î”);        $âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€ = MatrixFactory::createFromRowVector($Î”);        $âˆ‘â»Â¹     = $âˆ‘->inverse();        $expâŸ®âˆ’Â½âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€âˆ‘â»Â¹âŸ®xÂ âˆ’Â Î¼âŸ¯âŸ¯ = \exp(            $âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€->scalarDivide(-2)                ->multiply($âˆ‘â»Â¹)                ->multiply($âŸ®xÂ âˆ’Â Î¼âŸ¯)                ->get(0, 0)        );        return $expâŸ®âˆ’Â½âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€âˆ‘â»Â¹âŸ®xÂ âˆ’Â Î¼âŸ¯âŸ¯ / $âˆšâŸ®2Ï€âŸ¯áµâ”‚âˆ‘â”‚;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3167, Cumulative distribution function\n Probability of being below X.\n Area under the normal distribution from -âˆž to X.\n             _                  _\n          1 |         / x - Î¼ \\  |\n cdf(x) = - | 1 + erf|  ----- |  |\n          2 |_        \\  Ïƒâˆš2  / _|\n\n @param float $x upper bound\n\n @return float cdf(x) below\n,Funkcija kumulativne raspodele. Verovatnoća da bude ispod X. Površina ispod normalne raspodele od -a do X,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        return 1 / 2 * ( 1 + Special::erf(($x - $Î¼) / ($Ïƒ * \sqrt(2))) );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Installer_2547, Whether or not generated autoloader are optimized\n\n @param  bool      $optimizeAutoloader\n @return Installer\n,Bez obzira da li je ili ne generisan automatski  se autoloader optimizuje,    public function setOptimizeAutoloader($optimizeAutoloader)    {        $this->optimizeAutoloader = (bool) $optimizeAutoloader;        if (!$this->optimizeAutoloader) {            // Force classMapAuthoritative off when not optimizing the            // autoloader            $this->setClassMapAuthoritative(false);        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_1228, Uses previously generated safe universal build and generates optimized build for a specific platform\\n,Koristi prethodno generisanu sigurnu univerzalni build i generiše optimizovani build za određenu platformu,"class Generator_Optimized{    /**     * Directory, where safe universal build files are generated     *     * @var string     */    protected string $sourceBuildDir;    /**     * Platform settings for supported optimized builds     *     * @var array     */    protected array $settings;    /**     * Filters for processing (optimizing) lines from safe universal phalcon.c     *     * @var array     */    protected array $filters;    /**     * @param string $sourceBuildDir     * @param string $output32Dir     * @param string $output64Dir     */    public function __construct(string $sourceBuildDir, string $output32Dir, string $output64Dir)    {        $this->sourceBuildDir = $sourceBuildDir;        $this->settings = $this->getPlatformsSettings($output32Dir, $output64Dir);        $this->filters = $this->getFilters();    }    /**     * Return array of supported platform settings for optimized builds     *     * @param string $output32Dir     * @param string $output64Dir     * @return array     */    protected function getPlatformsSettings(string $output32Dir, string $output64Dir)    {        return array(            '32bit' => array(                'dir' => $output32Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey32($string) . 'UL';                }            ),            '64bit' => array(                'dir' => $output64Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey64($string) . 'UL';                }            ),        );    }    /**     * Return filters for processing lines from safe universal phalcon.c     *     * @return array     */    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }    /**     * Run generation process     */    public function run()    {        echo 'Generating builds, optimized for 32-bit and 64-bit platforms... ';        $this->cleanBuildDirectories();        $this->copyFilesFromSourceBuildDir();        $this->copyAndOptimizePhalconC();        echo ""OK\n"";    }    /**     * Delete all files in target directories     */    public function cleanBuildDirectories()    {        foreach ($this->settings as $setting) {            Util::cleanDirectory($setting['dir']);        }    }    /**     * Copy all files from the original safe universal build directory     */    protected function copyFilesFromSourceBuildDir()    {        $files = glob($this->sourceBuildDir . '/*.*');        foreach ($files as $file) {            // phalcon.c is processed in a separate optimization func            if (basename($file) == 'phalcon.zep.c') {                continue;            }            foreach ($this->settings as $setting) {                copy($file, $setting['dir'] . '/' . basename($file));            }        }    }    /**     * Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.     * Precalculation is, actually, the optimization being performed.     */    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }    /**     * Pass line through filters and add the processed result to platform builds     *     * @param string $line     * @param array $result     */    protected function filterLine($line, &$result)    {        /** @var callable|null $func */        $func = null;        foreach ($this->filters as $filter) {            if (!preg_match($filter['regexp'], $line, $matches)) {                continue;            }            $func = $filter['func'];            break; // We don't expect more than one replacement to be made on the same line        }        foreach ($this->settings as $platform => $setting) {            $result[$platform] .= $func ? $func($line, $matches, $setting['hashFunc']) : $line;        }    }}",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_834, Get all attributes groups for a given language.\\n\\n @param int $idLang Language id\\n\\n @return array Attributes groups\\n,Dohvata sve grupe atributa za dati jezik,"    public static function getAttributesGroups($idLang)    {        if (!Combination::isFeatureActive()) {            return [];        }        return Db::getInstance()->executeS('SELECT DISTINCT agl.`name`, ag.*, agl.*FROM `' . _DB_PREFIX_ . 'attribute_group` ag' . Shop::addSqlAssociation('attribute_group', 'ag') . 'LEFT JOIN `' . _DB_PREFIX_ . 'attribute_group_lang` aglON (ag.`id_attribute_group` = agl.`id_attribute_group` AND `id_lang` = ' . (int) $idLang . ')ORDER BY `name` ASC');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2164, Extracts the key from a command with multiple keys only when all keys in\n the arguments array produce the same hash.\n\n @param CommandInterface $command Command instance.\n\n @return string|null\n,Izdvaja ključ iz naredbe sa više ključeva samo kada svi ključevi u polju argumenata proizvode isto heširanje,    protected function getKeyFromInterleavedArguments(CommandInterface $command)    {        $arguments = $command->getArguments();        $keys = array();        for ($i = 0; $i < count($arguments); $i += 2) {            $keys[] = $arguments[$i];        }        if ($this->checkSameSlotForKeys($keys)) {            return $arguments[0];        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_8679, Check errors when current process exited.\n\n @return void\n,Proverite greške kada je trenutni proces završio,"    public static function log($msg)    {        $msg = $msg . ""\n"";        if (!static::$daemonize) {            static::safeEcho($msg);        }        \file_put_contents((string)static::$logFile, \date('Y-m-d H:i:s') . ' ' . 'pid:'            . (static::$_OS === \OS_TYPE_LINUX ? \posix_getpid() : 1) . ' ' . $msg, \FILE_APPEND | \LOCK_EX);    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
walkor_Workerman_Worker_9621, Exit current process.\n\n @return void\n,Izađite iz trenutnog procesa,"    public static function checkIfChildRunning()    {        foreach (static::$_pidMap as $worker_id => $worker_pid_array) {            foreach ($worker_pid_array as $pid => $worker_pid) {                if (!\posix_kill($pid, 0)) {                    unset(static::$_pidMap[$worker_id][$pid]);                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_DateComparator_390, DateCompare compiles date comparisons.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n,DateCompare kompajlira poređenje datuma,"class DateComparator extends Comparator{    /**     * @param string $test A comparison string     *     * @throws \InvalidArgumentException If the test is not understood     */    public function __construct(string $test)    {        if (!preg_match('#^\s*(==|!=|[<>]=?|after|since|before|until)?\s*(.+?)\s*$#i', $test, $matches)) {            throw new \InvalidArgumentException(sprintf('Don\'t understand ""%s"" as a date test.', $test));        }        try {            $date = new \DateTime($matches[2]);            $target = $date->format('U');        } catch (\Exception $e) {            throw new \InvalidArgumentException(sprintf('""%s"" is not a valid date.', $matches[2]));        }        $operator = $matches[1] ?? '==';        if ('since' === $operator || 'after' === $operator) {            $operator = '>';        }        if ('until' === $operator || 'before' === $operator) {            $operator = '<';        }        $this->setOperator($operator);        $this->setTarget($target);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_JsonResponse_8807, Response represents an HTTP response in JSON format.\n\n Note that this class does not force the returned JSON content to be an\n object. It is however recommended that you do return an object as it\n protects yourself against XSSI and JSON-JavaScript Hijacking.\n\n @see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside\n\n @author Igor Wiedler <igor@wiedler.ch>\n,"Odgovor predstavlja HTTP odgovor u JSON formatu. Imajte na umu da ova klasa ne prisiljava vraćeni JSON sadržaj da bude objekat. Međutim, preporučuje se da vratite objekat jer se on štiti od XSSSI i JSON-JavaScript hakovanja","class JsonResponse extends Response{    protected $data;    protected $callback;    // Encode <, >, ', &, and "" characters in the JSON, making it also safe to be embedded into HTML.    // 15 === JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT    public const DEFAULT_ENCODING_OPTIONS = 15;    protected $encodingOptions = self::DEFAULT_ENCODING_OPTIONS;    /**     * @param mixed $data    The response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     * @param bool  $json    If the data is already a JSON string     */    public function __construct($data = null, int $status = 200, array $headers = [], bool $json = false)    {        parent::__construct('', $status, $headers);        if ($json && !\is_string($data) && !is_numeric($data) && !\is_callable([$data, '__toString'])) {            throw new \TypeError(sprintf('""%s"": If $json is set to true, argument $data must be a string or object implementing __toString(), ""%s"" given.', __METHOD__, get_debug_type($data)));        }        if (null === $data) {            $data = new \ArrayObject();        }        $json ? $this->setJson($data) : $this->setData($data);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::create(['key' => 'value'])     *         ->setSharedMaxAge(300);     *     * @param mixed $data    The JSON response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     *     * @return static     *     * @deprecated since Symfony 5.1, use __construct() instead.     */    public static function create($data = null, int $status = 200, array $headers = [])    {        trigger_deprecation('symfony/http-foundation', '5.1', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($data, $status, $headers);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::fromJsonString('{""key"": ""value""}')     *         ->setSharedMaxAge(300);     *     * @param string $data    The JSON response string     * @param int    $status  The response status code     * @param array  $headers An array of response headers     *     * @return static     */    public static function fromJsonString(string $data, int $status = 200, array $headers = [])    {        return new static($data, $status, $headers, true);    }    /**     * Sets the JSONP callback.     *     * @param string|null $callback The JSONP callback or null to use none     *     * @return $this     *     * @throws \InvalidArgumentException When the callback name is not valid     */    public function setCallback(string $callback = null)    {        if (null !== $callback) {            // partially taken from https://geekality.net/2011/08/03/valid-javascript-identifier/            // partially taken from https://github.com/willdurand/JsonpCallbackValidator            //      JsonpCallbackValidator is released under the MIT License. See https://github.com/willdurand/JsonpCallbackValidator/blob/v1.1.0/LICENSE for details.            //      (c) William Durand <william.durand1@gmail.com>            $pattern = '/^[$_\p{L}][$_\p{L}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\x{200C}\x{200D}]*(?:\[(?:""(?:\\\.|[^""\\\])*""|\'(?:\\\.|[^\'\\\])*\'|\d+)\])*?$/u';            $reserved = [                'break', 'do', 'instanceof', 'typeof', 'case', 'else', 'new', 'var', 'catch', 'finally', 'return', 'void', 'continue', 'for', 'switch', 'while',                'debugger', 'function', 'this', 'with', 'default', 'if', 'throw', 'delete', 'in', 'try', 'class', 'enum', 'extends', 'super',  'const', 'export',                'import', 'implements', 'let', 'private', 'public', 'yield', 'interface', 'package', 'protected', 'static', 'null', 'true', 'false',            ];            $parts = explode('.', $callback);            foreach ($parts as $part) {                if (!preg_match($pattern, $part) || \in_array($part, $reserved, true)) {                    throw new \InvalidArgumentException('The callback name is not valid.');                }            }        }        $this->callback = $callback;        return $this->update();    }    /**     * Sets a raw string containing a JSON document to be sent.     *     * @return $this     */    public function setJson(string $json)    {        $this->data = $json;        return $this->update();    }    /**     * Sets the data to be sent as JSON.     *     * @param mixed $data     *     * @return $this     *     * @throws \InvalidArgumentException     */    public function setData($data = [])    {        try {            $data = json_encode($data, $this->encodingOptions);        } catch (\Exception $e) {            if ('Exception' === \get_class($e) && 0 === strpos($e->getMessage(), 'Failed calling ')) {                throw $e->getPrevious() ?: $e;            }            throw $e;        }        if (\PHP_VERSION_ID >= 70300 && (\JSON_THROW_ON_ERROR & $this->encodingOptions)) {            return $this->setJson($data);        }        if (\JSON_ERROR_NONE !== json_last_error()) {            throw new \InvalidArgumentException(json_last_error_msg());        }        return $this->setJson($data);    }    /**     * Returns options used while encoding data to JSON.     *     * @return int     */    public function getEncodingOptions()    {        return $this->encodingOptions;    }    /**     * Sets options used while encoding data to JSON.     *     * @return $this     */    public function setEncodingOptions(int $encodingOptions)    {        $this->encodingOptions = $encodingOptions;        return $this->setData(json_decode($this->data));    }    /**     * Updates the content and headers according to the JSON data and callback.     *     * @return $this     */    protected function update()    {        if (null !== $this->callback) {            // Not using application/javascript for compatibility reasons with older browsers.            $this->headers->set('Content-Type', 'text/javascript');            return $this->setContent(sprintf('/**/%s(%s);', $this->callback, $this->data));        }        // Only set the header when there is none or when it equals 'text/javascript' (from a previous update with callback)        // in order to not overwrite a custom definition.        if (!$this->headers->has('Content-Type') || 'text/javascript' === $this->headers->get('Content-Type')) {            $this->headers->set('Content-Type', 'application/json');        }        return $this->setContent($this->data);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_DebugClassLoader_1727," Autoloader checking if the class is really defined in the file found.\n\n The ClassLoader will wrap all registered autoloaders\n and will throw an exception if a file is found but does\n not declare the class.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Christophe Coevoet <stof@notk.org>\n @author Nicolas Grekas <p@tchwork.com>\n @author Guilhem Niot <guilhem.niot@gmail.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\DebugClassLoader instead.\n","Autoloader proverava da li je klasa zaista definisana u pronađenoj datoteci. ClassLoader će umotati sve registrovane autoloadere i izbaciće izuzetak ako je datoteka pronađena, ali ne deklariše klasu","class DebugClassLoader{    private $classLoader;    private $isFinder;    private $loaded = [];    private static $caseCheck;    private static $checkedClasses = [];    private static $final = [];    private static $finalMethods = [];    private static $deprecated = [];    private static $internal = [];    private static $internalMethods = [];    private static $annotatedParameters = [];    private static $darwinCache = ['/' => ['/', []]];    private static $method = [];    public function __construct(callable $classLoader)    {        $this->classLoader = $classLoader;        $this->isFinder = \is_array($classLoader) && method_exists($classLoader[0], 'findFile');        if (!isset(self::$caseCheck)) {            $file = file_exists(__FILE__) ? __FILE__ : rtrim(realpath('.'), \DIRECTORY_SEPARATOR);            $i = strrpos($file, \DIRECTORY_SEPARATOR);            $dir = substr($file, 0, 1 + $i);            $file = substr($file, 1 + $i);            $test = strtoupper($file) === $file ? strtolower($file) : strtoupper($file);            $test = realpath($dir.$test);            if (false === $test || false === $i) {                // filesystem is case sensitive                self::$caseCheck = 0;            } elseif (substr($test, -\strlen($file)) === $file) {                // filesystem is case insensitive and realpath() normalizes the case of characters                self::$caseCheck = 1;            } elseif (false !== stripos(\PHP_OS, 'darwin')) {                // on MacOSX, HFS+ is case insensitive but realpath() doesn't normalize the case of characters                self::$caseCheck = 2;            } else {                // filesystem case checks failed, fallback to disabling them                self::$caseCheck = 0;            }        }    }    /**     * Gets the wrapped class loader.     *     * @return callable The wrapped class loader     */    public function getClassLoader()    {        return $this->classLoader;    }    /**     * Wraps all autoloaders.     */    public static function enable()    {        // Ensures we don't hit https://bugs.php.net/42098        class_exists(\Symfony\Component\Debug\ErrorHandler::class);        class_exists(\Psr\Log\LogLevel::class);        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (!\is_array($function) || !$function[0] instanceof self) {                $function = [new static($function), 'loadClass'];            }            spl_autoload_register($function);        }    }    /**     * Disables the wrapping.     */    public static function disable()    {        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (\is_array($function) && $function[0] instanceof self) {                $function = $function[0]->getClassLoader();            }            spl_autoload_register($function);        }    }    /**     * @return string|null     */    public function findFile($class)    {        return $this->isFinder ? $this->classLoader[0]->findFile($class) ?: null : null;    }    /**     * Loads the given class or interface.     *     * @param string $class The name of the class     *     * @throws \RuntimeException     */    public function loadClass($class)    {        $e = error_reporting(error_reporting() | \E_PARSE | \E_ERROR | \E_CORE_ERROR | \E_COMPILE_ERROR);        try {            if ($this->isFinder && !isset($this->loaded[$class])) {                $this->loaded[$class] = true;                if (!$file = $this->classLoader[0]->findFile($class) ?: false) {                    // no-op                } elseif (\function_exists('opcache_is_script_cached') && @opcache_is_script_cached($file)) {                    include $file;                    return;                } elseif (false === include $file) {                    return;                }            } else {                ($this->classLoader)($class);                $file = false;            }        } finally {            error_reporting($e);        }        $this->checkClass($class, $file);    }    private function checkClass(string $class, string $file = null)    {        $exists = null === $file || class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);        if (null !== $file && $class && '\\' === $class[0]) {            $class = substr($class, 1);        }        if ($exists) {            if (isset(self::$checkedClasses[$class])) {                return;            }            self::$checkedClasses[$class] = true;            $refl = new \ReflectionClass($class);            if (null === $file && $refl->isInternal()) {                return;            }            $name = $refl->getName();            if ($name !== $class && 0 === strcasecmp($name, $class)) {                throw new \RuntimeException(sprintf('Case mismatch between loaded and declared class names: ""%s"" vs ""%s"".', $class, $name));            }            $deprecations = $this->checkAnnotations($refl, $name);            foreach ($deprecations as $message) {                @trigger_error($message, \E_USER_DEPRECATED);            }        }        if (!$file) {            return;        }        if (!$exists) {            if (false !== strpos($class, '/')) {                throw new \RuntimeException(sprintf('Trying to autoload a class with an invalid name ""%s"". Be careful that the namespace separator is ""\"" in PHP, not ""/"".', $class));            }            throw new \RuntimeException(sprintf('The autoloader expected class ""%s"" to be defined in file ""%s"". The file was found but the class was not in it, the class name or namespace probably has a typo.', $class, $file));        }        if (self::$caseCheck && $message = $this->checkCase($refl, $file, $class)) {            throw new \RuntimeException(sprintf('Case mismatch between class and real file names: ""%s"" vs ""%s"" in ""%s"".', $message[0], $message[1], $message[2]));        }    }    public function checkAnnotations(\ReflectionClass $refl, $class)    {        $deprecations = [];        // Don't trigger deprecations for classes in the same vendor        if (2 > $len = 1 + (strpos($class, '\\') ?: strpos($class, '_'))) {            $len = 0;            $ns = '';        } else {            $ns = str_replace('_', '\\', substr($class, 0, $len));        }        // Detect annotations on the class        if (false !== $doc = $refl->getDocComment()) {            foreach (['final', 'deprecated', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    self::${$annotation}[$class] = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                }            }            if ($refl->isInterface() && false !== strpos($doc, 'method') && preg_match_all('#\n \* @method\s+(static\s+)?+(?:[\w\|&\[\]\\\]+\s+)?(\w+(?:\s*\([^\)]*\))?)+(.+?([[:punct:]]\s*)?)?(?=\r?\n \*(?: @|/$|\r?\n))#', $doc, $notice, \PREG_SET_ORDER)) {                foreach ($notice as $method) {                    $static = '' !== $method[1];                    $name = $method[2];                    $description = $method[3] ?? null;                    if (false === strpos($name, '(')) {                        $name .= '()';                    }                    if (null !== $description) {                        $description = trim($description);                        if (!isset($method[4])) {                            $description .= '.';                        }                    }                    self::$method[$class][] = [$class, $name, $static, $description];                }            }        }        $parent = get_parent_class($class);        $parentAndOwnInterfaces = $this->getOwnInterfaces($class, $parent ?: null);        if ($parent) {            $parentAndOwnInterfaces[$parent] = $parent;            if (!isset(self::$checkedClasses[$parent])) {                $this->checkClass($parent);            }            if (isset(self::$final[$parent])) {                $deprecations[] = sprintf('The ""%s"" class is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $parent, self::$final[$parent], $class);            }        }        // Detect if the parent is annotated        foreach ($parentAndOwnInterfaces + class_uses($class, false) as $use) {            if (!isset(self::$checkedClasses[$use])) {                $this->checkClass($use);            }            if (isset(self::$deprecated[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len) && !isset(self::$deprecated[$class])) {                $type = class_exists($class, false) ? 'class' : (interface_exists($class, false) ? 'interface' : 'trait');                $verb = class_exists($use, false) || interface_exists($class, false) ? 'extends' : (interface_exists($use, false) ? 'implements' : 'uses');                $deprecations[] = sprintf('The ""%s"" %s %s ""%s"" that is deprecated%s.', $class, $type, $verb, $use, self::$deprecated[$use]);            }            if (isset(self::$internal[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len)) {                $deprecations[] = sprintf('The ""%s"" %s is considered internal%s. It may change without further notice. You should not use it from ""%s"".', $use, class_exists($use, false) ? 'class' : (interface_exists($use, false) ? 'interface' : 'trait'), self::$internal[$use], $class);            }            if (isset(self::$method[$use])) {                if ($refl->isAbstract()) {                    if (isset(self::$method[$class])) {                        self::$method[$class] = array_merge(self::$method[$class], self::$method[$use]);                    } else {                        self::$method[$class] = self::$method[$use];                    }                } elseif (!$refl->isInterface()) {                    $hasCall = $refl->hasMethod('__call');                    $hasStaticCall = $refl->hasMethod('__callStatic');                    foreach (self::$method[$use] as $method) {                        [$interface, $name, $static, $description] = $method;                        if ($static ? $hasStaticCall : $hasCall) {                            continue;                        }                        $realName = substr($name, 0, strpos($name, '('));                        if (!$refl->hasMethod($realName) || !($methodRefl = $refl->getMethod($realName))->isPublic() || ($static && !$methodRefl->isStatic()) || (!$static && $methodRefl->isStatic())) {                            $deprecations[] = sprintf('Class ""%s"" should implement method ""%s::%s""%s', $class, ($static ? 'static ' : '').$interface, $name, null == $description ? '.' : ': '.$description);                        }                    }                }            }        }        if (trait_exists($class)) {            return $deprecations;        }        // Inherit @final, @internal and @param annotations for methods        self::$finalMethods[$class] = [];        self::$internalMethods[$class] = [];        self::$annotatedParameters[$class] = [];        foreach ($parentAndOwnInterfaces as $use) {            foreach (['finalMethods', 'internalMethods', 'annotatedParameters'] as $property) {                if (isset(self::${$property}[$use])) {                    self::${$property}[$class] = self::${$property}[$class] ? self::${$property}[$use] + self::${$property}[$class] : self::${$property}[$use];                }            }        }        foreach ($refl->getMethods(\ReflectionMethod::IS_PUBLIC | \ReflectionMethod::IS_PROTECTED) as $method) {            if ($method->class !== $class) {                continue;            }            if ($parent && isset(self::$finalMethods[$parent][$method->name])) {                [$declaringClass, $message] = self::$finalMethods[$parent][$method->name];                $deprecations[] = sprintf('The ""%s::%s()"" method is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);            }            if (isset(self::$internalMethods[$class][$method->name])) {                [$declaringClass, $message] = self::$internalMethods[$class][$method->name];                if (strncmp($ns, $declaringClass, $len)) {                    $deprecations[] = sprintf('The ""%s::%s()"" method is considered internal%s. It may change without further notice. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);                }            }            // To read method annotations            $doc = $method->getDocComment();            if (isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }                foreach (self::$annotatedParameters[$class][$method->name] as $parameterName => $deprecation) {                    if (!isset($definedParameters[$parameterName]) && !($doc && preg_match(""/\\n\\s+\\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\\\${$parameterName}\\b/"", $doc))) {                        $deprecations[] = sprintf($deprecation, $class);                    }                }            }            if (!$doc) {                continue;            }            $finalOrInternal = false;            foreach (['final', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    $message = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                    self::${$annotation.'Methods'}[$class][$method->name] = [$class, $message];                    $finalOrInternal = true;                }            }            if ($finalOrInternal || $method->isConstructor() || false === strpos($doc, '@param') || StatelessInvocation::class === $class) {                continue;            }            if (!preg_match_all('#\n\s+\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\$([a-zA-Z0-9_\x7f-\xff]++)#', $doc, $matches, \PREG_SET_ORDER)) {                continue;            }            if (!isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }            }            foreach ($matches as [, $parameterType, $parameterName]) {                if (!isset($definedParameters[$parameterName])) {                    $parameterType = trim($parameterType);                    self::$annotatedParameters[$class][$method->name][$parameterName] = sprintf('The ""%%s::%s()"" method will require a new ""%s$%s"" argument in the next major version of its %s ""%s"", not defining it is deprecated.', $method->name, $parameterType ? $parameterType.' ' : '', $parameterName, interface_exists($class) ? 'interface' : 'parent class', $method->class);                }            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_IpUtils_8805," Compares two IPv6 addresses.\n In case a subnet is given, it checks if it contains the request IP.\n\n @author David Soria Parra <dsp at php dot net>\n\n @see https://github.com/dsp/v6tools\n\n @param string $ip IPv6 address or subnet in CIDR notation\n\n @return bool Whether the IP is valid\n\n @throws \\RuntimeException When IPV6 support is not enabled\n","Poredi dve IPv6 adrese. U slučaju davanja podmreže, ona proverava da li sadrži IP zahtev","    public static function checkIp6(?string $requestIp, string $ip)    {        $cacheKey = $requestIp.'-'.$ip;        if (isset(self::$checkedIps[$cacheKey])) {            return self::$checkedIps[$cacheKey];        }        if (!((\extension_loaded('sockets') && \defined('AF_INET6')) || @inet_pton('::1'))) {            throw new \RuntimeException('Unable to check Ipv6. Check that PHP was not compiled with option ""disable-ipv6"".');        }        if (false !== strpos($ip, '/')) {            [$address, $netmask] = explode('/', $ip, 2);            if ('0' === $netmask) {                return (bool) unpack('n*', @inet_pton($address));            }            if ($netmask < 1 || $netmask > 128) {                return self::$checkedIps[$cacheKey] = false;            }        } else {            $address = $ip;            $netmask = 128;        }        $bytesAddr = unpack('n*', @inet_pton($address));        $bytesTest = unpack('n*', @inet_pton($requestIp));        if (!$bytesAddr || !$bytesTest) {            return self::$checkedIps[$cacheKey] = false;        }        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {            $left = $netmask - 16 * ($i - 1);            $left = ($left <= 16) ? $left : 16;            $mask = ~(0xffff >> $left) & 0xffff;            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {                return self::$checkedIps[$cacheKey] = false;            }        }        return self::$checkedIps[$cacheKey] = true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
firefly-iii_firefly-iii_breadcrumbs_832, Cuts away the middle of a string when it's very long.\\n\\n @param string $string\\n\\n @return string\\n,Odseče sredinu od stringa kada je veoma dugačka,"    function limitStringLength(string $string): string    {        $maxChars = 75;        $length   = \strlen($string);        $result   = $string;        if ($length > $maxChars) {            $result = substr_replace($string, ' ... ', (int)($maxChars / 2), $length - $maxChars);        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_RowEvolution_986," Returns a prettier, more comprehensible version of a row evolution label for display.\n","Vraća lepšu, razumljiviju verziju oznake evolucije reda za prikaz","    private function cleanOriginalLabel($label)    {        $label = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        $label = SafeDecodeLabel::decodeLabelSafe($label);        return $label;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1151," Prepare the version number.\n\n @todo Remove the error supression from str_replace() call.\n\n @param string $ver The string version, like ""2.6.21.2152"";\n\n @return float\n",Pripremite broj verzije,"    public function prepareVersionNo($ver)    {        $ver = str_replace(array('_', ' ', '/'), '.', $ver);        $arrVer = explode('.', $ver, 2);        if (isset($arrVer[1])) {            $arrVer[1] = @str_replace('.', '', $arrVer[1]); // @todo: treat strings versions.        }        return (float) implode('.', $arrVer);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_432, Determines if current source data is base64 encoded\\\\n\\\\n @return boolean\\\\n,Određuje da li su trenutni izvorni podaci base64 kodirani ,"    public function isBase64()    {        if (!is_string($this->data)) {            return false;        }        return base64_encode(base64_decode($this->data)) === str_replace([""\n"", ""\r""], '', $this->data);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Frame_6725," Returns the full contents of the file for this frame,\n if it's known.\n @return string|null\n","Vraća puni sadržaj datoteke za dati frejm, ako je poznat","    public function getFileContents()    {        if ($this->fileContentsCache === null && $filePath = $this->getFile()) {            // Leave the stage early when 'Unknown' or '[internal]' is passed            // this would otherwise raise an exception when            // open_basedir is enabled.            if ($filePath === ""Unknown"" || $filePath === '[internal]') {                return null;            }            try {                $this->fileContentsCache = file_get_contents($filePath);            } catch (ErrorException $exception) {                // Internal file paths of PHP extensions cannot be opened            }        }        return $this->fileContentsCache;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1643, Buffer incoming data until slave connection is available\\\\n and headers have been received\\\\n\\\\n @param string $data\\\\n,Podaci dolaze preko bafera dok ne bude dostupna pomoćna veza i zaglavlja se ne prime,"    public function handleData($data)    {        $this->incomingBuffer .= $data;        if ($this->connection && $this->isHeaderEnd($this->incomingBuffer)) {            $remoteAddress = (string) $this->incoming->getRemoteAddress();            $headersToReplace = [                'X-PHP-PM-Remote-IP' => \trim(\parse_url($remoteAddress, PHP_URL_HOST), '[]'),                'X-PHP-PM-Remote-Port' => \trim(\parse_url($remoteAddress, PHP_URL_PORT), '[]')            ];            $buffer = $this->replaceHeader($this->incomingBuffer, $headersToReplace);            $this->connection->write($buffer);            $this->incoming->removeListener('data', [$this, 'handleData']);            $this->incoming->pipe($this->connection);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_BufferingLogger_1725," A buffering logger that stacks logs for later.\n\n @author Nicolas Grekas <p@tchwork.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\BufferingLogger instead.\n",Loger bafera slaže evidencije za kasnije,"class BufferingLogger extends AbstractLogger{    private $logs = [];    /**     * @return void     */    public function log($level, $message, array $context = [])    {        $this->logs[] = [$level, $message, $context];    }    public function cleanLogs()    {        $logs = $this->logs;        $this->logs = [];        return $logs;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8045, Cleans or flushes output buffers up to target level.\n\n Resulting level can be greater than target level if a non-removable buffer has been encountered.\n\n @final\n,Čisti ili ispira izlazne bafere do ciljanog nivoa. Rezultatni nivo može biti veći od ciljnog ako je naišao na ne uklonjivi bafer,"    public function __toString()    {        return            sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText).""\r\n"".            $this->headers.""\r\n"".            $this->getContent();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
guzzle_guzzle_BodySummarizer_1389, Returns a summarized message body.\n,Prikazuje sažeto telo poruke,"    public function summarize(MessageInterface $message): ?string    {        return $this->truncateAt === null            ? \GuzzleHttp\Psr7\Message::bodySummary($message)            : \GuzzleHttp\Psr7\Message::bodySummary($message, $this->truncateAt);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mockery_mockery_CompositeExpectation_418, Return the string summary of this composite expectation\\\\\\\\n\\\\\\\\n @return string\\\\\\\\n,Vrati string rezime složenog očekivanja,"    public function __toString()    {        $return = '[';        $parts = array();        foreach ($this->_expectations as $exp) {            $parts[] = (string) $exp;        }        $return .= implode(', ', $parts) . ']';        return $return;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-pm_php-pm_SlavePool_1678, Return a human-readable summary of the slaves in the pool.\\\\n\\\\n @return array\\\\n,Vratite čoveku čitljiv sažetak slaves-a u pool-u,"    public function getStatusSummary()    {        $map = [            'total' => Slave::ANY,            'ready' => Slave::READY,            'busy' => Slave::BUSY,            'created' => Slave::CREATED,            'registered' => Slave::REGISTERED,            'closed' => Slave::CLOSED        ];        return \array_map(function ($state) {            return \count($this->getByStatus($state));        }, $map);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
spatie_array-functions_array_functions_1062, Returns an array with the unique values from all the given arrays.\n\n @param \\array[] $arrays\n\n @return array\n,Prikazuje niz sa jedinstvenim vrednostima iz svih zadatih nizova,"function array_merge_values(array ...$arrays){    $allValues = array_reduce($arrays, static function ($carry, $array) {        return array_merge($carry, $array);    }, []);    return array_values(array_unique($allValues));}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PrestaShop_PrestaShop_CMSCategory_855, Return an array of all children of the current CMSCategory.\\\\n\\\\n @return PrestaShopCollection Collection of CMSCategory\\\\n,Vrati niz svih podređenih elemenata trenutne CMSCategorije,"    private function getAllChildren()    {        // Get children        $toDelete = [(int) $this->id];        $this->recursiveDelete($toDelete, (int) $this->id);        $toDelete = array_unique($toDelete);        // remove id of current CMSCategory because we want only ids of children        unset($toDelete[0]);        if (count($toDelete)) {            $children = new PrestaShopCollection('CMSCategory');            $children->where('id_cms_category', 'in', $toDelete);            return $children;        }        return $toDelete;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Apriori_811," Calculates frequent k item sets, where count($samples) == $k - 1.\n\n @param mixed[][] $samples\n\n @return mixed[][]\n","Izračunava česte k skupove predmeta, gde je count($samples) == $k - 1","    private function candidates(array $samples): array    {        $candidates = [];        foreach ($samples as $p) {            foreach ($samples as $q) {                if (count(array_merge(array_diff($p, $q), array_diff($q, $p))) != 2) {                    continue;                }                $candidate = array_values(array_unique(array_merge($p, $q)));                if ($this->contains($candidates, $candidate)) {                    continue;                }                foreach ($this->samples as $sample) {                    if ($this->subset($sample, $candidate)) {                        $candidates[] = $candidate;                        continue 2;                    }                }            }        }        return $candidates;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Integer_2969, Radical (or squarefree kernel)\\n The radical of a positive integer is the product of its distinct prime factors.\\n\\n @see    https://en.wikipedia.org/wiki/Radical_of_an_integer\\n @see    https://oeis.org/A007947\\n\\n @param  int $n\\n\\n @return int the radical of n\\n\\n @throws Exception\\\\OutOfBoundsException if n is < 1.\\n,Radikal (ili jezgro bez kvadrata) Radikal pozitivnog celog broja proizvod je njegovih različitih osnovnih faktora,    public static function radical(int $n): int    {        return \array_product(\array_unique(self::primeFactorization($n)));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_css-selector_FunctionExtension_3331," XPath expression translator function extension.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-FranÃ§ois Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n",Proširenje funkcije prevodioca izraza XPath. Ova komponenta je port Python cssselect biblioteke,"class FunctionExtension extends AbstractExtension{    /**     * {@inheritdoc}     */    public function getFunctionTranslators(): array    {        return [            'nth-child' => [$this, 'translateNthChild'],            'nth-last-child' => [$this, 'translateNthLastChild'],            'nth-of-type' => [$this, 'translateNthOfType'],            'nth-last-of-type' => [$this, 'translateNthLastOfType'],            'contains' => [$this, 'translateContains'],            'lang' => [$this, 'translateLang'],        ];    }    /**     * @throws ExpressionErrorException     */    public function translateNthChild(XPathExpr $xpath, FunctionNode $function, bool $last = false, bool $addNameTest = true): XPathExpr    {        try {            [$a, $b] = Parser::parseSeries($function->getArguments());        } catch (SyntaxErrorException $e) {            throw new ExpressionErrorException(sprintf('Invalid series: ""%s"".', implode('"", ""', $function->getArguments())), 0, $e);        }        $xpath->addStarPrefix();        if ($addNameTest) {            $xpath->addNameTest();        }        if (0 === $a) {            return $xpath->addCondition('position() = '.($last ? 'last() - '.($b - 1) : $b));        }        if ($a < 0) {            if ($b < 1) {                return $xpath->addCondition('false()');            }            $sign = '<=';        } else {            $sign = '>=';        }        $expr = 'position()';        if ($last) {            $expr = 'last() - '.$expr;            --$b;        }        if (0 !== $b) {            $expr .= ' - '.$b;        }        $conditions = [sprintf('%s %s 0', $expr, $sign)];        if (1 !== $a && -1 !== $a) {            $conditions[] = sprintf('(%s) mod %d = 0', $expr, $a);        }        return $xpath->addCondition(implode(' and ', $conditions));        // todo: handle an+b, odd, even        // an+b means every-a, plus b, e.g., 2n+1 means odd        // 0n+b means b        // n+0 means a=1, i.e., all elements        // an means every a elements, i.e., 2n means even        // -n means -1n        // -1n+6 means elements 6 and previous    }    public function translateNthLastChild(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        return $this->translateNthChild($xpath, $function, true);    }    public function translateNthOfType(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        return $this->translateNthChild($xpath, $function, false, false);    }    /**     * @throws ExpressionErrorException     */    public function translateNthLastOfType(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        if ('*' === $xpath->getElement()) {            throw new ExpressionErrorException('""*:nth-of-type()"" is not implemented.');        }        return $this->translateNthChild($xpath, $function, true, false);    }    /**     * @throws ExpressionErrorException     */    public function translateContains(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        $arguments = $function->getArguments();        foreach ($arguments as $token) {            if (!($token->isString() || $token->isIdentifier())) {                throw new ExpressionErrorException('Expected a single string or identifier for :contains(), got '.implode(', ', $arguments));            }        }        return $xpath->addCondition(sprintf(            'contains(string(.), %s)',            Translator::getXpathLiteral($arguments[0]->getValue())        ));    }    /**     * @throws ExpressionErrorException     */    public function translateLang(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        $arguments = $function->getArguments();        foreach ($arguments as $token) {            if (!($token->isString() || $token->isIdentifier())) {                throw new ExpressionErrorException('Expected a single string or identifier for :lang(), got '.implode(', ', $arguments));            }        }        return $xpath->addCondition(sprintf(            'lang(%s)',            Translator::getXpathLiteral($arguments[0]->getValue())        ));    }    /**     * {@inheritdoc}     */    public function getName(): string    {        return 'function';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
symfony_css-selector_Translator_3301," XPath expression translator interface.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-FranÃ§ois Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n",Interfejs prevodioca izraza XPath. Ova komponenta je port Python cssselect biblioteke,"class Translator implements TranslatorInterface{    private $mainParser;    /**     * @var ParserInterface[]     */    private $shortcutParsers = [];    /**     * @var Extension\ExtensionInterface[]     */    private $extensions = [];    private $nodeTranslators = [];    private $combinationTranslators = [];    private $functionTranslators = [];    private $pseudoClassTranslators = [];    private $attributeMatchingTranslators = [];    public function __construct(ParserInterface $parser = null)    {        $this->mainParser = $parser ?? new Parser();        $this            ->registerExtension(new Extension\NodeExtension())            ->registerExtension(new Extension\CombinationExtension())            ->registerExtension(new Extension\FunctionExtension())            ->registerExtension(new Extension\PseudoClassExtension())            ->registerExtension(new Extension\AttributeMatchingExtension())        ;    }    public static function getXpathLiteral(string $element): string    {        if (false === strpos($element, ""'"")) {            return ""'"".$element.""'"";        }        if (false === strpos($element, '""')) {            return '""'.$element.'""';        }        $string = $element;        $parts = [];        while (true) {            if (false !== $pos = strpos($string, ""'"")) {                $parts[] = sprintf(""'%s'"", substr($string, 0, $pos));                $parts[] = ""\""'\"""";                $string = substr($string, $pos + 1);            } else {                $parts[] = ""'$string'"";                break;            }        }        return sprintf('concat(%s)', implode(', ', $parts));    }    /**     * {@inheritdoc}     */    public function cssToXPath(string $cssExpr, string $prefix = 'descendant-or-self::'): string    {        $selectors = $this->parseSelectors($cssExpr);        /** @var SelectorNode $selector */        foreach ($selectors as $index => $selector) {            if (null !== $selector->getPseudoElement()) {                throw new ExpressionErrorException('Pseudo-elements are not supported.');            }            $selectors[$index] = $this->selectorToXPath($selector, $prefix);        }        return implode(' | ', $selectors);    }    /**     * {@inheritdoc}     */    public function selectorToXPath(SelectorNode $selector, string $prefix = 'descendant-or-self::'): string    {        return ($prefix ?: '').$this->nodeToXPath($selector);    }    /**     * @return $this     */    public function registerExtension(Extension\ExtensionInterface $extension): self    {        $this->extensions[$extension->getName()] = $extension;        $this->nodeTranslators = array_merge($this->nodeTranslators, $extension->getNodeTranslators());        $this->combinationTranslators = array_merge($this->combinationTranslators, $extension->getCombinationTranslators());        $this->functionTranslators = array_merge($this->functionTranslators, $extension->getFunctionTranslators());        $this->pseudoClassTranslators = array_merge($this->pseudoClassTranslators, $extension->getPseudoClassTranslators());        $this->attributeMatchingTranslators = array_merge($this->attributeMatchingTranslators, $extension->getAttributeMatchingTranslators());        return $this;    }    /**     * @throws ExpressionErrorException     */    public function getExtension(string $name): Extension\ExtensionInterface    {        if (!isset($this->extensions[$name])) {            throw new ExpressionErrorException(sprintf('Extension ""%s"" not registered.', $name));        }        return $this->extensions[$name];    }    /**     * @return $this     */    public function registerParserShortcut(ParserInterface $shortcut): self    {        $this->shortcutParsers[] = $shortcut;        return $this;    }    /**     * @throws ExpressionErrorException     */    public function nodeToXPath(NodeInterface $node): XPathExpr    {        if (!isset($this->nodeTranslators[$node->getNodeName()])) {            throw new ExpressionErrorException(sprintf('Node ""%s"" not supported.', $node->getNodeName()));        }        return $this->nodeTranslators[$node->getNodeName()]($node, $this);    }    /**     * @throws ExpressionErrorException     */    public function addCombination(string $combiner, NodeInterface $xpath, NodeInterface $combinedXpath): XPathExpr    {        if (!isset($this->combinationTranslators[$combiner])) {            throw new ExpressionErrorException(sprintf('Combiner ""%s"" not supported.', $combiner));        }        return $this->combinationTranslators[$combiner]($this->nodeToXPath($xpath), $this->nodeToXPath($combinedXpath));    }    /**     * @throws ExpressionErrorException     */    public function addFunction(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        if (!isset($this->functionTranslators[$function->getName()])) {            throw new ExpressionErrorException(sprintf('Function ""%s"" not supported.', $function->getName()));        }        return $this->functionTranslators[$function->getName()]($xpath, $function);    }    /**     * @throws ExpressionErrorException     */    public function addPseudoClass(XPathExpr $xpath, string $pseudoClass): XPathExpr    {        if (!isset($this->pseudoClassTranslators[$pseudoClass])) {            throw new ExpressionErrorException(sprintf('Pseudo-class ""%s"" not supported.', $pseudoClass));        }        return $this->pseudoClassTranslators[$pseudoClass]($xpath);    }    /**     * @throws ExpressionErrorException     */    public function addAttributeMatching(XPathExpr $xpath, string $operator, string $attribute, $value): XPathExpr    {        if (!isset($this->attributeMatchingTranslators[$operator])) {            throw new ExpressionErrorException(sprintf('Attribute matcher operator ""%s"" not supported.', $operator));        }        return $this->attributeMatchingTranslators[$operator]($xpath, $attribute, $value);    }    /**     * @return SelectorNode[]     */    private function parseSelectors(string $css): array    {        foreach ($this->shortcutParsers as $shortcut) {            $tokens = $shortcut->parse($css);            if (!empty($tokens)) {                return $tokens;            }        }        return $this->mainParser->parse($css);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
pagekit_pagekit_ExtensionTranslateCommand_892, Returns all files of an extension to extract translations.\\n\\n @param  string $path\\n @return array\\n,Vraća sve datoteke ekstenzije za izdvajanje prevoda,"    protected function getFiles($path, $extension)    {        $files = Finder::create()->files()->in($path);        if ($extension == ""system"") {            // add installer files            $files->in($this->container->path().'/app/installer');        }        return $files->name('*.{php,vue,js,html,twig}');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2167, Extracts the key from BITOP command.\n\n @param CommandInterface $command Command instance.\n\n @return string|null\n,Izdvaja ključ iz BITOP naredbe,"    protected function getKeyFromBitOp(CommandInterface $command)    {        $arguments = $command->getArguments();        if ($this->checkSameSlotForKeys(array_slice($arguments, 1, count($arguments)))) {            return $arguments[1];        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_ClusterStrategy_2170, Extracts the key from EVAL and EVALSHA commands.\\n\\n @param CommandInterface $command Command instance.\\n\\n @return string|null\\n,Izdvaja ključ iz naredbi EVAL i EVALSHA,"    protected function getKeyFromScriptingCommands(CommandInterface $command)    {        if ($command instanceof ScriptCommand) {            $keys = $command->getKeys();        } else {            $keys = array_slice($args = $command->getArguments(), 2, $args[1]);        }        if ($keys && $this->checkSameSlotForKeys($keys)) {            return $keys[0];        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_899, PHPWord settings class\\n\\n @since 0.8.0\\n,HPWord podešavanja klase,"class Settings{    /**     * Zip libraries     *     * @const string     */    const ZIPARCHIVE = 'ZipArchive';    const PCLZIP = 'PclZip';    const OLD_LIB = 'PhpOffice\\PhpWord\\Shared\\ZipArchive'; // @deprecated 0.11    /**     * PDF rendering libraries     *     * @const string     */    const PDF_RENDERER_DOMPDF = 'DomPDF';    const PDF_RENDERER_TCPDF = 'TCPDF';    const PDF_RENDERER_MPDF = 'MPDF';    /**     * Measurement units multiplication factor     *     * Applied to:     * - Section: margins, header/footer height, gutter, column spacing     * - Tab: position     * - Indentation: left, right, firstLine, hanging     * - Spacing: before, after     *     * @const string     */    const UNIT_TWIP = 'twip'; // = 1/20 point    const UNIT_CM = 'cm';    const UNIT_MM = 'mm';    const UNIT_INCH = 'inch';    const UNIT_POINT = 'point'; // = 1/72 inch    const UNIT_PICA = 'pica'; // = 1/6 inch = 12 points    /**     * Default font settings     *     * OOXML defined font size values in halfpoints, i.e. twice of what PhpWord     * use, and the conversion will be conducted during XML writing.     */    const DEFAULT_FONT_NAME = 'Arial';    const DEFAULT_FONT_SIZE = 10;    const DEFAULT_FONT_COLOR = '000000';    const DEFAULT_FONT_CONTENT_TYPE = 'default'; // default|eastAsia|cs    const DEFAULT_PAPER = 'A4';    /**     * Compatibility option for XMLWriter     *     * @var bool     */    private static $xmlWriterCompatibility = true;    /**     * Name of the class used for Zip file management     *     * @var string     */    private static $zipClass = self::ZIPARCHIVE;    /**     * Name of the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererName = null;    /**     * Directory Path to the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererPath = null;    /**     * Measurement unit     *     * @var int|float     */    private static $measurementUnit = self::UNIT_TWIP;    /**     * Default font name     *     * @var string     */    private static $defaultFontName = self::DEFAULT_FONT_NAME;    /**     * Default font size     * @var int     */    private static $defaultFontSize = self::DEFAULT_FONT_SIZE;    /**     * Default paper     * @var string     */    private static $defaultPaper = self::DEFAULT_PAPER;    /**     * The user defined temporary directory.     *     * @var string     */    private static $tempDir = '';    /**     * Enables built-in output escaping mechanism.     * Default value is `false` for backward compatibility with versions below 0.13.0.     *     * @var bool     */    private static $outputEscapingEnabled = false;    /**     * Return the compatibility option used by the XMLWriter     *     * @return bool Compatibility     */    public static function hasCompatibility()    {        return self::$xmlWriterCompatibility;    }    /**     * Set the compatibility option used by the XMLWriter     *     * This sets the setIndent and setIndentString for better compatibility     *     * @param bool $compatibility     * @return bool     */    public static function setCompatibility($compatibility)    {        $compatibility = (bool) $compatibility;        self::$xmlWriterCompatibility = $compatibility;        return true;    }    /**     * Get zip handler class     *     * @return string     */    public static function getZipClass()    {        return self::$zipClass;    }    /**     * Set zip handler class     *     * @param  string $zipClass     * @return bool     */    public static function setZipClass($zipClass)    {        if (in_array($zipClass, array(self::PCLZIP, self::ZIPARCHIVE, self::OLD_LIB))) {            self::$zipClass = $zipClass;            return true;        }        return false;    }    /**     * Set details of the external library for rendering PDF files     *     * @param string $libraryName     * @param string $libraryBaseDir     * @return bool Success or failure     */    public static function setPdfRenderer($libraryName, $libraryBaseDir)    {        if (!self::setPdfRendererName($libraryName)) {            return false;        }        return self::setPdfRendererPath($libraryBaseDir);    }    /**     * Return the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererName()    {        return self::$pdfRendererName;    }    /**     * Identify the external library to use for rendering PDF files     *     * @param string $libraryName     * @return bool     */    public static function setPdfRendererName($libraryName)    {        $pdfRenderers = array(self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_MPDF);        if (!in_array($libraryName, $pdfRenderers)) {            return false;        }        self::$pdfRendererName = $libraryName;        return true;    }    /**     * Return the directory path to the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererPath()    {        return self::$pdfRendererPath;    }    /**     * Location of external library to use for rendering PDF files     *     * @param string $libraryBaseDir Directory path to the library's base folder     * @return bool Success or failure     */    public static function setPdfRendererPath($libraryBaseDir)    {        if (false === file_exists($libraryBaseDir) || false === is_readable($libraryBaseDir)) {            return false;        }        self::$pdfRendererPath = $libraryBaseDir;        return true;    }    /**     * Get measurement unit     *     * @return string     */    public static function getMeasurementUnit()    {        return self::$measurementUnit;    }    /**     * Set measurement unit     *     * @param string $value     * @return bool     */    public static function setMeasurementUnit($value)    {        $units = array(self::UNIT_TWIP, self::UNIT_CM, self::UNIT_MM, self::UNIT_INCH,            self::UNIT_POINT, self::UNIT_PICA, );        if (!in_array($value, $units)) {            return false;        }        self::$measurementUnit = $value;        return true;    }    /**     * Sets the user defined path to temporary directory.     *     * @since 0.12.0     *     * @param string $tempDir The user defined path to temporary directory     */    public static function setTempDir($tempDir)    {        self::$tempDir = $tempDir;    }    /**     * Returns path to temporary directory.     *     * @since 0.12.0     *     * @return string     */    public static function getTempDir()    {        if (!empty(self::$tempDir)) {            $tempDir = self::$tempDir;        } else {            $tempDir = sys_get_temp_dir();        }        return $tempDir;    }    /**     * @since 0.13.0     *     * @return bool     */    public static function isOutputEscapingEnabled()    {        return self::$outputEscapingEnabled;    }    /**     * @since 0.13.0     *     * @param bool $outputEscapingEnabled     */    public static function setOutputEscapingEnabled($outputEscapingEnabled)    {        self::$outputEscapingEnabled = $outputEscapingEnabled;    }    /**     * Get default font name     *     * @return string     */    public static function getDefaultFontName()    {        return self::$defaultFontName;    }    /**     * Set default font name     *     * @param string $value     * @return bool     */    public static function setDefaultFontName($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultFontName = $value;            return true;        }        return false;    }    /**     * Get default font size     *     * @return int     */    public static function getDefaultFontSize()    {        return self::$defaultFontSize;    }    /**     * Set default font size     *     * @param int $value     * @return bool     */    public static function setDefaultFontSize($value)    {        $value = (int) $value;        if ($value > 0) {            self::$defaultFontSize = $value;            return true;        }        return false;    }    /**     * Load setting from phpword.yml or phpword.yml.dist     *     * @param string $filename     * @return array     */    public static function loadConfig($filename = null)    {        // Get config file        $configFile = null;        $configPath = __DIR__ . '/../../';        if ($filename !== null) {            $files = array($filename);        } else {            $files = array(""{$configPath}phpword.ini"", ""{$configPath}phpword.ini.dist"");        }        foreach ($files as $file) {            if (file_exists($file)) {                $configFile = realpath($file);                break;            }        }        // Parse config file        $config = array();        if ($configFile !== null) {            $config = @parse_ini_file($configFile);            if ($config === false) {                return $config;            }        }        // Set config value        foreach ($config as $key => $value) {            $method = ""set{$key}"";            if (method_exists(__CLASS__, $method)) {                self::$method($value);            }        }        return $config;    }    /**     * Get default paper     *     * @return string     */    public static function getDefaultPaper()    {        return self::$defaultPaper;    }    /**     * Set default paper     *     * @param string $value     * @return bool     */    public static function setDefaultPaper($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultPaper = $value;            return true;        }        return false;    }    /**     * Return the compatibility option used by the XMLWriter     *     * @deprecated 0.10.0     *     * @codeCoverageIgnore     */    public static function getCompatibility()    {        return self::hasCompatibility();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Driver_580, Returns clone of given core\n\n @return mixed\n,Vraća klon datog jezgra ,"    public function cloneCore($core)    {        $width = imagesx($core);        $height = imagesy($core);        $clone = imagecreatetruecolor($width, $height);        imagealphablending($clone, false);        imagesavealpha($clone, true);        $transparency = imagecolorallocatealpha($clone, 0, 0, 0, 127);        imagefill($clone, 0, 0, $transparency);                imagecopy($clone, $core, 0, 0, 0, 0, $width, $height);        return $clone;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Safe_179, Generate all the files in the output directory\n,Generišite sve datoteke u izlaznom direktorijumu,"    protected function generateFiles()    {        $includedHeaderFiles = $this->phalconH->generate();        $this->phalconC->generate($includedHeaderFiles);        $this->configM4->generate();        $this->configW32->generate();        copy($this->sourceDir . '/php_phalcon.h', $this->outputDir . '/php_phalcon.h');        $this->processKernelGlobals();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_BinaryFileResponse_8747, BinaryFileResponse represents an HTTP response delivering a file.\n\n @author Niklas Fiekas <niklas.fiekas@tu-clausthal.de>\n @author stealth35 <stealth35-php@live.fr>\n @author Igor Wiedler <igor@wiedler.ch>\n @author Jordan Alliot <jordan.alliot@gmail.com>\n @author Sergey Linnik <linniksa@gmail.com>\n,BinariFileResponse predstavlja HTTP odgovor,"class BinaryFileResponse extends Response{    protected static $trustXSendfileTypeHeader = false;    /**     * @var File     */    protected $file;    protected $offset = 0;    protected $maxlen = -1;    protected $deleteFileAfterSend = false;    /**     * @param \SplFileInfo|string $file               The file to stream     * @param int                 $status             The response status code     * @param array               $headers            An array of response headers     * @param bool                $public             Files are public by default     * @param string|null         $contentDisposition The type of Content-Disposition to set automatically with the filename     * @param bool                $autoEtag           Whether the ETag header should be automatically set     * @param bool                $autoLastModified   Whether the Last-Modified header should be automatically set     */    public function __construct($file, int $status = 200, array $headers = [], bool $public = true, string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)    {        parent::__construct(null, $status, $headers);        $this->setFile($file, $contentDisposition, $autoEtag, $autoLastModified);        if ($public) {            $this->setPublic();        }    }    /**     * @param \SplFileInfo|string $file               The file to stream     * @param int                 $status             The response status code     * @param array               $headers            An array of response headers     * @param bool                $public             Files are public by default     * @param string|null         $contentDisposition The type of Content-Disposition to set automatically with the filename     * @param bool                $autoEtag           Whether the ETag header should be automatically set     * @param bool                $autoLastModified   Whether the Last-Modified header should be automatically set     *     * @return static     *     * @deprecated since Symfony 5.2, use __construct() instead.     */    public static function create($file = null, int $status = 200, array $headers = [], bool $public = true, string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)    {        trigger_deprecation('symfony/http-foundation', '5.2', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($file, $status, $headers, $public, $contentDisposition, $autoEtag, $autoLastModified);    }    /**     * Sets the file to stream.     *     * @param \SplFileInfo|string $file The file to stream     *     * @return $this     *     * @throws FileException     */    public function setFile($file, string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)    {        if (!$file instanceof File) {            if ($file instanceof \SplFileInfo) {                $file = new File($file->getPathname());            } else {                $file = new File((string) $file);            }        }        if (!$file->isReadable()) {            throw new FileException('File must be readable.');        }        $this->file = $file;        if ($autoEtag) {            $this->setAutoEtag();        }        if ($autoLastModified) {            $this->setAutoLastModified();        }        if ($contentDisposition) {            $this->setContentDisposition($contentDisposition);        }        return $this;    }    /**     * Gets the file.     *     * @return File The file to stream     */    public function getFile()    {        return $this->file;    }    /**     * Automatically sets the Last-Modified header according the file modification date.     */    public function setAutoLastModified()    {        $this->setLastModified(\DateTime::createFromFormat('U', $this->file->getMTime()));        return $this;    }    /**     * Automatically sets the ETag header according to the checksum of the file.     */    public function setAutoEtag()    {        $this->setEtag(base64_encode(hash_file('sha256', $this->file->getPathname(), true)));        return $this;    }    /**     * Sets the Content-Disposition header with the given filename.     *     * @param string $disposition      ResponseHeaderBag::DISPOSITION_INLINE or ResponseHeaderBag::DISPOSITION_ATTACHMENT     * @param string $filename         Optionally use this UTF-8 encoded filename instead of the real name of the file     * @param string $filenameFallback A fallback filename, containing only ASCII characters. Defaults to an automatically encoded filename     *     * @return $this     */    public function setContentDisposition(string $disposition, string $filename = '', string $filenameFallback = '')    {        if ('' === $filename) {            $filename = $this->file->getFilename();        }        if ('' === $filenameFallback && (!preg_match('/^[\x20-\x7e]*$/', $filename) || false !== strpos($filename, '%'))) {            $encoding = mb_detect_encoding($filename, null, true) ?: '8bit';            for ($i = 0, $filenameLength = mb_strlen($filename, $encoding); $i < $filenameLength; ++$i) {                $char = mb_substr($filename, $i, 1, $encoding);                if ('%' === $char || \ord($char) < 32 || \ord($char) > 126) {                    $filenameFallback .= '_';                } else {                    $filenameFallback .= $char;                }            }        }        $dispositionHeader = $this->headers->makeDisposition($disposition, $filename, $filenameFallback);        $this->headers->set('Content-Disposition', $dispositionHeader);        return $this;    }    /**     * {@inheritdoc}     */    public function prepare(Request $request)    {        if (!$this->headers->has('Content-Type')) {            $this->headers->set('Content-Type', $this->file->getMimeType() ?: 'application/octet-stream');        }        if ('HTTP/1.0' !== $request->server->get('SERVER_PROTOCOL')) {            $this->setProtocolVersion('1.1');        }        $this->ensureIEOverSSLCompatibility($request);        $this->offset = 0;        $this->maxlen = -1;        if (false === $fileSize = $this->file->getSize()) {            return $this;        }        $this->headers->set('Content-Length', $fileSize);        if (!$this->headers->has('Accept-Ranges')) {            // Only accept ranges on safe HTTP methods            $this->headers->set('Accept-Ranges', $request->isMethodSafe() ? 'bytes' : 'none');        }        if (self::$trustXSendfileTypeHeader && $request->headers->has('X-Sendfile-Type')) {            // Use X-Sendfile, do not send any content.            $type = $request->headers->get('X-Sendfile-Type');            $path = $this->file->getRealPath();            // Fall back to scheme://path for stream wrapped locations.            if (false === $path) {                $path = $this->file->getPathname();            }            if ('x-accel-redirect' === strtolower($type)) {                // Do X-Accel-Mapping substitutions.                // @link https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/#x-accel-redirect                $parts = HeaderUtils::split($request->headers->get('X-Accel-Mapping', ''), ',=');                foreach ($parts as $part) {                    [$pathPrefix, $location] = $part;                    if (substr($path, 0, \strlen($pathPrefix)) === $pathPrefix) {                        $path = $location.substr($path, \strlen($pathPrefix));                        // Only set X-Accel-Redirect header if a valid URI can be produced                        // as nginx does not serve arbitrary file paths.                        $this->headers->set($type, $path);                        $this->maxlen = 0;                        break;                    }                }            } else {                $this->headers->set($type, $path);                $this->maxlen = 0;            }        } elseif ($request->headers->has('Range') && $request->isMethod('GET')) {            // Process the range headers.            if (!$request->headers->has('If-Range') || $this->hasValidIfRangeHeader($request->headers->get('If-Range'))) {                $range = $request->headers->get('Range');                if (0 === strpos($range, 'bytes=')) {                    [$start, $end] = explode('-', substr($range, 6), 2) + [0];                    $end = ('' === $end) ? $fileSize - 1 : (int) $end;                    if ('' === $start) {                        $start = $fileSize - $end;                        $end = $fileSize - 1;                    } else {                        $start = (int) $start;                    }                    if ($start <= $end) {                        $end = min($end, $fileSize - 1);                        if ($start < 0 || $start > $end) {                            $this->setStatusCode(416);                            $this->headers->set('Content-Range', sprintf('bytes */%s', $fileSize));                        } elseif ($end - $start < $fileSize - 1) {                            $this->maxlen = $end < $fileSize ? $end - $start + 1 : -1;                            $this->offset = $start;                            $this->setStatusCode(206);                            $this->headers->set('Content-Range', sprintf('bytes %s-%s/%s', $start, $end, $fileSize));                            $this->headers->set('Content-Length', $end - $start + 1);                        }                    }                }            }        }        return $this;    }    private function hasValidIfRangeHeader(?string $header): bool    {        if ($this->getEtag() === $header) {            return true;        }        if (null === $lastModified = $this->getLastModified()) {            return false;        }        return $lastModified->format('D, d M Y H:i:s').' GMT' === $header;    }    /**     * Sends the file.     *     * {@inheritdoc}     */    public function sendContent()    {        if (!$this->isSuccessful()) {            return parent::sendContent();        }        if (0 === $this->maxlen) {            return $this;        }        $out = fopen('php://output', 'w');        $file = fopen($this->file->getPathname(), 'r');        stream_copy_to_stream($file, $out, $this->maxlen, $this->offset);        fclose($out);        fclose($file);        if ($this->deleteFileAfterSend && is_file($this->file->getPathname())) {            unlink($this->file->getPathname());        }        return $this;    }    /**     * {@inheritdoc}     *     * @throws \LogicException when the content is not null     */    public function setContent(?string $content)    {        if (null !== $content) {            throw new \LogicException('The content cannot be set on a BinaryFileResponse instance.');        }        return $this;    }    /**     * {@inheritdoc}     */    public function getContent()    {        return false;    }    /**     * Trust X-Sendfile-Type header.     */    public static function trustXSendfileTypeHeader()    {        self::$trustXSendfileTypeHeader = true;    }    /**     * If this is set to true, the file will be unlinked after the request is sent     * Note: If the X-Sendfile header is used, the deleteFileAfterSend setting will not be used.     *     * @return $this     */    public function deleteFileAfterSend(bool $shouldDelete = true)    {        $this->deleteFileAfterSend = $shouldDelete;        return $this;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8916, Clones the current Response instance.\n,Klonira trenutnu instancu odgovora,"    public function sendHeaders()    {        // headers have already been sent by the developer        if (headers_sent()) {            return $this;        }        // headers        foreach ($this->headers->allPreserveCaseWithoutCookies() as $name => $values) {            $replace = 0 === strcasecmp($name, 'Content-Type');            foreach ($values as $value) {                header($name.': '.$value, $replace, $this->statusCode);            }        }        // cookies        foreach ($this->headers->getCookies() as $cookie) {            header('Set-Cookie: '.$cookie, false, $this->statusCode);        }        // status        header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText), true, $this->statusCode);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_ResponseHeaderBag_8965, ResponseHeaderBag is a container for Response HTTP headers.\n\n @author Fabien Potencier <fabien@symfony.com>\n,ResponseHeaderBag je kontejner za odgovor HTTP zaglavlja,"class ResponseHeaderBag extends HeaderBag{    public const COOKIES_FLAT = 'flat';    public const COOKIES_ARRAY = 'array';    public const DISPOSITION_ATTACHMENT = 'attachment';    public const DISPOSITION_INLINE = 'inline';    protected $computedCacheControl = [];    protected $cookies = [];    protected $headerNames = [];    public function __construct(array $headers = [])    {        parent::__construct($headers);        if (!isset($this->headers['cache-control'])) {            $this->set('Cache-Control', '');        }        /* RFC2616 - 14.18 says all Responses need to have a Date */        if (!isset($this->headers['date'])) {            $this->initDate();        }    }    /**     * Returns the headers, with original capitalizations.     *     * @return array An array of headers     */    public function allPreserveCase()    {        $headers = [];        foreach ($this->all() as $name => $value) {            $headers[$this->headerNames[$name] ?? $name] = $value;        }        return $headers;    }    public function allPreserveCaseWithoutCookies()    {        $headers = $this->allPreserveCase();        if (isset($this->headerNames['set-cookie'])) {            unset($headers[$this->headerNames['set-cookie']]);        }        return $headers;    }    /**     * {@inheritdoc}     */    public function replace(array $headers = [])    {        $this->headerNames = [];        parent::replace($headers);        if (!isset($this->headers['cache-control'])) {            $this->set('Cache-Control', '');        }        if (!isset($this->headers['date'])) {            $this->initDate();        }    }    /**     * {@inheritdoc}     */    public function all(string $key = null)    {        $headers = parent::all();        if (null !== $key) {            $key = strtr($key, self::UPPER, self::LOWER);            return 'set-cookie' !== $key ? $headers[$key] ?? [] : array_map('strval', $this->getCookies());        }        foreach ($this->getCookies() as $cookie) {            $headers['set-cookie'][] = (string) $cookie;        }        return $headers;    }    /**     * {@inheritdoc}     */    public function set(string $key, $values, bool $replace = true)    {        $uniqueKey = strtr($key, self::UPPER, self::LOWER);        if ('set-cookie' === $uniqueKey) {            if ($replace) {                $this->cookies = [];            }            foreach ((array) $values as $cookie) {                $this->setCookie(Cookie::fromString($cookie));            }            $this->headerNames[$uniqueKey] = $key;            return;        }        $this->headerNames[$uniqueKey] = $key;        parent::set($key, $values, $replace);        // ensure the cache-control header has sensible defaults        if (\in_array($uniqueKey, ['cache-control', 'etag', 'last-modified', 'expires'], true) && '' !== $computed = $this->computeCacheControlValue()) {            $this->headers['cache-control'] = [$computed];            $this->headerNames['cache-control'] = 'Cache-Control';            $this->computedCacheControl = $this->parseCacheControl($computed);        }    }    /**     * {@inheritdoc}     */    public function remove(string $key)    {        $uniqueKey = strtr($key, self::UPPER, self::LOWER);        unset($this->headerNames[$uniqueKey]);        if ('set-cookie' === $uniqueKey) {            $this->cookies = [];            return;        }        parent::remove($key);        if ('cache-control' === $uniqueKey) {            $this->computedCacheControl = [];        }        if ('date' === $uniqueKey) {            $this->initDate();        }    }    /**     * {@inheritdoc}     */    public function hasCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->computedCacheControl);    }    /**     * {@inheritdoc}     */    public function getCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->computedCacheControl) ? $this->computedCacheControl[$key] : null;    }    public function setCookie(Cookie $cookie)    {        $this->cookies[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie;        $this->headerNames['set-cookie'] = 'Set-Cookie';    }    /**     * Removes a cookie from the array, but does not unset it in the browser.     */    public function removeCookie(string $name, ?string $path = '/', string $domain = null)    {        if (null === $path) {            $path = '/';        }        unset($this->cookies[$domain][$path][$name]);        if (empty($this->cookies[$domain][$path])) {            unset($this->cookies[$domain][$path]);            if (empty($this->cookies[$domain])) {                unset($this->cookies[$domain]);            }        }        if (empty($this->cookies)) {            unset($this->headerNames['set-cookie']);        }    }    /**     * Returns an array with all cookies.     *     * @return Cookie[]     *     * @throws \InvalidArgumentException When the $format is invalid     */    public function getCookies(string $format = self::COOKIES_FLAT)    {        if (!\in_array($format, [self::COOKIES_FLAT, self::COOKIES_ARRAY])) {            throw new \InvalidArgumentException(sprintf('Format ""%s"" invalid (%s).', $format, implode(', ', [self::COOKIES_FLAT, self::COOKIES_ARRAY])));        }        if (self::COOKIES_ARRAY === $format) {            return $this->cookies;        }        $flattenedCookies = [];        foreach ($this->cookies as $path) {            foreach ($path as $cookies) {                foreach ($cookies as $cookie) {                    $flattenedCookies[] = $cookie;                }            }        }        return $flattenedCookies;    }    /**     * Clears a cookie in the browser.     */    public function clearCookie(string $name, ?string $path = '/', string $domain = null, bool $secure = false, bool $httpOnly = true, string $sameSite = null)    {        $this->setCookie(new Cookie($name, null, 1, $path, $domain, $secure, $httpOnly, false, $sameSite));    }    /**     * @see HeaderUtils::makeDisposition()     */    public function makeDisposition(string $disposition, string $filename, string $filenameFallback = '')    {        return HeaderUtils::makeDisposition($disposition, $filename, $filenameFallback);    }    /**     * Returns the calculated value of the cache-control header.     *     * This considers several other headers and calculates or modifies the     * cache-control header to a sensible, conservative value.     *     * @return string     */    protected function computeCacheControlValue()    {        if (!$this->cacheControl) {            if ($this->has('Last-Modified') || $this->has('Expires')) {                return 'private, must-revalidate'; // allows for heuristic expiration (RFC 7234 Section 4.2.2) in the case of ""Last-Modified""            }            // conservative by default            return 'no-cache, private';        }        $header = $this->getCacheControlHeader();        if (isset($this->cacheControl['public']) || isset($this->cacheControl['private'])) {            return $header;        }        // public if s-maxage is defined, private otherwise        if (!isset($this->cacheControl['s-maxage'])) {            return $header.', private';        }        return $header;    }    private function initDate(): void    {        $this->set('Date', gmdate('D, d M Y H:i:s').' GMT');    }}",0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_1288, Return a random message.\n @param array $messages\n @return $this\n,Vrati nasumičnu poruku,    public function randomReply(array $messages)    {        return $this->reply($messages[array_rand($messages)]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
typecho_typecho_HyperDown_1372, parseShtml\n\n @param array $lines\n @param mixed $value\n @param int $start\n @return string\n,Parsira html,"    private function parseSh(array $lines, $num, $start, $end)    {        $line = $this->markLine($start, $end) . $this->parseInline(trim($lines[0], '# '));        return preg_match(""/^\s*$/"", $line) ? '' : ""<h{$num}>{$line}</h{$num}>"";    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0
typecho_typecho_HyperDown_1375, parseMh\\n\\n @param array $lines\\n @param int $num\\n @param int $start\\n @param int $end\\n @return string\\n,parseMh,"    private function parseList(array $lines, $value, $start)    {        $html = '';        list($space, $type, $tab) = $value;        $rows = array();        $suffix = '';        $last = 0;        foreach ($lines as $key => $line) {            if (preg_match(""/^(\s{"" . $space . ""})((?:[0-9]+\.?)|\-|\+|\*)(\s+)(.*)$/i"", $line, $matches)) {                if ($type == 'ol' && $key == 0) {                    $start = intval($matches[2]);                    if ($start != 1) {                        $suffix = ' start=""' . $start . '""';                    }                }                $rows[] = [$matches[4]];                $last = count($rows) - 1;            } else {                $rows[$last][] = preg_replace(""/^\s{"" . ($tab + $space) . ""}/"", '', $line);            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Archive_2845, Class to work with archives\n\n @author      Magento Core Team <core@magentocommerce.com>\n,Klasa za rad sa arhivama,"class Archive{    /**     * Archiver is used for compress.     */    const DEFAULT_ARCHIVER = 'gz';    /**     * Default packer for directory.     */    const TAPE_ARCHIVER = 'tar';    /**     * Current archiver is used for compress.     *     * @var \Magento\Framework\Archive\Tar|\Magento\Framework\Archive\Gz|\Magento\Framework\Archive\Bz     */    protected $_archiver = null;    /**     * Accessible formats for compress.     *     * @var array     */    protected $_formats = [        'tar' => 'tar',        'gz' => 'gz',        'gzip' => 'gz',        'tgz' => 'tar.gz',        'tgzip' => 'tar.gz',        'bz' => 'bz',        'bzip' => 'bz',        'bzip2' => 'bz',        'bz2' => 'bz',        'tbz' => 'tar.bz',        'tbzip' => 'tar.bz',        'tbz2' => 'tar.bz',        'tbzip2' => 'tar.bz',    ];    /**     * Create object of current archiver by $extension.     *     * @param string $extension     * @return Tar|Gz|Bz     */    protected function _getArchiver($extension)    {        $extension = strtolower($extension);        $format = isset($this->_formats[$extension]) ? $this->_formats[$extension] : self::DEFAULT_ARCHIVER;        $class = '\\Magento\Framework\Archive\\' . ucfirst($format);        $this->_archiver = new $class();        return $this->_archiver;    }    /**     * Split current format to list of archivers.     *     * @param string $source     * @return string[]|string     */    protected function _getArchivers($source)    {        $ext = pathinfo($source, PATHINFO_EXTENSION);        if (!empty($this->_formats[$ext])) {            return explode('.', $this->_formats[$ext]);        }        return [];    }    /**     * Pack file or directory to archivers are parsed from extension.     *     * @param string $source     * @param string $destination     * @param boolean $skipRoot skip first level parent     * @return string Path to file     */    public function pack($source, $destination = 'packed.tgz', $skipRoot = false)    {        $archivers = $this->_getArchivers($destination);        $interimSource = '';        for ($i = 0, $count = count($archivers); $i < $count; $i++) {            if ($i == $count - 1) {                $packed = $destination;            } else {                $packed = dirname($destination) . '/~tmp-' . microtime(true) . $archivers[$i] . '.' . $archivers[$i];            }            $source = $this->_getArchiver($archivers[$i])->pack($source, $packed, $skipRoot);            if ($interimSource && $i < $count) {                unlink($interimSource);            }            $interimSource = $source;        }        return $source;    }    /**     * Unpack file from archivers are parsed from extension.     * If $tillTar == true unpack file from archivers till     * meet TAR archiver.     *     * @param string $source     * @param string $destination     * @param bool $tillTar     * @param bool $clearInterm     * @return string Path to file     */    public function unpack($source, $destination = '.', $tillTar = false, $clearInterm = true)    {        $archivers = $this->_getArchivers($source);        $interimSource = '';        for ($i = count($archivers) - 1; $i >= 0; $i--) {            if ($tillTar && $archivers[$i] == self::TAPE_ARCHIVER) {                break;            }            if ($i == 0) {                $packed = rtrim($destination, '/') . '/';            } else {                $packed = rtrim(                    $destination,                    '/'                ) . '/~tmp-' . microtime(                    true                ) . $archivers[$i - 1] . '.' . $archivers[$i - 1];            }            $source = $this->_getArchiver($archivers[$i])->unpack($source, $packed);            if ($clearInterm && $interimSource && $i >= 0) {                unlink($interimSource);            }            $interimSource = $source;        }        return $source;    }    /**     * Extract one file from TAR (Tape Archiver).     *     * @param string $file     * @param string $source     * @param string $destination     * @return string Path to file     */    public function extract($file, $source, $destination = '.')    {        $tarFile = $this->unpack($source, $destination, true);        $resFile = $this->_getArchiver(self::TAPE_ARCHIVER)->extract($file, $tarFile, $destination);        if (!$this->isTar($source)) {            unlink($tarFile);        }        return $resFile;    }    /**     * Check file is archive.     *     * @param string $file     * @return boolean     */    public function isArchive($file)    {        $archivers = $this->_getArchivers($file);        if (count($archivers)) {            return true;        }        return false;    }    /**     * Check file is TAR.     *     * @param string $file     * @return boolean     */    public function isTar($file)    {        $archivers = $this->_getArchivers($file);        if (count($archivers) == 1 && $archivers[0] == self::TAPE_ARCHIVER) {            return true;        }        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_IdenticalBinaryConstraint_2134, A binary safe string comparison.\n\n @author Chris Corbyn\n,Binarno sigurno poređenje nizova,"class IdenticalBinaryConstraint extends \PHPUnit\Framework\Constraint\Constraint{    protected $value;    public function __construct($value)    {        $this->value = $value;    }    /**     * Evaluates the constraint for parameter $other. Returns TRUE if the     * constraint is met, FALSE otherwise.     *     * @param mixed $other value or object to evaluate     */    public function matches($other): bool    {        $aHex = $this->asHexString($this->value);        $bHex = $this->asHexString($other);        return $aHex === $bHex;    }    /**     * Returns a string representation of the constraint.     */    public function toString(): string    {        return 'identical binary';    }    /**     * Get the given string of bytes as a stirng of Hexadecimal sequences.     *     * @param string $binary     *     * @return string     */    private function asHexString($binary)    {        $hex = '';        $bytes = unpack('H*', $binary);        foreach ($bytes as &$byte) {            $byte = strtoupper($byte);        }        return implode('', $bytes);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_IdenticalBinaryConstraint_239, Get the given string of bytes as a stirng of Hexadecimal sequences.\\n\\n @param string $binary\\n\\n @return string\\n,Dohvata dati niz bajtova kao string heksadecimalnih sekvenci,"    private function asHexString($binary)    {        $hex = '';        $bytes = unpack('H*', $binary);        foreach ($bytes as &$byte) {            $byte = strtoupper($byte);        }        return implode('', $bytes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
predis_predis_Autoloader_2121, Loads a class from a file using its fully qualified name.\\n\\n @param string $className Fully qualified name of a class.\\n,Učitava klasu iz datoteke koristeći potpuno kvalifikovano ime,"    public function autoload($className)    {        if (0 === strpos($className, $this->prefix)) {            $parts = explode('\\', substr($className, $this->prefixLength));            $filepath = $this->directory.DIRECTORY_SEPARATOR.implode(DIRECTORY_SEPARATOR, $parts).'.php';            if (is_file($filepath)) {                require $filepath;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_918, Constructs a file.\\n\\n @param string                   $path    The absolute path to the file to process.\\n @param \\\\PHP_CodeSniffer\\\\Ruleset $ruleset The ruleset used for the run.\\n @param \\\\PHP_CodeSniffer\\\\Config  $config  The config data for the run.\\n\\n @return void\\n,Izrađuje datoteku,"    public function __construct($path, Ruleset $ruleset, Config $config)    {        $this->path    = $path;        $this->ruleset = $ruleset;        $this->config  = $config;        $this->fixer   = new Fixer();        $parts     = explode('.', $path);        $extension = array_pop($parts);        if (isset($config->extensions[$extension]) === true) {            $this->tokenizerType = $config->extensions[$extension];        } else {            // Revert to default.            $this->tokenizerType = 'PHP';        }        $this->configCache['cache']           = $this->config->cache;        $this->configCache['sniffs']          = array_map('strtolower', $this->config->sniffs);        $this->configCache['exclude']         = array_map('strtolower', $this->config->exclude);        $this->configCache['errorSeverity']   = $this->config->errorSeverity;        $this->configCache['warningSeverity'] = $this->config->warningSeverity;        $this->configCache['recordErrors']    = $this->config->recordErrors;        $this->configCache['ignorePatterns']  = $this->ruleset->ignorePatterns;        $this->configCache['includePatterns'] = $this->ruleset->includePatterns;    }//end __construct()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_9679," Returns given value's item, if exists.\n\n @return AcceptHeaderItem|null\n",Vraća stavku date vrednosti ako postoji,"    public function get(string $value)    {        return $this->items[$value] ?? $this->items[explode('/', $value)[0].'/*'] ?? $this->items['*/*'] ?? $this->items['*'] ?? null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
symfony_http-foundation_Request_9843," Returns the prefix as encoded in the string when the string starts with\n the given prefix, null otherwise.\n","Vraća prefiks kodiran u stingu kada niz započinje sa datim prefiksom, u suprotnom ništa","    private function getUrlencodedPrefix(string $string, string $prefix): ?string    {        if (0 !== strpos(rawurldecode($string), $prefix)) {            return null;        }        $len = \strlen($prefix);        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {            return $match[0];        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
php-pm_php-pm_RequestHandler_1651, Checks whether the end of the header is in $buffer.\\\\n\\\\n @param string $buffer\\\\n\\\\n @return bool\\\\n,Proverava da li je kraj zaglavlja u $baffer,"    protected function isHeaderEnd($buffer)    {        return false !== \strpos($buffer, ""\r\n\r\n"");    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_966, Find the nearest block end position after $offset\n\n @param int $offset    Search position\n @param string  $blockType XML Block tag\n @return int -1 if block end not found\n,Pronađite najbliži krajnji položaj bloka nakon $offset,"    protected function findXmlBlockEnd($offset, $blockType)    {        $blockEndStart = strpos($this->tempDocumentMainPart, '</' . $blockType . '>', $offset);        // return position of end of tag if found, otherwise -1        return ($blockEndStart === false) ? -1 : $blockEndStart + 3 + strlen($blockType);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
symfony_http-foundation_IpUtils_8805," Compares two IPv6 addresses.\n In case a subnet is given, it checks if it contains the request IP.\n\n @author David Soria Parra <dsp at php dot net>\n\n @see https://github.com/dsp/v6tools\n\n @param string $ip IPv6 address or subnet in CIDR notation\n\n @return bool Whether the IP is valid\n\n @throws \\RuntimeException When IPV6 support is not enabled\n","Poredi dve IPv6 adrese. U slučaju davanja podmreže, ona proverava da li sadrži IP zahtev","    public static function checkIp6(?string $requestIp, string $ip)    {        $cacheKey = $requestIp.'-'.$ip;        if (isset(self::$checkedIps[$cacheKey])) {            return self::$checkedIps[$cacheKey];        }        if (!((\extension_loaded('sockets') && \defined('AF_INET6')) || @inet_pton('::1'))) {            throw new \RuntimeException('Unable to check Ipv6. Check that PHP was not compiled with option ""disable-ipv6"".');        }        if (false !== strpos($ip, '/')) {            [$address, $netmask] = explode('/', $ip, 2);            if ('0' === $netmask) {                return (bool) unpack('n*', @inet_pton($address));            }            if ($netmask < 1 || $netmask > 128) {                return self::$checkedIps[$cacheKey] = false;            }        } else {            $address = $ip;            $netmask = 128;        }        $bytesAddr = unpack('n*', @inet_pton($address));        $bytesTest = unpack('n*', @inet_pton($requestIp));        if (!$bytesAddr || !$bytesTest) {            return self::$checkedIps[$cacheKey] = false;        }        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {            $left = $netmask - 16 * ($i - 1);            $left = ($left <= 16) ? $left : 16;            $mask = ~(0xffff >> $left) & 0xffff;            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {                return self::$checkedIps[$cacheKey] = false;            }        }        return self::$checkedIps[$cacheKey] = true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
markrogoyski_math-php_ChiSquared_3079, Median - closed form approximation\n\n             /    2 \\Â³\n median â‰ˆ k | 1 - -  |\n             \\    k /\n\n @return float\n,Medijana - aproksimacija zatvorenog oblika,    public function median(): float    {        $k          = $this->k;        $âŸ®1Â âˆ’Â 2ï¼9kâŸ¯ = 1 - (2 / (9 * $k));        return $k * $âŸ®1Â âˆ’Â 2ï¼9kâŸ¯ ** 3;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
phalcon_cphalcon_Safe_179, Generate all the files in the output directory\n,Generišite sve datoteke u izlaznom direktorijumu,"    protected function generateFiles()    {        $includedHeaderFiles = $this->phalconH->generate();        $this->phalconC->generate($includedHeaderFiles);        $this->configM4->generate();        $this->configW32->generate();        copy($this->sourceDir . '/php_phalcon.h', $this->outputDir . '/php_phalcon.h');        $this->processKernelGlobals();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0
symfony_http-kernel_CacheWarmer_3109, Abstract cache warmer that knows how to write a file to the cache.\n\n @author Fabien Potencier <fabien@symfony.com>\n,Apstraktni grejač keš memorije koji zna kako da upiše datoteku u keš memoriju,class ChainCacheClearer implements CacheClearerInterface{    private $clearers;    public function __construct(iterable $clearers = [])    {        $this->clearers = $clearers;    }    /**     * {@inheritdoc}     */    public function clear(string $cacheDir)    {        foreach ($this->clearers as $clearer) {            $clearer->clear($cacheDir);        }    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
googleapis_google-api-php-client_Verify_673, Retrieve and cache a certificates file.\n\n @param $url string location\n @throws \\Google\\Exception\n @return array certificates\n,Preuzmite i keširajte datoteku sertifikata,"  private function retrieveCertsFromLocation($url)  {    // If we're retrieving a local file, just grab it.    if (0 !== strpos($url, 'http')) {      if (!$file = file_get_contents($url)) {        throw new GoogleException(            ""Failed to retrieve verification certificates: '"" .            $url . ""'.""        );      }      return json_decode($file, true);    }    $response = $this->http->get($url);    if ($response->getStatusCode() == 200) {      return json_decode((string) $response->getBody(), true);    }    throw new GoogleException(        sprintf(            'Failed to retrieve verification certificates: ""%s"".',            $response->getBody()->getContents()        ),        $response->getStatusCode()    );  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
pagekit_pagekit_ExtensionTranslateCommand_894, Writes the translation file for the given extension.\n\n @param array  $messages\n @param string $extension\n @param string $path\n,Piše datoteku prevoda za datu ekstenziju,"    protected function writeTranslationFile($messages, $extension, $path)    {        foreach ($messages as $domain => $strings) {            $data = $this->getHeader($extension, $domain);            foreach ($strings as $string) {                $string = str_replace('""', '\""', $string);                $data .= ""msgid \"""".$string.""\""\nmsgstr \""\""\n\n"";            }            $refFile = $path.'/'.$domain.'.pot';            if (!file_exists($refFile) || !($compare = preg_replace('/^""POT-Creation-Date: (.*)$/im', '', [file_get_contents($refFile), $data]) and $compare[0] === $compare[1])) {                file_put_contents($refFile, $data);            }        }    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0
phalcon_cphalcon_Safe_1568, Resolves headers in the php_phalcon.h file\n,Rešava zaglavlja u php_phalcon,"    protected function processKernelGlobals()    {        $lines = [];        foreach (file($this->outputDir . '/php_phalcon.h') as $line) {            if (preg_match('@^#include ""(kernel/.+)""@', $line, $matches)) {                $content = file_get_contents($this->sourceDir . DIRECTORY_SEPARATOR . $matches[1]);                $lines[] = $content . PHP_EOL;            } else {                $lines[] = $line;            }        }        file_put_contents($this->outputDir . '/php_phalcon.h', join('', $lines));    }",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
getgrav_grav_Composer_1482, Return the composer executable file path\\n\\n @return string\\n,Vrati putanju izvršne datoteke kompozera,"    public static function getComposerExecutor()    {        $executor = PHP_BINARY . ' ';        $composer = static::getComposerLocation();        if ($composer !== static::DEFAULT_PATH && is_executable($composer)) {            $file = fopen($composer, 'rb');            $firstLine = fgets($file);            fclose($file);            if (!preg_match('/^#!.+php/i', $firstLine)) {                $executor = '';            }        }        return $executor . $composer;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
squizlabs_PHP_CodeSniffer_Runner_913," Processes a single file, including checking and fixing.\\n\\n @param \\\\PHP_CodeSniffer\\\\Files\\\\File $file The file to be processed.\\n\\n @return void\\n @throws \\\\PHP_CodeSniffer\\\\Exceptions\\\\DeepExitException\\n","Obrađuje jednu datoteku, uključujući proveru i popravljanje","    public function processFile($file)    {        if (PHP_CODESNIFFER_VERBOSITY > 0) {            $startTime = microtime(true);            echo 'Processing '.basename($file->path).' ';            if (PHP_CODESNIFFER_VERBOSITY > 1) {                echo PHP_EOL;            }        }        try {            $file->process();            if (PHP_CODESNIFFER_VERBOSITY > 0) {                $timeTaken = ((microtime(true) - $startTime) * 1000);                if ($timeTaken < 1000) {                    $timeTaken = round($timeTaken);                    echo ""DONE in {$timeTaken}ms"";                } else {                    $timeTaken = round(($timeTaken / 1000), 2);                    echo ""DONE in $timeTaken secs"";                }                if (PHP_CODESNIFFER_CBF === true) {                    $errors = $file->getFixableCount();                    echo "" ($errors fixable violations)"".PHP_EOL;                } else {                    $errors   = $file->getErrorCount();                    $warnings = $file->getWarningCount();                    echo "" ($errors errors, $warnings warnings)"".PHP_EOL;                }            }        } catch (\Exception $e) {            $error = 'An error occurred during processing; checking has been aborted. The error message was: '.$e->getMessage();            $file->addErrorOnLine($error, 1, 'Internal.Exception');        }//end try        $this->reporter->cacheFileReport($file, $this->config);        if ($this->config->interactive === true) {            /*                Running interactively.                Print the error report for the current file and then wait for user input.            */            // Get current violations and then clear the list to make sure            // we only print violations for a single file each time.            $numErrors = null;            while ($numErrors !== 0) {                $numErrors = ($file->getErrorCount() + $file->getWarningCount());                if ($numErrors === 0) {                    continue;                }                $this->reporter->printReport('full');                echo '<ENTER> to recheck, [s] to skip or [q] to quit : ';                $input = fgets(STDIN);                $input = trim($input);                switch ($input) {                case 's':                    break(2);                case 'q':                    throw new DeepExitException('', 0);                default:                    // Repopulate the sniffs because some of them save their state                    // and only clear it when the file changes, but we are rechecking                    // the same file.                    $file->ruleset->populateTokenListeners();                    $file->reloadContent();                    $file->process();                    $this->reporter->cacheFileReport($file, $this->config);                    break;                }            }//end while        }//end if        // Clean up the file to save (a lot of) memory.        $file->cleanUp();    }//end processFile()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
phacility_phabricator_Figlet_519, Function loads one character in the internal array from file\\n\\n @param resource &$fp handle of font file\\n\\n @return mixed lines of the character or false if foef occured\\n @access private\\n,Funkcija učitava jedan znak u unutrašnjem nizu iz datoteke,"    function _char(&$fp)    {        $out = array();        for ($i = 0; $i < $this->height; $i++) {            if (feof($fp)) {                return false;            }            $line = rtrim(fgets($fp, 2048), ""\r\n"");            if (preg_match('/(.){1,2}$/', $line, $r)) {                $line = str_replace($r[1], '', $line);            }            $line .= ""\x00"";            $out[] = $line;        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
