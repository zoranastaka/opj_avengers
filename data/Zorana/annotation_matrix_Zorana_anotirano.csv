pair_id,comment,Komentar,code,"1
","2
","3
","4
","5
","6
",7,"8
","9
","10
","11
","12
","13
","14
","15
","16
","17
","18
","19
","20
","21
","22
","23
","24
","25
","26
","27
","28
","29
","30
","31
","32
","33
","34
","35
","36
","37
","38
","39
","40
",41,"42
","43
","44
","45
","46
","47
","48
","49
","50
","konverzija json u xml datoteku
","kako nasumiƒçno izabrati broj
","normalna raspodela
","Nelder-Mead optimizacija
","hashset za odreƒëivanje broja razliƒçitih elemenata
","kako dohvatiti naziv tabele iz baze
","deserializacija json-a
","pronaƒëi int unutar stringa
","dohvatanje jedinstvenog identifikatora trenutnog procesa
","regex ne razlikuje velika i mala slova
","prilagoƒëeni http odgovor gre≈°ke
","kako odrediti da li je string valida reƒç
","zamena http entiteta
","sakrij atribute datoteke
","sortiraj vi≈°e nizova na osnovu redosleda drugih sortiranih nizova
","levenshteinova slicnost stringova
","kako dohvatiti html kod sa veb sajta
","baferisano ƒçitanje teksta ƒçitaƒçem fajlova
","aes ≈°ifrovanje u ctr naƒçinu rada
","matrica mno≈æenja
","≈°tampanje rezimea modela
","jedinstveni elementi
","izvlaƒçenje podataka iz sadr≈æaja html koda
","toplotna mapa iz 3d koordinata
","dohvatanje svih roditelja xml ƒçvora
","kako rekurzivno raspakovati zip datoteku
","podvuci tekst u label vid≈æetu
","raspakivanje velikih datoteka
","kopiranje putanje fajla
","dohvati opis http statusnog koda
","nasumiƒçno izvuci x stavki iz liste
","konvertuj string datum u yyyymmdd format
","pretvoriti utc vreme u epohu
","sve permutacije liste
","izvuci geografsku ≈°irinu i du≈æinu iz datog unosa
","kako proveriti da je checkbox ≈°tikliran
","pretvoriti uint8 niz u sliku
","memoizacija na disk - persistentna memoizacija
","parsiranje argumenata komandne linije
","kako proƒçitati sadr≈æaj iz .gz zapakovanog fajla
","slanje binarnih podataka preko seriske veze
","otpakovanje podataka iz tekstualne datoteke
","pozicije podstingova u stringu
","ƒçitanje elemenata iz html-a - <td>
","oduzimanje medijana iz svake kolone
","uklanjanja zaglavlja prilikom spajanja nekoliko datoteka
","parsiranje query stringa u url-u
","rangiranje fazi ƒçlanova na osnovu stepena podudaranja
","izlaz u html datoteku
",kako efikasno proƒçitati .csv datoteku
BookStackApp_BookStack_2014_10_12_100000_create_password_resets_table_764, Reverse the migrations.\n\n @return void\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('password_resets');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_2015_07_12_114933_create_books_table_765, Run the migrations.\n\n @return void\n, Pokrenuti migraciju.,"    public function up()    {        Schema::create('books', function (Blueprint $table) {            $table->increments('id');            $table->string('name');            $table->string('slug')->indexed();            $table->text('description');            $table->nullableTimestamps();        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_2015_08_08_200447_add_users_to_entities_773, Run the migrations.\n\n @return void\n, Pokrenuti migraciju.,"    public function up()    {        Schema::table('pages', function (Blueprint $table) {            $table->integer('created_by');            $table->integer('updated_by');        });        Schema::table('chapters', function (Blueprint $table) {            $table->integer('created_by');            $table->integer('updated_by');        });        Schema::table('images', function (Blueprint $table) {            $table->integer('created_by');            $table->integer('updated_by');        });        Schema::table('books', function (Blueprint $table) {            $table->integer('created_by');            $table->integer('updated_by');        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_2015_08_16_142133_create_activities_table_778, Reverse the migrations.\n\n @return void\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('activities');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_ActivityService_743, Flashes a notification message to the session if an appropriate message is available.\n, Prikazuje notifikaciju za sesiju ako je odgovaraju?a poruka dostupna. ,"    protected function setNotification(string $type)    {        $notificationTextKey = 'activities.' . $type . '_notification';        if (trans()->has($notificationTextKey)) {            $message = trans($notificationTextKey);            session()->flash('success', $message);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_Activity_734, Get the entity for this activity.\n, Vra?a entitet za ovu aktivnost. ,    public function entity(): MorphTo    {        if ($this->entity_type === '') {            $this->entity_type = null;        }        return $this->morphTo('entity');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_BrowserKitTest_784, Check if the page contains the given element.\n @param  string  $selector\n, Provjerava da li stranica sadrûi dati elemenat.,"    protected function pageHasElement($selector)    {        $elements = $this->crawler->filter($selector);        $this->assertTrue(count($elements) > 0, ""The page does not contain an element matching "" . $selector);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
BookStackApp_BookStack_CommentRepo_751, Get a comment by ID.\n, Vra?a komentar po ID. ,    public function getById(int $id): Comment    {        return $this->comment->newQuery()->findOrFail($id);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_CommentRepo_755, Convert the given comment markdown text to HTML.\n, Konvertuje dati komentar Convert the given comment markdown text to HTML.,"    public function commentToHtml(string $commentText): string    {        $converter = new CommonMarkConverter([            'html_input' => 'strip',            'max_nesting_level' => 10,            'allow_unsafe_links' => false,        ]);        return $converter->convertToHtml($commentText);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_CommentRepo_756, Get the next local ID relative to the linked entity.\n, Vra?a slede?i lokalni ID relativan povezanom entitetu. Get the next local ID relative to the linked entity.,"    protected function getNextLocalId(Entity $entity): int    {        $comments = $entity->comments(false)->orderBy('local_id', 'desc')->first();        return ($comments->local_id ?? 0) + 1;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_Favourite_757, Get the related model that can be favourited.\n, Vra?a povezani model koji moûe biti favorizovan. ,    public function favouritable(): MorphTo    {        return $this->morphTo();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_Tag_758, Get the entity that this tag belongs to\n, Vra?a entitet kojem ovaj tag pripada ,    public function entity(): MorphTo    {        return $this->morphTo('entity');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_201324_CreateComponentGroupsTable_1177, Reverse the migrations.\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('component_groups');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_202446_CreateIncidentTemplatesTable_1180, Run the migrations.\n, Pokrenuti migraciju.,"    public function up()    {        Schema::create('incident_templates', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->string('name');            $table->string('slug');            $table->longText('template');            $table->timestamps();            $table->softDeletes();        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_202446_CreateIncidentTemplatesTable_1181, Reverse the migrations.\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('incident_templates');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_203014_CreateSettingsTable_1188, Run the migrations.\n, Pokrenuti migraciju.,"    public function up()    {        Schema::create('settings', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->string('name');            $table->longText('value');            $table->timestamps();        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_203014_CreateSettingsTable_1189, Reverse the migrations.\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('settings');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_203235_CreateSubscribersTable_1191, Reverse the migrations.\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('subscribers');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_2015_01_05_203341_CreateUsersTable_1192, Run the migrations.\n, Pokrenuti migraciju.,"    public function up()    {        Schema::create('users', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->string('username');            $table->string('password');            $table->rememberToken();            $table->string('email');            $table->string('api_key');            $table->boolean('active')->default(1);            $table->tinyInteger('level')->default(2);            $table->timestamps();            $table->index('remember_token');            $table->index('active');            $table->unique('username');            $table->unique('api_key');            $table->unique('email');        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_AbstractApiTestCase_1212, Become a user.\n\n @return $this\n, Postani korisnik.,"    protected function beUser()    {        $this->user = factory(User::class)->create([            'username' => 'cachet-test',        ]);        $this->be($this->user);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_AbstractTestCase_1195, Set up the needed configuration to be able to run the tests.\n\n @return \\CachetHQ\\Tests\\Cachet\\AbstractTestCase\n, Podeöavanje potrebne konfiguracije za pokretanje testova. ,"    protected function setupConfig()    {        $env = $this->app->environment();        $repo = $this->app->make(Repository::class);        $cache = $this->app->make(Cache::class);        $loaded = $cache->load($env);        if ($loaded === false) {            $loaded = $repo->all();            $cache->store($env, $loaded);        }        $settings = array_merge($this->app->config->get('setting'), $loaded);        $this->app->config->set('setting', $settings);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_AnalysisTest_1196, This is the analysis test class.\n\n @author Graham Campbell <graham@alt-three.com>\n @author James Brooks <james@alt-three.com>\n, Ovo je klasa za analizu testa. ,"class AnalysisTest extends TestCase{    use AnalysisTrait;    /**     * Get the code paths to analyze.     *     * @return string[]     */    protected function getPaths()    {        return [            realpath(__DIR__.'/../app'),            realpath(__DIR__.'/../bootstrap'),            realpath(__DIR__.'/../config'),            realpath(__DIR__.'/../database'),            realpath(__DIR__),        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_ComponentGroupTest_1214, Set up the needed data for the tests.\n\n @return $this\n, Podeöavanje potrebnih podataka za testove. ,"    protected function createComponentGroups()    {        $this->createComponentGroup(self::COMPONENT_GROUP_1_NAME, ComponentGroup::VISIBLE_GUEST)            ->createComponentGroup(self::COMPONENT_GROUP_2_NAME, ComponentGroup::VISIBLE_AUTHENTICATED);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_ComponentGroupTest_1215, Create a component group.\n\n Also attaches a creator if any given as a parameter or exists in the test class.\n\n @param string $name\n @param string $visible\n\n @return $this\n, Kreiranje komponentne grupe.,"    protected function createComponentGroup($name, $visible)    {        factory(ComponentGroup::class)            ->create(['name' => $name, 'visible' => $visible]);        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_CreateComponentGroupCommand_1167, This is the create component group command.\n\n @author James Brooks <james@alt-three.com>\n, Ovo je komanda za kreiranje komponente grupe. ,"final class CreateComponentGroupCommand{    /**     * The component group name.     *     * @var string     */    public $name;    /**     * The component group description.     *     * @var int     */    public $order;    /**     * Is the component group collapsed?     *     * @var int     */    public $collapsed;    /**     * Is the component visible to public?     *     * @var int     */    public $visible;    /**     * The validation rules.     *     * @var string[]     */    public $rules = [        'name'      => 'required|string',        'order'     => 'required|int',        'collapsed' => 'required|int|between:0,4',        'visible'   => 'required|bool',    ];    /**     * Create a add component group command instance.     *     * @param string $name     * @param int    $order     * @param int    $collapsed     * @param int    $visible     *     * @return void     */    public function __construct($name, $order, $collapsed, $visible)    {        $this->name = $name;        $this->order = (int) $order;        $this->collapsed = $collapsed;        $this->visible = (int) $visible;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_CreateComponentGroupCommand_1168, Create a add component group command instance.\n\n @param string $name\n @param int    $order\n @param int    $collapsed\n @param int    $visible\n\n @return void\n, Kreira instancu komande za dodavanje komponente grupe.,"    public function __construct($name, $order, $collapsed, $visible)    {        $this->name = $name;        $this->order = (int) $order;        $this->collapsed = $collapsed;        $this->visible = (int) $visible;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_GeneralTest_1217, This is the general test class.\n\n @author James Brooks <james@alt-three.com>\n @author Graham Campbell <graham@alt-three.com>\n, Ovo je uopötena testna klasa. ,"class GeneralTest extends AbstractApiTestCase{    public function test_can_ping()    {        $response = $this->json('GET', '/api/v1/ping');        $response->assertStatus(200);        $response->assertHeader('Content-Type', 'application/json');        $response->assertJsonFragment(['data' => 'Pong!']);    }    public function test_see_error_page_for_unknown_endpoint()    {        $response = $this->json('GET', '/api/v1/not-found');        $response->assertStatus(404);        $response->assertHeader('Content-Type', 'application/json');    }    public function test_non_acceptable_content_type()    {        $response = $this->json('GET', '/api/v1/ping', [], ['HTTP_Accept' => 'text/html']);        $response->assertStatus(406);    }    public function test_can_get_system_status()    {        $response = $this->json('GET', '/api/v1/status');        $response->assertStatus(200)                 ->assertHeader('Cache-Control')                 ->assertJsonFragment([                     'data' => [                         'status'  => 'success',                         'message' => 'System operational',                     ],                 ]);    }    public function test_can_get_system_status_not_success()    {        factory(Component::class)->create([            'status' => 3,        ]);        $response = $this->json('GET', '/api/v1/status');        $response->assertStatus(200)                 ->assertHeader('Cache-Control')                 ->assertJsonFragment([                     'data' => [                         'status'  => 'info',                         'message' => 'The system is experiencing issues',                     ],                 ]);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_RemoveComponentGroupCommand_1169, Create a new remove component group command instance.\n\n @param \\CachetHQ\\Cachet\\Models\\ComponentGroup $group\n\n @return void\n, Kreiranje nove instance komande za uklanjanje komponente grupe.,    public function __construct(ComponentGroup $group)    {        $this->group = $group;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_RemoveIncidentCommand_1173, Create a new remove incident command instance.\n\n @param \\CachetHQ\\Cachet\\Models\\Incident $incident\n\n @return void\n, Kreiranje nove instance komande za uklanjanje incidenta.,    public function __construct(Incident $incident)    {        $this->incident = $incident;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_TestListener_1200, This is the test listener class.\n\n @author Connor S. Parks <connor@connorvg.tv>\n, Ovo je klasa za testni osluökiva?.,"class TestListener implements PHPUnitTestListener{    /**     * An error occurred.     */    public function addError(Test $test, \Throwable $t, float $time): void    {        //    }    /**     * A warning occurred.     */    public function addWarning(Test $test, Warning $e, float $time): void    {        //    }    /**     * A failure occurred.     */    public function addFailure(Test $test, AssertionFailedError $e, float $time): void    {        //    }    /**     * Incomplete test.     */    public function addIncompleteTest(Test $test, \Throwable $t, float $time): void    {        //    }    /**     * Risky test.     */    public function addRiskyTest(Test $test, \Throwable $t, float $time): void    {        //    }    /**     * Skipped test.     */    public function addSkippedTest(Test $test, \Throwable $t, float $time): void    {        //    }    /**     * A test suite started.     */    public function startTestSuite(TestSuite $suite): void    {        //    }    /**     * A test suite ended.     */    public function endTestSuite(TestSuite $suite): void    {        if ($suite->getName() !== 'Cachet Test Suite') {            return;        }        foreach (glob(__DIR__.'/../bootstrap/cache{,t}/*.php', GLOB_BRACE) as $file) {            unlink($file);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_TestListener_1210, A test ended.\n, Test se zavröio.,"    public function endTest(Test $test, float $time): void    {        //    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_UpdateComponentGroupCommand_1170, This is the update component group command.\n\n @author James Brooks <james@alt-three.com>\n, Ovo je komanda za aûuriranje komponente grupe. ,"final class UpdateComponentGroupCommand{    /**     * The component group.     *     * @var \CachetHQ\Cachet\Models\ComponentGroup     */    public $group;    /**     * The component group name.     *     * @var string     */    public $name;    /**     * The component group description.     *     * @var int     */    public $order;    /**     * Is the component group collapsed?     *     * @var int     */    public $collapsed;    /**     * Is the component visible to public?     *     * @var int     */    public $visible;    /**     * The validation rules.     *     * @var string[]     */    public $rules = [        'name'      => 'nullable|string',        'order'     => 'nullable|int',        'collapsed' => 'nullable|int|between:0,4',        'visible'   => 'nullable|bool',    ];    /**     * Create a add component group command instance.     *     * @param \CachetHQ\Cachet\Models\ComponentGroup $group     * @param string                                 $name     * @param int                                    $order     * @param int                                    $collapsed     * @param int                                    $visible     *     * @return void     */    public function __construct(ComponentGroup $group, $name, $order, $collapsed, $visible)    {        $this->group = $group;        $this->name = $name;        $this->order = (int) $order;        $this->collapsed = $collapsed;        $this->visible = (int) $visible;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CachetHQ_Cachet_app_1175, Packages Service Providers...\n, Paketi dobavlja?a usluga...,"        env('APP_DEBUG') ? Bugsnag\BugsnagLaravel\BugsnagServiceProvider::class : null,",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_6394," Each concrete command is built with different receivers.\n There can be one, many or completely no receivers, but there can be other commands in the parameters.\n", Svaka konkretna komanda se pravi sa razli?itim prijemnicima. ,    public function __construct(private Receiver $output)    {    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_6668, Execute and make receiver to enable displaying messages date.\n, Izvröava i pravi prijemnika da se omogu?i prikaz datuma poruka.,"    public function execute()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->enableDate();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_7042, Undo the command and make receiver to disable displaying messages date.\n, Poniötite komandu i podesite prijemnik da onemoguc?i prikazivanje datuma poruka.,"    public function undo()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->disableDate();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Command_6670," this is the most important method in the Command pattern,\n The Receiver goes in the constructor.\n"," ovo je najbitnija metoda u komandnom öablonu,",    public function execute();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_EBookAdapter_6415," This is the adapter here. Notice it implements Book,\n therefore you don't have to change the code of the client which is using a Book\n","Ovo ovde je adapter. Primetiti da impementira Book,","class EBookAdapter implements Book{    public function __construct(protected EBook $eBook)    {    }    /**     * This class makes the proper translation from one interface to another.     */    public function open()    {        $this->eBook->unlock();    }    public function turnPage()    {        $this->eBook->pressNext();    }    /**     * notice the adapted behavior here: EBook::getPage() will return two integers, but Book     * supports only a current page getter, so we adapt the behavior here     */    public function getPage(): int    {        return $this->eBook->getPage()[0];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Handler_7422, This approach by using a template method pattern ensures you that\n each subclass will not forget to call the successor\n, Ovaj pristup koriö?enjem öablona metode öablona omogu?ava da ,    final public function handle(RequestInterface $request): ?string    {        $processed = $this->processing($request);        if ($processed === null && $this->successor !== null) {            // the request has not been processed by this handler => see the next            $processed = $this->successor->handle($request);        }        return $processed;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_HelloCommand_6400," execute and output ""Hello World"".\n"," izvröava i ispisuje ""Hello World"".","    public function execute()    {        // sometimes, there is no receiver and this is the command which does all the work        $this->output->write('Hello World');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_HelloCommand_6671," This concrete command calls ""print"" on the Receiver, but an external\n invoker just knows that it can call ""execute""\n"," Ova konkretna komanda poziva ""print"" na prijemniku, ali eksterni","class HelloCommand implements Command{    /**     * Each concrete command is built with different receivers.     * There can be one, many or completely no receivers, but there can be other commands in the parameters     */    public function __construct(private Receiver $output)    {    }    /**     * execute and output ""Hello World"".     */    public function execute()    {        // sometimes, there is no receiver and this is the command which does all the work        $this->output->write('Hello World');    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Invoker_6401, Invoker is using the command given to it.\n Example : an Application in SF2.\n, Priziva? koristi komandu koja mu je data. ,"class Invoker{    private Command $command;    /**     * in the invoker we find this kind of method for subscribing the command     * There can be also a stack, a list, a fixed set ...     */    public function setCommand(Command $cmd)    {        $this->command = $cmd;    }    /**     * executes the command; the invoker is the same whatever is the command     */    public function run()    {        $this->command->execute();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Invoker_8351, executes the command; the invoker is the same whatever is the command\n, izvröava komandu; priziva? je isti koja god da je komanda u pitanju,    public function run()    {        $this->command->execute();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Kindle_6691," this is the adapted class. In production code, this could be a class from another package, some vendor code.\n Notice that it uses another naming scheme and the implementation does something similar but in another way\n"," ovo je adaptirana klasa. U produkciji, ovo bi mogla da bude klasa iz drugog  paketa, neki kod proizvo?a?a","class Kindle implements EBook{    private int $page = 1;    private int $totalPages = 100;    public function pressNext()    {        $this->page++;    }    public function unlock()    {    }    /**     * returns current page and total number of pages, like [10, 100] is page 10 of 100     *     * @return int[]     */    public function getPage(): array    {        return [$this->page, $this->totalPages];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_PostId_8359, This is a perfect example of a value object that is identifiable by it's value alone and\n is guaranteed to be valid each time an instance is created. Another important property of value objects\n is immutability.\n\n Notice also the use of a named constructor (fromInt) which adds a little context when creating an instance.\n," Ovo je savröen primer vrednosti objekta koji je mogu?e identifikovati samo po vrednosti i\n garantovano je da ?e da bude validno svaki put kada je instanca kreirana. Joö jedno bitno svojstvo vrednosti objekta je nepromenljivost. Primetiti tako?e, da se koristi imenovani konstruktor (fromInt) koji dodaje malo konteksta kada se kreira instanca. ",class PostId{    public static function fromInt(int $id): PostId    {        self::ensureIsValid($id);        return new self($id);    }    private function __construct(private int $id)    {    }    public function toInt(): int    {        return $this->id;    }    private static function ensureIsValid(int $id)    {        if ($id <= 0) {            throw new InvalidArgumentException('Invalid PostId given');        }    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_PostStatus_6412," Like PostId, this is a value object which holds the value of the current status of a Post. It can be constructed\n either from a string or int and is able to validate itself. An instance can then be converted back to int or string.\n"," Kao i PostId, ovo je vrednosni objekat koji ?uva vrednost trenutnog statusa Post. Moûe se konstruisati","class PostStatus{    const STATE_DRAFT_ID = 1;    const STATE_PUBLISHED_ID = 2;    const STATE_DRAFT = 'draft';    const STATE_PUBLISHED = 'published';    private static array $validStates = [        self::STATE_DRAFT_ID => self::STATE_DRAFT,        self::STATE_PUBLISHED_ID => self::STATE_PUBLISHED,    ];    public static function fromInt(int $statusId)    {        self::ensureIsValidId($statusId);        return new self($statusId, self::$validStates[$statusId]);    }    public static function fromString(string $status)    {        self::ensureIsValidName($status);        $state = array_search($status, self::$validStates);        if ($state === false) {            throw new InvalidArgumentException('Invalid state given!');        }        return new self($state, $status);    }    private function __construct(private int $id, private string $name)    {    }    public function toInt(): int    {        return $this->id;    }    /**     * there is a reason that I avoid using __toString() as it operates outside of the stack in PHP     * and is therefor not able to operate well with exceptions     */    public function toString(): string    {        return $this->name;    }    private static function ensureIsValidId(int $status)    {        if (!in_array($status, array_keys(self::$validStates), true)) {            throw new InvalidArgumentException('Invalid status id given');        }    }    private static function ensureIsValidName(string $status)    {        if (!in_array($status, self::$validStates, true)) {            throw new InvalidArgumentException('Invalid status name given');        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_PostStatus_6413, there is a reason that I avoid using __toString() as it operates outside of the stack in PHP\n and is therefor not able to operate well with exceptions\n, postoji razlog zbog kojeg sam izbegavao da koristim __toString() poöto radi izvan steka u PHP,    public function toString(): string    {        return $this->name;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Receiver_7436, Disable receiver to display message date\n, Onemogu?iti prijemnik da prikazuje poruke o datumu,    public function disableDate()    {        $this->enableDate = false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractLinesBeforeNamespaceFixer_6880, Make sure # of line breaks prefixing namespace is within given range.\n\n @param int $expectedMin min. # of line breaks\n @param int $expectedMax max. # of line breaks\n, Osigurati da je broj preloma prefiksa imena prostora unutar zadatog opsega. ,"    protected function fixLinesBeforeNamespace(Tokens $tokens, int $index, int $expectedMin, int $expectedMax): void    {        // Let's determine the total numbers of new lines before the namespace        // and the opening token        $openingTokenIndex = null;        $precedingNewlines = 0;        $newlineInOpening = false;        $openingToken = null;        for ($i = 1; $i <= 2; ++$i) {            if (isset($tokens[$index - $i])) {                $token = $tokens[$index - $i];                if ($token->isGivenKind(T_OPEN_TAG)) {                    $openingToken = $token;                    $openingTokenIndex = $index - $i;                    $newlineInOpening = false !== strpos($token->getContent(), ""\n"");                    if ($newlineInOpening) {                        ++$precedingNewlines;                    }                    break;                }                if (false === $token->isGivenKind(T_WHITESPACE)) {                    break;                }                $precedingNewlines += substr_count($token->getContent(), ""\n"");            }        }        if ($precedingNewlines >= $expectedMin && $precedingNewlines <= $expectedMax) {            return;        }        $previousIndex = $index - 1;        $previous = $tokens[$previousIndex];        if (0 === $expectedMax) {            // Remove all the previous new lines            if ($previous->isWhitespace()) {                $tokens->clearAt($previousIndex);            }            // Remove new lines in opening token            if ($newlineInOpening) {                $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, rtrim($openingToken->getContent()).' ']);            }            return;        }        $lineEnding = $this->whitespacesConfig->getLineEnding();        $newlinesForWhitespaceToken = $expectedMax;        if (null !== $openingToken) {            // Use the configured line ending for the PHP opening tag            $content = rtrim($openingToken->getContent());            $newContent = $content.$lineEnding;            $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, $newContent]);            --$newlinesForWhitespaceToken;        }        if (0 === $newlinesForWhitespaceToken) {            // We have all the needed new lines in the opening tag            if ($previous->isWhitespace()) {                // Let's remove the previous token containing extra new lines                $tokens->clearAt($previousIndex);            }            return;        }        if ($previous->isWhitespace()) {            // Fix the previous whitespace token            $tokens[$previousIndex] = new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken).substr($previous->getContent(), strrpos($previous->getContent(), ""\n"") + 1)]);        } else {            // Add a new whitespace token            $tokens->insertAt($index, new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken)]));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractNoUselessElseFixer_6885," For internal use only, as it is not perfect.\n\n Returns if the token at given index is part of a if/elseif/else statement\n without {}. Assumes not passing the last `;`/close tag of the statement, not\n out of range index, etc.\n\n @param int $index Index of the token to check\n"," Samo za unutraönju upotrebu, jer nije savröena.","    private function isInConditionWithoutBraces(Tokens $tokens, int $index, int $lowerLimitIndex): bool    {        do {            if ($tokens[$index]->isComment() || $tokens[$index]->isWhitespace()) {                $index = $tokens->getPrevMeaningfulToken($index);            }            $token = $tokens[$index];            if ($token->isGivenKind([T_IF, T_ELSEIF, T_ELSE])) {                return true;            }            if ($token->equals(';')) {                return false;            }            if ($token->equals('{')) {                $index = $tokens->getPrevMeaningfulToken($index);                // OK if belongs to: for, do, while, foreach                // Not OK if belongs to: if, else, elseif                if ($tokens[$index]->isGivenKind(T_DO)) {                    --$index;                    continue;                }                if (!$tokens[$index]->equals(')')) {                    return false; // like `else {`                }                $index = $tokens->findBlockStart(                    Tokens::BLOCK_TYPE_PARENTHESIS_BRACE,                    $index                );                $index = $tokens->getPrevMeaningfulToken($index);                if ($tokens[$index]->isGivenKind([T_IF, T_ELSEIF])) {                    return false;                }            } elseif ($token->equals(')')) {                $type = Tokens::detectBlockType($token);                $index = $tokens->findBlockStart(                    $type['type'],                    $index                );                $index = $tokens->getPrevMeaningfulToken($index);            } else {                --$index;            }        } while ($index > $lowerLimitIndex);        return false;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_6619, This abstract fixer provides a base for fixers to fix types in PHPDoc.\n\n @author Graham Campbell <graham@alt-three.com>\n\n @internal\n, Ovaj apstraktni popravlja? pruûa osnovu popravlja?ima za popravljanje tipovi u PHPdoc.,"abstract class AbstractPhpdocTypesFixer extends AbstractFixer{    /**     * The annotation tags search inside.     *     * @var string[]     */    protected $tags;    /**     * {@inheritdoc}     */    public function __construct()    {        parent::__construct();        $this->tags = Annotation::getTagsWithTypes();    }    /**     * {@inheritdoc}     */    public function isCandidate(Tokens $tokens): bool    {        return $tokens->isTokenKindFound(T_DOC_COMMENT);    }    /**     * {@inheritdoc}     */    protected function applyFix(\SplFileInfo $file, Tokens $tokens): void    {        foreach ($tokens as $index => $token) {            if (!$token->isGivenKind(T_DOC_COMMENT)) {                continue;            }            $doc = new DocBlock($token->getContent());            $annotations = $doc->getAnnotationsOfType($this->tags);            if (empty($annotations)) {                continue;            }            foreach ($annotations as $annotation) {                $this->fixTypes($annotation);            }            $tokens[$index] = new Token([T_DOC_COMMENT, $doc->getContent()]);        }    }    /**     * Actually normalize the given type.     */    abstract protected function normalize(string $type): string;    /**     * Fix the types at the given line.     *     * We must be super careful not to modify parts of words.     *     * This will be nicely handled behind the scenes for us by the annotation class.     */    private function fixTypes(Annotation $annotation): void    {        $types = $annotation->getTypes();        $new = $this->normalizeTypes($types);        if ($types !== $new) {            $annotation->setTypes($new);        }    }    /**     * @param string[] $types     *     * @return string[]     */    private function normalizeTypes(array $types): array    {        foreach ($types as $index => $type) {            $types[$index] = $this->normalizeType($type);        }        return $types;    }    /**     * Prepare the type and normalize it.     */    private function normalizeType(string $type): string    {        if ('[]' === substr($type, -2)) {            return $this->normalizeType(substr($type, 0, -2)).'[]';        }        return $this->normalize($type);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_8571, Actually normalize the given type.\n, Zapravo normalizuju dati tip.,    abstract protected function normalize(string $type): string;,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_8572, Fix the types at the given line.\n\n We must be super careful not to modify parts of words.\n\n This will be nicely handled behind the scenes for us by the annotation class.\n, Popravlja tipove na datoj liniji.,    private function fixTypes(Annotation $annotation): void    {        $types = $annotation->getTypes();        $new = $this->normalizeTypes($types);        if ($types !== $new) {            $annotation->setTypes($new);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_8574, Prepare the type and normalize it.\n, Priprema tip i normlizuje ga.,"    private function normalizeType(string $type): string    {        if ('[]' === substr($type, -2)) {            return $this->normalizeType(substr($type, 0, -2)).'[]';        }        return $this->normalize($type);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_413, Parses given value as color\n\n @param  mixed $value\n @return \\Intervention\\Image\\AbstractColor\n, Parsira datu vrednost kao boju,"    public function parse($value)    {        switch (true) {            case is_string($value):                $this->initFromString($value);                break;            case is_int($value):                $this->initFromInteger($value);                break;            case is_array($value):                $this->initFromArray($value);                break;            case is_object($value):                $this->initFromObject($value);                break;            case is_null($value):                $this->initFromArray([255, 255, 255, 0]);                break;            default:                throw new NotReadableException(                    ""Color format ({$value}) cannot be read.""                );        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_414, Formats current color instance into given format\\\\n\\\\n @param  string $type\\\\n @return mixed\\\\n, Formatira datu instancu boje u dati format,"    public function format($type)    {        switch (strtolower($type)) {            case 'rgba':                return $this->getRgba();            case 'hex':                return $this->getHex('#');            case 'int':            case 'integer':                return $this->getInt();            case 'array':                return $this->getArray();            case 'obj':            case 'object':                return $this;            default:                throw new NotSupportedException(                    ""Color format ({$type}) is not supported.""                );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_415, Reads RGBA values from string into array\n\n @param  string $value\n @return array\n, ?ita RGBA vrednost iz stringa u niz.,"    protected function rgbaFromString($value)    {        $result = false;        // parse color string in hexidecimal format like #cccccc or cccccc or ccc        $hexPattern = '/^#?([a-f0-9]{1,2})([a-f0-9]{1,2})([a-f0-9]{1,2})$/i';        // parse color string in format rgb(140, 140, 140)        $rgbPattern = '/^rgb ?\(([0-9]{1,3}), ?([0-9]{1,3}), ?([0-9]{1,3})\)$/i';        // parse color string in format rgba(255, 0, 0, 0.5)        $rgbaPattern = '/^rgba ?\(([0-9]{1,3}), ?([0-9]{1,3}), ?([0-9]{1,3}), ?([0-9.]{1,4})\)$/i';        if (preg_match($hexPattern, $value, $matches)) {            $result = [];            $result[0] = strlen($matches[1]) == '1' ? hexdec($matches[1].$matches[1]) : hexdec($matches[1]);            $result[1] = strlen($matches[2]) == '1' ? hexdec($matches[2].$matches[2]) : hexdec($matches[2]);            $result[2] = strlen($matches[3]) == '1' ? hexdec($matches[3].$matches[3]) : hexdec($matches[3]);            $result[3] = 1;        } elseif (preg_match($rgbPattern, $value, $matches)) {            $result = [];            $result[0] = ($matches[1] >= 0 && $matches[1] <= 255) ? intval($matches[1]) : 0;            $result[1] = ($matches[2] >= 0 && $matches[2] <= 255) ? intval($matches[2]) : 0;            $result[2] = ($matches[3] >= 0 && $matches[3] <= 255) ? intval($matches[3]) : 0;            $result[3] = 1;        } elseif (preg_match($rgbaPattern, $value, $matches)) {            $result = [];            $result[0] = ($matches[1] >= 0 && $matches[1] <= 255) ? intval($matches[1]) : 0;            $result[1] = ($matches[2] >= 0 && $matches[2] <= 255) ? intval($matches[2]) : 0;            $result[2] = ($matches[3] >= 0 && $matches[3] <= 255) ? intval($matches[3]) : 0;            $result[3] = ($matches[4] >= 0 && $matches[4] <= 1) ? $matches[4] : 0;        } else {            throw new NotReadableException(                ""Unable to read color ({$value}).""            );        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractCommand_535, Executes current command on given image\n\n @param  \\Intervention\\Image\\Image $image\n @return mixed\n, Izvröava trenutnu komandu nad datom slikom,    abstract public function execute($image);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractCommand_536, Creates new command instance\\n\\n @param array $arguments\\n, Kreira novu instancu komande,    public function __construct($arguments)    {        $this->arguments = $arguments;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractCommand_537, Creates new argument instance from given argument key\\n\\n @param  int $key\\n @return \\\\Intervention\\\\Image\\\\Commands\\\\Argument\\n, Kreira novu instancu argumenta od datog klju?a,"    public function argument($key)    {        return new Argument($this, $key);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractCommand_540, Sets output data of current command\n\n @param mixed $value\n, Postavlja izlazne podatke trenutnne komande,    public function setOutput($value)    {        $this->output = $value;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_416, Initiates new image from path in filesystem\\n\\n @param  string $path\\n @return \\\\Intervention\\\\Image\\\\Image\\n, Inicira novu sliku sa putanjom u sistemu datoteka,    abstract public function initFromPath($path);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_417, Initiates new image from binary data\\\\n\\\\n @param  string $data\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n, Inicira novu sliku od binarnih podataka,    abstract public function initFromBinary($data);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_419, Initiates new image from Imagick object\n\n @param \\Imagick $object\n @return \\Intervention\\Image\\Image\n, Inicira novu sliku od Imagick objekta,    abstract public function initFromImagick(\Imagick $object);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_422, Determines if current source data is GD resource\\\\n\\\\n @return boolean\\\\n, Odlu?uje da li je trenutni izvor podataka GD izvor,    public function isGdResource()    {        if (is_resource($this->data)) {            return (get_resource_type($this->data) == 'gd');        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_423, Determines if current source data is Imagick object\n\n @return boolean\n, Odlu?uje da li je trenutni izvor podataka Imagick objekat,"    public function isImagick()    {        return is_a($this->data, 'Imagick');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_425, Determines if current data is SplFileInfo object\\n\\n @return boolean\\n, Odlu?uje da li je trenutni izvor podataka SplFileInfo objekat,"    public function isSplFileInfo()    {        return is_a($this->data, 'SplFileInfo');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_426, Determines if current data is Symfony UploadedFile component\n\n @return boolean\n,  Odlu?uje da li je trenutni izvor podataka Symfony UploadedFile komponenta,"    public function isSymfonyUpload()    {        return is_a($this->data, 'Symfony\Component\HttpFoundation\File\UploadedFile');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_427, Determines if current source data is file path\n\n @return boolean\n,  Odlu?uje da li je trenutni izvor podataka putanja do fajla,    public function isFilePath()    {        if (is_string($this->data)) {            try {                return is_file($this->data);            } catch (\Exception $e) {                return false;            }        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_430, Determines if current source data is binary data\n\n @return boolean\n,  Odlu?uje da li je trenutni izvor podataka binarni podatak,"    public function isBinary()    {        if (is_string($this->data)) {            $mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $this->data);            return (substr($mime, 0, 4) != 'text' && $mime != 'application/x-empty');        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_431, Determines if current source data is data-url\n\n @return boolean\n,   Odlu?uje da li je trenutni izvor podataka url,    public function isDataUrl()    {        $data = $this->decodeDataUrl($this->data);        return is_null($data) ? false : true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_432, Determines if current source data is base64 encoded\\n\\n @return boolean\\n,   Odlu?uje da li je trenutni izvor podataka base64 enkodiran ,"    public function isBase64()    {        if (!is_string($this->data)) {            return false;        }        return base64_encode(base64_decode($this->data)) === str_replace([""\n"", ""\r""], '', $this->data);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_433, Initiates new Image from Intervention\\\\Image\\\\Image\\n\\n @param  Image $object\\n @return \\\\Intervention\\\\Image\\\\Image\\n, Inicira novu sliku iz Intervention ,    public function initFromInterventionImage($object)    {        return $object;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_434, Parses and decodes binary image data from data-url\n\n @param  string $data_url\n @return string\n, Parsira i dekodira binarne podatke za sliku iz url ,"    private function decodeDataUrl($data_url)    {        if (!is_string($data_url)) {            return null;        }        $pattern = ""/^data:(?:image\/[a-zA-Z\-\.]+)(?:charset=\"".+\"")?;base64,(?P<data>.+)$/"";        preg_match($pattern, $data_url, $matches);        if (is_array($matches) && array_key_exists('data', $matches)) {            return base64_decode($matches['data']);        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_435, Initiates new image from mixed data\\\\n\\\\n @param  mixed $data\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n, Inicira novu sliku iz meöovitih podataka ,"    public function init($data)    {        $this->data = $data;        switch (true) {            case $this->isGdResource():                return $this->initFromGdResource($this->data);            case $this->isImagick():                return $this->initFromImagick($this->data);            case $this->isInterventionImage():                return $this->initFromInterventionImage($this->data);            case $this->isSplFileInfo():                return $this->initFromPath($this->data->getRealPath());            case $this->isBinary():                return $this->initFromBinary($this->data);            case $this->isUrl():                return $this->initFromUrl($this->data);            case $this->isStream():                return $this->initFromStream($this->data);            case $this->isDataUrl():                return $this->initFromBinary($this->decodeDataUrl($this->data));            case $this->isFilePath():                return $this->initFromPath($this->data);            // isBase64 has to be after isFilePath to prevent false positives            case $this->isBase64():                return $this->initFromBinary(base64_decode($this->data));            default:                throw new NotReadableException(""Image source not readable"");        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_438, Reads given string into color object\\\\n\\\\n @param  string $value\\\\n @return AbstractColor\\\\n, ?ita dati string kao objekat boju ,    abstract public function parseColor($value);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_444, Returns classname of given command name\\\\n\\\\n @param  string $name\\\\n @return string\\\\n, Vra?a ime klase za dato ime komande ,"    private function getCommandClassName($name)    {        $name = mb_convert_case($name[0], MB_CASE_UPPER, 'utf-8') . mb_substr($name, 1, mb_strlen($name));                $drivername = $this->getDriverName();        $classnameLocal = sprintf('\Intervention\Image\%s\Commands\%sCommand', $drivername, ucfirst($name));        $classnameGlobal = sprintf('\Intervention\Image\Commands\%sCommand', ucfirst($name));        if (class_exists($classnameLocal)) {            return $classnameLocal;        } elseif (class_exists($classnameGlobal)) {            return $classnameGlobal;        }        throw new NotSupportedException(            ""Command ({$name}) is not available for driver ({$drivername}).""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_445, Returns name of current driver instance\\n\\n @return string\\n, Vra?a naziv trenutne instance drajvera,"    public function getDriverName()    {        $reflect = new \ReflectionClass($this);        $namespace = $reflect->getNamespaceName();        return substr(strrchr($namespace, ""\\""), 1);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_447, Processes and returns encoded image as PNG string\\n\\n @return string\\n, Obra?uje i vra?a kodovanu sliku kao PNG string,    abstract protected function processPng();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_448, Processes and returns encoded image as GIF string\\\\n\\\\n @return string\\\\n, Procesira i vra?a kodovanu sliku kao GIF string,    abstract protected function processGif();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_449, Processes and returns encoded image as TIFF string\\\\n\\\\n @return string\\\\n, Procesira i vra?a kodovanu sliku kao TIFF string,    abstract protected function processTiff();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_450, Processes and returns encoded image as BMP string\\n\\n @return string\\n, Procesira i vra?a kodovanu sliku kao BMP string,    abstract protected function processBmp();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_451, Processes and returns encoded image as ICO string\n\n @return string\n, Procesira i vra?a kodovanu sliku kao ICO string,    abstract protected function processIco();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_453, Processes and returns encoded image as data-url string\\n\\n @return string\\n,  Procesira i vra?a kodovanu sliku kao url string,"    protected function processDataUrl()    {        $mime = $this->image->mime ? $this->image->mime : 'image/png';        return sprintf('data:%s;base64,%s',            $mime,            base64_encode($this->process($this->image, $mime, $this->quality))        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractEncoder_455, Determines output quality\n\n @param int $quality\n, Odre?uje kvalitet izlaza,    protected function setQuality($quality)    {        $quality = is_null($quality) ? 90 : $quality;        $quality = $quality === 0 ? 1 : $quality;        if ($quality < 0 || $quality > 100) {            throw new InvalidArgumentException(                'Quality must range from 0 to 100.'            );        }        $this->quality = intval($quality);        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractShape_474, Determines if current shape has border\\\\n\\\\n @return boolean\\\\n, Odre?uje da li trenutni oblik ima okvir,    public function hasBorder()    {        return ($this->border_width >= 1);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Argument_541, Returns name of current arguments command\n\n @return string\n, Vra?a naziv trenutne komande argumenta,"    public function getCommandName()    {        preg_match(""/\\\\([\w]+)Command$/"", get_class($this->command), $matches);        return isset($matches[1]) ? lcfirst($matches[1]).'()' : 'Method';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Argument_542, Defines current argument as required\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Commands\\\\\\\\Argument\\\\n, Definiöe trenutni argument kao potreban,"    public function required()    {        if ( ! array_key_exists($this->key, $this->command->arguments)) {            throw new InvalidArgumentException(                sprintf(""Missing argument %d for %s"", $this->key + 1, $this->getCommandName())            );        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Argument_544, Determines that current argument value must be numeric between given values\\n\\n @return \\\\Intervention\\\\Image\\\\Commands\\\\Argument\\n, Odre?uje da li trenutni vrednost argumenta mora biti numeri?ka izme?u datih vrednosti,"    public function between($x, $y)    {        $value = $this->type('numeric')->value();        if (is_null($value)) {            return $this;        }        $alpha = min($x, $y);        $omega = max($x, $y);        if ($value < $alpha || $value > $omega) {            throw new InvalidArgumentException(                sprintf('Argument %d must be between %s and %s.', $this->key, $x, $y)            );        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Argument_546, Determines that current argument must be under a maxiumum value\\n\\n @return \\\\Intervention\\\\Image\\\\Commands\\\\Argument\\n, Odre?uje da li trenutna vrednost argumenta mora biti ispod maksimalne vrednosti,"    public function max($value)    {        $v = $this->type('numeric')->value();        if (is_null($v)) {            return $this;        }        if ($v > $value) {            throw new InvalidArgumentException(                sprintf('Argument %d may not be greater than %s.', $this->key, $value)            );        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_BackupCommand_593, Saves a backups of current state of image core\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, ?uva rezervne kopije trenutnog stanja jezgra slike,"    public function execute($image)    {        $backupName = $this->argument(0)->value();        // clone current image resource        $clone = clone $image;        $image->setBackup($clone->getCore(), $backupName);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_BlurCommand_594, Applies blur effect on image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Primenjuje efekat zamu?enja slike,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(1);        for ($i=0; $i < intval($amount); $i++) {            imagefilter($image->getCore(), IMG_FILTER_GAUSSIAN_BLUR);        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ChecksumCommand_548, Calculates checksum of given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Ra?una kontolnu sumu za datu sliku,"    public function execute($image)    {        $colors = [];        $size = $image->getSize();        for ($x=0; $x <= ($size->width-1); $x++) {            for ($y=0; $y <= ($size->height-1); $y++) {                $colors[] = $image->pickColor($x, $y, 'array');            }        }        $this->setOutput(md5(serialize($colors)));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_CircleCommand_549, Draw a circle centered on given image\n\n @param  \\Intervention\\Image\\image $image\n @return boolean\n, Crta krug koji je centriran na datoj slici,"    public function execute($image)    {        $diameter = $this->argument(0)->type('numeric')->required()->value();        $x = $this->argument(1)->type('numeric')->required()->value();        $y = $this->argument(2)->type('numeric')->required()->value();        $callback = $this->argument(3)->type('closure')->value();        $circle_classname = sprintf('\Intervention\Image\%s\Shapes\CircleShape',            $image->getDriver()->getDriverName());        $circle = new $circle_classname($diameter);        if ($callback instanceof Closure) {            $callback($circle);        }        $circle->applyToImage($image, $x, $y);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_565, Initiates color object from given array\\n\\n @param  array $value\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n, Inicira objekat boje iz datog niza,"    public function initFromArray($array)    {        $array = array_values($array);        if (count($array) == 4) {            // color array with alpha value            list($r, $g, $b, $a) = $array;            $this->a = $this->alpha2gd($a);        } elseif (count($array) == 3) {            // color array without alpha value            list($r, $g, $b) = $array;            $this->a = 0;        }        $this->r = $r;        $this->g = $g;        $this->b = $b;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_568, Initiates color object from given ImagickPixel object\\\\n\\\\n @param  ImagickPixel $value\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n,Inicira objekat je na osnovu datog ImagickPixel objekta,"    public function initFromObject($value)    {        throw new NotSupportedException(            ""GD colors cannot init from ImagickPixel objects.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_569, Calculates integer value of current color instance\n\n @return int\n, Izra?unava celobrojnu vrednost trenutne instance boje,    public function getInt()    {        return ($this->a << 24) + ($this->r << 16) + ($this->g << 8) + $this->b;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_570, Calculates RGB(A) in array format of current color instance\\\\n\\\\n @return array\\\\n, Izra?unava RGB(A) u formatu niza trenutne instance boje,"    public function getArray()    {        return [$this->r, $this->g, $this->b, round(1 - $this->a / 127, 2)];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_571, Calculates RGBA in string format of current color instance\\\\n\\\\n @return string\\\\n, Izra?unava RGB(A) u formatu stringa trenutne instance boje,"    public function getRgba()    {        return sprintf('rgba(%d, %d, %d, %.2F)', $this->r, $this->g, $this->b, round(1 - $this->a / 127, 2));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_572, Convert rgba alpha (0-1) value to gd value (0-127)\\n\\n @param  float $input\\n @return int\\n, Konvertuje rgba alfa (0-1) vrednost u gd vrednost (0-127),    private function alpha2gd($input)    {        $oldMin = 0;        $oldMax = 1;        $newMin = 127;        $newMax = 0;        return ceil(((($input- $oldMin) * ($newMax - $newMin)) / ($oldMax - $oldMin)) + $newMin);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_627, Initiates color object from integer\\\\n\\\\n @param  int $value\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n, Inicira objekat boje na osnovu celog broja ,"    public function initFromInteger($value)    {        $a = ($value >> 24) & 0xFF;        $r = ($value >> 16) & 0xFF;        $g = ($value >> 8) & 0xFF;        $b = $value & 0xFF;        $a = $this->rgb2alpha($a);        $this->setPixel($r, $g, $b, $a);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_630, Initiates color object from given ImagickPixel object\\n\\n @param  ImagickPixel $value\\n\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n, Inicira objekat boje od datog ImagickPixel objekta,"    public function initFromObject($value)    {        if (is_a($value, '\ImagickPixel')) {            $this->pixel = $value;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_631," Initiates color object from given R, G and B values\\\\n\\\\n @param  int $r\\\\n @param  int $g\\\\n @param  int $b\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n"," Inicira objekat boje od datih R, G i B vrednosti","    public function initFromRgb($r, $g, $b)    {        $this->setPixel($r, $g, $b);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_632," Initiates color object from given R, G, B and A values\\\\n\\\\n @param  int     $r\\\\n @param  int     $g\\\\n @param  int     $b\\\\n @param  float   $a\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n","Inicira objekat boje od datih R, G, B i A vrednosti","    public function initFromRgba($r, $g, $b, $a)    {        $this->setPixel($r, $g, $b, $a);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_633, Calculates integer value of current color instance\\n\\n @return int\\n, Izra?unava celobrojnu vrednost trenutne instance boje,    public function getInt()    {        $r = $this->getRedValue();        $g = $this->getGreenValue();        $b = $this->getBlueValue();        $a = intval(round($this->getAlphaValue() * 255));        return intval(($a << 24) + ($r << 16) + ($g << 8) + $b);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_636, Returns RGB red value of current color\\\\n\\\\n @return int\\\\n, Vra?a RGB crvenu vrednost trenutne boje,    public function getRedValue()    {        return intval(round($this->pixel->getColorValue(\Imagick::COLOR_RED) * 255));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_639, Returns RGB alpha value of current color\\\\n\\\\n @return float\\\\n, Vra?a RGB alfa vrednost trenutne boje,"    public function getAlphaValue()    {        return round($this->pixel->getColorValue(\Imagick::COLOR_ALPHA), 2);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_641, Calculates RGA integer alpha value into float value\\n\\n @param  int $value\\n @return float\\n,Izra?unava RGA celobrojnu alfa vrednost kao vrednost sa pokretnim zarezom,"    private function rgb2alpha($value)    {        // (255 -> 1.0) / (0 -> 0.0)        return (float) round($value/255, 2);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ColorizeCommand_596, Changes balance of different RGB color channels\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Menja balans na razli?itim RGB kanalima boja,"    public function execute($image)    {        $red = $this->argument(0)->between(-100, 100)->required()->value();        $green = $this->argument(1)->between(-100, 100)->required()->value();        $blue = $this->argument(2)->between(-100, 100)->required()->value();        // normalize colorize levels        $red = round($red * 2.55);        $green = round($green * 2.55);        $blue = round($blue * 2.55);        // apply filter        return imagefilter($image->getCore(), IMG_FILTER_COLORIZE, $red, $green, $blue);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ColorizeCommand_660, Changes balance of different RGB color channels\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Menja balans na razli?itim RGB kanalima boja,"    public function execute($image)    {        $red = $this->argument(0)->between(-100, 100)->required()->value();        $green = $this->argument(1)->between(-100, 100)->required()->value();        $blue = $this->argument(2)->between(-100, 100)->required()->value();        // normalize colorize levels        $red = $this->normalizeLevel($red);        $green = $this->normalizeLevel($green);        $blue = $this->normalizeLevel($blue);        $qrange = $image->getCore()->getQuantumRange();        // apply        $image->getCore()->levelImage(0, $red, $qrange['quantumRangeLong'], \Imagick::CHANNEL_RED);        $image->getCore()->levelImage(0, $green, $qrange['quantumRangeLong'], \Imagick::CHANNEL_GREEN);        $image->getCore()->levelImage(0, $blue, $qrange['quantumRangeLong'], \Imagick::CHANNEL_BLUE);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Constraint_478, Checks if given argument is fixed in current constraint\\n\\n @param  int  $type\\n @return boolean\\n, Proverava da li je dati argument fiksan u trenutnom ograni?enju,    public function isFixed($type)    {        return (bool) ($this->fixed & (1 << $type));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ContrastCommand_597, Changes contrast of image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Menja kontrast slike,"    public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return imagefilter($image->getCore(), IMG_FILTER_CONTRAST, ($level * -1));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ContrastCommand_661, Changes contrast of image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Menja kontrast slike,"    public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return $image->getCore()->sigmoidalContrastImage($level > 0, $level / 4, 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_CropCommand_598, Crop an image instance\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Se?e instancu slike,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->required()->value();        $x = $this->argument(2)->type('digit')->value();        $y = $this->argument(3)->type('digit')->value();        if (is_null($width) || is_null($height)) {            throw new \Intervention\Image\Exception\InvalidArgumentException(                ""Width and height of cutout needs to be defined.""            );        }        $cropped = new Size($width, $height);        $position = new Point($x, $y);        // align boxes        if (is_null($x) && is_null($y)) {            $position = $image->getSize()->align('center')->relativePosition($cropped->align('center'));        }        // crop image core        return $this->modify($image, 0, 0, $position->x, $position->y, $cropped->width, $cropped->height, $cropped->width, $cropped->height);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_CropCommand_662, Crop an image instance\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Se?e instancu slike,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->required()->value();        $x = $this->argument(2)->type('digit')->value();        $y = $this->argument(3)->type('digit')->value();        if (is_null($width) || is_null($height)) {            throw new InvalidArgumentException(                ""Width and height of cutout needs to be defined.""            );        }        $cropped = new Size($width, $height);        $position = new Point($x, $y);        // align boxes        if (is_null($x) && is_null($y)) {            $position = $image->getSize()->align('center')->relativePosition($cropped->align('center'));        }        // crop image core        $image->getCore()->cropImage($cropped->width, $cropped->height, $position->x, $position->y);        $image->getCore()->setImagePage(0,0,0,0);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_574, Initiates new image from GD resource\\\\n\\\\n @param  Resource $resource\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Inicira novu sliku iz GD izvora,"    public function initFromGdResource($resource)    {        return new Image(new Driver, $resource);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_576, Initiates new image from binary data\\n\\n @param  string $data\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicira novu sliku iz binarnih podataka,"    public function initFromBinary($binary)    {        $resource = @imagecreatefromstring($binary);        if ($resource === false) {             throw new NotReadableException(                ""Unable to init from given binary data.""            );        }        $image = $this->initFromGdResource($resource);        $image->mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $binary);        return $image;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_576, Initiates new image from binary data\\\\n\\\\n @param  string $data\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Inicira novu sliku iz binarnih podataka,"    public function initFromBinary($binary)    {        $resource = @imagecreatefromstring($binary);        if ($resource === false) {             throw new NotReadableException(                ""Unable to init from given binary data.""            );        }        $image = $this->initFromGdResource($resource);        $image->mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $binary);        return $image;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_577, Transform GD resource into Truecolor version\\n\\n @param  resource $resource\\n @return bool\\n, Transformiöe GD izvor u Truecolor verziju,"    public function gdResourceToTruecolor(&$resource)    {        $width = imagesx($resource);        $height = imagesy($resource);        // new canvas        $canvas = imagecreatetruecolor($width, $height);        // fill with transparent color        imagealphablending($canvas, false);        $transparent = imagecolorallocatealpha($canvas, 255, 255, 255, 127);        imagefilledrectangle($canvas, 0, 0, $width, $height, $transparent);        imagecolortransparent($canvas, $transparent);        imagealphablending($canvas, true);        // copy original        imagecopy($canvas, $resource, 0, 0, 0, 0, $width, $height);        imagedestroy($resource);        $resource = $canvas;        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_643, Initiates new image from GD resource\n\n @param  Resource $resource\n @return \\Intervention\\Image\\Image\n,Inicira novu sliku iz GD izvora,    public function initFromGdResource($resource)    {        throw new NotSupportedException(            'Imagick driver is unable to init from GD resource.'        );    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_644, Initiates new image from Imagick object\\\\n\\\\n @param  Imagick $object\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n, Inicira novu sliku iz Imagick objekta,"    public function initFromImagick(\Imagick $object)    {        // currently animations are not supported        // so all images are turned into static        $object = $this->removeAnimation($object);        // reset image orientation        $object->setImageOrientation(\Imagick::ORIENTATION_UNDEFINED);        return new Image(new Driver, $object);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_645, Initiates new image from binary data\\n\\n @param  string $data\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicira novu sliku iz binarnih podataka,"    public function initFromBinary($binary)    {        $core = new \Imagick;        try {            $core->setBackgroundColor(new \ImagickPixel('transparent'));            $core->readImageBlob($binary);        } catch (\ImagickException $e) {            throw new NotReadableException(                ""Unable to read image from binary data."",                0,                $e            );        }        // build image        $image = $this->initFromImagick($core);        $image->mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $binary);        return $image;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Decoder_646, Turns object into one frame Imagick object\n by removing all frames except first\n\n @param  Imagick $object\n @return Imagick\n,Pretvara objekat u jedan frame Imagick objekta,    private function removeAnimation(\Imagick $object)    {        $imagick = new \Imagick;        foreach ($object as $frame) {            $imagick->addImage($frame->getImage());            break;        }        $object->destroy();        return $imagick;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_DemoFilter_562, Applies filter effects to given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Primenjuje efekat filtera na datu sliku,    public function applyFilter(Image $image)    {        $image->pixelate($this->size);        $image->greyscale();        return $image;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_DestroyCommand_599, Destroys current image core and frees up memory\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Uniötava jezgro trenutne slike i osloba?a memoriju,    public function execute($image)    {        // destroy image core        imagedestroy($image->getCore());        // destroy backups        foreach ($image->getBackups() as $backup) {            imagedestroy($backup);        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_DestroyCommand_663, Destroys current image core and frees up memory\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Uniötava jezgro trenutne slike i osloba?a memoriju,    public function execute($image)    {        // destroy image core        $image->getCore()->clear();        // destroy backups        foreach ($image->getBackups() as $backup) {            $backup->clear();        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Driver_578, Reads given string into color object\\n\\n @param  string $value\\n @return AbstractColor\\n, ?ita odre?eni string u objekat boje,    public function parseColor($value)    {        return new Color($value);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Driver_580, Returns clone of given core\\n\\n @return mixed\\n, Vra?a klona datog jezgra,"    public function cloneCore($core)    {        $width = imagesx($core);        $height = imagesy($core);        $clone = imagecreatetruecolor($width, $height);        imagealphablending($clone, false);        imagesavealpha($clone, true);        $transparency = imagecolorallocatealpha($clone, 0, 0, 0, 127);        imagefill($clone, 0, 0, $transparency);                imagecopy($clone, $core, 0, 0, 0, 0, $width, $height);        return $clone;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_582, Processes and returns encoded image as PNG string\n\n @return string\n, Obra?uje i vra?a kodovanu sliku kao PNG string,"    protected function processPng()    {        ob_start();        $resource = $this->image->getCore();        imagealphablending($resource, false);        imagesavealpha($resource, true);        imagepng($resource, null, -1);        $this->image->mime = image_type_to_mime_type(IMAGETYPE_PNG);        $buffer = ob_get_contents();        ob_end_clean();        return $buffer;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_584, Processes and returns encoded image as TIFF string\\n\\n @return string\\n, Procesira i vra?a kodovanu sliku kao TIFF string,"    protected function processTiff()    {        throw new NotSupportedException(            ""TIFF format is not supported by Gd Driver.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_585, Processes and returns encoded image as BMP string\n\n @return string\n, Procesira i vra?a kodovanu sliku kao BMP string,"    protected function processBmp()    {        throw new NotSupportedException(            ""BMP format is not supported by Gd Driver.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_586, Processes and returns encoded image as ICO string\\\\n\\\\n @return string\\\\n, Procesira i vra?a kodovanu sliku kao ICO string,"    protected function processIco()    {        throw new NotSupportedException(            ""ICO format is not supported by Gd Driver.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_650, Processes and returns encoded image as PNG string\\n\\n @return string\\n, Obra?uje i vra?a kodovanu sliku kao PNG string,    protected function processPng()    {        $format = 'png';        $compression = \Imagick::COMPRESSION_ZIP;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_651, Processes and returns encoded image as GIF string\\\\n\\\\n @return string\\\\n, Procesira i vra?a kodovanu sliku kao GIF string,    protected function processGif()    {        $format = 'gif';        $compression = \Imagick::COMPRESSION_LZW;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_652, Processes and returns encoded image as TIFF string\\\\n\\\\n @return string\\\\n, Procesira i vra?a kodovanu sliku kao TIFF string,    protected function processTiff()    {        $format = 'tiff';        $compression = \Imagick::COMPRESSION_UNDEFINED;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        $imagick->setCompressionQuality($this->quality);        $imagick->setImageCompressionQuality($this->quality);        return $imagick->getImagesBlob();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Encoder_653, Processes and returns encoded image as BMP string\n\n @return string\n, Procesira i vra?a kodovanu sliku kao BMP string,    protected function processBmp()    {        $format = 'bmp';        $compression = \Imagick::COMPRESSION_UNDEFINED;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ExifCommand_665, Read Exif data from the given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, ?ita Exif podatke iz date slike,"    public function execute($image)    {        if ($this->preferExtension && function_exists('exif_read_data')) {            return parent::execute($image);        }        $core = $image->getCore();        if ( ! method_exists($core, 'getImageProperties')) {            throw new NotSupportedException(                ""Reading Exif data is not supported by this PHP installation.""            );        }        $requestedKey = $this->argument(0)->value();        if ($requestedKey !== null) {            $this->setOutput($core->getImageProperty('exif:' . $requestedKey));            return true;        }        $exif = [];        $properties = $core->getImageProperties();        foreach ($properties as $key => $value) {            if (substr($key, 0, 5) !== 'exif:') {                continue;            }            $exif[substr($key, 5)] = $value;        }        $this->setOutput($exif);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_File_481, Sets all instance properties from given path\\n\\n @param string $path\\n, Postavlja sva svojstva instance na osnovu date putanja,"    public function setFileInfoFromPath($path)    {        $info = pathinfo($path);        $this->dirname = array_key_exists('dirname', $info) ? $info['dirname'] : null;        $this->basename = array_key_exists('basename', $info) ? $info['basename'] : null;        $this->extension = array_key_exists('extension', $info) ? $info['extension'] : null;        $this->filename = array_key_exists('filename', $info) ? $info['filename'] : null;        if (file_exists($path) && is_file($path)) {            $this->mime = finfo_file(finfo_open(FILEINFO_MIME_TYPE), $path);        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_File_482, Get file size\n \n @return mixed\n, Vra?a veli?inu fajla,    public function filesize()    {        $path = $this->basePath();        if (file_exists($path) && is_file($path)) {            return filesize($path);        }                return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_File_483, Get fully qualified path\n\n @return string\n, Vra?a poptpuno kvalifikovanu putanju,    public function basePath()    {        if ($this->dirname && $this->basename) {            return ($this->dirname .'/'. $this->basename);        }        return null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FillCommand_600, Fills image with color or pattern\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Popunjava sliku sa bojom ili obrascem,"    public function execute($image)    {        $filling = $this->argument(0)->value();        $x = $this->argument(1)->type('digit')->value();        $y = $this->argument(2)->type('digit')->value();        $width = $image->getWidth();        $height = $image->getHeight();        $resource = $image->getCore();        try {            // set image tile filling            $source = new Decoder;            $tile = $source->init($filling);            imagesettile($image->getCore(), $tile->getCore());            $filling = IMG_COLOR_TILED;        } catch (\Intervention\Image\Exception\NotReadableException $e) {            // set solid color filling            $color = new Color($filling);            $filling = $color->getInt();        }        imagealphablending($resource, true);        if (is_int($x) && is_int($y)) {            // resource should be visible through transparency            $base = $image->getDriver()->newImage($width, $height)->getCore();            imagecopy($base, $resource, 0, 0, 0, 0, $width, $height);            // floodfill if exact position is defined            imagefill($resource, $x, $y, $filling);            // copy filled original over base            imagecopy($base, $resource, 0, 0, 0, 0, $width, $height);            // set base as new resource-core            $image->setCore($base);            imagedestroy($resource);        } else {            // fill whole image otherwise            imagefilledrectangle($resource, 0, 0, $width - 1, $height - 1, $filling);        }        isset($tile) ? imagedestroy($tile->getCore()) : null;        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FillCommand_666, Fills image with color or pattern\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Popunjava sliku sa bojom ili obrascem,"    public function execute($image)    {        $filling = $this->argument(0)->value();        $x = $this->argument(1)->type('digit')->value();        $y = $this->argument(2)->type('digit')->value();        $imagick = $image->getCore();        try {            // set image filling            $source = new Decoder;            $filling = $source->init($filling);        } catch (NotReadableException $e) {            // set solid color filling            $filling = new Color($filling);        }        // flood fill if coordinates are set        if (is_int($x) && is_int($y)) {            // flood fill with texture            if ($filling instanceof Image) {                // create tile                $tile = clone $image->getCore();                // mask away color at position                $tile->transparentPaintImage($tile->getImagePixelColor($x, $y), 0, 0, false);                // create canvas                $canvas = clone $image->getCore();                // fill canvas with texture                $canvas = $canvas->textureImage($filling->getCore());                // merge canvas and tile                $canvas->compositeImage($tile, \Imagick::COMPOSITE_DEFAULT, 0, 0);                // replace image core                $image->setCore($canvas);            // flood fill with color            } elseif ($filling instanceof Color) {                // create canvas with filling                $canvas = new \Imagick;                $canvas->newImage($image->getWidth(), $image->getHeight(), $filling->getPixel(), 'png');                // create tile to put on top                $tile = clone $image->getCore();                // mask away color at pos.                $tile->transparentPaintImage($tile->getImagePixelColor($x, $y), 0, 0, false);                // save alpha channel of original image                $alpha = clone $image->getCore();                // merge original with canvas and tile                $image->getCore()->compositeImage($canvas, \Imagick::COMPOSITE_DEFAULT, 0, 0);                $image->getCore()->compositeImage($tile, \Imagick::COMPOSITE_DEFAULT, 0, 0);                // restore alpha channel of original image                $image->getCore()->compositeImage($alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);            }        } else {            if ($filling instanceof Image) {                // fill whole image with texture                $image->setCore($image->getCore()->textureImage($filling->getCore()));            } elseif ($filling instanceof Color) {                // fill whole image with color                $draw = new \ImagickDraw();                $draw->setFillColor($filling->getPixel());                $draw->rectangle(0, 0, $image->getWidth(), $image->getHeight());                $image->getCore()->drawImage($draw);            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FilterInterface_563, Applies filter to given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return \\\\Intervention\\\\Image\\\\Image\\n, Primenjuje filter na datu sliku,    public function applyFilter(Image $image);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FitCommand_667, Crops and resized an image at the same time\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Ise?e i promeni veli?inu slici u isto vreme,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->value($width);        $constraints = $this->argument(2)->type('closure')->value();        $position = $this->argument(3)->type('string')->value('center');        // calculate size        $cropped = $image->getSize()->fit(new Size($width, $height), $position);        $resized = clone $cropped;        $resized = $resized->resize($width, $height, $constraints);        // crop image        $image->getCore()->cropImage(            $cropped->width,            $cropped->height,            $cropped->pivot->x,            $cropped->pivot->y        );        // resize image        $image->getCore()->scaleImage($resized->getWidth(), $resized->getHeight());        $image->getCore()->setImagePage(0,0,0,0);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FlipCommand_602, Mirrors an image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Pravi sliku u ogledalu,"    public function execute($image)    {        $mode = $this->argument(0)->value('h');        $size = $image->getSize();        $dst = clone $size;        switch (strtolower($mode)) {            case 2:            case 'v':            case 'vert':            case 'vertical':                $size->pivot->y = $size->height - 1;                $size->height = $size->height * (-1);                break;            default:                $size->pivot->x = $size->width - 1;                $size->width = $size->width * (-1);                break;        }        return $this->modify($image, 0, 0, $size->pivot->x, $size->pivot->y, $dst->width, $dst->height, $size->width, $size->height);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FlipCommand_668, Mirrors an image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Pravi sliku u ogledalu,"    public function execute($image)    {        $mode = $this->argument(0)->value('h');        if (in_array(strtolower($mode), [2, 'v', 'vert', 'vertical'])) {            // flip vertical            return $image->getCore()->flipImage();        } else {            // flip horizontal            return $image->getCore()->flopImage();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_590, Get width of an internal font character\\\\n\\\\n @return int\\\\n, Vra?a öirinu unutraönjeg fonta karaktera,    private function getInternalFontWidth()    {        return $this->getInternalFont() + 4;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_591, Get height of an internal font character\n\n @return int\n,  Vra?a visinu unutraönjeg fonta karaktera,    private function getInternalFontHeight()    {        switch ($this->getInternalFont()) {            case 1:                return 8;            case 2:                return 14;            case 3:                return 14;            case 4:                return 16;            case 5:                return 16;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Font_592, Calculates bounding box of current font setting\\n\\n @return Array\\n, Ra?una okvir za ograni?enje trenutkih podeöavanja fonta,"    public function getBoxSize()    {        $box = [];        if ($this->hasApplicableFontFile()) {            // imagettfbbox() converts numeric entities to their respective            // character. Preserve any originally double encoded entities to be            // represented as is.            // eg: &amp;#160; will render &#160; rather than its character.            $this->text = preg_replace('/&(#(?:x[a-fA-F0-9]+|[0-9]+);)/', '&#38;\1', $this->text);            $this->text = mb_encode_numericentity($this->text, array(0x0080, 0xffff, 0, 0xffff), 'UTF-8');            // get bounding box with angle 0            $box = imagettfbbox($this->getPointSize(), 0, $this->file, $this->text);            // rotate points manually            if ($this->angle != 0) {                $angle = pi() * 2 - $this->angle * pi() * 2 / 360;                for ($i=0; $i<4; $i++) {                    $x = $box[$i * 2];                    $y = $box[$i * 2 + 1];                    $box[$i * 2] = cos($angle) * $x - sin($angle) * $y;                    $box[$i * 2 + 1] = sin($angle) * $x + cos($angle) * $y;                }            }            $box['width'] = intval(abs($box[4] - $box[0]));            $box['height'] = intval(abs($box[5] - $box[1]));        } else {            // get current internal font size            $width = $this->getInternalFontWidth();            $height = $this->getInternalFontHeight();            if (strlen($this->text) == 0) {                // no text -> no boxsize                $box['width'] = 0;                $box['height'] = 0;            } else {                // calculate boxsize                $box['width'] = strlen($this->text) * $width;                $box['height'] = $height;            }        }        return $box;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_GreyscaleCommand_605, Turns an image into a greyscale version\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Pretvara sliku u verziju sa sivim tonovima,"    public function execute($image)    {        return imagefilter($image->getCore(), IMG_FILTER_GRAYSCALE);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageManagerStatic_506, Get or create new ImageManager instance\\\\n\\\\n @return ImageManager\\\\n, Vra?a ili kreira novu instancu ImageManager,    public static function getManager()    {        return self::$manager ? self::$manager : new ImageManager;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageManagerStatic_507, Statically initiates an Image instance from different input types\n\n @param  mixed $data\n\n @return \\Intervention\\Image\\Image\n @throws \\Intervention\\Image\\Exception\\NotReadableException\n, Inicira instancu Image stati?no od razli?itih ulaznih tipova,    public static function make($data)    {        return self::getManager()->make($data);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageManager_503, Initiates an Image instance from different input types\\n\\n @param  mixed $data\\n\\n @return \\\\Intervention\\\\Image\\\\Image\\n, Inicira instancu Image od razli?itih ulaznih tipova,    public function make($data)    {        return $this->createDriver()->init($data);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageManager_504, Creates a driver instance according to config settings\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractDriver\\\\n,Kreira instancu drajvera u skladu sa config podeöavanjima ,"    private function createDriver()    {        if (is_string($this->config['driver'])) {            $drivername = ucfirst($this->config['driver']);            $driverclass = sprintf('Intervention\\Image\\%s\\Driver', $drivername);            if (class_exists($driverclass)) {                return new $driverclass;            }            throw new NotSupportedException(                ""Driver ({$drivername}) could not be instantiated.""            );        }        if ($this->config['driver'] instanceof AbstractDriver) {            return $this->config['driver'];        }        throw new NotSupportedException(            ""Unknown driver type.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageManager_505, Check if all requirements are available\\n\\n @return void\\n, Provera da li su svi zahtevi dostupni,"    private function checkRequirements()    {        if ( ! function_exists('finfo_buffer')) {            throw new MissingDependencyException(                ""PHP Fileinfo extension must be installed/enabled to use Intervention Image.""            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLaravel4_514, Register the service provider.\n\n @return void\n, Registruje provajdera usluga,"    public function register()    {        $app = $this->app;        $app['image'] = $app->share(function ($app) {            return new ImageManager($app['config']->get('image::config'));        });        $app->alias('image', 'Intervention\Image\ImageManager');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLaravelRecent_516, Bootstrap the application events.\\n\\n @return void\\n,Butstrapuje doga?aje aplikacije,    public function boot()    {        $this->publishes([            __DIR__.'/../../config/config.php' => config_path('image.php')        ]);        // setup intervention/imagecache if package is installed        $this->cacheIsInstalled() ? $this->bootstrapImageCache() : null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLaravelRecent_517, Register the service provider.\\n\\n @return void\\n, Registruje provajdera usluga,"    public function register()    {        $app = $this->app;        // merge default config        $this->mergeConfigFrom(            __DIR__.'/../../config/config.php',            'image'        );        // create image        $app->singleton('image', function ($app) {            return new ImageManager($this->getImageConfig($app));        });        $app->alias('image', 'Intervention\Image\ImageManager');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLaravelRecent_518, create image\n,kreira sliku,"        $app->singleton('image', function ($app) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLaravelRecent_519, Bootstrap imagecache\n\n @return void\n, Butstrapuje imagecache,"    protected function bootstrapImageCache()    {        $app = $this->app;        $config = __DIR__.'/../../../../imagecache/src/config/config.php';        $this->publishes([            $config => config_path('imagecache.php')        ]);        // merge default config        $this->mergeConfigFrom(            $config,            'imagecache'        );        // imagecache route        if (is_string(config('imagecache.route'))) {            $filename_pattern = '[ \w\\.\\/\\-\\@\(\)]+';            // route to access template applied image file            $app['router']->get(config('imagecache.route').'/{template}/{filename}', [                'uses' => 'Intervention\Image\ImageCacheController@getResponse',                'as' => 'imagecache'            ])->where(['filename' => $filename_pattern]);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLaravelRecent_520, Return image configuration as array\\n\\n @param  Application $app\\n @return array\\n,Vra?a podeöavanja slike u vidu niza,    private function getImageConfig($app)    {        $config = $app['config']->get('image');        if (is_null($config)) {            return [];        }        return $config;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLeague_521, Register the server provider.\n\n @return void\n, Register the server provider.,"    public function register()    {        $this->getContainer()->share('Intervention\Image\ImageManager', function () {            return new ImageManager($this->config);        });    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProviderLumen_522, Register the service provider.\n\n @return void\n, Registruje provajdera usluga,"    public function register()    {        $app = $this->app;        // merge default config        $this->mergeConfigFrom(          __DIR__.'/../../config/config.php',          'image'        );        // set configuration        $app->configure('image');        // create image        $app->singleton('image',function ($app) {            return new ImageManager($app['config']->get('image'));        });        $app->alias('image', 'Intervention\Image\ImageManager');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProvider_508, Create a new service provider instance.\\\\n\\\\n @param  \\\\\\\\Illuminate\\\\\\\\Contracts\\\\\\\\Foundation\\\\\\\\Application  $app\\\\n @return void\\\\n, Kreira novu instancu provajdera usluga,    public function __construct($app)    {        parent::__construct($app);        $this->provider = $this->getProvider();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ImageServiceProvider_510, Register the service provider.\n\n @return void\n, Registruje provajdera usluga,    public function register()    {        return $this->provider->register();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_485, Magic method to catch all image calls\\\\n usually any AbstractCommand\\\\n\\\\n @param  string $name\\\\n @param  Array  $arguments\\\\n @return mixed\\\\n, Magi?na metoda koja hvata sve pozive slika,"    public function __call($name, $arguments)    {        $command = $this->driver->executeCommand($this, $name, $arguments);        return $command->hasOutput() ? $command->getOutput() : $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_488, Sets current image driver\\n @param AbstractDriver $driver\\n,Postavlja trenutni drajver slike,    public function setDriver(AbstractDriver $driver)    {        $this->driver = $driver;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_492, Checks if named backup exists\n\n @param  string $name\n @return bool\n, Proverava da li imenovana sigurnosna kopija postoji,"    private function backupExists($name)    {        return array_key_exists($name, $this->backups);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_493, Checks if current image is already encoded\\\\n\\\\n @return boolean\\\\n,Proverava da li je trenuta slika ve? kodovana,    public function isEncoded()    {        return ! empty($this->encoded);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_496, Calculates current image width\\\\n\\\\n @return int\\\\n,Izra?unava öirinu trenutne slike ,    public function getWidth()    {        return $this->getSize()->width;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_497, Alias of getWidth()\n\n @return int\n, Pseudonim getWidth() metode,    public function width()    {        return $this->getWidth();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_498, Calculates current image height\n\n @return int\n,Izra?unava visinu trenutne slike ,    public function getHeight()    {        return $this->getSize()->height;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Image_502, Cloning an image\\\\n,Klonira sliku,    public function __clone()    {        $this->core = $this->driver->cloneCore($this->core);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_InsertCommand_673, Insert another image into given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Insertuje neku drugu sliku u datu sliku,"    public function execute($image)    {        $source = $this->argument(0)->required()->value();        $position = $this->argument(1)->type('string')->value();        $x = $this->argument(2)->type('digit')->value(0);        $y = $this->argument(3)->type('digit')->value(0);        // build watermark        $watermark = $image->getDriver()->init($source);        // define insertion point        $image_size = $image->getSize()->align($position, $x, $y);        $watermark_size = $watermark->getSize()->align($position);        $target = $image_size->relativePosition($watermark_size);        // insert image at position        return $image->getCore()->compositeImage($watermark->getCore(), \Imagick::COMPOSITE_DEFAULT, $target->x, $target->y);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_LineCommand_553, Draws line on given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Crta linije na datoj slici,"    public function execute($image)    {        $x1 = $this->argument(0)->type('numeric')->required()->value();        $y1 = $this->argument(1)->type('numeric')->required()->value();        $x2 = $this->argument(2)->type('numeric')->required()->value();        $y2 = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $line_classname = sprintf('\Intervention\Image\%s\Shapes\LineShape',            $image->getDriver()->getDriverName());        $line = new $line_classname($x2, $y2);        if ($callback instanceof Closure) {            $callback($line);        }        $line->applyToImage($image, $x1, $y1);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_LineShape_625, Set current line width in pixels\\n\\n @param  int $width\\n @return void\\n,Postavlja trenutnu öiinu linije u pikselima,"    public function width($width)    {        throw new \Intervention\Image\Exception\NotSupportedException(            ""Line width is not supported by GD driver.""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_LineShape_689, Set current line color\\n\\n @param  string $color\\n @return void\\n, Postavlja boju trenutne linije,    public function color($color)    {        $this->color = $color;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_LineShape_690, Set current line width in pixels\\n\\n @param  int $width\\n @return void\\n,Postavlja trenutnu öiinu linije u pikselima,    public function width($width)    {        $this->width = $width;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_MaskCommand_677, Applies an alpha mask to an image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Primenjuje alfa masku na sliku ,"    public function execute($image)    {        $mask_source = $this->argument(0)->value();        $mask_w_alpha = $this->argument(1)->type('bool')->value(false);        // get imagick        $imagick = $image->getCore();        // build mask image from source        $mask = $image->getDriver()->init($mask_source);        // resize mask to size of current image (if necessary)        $image_size = $image->getSize();        if ($mask->getSize() != $image_size) {            $mask->resize($image_size->width, $image_size->height);        }        $imagick->setImageMatte(true);        if ($mask_w_alpha) {            // just mask with alpha map            $imagick->compositeImage($mask->getCore(), \Imagick::COMPOSITE_DSTIN, 0, 0);        } else {            // get alpha channel of original as greyscale image            $original_alpha = clone $imagick;            $original_alpha->separateImageChannel(\Imagick::CHANNEL_ALPHA);            // use red channel from mask ask alpha            $mask_alpha = clone $mask->getCore();            $mask_alpha->compositeImage($mask->getCore(), \Imagick::COMPOSITE_DEFAULT, 0, 0);            // $mask_alpha->setImageAlphaChannel(\Imagick::ALPHACHANNEL_DEACTIVATE);            $mask_alpha->separateImageChannel(\Imagick::CHANNEL_ALL);            // combine both alphas from original and mask            $original_alpha->compositeImage($mask_alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);            // mask the image with the alpha combination            $imagick->compositeImage($original_alpha, \Imagick::COMPOSITE_DSTIN, 0, 0);        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PixelCommand_614, Draws one pixel to a given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Crta jedan piksel na datu sliku,"    public function execute($image)    {        $color = $this->argument(0)->required()->value();        $color = new Color($color);        $x = $this->argument(1)->type('digit')->required()->value();        $y = $this->argument(2)->type('digit')->required()->value();        return imagesetpixel($image->getCore(), $x, $y, $color->getInt());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PixelateCommand_681, Applies a pixelation effect to a given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Primenjuje efekat pikselacije na datu sliku,"    public function execute($image)    {        $size = $this->argument(0)->type('digit')->value(10);        $width = $image->getWidth();        $height = $image->getHeight();        $image->getCore()->scaleImage(max(1, ($width / $size)), max(1, ($height / $size)));        $image->getCore()->scaleImage($width, $height);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Point_524, Sets X coordinate\n\n @param int $x\n,Postavlja X koordinatu,    public function setX($x)    {        $this->x = intval($x);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PolygonCommand_555, Draw a polygon on given image\\n\\n @param  \\\\Intervention\\\\Image\\\\image $image\\n @return boolean\\n, Crta poligon na datu sliku,"    public function execute($image)    {        $points = $this->argument(0)->type('array')->required()->value();        $callback = $this->argument(1)->type('closure')->value();        $vertices_count = count($points);        // check if number if coordinates is even        if ($vertices_count % 2 !== 0) {            throw new InvalidArgumentException(                ""The number of given polygon vertices must be even.""            );        }        if ($vertices_count < 6) {            throw new InvalidArgumentException(                ""You must have at least 3 points in your array.""            );        }                $polygon_classname = sprintf('\Intervention\Image\%s\Shapes\PolygonShape',            $image->getDriver()->getDriverName());        $polygon = new $polygon_classname($points);                if ($callback instanceof Closure) {            $callback($polygon);        }        $polygon->applyToImage($image);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PolygonShape_626, Create new polygon instance\n\n @param array $points\n, Kreira novu instancu poligona,    public function __construct($points)    {        $this->points = $points;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PolygonShape_691, Create new polygon instance\\n\\n @param array $points\\n, Kreira novu instancu poligona,    public function __construct($points)    {        $this->points = $this->formatPoints($points);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_PsrResponseCommand_556," Builds PSR7 compatible response. May replace ""response"" command in\\\\n some future.\\\\n\\\\n Method will generate binary stream and put it inside PSR-7\\\\n ResponseInterface. Following code can be optimized using native php\\\\n streams and more ""clean"" streaming, however drivers has to be updated\\\\n first.\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n", Kreira odgovor koji je kompatibilan sa PSR7. Moûe zameniti komandu odgovora,"    public function execute($image)    {        $format = $this->argument(0)->value();        $quality = $this->argument(1)->between(0, 100)->value();        //Encoded property will be populated at this moment        $stream = $image->stream($format, $quality);        $mimetype = finfo_buffer(            finfo_open(FILEINFO_MIME_TYPE),            $image->getEncoded()        );        $this->setOutput(new Response(            200,            [                'Content-Type'   => $mimetype,                'Content-Length' => strlen($image->getEncoded())            ],            $stream        ));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_RectangleCommand_557, Draws rectangle on given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Crta pravougaonik na datu sliku,"    public function execute($image)    {        $x1 = $this->argument(0)->type('numeric')->required()->value();        $y1 = $this->argument(1)->type('numeric')->required()->value();        $x2 = $this->argument(2)->type('numeric')->required()->value();        $y2 = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $rectangle_classname = sprintf('\Intervention\Image\%s\Shapes\RectangleShape',            $image->getDriver()->getDriverName());        $rectangle = new $rectangle_classname($x1, $y1, $x2, $y2);        if ($callback instanceof Closure) {            $callback($rectangle);        }        $rectangle->applyToImage($image, $x1, $y1);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_RectangleCommand_557, Draws rectangle on given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Crta pravougaonik na datu sliku,"    public function execute($image)    {        $x1 = $this->argument(0)->type('numeric')->required()->value();        $y1 = $this->argument(1)->type('numeric')->required()->value();        $x2 = $this->argument(2)->type('numeric')->required()->value();        $y2 = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $rectangle_classname = sprintf('\Intervention\Image\%s\Shapes\RectangleShape',            $image->getDriver()->getDriverName());        $rectangle = new $rectangle_classname($x1, $y1, $x2, $y2);        if ($callback instanceof Closure) {            $callback($rectangle);        }        $rectangle->applyToImage($image, $x1, $y1);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ResetCommand_616, Resets given image to its backup state\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Resetuje zadatu sliku u stanje rezervne kopije,"    public function execute($image)    {        $backupName = $this->argument(0)->value();        if (is_resource($backup = $image->getBackup($backupName))) {            // destroy current resource            imagedestroy($image->getCore());            // clone backup            $backup = $image->getDriver()->cloneCore($backup);            // reset to new resource            $image->setCore($backup);            return true;        }        throw new RuntimeException(            ""Backup not available. Call backup() before reset().""        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ResizeCommand_618, Resizes image dimensions\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Menja dimenzije slike,"    public function execute($image)    {        $width = $this->argument(0)->value();        $height = $this->argument(1)->value();        $constraints = $this->argument(2)->type('closure')->value();        // resize box        $resized = $image->getSize()->resize($width, $height, $constraints);        // modify image        $this->modify($image, 0, 0, 0, 0, $resized->getWidth(), $resized->getHeight(), $image->getWidth(), $image->getHeight());        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_ResponseCommand_558, Builds HTTP response from given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Pravi HTTP odgovor od date slike,"    public function execute($image)    {        $format = $this->argument(0)->value();        $quality = $this->argument(1)->between(0, 100)->value();        $response = new Response($image, $format, $quality);        $this->setOutput($response->make());        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Response_527, Builds response according to settings\\n\\n @return mixed\\n, Pravi odgovor u sklau sa podeöavanjima,"    public function make()    {        $this->image->encode($this->format, $this->quality);        $data = $this->image->getEncoded();        $mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $data);        $length = strlen($data);        if (function_exists('app') && is_a($app = app(), 'Illuminate\Foundation\Application')) {            $response = IlluminateResponse::make($data);            $response->header('Content-Type', $mime);            $response->header('Content-Length', $length);        } elseif (class_exists('\Symfony\Component\HttpFoundation\Response')) {            $response = SymfonyResponse::create($data);            $response->headers->set('Content-Type', $mime);            $response->headers->set('Content-Length', $length);        } else {            header('Content-Type: ' . $mime);            header('Content-Length: ' . $length);            $response = $data;        }        return $response;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_RotateCommand_620, Rotates image counter clockwise\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Rotira sliku u smeru suprotnom od kazaljki na satu,"    public function execute($image)    {        $angle = $this->argument(0)->type('numeric')->required()->value();        $color = $this->argument(1)->value();        $color = new Color($color);        // restrict rotations beyond 360 degrees, since the end result is the same        $angle %= 360;        // rotate image        $image->setCore(imagerotate($image->getCore(), $angle, $color->getInt()));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_RotateCommand_685, Rotates image counter clockwise\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Rotira sliku u smeru suprotnom od kazaljki na satu,"    public function execute($image)    {        $angle = $this->argument(0)->type('numeric')->required()->value();        $color = $this->argument(1)->value();        $color = new Color($color);        // restrict rotations beyond 360 degrees, since the end result is the same        $angle %= 360;        // rotate image        $image->getCore()->rotateImage($color->getPixel(), ($angle * -1));        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_SharpenCommand_621, Sharpen image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Izoötrava sliku,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(10);        // build matrix        $min = $amount >= 10 ? $amount * -0.01 : 0;        $max = $amount * -0.025;        $abs = ((4 * $min + 4 * $max) * -1) + 1;        $div = 1;        $matrix = [            [$min, $max, $min],            [$max, $abs, $max],            [$min, $max, $min]        ];        // apply the matrix        return imageconvolution($image->getCore(), $matrix, $div, 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_SharpenCommand_686, Sharpen image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Izoötrava sliku,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(10);        return $image->getCore()->unsharpMaskImage(1, 1, $amount / 6.25, 0);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Size_529, Set current pivot point\n\n @param Point $point\n,Podeöavanje trenutne ta?ke okretanja,    public function setPivot(Point $point)    {        $this->pivot = $point;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Size_532, Calculate the current aspect ratio\n\n @return float\n,Izra?unava trenutni odnos öirine i visine,    public function getRatio()    {        return $this->width / $this->height;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Size_533, Calculate the relative position to another Size\\n based on the pivot point settings of both sizes.\\n\\n @param  Size   $size\\n @return \\\\Intervention\\\\Image\\\\Point\\n, Izra?unava relativnu poziciju u odnosu na drugi Size,"    public function relativePosition(Size $size)    {        $x = $this->pivot->x - $size->pivot->x;        $y = $this->pivot->y - $size->pivot->y;        return new Point($x, $y);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Size_534, Checks if given size fits into current size\n\n @param  Size   $size\n @return boolean\n, Proverava da li data veli?ina moûe da stane u trenutnu veli?inu,    public function fitsInto(Size $size)    {        return ($this->width <= $size->width) && ($this->height <= $size->height);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_TextCommand_560, Write text on given image\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Ispisuje tekst na datu sliku,"    public function execute($image)    {        $text = $this->argument(0)->required()->value();        $x = $this->argument(1)->type('numeric')->value(0);        $y = $this->argument(2)->type('numeric')->value(0);        $callback = $this->argument(3)->type('closure')->value();        $fontclassname = sprintf('\Intervention\Image\%s\Font',            $image->getDriver()->getDriverName());        $font = new $fontclassname($text);        if ($callback instanceof Closure) {            $callback($font);        }        $font->applyToImage($image, $x, $y);        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_TrimCommand_622, Trims away parts of an image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Se?e delove slike,"    public function execute($image)    {        $base = $this->argument(0)->type('string')->value();        $away = $this->argument(1)->value();        $tolerance = $this->argument(2)->type('numeric')->value(0);        $feather = $this->argument(3)->type('numeric')->value(0);        $width = $image->getWidth();        $height = $image->getHeight();        // default values        $checkTransparency = false;        // define borders to trim away        if (is_null($away)) {            $away = ['top', 'right', 'bottom', 'left'];        } elseif (is_string($away)) {            $away = [$away];        }        // lower border names        foreach ($away as $key => $value) {            $away[$key] = strtolower($value);        }        // define base color position        switch (strtolower($base)) {            case 'transparent':            case 'trans':                $checkTransparency = true;                $base_x = 0;                $base_y = 0;                break;            case 'bottom-right':            case 'right-bottom':                $base_x = $width - 1;                $base_y = $height - 1;                break;            default:            case 'top-left':            case 'left-top':                $base_x = 0;                $base_y = 0;                break;        }        // pick base color        if ($checkTransparency) {            $color = new Color; // color will only be used to compare alpha channel        } else {            $color = $image->pickColor($base_x, $base_y, 'object');        }        $top_x = 0;        $top_y = 0;        $bottom_x = $width;        $bottom_y = $height;        // search upper part of image for colors to trim away        if (in_array('top', $away)) {            for ($y=0; $y < ceil($height/2); $y++) {                for ($x=0; $x < $width; $x++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $top_y = max(0, $y - $feather);                        break 2;                    }                }            }        }        // search left part of image for colors to trim away        if (in_array('left', $away)) {            for ($x=0; $x < ceil($width/2); $x++) {                for ($y=$top_y; $y < $height; $y++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $top_x = max(0, $x - $feather);                        break 2;                    }                }            }        }        // search lower part of image for colors to trim away        if (in_array('bottom', $away)) {            for ($y=($height-1); $y >= floor($height/2)-1; $y--) {                for ($x=$top_x; $x < $width; $x++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $bottom_y = min($height, $y+1 + $feather);                        break 2;                    }                }            }        }        // search right part of image for colors to trim away        if (in_array('right', $away)) {            for ($x=($width-1); $x >= floor($width/2)-1; $x--) {                for ($y=$top_y; $y < $bottom_y; $y++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $bottom_x = min($width, $x+1 + $feather);                        break 2;                    }                }            }        }        // trim parts of image        return $this->modify($image, 0, 0, $top_x, $top_y, ($bottom_x-$top_x), ($bottom_y-$top_y), ($bottom_x-$top_x), ($bottom_y-$top_y));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_TrimCommand_687, Trims away parts of an image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Se?e delove slike,"    public function execute($image)    {        $base = $this->argument(0)->type('string')->value();        $away = $this->argument(1)->value();        $tolerance = $this->argument(2)->type('numeric')->value(0);        $feather = $this->argument(3)->type('numeric')->value(0);        $width = $image->getWidth();        $height = $image->getHeight();        $checkTransparency = false;        // define borders to trim away        if (is_null($away)) {            $away = ['top', 'right', 'bottom', 'left'];        } elseif (is_string($away)) {            $away = [$away];        }        // lower border names        foreach ($away as $key => $value) {            $away[$key] = strtolower($value);        }        // define base color position        switch (strtolower($base)) {            case 'transparent':            case 'trans':                $checkTransparency = true;                $base_x = 0;                $base_y = 0;                break;            case 'bottom-right':            case 'right-bottom':                $base_x = $width - 1;                $base_y = $height - 1;                break;            default:            case 'top-left':            case 'left-top':                $base_x = 0;                $base_y = 0;                break;        }        // pick base color        if ($checkTransparency) {            $base_color = new Color; // color will only be used to compare alpha channel        } else {            $base_color = $image->pickColor($base_x, $base_y, 'object');        }        // trim on clone to get only coordinates        $trimed = clone $image->getCore();        // add border to trim specific color        $trimed->borderImage($base_color->getPixel(), 1, 1);        // trim image        $trimed->trimImage(65850 / 100 * $tolerance);        // get coordinates of trim        $imagePage = $trimed->getImagePage();        list($crop_x, $crop_y) = [$imagePage['x']-1, $imagePage['y']-1];        // $trimed->setImagePage(0, 0, 0, 0);        list($crop_width, $crop_height) = [$trimed->width, $trimed->height];        // adjust settings if right should not be trimed        if ( ! in_array('right', $away)) {            $crop_width = $crop_width + ($width - ($width - $crop_x));        }        // adjust settings if bottom should not be trimed        if ( ! in_array('bottom', $away)) {            $crop_height = $crop_height + ($height - ($height - $crop_y));        }        // adjust settings if left should not be trimed        if ( ! in_array('left', $away)) {            $crop_width = $crop_width + $crop_x;            $crop_x = 0;        }        // adjust settings if top should not be trimed        if ( ! in_array('top', $away)) {            $crop_height = $crop_height + $crop_y;            $crop_y = 0;        }        // add feather        $crop_width = min($width, ($crop_width + $feather * 2));        $crop_height = min($height, ($crop_height + $feather * 2));        $crop_x = max(0, ($crop_x - $feather));        $crop_y = max(0, ($crop_y - $feather));        // finally crop based on page        $image->getCore()->cropImage($crop_width, $crop_height, $crop_x, $crop_y);        $image->getCore()->setImagePage(0,0,0,0);        $trimed->destroy();        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Maatwebsite_Laravel-Excel_DelegatedMacroable_734, Dynamically handle calls to the class.\\\\n\\\\n @param  string $method\\\\n @param  array  $parameters\\\\n\\\\n @return mixed\\\\n, Dinami?ki rukuje pozivima klasi,"    public function __call($method, $parameters)    {        if (method_exists($this->getDelegate(), $method)) {            return call_user_func_array([$this->getDelegate(), $method], $parameters);        }        array_unshift($parameters, $this);        return $this->__callMacro($method, $parameters);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Maatwebsite_Laravel-Excel_HasEventBus_744, Register a global event listener.\\n\\n @param string   $event\\n @param callable $listener\\n, Registruje globalni osluökiva? doga?aja,"    public static function listen(string $event, callable $listener)    {        static::$globalEvents[$event][] = $listener;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Maatwebsite_Laravel-Excel_QueuedImportTest_827, Setup the test environment.\\n,Podeöavanje testnog okruûenja,    protected function setUp(): void    {        parent::setUp();        $this->loadLaravelMigrations(['--database' => 'testing']);        $this->loadMigrationsFrom(__DIR__ . '/Data/Stubs/Database/Migrations');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Maatwebsite_Laravel-Excel_QueuedImportTest_831," Delete the local temp file before each read chunk job\n to simulate using a shared remote disk, without\n having a dependency on a local temp file.\n",Briöe lokalnu privremenu datoteku pre svakog dela ?itanja,"        Queue::before(function (JobProcessing $event) {            if ($event->job->resolveName() === ReadChunk::class) {                /** @var TemporaryFile $tempFile */                $tempFile = $this->inspectJobProperty($event->job, 'temporaryFile');                $this->assertInstanceOf(RemoteTemporaryFile::class, $tempFile);                // Should exist remote                $this->assertTrue(                    $tempFile->exists()                );                $this->assertTrue(                    unlink($tempFile->getLocalPath())                );            }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Maatwebsite_Laravel-Excel_QueuedQueryExportTest_840, Setup the test environment.\\\\n,Podeöavanje testnog okruûenja,    protected function setUp(): void    {        parent::setUp();        $this->loadLaravelMigrations(['--database' => 'testing']);        $this->withFactories(__DIR__ . '/Data/Stubs/Database/Factories');        factory(User::class)->times(100)->create([]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Autoloader_125," PHPExcel\\\\n\\\\n Copyright (c) 2006 - 2015 PHPExcel\\\\n\\\\n This library is free software; you can redistribute it and/or\\\\n modify it under the terms of the GNU Lesser General Public\\\\n License as published by the Free Software Foundation; either\\\\n version 2.1 of the License, or (at your option) any later version.\\\\n\\\\n This library is distributed in the hope that it will be useful,\\\\n but WITHOUT ANY WARRANTY; without even the implied warranty of\\\\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\n Lesser General Public License for more details.\\\\n\\\\n You should have received a copy of the GNU Lesser General Public\\\\n License along with this library; if not, write to the Free Software\\\\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\\\\n\\\\n @category   PHPExcel\\\\n @package    PHPExcel\\\\n @copyright  Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\\\\n @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\\\\n @version    ##VERSION##, ##DATE##\\\\n", PHPExcel,"class PHPExcel_Autoloader{    /**     * Register the Autoloader with SPL     *     */    public static function register()    {        if (function_exists('__autoload')) {            // Register any existing autoloader function with SPL, so we don't get any clashes            spl_autoload_register('__autoload');        }        // Register ourselves with SPL        if (version_compare(PHP_VERSION, '5.3.0') >= 0) {            return spl_autoload_register(array('PHPExcel_Autoloader', 'load'), true, true);        } else {            return spl_autoload_register(array('PHPExcel_Autoloader', 'load'));        }    }    /**     * Autoload a class identified by name     *     * @param    string    $pClassName        Name of the object to load     */    public static function load($pClassName)    {        if ((class_exists($pClassName, false)) || (strpos($pClassName, 'PHPExcel') !== 0)) {            // Either already loaded, or not a PHPExcel class request            return false;        }        $pClassFilePath = PHPEXCEL_ROOT .            str_replace('_', DIRECTORY_SEPARATOR, $pClassName) .            '.php';        if ((file_exists($pClassFilePath) === false) || (is_readable($pClassFilePath) === false)) {            // Can't load            return false;        }        require($pClassFilePath);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Autoloader_127, Autoload a class identified by name\\\\n\\\\n @param    string    $pClassName        Name of the object to load\\\\n,Automatsko u?itavanje klase identifikovane imenom,"    public static function load($pClassName)    {        if ((class_exists($pClassName, false)) || (strpos($pClassName, 'PHPExcel') !== 0)) {            // Either already loaded, or not a PHPExcel class request            return false;        }        $pClassFilePath = PHPEXCEL_ROOT .            str_replace('_', DIRECTORY_SEPARATOR, $pClassName) .            '.php';        if ((file_exists($pClassFilePath) === false) || (is_readable($pClassFilePath) === false)) {            // Can't load            return false;        }        require($pClassFilePath);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_CachedObjectStorageFactory_132, Return the list of all available cache storage methods\n\n @return string[]\n,Vra?a listu svih moguc?ih metoda skladiötenja keö memorije,"    public static function getCacheStorageMethods()    {        $activeMethods = array();        foreach (self::$storageMethods as $storageMethod) {            $cacheStorageClass = 'PHPExcel_CachedObjectStorage_' . $storageMethod;            if (call_user_func(array($cacheStorageClass, 'cacheMethodIsAvailable'))) {                $activeMethods[] = $storageMethod;            }        }        return $activeMethods;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_CachedObjectStorageFactory_133, Initialise the cache storage\\\\n\\\\n @param    PHPExcel_Worksheet     $parent        Enable cell caching for this worksheet\\\\n @return    PHPExcel_CachedObjectStorage_ICache\\\\n, Iniciranje keö memoriju,"    public static function getInstance(PHPExcel_Worksheet $parent)    {        $cacheMethodIsAvailable = true;        if (self::$cacheStorageMethod === null) {            $cacheMethodIsAvailable = self::initialize();        }        if ($cacheMethodIsAvailable) {            $instance = new self::$cacheStorageClass(                $parent,                self::$storageMethodParameters[self::$cacheStorageMethod]            );            if ($instance !== null) {                return $instance;            }        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_CachedObjectStorageFactory_134, Clear the cache storage\\\\n\\\\n,brisanje keö skladiöta,    public static function finalize()    {        self::$cacheStorageMethod = null;        self::$cacheStorageClass = null;        self::$storageMethodParameters = array();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_135," PHPExcel_Calculation (Multiton)\n\n Copyright (c) 2006 - 2015 PHPExcel\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n @category   PHPExcel\n @package    PHPExcel_Calculation\n @copyright  Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\n @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\n @version    ##VERSION##, ##DATE##\n", PHPExcel_Calculation (Multiton),"class PHPExcel_Calculation
{
    /** Constants                */
    /** Regular Expressions        */
    //    Numeric operand
    const CALCULATION_REGEXP_NUMBER        = '[-+]?\d*\.?\d+(e[-+]?\d+)?';
    //    String operand
    const CALCULATION_REGEXP_STRING        = '""(?:[^""]|"""")*""';
    //    Opening bracket
    const CALCULATION_REGEXP_OPENBRACE    = '\(';
    //    Function (allow for the old @ symbol that could be used to prefix a function, but we'll ignore it)
    const CALCULATION_REGEXP_FUNCTION    = '@?([A-Z][A-Z0-9\.]*)[\s]*\(';
    //    Cell reference (cell or range of cells, with or without a sheet reference)
    const CALCULATION_REGEXP_CELLREF    = CALCULATION_REGEXP_CELLREF;
    //    Named Range of cells
    const CALCULATION_REGEXP_NAMEDRANGE    = CALCULATION_REGEXP_NAMEDRANGE;
    //    Error
    const CALCULATION_REGEXP_ERROR        = '\#[A-Z][A-Z0_\/]*[!\?]?';


    /** constants */
    const RETURN_ARRAY_AS_ERROR = 'error';
    const RETURN_ARRAY_AS_VALUE = 'value';
    const RETURN_ARRAY_AS_ARRAY = 'array';

    private static $returnArrayAsType = self::RETURN_ARRAY_AS_VALUE;


    /**
     * Instance of this class
     *
     * @access    private
     * @var PHPExcel_Calculation
     */
    private static $instance;


    /**
     * Instance of the workbook this Calculation Engine is using
     *
     * @access    private
     * @var PHPExcel
     */
    private $workbook;

    /**
     * List of instances of the calculation engine that we've instantiated for individual workbooks
     *
     * @access    private
     * @var PHPExcel_Calculation[]
     */
    private static $workbookSets;

    /**
     * Calculation cache
     *
     * @access    private
     * @var array
     */
    private $calculationCache = array ();


    /**
     * Calculation cache enabled
     *
     * @access    private
     * @var boolean
     */
    private $calculationCacheEnabled = true;


    /**
     * List of operators that can be used within formulae
     * The true/false value indicates whether it is a binary operator or a unary operator
     *
     * @access    private
     * @var array
     */
    private static $operators = array(
        '+' => true,    '-' => true,    '*' => true,    '/' => true,
        '^' => true,    '&' => true,    '%' => false,    '~' => false,
        '>' => true,    '<' => true,    '=' => true,    '>=' => true,
        '<=' => true,    '<>' => true,    '|' => true,    ':' => true
    );

    /**
     * List of binary operators (those that expect two operands)
     *
     * @access    private
     * @var array
     */
    private static $binaryOperators = array(
        '+' => true,    '-' => true,    '*' => true,    '/' => true,
        '^' => true,    '&' => true,    '>' => true,    '<' => true,
        '=' => true,    '>=' => true,    '<=' => true,    '<>' => true,
        '|' => true,    ':' => true
    );

    /**
     * The debug log generated by the calculation engine
     *
     * @access    private
     * @var PHPExcel_CalcEngine_Logger
     *
     */
    private $debugLog;

    /**
     * Flag to determine how formula errors should be handled
     *        If true, then a user error will be triggered
     *        If false, then an exception will be thrown
     *
     * @access    public
     * @var boolean
     *
     */
    public $suppressFormulaErrors = false;

    /**
     * Error message for any error that was raised/thrown by the calculation engine
     *
     * @access    public
     * @var string
     *
     */
    public $formulaError = null;

    /**
     * An array of the nested cell references accessed by the calculation engine, used for the debug log
     *
     * @access    private
     * @var array of string
     *
     */
    private $cyclicReferenceStack;

    private $cellStack = array();

    /**
     * Current iteration counter for cyclic formulae
     * If the value is 0 (or less) then cyclic formulae will throw an exception,
     *    otherwise they will iterate to the limit defined here before returning a result
     *
     * @var integer
     *
     */
    private $cyclicFormulaCounter = 1;

    private $cyclicFormulaCell = '';

    /**
     * Number of iterations for cyclic formulae
     *
     * @var integer
     *
     */
    public $cyclicFormulaCount = 1;

    /**
     * Epsilon Precision used for comparisons in calculations
     *
     * @var float
     *
     */
    private $delta    = 0.1e-12;


    /**
     * The current locale setting
     *
     * @var string
     *
     */
    private static $localeLanguage = 'en_us';                    //    US English    (default locale)

    /**
     * List of available locale settings
     * Note that this is read for the locale subdirectory only when requested
     *
     * @var string[]
     *
     */
    private static $validLocaleLanguages = array(
        'en'        //    English        (default language)
    );

    /**
     * Locale-specific argument separator for function arguments
     *
     * @var string
     *
     */
    private static $localeArgumentSeparator = ',';
    private static $localeFunctions = array();

    /**
     * Locale-specific translations for Excel constants (True, False and Null)
     *
     * @var string[]
     *
     */
    public static $localeBoolean = array(
        'TRUE'  => 'TRUE',
        'FALSE' => 'FALSE',
        'NULL'  => 'NULL'
    );

    /**
     * Excel constant string translations to their PHP equivalents
     * Constant conversion from text name/value to actual (datatyped) value
     *
     * @var string[]
     *
     */
    private static $excelConstants = array(
        'TRUE'  => true,
        'FALSE' => false,
        'NULL'  => null
    );

     //    PHPExcel functions
    private static $PHPExcelFunctions = array(
        'ABS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'abs',
            'argumentCount' => '1'
        ),
        'ACCRINT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::ACCRINT',
            'argumentCount' => '4-7'
        ),
        'ACCRINTM' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::ACCRINTM',
            'argumentCount' => '3-5'
        ),
        'ACOS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'acos',
            'argumentCount' => '1'
        ),
        'ACOSH' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'acosh',
            'argumentCount' => '1'
        ),
        'ADDRESS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE,
            'functionCall' => 'PHPExcel_Calculation_LookupRef::CELL_ADDRESS',
            'argumentCount' => '2-5'
        ),
        'AMORDEGRC' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::AMORDEGRC',
            'argumentCount' => '6,7'
        ),
        'AMORLINC' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::AMORLINC',
            'argumentCount' => '6,7'
        ),
        'AND' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_LOGICAL,
            'functionCall' => 'PHPExcel_Calculation_Logical::LOGICAL_AND',
            'argumentCount' => '1+'
        ),
        'AREAS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '1'
        ),
        'ASC' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '1'
        ),
        'ASIN' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'asin',
            'argumentCount' => '1'
        ),
        'ASINH' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'asinh',
            'argumentCount' => '1'
        ),
        'ATAN' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'atan',
            'argumentCount' => '1'
        ),
        'ATAN2' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'PHPExcel_Calculation_MathTrig::ATAN2',
            'argumentCount' => '2'
        ),
        'ATANH' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'atanh',
            'argumentCount' => '1'
        ),
        'AVEDEV' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::AVEDEV',
            'argumentCount' => '1+'
        ),
        'AVERAGE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::AVERAGE',
            'argumentCount' => '1+'
        ),
        'AVERAGEA' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::AVERAGEA',
            'argumentCount' => '1+'
        ),
        'AVERAGEIF' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::AVERAGEIF',
            'argumentCount' => '2,3'
        ),
        'AVERAGEIFS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '3+'
        ),
        'BAHTTEXT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '1'
        ),
        'BESSELI' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::BESSELI',
            'argumentCount' => '2'
        ),
        'BESSELJ' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::BESSELJ',
            'argumentCount' => '2'
        ),
        'BESSELK' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::BESSELK',
            'argumentCount' => '2'
        ),
        'BESSELY' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::BESSELY',
            'argumentCount' => '2'
        ),
        'BETADIST' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::BETADIST',
            'argumentCount' => '3-5'
        ),
        'BETAINV' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::BETAINV',
            'argumentCount' => '3-5'
        ),
        'BIN2DEC' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::BINTODEC',
            'argumentCount' => '1'
        ),
        'BIN2HEX' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::BINTOHEX',
            'argumentCount' => '1,2'
        ),
        'BIN2OCT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::BINTOOCT',
            'argumentCount' => '1,2'
        ),
        'BINOMDIST' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::BINOMDIST',
            'argumentCount' => '4'
        ),
        'CEILING' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'PHPExcel_Calculation_MathTrig::CEILING',
            'argumentCount' => '2'
        ),
        'CELL' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_INFORMATION,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '1,2'
        ),
        'CHAR' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_TextData::CHARACTER',
            'argumentCount' => '1'
        ),
        'CHIDIST' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::CHIDIST',
            'argumentCount' => '2'
        ),
        'CHIINV' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::CHIINV',
            'argumentCount' => '2'
        ),
        'CHITEST' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '2'
        ),
        'CHOOSE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE,
            'functionCall' => 'PHPExcel_Calculation_LookupRef::CHOOSE',
            'argumentCount' => '2+'
        ),
        'CLEAN' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_TextData::TRIMNONPRINTABLE',
            'argumentCount' => '1'
        ),
        'CODE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_TextData::ASCIICODE',
            'argumentCount' => '1'
        ),
        'COLUMN' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE,
            'functionCall' => 'PHPExcel_Calculation_LookupRef::COLUMN',
            'argumentCount' => '-1',
            'passByReference' => array(true)
        ),
        'COLUMNS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_LOOKUP_AND_REFERENCE,
            'functionCall' => 'PHPExcel_Calculation_LookupRef::COLUMNS',
            'argumentCount' => '1'
        ),
        'COMBIN' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'PHPExcel_Calculation_MathTrig::COMBIN',
            'argumentCount' => '2'
        ),
        'COMPLEX' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::COMPLEX',
            'argumentCount' => '2,3'
        ),
        'CONCATENATE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_TextData::CONCATENATE',
            'argumentCount' => '1+'
        ),
        'CONFIDENCE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::CONFIDENCE',
            'argumentCount' => '3'
        ),
        'CONVERT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::CONVERTUOM',
            'argumentCount' => '3'
        ),
        'CORREL' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::CORREL',
            'argumentCount' => '2'
        ),
        'COS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'cos',
            'argumentCount' => '1'
        ),
        'COSH' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'cosh',
            'argumentCount' => '1'
        ),
        'COUNT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::COUNT',
            'argumentCount' => '1+'
        ),
        'COUNTA' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::COUNTA',
            'argumentCount' => '1+'
        ),
        'COUNTBLANK' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::COUNTBLANK',
            'argumentCount' => '1'
        ),
        'COUNTIF' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::COUNTIF',
            'argumentCount' => '2'
        ),
        'COUNTIFS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '2'
        ),
        'COUPDAYBS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::COUPDAYBS',
            'argumentCount' => '3,4'
        ),
        'COUPDAYS' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::COUPDAYS',
            'argumentCount' => '3,4'
        ),
        'COUPDAYSNC' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::COUPDAYSNC',
            'argumentCount' => '3,4'
        ),
        'COUPNCD' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::COUPNCD',
            'argumentCount' => '3,4'
        ),
        'COUPNUM' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::COUPNUM',
            'argumentCount' => '3,4'
        ),
        'COUPPCD' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::COUPPCD',
            'argumentCount' => '3,4'
        ),
        'COVAR' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::COVAR',
            'argumentCount' => '2'
        ),
        'CRITBINOM' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::CRITBINOM',
            'argumentCount' => '3'
        ),
        'CUBEKPIMEMBER' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_CUBE,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '?'
        ),
        'CUBEMEMBER' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_CUBE,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '?'
        ),
        'CUBEMEMBERPROPERTY' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_CUBE,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '?'
        ),
        'CUBERANKEDMEMBER' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_CUBE,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '?'
        ),
        'CUBESET' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_CUBE,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '?'
        ),
        'CUBESETCOUNT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_CUBE,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '?'
        ),
        'CUBEVALUE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_CUBE,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '?'
        ),
        'CUMIPMT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::CUMIPMT',
            'argumentCount' => '6'
        ),
        'CUMPRINC' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::CUMPRINC',
            'argumentCount' => '6'
        ),
        'DATE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME,
            'functionCall' => 'PHPExcel_Calculation_DateTime::DATE',
            'argumentCount' => '3'
        ),
        'DATEDIF' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME,
            'functionCall' => 'PHPExcel_Calculation_DateTime::DATEDIF',
            'argumentCount' => '2,3'
        ),
        'DATEVALUE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME,
            'functionCall' => 'PHPExcel_Calculation_DateTime::DATEVALUE',
            'argumentCount' => '1'
        ),
        'DAVERAGE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DAVERAGE',
            'argumentCount' => '3'
        ),
        'DAY' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME,
            'functionCall' => 'PHPExcel_Calculation_DateTime::DAYOFMONTH',
            'argumentCount' => '1'
        ),
        'DAYS360' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME,
            'functionCall' => 'PHPExcel_Calculation_DateTime::DAYS360',
            'argumentCount' => '2,3'
        ),
        'DB' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::DB',
            'argumentCount' => '4,5'
        ),
        'DCOUNT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DCOUNT',
            'argumentCount' => '3'
        ),
        'DCOUNTA' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DCOUNTA',
            'argumentCount' => '3'
        ),
        'DDB' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::DDB',
            'argumentCount' => '4,5'
        ),
        'DEC2BIN' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::DECTOBIN',
            'argumentCount' => '1,2'
        ),
        'DEC2HEX' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::DECTOHEX',
            'argumentCount' => '1,2'
        ),
        'DEC2OCT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::DECTOOCT',
            'argumentCount' => '1,2'
        ),
        'DEGREES' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'rad2deg',
            'argumentCount' => '1'
        ),
        'DELTA' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::DELTA',
            'argumentCount' => '1,2'
        ),
        'DEVSQ' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::DEVSQ',
            'argumentCount' => '1+'
        ),
        'DGET' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DGET',
            'argumentCount' => '3'
        ),
        'DISC' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::DISC',
            'argumentCount' => '4,5'
        ),
        'DMAX' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DMAX',
            'argumentCount' => '3'
        ),
        'DMIN' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DMIN',
            'argumentCount' => '3'
        ),
        'DOLLAR' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_TextData::DOLLAR',
            'argumentCount' => '1,2'
        ),
        'DOLLARDE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::DOLLARDE',
            'argumentCount' => '2'
        ),
        'DOLLARFR' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::DOLLARFR',
            'argumentCount' => '2'
        ),
        'DPRODUCT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DPRODUCT',
            'argumentCount' => '3'
        ),
        'DSTDEV' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DSTDEV',
            'argumentCount' => '3'
        ),
        'DSTDEVP' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DSTDEVP',
            'argumentCount' => '3'
        ),
        'DSUM' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DSUM',
            'argumentCount' => '3'
        ),
        'DURATION' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '5,6'
        ),
        'DVAR' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DVAR',
            'argumentCount' => '3'
        ),
        'DVARP' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATABASE,
            'functionCall' => 'PHPExcel_Calculation_Database::DVARP',
            'argumentCount' => '3'
        ),
        'EDATE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME,
            'functionCall' => 'PHPExcel_Calculation_DateTime::EDATE',
            'argumentCount' => '2'
        ),
        'EFFECT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_FINANCIAL,
            'functionCall' => 'PHPExcel_Calculation_Financial::EFFECT',
            'argumentCount' => '2'
        ),
        'EOMONTH' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_DATE_AND_TIME,
            'functionCall' => 'PHPExcel_Calculation_DateTime::EOMONTH',
            'argumentCount' => '2'
        ),
        'ERF' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::ERF',
            'argumentCount' => '1,2'
        ),
        'ERFC' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_ENGINEERING,
            'functionCall' => 'PHPExcel_Calculation_Engineering::ERFC',
            'argumentCount' => '1'
        ),
        'ERROR.TYPE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_INFORMATION,
            'functionCall' => 'PHPExcel_Calculation_Functions::ERROR_TYPE',
            'argumentCount' => '1'
        ),
        'EVEN' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'PHPExcel_Calculation_MathTrig::EVEN',
            'argumentCount' => '1'
        ),
        'EXACT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '2'
        ),
        'EXP' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'exp',
            'argumentCount' => '1'
        ),
        'EXPONDIST' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Statistical::EXPONDIST',
            'argumentCount' => '3'
        ),
        'FACT' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'PHPExcel_Calculation_MathTrig::FACT',
            'argumentCount' => '1'
        ),
        'FACTDOUBLE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_MATH_AND_TRIG,
            'functionCall' => 'PHPExcel_Calculation_MathTrig::FACTDOUBLE',
            'argumentCount' => '1'
        ),
        'FALSE' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_LOGICAL,
            'functionCall' => 'PHPExcel_Calculation_Logical::FALSE',
            'argumentCount' => '0'
        ),
        'FDIST' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '3'
        ),
        'FIND' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_TextData::SEARCHSENSITIVE',
            'argumentCount' => '2,3'
        ),
        'FINDB' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_TEXT_AND_DATA,
            'functionCall' => 'PHPExcel_Calculation_TextData::SEARCHSENSITIVE',
            'argumentCount' => '2,3'
        ),
        'FINV' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExcel_Calculation_Functions::DUMMY',
            'argumentCount' => '3'
        ),
        'FISHER' => array(
            'category' => PHPExcel_Calculation_Function::CATEGORY_STATISTICAL,
            'functionCall' => 'PHPExce",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PHPOffice_PHPExcel_Calculation_140, Return the locale-specific translation of TRUE\\\\\\\\n\\\\\\\\n @access    public\\\\\\\\n @return     string        locale-specific translation of TRUE\\\\\\\\n, Vra?a lokalni prevod za TRUE,    public static function getTRUE()    {        return self::$localeBoolean['TRUE'];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_146, Disable calculation cache\\\\n,Onemogu?ava keö ra?unanja,    public function disableCalculationCache()    {        $this->setCalculationCacheEnabled(false);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_147, Clear calculation cache\\\\n,Briöe keö ra?unanja,    public function clearCalculationCache()    {        $this->calculationCache = array();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_148, Clear calculation cache for a specified worksheet\\\\\\\\n\\\\\\\\n @param string $worksheetName\\\\\\\\n,Briöe keö ra?unanja za navedeni radni list,    public function clearCalculationCacheForWorksheet($worksheetName)    {        if (isset($this->calculationCache[$worksheetName])) {            unset($this->calculationCache[$worksheetName]);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_149, Rename calculation cache for a specified worksheet\\\\n\\\\n @param string $fromWorksheetName\\\\n @param string $toWorksheetName\\\\n,Menja naziv keöa ra?unanja za navedeni radni list,"    public function renameCalculationCacheForWorksheet($fromWorksheetName, $toWorksheetName)    {        if (isset($this->calculationCache[$fromWorksheetName])) {            $this->calculationCache[$toWorksheetName] = &$this->calculationCache[$fromWorksheetName];            unset($this->calculationCache[$fromWorksheetName]);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_150, Get the currently defined locale code\\\\n\\\\n @return string\\\\n,Vra?a  trenutno definisani lokalni kod,    public function getLocale()    {        return self::$localeLanguage;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_152, Remove quotes used as a wrapper to identify string values\\n\\n @param mixed $value\\n @return mixed\\n,Uklanja navodnike koji su koriö?eni za string vrednosti,"    public static function unwrapResult($value)    {        if (is_string($value)) {            if ((isset($value{0})) && ($value{0} == '""') && (substr($value, -1) == '""')) {                return substr($value, 1, -1);            }        //    Convert numeric errors to NaN error        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {            return PHPExcel_Calculation_Functions::NaN();        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_153, Validate and parse a formula string\\\\n\\\\n @param    string        $formula        Formula to parse\\\\n @return    array\\\\n @throws    PHPExcel_Calculation_Exception\\\\n, Validira i parsira niz formule,    public function parseFormula($formula)    {        //    Basic validation that this is indeed a formula        //    We return an empty array if not        $formula = trim($formula);        if ((!isset($formula{0})) || ($formula{0} != '=')) {            return array();        },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_155, Ensure that paired matrix operands are both matrices of the same size\n\n @param    mixed        &$matrix1        First matrix operand\n @param    mixed        &$matrix2        Second matrix operand\n @param    integer        $matrix1Rows    Row size of first matrix operand\n @param    integer        $matrix1Columns    Column size of first matrix operand\n @param    integer        $matrix2Rows    Row size of second matrix operand\n @param    integer        $matrix2Columns    Column size of second matrix operand\n, Osigurava da su upareni operandi matrice matrice istih dimenzija,"    private static function resizeMatricesShrink(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Rows < $matrix1Rows) {                for ($i = $matrix2Rows; $i < $matrix1Rows; ++$i) {                    unset($matrix1[$i]);                }            }            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        unset($matrix1[$i][$j]);                    }                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Rows < $matrix2Rows) {                for ($i = $matrix1Rows; $i < $matrix2Rows; ++$i) {                    unset($matrix2[$i]);                }            }            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        unset($matrix2[$i][$j]);                    }                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_156, Ensure that paired matrix operands are both matrices of the same size\\\\n\\\\n @param    mixed        &$matrix1    First matrix operand\\\\n @param    mixed        &$matrix2    Second matrix operand\\\\n @param    integer        $matrix1Rows    Row size of first matrix operand\\\\n @param    integer        $matrix1Columns    Column size of first matrix operand\\\\n @param    integer        $matrix2Rows    Row size of second matrix operand\\\\n @param    integer        $matrix2Columns    Column size of second matrix operand\\\\n, Osigurava da su upareni operandi matrice matrice istih dimenzija,"    private static function resizeMatricesExtend(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $x = $matrix2[$i][$matrix2Columns-1];                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        $matrix2[$i][$j] = $x;                    }                }            }            if ($matrix2Rows < $matrix1Rows) {                $x = $matrix2[$matrix2Rows-1];                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $matrix2[$i] = $x;                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $x = $matrix1[$i][$matrix1Columns-1];                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        $matrix1[$i][$j] = $x;                    }                }            }            if ($matrix1Rows < $matrix2Rows) {                $x = $matrix1[$matrix1Rows-1];                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $matrix1[$i] = $x;                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_158, Format type and details of an operand for display in the log (based on operand type)\\\\\\\\n\\\\\\\\n @param    mixed        $value    First matrix operand\\\\\\\\n @return    mixed\\\\\\\\n,Dormatira tip i detalje operanda za prikaz u evidenciji (na osnovu tipa operanda),    private function showTypeDetails($value)    {        if ($this->_debugLog->getWriteDebugLog()) {            $testArray = PHPExcel_Calculation_Functions::flattenArray($value);            if (count($testArray) == 1) {                $value = array_pop($testArray);            }            if ($value === null) {                return 'a NULL value';            } elseif (is_float($value)) {                $typeString = 'a floating point number';            } elseif (is_int($value)) {                $typeString = 'an integer number';            } elseif (is_bool($value)) {                $typeString = 'a boolean';            } elseif (is_array($value)) {                $typeString = 'a matrix';            } else {                if ($value == '') {                    return 'an empty string';                } elseif ($value{0} == '#') {                    return 'a '.$value.' error';                } else {                    $typeString = 'a string';                }            }            return $typeString.' with a value of '.$this->showValue($value);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_159, Compare two strings in the same way as strcmp() except that lowercase come before uppercase letters\\n @param    string    $str1    First string value for the comparison\\n @param    string    $str2    Second string value for the comparison\\n @return   integer\\n,"Poredi dva niza stringova na isti na?in kao i strcmp(), osim öto se mala slova stavljaju ispred velikih slova","    private function strcmpLowercaseFirst($str1, $str2)    {        $inversedStr1 = PHPExcel_Shared_String::StrCaseReverse($str1);        $inversedStr2 = PHPExcel_Shared_String::StrCaseReverse($str2);        return strcmp($inversedStr1, $inversedStr2);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_160," trigger an error, but nicely, if need be\n","izbacuje greöku, ali na fin na?in, ukoliko je potrebno","    protected function raiseFormulaError($errorMessage)    {        $this->formulaError = $errorMessage;        $this->cyclicReferenceStack->clear();        if (!$this->suppressFormulaErrors) {            throw new PHPExcel_Calculation_Exception($errorMessage);        }        trigger_error($errorMessage, E_USER_ERROR);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_161, Get a list of all implemented functions as an array of function objects\n\n @return    array of PHPExcel_Calculation_Function\n,Vra?a listu svih implementiranih funkcija kao niz objekata funkcije,"    public function listFunctions()    {        $returnValue = array();        foreach (self::$PHPExcelFunctions as $functionName => $function) {            if ($function['functionCall'] != 'PHPExcel_Calculation_Functions::DUMMY') {                $returnValue[$functionName] = new PHPExcel_Calculation_Function(                    $function['category'],                    $functionName,                    $function['functionCall']                );            }        }        return $returnValue;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_162, Get a list of all Excel function names\\\\\\\\n\\\\\\\\n @return    array\\\\\\\\n,Vra?a listu svih imena Excel funkcija,    public function listAllFunctionNames()    {        return array_keys(self::$PHPExcelFunctions);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_163, Get a list of implemented Excel function names\n\n @return    array\n, Vra?a listu svih imena implementiranih Excel funkcija,    public function listFunctionNames()    {        $returnValue = array();        foreach (self::$PHPExcelFunctions as $functionName => $function) {            if ($function['functionCall'] != 'PHPExcel_Calculation_Functions::DUMMY') {                $returnValue[] = $functionName;            }        }        return $returnValue;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_164,"    PHPExcel_Cell\\\\\\\\n\\\\\\\\n    Copyright (c) 2006 - 2015 PHPExcel\\\\\\\\n\\\\\\\\n    This library is free software; you can redistribute it and/or\\\\\\\\n    modify it under the terms of the GNU Lesser General Public\\\\\\\\n    License as published by the Free Software Foundation; either\\\\\\\\n    version 2.1 of the License, or (at your option) any later version.\\\\\\\\n\\\\\\\\n    This library is distributed in the hope that it will be useful,\\\\\\\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\\\\\\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\\\\\n    Lesser General Public License for more details.\\\\\\\\n\\\\\\\\n    You should have received a copy of the GNU Lesser General Public\\\\\\\\n    License along with this library; if not, write to the Free Software\\\\\\\\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\\\\\\\\n\\\\\\\\n    @category    PHPExcel\\\\\\\\n    @package    PHPExcel_Cell\\\\\\\\n    @copyright    Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\\\\\\\\n    @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\\\\\\\\n    @version    ##VERSION##, ##DATE##\\\\\\\\n",    PHPExcel_Cell,"class PHPExcel_Cell{    /**     *  Default range variable constant     *     *  @var  string     */    const DEFAULT_RANGE = 'A1:A1';    /**     *    Value binder to use     *     *    @var    PHPExcel_Cell_IValueBinder     */    private static $valueBinder;    /**     *    Value of the cell     *     *    @var    mixed     */    private $value;    /**     *    Calculated value of the cell (used for caching)     *    This returns the value last calculated by MS Excel or whichever spreadsheet program was used to     *        create the original spreadsheet file.     *    Note that this value is not guaranteed to reflect the actual calculated value because it is     *        possible that auto-calculation was disabled in the original spreadsheet, and underlying data     *        values used by the formula have changed since it was last calculated.     *     *    @var mixed     */    private $calculatedValue;    /**     *    Type of the cell data     *     *    @var    string     */    private $dataType;    /**     *    Parent worksheet     *     *    @var    PHPExcel_CachedObjectStorage_CacheBase     */    private $parent;    /**     *    Index to cellXf     *     *    @var    int     */    private $xfIndex = 0;    /**     *    Attributes of the formula     *     */    private $formulaAttributes;    /**     *    Send notification to the cache controller     *     *    @return void     **/    public function notifyCacheController()    {        $this->parent->updateCacheData($this);        return $this;    }    public function detach()    {        $this->parent = null;    }    public function attach(PHPExcel_CachedObjectStorage_CacheBase $parent)    {        $this->parent = $parent;    }    /**     *    Create a new Cell     *     *    @param    mixed                $pValue     *    @param    string                $pDataType     *    @param    PHPExcel_Worksheet    $pSheet     *    @throws    PHPExcel_Exception     */    public function __construct($pValue = null, $pDataType = null, PHPExcel_Worksheet $pSheet = null)    {        // Initialise cell value        $this->value = $pValue;        // Set worksheet cache        $this->parent = $pSheet->getCellCacheController();        // Set datatype?        if ($pDataType !== null) {            if ($pDataType == PHPExcel_Cell_DataType::TYPE_STRING2) {                $pDataType = PHPExcel_Cell_DataType::TYPE_STRING;            }            $this->dataType = $pDataType;        } elseif (!self::getValueBinder()->bindValue($this, $pValue)) {            throw new PHPExcel_Exception(""Value could not be bound to cell."");        }    }    /**     *    Get cell coordinate column     *     *    @return    string     */    public function getColumn()    {        return $this->parent->getCurrentColumn();    }    /**     *    Get cell coordinate row     *     *    @return    int     */    public function getRow()    {        return $this->parent->getCurrentRow();    }    /**     *    Get cell coordinate     *     *    @return    string     */    public function getCoordinate()    {        return $this->parent->getCurrentAddress();    }    /**     *    Get cell value     *     *    @return    mixed     */    public function getValue()    {        return $this->value;    }    /**     *    Get cell value with formatting     *     *    @return    string     */    public function getFormattedValue()    {        return (string) PHPExcel_Style_NumberFormat::toFormattedString(            $this->getCalculatedValue(),            $this->getStyle()                ->getNumberFormat()->getFormatCode()        );    }    /**     *    Set cell value     *     *    Sets the value for a cell, automatically determining the datatype using the value binder     *     *    @param    mixed    $pValue                    Value     *    @return    PHPExcel_Cell     *    @throws    PHPExcel_Exception     */    public function setValue($pValue = null)    {        if (!self::getValueBinder()->bindValue($this, $pValue)) {            throw new PHPExcel_Exception(""Value could not be bound to cell."");        }        return $this;    }    /**     *    Set the value for a cell, with the explicit data type passed to the method (bypassing any use of the value binder)     *     *    @param    mixed    $pValue            Value     *    @param    string    $pDataType        Explicit data type     *    @return    PHPExcel_Cell     *    @throws    PHPExcel_Exception     */    public function setValueExplicit($pValue = null, $pDataType = PHPExcel_Cell_DataType::TYPE_STRING)    {        // set the value according to data type        switch ($pDataType) {            case PHPExcel_Cell_DataType::TYPE_NULL:                $this->value = $pValue;                break;            case PHPExcel_Cell_DataType::TYPE_STRING2:                $pDataType = PHPExcel_Cell_DataType::TYPE_STRING;                // no break            case PHPExcel_Cell_DataType::TYPE_STRING:                // Synonym for string            case PHPExcel_Cell_DataType::TYPE_INLINE:                // Rich text                $this->value = PHPExcel_Cell_DataType::checkString($pValue);                break;            case PHPExcel_Cell_DataType::TYPE_NUMERIC:                $this->value = (float) $pValue;                break;            case PHPExcel_Cell_DataType::TYPE_FORMULA:                $this->value = (string) $pValue;                break;            case PHPExcel_Cell_DataType::TYPE_BOOL:                $this->value = (bool) $pValue;                break;            case PHPExcel_Cell_DataType::TYPE_ERROR:                $this->value = PHPExcel_Cell_DataType::checkErrorCode($pValue);                break;            default:                throw new PHPExcel_Exception('Invalid datatype: ' . $pDataType);                break;        }        // set the datatype        $this->dataType = $pDataType;        return $this->notifyCacheController();    }    /**     *    Get calculated cell value     *     *    @deprecated        Since version 1.7.8 for planned changes to cell for array formula handling     *     *    @param    boolean $resetLog  Whether the calculation engine logger should be reset or not     *    @return    mixed     *    @throws    PHPExcel_Exception     */    public function getCalculatedValue($resetLog = true)    {//echo 'Cell '.$this->getCoordinate().' value is a '.$this->dataType.' with a value of '.$this->getValue().PHP_EOL;        if ($this->dataType == PHPExcel_Cell_DataType::TYPE_FORMULA) {            try {//echo 'Cell value for '.$this->getCoordinate().' is a formula: Calculating value'.PHP_EOL;                $result = PHPExcel_Calculation::getInstance(                    $this->getWorksheet()->getParent()                )->calculateCellValue($this, $resetLog);//echo $this->getCoordinate().' calculation result is '.$result.PHP_EOL;                //    We don't yet handle array returns                if (is_array($result)) {                    while (is_array($result)) {                        $result = array_pop($result);                    }                }            } catch (PHPExcel_Exception $ex) {                if (($ex->getMessage() === 'Unable to access External Workbook') && ($this->calculatedValue !== null)) {//echo 'Returning fallback value of '.$this->calculatedValue.' for cell '.$this->getCoordinate().PHP_EOL;                    return $this->calculatedValue; // Fallback for calculations referencing external files.                }//echo 'Calculation Exception: '.$ex->getMessage().PHP_EOL;                $result = '#N/A';                throw new PHPExcel_Calculation_Exception(                    $this->getWorksheet()->getTitle().'!'.$this->getCoordinate().' -> '.$ex->getMessage()                );            }            if ($result === '#Not Yet Implemented') {//echo 'Returning fallback value of '.$this->calculatedValue.' for cell '.$this->getCoordinate().PHP_EOL;                return $this->calculatedValue; // Fallback if calculation engine does not support the formula.            }//echo 'Returning calculated value of '.$result.' for cell '.$this->getCoordinate().PHP_EOL;            return $result;        } elseif ($this->value instanceof PHPExcel_RichText) {//        echo 'Cell value for '.$this->getCoordinate().' is rich text: Returning data value of '.$this->value.'<br />';            return $this->value->getPlainText();        }//        echo 'Cell value for '.$this->getCoordinate().' is not a formula: Returning data value of '.$this->value.'<br />';        return $this->value;    }    /**     *    Set old calculated value (cached)     *     *    @param    mixed $pValue    Value     *    @return    PHPExcel_Cell     */    public function setCalculatedValue($pValue = null)    {        if ($pValue !== null) {            $this->calculatedValue = (is_numeric($pValue)) ? (float) $pValue : $pValue;        }        return $this->notifyCacheController();    }    /**     *    Get old calculated value (cached)     *    This returns the value last calculated by MS Excel or whichever spreadsheet program was used to     *        create the original spreadsheet file.     *    Note that this value is not guaranteed to refelect the actual calculated value because it is     *        possible that auto-calculation was disabled in the original spreadsheet, and underlying data     *        values used by the formula have changed since it was last calculated.     *     *    @return    mixed     */    public function getOldCalculatedValue()    {        return $this->calculatedValue;    }    /**     *    Get cell data type     *     *    @return string     */    public function getDataType()    {        return $this->dataType;    }    /**     *    Set cell data type     *     *    @param    string $pDataType     *    @return    PHPExcel_Cell     */    public function setDataType($pDataType = PHPExcel_Cell_DataType::TYPE_STRING)    {        if ($pDataType == PHPExcel_Cell_DataType::TYPE_STRING2) {            $pDataType = PHPExcel_Cell_DataType::TYPE_STRING;        }        $this->dataType = $pDataType;        return $this->notifyCacheController();    }    /**     *  Identify if the cell contains a formula     *     *  @return boolean     */    public function isFormula()    {        return $this->dataType == PHPExcel_Cell_DataType::TYPE_FORMULA;    }    /**     *    Does this cell contain Data validation rules?     *     *    @return    boolean     *    @throws    PHPExcel_Exception     */    public function hasDataValidation()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot check for data validation when cell is not bound to a worksheet');        }        return $this->getWorksheet()->dataValidationExists($this->getCoordinate());    }    /**     *    Get Data validation rules     *     *    @return    PHPExcel_Cell_DataValidation     *    @throws    PHPExcel_Exception     */    public function getDataValidation()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot get data validation for cell that is not bound to a worksheet');        }        return $this->getWorksheet()->getDataValidation($this->getCoordinate());    }    /**     *    Set Data validation rules     *     *    @param    PHPExcel_Cell_DataValidation    $pDataValidation     *    @return    PHPExcel_Cell     *    @throws    PHPExcel_Exception     */    public function setDataValidation(PHPExcel_Cell_DataValidation $pDataValidation = null)    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot set data validation for cell that is not bound to a worksheet');        }        $this->getWorksheet()->setDataValidation($this->getCoordinate(), $pDataValidation);        return $this->notifyCacheController();    }    /**     *    Does this cell contain a Hyperlink?     *     *    @return boolean     *    @throws    PHPExcel_Exception     */    public function hasHyperlink()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot check for hyperlink when cell is not bound to a worksheet');        }        return $this->getWorksheet()->hyperlinkExists($this->getCoordinate());    }    /**     *    Get Hyperlink     *     *    @return    PHPExcel_Cell_Hyperlink     *    @throws    PHPExcel_Exception     */    public function getHyperlink()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot get hyperlink for cell that is not bound to a worksheet');        }        return $this->getWorksheet()->getHyperlink($this->getCoordinate());    }    /**     *    Set Hyperlink     *     *    @param    PHPExcel_Cell_Hyperlink    $pHyperlink     *    @return    PHPExcel_Cell     *    @throws    PHPExcel_Exception     */    public function setHyperlink(PHPExcel_Cell_Hyperlink $pHyperlink = null)    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot set hyperlink for cell that is not bound to a worksheet');        }        $this->getWorksheet()->setHyperlink($this->getCoordinate(), $pHyperlink);        return $this->notifyCacheController();    }    /**     *    Get parent worksheet     *     *    @return PHPExcel_CachedObjectStorage_CacheBase     */    public function getParent()    {        return $this->parent;    }    /**     *    Get parent worksheet     *     *    @return PHPExcel_Worksheet     */    public function getWorksheet()    {        return $this->parent->getParent();    }    /**     *    Is this cell in a merge range     *     *    @return boolean     */    public function isInMergeRange()    {        return (boolean) $this->getMergeRange();    }    /**     *    Is this cell the master (top left cell) in a merge range (that holds the actual data value)     *     *    @return boolean     */    public function isMergeRangeValueCell()    {        if ($mergeRange = $this->getMergeRange()) {            $mergeRange = PHPExcel_Cell::splitRange($mergeRange);            list($startCell) = $mergeRange[0];            if ($this->getCoordinate() === $startCell) {                return true;            }        }        return false;    }    /**     *    If this cell is in a merge range, then return the range     *     *    @return string     */    public function getMergeRange()    {        foreach ($this->getWorksheet()->getMergeCells() as $mergeRange) {            if ($this->isInRange($mergeRange)) {                return $mergeRange;            }        }        return false;    }    /**     *    Get cell style     *     *    @return    PHPExcel_Style     */    public function getStyle()    {        return $this->getWorksheet()->getStyle($this->getCoordinate());    }    /**     *    Re-bind parent     *     *    @param    PHPExcel_Worksheet $parent     *    @return    PHPExcel_Cell     */    public function rebindParent(PHPExcel_Worksheet $parent)    {        $this->parent = $parent->getCellCacheController();        return $this->notifyCacheController();    }    /**     *    Is cell in a specific range?     *     *    @param    string    $pRange        Cell range (e.g. A1:A1)     *    @return    boolean     */    public function isInRange($pRange = 'A1:A1')    {        list($rangeStart, $rangeEnd) = self::rangeBoundaries($pRange);        // Translate properties        $myColumn = self::columnIndexFromString($this->getColumn());        $myRow    = $this->getRow();        // Verify if cell is in range        return (($rangeStart[0] <= $myColumn) && ($rangeEnd[0] >= $myColumn) &&                ($rangeStart[1] <= $myRow) && ($rangeEnd[1] >= $myRow)               );    }    /**     *    Coordinate from string     *     *    @param    string    $pCoordinateString     *    @return    array    Array containing column and row (indexes 0 and 1)     *    @throws    PHPExcel_Exception     */    public static function coordinateFromString($pCoordinateString = 'A1')    {        if (preg_match(""/^([$]?[A-Z]{1,3})([$]?\d{1,7})$/"", $pCoordinateString, $matches)) {            return array($matches[1],$matches[2]);        } elseif ((strpos($pCoordinateString, ':') !== false) || (strpos($pCoordinateString, ',') !== false)) {            throw new PHPExcel_Exception('Cell coordinate string can not be a range of cells');        } elseif ($pCoordinateString == '') {            throw new PHPExcel_Exception('Cell coordinate can not be zero-length string');        }        throw new PHPExcel_Exception('Invalid cell coordinate '.$pCoordinateString);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_165,    Send notification to the cache controller\\\\n\\\\n    @return void\\\\n,  äalje obaveötenje kontroloru keö memorije,    public function notifyCacheController()    {        $this->parent->updateCacheData($this);        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_166,    Get cell coordinate column\\\\\\\\n\\\\\\\\n    @return    string\\\\\\\\n,Vra?a kolonu koordinata c?elije,    public function getColumn()    {        return $this->parent->getCurrentColumn();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_167,    Get cell coordinate row\n\n    @return    int\n,Vra?a red koordinata c?elije,    public function getRow()    {        return $this->parent->getCurrentRow();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_168,    Get cell coordinate\\\\n\\\\n    @return    string\\\\n,Vra?a koordinate c?elije,    public function getCoordinate()    {        return $this->parent->getCurrentAddress();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_170,    Get cell value with formatting\n\n    @return    string\n,Vra?a vrednost ?elije sa formatiranjem,"    public function getFormattedValue()    {        return (string) PHPExcel_Style_NumberFormat::toFormattedString(            $this->getCalculatedValue(),            $this->getStyle()                ->getNumberFormat()->getFormatCode()        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_171,"    Get old calculated value (cached)\\\\n    This returns the value last calculated by MS Excel or whichever spreadsheet program was used to\\\\n        create the original spreadsheet file.\\\\n    Note that this value is not guaranteed to refelect the actual calculated value because it is\\\\n        possible that auto-calculation was disabled in the original spreadsheet, and underlying data\\\\n        values used by the formula have changed since it was last calculated.\\\\n\\\\n    @return    mixed\\\\n",Vra?a staru izra?unatu vrednost (keöiranu),    public function getOldCalculatedValue()    {        return $this->calculatedValue;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_172,    Get cell data type\n\n    @return string\n,Vra?a tip podatka u ?eliji,    public function getDataType()    {        return $this->dataType;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_173,  Identify if the cell contains a formula\\\\\\\\n\\\\\\\\n  @return boolean\\\\\\\\n,Utvr?uje da li c?elija sadrûi formulu,    public function isFormula()    {        return $this->dataType == PHPExcel_Cell_DataType::TYPE_FORMULA;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_174,    Does this cell contain Data validation rules?\\n\\n    @return    boolean\\n    @throws    PHPExcel_Exception\\n,Da li ova c?elija sadrûi pravila za proveru podataka?,    public function hasDataValidation()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot check for data validation when cell is not bound to a worksheet');        }        return $this->getWorksheet()->dataValidationExists($this->getCoordinate());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_175,    Get Data validation rules\n\n    @return    PHPExcel_Cell_DataValidation\n    @throws    PHPExcel_Exception\n,Vra?a pravila za proveru podataka,    public function getDataValidation()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot get data validation for cell that is not bound to a worksheet');        }        return $this->getWorksheet()->getDataValidation($this->getCoordinate());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_178,    Get parent worksheet\\\\n\\\\n    @return PHPExcel_CachedObjectStorage_CacheBase\\\\n, Vra?a radni list roditelja,    public function getParent()    {        return $this->parent;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_180,    Is this cell in a merge range\\n\\n    @return boolean\\n,Da li je ova c?elija u opsegu spajanja,    public function isInMergeRange()    {        return (boolean) $this->getMergeRange();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_181,    Is this cell the master (top left cell) in a merge range (that holds the actual data value)\\\\\\\\n\\\\\\\\n    @return boolean\\\\\\\\n,Da li je ova c?elija glavna (gornja leva c?elija) u opsegu objedinjavanja (koji sadrûi stvarnu vrednost podataka),    public function isMergeRangeValueCell()    {        if ($mergeRange = $this->getMergeRange()) {            $mergeRange = PHPExcel_Cell::splitRange($mergeRange);            list($startCell) = $mergeRange[0];            if ($this->getCoordinate() === $startCell) {                return true;            }        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_182,"    If this cell is in a merge range, then return the range\n\n    @return string\n","Ako je ova c?elija u opsegu objedinjavanja, vra?a opseg",    public function getMergeRange()    {        foreach ($this->getWorksheet()->getMergeCells() as $mergeRange) {            if ($this->isInRange($mergeRange)) {                return $mergeRange;            }        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_183,    Get cell style\n\n    @return    PHPExcel_Style\n,Vra?a stil ?elije,    public function getStyle()    {        return $this->getWorksheet()->getStyle($this->getCoordinate());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_184,    Re-bind parent\\\\\\\\n\\\\\\\\n    @param    PHPExcel_Worksheet $parent\\\\\\\\n    @return    PHPExcel_Cell\\\\\\\\n,Ponovno povezivanje roditelja,    public function rebindParent(PHPExcel_Worksheet $parent)    {        $this->parent = $parent->getCellCacheController();        return $this->notifyCacheController();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_186," Compare 2 cells\n\n @param    PHPExcel_Cell    $a    Cell a\n @param    PHPExcel_Cell    $b    Cell b\n @return    int        Result of comparison (always -1 or 1, never zero!)\n",Poredi 2 ?elije,"    public static function compareCells(PHPExcel_Cell $a, PHPExcel_Cell $b)    {        if ($a->getRow() < $b->getRow()) {            return -1;        } elseif ($a->getRow() > $b->getRow()) {            return 1;        } elseif (self::columnIndexFromString($a->getColumn()) < self::columnIndexFromString($b->getColumn())) {            return -1;        } else {            return 1;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_188," Implement PHP __clone to create a deep clone, not just a shallow copy.\n","Implementira PHP __clone da kreira duboka kopija, ne samo plitka kopija. ",    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if ((is_object($value)) && ($key != 'parent')) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Comment_218," PHPExcel_Comment\\\\n\\\\n Copyright (c) 2006 - 2015 PHPExcel\\\\n\\\\n This library is free software; you can redistribute it and/or\\\\n modify it under the terms of the GNU Lesser General Public\\\\n License as published by the Free Software Foundation; either\\\\n version 2.1 of the License, or (at your option) any later version.\\\\n\\\\n This library is distributed in the hope that it will be useful,\\\\n but WITHOUT ANY WARRANTY; without even the implied warranty of\\\\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\n Lesser General Public License for more details.\\\\n\\\\n You should have received a copy of the GNU Lesser General Public\\\\n License along with this library; if not, write to the Free Software\\\\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\\\\n\\\\n @category   PHPExcel\\\\n @package    PHPExcel\\\\n @copyright  Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\\\\n @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\\\\n @version    ##VERSION##, ##DATE##\\\\n", PHPExcel_Comment,"class PHPExcel_Comment implements PHPExcel_IComparable{    /**     * Author     *     * @var string     */    private $author;    /**     * Rich text comment     *     * @var PHPExcel_RichText     */    private $text;    /**     * Comment width (CSS style, i.e. XXpx or YYpt)     *     * @var string     */    private $width = '96pt';    /**     * Left margin (CSS style, i.e. XXpx or YYpt)     *     * @var string     */    private $marginLeft = '59.25pt';    /**     * Top margin (CSS style, i.e. XXpx or YYpt)     *     * @var string     */    private $marginTop = '1.5pt';    /**     * Visible     *     * @var boolean     */    private $visible = false;    /**     * Comment height (CSS style, i.e. XXpx or YYpt)     *     * @var string     */    private $height = '55.5pt';    /**     * Comment fill color     *     * @var PHPExcel_Style_Color     */    private $fillColor;    /**     * Alignment     *     * @var string     */    private $alignment;    /**     * Create a new PHPExcel_Comment     *     * @throws PHPExcel_Exception     */    public function __construct()    {        // Initialise variables        $this->author    = 'Author';        $this->text      = new PHPExcel_RichText();        $this->fillColor = new PHPExcel_Style_Color('FFFFFFE1');        $this->alignment = PHPExcel_Style_Alignment::HORIZONTAL_GENERAL;    }    /**     * Get Author     *     * @return string     */    public function getAuthor()    {        return $this->author;    }    /**     * Set Author     *     * @param string $pValue     * @return PHPExcel_Comment     */    public function setAuthor($pValue = '')    {        $this->author = $pValue;        return $this;    }    /**     * Get Rich text comment     *     * @return PHPExcel_RichText     */    public function getText()    {        return $this->text;    }    /**     * Set Rich text comment     *     * @param PHPExcel_RichText $pValue     * @return PHPExcel_Comment     */    public function setText(PHPExcel_RichText $pValue)    {        $this->text = $pValue;        return $this;    }    /**     * Get comment width (CSS style, i.e. XXpx or YYpt)     *     * @return string     */    public function getWidth()    {        return $this->width;    }    /**     * Set comment width (CSS style, i.e. XXpx or YYpt)     *     * @param string $value     * @return PHPExcel_Comment     */    public function setWidth($value = '96pt')    {        $this->width = $value;        return $this;    }    /**     * Get comment height (CSS style, i.e. XXpx or YYpt)     *     * @return string     */    public function getHeight()    {        return $this->height;    }    /**     * Set comment height (CSS style, i.e. XXpx or YYpt)     *     * @param string $value     * @return PHPExcel_Comment     */    public function setHeight($value = '55.5pt')    {        $this->height = $value;        return $this;    }    /**     * Get left margin (CSS style, i.e. XXpx or YYpt)     *     * @return string     */    public function getMarginLeft()    {        return $this->marginLeft;    }    /**     * Set left margin (CSS style, i.e. XXpx or YYpt)     *     * @param string $value     * @return PHPExcel_Comment     */    public function setMarginLeft($value = '59.25pt')    {        $this->marginLeft = $value;        return $this;    }    /**     * Get top margin (CSS style, i.e. XXpx or YYpt)     *     * @return string     */    public function getMarginTop()    {        return $this->marginTop;    }    /**     * Set top margin (CSS style, i.e. XXpx or YYpt)     *     * @param string $value     * @return PHPExcel_Comment     */    public function setMarginTop($value = '1.5pt')    {        $this->marginTop = $value;        return $this;    }    /**     * Is the comment visible by default?     *     * @return boolean     */    public function getVisible()    {        return $this->visible;    }    /**     * Set comment default visibility     *     * @param boolean $value     * @return PHPExcel_Comment     */    public function setVisible($value = false)    {        $this->visible = $value;        return $this;    }    /**     * Get fill color     *     * @return PHPExcel_Style_Color     */    public function getFillColor()    {        return $this->fillColor;    }    /**     * Set Alignment     *     * @param string $pValue     * @return PHPExcel_Comment     */    public function setAlignment($pValue = PHPExcel_Style_Alignment::HORIZONTAL_GENERAL)    {        $this->alignment = $pValue;        return $this;    }    /**     * Get Alignment     *     * @return string     */    public function getAlignment()    {        return $this->alignment;    }    /**     * Get hash code     *     * @return string    Hash code     */    public function getHashCode()    {        return md5(            $this->author .            $this->text->getHashCode() .            $this->width .            $this->height .            $this->marginLeft .            $this->marginTop .            ($this->visible ? 1 : 0) .            $this->fillColor->getHashCode() .            $this->alignment .            __CLASS__        );    }    /**     * Implement PHP __clone to create a deep clone, not just a shallow copy.     */    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if (is_object($value)) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    }    /**     * Convert to string     *     * @return string     */    public function __toString()    {        return $this->text->getPlainText();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Comment_219, Create a new PHPExcel_Comment\\\\n\\\\n @throws PHPExcel_Exception\\\\n,Kreiranje novog PHPExcel_Comment,    public function __construct()    {        // Initialise variables        $this->author    = 'Author';        $this->text      = new PHPExcel_RichText();        $this->fillColor = new PHPExcel_Style_Color('FFFFFFE1');        $this->alignment = PHPExcel_Style_Alignment::HORIZONTAL_GENERAL;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Comment_230, Get hash code\n\n @return string    Hash code\n,Vra?a heö kod,    public function getHashCode()    {        return md5(            $this->author .            $this->text->getHashCode() .            $this->width .            $this->height .            $this->marginLeft .            $this->marginTop .            ($this->visible ? 1 : 0) .            $this->fillColor->getHashCode() .            $this->alignment .            __CLASS__        );    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Comment_232, Convert to string\n\n @return string\n,Konvertovanje u string,    public function __toString()    {        return $this->text->getPlainText();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_DocumentProperties_233," PHPExcel_DocumentProperties\\\\\\\\n\\\\\\\\n Copyright (c) 2006 - 2015 PHPExcel\\\\\\\\n\\\\\\\\n This library is free software; you can redistribute it and/or\\\\\\\\n modify it under the terms of the GNU Lesser General Public\\\\\\\\n License as published by the Free Software Foundation; either\\\\\\\\n version 2.1 of the License, or (at your option) any later version.\\\\\\\\n\\\\\\\\n This library is distributed in the hope that it will be useful,\\\\\\\\n but WITHOUT ANY WARRANTY; without even the implied warranty of\\\\\\\\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\\\\\n Lesser General Public License for more details.\\\\\\\\n\\\\\\\\n You should have received a copy of the GNU Lesser General Public\\\\\\\\n License along with this library; if not, write to the Free Software\\\\\\\\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\\\\\\\\n\\\\\\\\n @category    PHPExcel\\\\\\\\n @package    PHPExcel\\\\\\\\n @copyright    Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\\\\\\\\n @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\\\\\\\\n @version    ##VERSION##, ##DATE##\\\\\\\\n", PHPExcel_DocumentProperties,"class PHPExcel_DocumentProperties{    /** constants */    const PROPERTY_TYPE_BOOLEAN = 'b';    const PROPERTY_TYPE_INTEGER = 'i';    const PROPERTY_TYPE_FLOAT   = 'f';    const PROPERTY_TYPE_DATE    = 'd';    const PROPERTY_TYPE_STRING  = 's';    const PROPERTY_TYPE_UNKNOWN = 'u';    /**     * Creator     *     * @var string     */    private $creator = 'Unknown Creator';    /**     * LastModifiedBy     *     * @var string     */    private $lastModifiedBy;    /**     * Created     *     * @var datetime     */    private $created;    /**     * Modified     *     * @var datetime     */    private $modified;    /**     * Title     *     * @var string     */    private $title = 'Untitled Spreadsheet';    /**     * Description     *     * @var string     */    private $description = '';    /**     * Subject     *     * @var string     */    private $subject = '';    /**     * Keywords     *     * @var string     */    private $keywords = '';    /**     * Category     *     * @var string     */    private $category = '';    /**     * Manager     *     * @var string     */    private $manager = '';    /**     * Company     *     * @var string     */    private $company = 'Microsoft Corporation';    /**     * Custom Properties     *     * @var string     */    private $customProperties = array();    /**     * Create a new PHPExcel_DocumentProperties     */    public function __construct()    {        // Initialise values        $this->lastModifiedBy = $this->creator;        $this->created  = time();        $this->modified = time();    }    /**     * Get Creator     *     * @return string     */    public function getCreator()    {        return $this->creator;    }    /**     * Set Creator     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setCreator($pValue = '')    {        $this->creator = $pValue;        return $this;    }    /**     * Get Last Modified By     *     * @return string     */    public function getLastModifiedBy()    {        return $this->lastModifiedBy;    }    /**     * Set Last Modified By     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setLastModifiedBy($pValue = '')    {        $this->lastModifiedBy = $pValue;        return $this;    }    /**     * Get Created     *     * @return datetime     */    public function getCreated()    {        return $this->created;    }    /**     * Set Created     *     * @param datetime $pValue     * @return PHPExcel_DocumentProperties     */    public function setCreated($pValue = null)    {        if ($pValue === null) {            $pValue = time();        } elseif (is_string($pValue)) {            if (is_numeric($pValue)) {                $pValue = intval($pValue);            } else {                $pValue = strtotime($pValue);            }        }        $this->created = $pValue;        return $this;    }    /**     * Get Modified     *     * @return datetime     */    public function getModified()    {        return $this->modified;    }    /**     * Set Modified     *     * @param datetime $pValue     * @return PHPExcel_DocumentProperties     */    public function setModified($pValue = null)    {        if ($pValue === null) {            $pValue = time();        } elseif (is_string($pValue)) {            if (is_numeric($pValue)) {                $pValue = intval($pValue);            } else {                $pValue = strtotime($pValue);            }        }        $this->modified = $pValue;        return $this;    }    /**     * Get Title     *     * @return string     */    public function getTitle()    {        return $this->title;    }    /**     * Set Title     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setTitle($pValue = '')    {        $this->title = $pValue;        return $this;    }    /**     * Get Description     *     * @return string     */    public function getDescription()    {        return $this->description;    }    /**     * Set Description     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setDescription($pValue = '')    {        $this->description = $pValue;        return $this;    }    /**     * Get Subject     *     * @return string     */    public function getSubject()    {        return $this->subject;    }    /**     * Set Subject     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setSubject($pValue = '')    {        $this->subject = $pValue;        return $this;    }    /**     * Get Keywords     *     * @return string     */    public function getKeywords()    {        return $this->keywords;    }    /**     * Set Keywords     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setKeywords($pValue = '')    {        $this->keywords = $pValue;        return $this;    }    /**     * Get Category     *     * @return string     */    public function getCategory()    {        return $this->category;    }    /**     * Set Category     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setCategory($pValue = '')    {        $this->category = $pValue;        return $this;    }    /**     * Get Company     *     * @return string     */    public function getCompany()    {        return $this->company;    }    /**     * Set Company     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setCompany($pValue = '')    {        $this->company = $pValue;        return $this;    }    /**     * Get Manager     *     * @return string     */    public function getManager()    {        return $this->manager;    }    /**     * Set Manager     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setManager($pValue = '')    {        $this->manager = $pValue;        return $this;    }    /**     * Get a List of Custom Property Names     *     * @return array of string     */    public function getCustomProperties()    {        return array_keys($this->customProperties);    }    /**     * Check if a Custom Property is defined     *     * @param string $propertyName     * @return boolean     */    public function isCustomPropertySet($propertyName)    {        return isset($this->customProperties[$propertyName]);    }    /**     * Get a Custom Property Value     *     * @param string $propertyName     * @return string     */    public function getCustomPropertyValue($propertyName)    {        if (isset($this->customProperties[$propertyName])) {            return $this->customProperties[$propertyName]['value'];        }    }    /**     * Get a Custom Property Type     *     * @param string $propertyName     * @return string     */    public function getCustomPropertyType($propertyName)    {        if (isset($this->customProperties[$propertyName])) {            return $this->customProperties[$propertyName]['type'];        }    }    /**     * Set a Custom Property     *     * @param string $propertyName     * @param mixed $propertyValue     * @param string $propertyType     *      'i'    : Integer     *   'f' : Floating Point     *   's' : String     *   'd' : Date/Time     *   'b' : Boolean     * @return PHPExcel_DocumentProperties     */    public function setCustomProperty($propertyName, $propertyValue = '', $propertyType = null)    {        if (($propertyType === null) || (!in_array($propertyType, array(self::PROPERTY_TYPE_INTEGER,                                                                        self::PROPERTY_TYPE_FLOAT,                                                                        self::PROPERTY_TYPE_STRING,                                                                        self::PROPERTY_TYPE_DATE,                                                                        self::PROPERTY_TYPE_BOOLEAN)))) {            if ($propertyValue === null) {                $propertyType = self::PROPERTY_TYPE_STRING;            } elseif (is_float($propertyValue)) {                $propertyType = self::PROPERTY_TYPE_FLOAT;            } elseif (is_int($propertyValue)) {                $propertyType = self::PROPERTY_TYPE_INTEGER;            } elseif (is_bool($propertyValue)) {                $propertyType = self::PROPERTY_TYPE_BOOLEAN;            } else {                $propertyType = self::PROPERTY_TYPE_STRING;            }        }        $this->customProperties[$propertyName] = array(            'value' => $propertyValue,            'type' => $propertyType        );        return $this;    }    /**     * Implement PHP __clone to create a deep clone, not just a shallow copy.     */    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if (is_object($value)) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    }    public static function convertProperty($propertyValue, $propertyType)    {        switch ($propertyType) {            case 'empty':     //    Empty                return '';                break;            case 'null':      //    Null                return null;                break;            case 'i1':        //    1-Byte Signed Integer            case 'i2':        //    2-Byte Signed Integer            case 'i4':        //    4-Byte Signed Integer            case 'i8':        //    8-Byte Signed Integer            case 'int':       //    Integer                return (int) $propertyValue;                break;            case 'ui1':       //    1-Byte Unsigned Integer            case 'ui2':       //    2-Byte Unsigned Integer            case 'ui4':       //    4-Byte Unsigned Integer            case 'ui8':       //    8-Byte Unsigned Integer            case 'uint':      //    Unsigned Integer                return abs((int) $propertyValue);                break;            case 'r4':        //    4-Byte Real Number            case 'r8':        //    8-Byte Real Number            case 'decimal':   //    Decimal                return (float) $propertyValue;                break;            case 'lpstr':     //    LPSTR            case 'lpwstr':    //    LPWSTR            case 'bstr':      //    Basic String                return $propertyValue;                break;            case 'date':      //    Date and Time            case 'filetime':  //    File Time                return strtotime($propertyValue);                break;            case 'bool':     //    Boolean                return ($propertyValue == 'true') ? true : false;                break;            case 'cy':       //    Currency            case 'error':    //    Error Status Code            case 'vector':   //    Vector            case 'array':    //    Array            case 'blob':     //    Binary Blob            case 'oblob':    //    Binary Blob Object            case 'stream':   //    Binary Stream            case 'ostream':  //    Binary Stream Object            case 'storage':  //    Binary Storage            case 'ostorage': //    Binary Storage Object            case 'vstream':  //    Binary Versioned Stream            case 'clsid':    //    Class ID            case 'cf':       //    Clipboard Data                return $propertyValue;                break;        }        return $propertyValue;    }    public static function convertPropertyType($propertyType)    {        switch ($propertyType) {            case 'i1':       //    1-Byte Signed Integer            case 'i2':       //    2-Byte Signed Integer            case 'i4':       //    4-Byte Signed Integer            case 'i8':       //    8-Byte Signed Integer            case 'int':      //    Integer            case 'ui1':      //    1-Byte Unsigned Integer            case 'ui2':      //    2-Byte Unsigned Integer            case 'ui4':      //    4-Byte Unsigned Integer            case 'ui8':      //    8-Byte Unsigned Integer            case 'uint':     //    Unsigned Integer                return self::PROPERTY_TYPE_INTEGER;                break;            case 'r4':       //    4-Byte Real Number            case 'r8':       //    8-Byte Real Number            case 'decimal':  //    Decimal                return self::PROPERTY_TYPE_FLOAT;                break;            case 'empty':    //    Empty            case 'null':     //    Null            case 'lpstr':    //    LPSTR            case 'lpwstr':   //    LPWSTR            case 'bstr':     //    Basic String                return self::PROPERTY_TYPE_STRING;                break;            case 'date':     //    Date and Time            case 'filetime': //    File Time                return self::PROPERTY_TYPE_DATE;                break;            case 'bool':     //    Boolean                return self::PROPERTY_TYPE_BOOLEAN;                break;            case 'cy':       //    Currency            case 'error':    //    Error Status Code            case 'vector':   //    Vector            case 'array':    //    Array            case 'blob':     //    Binary Blob            case 'oblob':    //    Binary Blob Object            case 'stream':   //    Binary Stream            case 'ostream':  //    Binary Stream Object            case 'storage':  //    Binary Storage            case 'ostorage': //    Binary Storage Object            case 'vstream':  //    Binary Versioned Stream            case 'clsid':    //    Class ID            case 'cf':       //    Clipboard Data                return self::PROPERTY_TYPE_UNKNOWN;                break;        }        return self::PROPERTY_TYPE_UNKNOWN;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_DocumentProperties_234, Create a new PHPExcel_DocumentProperties\\\\\\\\n, Kreiranje novog PHPExcel_DocumentProperties,    public function __construct()    {        // Initialise values        $this->lastModifiedBy = $this->creator;        $this->created  = time();        $this->modified = time();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_DocumentSecurity_251," PHPExcel_DocumentSecurity\\\\n\\\\n Copyright (c) 2006 - 2015 PHPExcel\\\\n\\\\n This library is free software; you can redistribute it and/or\\\\n modify it under the terms of the GNU Lesser General Public\\\\n License as published by the Free Software Foundation; either\\\\n version 2.1 of the License, or (at your option) any later version.\\\\n\\\\n This library is distributed in the hope that it will be useful,\\\\n but WITHOUT ANY WARRANTY; without even the implied warranty of\\\\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\n Lesser General Public License for more details.\\\\n\\\\n You should have received a copy of the GNU Lesser General Public\\\\n License along with this library; if not, write to the Free Software\\\\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\\\\n\\\\n @category   PHPExcel\\\\n @package    PHPExcel\\\\n @copyright  Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\\\\n @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\\\\n @version    ##VERSION##, ##DATE##\\\\n", PHPExcel_DocumentSecurity,"class PHPExcel_DocumentSecurity{    /**     * LockRevision     *     * @var boolean     */    private $lockRevision;    /**     * LockStructure     *     * @var boolean     */    private $lockStructure;    /**     * LockWindows     *     * @var boolean     */    private $lockWindows;    /**     * RevisionsPassword     *     * @var string     */    private $revisionsPassword;    /**     * WorkbookPassword     *     * @var string     */    private $workbookPassword;    /**     * Create a new PHPExcel_DocumentSecurity     */    public function __construct()    {        // Initialise values        $this->lockRevision      = false;        $this->lockStructure     = false;        $this->lockWindows       = false;        $this->revisionsPassword = '';        $this->workbookPassword  = '';    }    /**     * Is some sort of document security enabled?     *     * @return boolean     */    public function isSecurityEnabled()    {        return  $this->lockRevision ||                $this->lockStructure ||                $this->lockWindows;    }    /**     * Get LockRevision     *     * @return boolean     */    public function getLockRevision()    {        return $this->lockRevision;    }    /**     * Set LockRevision     *     * @param boolean $pValue     * @return PHPExcel_DocumentSecurity     */    public function setLockRevision($pValue = false)    {        $this->lockRevision = $pValue;        return $this;    }    /**     * Get LockStructure     *     * @return boolean     */    public function getLockStructure()    {        return $this->lockStructure;    }    /**     * Set LockStructure     *     * @param boolean $pValue     * @return PHPExcel_DocumentSecurity     */    public function setLockStructure($pValue = false)    {        $this->lockStructure = $pValue;        return $this;    }    /**     * Get LockWindows     *     * @return boolean     */    public function getLockWindows()    {        return $this->lockWindows;    }    /**     * Set LockWindows     *     * @param boolean $pValue     * @return PHPExcel_DocumentSecurity     */    public function setLockWindows($pValue = false)    {        $this->lockWindows = $pValue;        return $this;    }    /**     * Get RevisionsPassword (hashed)     *     * @return string     */    public function getRevisionsPassword()    {        return $this->revisionsPassword;    }    /**     * Set RevisionsPassword     *     * @param string     $pValue     * @param boolean     $pAlreadyHashed If the password has already been hashed, set this to true     * @return PHPExcel_DocumentSecurity     */    public function setRevisionsPassword($pValue = '', $pAlreadyHashed = false)    {        if (!$pAlreadyHashed) {            $pValue = PHPExcel_Shared_PasswordHasher::hashPassword($pValue);        }        $this->revisionsPassword = $pValue;        return $this;    }    /**     * Get WorkbookPassword (hashed)     *     * @return string     */    public function getWorkbookPassword()    {        return $this->workbookPassword;    }    /**     * Set WorkbookPassword     *     * @param string     $pValue     * @param boolean     $pAlreadyHashed If the password has already been hashed, set this to true     * @return PHPExcel_DocumentSecurity     */    public function setWorkbookPassword($pValue = '', $pAlreadyHashed = false)    {        if (!$pAlreadyHashed) {            $pValue = PHPExcel_Shared_PasswordHasher::hashPassword($pValue);        }        $this->workbookPassword = $pValue;        return $this;    }    /**     * Implement PHP __clone to create a deep clone, not just a shallow copy.     */    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if (is_object($value)) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Exception_260, PHPExcel_Exception\\\\n\\\\n @category   PHPExcel\\\\n @package    PHPExcel\\\\n @copyright  Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\\\\n, PHPExcel_Exception,"class PHPExcel_Exception extends Exception{    /**     * Error handler callback     *     * @param mixed $code     * @param mixed $string     * @param mixed $file     * @param mixed $line     * @param mixed $context     */    public static function errorHandlerCallback($code, $string, $file, $line, $context)    {        $e = new self($string, $code);        $e->line = $line;        $e->file = $file;        throw $e;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Exception_261, Error handler callback\\n\\n @param mixed $code\\n @param mixed $string\\n @param mixed $file\\n @param mixed $line\\n @param mixed $context\\n,Povratni poziv za obradu greöke,"    public static function errorHandlerCallback($code, $string, $file, $line, $context)    {        $e = new self($string, $code);        $e->line = $line;        $e->file = $file;        throw $e;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_105, Check if a sheet with a specified name already exists\\\\n\\\\n @param  string $pSheetName  Name of the worksheet to check\\\\n @return boolean\\\\n,Proverava da li tabela sa navedenim imenom vec? postoji,    public function sheetNameExists($pSheetName)    {        return ($this->getSheetByName($pSheetName) !== null);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_108, Set index for sheet by sheet name.\\n\\n @param  string $sheetName Sheet name to modify index for\\n @param  int $newIndex New index for the sheet\\n @return int New sheet index\\n @throws PHPExcel_Exception\\n,Podeöavanje indeks za list na osnovu imenu lista.,"    public function setIndexByName($sheetName, $newIndex)    {        $oldIndex = $this->getIndex($this->getSheetByName($sheetName));        $pSheet = array_splice(            $this->workSheetCollection,            $oldIndex,            1        );        array_splice(            $this->workSheetCollection,            $newIndex,            0,            $pSheet        );        return $newIndex;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_109, Get sheet count\n\n @return int\n,Vra?a broj listova,    public function getSheetCount()    {        return count($this->workSheetCollection);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_111, Get sheet names\n\n @return string[]\n,Vra?a nazive listova,    public function getSheetNames()    {        $returnValue = array();        $worksheetCount = $this->getSheetCount();        for ($i = 0; $i < $worksheetCount; ++$i) {            $returnValue[] = $this->getSheet($i)->getTitle();        }        return $returnValue;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_113, Add named range\\n\\n @param  PHPExcel_NamedRange $namedRange\\n @return boolean\\n,Dodaje imenovani ospeg,    public function addNamedRange(PHPExcel_NamedRange $namedRange)    {        if ($namedRange->getScope() == null) {            // global scope            $this->namedRanges[$namedRange->getName()] = $namedRange;        } else {            // local scope            $this->namedRanges[$namedRange->getScope()->getTitle().'!'.$namedRange->getName()] = $namedRange;        }        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_114, Get worksheet iterator\\n\\n @return PHPExcel_WorksheetIterator\\n,Vra?a iterator radnog lista,    public function getWorksheetIterator()    {        return new PHPExcel_WorksheetIterator($this);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_115, Copy workbook (!= clone!)\\\\n\\\\n @return PHPExcel\\\\n,Kopiranje radne knjige (!= klona),    public function copy()    {        $copied = clone $this;        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            $this->workSheetCollection[$i] = $this->workSheetCollection[$i]->copy();            $this->workSheetCollection[$i]->rebindParent($this);        }        return $copied;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_119, Add a cellXf to the workbook\\\\n\\\\n @param PHPExcel_Style $style\\\\n,Dodavanje cellXf u radnu knjigu,    public function addCellXf(PHPExcel_Style $style)    {        $this->cellXfCollection[] = $style;        $style->setIndex(count($this->cellXfCollection) - 1);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_120, Get the cellXf supervisor\n\n @return PHPExcel_Style\n, Vra?a supervizora cellXf,    public function getCellXfSupervisor()    {        return $this->cellXfSupervisor;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_121, Get the workbook collection of cellStyleXfs\\\\\\\\n\\\\\\\\n @return PHPExcel_Style[]\\\\\\\\n, Vra?a kolekciju ranih knjiga cellStyleXfs,    public function getCellStyleXfCollection()    {        return $this->cellStyleXfCollection;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_89, Is the project signed ?\\n\\n @return boolean true|false\\n, Da li je projekat potpisan?,    public function hasMacrosCertificate()    {        return !is_null($this->macrosCertificate);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_91," Remove all macros, certificate from spreadsheet\n\n","Uklanja sve markonaredbe, sertifikate iz tabele",    public function discardMacros()    {        $this->hasMacros=false;        $this->macrosCode=null;        $this->macrosCertificate=null;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_92, return the extension of a filename. Internal use for a array_map callback (php<5.3 don't like lambda function)\\\\\\\\n\\\\\\\\n,vra?a ekstenziju imena fajla. Interna upotreba je za povratni poziv array_map (php<5.3 se ne svi?aju lambda funkcije),"    private function getExtensionOnly($ThePath)    {        return pathinfo($ThePath, PATHINFO_EXTENSION);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_93, This workbook have a custom UI ?\\\\\\\\n\\\\\\\\n @return boolean true|false\\\\\\\\n,Ima li ova radna knjiga prilago?eni korisni?ki interfejs? ,    public function hasRibbon()    {        return !is_null($this->ribbonXMLData);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_94, This workbook have additionnal object for the ribbon ?\\\\n\\\\n @return boolean true|false\\\\n,Ima li ova radna knjiga dodatni objekat za vrpcu? ,    public function hasRibbonBinObjects()    {        return !is_null($this->ribbonBinObjects);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_PHPExcel_98," Disconnect all worksheets from this PHPExcel workbook object,\\n    typically so that the PHPExcel object can be unset\\n\\n"," Odspojiti sve radne listove iz ovog PHPExcel objekta, obi?no da bi se mogao PHPExcel objekat poniötiti",    public function disconnectWorksheets()    {        $worksheet = null;        foreach ($this->workSheetCollection as $k => &$worksheet) {            $worksheet->disconnectCells();            $this->workSheetCollection[$k] = null;        }        unset($worksheet);        $this->workSheetCollection = array();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_AbstractCollection_971, Get item by index\\n\\n @param int $index\\n @return \\\\PhpOffice\\\\PhpWord\\\\Element\\\\AbstractContainer\\n,Vra?a stavku na osnovu indeksa,"    public function getItem($index)    {        if (array_key_exists($index, $this->items)) {            return $this->items[$index];        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_AbstractCollection_974, Get item count\\n\\n @return int\\n,Vra?a broj stavki,    public function countItems()    {        return count($this->items);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_CollectionTest_1048, Test collection\n,Testna kolekcija,"    public function testCollection()    {        $object = new Footnotes();        $object->addItem(new Footnote()); // addItem #1        $this->assertEquals(2, $object->addItem(new Footnote())); // addItem #2. Should returns new item index        $this->assertCount(2, $object->getItems()); // getItems returns array        $this->assertInstanceOf('PhpOffice\\PhpWord\\Element\\Footnote', $object->getItem(1)); // getItem returns object        $this->assertNull($object->getItem(3)); // getItem returns null when invalid index is referenced        $object->setItem(2, null); // Set item #2 to null        $this->assertNull($object->getItem(2)); // Check if it's null    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_FootnotePropertiesTest_1053, Test throws exception if wrong number restart given\\n\\n @expectedException \\\\InvalidArgumentException\\n, Test izbacuje izuzetak ako je pogreöan broj restarta dat,    public function testWrongNumRestart()    {        $footnoteProp = new FootnoteProperties();        $footnoteProp->setNumRestart(NumberFormat::LOWER_ROMAN);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_IOFactory_872, Check if it's a concrete class (not abstract nor interface)\\n\\n @param string $class\\n @return bool\\n,Porverava da li je konkretna klasa (da nije apstraktna ni interfejs) ,    private static function isConcreteClass($class)    {        $reflection = new \ReflectionClass($class);        return !$reflection->isAbstract() && !$reflection->isInterface();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_MediaTest_985, Get header media elements\\n,Vra?a elemente zaglavalja medija,"    public function testGetHeaderMediaElementsWithNull()    {        $this->assertEquals(array(), Media::getElements('header'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_MediaTest_986, Get footer media elements\n,Vra?a elemente podnoûja medija,"    public function testGetFooterMediaElementsWithNull()    {        $this->assertEquals(array(), Media::getElements('footer'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_MediaTest_987, Count section media elements\n,Broji elemente medija u odeljku,"    public function testCountSectionMediaElementsWithNull()    {        $this->assertEquals(0, Media::countElements('section'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_MediaTest_990, Add header media element\\n, Add header media element,"    public function testAddHeaderMediaElement()    {        $local = __DIR__ . '/_files/images/mars.jpg';        $remote = self::getRemoteImageUrl();        Media::addElement('header1', 'image', $local, new Image($local));        Media::addElement('header1', 'image', $local, new Image($local));        Media::addElement('header1', 'image', $remote, new Image($remote));        $this->assertCount(2, Media::getElements('header1'));        $this->assertEmpty(Media::getElements('header2'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_MediaTest_992, Add image element exception\n\n @expectedException \\Exception\n @expectedExceptionMessage Image object not assigned.\n,Dodaje izuzetak elementa slike,"    public function testAddElementImageException()    {        Media::addElement('section', 'image', __DIR__ . '/_files/images/mars.jpg');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Media_878, Get Footer Media Elements Count\n\n @deprecated 0.10.0\n\n @param string $key\n\n @return int\n\n @codeCoverageIgnore\n,Vra?a broj podnoûja elemenata medija ,    public static function countFooterMediaElements($key)    {        return self::countElements($key);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_1001, Test load template\n\n @deprecated 0.12.0\n,äablon za probno optere?enje,"    public function testLoadTemplate()    {        $templateFqfn = __DIR__ . '/_files/templates/blank.docx';        $phpWord = new PhpWord();        $this->assertInstanceOf(            'PhpOffice\\PhpWord\\TemplateProcessor',            $phpWord->loadTemplate($templateFqfn)        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_1003, Test save\\n,Testno ?uvanje,"    public function testSave()    {        $this->setOutputCallback(function () {        });        $phpWord = new PhpWord();        $section = $phpWord->addSection();        $section->addText('Hello world!');        $this->assertTrue($phpWord->save('test.docx', 'Word2007', true));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_1004, Test calling undefined method\\n\\n @expectedException \\\\BadMethodCallException\\n @expectedExceptionMessage is not defined\\n,Testno pozvianje nedefinisane metode,    public function testCallUndefinedMethod()    {        $phpWord = new PhpWord();        $phpWord->undefinedMethod();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_995, Test create/get section\\n,Test kreiranje/pribavljanje sekcije,"    public function testCreateGetSections()    {        $phpWord = new PhpWord();        $phpWord->addSection();        $this->assertCount(1, $phpWord->getSections());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_997, Test set/get default font size\\n,Test postavljanje/vra?anje zadate veli?ine fonta,"    public function testSetGetDefaultFontSize()    {        $phpWord = new PhpWord();        $fontSize = 16;        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, $phpWord->getDefaultFontSize());        $phpWord->setDefaultFontSize($fontSize);        $this->assertEquals($fontSize, $phpWord->getDefaultFontSize());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWordTest_999, Test add styles\\n, Test dodavanje stila,"    public function testAddStyles()    {        $phpWord = new PhpWord();        $styles = array(            'Paragraph' => 'Paragraph',            'Font'      => 'Font',            'Table'     => 'Table',            'Link'      => 'Font',        );        foreach ($styles as $key => $value) {            $method = ""add{$key}Style"";            $styleId = ""{$key} Style"";            $phpWord->$method($styleId, array());            $this->assertInstanceOf(""PhpOffice\\PhpWord\\Style\\{$value}"", Style::getStyle($styleId));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWord_880," PHPWord main class\\n\\n @method Collection\\\\Titles getTitles()\\n @method Collection\\\\Footnotes getFootnotes()\\n @method Collection\\\\Endnotes getEndnotes()\\n @method Collection\\\\Charts getCharts()\\n @method Collection\\\\Comments getComments()\\n @method int addBookmark(Element\\\\Bookmark $bookmark)\\n @method int addTitle(Element\\\\Title $title)\\n @method int addFootnote(Element\\\\Footnote $footnote)\\n @method int addEndnote(Element\\\\Endnote $endnote)\\n @method int addChart(Element\\\\Chart $chart)\\n @method int addComment(Element\\\\Comment $comment)\\n\\n @method Style\\\\Paragraph addParagraphStyle(string $styleName, mixed $styles)\\n @method Style\\\\Font addFontStyle(string $styleName, mixed $fontStyle, mixed $paragraphStyle = null)\\n @method Style\\\\Font addLinkStyle(string $styleName, mixed $styles)\\n @method Style\\\\Font addTitleStyle(mixed $depth, mixed $fontStyle, mixed $paragraphStyle = null)\\n @method Style\\\\Table addTableStyle(string $styleName, mixed $styleTable, mixed $styleFirstRow = null)\\n @method Style\\\\Numbering addNumberingStyle(string $styleName, mixed $styles)\\n", PHPWord main class,"class PhpWord{    /**     * Default font settings     *     * @deprecated 0.11.0 Use Settings constants     *     * @const string|int     */    const DEFAULT_FONT_NAME = Settings::DEFAULT_FONT_NAME;    /**     * @deprecated 0.11.0 Use Settings constants     */    const DEFAULT_FONT_SIZE = Settings::DEFAULT_FONT_SIZE;    /**     * @deprecated 0.11.0 Use Settings constants     */    const DEFAULT_FONT_COLOR = Settings::DEFAULT_FONT_COLOR;    /**     * @deprecated 0.11.0 Use Settings constants     */    const DEFAULT_FONT_CONTENT_TYPE = Settings::DEFAULT_FONT_CONTENT_TYPE;    /**     * Collection of sections     *     * @var \PhpOffice\PhpWord\Element\Section[]     */    private $sections = array();    /**     * Collections     *     * @var array     */    private $collections = array();    /**     * Metadata     *     * @var array     * @since 0.12.0     */    private $metadata = array();    /**     * Create new instance     *     * Collections are created dynamically     */    public function __construct()    {        // Reset Media and styles        Media::resetElements();        Style::resetStyles();        // Collection        $collections = array('Bookmarks', 'Titles', 'Footnotes', 'Endnotes', 'Charts', 'Comments');        foreach ($collections as $collection) {            $class = 'PhpOffice\\PhpWord\\Collection\\' . $collection;            $this->collections[$collection] = new $class();        }        // Metadata        $metadata = array('DocInfo', 'Settings', 'Compatibility');        foreach ($metadata as $meta) {            $class = 'PhpOffice\\PhpWord\\Metadata\\' . $meta;            $this->metadata[$meta] = new $class();        }    }    /**     * Dynamic function call to reduce static dependency     *     * @since 0.12.0     *     * @param mixed $function     * @param mixed $args     *     * @throws \BadMethodCallException     *     * @return mixed     */    public function __call($function, $args)    {        $function = strtolower($function);        $getCollection = array();        $addCollection = array();        $addStyle = array();        $collections = array('Bookmark', 'Title', 'Footnote', 'Endnote', 'Chart', 'Comment');        foreach ($collections as $collection) {            $getCollection[] = strtolower(""get{$collection}s"");            $addCollection[] = strtolower(""add{$collection}"");        }        $styles = array('Paragraph', 'Font', 'Table', 'Numbering', 'Link', 'Title');        foreach ($styles as $style) {            $addStyle[] = strtolower(""add{$style}Style"");        }        // Run get collection method        if (in_array($function, $getCollection)) {            $key = ucfirst(str_replace('get', '', $function));            return $this->collections[$key];        }        // Run add collection item method        if (in_array($function, $addCollection)) {            $key = ucfirst(str_replace('add', '', $function) . 's');            /** @var \PhpOffice\PhpWord\Collection\AbstractCollection $collectionObject */            $collectionObject = $this->collections[$key];            return $collectionObject->addItem(isset($args[0]) ? $args[0] : null);        }        // Run add style method        if (in_array($function, $addStyle)) {            return forward_static_call_array(array('PhpOffice\\PhpWord\\Style', $function), $args);        }        // Exception        throw new \BadMethodCallException(""Method $function is not defined."");    }    /**     * Get document properties object     *     * @return \PhpOffice\PhpWord\Metadata\DocInfo     */    public function getDocInfo()    {        return $this->metadata['DocInfo'];    }    /**     * Get protection     *     * @return \PhpOffice\PhpWord\Metadata\Protection     * @since 0.12.0     * @deprecated Get the Document protection from PhpWord->getSettings()->getDocumentProtection();     * @codeCoverageIgnore     */    public function getProtection()    {        return $this->getSettings()->getDocumentProtection();    }    /**     * Get compatibility     *     * @return \PhpOffice\PhpWord\Metadata\Compatibility     * @since 0.12.0     */    public function getCompatibility()    {        return $this->metadata['Compatibility'];    }    /**     * Get compatibility     *     * @return \PhpOffice\PhpWord\Metadata\Settings     * @since 0.14.0     */    public function getSettings()    {        return $this->metadata['Settings'];    }    /**     * Get all sections     *     * @return \PhpOffice\PhpWord\Element\Section[]     */    public function getSections()    {        return $this->sections;    }    /**     * Returns the section at the requested position     *     * @param int $index     * @return \PhpOffice\PhpWord\Element\Section|null     */    public function getSection($index)    {        if (array_key_exists($index, $this->sections)) {            return $this->sections[$index];        }        return null;    }    /**     * Create new section     *     * @param array $style     * @return \PhpOffice\PhpWord\Element\Section     */    public function addSection($style = null)    {        $section = new Section(count($this->sections) + 1, $style);        $section->setPhpWord($this);        $this->sections[] = $section;        return $section;    }    /**     * Sorts the sections using the callable passed     *     * @see http://php.net/manual/en/function.usort.php for usage     * @param callable $sorter     */    public function sortSections($sorter)    {        usort($this->sections, $sorter);    }    /**     * Get default font name     *     * @return string     */    public function getDefaultFontName()    {        return Settings::getDefaultFontName();    }    /**     * Set default font name.     *     * @param string $fontName     */    public function setDefaultFontName($fontName)    {        Settings::setDefaultFontName($fontName);    }    /**     * Get default font size     *     * @return int     */    public function getDefaultFontSize()    {        return Settings::getDefaultFontSize();    }    /**     * Set default font size.     *     * @param int $fontSize     */    public function setDefaultFontSize($fontSize)    {        Settings::setDefaultFontSize($fontSize);    }    /**     * Set default paragraph style definition to styles.xml     *     * @param array $styles Paragraph style definition     * @return \PhpOffice\PhpWord\Style\Paragraph     */    public function setDefaultParagraphStyle($styles)    {        return Style::setDefaultParagraphStyle($styles);    }    /**     * Load template by filename     *     * @deprecated 0.12.0 Use `new TemplateProcessor($documentTemplate)` instead.     *     * @param  string $filename Fully qualified filename     *     * @throws \PhpOffice\PhpWord\Exception\Exception     *     * @return TemplateProcessor     *     * @codeCoverageIgnore     */    public function loadTemplate($filename)    {        if (file_exists($filename)) {            return new TemplateProcessor($filename);        }        throw new Exception(""Template file {$filename} not found."");    }    /**     * Save to file or download     *     * All exceptions should already been handled by the writers     *     * @param string $filename     * @param string $format     * @param bool $download     * @return bool     */    public function save($filename, $format = 'Word2007', $download = false)    {        $mime = array(            'Word2007'  => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',            'ODText'    => 'application/vnd.oasis.opendocument.text',            'RTF'       => 'application/rtf',            'HTML'      => 'text/html',            'PDF'       => 'application/pdf',        );        $writer = IOFactory::createWriter($this, $format);        if ($download === true) {            header('Content-Description: File Transfer');            header('Content-Disposition: attachment; filename=""' . $filename . '""');            header('Content-Type: ' . $mime[$format]);            header('Content-Transfer-Encoding: binary');            header('Cache-Control: must-revalidate, post-check=0, pre-check=0');            header('Expires: 0');            $filename = 'php://output'; // Change filename to force download        }        $writer->save($filename);        return true;    }    /**     * Create new section     *     * @deprecated 0.10.0     *     * @param array $settings     *     * @return \PhpOffice\PhpWord\Element\Section     *     * @codeCoverageIgnore     */    public function createSection($settings = null)    {        return $this->addSection($settings);    }    /**     * Get document properties object     *     * @deprecated 0.12.0     *     * @return \PhpOffice\PhpWord\Metadata\DocInfo     *     * @codeCoverageIgnore     */    public function getDocumentProperties()    {        return $this->getDocInfo();    }    /**     * Set document properties object     *     * @deprecated 0.12.0     *     * @param \PhpOffice\PhpWord\Metadata\DocInfo $documentProperties     *     * @return self     *     * @codeCoverageIgnore     */    public function setDocumentProperties($documentProperties)    {        $this->metadata['Document'] = $documentProperties;        return $this;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWord_883, Exception\n,Izuzetak,"        throw new \BadMethodCallException(""Method $function is not defined."");",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWord_888, Get all sections\n\n @return \\PhpOffice\\PhpWord\\Element\\Section[]\n,Vra?a sve sekcije,    public function getSections()    {        return $this->sections;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWord_889, Returns the section at the requested position\n\n @param int $index\n @return \\PhpOffice\\PhpWord\\Element\\Section|null\n,Vra?a odeljak na traûenoj poziciji,"    public function getSection($index)    {        if (array_key_exists($index, $this->sections)) {            return $this->sections[$index];        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWord_890, Sorts the sections using the callable passed\n\n @see http://php.net/manual/en/function.usort.php for usage\n @param callable $sorter\n,Sortira odeljke koristec?i prosle?eni poziv,"    public function sortSections($sorter)    {        usort($this->sections, $sorter);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWord_896, Load template by filename\n\n @deprecated 0.12.0 Use `new TemplateProcessor($documentTemplate)` instead.\n\n @param  string $filename Fully qualified filename\n\n @throws \\PhpOffice\\PhpWord\\Exception\\Exception\n\n @return TemplateProcessor\n\n @codeCoverageIgnore\n,U?itava obrazac prema imenu datoteke,"    public function loadTemplate($filename)    {        if (file_exists($filename)) {            return new TemplateProcessor($filename);        }        throw new Exception(""Template file {$filename} not found."");    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_PhpWord_897, Get document properties object\n\n @deprecated 0.12.0\n\n @return \\PhpOffice\\PhpWord\\Metadata\\DocInfo\n\n @codeCoverageIgnore\n,Vra?a objekat svojstava dokumenta,    public function getDocumentProperties()    {        return $this->getDocInfo();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_ProofStateTest_1057, Test throws exception if wrong spelling proof state value given\\n\\n @expectedException \\\\InvalidArgumentException\\n,Test daje izuzetak ako je data pogreöna vrednost dokaza za pravopis,    public function testWrongSpelling()    {        $pState = new ProofState();        $pState->setSpelling('Wrong');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_SettingsTest_1013, Test set/get PDF renderer\n,Test postavljanje/vra?anje PDF renderera,"    public function testSetGetPdfRenderer()    {        $domPdfPath = realpath(PHPWORD_TESTS_BASE_DIR . '/../vendor/dompdf/dompdf');        $this->assertFalse(Settings::setPdfRenderer('FOO', 'dummy/path'));        $this->assertTrue(Settings::setPdfRenderer(Settings::PDF_RENDERER_DOMPDF, $domPdfPath));        $this->assertEquals(Settings::PDF_RENDERER_DOMPDF, Settings::getPdfRendererName());        $this->assertEquals($domPdfPath, Settings::getPdfRendererPath());        $this->assertFalse(Settings::setPdfRendererPath('dummy/path'));        $this->assertEquals($domPdfPath, Settings::getPdfRendererPath());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_SettingsTest_1014, Test set/get measurement unit\n,Test postavljanje/vra?anje mernih jedinica,"    public function testSetGetMeasurementUnit()    {        $this->assertEquals(Settings::UNIT_TWIP, Settings::getMeasurementUnit());        $this->assertFalse(Settings::setMeasurementUnit('foo'));        $this->assertEquals(Settings::UNIT_TWIP, Settings::getMeasurementUnit());        $this->assertTrue(Settings::setMeasurementUnit(Settings::UNIT_INCH));        $this->assertEquals(Settings::UNIT_INCH, Settings::getMeasurementUnit());        $this->assertFalse(Settings::setMeasurementUnit('foo'));        $this->assertEquals(Settings::UNIT_INCH, Settings::getMeasurementUnit());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_SettingsTest_1017, Test set/get default font name\\n,Test postavljanje/vra?anje podrazumevanog imena fonta,"    public function testSetGetDefaultFontName()    {        $this->assertEquals(Settings::DEFAULT_FONT_NAME, Settings::getDefaultFontName());        $this->assertFalse(Settings::setDefaultFontName(' '));        $this->assertEquals(Settings::DEFAULT_FONT_NAME, Settings::getDefaultFontName());        $this->assertTrue(Settings::setDefaultFontName('Times New Roman'));        $this->assertEquals('Times New Roman', Settings::getDefaultFontName());        $this->assertFalse(Settings::setDefaultFontName(' '));        $this->assertEquals('Times New Roman', Settings::getDefaultFontName());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_SettingsTest_1020, Test load config\n, Test u?itavanja konfiguracije,"    public function testLoadConfig()    {        $expected = array(            'compatibility'         => true,            'zipClass'              => 'ZipArchive',            'pdfRendererName'       => 'DomPDF',            'pdfRendererPath'       => '',            'defaultFontName'       => 'Arial',            'defaultFontSize'       => 10,            'outputEscapingEnabled' => false,            'defaultPaper'          => 'A4',        );        // Test default value        $this->assertEquals($expected, Settings::loadConfig());        // Test with valid file        $this->assertEquals($expected, Settings::loadConfig(__DIR__ . '/../../phpword.ini.dist'));        foreach ($expected as $key => $value) {            if ($key === 'compatibility') {                $meth = 'hasCompatibility';            } elseif ($key === 'outputEscapingEnabled') {                $meth = 'isOutputEscapingEnabled';            } else {                $meth = 'get' . ucfirst($key);            }            $this->assertEquals(Settings::$meth(), $value);        }        // Test with invalid file        $this->assertEmpty(Settings::loadConfig(__DIR__ . '/../../phpunit.xml.dist'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_899, PHPWord settings class\n\n @since 0.8.0\n, PHPWord klasa za podeöavanje,"class Settings{    /**     * Zip libraries     *     * @const string     */    const ZIPARCHIVE = 'ZipArchive';    const PCLZIP = 'PclZip';    const OLD_LIB = 'PhpOffice\\PhpWord\\Shared\\ZipArchive'; // @deprecated 0.11    /**     * PDF rendering libraries     *     * @const string     */    const PDF_RENDERER_DOMPDF = 'DomPDF';    const PDF_RENDERER_TCPDF = 'TCPDF';    const PDF_RENDERER_MPDF = 'MPDF';    /**     * Measurement units multiplication factor     *     * Applied to:     * - Section: margins, header/footer height, gutter, column spacing     * - Tab: position     * - Indentation: left, right, firstLine, hanging     * - Spacing: before, after     *     * @const string     */    const UNIT_TWIP = 'twip'; // = 1/20 point    const UNIT_CM = 'cm';    const UNIT_MM = 'mm';    const UNIT_INCH = 'inch';    const UNIT_POINT = 'point'; // = 1/72 inch    const UNIT_PICA = 'pica'; // = 1/6 inch = 12 points    /**     * Default font settings     *     * OOXML defined font size values in halfpoints, i.e. twice of what PhpWord     * use, and the conversion will be conducted during XML writing.     */    const DEFAULT_FONT_NAME = 'Arial';    const DEFAULT_FONT_SIZE = 10;    const DEFAULT_FONT_COLOR = '000000';    const DEFAULT_FONT_CONTENT_TYPE = 'default'; // default|eastAsia|cs    const DEFAULT_PAPER = 'A4';    /**     * Compatibility option for XMLWriter     *     * @var bool     */    private static $xmlWriterCompatibility = true;    /**     * Name of the class used for Zip file management     *     * @var string     */    private static $zipClass = self::ZIPARCHIVE;    /**     * Name of the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererName = null;    /**     * Directory Path to the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererPath = null;    /**     * Measurement unit     *     * @var int|float     */    private static $measurementUnit = self::UNIT_TWIP;    /**     * Default font name     *     * @var string     */    private static $defaultFontName = self::DEFAULT_FONT_NAME;    /**     * Default font size     * @var int     */    private static $defaultFontSize = self::DEFAULT_FONT_SIZE;    /**     * Default paper     * @var string     */    private static $defaultPaper = self::DEFAULT_PAPER;    /**     * The user defined temporary directory.     *     * @var string     */    private static $tempDir = '';    /**     * Enables built-in output escaping mechanism.     * Default value is `false` for backward compatibility with versions below 0.13.0.     *     * @var bool     */    private static $outputEscapingEnabled = false;    /**     * Return the compatibility option used by the XMLWriter     *     * @return bool Compatibility     */    public static function hasCompatibility()    {        return self::$xmlWriterCompatibility;    }    /**     * Set the compatibility option used by the XMLWriter     *     * This sets the setIndent and setIndentString for better compatibility     *     * @param bool $compatibility     * @return bool     */    public static function setCompatibility($compatibility)    {        $compatibility = (bool) $compatibility;        self::$xmlWriterCompatibility = $compatibility;        return true;    }    /**     * Get zip handler class     *     * @return string     */    public static function getZipClass()    {        return self::$zipClass;    }    /**     * Set zip handler class     *     * @param  string $zipClass     * @return bool     */    public static function setZipClass($zipClass)    {        if (in_array($zipClass, array(self::PCLZIP, self::ZIPARCHIVE, self::OLD_LIB))) {            self::$zipClass = $zipClass;            return true;        }        return false;    }    /**     * Set details of the external library for rendering PDF files     *     * @param string $libraryName     * @param string $libraryBaseDir     * @return bool Success or failure     */    public static function setPdfRenderer($libraryName, $libraryBaseDir)    {        if (!self::setPdfRendererName($libraryName)) {            return false;        }        return self::setPdfRendererPath($libraryBaseDir);    }    /**     * Return the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererName()    {        return self::$pdfRendererName;    }    /**     * Identify the external library to use for rendering PDF files     *     * @param string $libraryName     * @return bool     */    public static function setPdfRendererName($libraryName)    {        $pdfRenderers = array(self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_MPDF);        if (!in_array($libraryName, $pdfRenderers)) {            return false;        }        self::$pdfRendererName = $libraryName;        return true;    }    /**     * Return the directory path to the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererPath()    {        return self::$pdfRendererPath;    }    /**     * Location of external library to use for rendering PDF files     *     * @param string $libraryBaseDir Directory path to the library's base folder     * @return bool Success or failure     */    public static function setPdfRendererPath($libraryBaseDir)    {        if (false === file_exists($libraryBaseDir) || false === is_readable($libraryBaseDir)) {            return false;        }        self::$pdfRendererPath = $libraryBaseDir;        return true;    }    /**     * Get measurement unit     *     * @return string     */    public static function getMeasurementUnit()    {        return self::$measurementUnit;    }    /**     * Set measurement unit     *     * @param string $value     * @return bool     */    public static function setMeasurementUnit($value)    {        $units = array(self::UNIT_TWIP, self::UNIT_CM, self::UNIT_MM, self::UNIT_INCH,            self::UNIT_POINT, self::UNIT_PICA, );        if (!in_array($value, $units)) {            return false;        }        self::$measurementUnit = $value;        return true;    }    /**     * Sets the user defined path to temporary directory.     *     * @since 0.12.0     *     * @param string $tempDir The user defined path to temporary directory     */    public static function setTempDir($tempDir)    {        self::$tempDir = $tempDir;    }    /**     * Returns path to temporary directory.     *     * @since 0.12.0     *     * @return string     */    public static function getTempDir()    {        if (!empty(self::$tempDir)) {            $tempDir = self::$tempDir;        } else {            $tempDir = sys_get_temp_dir();        }        return $tempDir;    }    /**     * @since 0.13.0     *     * @return bool     */    public static function isOutputEscapingEnabled()    {        return self::$outputEscapingEnabled;    }    /**     * @since 0.13.0     *     * @param bool $outputEscapingEnabled     */    public static function setOutputEscapingEnabled($outputEscapingEnabled)    {        self::$outputEscapingEnabled = $outputEscapingEnabled;    }    /**     * Get default font name     *     * @return string     */    public static function getDefaultFontName()    {        return self::$defaultFontName;    }    /**     * Set default font name     *     * @param string $value     * @return bool     */    public static function setDefaultFontName($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultFontName = $value;            return true;        }        return false;    }    /**     * Get default font size     *     * @return int     */    public static function getDefaultFontSize()    {        return self::$defaultFontSize;    }    /**     * Set default font size     *     * @param int $value     * @return bool     */    public static function setDefaultFontSize($value)    {        $value = (int) $value;        if ($value > 0) {            self::$defaultFontSize = $value;            return true;        }        return false;    }    /**     * Load setting from phpword.yml or phpword.yml.dist     *     * @param string $filename     * @return array     */    public static function loadConfig($filename = null)    {        // Get config file        $configFile = null;        $configPath = __DIR__ . '/../../';        if ($filename !== null) {            $files = array($filename);        } else {            $files = array(""{$configPath}phpword.ini"", ""{$configPath}phpword.ini.dist"");        }        foreach ($files as $file) {            if (file_exists($file)) {                $configFile = realpath($file);                break;            }        }        // Parse config file        $config = array();        if ($configFile !== null) {            $config = @parse_ini_file($configFile);            if ($config === false) {                return $config;            }        }        // Set config value        foreach ($config as $key => $value) {            $method = ""set{$key}"";            if (method_exists(__CLASS__, $method)) {                self::$method($value);            }        }        return $config;    }    /**     * Get default paper     *     * @return string     */    public static function getDefaultPaper()    {        return self::$defaultPaper;    }    /**     * Set default paper     *     * @param string $value     * @return bool     */    public static function setDefaultPaper($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultPaper = $value;            return true;        }        return false;    }    /**     * Return the compatibility option used by the XMLWriter     *     * @deprecated 0.10.0     *     * @codeCoverageIgnore     */    public static function getCompatibility()    {        return self::hasCompatibility();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_900, Return the compatibility option used by the XMLWriter\n\n @return bool Compatibility\n,Vra?a opciju kompatibilnosti koju koristi XMLWriter,    public static function hasCompatibility()    {        return self::$xmlWriterCompatibility;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_901, Set the compatibility option used by the XMLWriter\\n\\n This sets the setIndent and setIndentString for better compatibility\\n\\n @param bool $compatibility\\n @return bool\\n,Postavlja opciju kompatibilnosti koju koristi XMLWriter,    public static function setCompatibility($compatibility)    {        $compatibility = (bool) $compatibility;        self::$xmlWriterCompatibility = $compatibility;        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_903, Set zip handler class\\n\\n @param  string $zipClass\\n @return bool\\n,Postavlja klasu zip rukovaoca,"    public static function setZipClass($zipClass)    {        if (in_array($zipClass, array(self::PCLZIP, self::ZIPARCHIVE, self::OLD_LIB))) {            self::$zipClass = $zipClass;            return true;        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_905, Return the PDF Rendering Library.\n\n @return string\n,Vra?a biblioteku za renderovanje PDF fajlova,    public static function getPdfRendererName()    {        return self::$pdfRendererName;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_906, Identify the external library to use for rendering PDF files\n\n @param string $libraryName\n @return bool\n,Identifikovanje ekternih biblioteka za renderovanje PDF fajlova,"    public static function setPdfRendererName($libraryName)    {        $pdfRenderers = array(self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_MPDF);        if (!in_array($libraryName, $pdfRenderers)) {            return false;        }        self::$pdfRendererName = $libraryName;        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_908, Location of external library to use for rendering PDF files\n\n @param string $libraryBaseDir Directory path to the library's base folder\n @return bool Success or failure\n,Lokacija eksternih biblioteka za renderovanje PDF fajlova,    public static function setPdfRendererPath($libraryBaseDir)    {        if (false === file_exists($libraryBaseDir) || false === is_readable($libraryBaseDir)) {            return false;        }        self::$pdfRendererPath = $libraryBaseDir;        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_909, Get measurement unit\n\n @return string\n, Vra?a jedinici mere,    public static function getMeasurementUnit()    {        return self::$measurementUnit;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_916, Set default font name\n\n @param string $value\n @return bool\n,Postavlja podrazumevani naziv fonta,    public static function setDefaultFontName($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultFontName = $value;            return true;        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Settings_920, Set default paper\\n\\n @param string $value\\n @return bool\\n,Postavlja podrazumevani papir,    public static function setDefaultPaper($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultPaper = $value;            return true;        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_StyleTest_1021, Test class for PhpOffice\\PhpWord\\Style\n\n @coversDefaultClass \\PhpOffice\\PhpWord\\Style\n @runTestsInSeparateProcesses\n, Testna klasa za PhpOffice,"class StyleTest extends \PHPUnit\Framework\TestCase{    /**     * Add and get paragraph, font, link, title, and table styles     *     * @covers ::addParagraphStyle     * @covers ::addFontStyle     * @covers ::addLinkStyle     * @covers ::addNumberingStyle     * @covers ::addTitleStyle     * @covers ::addTableStyle     * @covers ::setDefaultParagraphStyle     * @covers ::countStyles     * @covers ::getStyle     * @covers ::resetStyles     * @covers ::getStyles     * @test     */    public function testStyles()    {        $paragraph = array('alignment' => Jc::CENTER);        $font = array('italic' => true, '_bold' => true);        $table = array('bgColor' => 'CCCCCC');        $numbering = array(            'type'   => 'multilevel',            'levels' => array(                array(                    'start'     => 1,                    'format'    => 'decimal',                    'restart'   => 1,                    'suffix'    => 'space',                    'text'      => '%1.',                    'alignment' => Jc::START,                ),            ),        );        $styles = array(            'Paragraph' => 'Paragraph',            'Font'      => 'Font',            'Link'      => 'Font',            'Table'     => 'Table',            'Heading_1' => 'Font',            'Normal'    => 'Paragraph',            'Numbering' => 'Numbering',        );        Style::addParagraphStyle('Paragraph', $paragraph);        Style::addFontStyle('Font', $font);        Style::addLinkStyle('Link', $font);        Style::addNumberingStyle('Numbering', $numbering);        Style::addTitleStyle(1, $font);        Style::addTableStyle('Table', $table);        Style::setDefaultParagraphStyle($paragraph);        $this->assertCount(count($styles), Style::getStyles());        foreach ($styles as $name => $style) {            $this->assertInstanceOf(""PhpOffice\\PhpWord\\Style\\{$style}"", Style::getStyle($name));        }        $this->assertNull(Style::getStyle('Unknown'));        Style::resetStyles();        $this->assertCount(0, Style::getStyles());    }    /**     * Test default paragraph style     *     * @covers ::setDefaultParagraphStyle     * @test     */    public function testDefaultParagraphStyle()    {        $paragraph = array('alignment' => Jc::CENTER);        Style::setDefaultParagraphStyle($paragraph);        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Paragraph', Style::getStyle('Normal'));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Style_922, Style collection\\n,Kolekcija stilova,"class Style{    /**     * Style register     *     * @var array     */    private static $styles = array();    /**     * Add paragraph style     *     * @param string $styleName     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $styles     * @return \PhpOffice\PhpWord\Style\Paragraph     */    public static function addParagraphStyle($styleName, $styles)    {        return self::setStyleValues($styleName, new Paragraph(), $styles);    }    /**     * Add font style     *     * @param string $styleName     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $fontStyle     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $paragraphStyle     * @return \PhpOffice\PhpWord\Style\Font     */    public static function addFontStyle($styleName, $fontStyle, $paragraphStyle = null)    {        return self::setStyleValues($styleName, new Font('text', $paragraphStyle), $fontStyle);    }    /**     * Add link style     *     * @param string $styleName     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $styles     * @return \PhpOffice\PhpWord\Style\Font     */    public static function addLinkStyle($styleName, $styles)    {        return self::setStyleValues($styleName, new Font('link'), $styles);    }    /**     * Add numbering style     *     * @param string $styleName     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $styleValues     * @return \PhpOffice\PhpWord\Style\Numbering     * @since 0.10.0     */    public static function addNumberingStyle($styleName, $styleValues)    {        return self::setStyleValues($styleName, new Numbering(), $styleValues);    }    /**     * Add title style     *     * @param int|null $depth Provide null to set title font     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $fontStyle     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $paragraphStyle     * @return \PhpOffice\PhpWord\Style\Font     */    public static function addTitleStyle($depth, $fontStyle, $paragraphStyle = null)    {        if (empty($depth)) {            $styleName = 'Title';        } else {            $styleName = ""Heading_{$depth}"";        }        return self::setStyleValues($styleName, new Font('title', $paragraphStyle), $fontStyle);    }    /**     * Add table style     *     * @param string $styleName     * @param array $styleTable     * @param array|null $styleFirstRow     * @return \PhpOffice\PhpWord\Style\Table     */    public static function addTableStyle($styleName, $styleTable, $styleFirstRow = null)    {        return self::setStyleValues($styleName, new Table($styleTable, $styleFirstRow), null);    }    /**     * Count styles     *     * @return int     * @since 0.10.0     */    public static function countStyles()    {        return count(self::$styles);    }    /**     * Reset styles.     *     * @since 0.10.0     */    public static function resetStyles()    {        self::$styles = array();    }    /**     * Set default paragraph style     *     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $styles Paragraph style definition     * @return \PhpOffice\PhpWord\Style\Paragraph     */    public static function setDefaultParagraphStyle($styles)    {        return self::addParagraphStyle('Normal', $styles);    }    /**     * Get all styles     *     * @return \PhpOffice\PhpWord\Style\AbstractStyle[]     */    public static function getStyles()    {        return self::$styles;    }    /**     * Get style by name     *     * @param string $styleName     * @return \PhpOffice\PhpWord\Style\AbstractStyle Paragraph|Font|Table|Numbering     */    public static function getStyle($styleName)    {        if (isset(self::$styles[$styleName])) {            return self::$styles[$styleName];        }        return null;    }    /**     * Set style values and put it to static style collection     *     * The $styleValues could be an array or object     *     * @param string $name     * @param \PhpOffice\PhpWord\Style\AbstractStyle $style     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $value     * @return \PhpOffice\PhpWord\Style\AbstractStyle     */    private static function setStyleValues($name, $style, $value = null)    {        if (!isset(self::$styles[$name])) {            if ($value !== null) {                if (is_array($value)) {                    $style->setStyleByArray($value);                } elseif ($value instanceof AbstractStyle) {                    if (get_class($style) == get_class($value)) {                        $style = $value;                    }                }            }            $style->setStyleName($name);            $style->setIndex(self::countStyles() + 1); // One based index            self::$styles[$name] = $style;        }        return self::getStyle($name);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Style_923, Add paragraph style\\n\\n @param string $styleName\\n @param array|\\\\PhpOffice\\\\PhpWord\\\\Style\\\\AbstractStyle $styles\\n @return \\\\PhpOffice\\\\PhpWord\\\\Style\\\\Paragraph\\n,Dodavanjee stil pasusa,"    public static function addParagraphStyle($styleName, $styles)    {        return self::setStyleValues($styleName, new Paragraph(), $styles);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Style_924, Add link style\\n\\n @param string $styleName\\n @param array|\\\\PhpOffice\\\\PhpWord\\\\Style\\\\AbstractStyle $styles\\n @return \\\\PhpOffice\\\\PhpWord\\\\Style\\\\Font\\n,Dodavanje stil veze,"    public static function addLinkStyle($styleName, $styles)    {        return self::setStyleValues($styleName, new Font('link'), $styles);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Style_926, Count styles\\n\\n @return int\\n @since 0.10.0\\n,Preboj stilove,    public static function countStyles()    {        return count(self::$styles);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_Style_927, Reset styles.\\n\\n @since 0.10.0\\n,Resetuj stilove.,    public static function resetStyles()    {        self::$styles = array();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessorTest_1042, Template macros can be fixed.\\n\\n @covers ::fixBrokenMacros\\n @test\\n,Makronaredbe öablona mogu se popraviti.,"    public function testFixBrokenMacros()    {        $templateProcessor = new TestableTemplateProcesor();        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>normal text</w:t></w:r>');        $this->assertEquals('<w:r><w:t>normal text</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>${documentContent}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>${documentContent}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>$</w:t><w:t>{documentContent}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>${documentContent}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>$1500</w:t><w:t>${documentContent}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>$1500</w:t><w:t>${documentContent}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>$1500</w:t><w:t>$</w:t><w:t>{documentContent}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>$1500</w:t><w:t>${documentContent}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>25$ plus some info {hint}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>25$ plus some info {hint}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:t>$</w:t></w:r><w:bookmarkStart w:id=""0"" w:name=""_GoBack""/><w:bookmarkEnd w:id=""0""/><w:r><w:t xml:space=""preserve"">15,000.00. </w:t></w:r><w:r w:rsidR=""0056499B""><w:t>$</w:t></w:r><w:r w:rsidR=""00573DFD"" w:rsidRPr=""00573DFD""><w:rPr><w:iCs/></w:rPr><w:t>{</w:t></w:r><w:proofErr w:type=""spellStart""/><w:r w:rsidR=""00573DFD"" w:rsidRPr=""00573DFD""><w:rPr><w:iCs/></w:rPr><w:t>variable_name</w:t></w:r><w:proofErr w:type=""spellEnd""/><w:r w:rsidR=""00573DFD"" w:rsidRPr=""00573DFD""><w:rPr><w:iCs/></w:rPr><w:t>}</w:t></w:r>');        $this->assertEquals('<w:t>$</w:t></w:r><w:bookmarkStart w:id=""0"" w:name=""_GoBack""/><w:bookmarkEnd w:id=""0""/><w:r><w:t xml:space=""preserve"">15,000.00. </w:t></w:r><w:r w:rsidR=""0056499B""><w:t>${variable_name}</w:t></w:r>', $fixed);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_933," Expose zip class\\n\\n To replace an image: $templateProcessor->zip()->AddFromString(""word/media/image1.jpg"", file_get_contents($file));<br>\\n To read a file: $templateProcessor->zip()->getFromName(""word/media/image1.jpg"");\\n\\n @return \\\\PhpOffice\\\\PhpWord\\\\Shared\\\\ZipArchive\\n",Izlaganje zip klase,    public function zip()    {        return $this->zipClass;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_945, Clone a table row in a template document.\n\n @param string $search\n @param int $numberOfClones\n\n @throws \\PhpOffice\\PhpWord\\Exception\\Exception\n,Kloniranje reda tabele u dokumentu öablona.,"    public function cloneRow($search, $numberOfClones)    {        $search = static::ensureMacroCompleted($search);        $tagPos = strpos($this->tempDocumentMainPart, $search);        if (!$tagPos) {            throw new Exception('Can not clone row, template variable not found or variable contains markup.');        }        $rowStart = $this->findRowStart($tagPos);        $rowEnd = $this->findRowEnd($tagPos);        $xmlRow = $this->getSlice($rowStart, $rowEnd);        // Check if there's a cell spanning multiple rows.        if (preg_match('#<w:vMerge w:val=""restart""/>#', $xmlRow)) {            // $extraRowStart = $rowEnd;            $extraRowEnd = $rowEnd;            while (true) {                $extraRowStart = $this->findRowStart($extraRowEnd + 1);                $extraRowEnd = $this->findRowEnd($extraRowEnd + 1);                // If extraRowEnd is lower then 7, there was no next row found.                if ($extraRowEnd < 7) {                    break;                }                // If tmpXmlRow doesn't contain continue, this row is no longer part of the spanned row.                $tmpXmlRow = $this->getSlice($extraRowStart, $extraRowEnd);                if (!preg_match('#<w:vMerge/>#', $tmpXmlRow) &&                    !preg_match('#<w:vMerge w:val=""continue""\s*/>#', $tmpXmlRow)                ) {                    break;                }                // This row was a spanned row, update $rowEnd and search for the next row.                $rowEnd = $extraRowEnd;            }            $xmlRow = $this->getSlice($rowStart, $rowEnd);        }        $result = $this->getSlice(0, $rowStart);        $result .= implode($this->indexClonedVariables($numberOfClones, $xmlRow));        $result .= $this->getSlice($rowEnd);        $this->tempDocumentMainPart = $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_951, Saves the result document to the user defined file.\n\n @since 0.8.0\n\n @param string $fileName\n,?uvanje dokument rezultata u korisni?ki definisanu datoteku.,"    public function saveAs($fileName)    {        $tempFileName = $this->save();        if (file_exists($fileName)) {            unlink($fileName);        }        /*         * Note: we do not use `rename` function here, because it loses file ownership data on Windows platform.         * As a result, user cannot open the file directly getting ""Access denied"" message.         *         * @see https://github.com/PHPOffice/PHPWord/issues/532         */        copy($tempFileName, $fileName);        unlink($tempFileName);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_953, Find and replace macros in the given XML section.\\n\\n @param mixed $search\\n @param mixed $replace\\n @param string $documentPartXML\\n @param int $limit\\n\\n @return string\\n,Traûenje i zamena makronaredbe u datom XML odeljku.,"    protected function setValueForPart($search, $replace, $documentPartXML, $limit)    {        // Note: we can't use the same function for both cases here, because of performance considerations.        if (self::MAXIMUM_REPLACEMENTS_DEFAULT === $limit) {            return str_replace($search, $replace, $documentPartXML);        }        $regExpEscaper = new RegExp();        return preg_replace($regExpEscaper->escape($search), $replace, $documentPartXML, $limit);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_955, Get the name of the header file for $index.\n\n @param int $index\n\n @return string\n,Vra?a naziv datoteke zaglavalja za $index.,"    protected function getHeaderName($index)    {        return sprintf('word/header%d.xml', $index);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_956," Usually, the name of main part document will be 'document.xml'. However, some .docx files (possibly those from Office 365, experienced also on documents from Word Online created from blank templates) have file 'document22.xml' in their zip archive instead of 'document.xml'. This method searches content types file to correctly determine the file name.\n\n @return string\n"," Obi?no c?e naziv glavnog dela dokumenta biti Ñdocument.xmlì. Me?utim, neke .docx datoteke (moûda one iz Office 365, isto se deöava i na dokumentima iz programa Word Online kreiranim iz praznih öablona) imaju u svojoj zip arhivi datoteku 'document22.xml' umesto 'document.xml'. Ova metoda pretraûuje datotelu tipova sadrûaja da bi na pravi na?in bilo odre?eno ime datoteke.","    protected function getMainPartName()    {        $contentTypes = $this->zipClass->getFromName('[Content_Types].xml');        $pattern = '~PartName=""\/(word\/document.*?\.xml)"" ContentType=""application\/vnd\.openxmlformats-officedocument\.wordprocessingml\.document\.main\+xml""~';        $matches = array();        preg_match($pattern, $contentTypes, $matches);        return array_key_exists(1, $matches) ? $matches[1] : 'word/document.xml';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_958, Get the name of the footer file for $index.\n\n @param int $index\n\n @return string\n,Vra?a ime datoteke podnoûja za $index. ,"    protected function getFooterName($index)    {        return sprintf('word/footer%d.xml', $index);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_959, Get the name of the relations file for document part.\n\n @param string $documentPartName\n\n @return string\n,Vra?a ime datoteke sa kojom je dio dokumenta u odnosu. ,"    protected function getRelationsName($documentPartName)    {        return 'word/_rels/' . pathinfo($documentPartName, PATHINFO_BASENAME) . '.rels';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_962, Find the end position of the nearest table row after $offset.\n\n @param int $offset\n\n @return int\n,Traûi krajnji poloûaj najbliûeg reda tabele nakon $offset. ,"    protected function findRowEnd($offset)    {        return strpos($this->tempDocumentMainPart, '</w:tr>', $offset) + 7;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_966, Find the nearest block end position after $offset\\n\\n @param int $offset    Search position\\n @param string  $blockType XML Block tag\\n @return int -1 if block end not found\\n,Prona?ite najbliûi krajnji poloûaj bloka nakon $offset,"    protected function findXmlBlockEnd($offset, $blockType)    {        $blockEndStart = strpos($this->tempDocumentMainPart, '</' . $blockType . '>', $offset);        // return position of end of tag if found, otherwise -1        return ($blockEndStart === false) ? -1 : $blockEndStart + 3 + strlen($blockType);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_764, Find Tab ID by slug.\\\\n\\\\n @param string $authSlug Slug\\\\n\\\\n @return string Tab ID\\\\n @todo: Find out if we should return an int instead. (breaking change)\\\\n,Traûi Tab ID po ûetonu.,"    public static function findIdTabByAuthSlug($authSlug)    {        preg_match(            '/ROLE_MOD_[A-Z]+_(?P<classname>[A-Z]+)_(?P<auth>[A-Z]+)/',            $authSlug,            $matches        );        $result = Db::getInstance()->getRow('            SELECT `id_tab`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE UCASE(`class_name`) = ""' . $matches['classname'] . '""        ');        return $result['id_tab'];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_767, Find slug by Module ID.\\\\n\\\\n @param int $idModule Module ID\\\\n\\\\n @return string Full module slug\\\\n,Traûi ûeton po Module ID.,"    public static function findSlugByIdModule($idModule)    {        $result = Db::getInstance()->getRow('            SELECT `name`            FROM `' . _DB_PREFIX_ . 'module`            WHERE `id_module` = ""' . (int) $idModule . '""        ');        return self::sluggifyModule($result);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_769," Add access.\\\\n\\\\n @param int $idProfile Profile ID\\\\n @param int $idRole Role ID\\\\n\\\\n @return string Whether access has been successfully granted (""ok"", ""error"")\\\\n",Dodaj pristup.,"    public function addAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Access_773," Update (legacy) Module access.\n\n @param int $idProfile Profile ID\n @param int $idModule Module ID\n @param string $lgcAuth Legacy authorization\n @param int $enabled Whether module access should be granted\n\n @return string Whether module access has been succesfully changed (""ok"", ""error"")\n",Aûuriranje (zastarelog) pristup modulu.,"    public function updateLgcModuleAccess($idProfile, $idModule, $lgcAuth, $enabled)    {        $idProfile = (int) $idProfile;        $idModule = (int) $idModule;        if ($idModule == -1) {            $slug = 'ROLE_MOD_MODULE_%_';        } else {            $slug = self::findSlugByIdModule($idModule);        }        $whereClauses = [];        foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {            $slugLike = Db::getInstance()->escape($slug . $auth);            $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';        }        $roles = Db::getInstance()->executeS('            SELECT `id_authorization_role`            FROM `' . _DB_PREFIX_ . 'authorization_role` t            WHERE ' . implode(' OR ', $whereClauses) . '        ');        $res = [];        foreach ($roles as $role) {            if ($enabled) {                $res[] = $this->addModuleAccess($idProfile, $role['id_authorization_role']);            } else {                $res[] = $this->removeModuleAccess($idProfile, $role['id_authorization_role']);            }        }        return in_array('error', $res) ? 'error' : 'ok';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_793, Verify the existence of a field name and check the availability\\n of an association between a field name and a class (ClassName:fieldName)\\n if the separator is overview.\\n\\n @param string $patternName The composition of the class and field name\\n @param string $fieldsValidate The list of available field for the Address class\\n @todo: Why is $fieldsValidate unused?\\n,Proverava da li postoji ime polja i proverava dostupnost,"    protected function _checkLiableAssociation($patternName, $fieldsValidate)    {        $patternName = trim($patternName);        if ($associationName = explode(':', $patternName)) {            $totalNameUsed = count($associationName);            if ($totalNameUsed > 2) {                $this->_errorFormatList[] = $this->trans('This association has too many elements.', [], 'Admin.Notifications.Error');            } elseif ($totalNameUsed == 1) {                $associationName[0] = strtolower($associationName[0]);                if (in_array($associationName[0], self::$forbiddenPropertyList) ||                    !$this->_checkValidateClassField('Address', $associationName[0], false)) {                    $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                    $associationName[0];                }            } elseif ($totalNameUsed == 2) {                if (empty($associationName[0]) || empty($associationName[1])) {                    $this->_errorFormatList[] = $this->trans('Syntax error with this pattern.', [], 'Admin.Notifications.Error') . ': ' . $patternName;                } else {                    $associationName[0] = ucfirst($associationName[0]);                    $associationName[1] = strtolower($associationName[1]);                    if (in_array($associationName[0], self::$forbiddenClassList)) {                        $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                        $associationName[0];                    } else {                        // Check if the id field name exist in the Address class                        // Don't check this attribute on Address (no sense)                        if ($associationName[0] != 'Address') {                            $this->_checkValidateClassField('Address', 'id_' . strtolower($associationName[0]), true);                        }                        // Check if the field name exist in the class write by the user                        $this->_checkValidateClassField($associationName[0], $associationName[1], false);                    }                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_795, Checks that all required fields exist in a given fields list.\\\\n Fills _errorFormatList array in case of absence of a required field.\\\\n\\\\n @param array $fieldList\\\\n,Proverava da li sva obavezna polja postoje na datoj listi polja.,"    protected function checkRequiredFields($fieldList)    {        foreach (self::getFieldsRequired() as $requiredField) {            if (!in_array($requiredField, $fieldList)) {                $this->_errorFormatList[] = $this->trans(                    'The %s field (in tab %s) is required.',                    [$requiredField, $this->getFieldTabName($requiredField)],                    'Admin.Notifications.Error');            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_797, Returns the error list.\\\\n,Vra?a listu greöaka.,    public function getErrorList()    {        return $this->_errorFormatList;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_798, Set the layout key with the liable value\\\\n example : (firstname) => 'Presta' will result (Presta)\\\\n         : (firstname-lastname) => 'Presta' and 'Shop' result '(Presta-Shop)'.\\\\n,Postavlja klju? izgleda sa odgovornom vrednoö?u,"    protected static function _setOriginalDisplayFormat(&$formattedValueList, $currentLine, $currentKeyList)    {        if ($currentKeyList && is_array($currentKeyList)) {            if ($originalFormattedPatternList = explode(' ', $currentLine)) {                // Foreach the available pattern                foreach ($originalFormattedPatternList as $patternNum => $pattern) {                    // Var allows to modify the good formatted key value when multiple key exist into the same pattern                    $mainFormattedKey = '';                    // Multiple key can be found in the same pattern                    foreach ($currentKeyList as $key) {                        // Check if we need to use an older modified pattern if a key has already be matched before                        $replacedValue = empty($mainFormattedKey) ? $pattern : $formattedValueList[$mainFormattedKey];                        $chars = $start = $end = str_replace($key, '', $replacedValue);                        if (preg_match(self::_CLEANING_REGEX_, $chars)) {                            if (Tools::substr($replacedValue, 0, Tools::strlen($chars)) == $chars) {                                $end = '';                            } else {                                $start = '';                            }                            if ($chars) {                                $replacedValue = str_replace($chars, '', $replacedValue);                            }                        }                        if ($formattedValue = preg_replace('/^' . $key . '$/', $formattedValueList[$key], $replacedValue, -1, $count)) {                            if ($count) {                                // Allow to check multiple key in the same pattern,                                if (empty($mainFormattedKey)) {                                    $mainFormattedKey = $key;                                }                                // Set the pattern value to an empty string if an older key has already been matched before                                if ($mainFormattedKey != $key) {                                    $formattedValueList[$key] = '';                                }                                // Store the new pattern value                                $formattedValueList[$mainFormattedKey] = $start . $formattedValue . $end;                                unset($originalFormattedPatternList[$patternNum]);                            }                        }                    }                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_799, Cleaned the layout set by the user.\\\\\\\\n,?isti izgled postavljen od strane korisnika. ,"    public static function cleanOrderedAddress(&$orderedAddressField)    {        foreach ($orderedAddressField as &$line) {            $cleanedLine = '';            if (($keyList = preg_split(self::_CLEANING_REGEX_, $line, -1, PREG_SPLIT_NO_EMPTY))) {                foreach ($keyList as $key) {                    $cleanedLine .= $key . ' ';                }                $cleanedLine = trim($cleanedLine);                $line = $cleanedLine;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_801, Returns selected fields required for an address in an array according to a selection hash.\\n\\n @return array String values\\n,Vrac?a izabrana polja potrebna za adresu u nizu u skladu sa heöom izbora.,"    public static function getValidateFields($className)    {        $propertyList = [];        if (class_exists($className)) {            $object = new $className();            $reflect = new ReflectionObject($object);            // Check if the property is accessible            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                $propertyName = $property->getName();                if ((!in_array($propertyName, AddressFormat::$forbiddenPropertyList)) &&                        (!preg_match('#id|id_\w#', $propertyName))) {                    $propertyList[] = $propertyName;                }            }            unset(                $object,                $reflect            );        }        return $propertyList;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_802, Return a list of liable class of the className.\\n\\n @param string $className\\n\\n @return array\\n,Vra?a listu odgovornih klasa className. ,"    public static function getLiableClass($className)    {        $objectList = [];        if (class_exists($className)) {            $object = new $className();            $reflect = new ReflectionObject($object);            // Get all the name object liable to the Address class            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                $propertyName = $property->getName();                if (preg_match('#id_\w#', $propertyName) && strlen($propertyName) > 3) {                    $nameObject = ucfirst(substr($propertyName, 3));                    if (!in_array($nameObject, self::$forbiddenClassList) &&                            class_exists($nameObject)) {                        $objectList[$nameObject] = new $nameObject();                    }                }            }            unset(                $object,                $reflect            );        }        return $objectList;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_803," Return a data array containing ordered, formatedValue and object fields.\\\\\\\\n","Vra?a niz podataka koji sadrûi ure?ena, formatedValue i polja objekta.","    public static function getFormattedLayoutData($address)    {        $layoutData = [];        if ($address && $address instanceof Address) {            $layoutData['ordered'] = AddressFormat::getOrderedAddressFields((int) $address->id_country);            $layoutData['formated'] = AddressFormat::getFormattedAddressFieldsValues($address, $layoutData['ordered']);            $layoutData['object'] = [];            $reflect = new ReflectionObject($address);            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                if (isset($address->{$property->getName()})) {                    $layoutData['object'][$property->getName()] = $address->{$property->getName()};                }            }        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AddressFormat_806, Get Address format from DB.\\\\n\\\\n @param int $idCountry Country ID\\\\n\\\\n @return false|string|null Address format\\\\n\\\\n @since 1.7.0\\\\n,Vra?a format adrese iz DB.,"    protected function getFormatDB($idCountry)    {        if (!Cache::isStored('AddressFormat::getFormatDB' . $idCountry)) {            $format = Db::getInstance()->getValue('SELECT formatFROM `' . _DB_PREFIX_ . $this->def['table'] . '`WHERE `id_country` = ' . (int) $idCountry);            $format = trim($format);            Cache::store('AddressFormat::getFormatDB' . $idCountry, $format);            return $format;        }        return Cache::retrieve('AddressFormat::getFormatDB' . $idCountry);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_775, reset static cache (eg unit testing purpose).\\n, resetovanje stati?ke keö memorije (npr. u svrhu testiranja jedinice).,    public static function resetStaticCache()    {        static::$_idZones = [];        static::$_idCountries = [];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_778, Returns fields required for an address in an array hash.\\\\n\\\\n @return array Hash values\\\\n,Vra?a pptrebna polja za adresu u heöiranom nizu.,    public static function getFieldsValidate()    {        $tmp_addr = new Address();        $out = $tmp_addr->fieldsValidate;        unset($tmp_addr);        return $out;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_780, Check if the Country is active for a given address.\\\\\\\\n\\\\\\\\n @param int $id_address Address ID for which we want to get the Country status\\\\\\\\n\\\\\\\\n @return int Country status\\\\\\\\n,Proverava da li je drûava aktivna za datu adresu.,"    public static function isCountryActiveById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        $cache_id = 'Address::isCountryActiveById_' . (int) $id_address;        if (!Cache::isStored($cache_id)) {            $result = (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT c.`active`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`WHERE a.`id_address` = ' . (int) $id_address);            Cache::store($cache_id, $result);            return $result;        }        return Cache::retrieve($cache_id);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_781, Request to check if DNI field is required\\n depending on the current selected country.\\n\\n @param int $idCountry\\n\\n @return bool\\n,Zahtev da e proveri da li je DNI polje obavezno,    public static function dniRequired($idCountry)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT c.`need_identification_number` ' .            'FROM `' . _DB_PREFIX_ . 'country` c ' .            'WHERE c.`id_country` = ' . (int) $idCountry        );    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_782, Check if Address is used (at least one order placed).\\\\\\\\n\\\\\\\\n @return int Order count for this Address\\\\\\\\n,Proverava da li je adresa koriö?ena (barem jedna narudûba postoji).,    public function isUsed()    {        if ((int) $this->id <= 0) {            return false;        }        $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT COUNT(`id_order`) AS usedFROM `' . _DB_PREFIX_ . 'orders`WHERE `id_address_delivery` = ' . (int) $this->id . 'OR `id_address_invoice` = ' . (int) $this->id);        return $result > 0 ? (int) $result : false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_783, Get Country and State of this Address.\\n\\n @param int $id_address Address ID\\n\\n @return array\\n,Vra?a drûavu ove adrese.,"    public static function getCountryAndState($id_address)    {        if (isset(self::$_idCountries[$id_address])) {            return self::$_idCountries[$id_address];        }        if ($id_address) {            $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT `id_country`, `id_state`, `vat_number`, `postcode` FROM `' . _DB_PREFIX_ . 'address`WHERE `id_address` = ' . (int) $id_address);        } else {            $result = false;        }        self::$_idCountries[$id_address] = $result;        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_784, Specify if an address is already in base.\\\\n\\\\n @param int $id_address Address id\\\\n\\\\n @return bool The address exists\\\\n,Navodi da li adresa ve? postoji u bazi.,"    public static function addressExists($id_address)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT `id_address`             FROM ' . _DB_PREFIX_ . 'address a             WHERE a.`id_address` = ' . (int) $id_address,            false        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_785, Check if the address is valid.\n\n @param int $id_address Address id\n\n @return bool The address is valid\n,Proverava da li je adresa validna.,    public static function isValid($id_address)    {        $id_address = (int) $id_address;        $isValid = Db::getInstance()->getValue('            SELECT `id_address` FROM ' . _DB_PREFIX_ . 'address a            WHERE a.`id_address` = ' . $id_address . ' AND a.`deleted` = 0 AND a.`active` = 1        ');        return (bool) $isValid;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_786, Returns Address ID for a given Supplier ID.\n\n @since 1.5.0\n\n @param int $id_supplier Supplier ID\n\n @return int $id_address Address ID\n, Vra?a Address ID za dati Supplier ID.,    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_787, Check if the alias already exists.\n\n @param string $alias Alias of an address\n @param int $id_address Address id\n @param int $id_customer Customer id\n\n @return false|string|null Amount of aliases found\n @todo: Find out if we shouldn't be returning an int instead? (breaking change)\n,Provera da li pseudonim ve? postoji.,"    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AdminAccessController_863, return human readable Tabs hierarchy for display.\\n,vra?a hijerarhiju kartica ?itljivih za prikaz.,    protected function displayTabs(array $tabs)    {        $tabsTree = $this->getChildrenTab($tabs);        return $tabsTree;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AdminAttributesGroupsController_872, Call the right method for creating or updating object.\\\\\\\\n\\\\\\\\n @return mixed\\\\\\\\n,Pozovanje odgovaraju?e metode za stvaranje ili aûuriranje objekta.,    public function processSave()    {        if ($this->display == 'add' || $this->display == 'edit') {            $this->identifier = 'id_attribute_group';        }        if (!$this->id_object) {            return $this->processAdd();        } else {            return $this->processUpdate();        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Alias_810, Get all found aliases from DB with search query.\\\\\\\\n\\\\\\\\n @return string Comma separated aliases\\\\\\\\n,Vra?a sve prona?ene pseudonime iz DB pomo?u upita za pretragu.,"    public function getAliases()    {        if (!Alias::isFeatureActive()) {            return '';        }        $aliases = Db::getInstance()->executeS('SELECT a.aliasFROM `' . _DB_PREFIX_ . 'alias` aWHERE `search` = \'' . pSQL($this->search) . '\'');        $aliases = array_map('implode', $aliases);        return implode(', ', $aliases);    }",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Alias_812, This method is allow to know if a alias exist for AdminImportController.\\\\n\\\\n @param int $idAlias Alias ID\\\\n\\\\n @return bool\\\\n\\\\n @since 1.5.6.0\\\\n,Ova metoda dozvoljava da se zna postoji li pseudonim za AdminImportController.,"    public static function aliasExists($idAlias)    {        $sql = new DbQuery();        $sql->select('a.`id_alias`');        $sql->from('alias', 'a');        $sql->where('a.`id_alias` = ' . (int) $idAlias);        $row = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow($sql, false);        return isset($row['id_alias']);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AppKernel_759, Enable auto loading of module Composer autoloader if needed.\\n Need to be done as earlier as possible in application lifecycle.\\n\\n Note: this feature is also manage in PrestaShop\\\\PrestaShop\\\\Adapter\\\\ContainerBuilder\\n for non Symfony environments.\\n\\n @param array $modules the list of modules\\n,Omogu?avanje automatskog u?itavanje modula Composer autoloader ako je potrebno.,"    private function enableComposerAutoloaderOnModules($modules)    {        $moduleDirectoryPath = rtrim(_PS_MODULE_DIR_, '/') . '/';        foreach ($modules as $module) {            $autoloader = $moduleDirectoryPath . $module . '/vendor/autoload.php';            if (file_exists($autoloader)) {                include_once $autoloader;            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AppKernel_760, Gets the application root dir.\n Override Kernel due to the fact that we remove the composer.json in\n downloaded package. More we are not a framework and the root directory\n should always be the parent of this file.\n\n @return string The project root dir\n,Vra?a root direktorijum aplikacije. \n premoötava Kernel zbog ?injenice da smo uklonili composer.json u\n paketu za preuzimanje. ätaviöe mi nismo okvir i root direktorijum \n bi trebao uvek da bude roditelj ovog fajla. ,    public function getProjectDir()    {        return realpath(__DIR__ . '/..');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attachment_815, Delete selection of attachments.\\\\\\\\n\\\\\\\\n @param array $attachments Attachments\\\\\\\\n\\\\\\\\n @return bool|int Whether the selection has been successfully deleted\\\\\\\\n @todo: Find out if $return can be initialized with true. (breaking change)\\\\\\\\n,Brisanje izbora priloga.,    public function deleteSelection($attachments)    {        $return = 1;        foreach ($attachments as $idAttachment) {            $attachment = new Attachment((int) $idAttachment);            $return &= $attachment->delete();        }        return $return;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attachment_816, Delete Product attachments for the given Product ID.\n\n @param int $idProduct Product ID\n\n @return bool\n,Brisanje Product priloga za dati Product ID.,    public static function deleteProductAttachments($idProduct)    {        $res = Db::getInstance()->execute('DELETE FROM ' . _DB_PREFIX_ . 'product_attachmentWHERE id_product = ' . (int) $idProduct);        Product::updateCacheAttachment((int) $idProduct);        return $res;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attachment_817, Associate $id_product to the current object.\\\\\\\\n\\\\\\\\n @param int $idProduct id of the product to associate\\\\\\\\n\\\\\\\\n @return bool true if success\\\\\\\\n, Pridruûuje $id_product datom objektu.,"    public function attachProduct($idProduct)    {        return static::associateProductAttachment((int) $idProduct, (int) $this->id);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attachment_819, Associate an array of id_attachment $array to the product $id_product\\\\n and remove eventual previous association.\\\\n\\\\n @param int $idProduct Product ID\\\\n @param array $array Attachment IDs\\\\n\\\\n @return bool Whether the attachments have been successfully associated with the Product\\\\n, Pridruûuje niz id_attachment $array proizvodu $id_product,"    public static function attachToProduct($idProduct, $array)    {        $result1 = Attachment::deleteProductAttachments($idProduct);        if (is_array($array)) {            $ids = [];            foreach ($array as $idAttachment) {                if ((int) $idAttachment > 0) {                    $ids[] = ['id_product' => (int) $idProduct, 'id_attachment' => (int) $idAttachment];                }            }            if (!empty($ids)) {                $result2 = Db::getInstance()->insert('product_attachment', $ids);            }        }        Product::updateCacheAttachment((int) $idProduct);        if (is_array($array)) {            return $result1 && (!isset($result2) || $result2);        }        return $result1;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attachment_820, Get Attachment IDs for the given Product within the given range of attachment IDs.\\\\n\\\\n @param int $idLang Language ID\\\\n @param array $list List of attachment IDs in which to search\\\\n\\\\n @return array|bool List of attachment IDs found. False if nothing found.\\\\n,Vra?a Attachment ID-ijeve za dati Product u okviru opsega Id-ijeva priloga.,"    public static function getProductAttached($idLang, $list)    {        if (!is_array($list)) {            return false;        }        $idsAttachments = array_column($list, 'id_attachment');        $sql = 'SELECT * FROM `' . _DB_PREFIX_ . 'product_attachment` pa ' .             'LEFT JOIN `' . _DB_PREFIX_ . 'product_lang` pl ON (pa.`id_product` = pl.`id_product`' . Shop::addSqlRestrictionOnLang('pl') . ') ' .             'WHERE `id_attachment` IN (' . implode(',', array_map('intval', $idsAttachments)) . ') ' .             'AND pl.`id_lang` = ' . (int) $idLang;        $tmp = Db::getInstance()->executeS($sql);        $productAttachments = [];        foreach ($tmp as $t) {            $productAttachments[$t['id_attachment']][] = $t['name'];        }        return $productAttachments;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attachment_822," Set products ids of current attachment for association.\\n\\n @param array<int, array{id: int|string }> $products Products ids\\n\\n @return bool\\n",Postavljanje ID-jeva proizvoda trenutnog priloga za povezivanje.,"    public function setWsProducts(array $products): bool    {        $this->deleteAttachments(true);        foreach ($products as $product) {            Db::getInstance()->execute('INSERT INTO `' . _DB_PREFIX_ . 'product_attachment` (`id_product`, `id_attachment`) VALUES (' . (int) $product['id'] . ', ' . (int) $this->id . ')');            Product::updateCacheAttachment((int) $product['id']);        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_831, Clean dead combinations\\n A combination is considered dead when its Attribute ID cannot be found.\\n\\n @return bool Whether the dead combinations have been successfully deleted\\n,?iö?enje mrtvih kombinacija,"    public static function cleanDeadCombinations()    {        $attributeCombinations = Db::getInstance()->executeS('SELECT pac.`id_attribute`, pa.`id_product_attribute`FROM `' . _DB_PREFIX_ . 'product_attribute` paLEFT JOIN `' . _DB_PREFIX_ . 'product_attribute_combination` pacON (pa.`id_product_attribute` = pac.`id_product_attribute`)');        $toRemove = [];        foreach ($attributeCombinations as $attributeCombination) {            if ((int) $attributeCombination['id_attribute'] == 0) {                $toRemove[] = (int) $attributeCombination['id_product_attribute'];            }        }        $return = true;        if (!empty($toRemove)) {            foreach ($toRemove as $remove) {                $combination = new Combination($remove);                $return &= $combination->delete();            }        }        return $return;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_832, Deletes current AttributeGroup from database.\\\\\\\\n\\\\\\\\n @return bool True if delete was successful\\\\\\\\n\\\\\\\\n @throws PrestaShopException\\\\\\\\n,Briöe trenutnu AttributeGroup iz baze podataka.,"    public function delete()    {        if (!$this->hasMultishopEntries() || Shop::getContext() == Shop::CONTEXT_ALL) {            /* Select children in order to find linked combinations */            $attributeIds = Db::getInstance()->executeS(                'SELECT `id_attribute`FROM `' . _DB_PREFIX_ . 'attribute`WHERE `id_attribute_group` = ' . (int) $this->id            );            if ($attributeIds === false) {                return false;            }            /* Removing attributes to the found combinations */            $toRemove = [];            foreach ($attributeIds as $attribute) {                $toRemove[] = (int) $attribute['id_attribute'];            }            if (!empty($toRemove) && Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'product_attribute_combination`WHERE `id_attribute`IN (' . implode(', ', $toRemove) . ')') === false) {                return false;            }            /* Remove combinations if they do not possess attributes anymore */            if (!AttributeGroup::cleanDeadCombinations()) {                return false;            }            /* Also delete related attributes */            if (count($toRemove)) {                if (!Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_lang`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_shop`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute` WHERE `id_attribute_group` = ' . (int) $this->id)) {                    return false;                }            }            $this->cleanPositions();        }        $return = parent::delete();        if ($return) {            Hook::exec('actionAttributeGroupDelete', ['id_attribute_group' => $this->id]);        }        return $return;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_833, Get all attributes for a given language / group.\\\\n\\\\n @param int $idLang Language ID\\\\n @param int $idAttributeGroup AttributeGroup ID\\\\n\\\\n @return array Attributes\\\\n,Vra?a sve atribute za dati jezik/grupu.,"    public static function getAttributes($idLang, $idAttributeGroup)    {        if (!Combination::isFeatureActive()) {            return [];        }        return Db::getInstance()->executeS('SELECT *FROM `' . _DB_PREFIX_ . 'attribute` a' . Shop::addSqlAssociation('attribute', 'a') . 'LEFT JOIN `' . _DB_PREFIX_ . 'attribute_lang` alON (a.`id_attribute` = al.`id_attribute` AND al.`id_lang` = ' . (int) $idLang . ')WHERE a.`id_attribute_group` = ' . (int) $idAttributeGroup . 'ORDER BY `position` ASC');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_834, Get all attributes groups for a given language.\\\\n\\\\n @param int $idLang Language id\\\\n\\\\n @return array Attributes groups\\\\n,Vra?a sve atribute grupe za dati jezik.,"    public static function getAttributesGroups($idLang)    {        if (!Combination::isFeatureActive()) {            return [];        }        return Db::getInstance()->executeS('SELECT DISTINCT agl.`name`, ag.*, agl.*FROM `' . _DB_PREFIX_ . 'attribute_group` ag' . Shop::addSqlAssociation('attribute_group', 'ag') . 'LEFT JOIN `' . _DB_PREFIX_ . 'attribute_group_lang` aglON (ag.`id_attribute_group` = agl.`id_attribute_group` AND `id_lang` = ' . (int) $idLang . ')ORDER BY `name` ASC');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_836, Set the values of the current AttributeGroup for the webservice.\\n\\n @param array $values\\n\\n @return bool Whether the update was successful\\n,Postavlja vrednosti trenutnog AttributeGroup za web servis.,"    public function setWsProductOptionValues($values)    {        $ids = [];        foreach ($values as $value) {            $ids[] = (int) ($value['id']);        }        if (!empty($ids)) {            Db::getInstance()->execute(                '                DELETE FROM `' . _DB_PREFIX_ . 'attribute`                WHERE `id_attribute_group` = ' . (int) $this->id . '                AND `id_attribute` NOT IN (' . implode(',', $ids) . ')'            );        }        $ok = true;        foreach ($values as $value) {            $result = Db::getInstance()->execute(                'UPDATE `' . _DB_PREFIX_ . 'attribute`SET `id_attribute_group` = ' . (int) $this->id . 'WHERE `id_attribute` = ' . (int) $value['id']            );            if ($result === false) {                $ok = false;            }        }        return $ok;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_837, Get values of current AttributeGroup instance for the webservice.\n\n @return array|false|mysqli_result|PDOStatement|resource|null\n,Vra?a vrednosti trenutnog AttributeGroup za web servis.,"    public function getWsProductOptionValues()    {        $result = Db::getInstance()->executeS(            'SELECT a.id_attribute AS idFROM `' . _DB_PREFIX_ . 'attribute` a' . Shop::addSqlAssociation('attribute', 'a') . 'WHERE a.id_attribute_group = ' . (int) $this->id        );        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_AttributeGroup_838, Move a group attribute.\n\n @param bool $direction Up (1) or Down (0)\n @param int $position\n\n @return bool Update result\n,Premeötanje atributa grupe.,"    public function updatePosition($direction, $position)    {        if (!$res = Db::getInstance()->executeS(            'SELECT ag.`position`, ag.`id_attribute_group`FROM `' . _DB_PREFIX_ . 'attribute_group` agWHERE ag.`id_attribute_group` = ' . (int) Tools::getValue('id_attribute_group', 1) . 'ORDER BY ag.`position` ASC'        )) {            return false;        }        foreach ($res as $groupAttribute) {            if ((int) $groupAttribute['id_attribute_group'] == (int) $this->id) {                $movedGroupAttribute = $groupAttribute;            }        }        if (!isset($movedGroupAttribute) || !isset($position)) {            return false;        }        // < and > statements rather than BETWEEN operator        // since BETWEEN is treated differently according to databases        return Db::getInstance()->execute(            'UPDATE `' . _DB_PREFIX_ . 'attribute_group`SET `position`= `position` ' . ($direction ? '- 1' : '+ 1') . 'WHERE `position`' . ($direction                ? '> ' . (int) $movedGroupAttribute['position'] . ' AND `position` <= ' . (int) $position                : '< ' . (int) $movedGroupAttribute['position'] . ' AND `position` >= ' . (int) $position)        ) && Db::getInstance()->execute('UPDATE `' . _DB_PREFIX_ . 'attribute_group`SET `position` = ' . (int) $position . 'WHERE `id_attribute_group`=' . (int) $movedGroupAttribute['id_attribute_group']);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Attribute_827, Get minimal quantity for product with attributes quantity.\n\n @param int $idProductAttribute Product Attribute ID\n\n @return mixed Minimal quantity or false if no result\n, Vra?a minimalnu koli?inu proizvoda sa koli?inom atributa. ,    public static function getAttributeMinimalQty($idProductAttribute)    {        $minimalQuantity = Db::getInstance()->getValue(            'SELECT `minimal_quantity`FROM `' . _DB_PREFIX_ . 'product_attribute_shop` pasWHERE `id_shop` = ' . (int) Context::getContext()->shop->id . 'AND `id_product_attribute` = ' . (int) $idProductAttribute        );        if ($minimalQuantity > 1) {            return (int) $minimalQuantity;        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_CMSCategory_849, Recursively add specified CMSCategory childs to $toDelete array.\\\\\\\\n\\\\\\\\n @param array &$toDelete Array reference where categories ID will be saved\\\\\\\\n @param array|int $id_cms_category Parent CMSCategory ID\\\\\\\\n,Rekurzivno dodaje specifi?nu CMSCategory decu u $toDelete niz. ,"    protected function recursiveDelete(&$to_delete, $id_cms_category)    {        if (!is_array($to_delete) || !$id_cms_category) {            die(Tools::displayError());        }        $result = Db::getInstance()->executeS('SELECT `id_cms_category`FROM `' . _DB_PREFIX_ . 'cms_category`WHERE `id_parent` = ' . (int) $id_cms_category);        foreach ($result as $row) {            $to_delete[] = (int) $row['id_cms_category'];            $this->recursiveDelete($to_delete, (int) $row['id_cms_category']);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_CMSCategory_850," Directly call the parent of delete, in order to avoid recursion.\\\\n\\\\n @return bool Deletion result\\\\n",Direktno pozovanje roditelja za brisanje kako bi se izbeglo ponavljanje.,    private function deleteLite()    {        return parent::delete();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_CMSCategory_851, Delete pages which are in CMSCategories to delete.\\\\\\\\n\\\\\\\\n @return bool Deletion result\\\\\\\\n,Brisanje stranica u CMSCategory koje su za brisanje. ,"    private function deleteCMS()    {        $result = true;        $cms = new PrestaShopCollection('CMS');        $cms->where('id_cms_category', '=', $this->id);        foreach ($cms as $c) {            $result &= $c->delete();        }        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_CMSCategory_854, Hide CMSCategory prefix used for position.\\\\n\\\\n @param string $name CMSCategory name\\\\n\\\\n @return string Name without position\\\\n,Skriva CMSCategory prefiks koji se koristi za poziciju. ,"    public static function hideCMSCategoryPosition($name)    {        return preg_replace('/^[0-9]+\./', '', $name);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_CMSCategory_855, Return an array of all children of the current CMSCategory.\\n\\n @return PrestaShopCollection Collection of CMSCategory\\n, Vra?a niz sve dece trenutne CMSCategory. ,"    private function getAllChildren()    {        // Get children        $toDelete = [(int) $this->id];        $this->recursiveDelete($toDelete, (int) $this->id);        $toDelete = array_unique($toDelete);        // remove id of current CMSCategory because we want only ids of children        unset($toDelete[0]);        if (count($toDelete)) {            $children = new PrestaShopCollection('CMSCategory');            $children->where('id_cms_category', 'in', $toDelete);            return $children;        }        return $toDelete;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_CMSCategory_856, Check if CMSCategory can be moved in another one.\\n\\n @param int $id_parent Parent candidate\\n\\n @return bool Parent validity\\n, Povera da li se CMSCategory moûe pomeriti u drugu. ,"    public static function checkBeforeMove($id_cms_category, $id_parent)    {        if ($id_cms_category == $id_parent) {            return false;        }        if ($id_parent == 1) {            return true;        }        $i = (int) $id_parent;        while (42) {            $result = Db::getInstance()->getRow('SELECT `id_parent` FROM `' . _DB_PREFIX_ . 'cms_category` WHERE `id_cms_category` = ' . (int) $i);            if (!isset($result['id_parent'])) {                return false;            }            if ($result['id_parent'] == $id_cms_category) {                return false;            }            if ($result['id_parent'] == 1) {                return true;            }            $i = $result['id_parent'];        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Respect_Validation_CustomRule_1795, Example of a custom rule that does not have an exception.\\\\n\\\\n @author Casey McLaughlin <caseyamcl@gmail.com>\\\\n,Primer prilago?enog pravila koje nema izuzetak.,final class CustomRule extends AbstractRule{    /**     * {@inheritDoc}     */    public function validate($input): bool    {        return false;    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Respect_Validation_Factory_1756, Returns the default instance of the Factory.\\n, Vra?a podrazumevanu vrednost instance Factory.,    public static function getDefaultInstance(): self    {        if (self::$defaultInstance === null) {            self::$defaultInstance = new self();        }        return self::$defaultInstance;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Respect_Validation_Factory_1757, Define the default instance of the Factory.\\\\n, Definiöe podrazumevanu instancu Factory.,    public static function setDefaultInstance(self $defaultInstance): void    {        self::$defaultInstance = $defaultInstance;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Respect_Validation_Stub_1799, Initializes the rule.\n\n @param bool[] ...$validations\n,Inicijalizuje pravilo.,    public function __construct(bool ...$validations)    {        $this->validations = $validations;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Respect_Validation_UndefinedProvider_1792," Returns values that are not considered as ""undefined""\\\\n\\\\n @return mixed[][]\\\\n",Vrac?a vrednosti koje se ne smatraju Ñnedefinisanimaì,"    public function providerForNotUndefined(): array    {        return [            [0],            [0.0],            ['0'],            [false],            [true],            [' '],            [[]],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Respect_Validation_Validator_1777, Create a new rule by the name of the method and adds the rule to the chain.\\\\n\\\\n @param mixed[] $arguments\\\\n\\\\n @throws ComponentException\\\\n,Kreira novo pravilo po imenu metode i dodaje pravilo lancu.,"    public function __call(string $ruleName, array $arguments): self    {        $this->addRule(Factory::getDefaultInstance()->rule($ruleName, $arguments));        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1186," Re-usable, serializable priority queue implementation\n\n SplPriorityQueue acts as a heap; on iteration, each item is removed from the\n queue. If you wish to re-use such a queue, you need to clone it first. This\n makes for some interesting issues if you wish to delete items from the queue,\n or, as already stated, iterate over it multiple times.\n\n This class aggregates items for the queue itself, but also composes an\n ""inner"" iterator in the form of an SplPriorityQueue object for performing\n the actual iteration.\n\n @psalm-template T\n @implements IteratorAggregate<int, T>\n"," Ponovno iskoristiva, serijalizovna implementacija prioritetnog reda","class PriorityQueue implements Countable, IteratorAggregate, Serializable{    const EXTR_DATA     = 0x00000001;    const EXTR_PRIORITY = 0x00000002;    const EXTR_BOTH     = 0x00000003;    /**     * Inner queue class to use for iteration     * @var string     */    protected $queueClass = SplPriorityQueue::class;    /**     * Actual items aggregated in the priority queue. Each item is an array     * with keys ""data"" and ""priority"".     * @var array     */    protected $items      = [];    /**     * Inner queue object     * @var SplPriorityQueue     */    protected $queue;    /**     * Insert an item into the queue     *     * Priority defaults to 1 (low priority) if none provided.     *     * @param  mixed $data     * @param  int $priority     * @return PriorityQueue     *     * @psalm-param T $data     * @psalm-return PriorityQueue<T>     */    public function insert($data, $priority = 1)    {        $priority = (int) $priority;        $this->items[] = [            'data'     => $data,            'priority' => $priority,        ];        $this->getQueue()->insert($data, $priority);        return $this;    }    /**     * Remove an item from the queue     *     * This is different than {@link extract()}; its purpose is to dequeue an     * item.     *     * This operation is potentially expensive, as it requires     * re-initialization and re-population of the inner queue.     *     * Note: this removes the first item matching the provided item found. If     * the same item has been added multiple times, it will not remove other     * instances.     *     * @param  mixed $datum     * @return bool False if the item was not found, true otherwise.     *     * @psalm-param T $datum     */    public function remove($datum)    {        $found = false;        foreach ($this->items as $key => $item) {            if ($item['data'] === $datum) {                $found = true;                break;            }        }        if ($found) {            unset($this->items[$key]);            $this->queue = null;            if (! $this->isEmpty()) {                $queue = $this->getQueue();                foreach ($this->items as $item) {                    $queue->insert($item['data'], $item['priority']);                }            }            return true;        }        return false;    }    /**     * Is the queue empty?     *     * @return bool     */    public function isEmpty()    {        return (0 === $this->count());    }    /**     * How many items are in the queue?     *     * @return int     */    public function count()    {        return count($this->items);    }    /**     * Peek at the top node in the queue, based on priority.     *     * @return mixed     */    public function top()    {        return $this->getIterator()->top();    }    /**     * Extract a node from the inner queue and sift up     *     * @return mixed     */    public function extract()    {        $value = $this->getQueue()->extract();        $keyToRemove = null;        $highestPriority = null;        foreach ($this->items as $key => $item) {            if ($item['data'] !== $value) {                continue;            }            if (null === $highestPriority) {                $highestPriority = $item['priority'];                $keyToRemove = $key;                continue;            }            if ($highestPriority >= $item['priority']) {                continue;            }            $highestPriority = $item['priority'];            $keyToRemove = $key;        }        if ($keyToRemove !== null) {            unset($this->items[$keyToRemove]);        }        return $value;    }    /**     * Retrieve the inner iterator     *     * SplPriorityQueue acts as a heap, which typically implies that as items     * are iterated, they are also removed. This does not work for situations     * where the queue may be iterated multiple times. As such, this class     * aggregates the values, and also injects an SplPriorityQueue. This method     * retrieves the inner queue object, and clones it for purposes of     * iteration.     *     * @return SplPriorityQueue     *     * @psalm-return SplPriorityQueue<T>     */    public function getIterator()    {        $queue = $this->getQueue();        return clone $queue;    }    /**     * Serialize the data structure     *     * @return string     */    public function serialize()    {        return serialize($this->items);    }    /**     * Unserialize a string into a PriorityQueue object     *     * Serialization format is compatible with {@link Laminas\Stdlib\SplPriorityQueue}     *     * @param  string $data     * @return void     */    public function unserialize($data)    {        foreach (unserialize($data) as $item) {            $this->insert($item['data'], $item['priority']);        }    }    /**     * Serialize to an array     *     * By default, returns only the item data, and in the order registered (not     * sorted). You may provide one of the EXTR_* flags as an argument, allowing     * the ability to return priorities or both data and priority.     *     * @param  int $flag     * @return array     */    public function toArray($flag = self::EXTR_DATA)    {        switch ($flag) {            case self::EXTR_BOTH:                return $this->items;            case self::EXTR_PRIORITY:                return array_map(function ($item) {                    return $item['priority'];                }, $this->items);            case self::EXTR_DATA:            default:                return array_map(function ($item) {                    return $item['data'];                }, $this->items);        }    }    /**     * Specify the internal queue class     *     * Please see {@link getIterator()} for details on the necessity of an     * internal queue class. The class provided should extend SplPriorityQueue.     *     * @param  string $class     * @return PriorityQueue     *     * @psalm-return PriorityQueue<T>     */    public function setInternalQueueClass($class)    {        $this->queueClass = (string) $class;        return $this;    }    /**     * Does the queue contain the given datum?     *     * @param  mixed $datum     * @return bool     *     * @psalm-param T $datum     */    public function contains($datum)    {        foreach ($this->items as $item) {            if ($item['data'] === $datum) {                return true;            }        }        return false;    }    /**     * Does the queue have an item with the given priority?     *     * @param  int $priority     * @return bool     */    public function hasPriority($priority)    {        foreach ($this->items as $item) {            if ($item['priority'] === $priority) {                return true;            }        }        return false;    }    /**     * Get the inner priority queue instance     *     * @throws Exception\DomainException     * @return SplPriorityQueue     */    protected function getQueue()    {        if (null === $this->queue) {            $this->queue = new $this->queueClass();            if (! $this->queue instanceof \SplPriorityQueue) {                throw new Exception\DomainException(sprintf(                    'PriorityQueue expects an internal queue of type SplPriorityQueue; received ""%s""',                    get_class($this->queue)                ));            }        }        return $this->queue;    }    /**     * Add support for deep cloning     *     * @return void     */    public function __clone()    {        if (null !== $this->queue) {            $this->queue = clone $this->queue;        }    }}",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1191, Extract a node from the inner queue and sift up\n\n @return mixed\n,Izvla?enje unutraönjeg ?vor iz unutraönjeg reda i prosejavanje,    public function extract()    {        $value = $this->getQueue()->extract();        $keyToRemove = null;        $highestPriority = null;        foreach ($this->items as $key => $item) {            if ($item['data'] !== $value) {                continue;            }            if (null === $highestPriority) {                $highestPriority = $item['priority'];                $keyToRemove = $key;                continue;            }            if ($highestPriority >= $item['priority']) {                continue;            }            $highestPriority = $item['priority'];            $keyToRemove = $key;        }        if ($keyToRemove !== null) {            unset($this->items[$keyToRemove]);        }        return $value;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1194, Unserialize a string into a PriorityQueue object\n\n Serialization format is compatible with {@link Laminas\\Stdlib\\SplPriorityQueue}\n\n @param  string $data\n @return void\n,Deserializacija stringa u objekat PriorityQueue,"    public function unserialize($data)    {        foreach (unserialize($data) as $item) {            $this->insert($item['data'], $item['priority']);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1195, Specify the internal queue class\n\n Please see {@link getIterator()} for details on the necessity of an\n internal queue class. The class provided should extend SplPriorityQueue.\n\n @param  string $class\n @return PriorityQueue\n\n @psalm-return PriorityQueue<T>\n,Specificira internu klasu reda,    public function setInternalQueueClass($class)    {        $this->queueClass = (string) $class;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1196, Does the queue contain the given datum?\n\n @param  mixed $datum\n @return bool\n\n @psalm-param T $datum\n,Da li red sadrûi zadati datum?,    public function contains($datum)    {        foreach ($this->items as $item) {            if ($item['data'] === $datum) {                return true;            }        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_455," Peek at the top node in the queue, based on priority.\\n\\n @return mixed\\n",Zaviritit u gornji ?vor u redu na osnovu prioriteta.,    public function top()    {        return $this->getIterator()->top();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_458, Serialize the data structure\\n\\n @return string\\n, Serijalizacija strukture podataka,    public function serialize()    {        return serialize($this->items);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_463, Get the inner priority queue instance\\n\\n @throws Exception\\\\DomainException\\n @return SplPriorityQueue\\n,Vra?a instancu unutraönjeg prioritetnog reda,"    protected function getQueue()    {        if (null === $this->queue) {            $this->queue = new $this->queueClass();            if (! $this->queue instanceof \SplPriorityQueue) {                throw new Exception\DomainException(sprintf(                    'PriorityQueue expects an internal queue of type SplPriorityQueue; received ""%s""',                    get_class($this->queue)                ));            }        }        return $this->queue;    }",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_EditDistance_2066," Edit distance (Levenshtein distance).\n Compute the difference between two sequences, ie, the minimum number of changes\n to get to $str2 from $str1\n @param string $str1\n @param string $str2\n @return int the minimum number of changes to transform one string into another\n",Ure?ivanje udaljenosti (Levenshtein udaljenost).,"function editDistance($str1, $str2){    $lenStr1 = strlen($str1);    $lenStr2 = strlen($str2);    if ($lenStr1 == 0) {        return $lenStr2;    }    if ($lenStr2 == 0) {        return $lenStr1;    }    $distanceVectorInit = [];    $distanceVectorFinal = [];    for ($i = 0; $i < $lenStr1 + 1; $i++) {        $distanceVectorInit[] = 0;        $distanceVectorFinal[] = 0;    }    for ($i = 0; $i < $lenStr1 + 1; $i++) {        $distanceVectorInit[$i] = $i;    }    for ($i = 0; $i < $lenStr2; $i++) {        $distanceVectorFinal[0] = $i + 1;        // use formula to fill in the rest of the row        for ($j = 0; $j < $lenStr1; $j++) {            $substitutionCost = 0;            if ($str1[$j] == $str2[$i]) {                $substitutionCost = $distanceVectorInit[$j];            } else {                $substitutionCost = $distanceVectorInit[$j] + 1;            }            $distanceVectorFinal[$j+1] = min($distanceVectorInit[$j+1] + 1, min($distanceVectorFinal[$j] + 1, $substitutionCost));        }        $distanceVectorInit = $distanceVectorFinal;    }    return $distanceVectorFinal[$lenStr1];}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_caesarCipher_2069, Encrypt given text using caesar cipher.\n @param string text text to be encrypted\n @param int shift number of shifts to be applied\n @return string new encrypted text\n,Enkriptovanje datog teksta koriö?enjem Cezarovog öifrovanja.,"function encrypt(string $text, int $shift): string{    $encryptedText = ''; // Empty string to store encrypted text    foreach (str_split($text) as $c) { // Going through each character        if (ctype_alpha($c)) {            $placeValue = ord($c) - ord(ctype_upper($c) ? 'A' : 'a'); // Getting value of character (i.e. 0-25)            $placeValue = ($placeValue + $shift) % 26; // Applying encryption formula            $placeValue += ord(ctype_upper($c) ? 'A' : 'a');            $newChar = chr($placeValue); // Getting new character from new value (i.e. A-Z)            $encryptedText .= $newChar; // Appending encrypted character        } else {            $encryptedText .= $c; // Appending the original character        }    }    return $encryptedText; // Returning encrypted text}",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_linear_search_2071," Linear search in PHP\n \n Reference: https://www.geeksforgeeks.org/linear-search/\n \n @param Array $list a array of integers to search\n @param integer $target an integer number to search for in the list\n @return integer the index where the target is found (or -1 if not found)\n \n Examples:\n \n  data =  5, 7, 8, 11, 12, 15, 17, 18, 20\n  \n  x = 15\n  Element found at position 6\n  \n  x = 1\n  Element not found\n \n",Linearna pretraga u PHP,"function linear_search($list, $target) #Linear Search  { $n = sizeof($list);     for($i = 0; $i < $n; $i++)     {         if($list[$i] == $target)             return $i+1;     }     return -1;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
YOURLS_YOURLS_functions-geo_708, Return flag URL from 2 letter country code\n @param string $code\n @return string\n,Vra?a zastavu URL na osnovu 2 slova drûanog koda,function yourls_geo_get_flag( $code ) {    if ( !file_exists( YOURLS_INC.'/geo/flags/flag_'.strtolower( $code ).'.gif' ) ) {        $code = '';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_LaravelDebugbar_101," Enable the Debugbar and boot, if not already booted.\n","Omogu?iti Debugbar i pokrenuti, ako ve? nije pokrenut.",    public function enable()    {        $this->enabled = true;        if (!$this->booted) {            $this->boot();        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_LaravelDebugbar_102," Boot the debugbar (add collectors, renderer and listener)\n","Pokrenuti debugbar (i kolektore, renderere, i osluökiva?e)","    public function boot()    {        if ($this->booted) {            return;        }        /** @var \Barryvdh\Debugbar\LaravelDebugbar $debugbar */        $debugbar = $this;        /** @var Application $app */        $app = $this->app;        // Set custom error handler        if ($app['config']->get('debugbar.error_handler', false)) {            set_error_handler([$this, 'handleError']);        }        $this->selectStorage($debugbar);        if ($this->shouldCollect('phpinfo', true)) {            $this->addCollector(new PhpInfoCollector());        }        if ($this->shouldCollect('messages', true)) {            $this->addCollector(new MessagesCollector());        }        if ($this->shouldCollect('time', true)) {            $startTime = $app['request']->server('REQUEST_TIME_FLOAT');            $this->addCollector(new TimeDataCollector($startTime));            if (! $this->isLumen() && $startTime) {                $this->app->booted(                    function () use ($debugbar, $startTime) {                        $debugbar['time']->addMeasure('Booting', $startTime, microtime(true));                    }                );            }            $debugbar->startMeasure('application', 'Application');        }        if ($this->shouldCollect('memory', true)) {            $this->addCollector(new MemoryCollector());        }        if ($this->shouldCollect('exceptions', true)) {            try {                $exceptionCollector = new ExceptionsCollector();                $exceptionCollector->setChainExceptions(                    $this->app['config']->get('debugbar.options.exceptions.chain', true)                );                $this->addCollector($exceptionCollector);            } catch (\Exception $e) {            }        }        if ($this->shouldCollect('laravel', false)) {            $this->addCollector(new LaravelCollector($this->app));        }        if ($this->shouldCollect('default_request', false)) {            $this->addCollector(new RequestDataCollector());        }        if ($this->shouldCollect('events', false) && isset($this->app['events'])) {            try {                $startTime = $this->app['request']->server('REQUEST_TIME_FLOAT');                $eventCollector = new EventCollector($startTime);                $this->addCollector($eventCollector);                $this->app['events']->subscribe($eventCollector);            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add EventCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('views', true) && isset($this->app['events'])) {            try {                $collectData = $this->app['config']->get('debugbar.options.views.data', true);                $this->addCollector(new ViewCollector($collectData));                $this->app['events']->listen(                    'composing:*',                    function ($view, $data = []) use ($debugbar) {                        if ($data) {                            $view = $data[0]; // For Laravel >= 5.4                        }                        $debugbar['views']->addView($view);                    }                );            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add ViewCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if (!$this->isLumen() && $this->shouldCollect('route')) {            try {                $this->addCollector($this->app->make('Barryvdh\Debugbar\DataCollector\RouteCollector'));            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add RouteCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if (!$this->isLumen() && $this->shouldCollect('log', true)) {            try {                if ($this->hasCollector('messages')) {                    $logger = new MessagesCollector('log');                    $this['messages']->aggregate($logger);                    $this->app['log']->listen(                        function ($level, $message = null, $context = null) use ($logger) {                            // Laravel 5.4 changed how the global log listeners are called. We must account for                            // the first argument being an ""event object"", where arguments are passed                            // via object properties, instead of individual arguments.                            if ($level instanceof \Illuminate\Log\Events\MessageLogged) {                                $message = $level->message;                                $context = $level->context;                                $level = $level->level;                            }                            try {                                $logMessage = (string) $message;                                if (mb_check_encoding($logMessage, 'UTF-8')) {                                    $logMessage .= (!empty($context) ? ' ' . json_encode($context) : '');                                } else {                                    $logMessage = ""[INVALID UTF-8 DATA]"";                                }                            } catch (\Exception $e) {                                $logMessage = ""[Exception: "" . $e->getMessage() . ""]"";                            }                            $logger->addMessage(                                '[' . date('H:i:s') . '] ' . ""LOG.$level: "" . $logMessage,                                $level,                                false                            );                        }                    );                } else {                    $this->addCollector(new MonologCollector($this->getMonologLogger()));                }            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add LogsCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('db', true) && isset($this->app['db'])) {            $db = $this->app['db'];            if (                $debugbar->hasCollector('time') && $this->app['config']->get(                    'debugbar.options.db.timeline',                    false                )            ) {                $timeCollector = $debugbar->getCollector('time');            } else {                $timeCollector = null;            }            $queryCollector = new QueryCollector($timeCollector);            $queryCollector->setDataFormatter(new QueryFormatter());            if ($this->app['config']->get('debugbar.options.db.with_params')) {                $queryCollector->setRenderSqlWithParams(true);            }            if ($this->app['config']->get('debugbar.options.db.backtrace')) {                $middleware = ! $this->is_lumen ? $this->app['router']->getMiddleware() : [];                $queryCollector->setFindSource(true, $middleware);            }            if ($this->app['config']->get('debugbar.options.db.backtrace_exclude_paths')) {                $excludePaths = $this->app['config']->get('debugbar.options.db.backtrace_exclude_paths');                $queryCollector->mergeBacktraceExcludePaths($excludePaths);            }            $queryCollector->setDurationBackground($this->app['config']->get('debugbar.options.db.duration_background'));            if ($this->app['config']->get('debugbar.options.db.explain.enabled')) {                $types = $this->app['config']->get('debugbar.options.db.explain.types');                $queryCollector->setExplainSource(true, $types);            }            if ($this->app['config']->get('debugbar.options.db.hints', true)) {                $queryCollector->setShowHints(true);            }            if ($this->app['config']->get('debugbar.options.db.show_copy', false)) {                $queryCollector->setShowCopyButton(true);            }            $this->addCollector($queryCollector);            try {                $db->listen(                    function (                        $query,                        $bindings = null,                        $time = null,                        $connectionName = null                    ) use (                        $db,                        $queryCollector                    ) {                        if (!app(static::class)->shouldCollect('db', true)) {                            return; // Issue 776 : We've turned off collecting after the listener was attached                        }                        // Laravel 5.2 changed the way some core events worked. We must account for                        // the first argument being an ""event object"", where arguments are passed                        // via object properties, instead of individual arguments.                        if ($query instanceof \Illuminate\Database\Events\QueryExecuted) {                            $bindings = $query->bindings;                            $time = $query->time;                            $connection = $query->connection;                            $query = $query->sql;                        } else {                            $connection = $db->connection($connectionName);                        }                        //allow collecting only queries slower than a specified amount of milliseconds                        $threshold = app('config')->get('debugbar.options.db.slow_threshold', false);                        if (!$threshold || $time > $threshold) {                            $queryCollector->addQuery((string)$query, $bindings, $time, $connection);                        }                    }                );            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add listen to Queries for Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }            try {                $db->getEventDispatcher()->listen(                    \Illuminate\Database\Events\TransactionBeginning::class,                    function ($transaction) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Begin Transaction', $transaction->connection);                    }                );                $db->getEventDispatcher()->listen(                    \Illuminate\Database\Events\TransactionCommitted::class,                    function ($transaction) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Commit Transaction', $transaction->connection);                    }                );                $db->getEventDispatcher()->listen(                    \Illuminate\Database\Events\TransactionRolledBack::class,                    function ($transaction) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Rollback Transaction', $transaction->connection);                    }                );                $db->getEventDispatcher()->listen(                    'connection.*.beganTransaction',                    function ($event, $params) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Begin Transaction', $params[0]);                    }                );                $db->getEventDispatcher()->listen(                    'connection.*.committed',                    function ($event, $params) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Commit Transaction', $params[0]);                    }                );                $db->getEventDispatcher()->listen(                    'connection.*.rollingBack',                    function ($event, $params) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Rollback Transaction', $params[0]);                    }                );            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add listen transactions to Queries for Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('models', true)) {            try {                $modelsCollector = $this->app->make('Barryvdh\Debugbar\DataCollector\ModelsCollector');                $this->addCollector($modelsCollector);            } catch (\Exception $e) {                // No Models collector            }        }        if ($this->shouldCollect('livewire', true) && $this->app->bound('livewire')) {            try {                $livewireCollector = $this->app->make('Barryvdh\Debugbar\DataCollector\LivewireCollector');                $this->addCollector($livewireCollector);            } catch (\Exception $e) {                $this->addThrowable(                    new Exception('Cannot add Livewire Collector: ' . $e->getMessage(), $e->getCode(), $e)                );            }        }        if ($this->shouldCollect('mail', true) && class_exists('Illuminate\Mail\MailServiceProvider')) {            try {                $mailer = $this->app['mailer']->getSwiftMailer();                $this->addCollector(new SwiftMailCollector($mailer));                if (                    $this->app['config']->get('debugbar.options.mail.full_log') && $this->hasCollector(                        'messages'                    )                ) {                    $this['messages']->aggregate(new SwiftLogCollector($mailer));                }            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add MailCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('logs', false)) {            try {                $file = $this->app['config']->get('debugbar.options.logs.file');                $this->addCollector(new LogsCollector($file));            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add LogsCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('files', false)) {            $this->addCollector(new FilesCollector($app));        }        if ($this->shouldCollect('auth', false)) {            try {                $guards = $this->app['config']->get('auth.guards', []);                $authCollector = new MultiAuthCollector($app['auth'], $guards);                $authCollector->setShowName(                    $this->app['config']->get('debugbar.options.auth.show_name')                );                $this->addCollector($authCollector);            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add AuthCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('gate', false)) {            try {                $gateCollector = $this->app->make('Barryvdh\Debugbar\DataCollector\GateCollector');                $this->addCollector($gateCollector);            } catch (\Exception $e) {                // No Gate collector            }        }        if ($this->shouldCollect('cache', false) && isset($this->app['events'])) {            try {                $collectValues = $this->app['config']->get('debugbar.options.cache.values', true);                $startTime = $this->app['request']->server('REQUEST_TIME_FLOAT');                $cacheCollector = new CacheCollector($startTime, $collectValues);                $this->addCollector($cacheCollector);                $this->app['events']->subscribe($cacheCollector);            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add CacheCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        $renderer = $this->getJavascriptRenderer();        $renderer->setIncludeVendors($this->app['config']->get('debugbar.include_vendors', true));        $renderer->setBindAjaxHandlerToFetch($app['config']->get('debugbar.capture_ajax', true));        $renderer->setBindAjaxHandlerToXHR($app['config']->get('debugbar.capture_ajax', true));        $this->booted = true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_LaravelDebugbar_106, Adds an exception to be profiled in the debug bar\n\n @param Exception $e\n,Dodaje izuzetak za profilisanje u debug bar-u za otklanjanje greöaka,    public function addThrowable($e)    {        if ($this->hasCollector('exceptions')) {            /** @var \DebugBar\DataCollector\ExceptionsCollector $collector */            $collector = $this->getCollector('exceptions');            $collector->addThrowable($e);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_LaravelDebugbar_117, Magic calls for adding messages\n\n @param string $method\n @param array $args\n @return mixed|void\n, Magi?ni poziv za dodavanje poruka,"    public function __call($method, $args)    {        $messageLevels = ['emergency', 'alert', 'critical', 'error', 'warning', 'notice', 'info', 'debug', 'log'];        if (in_array($method, $messageLevels)) {            foreach ($args as $arg) {                $this->addMessage($arg, $method);            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_LaravelDebugbar_119, Add Server-Timing headers for the TimeData collector\n\n @see https://www.w3.org/TR/server-timing/\n @param Response $response\n,Dodajte zaglavlja Server-Timing za sakuplja? TimeData,"    protected function addServerTimingHeaders(Response $response)    {        if ($this->hasCollector('time')) {            $collector = $this->getCollector('time');            $headers = [];            foreach ($collector->collect()['measures'] as $k => $m) {                $headers[] = sprintf('app;desc=""%s"";dur=%F', str_replace('""', ""'"", $m['label']), $m['duration'] * 1000);            }            $response->headers->set('Server-Timing', $headers, false);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_LumenServiceProvider_122, Get the config path\n\n @return string\n,Vra?a putanju konfiguracije,    protected function getConfigPath()    {        return base_path('config/debugbar.php');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_LumenServiceProvider_123, Register the Debugbar Middleware\n\n @param  string $middleware\n,Registruje Debugbar Middleware,    protected function registerMiddleware($middleware)    {        $this->app->middleware([$middleware]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_ServiceProvider_129, Publish the config file\n\n @param  string $configPath\n, Objavi konfiguracioni fajl,"    protected function publishConfig($configPath)    {        $this->publishes([$configPath => config_path('debugbar.php')], 'config');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
barryvdh_laravel-debugbar_TestCase_151, Get package aliases.\n\n @param  \\Illuminate\\Foundation\\Application  $app\n\n @return array\n,Vra?a pseudonime paketa.,    protected function getPackageAliases($app)    {        return ['Debugbar' => Facade::class];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Benchmark_332, Memory Usage\\n\\n Simply returns the {memory_usage} marker.\\n\\n This permits it to be put it anywhere in a template\\n without the memory being calculated until the end.\\n The output class will swap the real value for this variable.\\n\\n @return\\tstring\\t'{memory_usage}'\\n,Koriö?enje memorije,public function memory_usage(){return '{memory_usage}';},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Common_334, Determines if the current version of PHP is equal to or greater than the supplied value\n\n @param\tstring\n @return\tbool\tTRUE if the current version is $version or higher\n,Utvr?uje da li je trenutna verzija PHP-a jednaka ili vec?a od isporu?ene vrednosti,"function is_php($version){static $_is_php;$version = (string) $version;if ( ! isset($_is_php[$version])){$_is_php[$version] = version_compare(PHP_VERSION, $version, '>=');}return $_is_php[$version];}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Common_335," Tests for file writability\\n\\n is_writable() returns TRUE on Windows servers when you really can't write to\\n the file, based on the read-only attribute.\\n\\n @link\\thttps://bugs.php.net/bug.php?id=54709\\n @param\\tstring\\n @return\\tbool\\n",Testovi za upisivanje u datoteke,"function is_really_writable($file){// If we're on a UNIX-like server, just is_writable()if (DIRECTORY_SEPARATOR === '/'){return is_writable($file);}/* For Windows servers and safe_mode ""on"" installations we'll actually * write a file then read it. Bah... */if (is_dir($file)){$file = rtrim($file, '/').'/'.md5(mt_rand());if (($fp = @fopen($file, 'ab')) === FALSE){return FALSE;}fclose($fp);@chmod($file, 0777);@unlink($file);return TRUE;}elseif ( ! is_file($file) OR ($fp = @fopen($file, 'ab')) === FALSE){return FALSE;}fclose($fp);return TRUE;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Common_337, Returns the MIME types array from config/mimes.php\n\n @return\tarray\n,Vrac?a niz MIME tipova iz config / mimes.php,"function &get_mimes(){static $_mimes;if (empty($_mimes)){$_mimes = file_exists(APPPATH.'config/mimes.php')? include(APPPATH.'config/mimes.php'): array();if (file_exists(APPPATH.'config/'.ENVIRONMENT.'/mimes.php')){$_mimes = array_merge($_mimes, include(APPPATH.'config/'.ENVIRONMENT.'/mimes.php'));}}return $_mimes;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Common_338, Is HTTPS?\\n\\n Determines if the application is accessed via an encrypted\\n (HTTPS) connection.\\n\\n @return\\tbool\\n,Da li je HTTPS?,function is_https(){if ( ! empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off'){return TRUE;}elseif (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) === 'https'){return TRUE;}elseif ( ! empty($_SERVER['HTTP_FRONT_END_HTTPS']) && strtolower($_SERVER['HTTP_FRONT_END_HTTPS']) !== 'off'){return TRUE;}return FALSE;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Config_348, Build URI string\n\n @used-by\tCI_Config::site_url()\n @used-by\tCI_Config::base_url()\n\n @param\tstring|string[]\t$uri\tURI string or an array of segments\n @return\tstring\n, Pravljenje URI stringa ,"protected function _uri_string($uri){if ($this->item('enable_query_strings') === FALSE){is_array($uri) && $uri = implode('/', $uri);return ltrim($uri, '/');}elseif (is_array($uri)){return http_build_query($uri);}return $uri;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Config_349, Set a config file item\n\n @param\tstring\t$item\tConfig item key\n @param\tstring\t$value\tConfig item value\n @return\tvoid\n,Postavljanje stavke konfiguracinog fajla,"public function set_item($item, $value){$this->config[$item] = $value;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Exceptions_357, Native PHP error handler\\n\\n @param\\tint\\t$severity\\tError level\\n @param\\tstring\\t$message\\tError message\\n @param\\tstring\\t$filepath\\tFile path\\n @param\\tint\\t$line\\t\\tLine number\\n @return\\tvoid\\n, Izvorni PHP rukovalac greökama,"public function show_php_error($severity, $message, $filepath, $line){$templates_path = config_item('error_views_path');if (empty($templates_path)){$templates_path = VIEWPATH.'errors'.DIRECTORY_SEPARATOR;}else{$templates_path = rtrim($templates_path, '/\\').DIRECTORY_SEPARATOR;}$severity = isset($this->levels[$severity]) ? $this->levels[$severity] : $severity;// For safety reasons we don't show the full file path in non-CLI requestsif ( ! is_cli()){$filepath = str_replace('\\', '/', $filepath);if (FALSE !== strpos($filepath, '/')){$x = explode('/', $filepath);$filepath = $x[count($x)-2].'/'.end($x);}$template = 'html'.DIRECTORY_SEPARATOR.'error_php';}else{$template = 'cli'.DIRECTORY_SEPARATOR.'error_php';}if (ob_get_level() > $this->ob_level + 1){ob_end_flush();}ob_start();include($templates_path.$template.'.php');$buffer = ob_get_contents();ob_end_clean();echo $buffer;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Input_365, Magic __get()\n\n Allows read access to protected properties\n\n @param\tstring\t$name\n @return\tmixed\n, Magi?ni __get(),public function __get($name){if ($name === 'raw_input_stream'){isset($this->_raw_input_stream) OR $this->_raw_input_stream = file_get_contents('php://input');return $this->_raw_input_stream;}elseif ($name === 'ip_address'){return $this->ip_address;}},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Loader_371, Is Loaded\n\n A utility method to test if a class is in the self::$_ci_classes array.\n\n @used-by\tMainly used by Form Helper function _get_validation_object().\n\n @param \tstring\t\t$class\tClass name to check for\n @return \tstring|bool\tClass object name if loaded or FALSE\n,Da li je u?itano,"public function is_loaded($class){return array_search(ucfirst($class), $this->_ci_classes, TRUE);}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Loader_373, Get Variable\\n\\n Check if a variable is set and retrieve it.\\n\\n @param\\tstring\\t$key\\tVariable name\\n @return\\tmixed\\tThe variable or NULL if not found\\n,Vrati varijablu,public function get_var($key){return isset($this->_ci_cached_vars[$key]) ? $this->_ci_cached_vars[$key] : NULL;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Loader_377, CI Autoloader\\n\\n Loads component listed in the config/autoload.php file.\\n\\n @used-by\\tCI_Loader::initialize()\\n @return\\tvoid\\n, CI Autoloader,"protected function _ci_autoloader(){if (file_exists(APPPATH.'config/autoload.php')){include(APPPATH.'config/autoload.php');}if (file_exists(APPPATH.'config/'.ENVIRONMENT.'/autoload.php')){include(APPPATH.'config/'.ENVIRONMENT.'/autoload.php');}if ( ! isset($autoload)){return;}// Autoload packagesif (isset($autoload['packages'])){foreach ($autoload['packages'] as $package_path){$this->add_package_path($package_path);}}// Load any custom config fileif (count($autoload['config']) > 0){foreach ($autoload['config'] as $val){$this->config($val);}}// Autoload helpers and languagesforeach (array('helper', 'language') as $type){if (isset($autoload[$type]) && count($autoload[$type]) > 0){$this->$type($autoload[$type]);}}// Autoload driversif (isset($autoload['drivers'])){$this->driver($autoload['drivers']);}// Load librariesif (isset($autoload['libraries']) && count($autoload['libraries']) > 0){// Load the database driver.if (in_array('database', $autoload['libraries'])){$this->database();$autoload['libraries'] = array_diff($autoload['libraries'], array('database'));}// Load all other libraries$this->library($autoload['libraries']);}// Autoload modelsif (isset($autoload['model'])){$this->model($autoload['model']);}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bcit-ci_CodeIgniter_Loader_378," Prepare variables for _ci_vars, to be later extract()-ed inside views\n\n Converts objects to associative arrays and filters-out internal\n variable names (i.e. keys prefixed with '_ci_').\n\n @param\tmixed\t$vars\n @return\tarray\n"," Pripremanje varijabli za _ci_vars,  da kasnije budu extract()-ovane unutar pogleda","protected function _ci_prepare_view_vars($vars){if ( ! is_array($vars)){$vars = is_object($vars)? get_object_vars($vars): array();}foreach (array_keys($vars) as $key){if (strncmp($key, '_ci_', 4) === 0){unset($vars[$key]);}}return $vars;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
blueimp_jQuery-File-Upload_UploadHandler_2," Fix for overflowing signed 32 bit integers,\n works for sizes up to 2^32-1 bytes (4 GiB - 1):\n","Ispravka za prekora?njenje 32-bitnih celih brojeva,\n radi sa veli?inama do 2^32-1 bitova (4 GB - 1)",    protected function fix_integer_overflow($size) {        if ($size < 0) {            $size += 2.0 * (PHP_INT_MAX + 1);        },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_CodeCleaner_1453, Get default CodeCleaner passes.\n\n @return array\n,Vra?a podrazumevane propusnice CodeCleaner.,"    private function getDefaultPasses()    {        if ($this->yolo) {            return $this->getYoloPasses();        }        $useStatementPass = new UseStatementPass();        $namespacePass = new NamespacePass($this);        // Try to add implicit `use` statements and an implicit namespace,        // based on the file in which the `debug` call was made.        $this->addImplicitDebugContext([$useStatementPass, $namespacePass]);        return [            // Validation passes            new AbstractClassPass(),            new AssignThisVariablePass(),            new CalledClassPass(),            new CallTimePassByReferencePass(),            new FinalClassPass(),            new FunctionContextPass(),            new FunctionReturnInWriteContextPass(),            new InstanceOfPass(),            new IssetPass(),            new LabelContextPass(),            new LeavePsyshAlonePass(),            new ListPass(),            new LoopContextPass(),            new PassableByReferencePass(),            new ReturnTypePass(),            new EmptyArrayDimFetchPass(),            new ValidConstructorPass(),            // Rewriting shenanigans            $useStatementPass,        // must run before the namespace pass            new ExitPass(),            new ImplicitReturnPass(),            new MagicConstantsPass(),            $namespacePass,           // must run after the implicit return pass            new RequirePass(),            new StrictTypesPass(),            // Namespace-aware validation (which depends on aforementioned shenanigans)            new ValidClassNamePass(),            new ValidConstantPass(),            new ValidFunctionNamePass(),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_CodeCleaner_1456, Search the stack trace for a file in which the user called Psy\\debug.\n\n @return string|null\n,Pretraûivanje traga steka za datoteku u kojoj je korisnik nazvao Psi,"    private static function getDebugFile()    {        $trace = \debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS);        foreach (\array_reverse($trace) as $stackFrame) {            if (!self::isDebugCall($stackFrame)) {                continue;            }            if (\preg_match('/eval\(/', $stackFrame['file'])) {                \preg_match_all('/([^\(]+)\((\d+)/', $stackFrame['file'], $matches);                return $matches[1][0];            }            return $stackFrame['file'];        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_ConfigPaths_1468, Find real config files in config directories.\n\n @param string[] $names Config file names\n\n @return string[]\n,Pronalaûenje prave konfiguracione datoteke u direktorijumima konfiguracije.,"    public function configFiles(array $names)    {        return $this->allRealFiles($this->configDirs(), $names);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_ConfigPaths_1477," Ensure that $file exists and is writable, make the parent directory if necessary.\n\n Generates E_USER_NOTICE error if either $file or its directory is not writable.\n\n @param string $file\n\n @return string|false Full path to $file, or false if file is not writable\n","Osigurava da $file postoji i da se moûe u njega upisati, ako je potrebno pravi roditeljski direktorijum. ","    public static function touchFileWithMkdir($file)    {        if (\file_exists($file)) {            if (\is_writable($file)) {                return $file;            }            \trigger_error(\sprintf('Writing to %s is not allowed.', $file), \E_USER_NOTICE);            return false;        }        if (!self::ensureDir(\dirname($file))) {            return false;        }        \touch($file);        return $file;    }",0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1480," Get the desired config file from the given input.\n\n @return string|null config file path, or null if none is specified\n",Vra?a ûeljenu konfiguracionu datoteku sa datog ulaza.,"    private static function getConfigFileFromInput(InputInterface $input)    {        // Best case, input is properly bound and validated.        if ($input->hasOption('config')) {            return $input->getOption('config');        }        return $input->getParameterOption('--config', null, true) ?: $input->getParameterOption('-c', null, true);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1491, Set the shell's data directory location.\n\n @param string $dir\n,Postavlja lokaciju direktorijuma podataka ljuske.,"    public function setDataDir($dir)    {        $this->dataDir = (string) $dir;        $this->configPaths->overrideDirs([            'configDir'  => $this->configDir,            'dataDir'    => $this->dataDir,            'runtimeDir' => $this->runtimeDir,        ]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1493, Set the shell's temporary directory location.\n\n @param string $dir\n,Postavlja trenutnu lokaciju direktorijuma podataka ljuske.,"    public function setRuntimeDir($dir)    {        $this->runtimeDir = (string) $dir;        $this->configPaths->overrideDirs([            'configDir'  => $this->configDir,            'dataDir'    => $this->dataDir,            'runtimeDir' => $this->runtimeDir,        ]);    }",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1498, Get the readline max history size.\n\n @return int\n,Vra?a maksimalnu veli?inu istorije za ?itanje.,    public function getHistorySize()    {        return $this->historySize;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1499, Sets whether readline erases old duplicate history entries.\n\n @param bool $value\n,Postavlja da li linija za ?itanje briöe stare duplikate unosa istorije.,    public function setEraseDuplicates($value)    {        $this->eraseDuplicates = (bool) $value;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1502, Get a filename suitable for a FIFO pipe of $type for process $pid.\n\n The pipe will be created inside the current temporary directory.\n\n @param string $type\n @param int    $pid\n\n @return string Pipe name\n,Vra?a naziv datoteke pogodan za FIFO cev $type za proces $pid.,"    public function getPipe($type, $pid)    {        return \sprintf('%s/%s_%s', $this->getRuntimeDir(), $type, $pid);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1513," Check whether to use Pcntl.\n\n If `setUsePcntl` has been set to true, but Pcntl is not actually\n available, this will return false.\n\n @return bool True if the current Shell should use Pcntl\n",Proverava da li da koristi Pcntl.,    public function usePcntl()    {        return isset($this->usePcntl) ? ($this->hasPcntl && $this->usePcntl) : $this->hasPcntl;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1518," Enable or disable Unicode in PsySH specific output.\n\n Note that this does not disable Unicode output in general, it just makes\n it so PsySH won't output any itself.\n\n @param bool $useUnicode\n",Omoguc?ite ili onemoguc?ite Unicode u izlazu specifi?nom za PsiSH.,    public function setUseUnicode($useUnicode)    {        $this->useUnicode = (bool) $useUnicode;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1519," Check whether to use Unicode in PsySH specific output.\n\n Note that this does not disable Unicode output in general, it just makes\n it so PsySH won't output any itself.\n\n @return bool\n",Proverava da li treba koristiti Unicode u izlazu specifi?nom za PsiSH.,    public function useUnicode()    {        if (isset($this->useUnicode)) {            return $this->useUnicode;        }        // @todo detect `chsh` != 65001 on Windows and return false        return true;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1526, Enable or disable tab completion.\n\n @param bool $useTabCompletion\n,Omoguc?ite ili onemoguc?ite dovröavanje.,    public function setUseTabCompletion($useTabCompletion)    {        $this->useTabCompletion = (bool) $useTabCompletion;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1528," Check whether to use tab completion.\n\n If `setUseTabCompletion` has been set to true, but readline is not\n actually available, this will return false.\n\n @return bool True if the current Shell should use tab completion\n",Proveravnje da li treba koristiti zavröetak kartice.,    public function useTabCompletion()    {        return isset($this->useTabCompletion) ? ($this->hasReadline && $this->useTabCompletion) : $this->hasReadline;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1531," Get a Shell Output service instance.\n\n If none has been explicitly provided, this will create a new instance\n with the configured verbosity and output pager supplied by self::getPager\n\n @see self::verbosity\n @see self::getPager\n\n @return ShellOutput\n", Vra?a instancu usluge Shell Output.,"    public function getOutput()    {        if (!isset($this->output)) {            $this->setOutput(new ShellOutput(                $this->getOutputVerbosity(),                null,                null,                $this->getPager()            ));            // This is racy because `getOutputDecorated` needs access to the            // output stream to figure out if it's piped or not, so create it            // first, then update after we have a stream.            $decorated = $this->getOutputDecorated();            if ($decorated !== null) {                $this->output->setDecorated($decorated);            }        }        return $this->output;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1533, Get the interactive setting for shell input.\n\n @return bool\n,Vra?a interaktivno podeöavanje za unos ljuske.,    public function getInputInteractive()    {        switch ($this->interactiveMode()) {            case self::INTERACTIVE_MODE_AUTO:                return !$this->inputIsPiped();            case self::INTERACTIVE_MODE_FORCED:                return true;            case self::INTERACTIVE_MODE_DISABLED:                return false;        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1534," Set the OutputPager service.\n\n If a string is supplied, a ProcOutputPager will be used which shells out\n to the specified command.\n\n @throws \\InvalidArgumentException if $pager is not a string or OutputPager instance\n\n @param string|OutputPager $pager\n",Postavljanje usluge OutputPager.,    public function setPager($pager)    {        if ($pager && !\is_string($pager) && !$pager instanceof OutputPager) {            throw new \InvalidArgumentException('Unexpected pager instance');        }        $this->pager = $pager;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1536, Set the Shell AutoCompleter service.\n\n @param AutoCompleter $autoCompleter\n,Postavljanje usluge Shell AutoCompleter.,    public function setAutoCompleter(AutoCompleter $autoCompleter)    {        $this->autoCompleter = $autoCompleter;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1548, Add an array of casters definitions.\n\n @param array $casters\n,Dodavamnje niz definicija kota?ic?a.,    public function addCasters(array $casters)    {        $this->getPresenter()->addCasters($casters);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1566, Set the force array indexes.\n\n @param bool $forceArrayIndexes\n,Postavljanje indeksa niza sila.,    public function setForceArrayIndexes($forceArrayIndexes)    {        $this->forceArrayIndexes = $forceArrayIndexes;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1568," Internal method for applying output formatter style customization.\n\n This is called on initialization of the shell output, and again if the\n formatter styles config is updated.\n",Interna metoda za primenu prilago?avanja stila izlaznog formatera.,"    private function applyFormatterStyles()    {        $formatter = $this->output->getFormatter();        foreach ($this->formatterStyles as $name => $style) {            $formatter->setStyle($name, $style);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Configuration_1570, Set the shell output verbosity.\n\n Accepts OutputInterface verbosity constants.\n\n @param string $verbosity\n, Podesite opöirnost izlaza ljuske.,"    public function setVerbosity($verbosity)    {        $validVerbosityLevels = [            self::VERBOSITY_QUIET,            self::VERBOSITY_NORMAL,            self::VERBOSITY_VERBOSE,            self::VERBOSITY_VERY_VERBOSE,            self::VERBOSITY_DEBUG,        ];        if (!\in_array($verbosity, $validVerbosityLevels)) {            throw new \InvalidArgumentException('Invalid verbosity level: '.$verbosity);        }        $this->verbosity = $verbosity;        if (isset($this->output)) {            $this->output->setVerbosity($this->getOutputVerbosity());        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Context_1578," The Shell execution context.\n\n This class encapsulates the current variables, most recent return value and\n exception, and the current namespace.\n",Kontekst izvröenja Shell.,"class Context{    private static $specialNames = ['_', '_e', '__out', '__psysh__', 'this'];    // Whitelist a very limited number of command-scope magic variable names.    // This might be a bad idea, but future me can sort it out.    private static $commandScopeNames = [        '__function', '__method', '__class', '__namespace', '__file', '__line', '__dir',    ];    private $scopeVariables = [];    private $commandScopeVariables = [];    private $returnValue;    private $lastException;    private $lastStdout;    private $boundObject;    private $boundClass;    /**     * Get a context variable.     *     * @throws \InvalidArgumentException If the variable is not found in the current context     *     * @param string $name     *     * @return mixed     */    public function get($name)    {        switch ($name) {            case '_':                return $this->returnValue;            case '_e':                if (isset($this->lastException)) {                    return $this->lastException;                }                break;            case '__out':                if (isset($this->lastStdout)) {                    return $this->lastStdout;                }                break;            case 'this':                if (isset($this->boundObject)) {                    return $this->boundObject;                }                break;            case '__function':            case '__method':            case '__class':            case '__namespace':            case '__file':            case '__line':            case '__dir':                if (\array_key_exists($name, $this->commandScopeVariables)) {                    return $this->commandScopeVariables[$name];                }                break;            default:                if (\array_key_exists($name, $this->scopeVariables)) {                    return $this->scopeVariables[$name];                }                break;        }        throw new \InvalidArgumentException('Unknown variable: $'.$name);    }    /**     * Get all defined variables.     *     * @return array     */    public function getAll()    {        return \array_merge($this->scopeVariables, $this->getSpecialVariables());    }    /**     * Get all defined magic variables: $_, $_e, $__out, $__class, $__file, etc.     *     * @return array     */    public function getSpecialVariables()    {        $vars = [            '_' => $this->returnValue,        ];        if (isset($this->lastException)) {            $vars['_e'] = $this->lastException;        }        if (isset($this->lastStdout)) {            $vars['__out'] = $this->lastStdout;        }        if (isset($this->boundObject)) {            $vars['this'] = $this->boundObject;        }        return \array_merge($vars, $this->commandScopeVariables);    }    /**     * Set all scope variables.     *     * This method does *not* set any of the magic variables: $_, $_e, $__out,     * $__class, $__file, etc.     *     * @param array $vars     */    public function setAll(array $vars)    {        foreach (self::$specialNames as $key) {            unset($vars[$key]);        }        foreach (self::$commandScopeNames as $key) {            unset($vars[$key]);        }        $this->scopeVariables = $vars;    }    /**     * Set the most recent return value.     *     * @param mixed $value     */    public function setReturnValue($value)    {        $this->returnValue = $value;    }    /**     * Get the most recent return value.     *     * @return mixed     */    public function getReturnValue()    {        return $this->returnValue;    }    /**     * Set the most recent Exception.     *     * @param \Exception $e     */    public function setLastException(\Exception $e)    {        $this->lastException = $e;    }    /**     * Get the most recent Exception.     *     * @throws \InvalidArgumentException If no Exception has been caught     *     * @return \Exception|null     */    public function getLastException()    {        if (!isset($this->lastException)) {            throw new \InvalidArgumentException('No most-recent exception');        }        return $this->lastException;    }    /**     * Set the most recent output from evaluated code.     *     * @param string $lastStdout     */    public function setLastStdout($lastStdout)    {        $this->lastStdout = $lastStdout;    }    /**     * Get the most recent output from evaluated code.     *     * @throws \InvalidArgumentException If no output has happened yet     *     * @return string|null     */    public function getLastStdout()    {        if (!isset($this->lastStdout)) {            throw new \InvalidArgumentException('No most-recent output');        }        return $this->lastStdout;    }    /**     * Set the bound object ($this variable) for the interactive shell.     *     * Note that this unsets the bound class, if any exists.     *     * @param object|null $boundObject     */    public function setBoundObject($boundObject)    {        $this->boundObject = \is_object($boundObject) ? $boundObject : null;        $this->boundClass = null;    }    /**     * Get the bound object ($this variable) for the interactive shell.     *     * @return object|null     */    public function getBoundObject()    {        return $this->boundObject;    }    /**     * Set the bound class (self) for the interactive shell.     *     * Note that this unsets the bound object, if any exists.     *     * @param string|null $boundClass     */    public function setBoundClass($boundClass)    {        $this->boundClass = (\is_string($boundClass) && $boundClass !== '') ? $boundClass : null;        $this->boundObject = null;    }    /**     * Get the bound class (self) for the interactive shell.     *     * @return string|null     */    public function getBoundClass()    {        return $this->boundClass;    }    /**     * Set command-scope magic variables: $__class, $__file, etc.     *     * @param array $commandScopeVariables     */    public function setCommandScopeVariables(array $commandScopeVariables)    {        $vars = [];        foreach ($commandScopeVariables as $key => $value) {            // kind of type check            if (\is_scalar($value) && \in_array($key, self::$commandScopeNames)) {                $vars[$key] = $value;            }        }        $this->commandScopeVariables = $vars;    }    /**     * Get command-scope magic variables: $__class, $__file, etc.     *     * @return array     */    public function getCommandScopeVariables()    {        return $this->commandScopeVariables;    }    /**     * Get unused command-scope magic variables names: __class, __file, etc.     *     * This is used by the shell to unset old command-scope variables after a     * new batch is set.     *     * @return array Array of unused variable names     */    public function getUnusedCommandScopeVariableNames()    {        return \array_diff(self::$commandScopeNames, \array_keys($this->commandScopeVariables));    }    /**     * Check whether a variable name is a magic variable.     *     * @param string $name     *     * @return bool     */    public static function isSpecialVariableName($name)    {        return \in_array($name, self::$specialNames) || \in_array($name, self::$commandScopeNames);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Context_1580, Get all defined variables.\n\n @return array\n,Vra?a sve definisane promenljive.,"    public function getAll()    {        return \array_merge($this->scopeVariables, $this->getSpecialVariables());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Context_1585, Set the most recent Exception.\n\n @param \\Exception $e\n,Postavite najnoviji izuzetak.,    public function setLastException(\Exception $e)    {        $this->lastException = $e;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_Context_1596, Check whether a variable name is a magic variable.\n\n @param string $name\n\n @return bool\n,Proverava da li je ime promenljive magi?na promenljiva.,"    public static function isSpecialVariableName($name)    {        return \in_array($name, self::$specialNames) || \in_array($name, self::$commandScopeNames);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_ArrayCache_1302, Determine if an item exists in the cache.\n\n @param  string $key\n @return bool\n,Odre?uje da li stavka postoji u keö memoriji.,    public function has($key)    {        return isset($this->cache[$key]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotManDriverEventTest_1353, Return the event payload.\n\n @return mixed\n,Vrati korisni teret doga?aja.,"    public function getPayload()    {        return [            'event' => 'test_event',            'data' => 'foo',        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_1271, Get the parameter names for the route.\n\n @param $value\n @return array\n,Vra?a ime parametara za rutu.,"    protected function compileParameterNames($value)    {        preg_match_all(Matcher::PARAM_NAME_REGEX, $value, $matches);        return array_map(function ($m) {            return trim($m, '?');        }, $matches[1]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_1274, Listening for image files.\n\n @param $callback\n @return Command\n,Osluökiva? za slike.,"    public function receivesVideos($callback)    {        return $this->hears(Video::PATTERN, $callback);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_1275, Listening for audio files.\n\n @param $callback\n @return Command\n,Osluökiva? za zvu?ne fajlove.,"    public function receivesAudio($callback)    {        return $this->hears(Audio::PATTERN, $callback);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_1278, Listening for files attachment.\n\n @param $callback\n @return Command\n,Osluökiva? za priloge.,"    public function receivesFiles($callback)    {        return $this->hears(File::PATTERN, $callback);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_1281, Try to match messages with the ones we should\n listen to.\n, Pokuöaj da se upare poruke sa onima kojima bi trebali,"    public function listen()    {        try {            $isVerificationRequest = $this->verifyServices();            if (! $isVerificationRequest) {                $this->fireDriverEvents();                if ($this->firedDriverEvents === false) {                    $this->loadActiveConversation();                    if ($this->loadedConversation === false) {                        $this->callMatchingMessages();                    }                    /*                     * If the driver has a  ""messagesHandled"" method, call it.                     * This method can be used to trigger driver methods                     * once the messages are handles.                     */                    if (method_exists($this->getDriver(), 'messagesHandled')) {                        $this->getDriver()->messagesHandled();                    }                }                $this->firedDriverEvents = false;                $this->message = new IncomingMessage('', '', '', null, $this->config['bot_id']);            }        } catch (\Throwable $e) {            $this->exceptionHandler->handleException($e, $this);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_527, Set a fallback message to use if no listener matches.\\n\\n @param callable $callback\\n,Podesite rezervnu poruku koja c?e se koristiti ako se nijedan osluökiva? ne podudara,    public function fallback($callback)    {        $this->fallbackMessage = $callback;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_538, Listening for image files.\\n\\n @param $callback\\n @return Command\\n,Osluökiva? za slike.,"    public function receivesImages($callback)    {        return $this->hears(Image::PATTERN, $callback);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_541, Listening for location attachment.\\n\\n @param $callback\\n @return Command\\n,Oslukiva? za priloge lokacije. ,"    public function receivesLocation($callback)    {        return $this->hears(Location::PATTERN, $callback);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_544, Create a command group with shared attributes.\\n\\n @param  array $attributes\\n @param  \\\\Closure $callback\\n,Kreiranje grupe naredbi sa deljenim atributima.,"    public function group(array $attributes, Closure $callback)    {        $previousGroupAttributes = $this->groupAttributes;        $this->groupAttributes = array_merge_recursive($previousGroupAttributes, $attributes);        \call_user_func($callback, $this);        $this->groupAttributes = $previousGroupAttributes;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_547, Call matching message callbacks.\\n,Povratni pozivi za podudaranje poziva.,"    protected function callMatchingMessages()    {        $matchingMessages = $this->conversationManager->getMatchingMessages($this->getMessages(), $this->middleware,            $this->getConversationAnswer(), $this->getDriver());        foreach ($matchingMessages as $matchingMessage) {            $this->command = $matchingMessage->getCommand();            $callback = $this->command->getCallback();            $callback = $this->getCallable($callback);            // Set the message first, so it's available for middlewares            $this->message = $matchingMessage->getMessage();            $commandMiddleware = Collection::make($this->command->getMiddleware())->filter(function ($middleware) {                return $middleware instanceof Heard;            })->toArray();            $this->message = $this->middleware->applyMiddleware('heard', $matchingMessage->getMessage(),                $commandMiddleware);            $parameterNames = $this->compileParameterNames($this->command->getPattern());            $parameters = $matchingMessage->getMatches();            if (\count($parameterNames) !== \count($parameters)) {                $parameters = array_merge(                //First, all named parameters (eg. function ($a, $b, $c))                    array_filter(                        $parameters,                        '\is_string',                        ARRAY_FILTER_USE_KEY                    ),                    //Then, all other unsorted parameters (regex non named results)                    array_filter(                        $parameters,                        '\is_integer',                        ARRAY_FILTER_USE_KEY                    )                );            }            $this->matches = $parameters;            array_unshift($parameters, $this);            $parameters = $this->conversationManager->addDataParameters($this->message, $parameters);            if (call_user_func_array($callback, array_values($parameters))) {                return;            }        }        if (empty($matchingMessages) && empty($this->getBotMessages()) && ! \is_null($this->fallbackMessage)) {            $this->callFallbackMessage();        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_560, Load driver on wakeup.\\n,U?itajte drajvera pri bu?enju.,"    public function __wakeup()    {        $this->driver = DriverManager::loadFromName($this->driverName, $this->config);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_CodeIgniterCache_1305, Determine if an item exists in the cache.\n\n @param  string $key\n @return bool\n,Odre?uje da li stavka postoji u keö memoriji.,    public function has($key)    {        return $this->cache->get($key) !== false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_LaravelCache_1312, Store an item in the cache.\n\n @param  string $key\n @param  mixed $value\n @param  \\DateTime|int $minutes\n @return void\n, Spremanje stavku u keö memoriju.,"    public function put($key, $value, $minutes)    {        if (! $minutes instanceof \DateTime) {            $minutes = $minutes * 60;        }        Cache::put($key, $value, $minutes);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_AbstractTestCase_385, Standardize given set of dates (or period) before assertion.\n\n @param array|\\DatePeriod $dates\n\n @return array\n,Standardizujte dati datum (ili period) pre tvrdnje.,    public function standardizeDates($dates)    {        $result = [];        foreach ($dates as $date) {            if ($date instanceof DateTime) {                $date = Carbon::instance($date);            } elseif (is_string($date)) {                $date = Carbon::parse($date);            }            $result[] = $date->format('Y-m-d H:i:s P');        }        return $result;    },0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_AddTest_402, Test non plural methods with non default args.\\n,Testiramke metode bez mnoûine sa nepodrazumevanim argumentima.,"    public function testAddYearPassingArg()    {        // addYear should ideally be used without argument        /** @var mixed $date */        $date = Carbon::createFromDate(1975);        $this->assertSame(1977, $date->addYear(2)->year);        $this->assertSame(1977, Carbon::createFromDate(1975)->add(2, 'year')->year);        $this->assertSame(1977, Carbon::createFromDate(1975)->add(2, 'years')->year);        $this->assertSame(1977, Carbon::createFromDate(1975)->add(CarbonInterval::years(2))->year);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonImmutable_4, Create a very old date representing start of time.\\\\n\\\\n @return static\\\\n,Kreira  vrlo stari datum koji predstavlja po?etak vremena.,    public static function startOfTime(): self    {        $date = static::parse('0001-01-01')->years(self::getStartOfTimeYear());        $date->startOfTime = true;        return $date;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_209," A simple API extension for DateInterval.\\\\n The implementation provides helpers to handle weeks but only days are saved.\\\\n Weeks are calculated based on the total days of the current instance.\\\\n\\\\n @property int $years Total years of the current interval.\\\\n @property int $months Total months of the current interval.\\\\n @property int $weeks Total weeks of the current interval calculated from the days.\\\\n @property int $dayz Total days of the current interval (weeks  @property int $hours Total hours of the current interval.\\\\n @property int $minutes Total minutes of the current interval.\\\\n @property int $seconds Total seconds of the current interval.\\\\n @property int $microseconds Total microseconds of the current interval.\\\\n @property int $milliseconds Total microseconds of the current interval.\\\\n @property int $microExcludeMilli Remaining microseconds without the milliseconds.\\\\n @property int $dayzExcludeWeeks Total days remaining in the final week of the current instance (days % 7).\\\\n @property int $daysExcludeWeeks alias of dayzExcludeWeeks\\\\n @property-read float $totalYears Number of years equivalent to the interval.\\\\n @property-read float $totalMonths Number of months equivalent to the interval.\\\\n @property-read float $totalWeeks Number of weeks equivalent to the interval.\\\\n @property-read float $totalDays Number of days equivalent to the interval.\\\\n @property-read float $totalDayz Alias for totalDays.\\\\n @property-read float $totalHours Number of hours equivalent to the interval.\\\\n @property-read float $totalMinutes Number of minutes equivalent to the interval.\\\\n @property-read float $totalSeconds Number of seconds equivalent to the interval.\\\\n @property-read float $totalMilliseconds Number of milliseconds equivalent to the interval.\\\\n @property-read float $totalMicroseconds Number of microseconds equivalent to the interval.\\\\n @property-read string $locale locale of the current instance\\\\n\\\\n @method static CarbonInterval years($years = 1) Create instance specifying a number of years or modify the number of years if called on an instance.\\\\n @method static CarbonInterval year($years = 1) Alias for years()\\\\n @method static CarbonInterval months($months = 1) Create instance specifying a number of months or modify the number of months if called on an instance.\\\\n @method static CarbonInterval month($months = 1) Alias for months()\\\\n @method static CarbonInterval weeks($weeks = 1) Create instance specifying a number of weeks or modify the number of weeks if called on an instance.\\\\n @method static CarbonInterval week($weeks = 1) Alias for weeks()\\\\n @method static CarbonInterval days($days = 1) Create instance specifying a number of days or modify the number of days if called on an instance.\\\\n @method static CarbonInterval dayz($days = 1) Alias for days()\\\\n @method static CarbonInterval daysExcludeWeeks($days = 1) Create instance specifying a number of days or modify the number of days (keeping the current number of weeks) if called on an instance.\\\\n @method static CarbonInterval dayzExcludeWeeks($days = 1) Alias for daysExcludeWeeks()\\\\n @method static CarbonInterval day($days = 1) Alias for days()\\\\n @method static CarbonInterval hours($hours = 1) Create instance specifying a number of hours or modify the number of hours if called on an instance.\\\\n @method static CarbonInterval hour($hours = 1) Alias for hours()\\\\n @method static CarbonInterval minutes($minutes = 1) Create instance specifying a number of minutes or modify the number of minutes if called on an instance.\\\\n @method static CarbonInterval minute($minutes = 1) Alias for minutes()\\\\n @method static CarbonInterval seconds($seconds = 1) Create instance specifying a number of seconds or modify the number of seconds if called on an instance.\\\\n @method static CarbonInterval second($seconds = 1) Alias for seconds()\\\\n @method static CarbonInterval milliseconds($milliseconds = 1) Create instance specifying a number of milliseconds or modify the number of milliseconds if called on an instance.\\\\n @method static CarbonInterval millisecond($milliseconds = 1) Alias for milliseconds()\\\\n @method static CarbonInterval microseconds($microseconds = 1) Create instance specifying a number of microseconds or modify the number of microseconds if called on an instance.\\\\n @method static CarbonInterval microsecond($microseconds = 1) Alias for microseconds()\\\\n @method $this addYears(int $years) Add given number of years to the current interval\\\\n @method $this subYears(int $years) Subtract given number of years to the current interval\\\\n @method $this addMonths(int $months) Add given number of months to the current interval\\\\n @method $this subMonths(int $months) Subtract given number of months to the current interval\\\\n @method $this addWeeks(int|float $weeks) Add given number of weeks to the current interval\\\\n @method $this subWeeks(int|float $weeks) Subtract given number of weeks to the current interval\\\\n @method $this addDays(int|float $days) Add given number of days to the current interval\\\\n @method $this subDays(int|float $days) Subtract given number of days to the current interval\\\\n @method $this addHours(int|float $hours) Add given number of hours to the current interval\\\\n @method $this subHours(int|float $hours) Subtract given number of hours to the current interval\\\\n @method $this addMinutes(int|float $minutes) Add given number of minutes to the current interval\\\\n @method $this subMinutes(int|float $minutes) Subtract given number of minutes to the current interval\\\\n @method $this addSeconds(int|float $seconds) Add given number of seconds to the current interval\\\\n @method $this subSeconds(int|float $seconds) Subtract given number of seconds to the current interval\\\\n @method $this addMilliseconds(int|float $milliseconds) Add given number of milliseconds to the current interval\\\\n @method $this subMilliseconds(int|float $milliseconds) Subtract given number of milliseconds to the current interval\\\\n @method $this addMicroseconds(int|float $microseconds) Add given number of microseconds to the current interval\\\\n @method $this subMicroseconds(int|float $microseconds) Subtract given number of microseconds to the current interval\\\\n @method $this roundYear(int|float $precision = 1, string $function = ""round"") Round the current instance year with given precision using the given function.\\\\n @method $this roundYears(int|float $precision = 1, string $function = ""round"") Round the current instance year with given precision using the given function.\\\\n @method $this floorYear(int|float $precision = 1) Truncate the current instance year with given precision.\\\\n @method $this floorYears(int|float $precision = 1) Truncate the current instance year with given precision.\\\\n @method $this ceilYear(int|float $precision = 1) Ceil the current instance year with given precision.\\\\n @method $this ceilYears(int|float $precision = 1) Ceil the current instance year with given precision.\\\\n @method $this roundMonth(int|float $precision = 1, string $function = ""round"") Round the current instance month with given precision using the given function.\\\\n @method $this roundMonths(int|float $precision = 1, string $function = ""round"") Round the current instance month with given precision using the given function.\\\\n @method $this floorMonth(int|float $precision = 1) Truncate the current instance month with given precision.\\\\n @method $this floorMonths(int|float $precision = 1) Truncate the current instance month with given precision.\\\\n @method $this ceilMonth(int|float $precision = 1) Ceil the current instance month with given precision.\\\\n @method $this ceilMonths(int|float $precision = 1) Ceil the current instance month with given precision.\\\\n @method $this roundWeek(int|float $precision = 1, string $function = ""round"") Round the current instance day with given precision using the given function.\\\\n @method $this roundWeeks(int|float $precision = 1, string $function = ""round"") Round the current instance day with given precision using the given function.\\\\n @method $this floorWeek(int|float $precision = 1) Truncate the current instance day with given precision.\\\\n @method $this floorWeeks(int|float $precision = 1) Truncate the current instance day with given precision.\\\\n @method $this ceilWeek(int|float $precision = 1) Ceil the current instance day with given precision.\\\\n @method $this ceilWeeks(int|float $precision = 1) Ceil the current instance day with given precision.\\\\n @method $this roundDay(int|float $precision = 1, string $function = ""round"") Round the current instance day with given precision using the given function.\\\\n @method $this roundDays(int|float $precision = 1, string $function = ""round"") Round the current instance day with given precision using the given function.\\\\n @method $this floorDay(int|float $precision = 1) Truncate the current instance day with given precision.\\\\n @method $this floorDays(int|float $precision = 1) Truncate the current instance day with given precision.\\\\n @method $this ceilDay(int|float $precision = 1) Ceil the current instance day with given precision.\\\\n @method $this ceilDays(int|float $precision = 1) Ceil the current instance day with given precision.\\\\n @method $this roundHour(int|float $precision = 1, string $function = ""round"") Round the current instance hour with given precision using the given function.\\\\n @method $this roundHours(int|float $precision = 1, string $function = ""round"") Round the current instance hour with given precision using the given function.\\\\n @method $this floorHour(int|float $precision = 1) Truncate the current instance hour with given precision.\\\\n @method $this floorHours(int|float $precision = 1) Truncate the current instance hour with given precision.\\\\n @method $this ceilHour(int|float $precision = 1) Ceil the current instance hour with given precision.\\\\n @method $this ceilHours(int|float $precision = 1) Ceil the current instance hour with given precision.\\\\n @method $this roundMinute(int|float $precision = 1, string $function = ""round"") Round the current instance minute with given precision using the given function.\\\\n @method $this roundMinutes(int|float $precision = 1, string $function = ""round"") Round the current instance minute with given precision using the given function.\\\\n @method $this floorMinute(int|float $precision = 1) Truncate the current instance minute with given precision.\\\\n @method $this floorMinutes(int|float $precision = 1) Truncate the current instance minute with given precision.\\\\n @method $this ceilMinute(int|float $precision = 1) Ceil the current instance minute with given precision.\\\\n @method $this ceilMinutes(int|float $precision = 1) Ceil the current instance minute with given precision.\\\\n @method $this roundSecond(int|float $precision = 1, string $function = ""round"") Round the current instance second with given precision using the given function.\\\\n @method $this roundSeconds(int|float $precision = 1, string $function = ""round"") Round the current instance second with given precision using the given function.\\\\n @method $this floorSecond(int|float $precision = 1) Truncate the current instance second with given precision.\\\\n @method $this floorSeconds(int|float $precision = 1) Truncate the current instance second with given precision.\\\\n @method $this ceilSecond(int|float $precision = 1) Ceil the current instance second with given precision.\\\\n @method $this ceilSeconds(int|float $precision = 1) Ceil the current instance second with given precision.\\\\n @method $this roundMillennium(int|float $precision = 1, string $function = ""round"") Round the current instance millennium with given precision using the given function.\\\\n @method $this roundMillennia(int|float $precision = 1, string $function = ""round"") Round the current instance millennium with given precision using the given function.\\\\n @method $this floorMillennium(int|float $precision = 1) Truncate the current instance millennium with given precision.\\\\n @method $this floorMillennia(int|float $precision = 1) Truncate the current instance millennium with given precision.\\\\n @method $this ceilMillennium(int|float $precision = 1) Ceil the current instance millennium with given precision.\\\\n @method $this ceilMillennia(int|float $precision = 1) Ceil the current instance millennium with given precision.\\\\n @method $this roundCentury(int|float $precision = 1, string $function = ""round"") Round the current instance century with given precision using the given function.\\\\n @method $this roundCenturies(int|float $precision = 1, string $function = ""round"") Round the current instance century with given precision using the given function.\\\\n @method $this floorCentury(int|float $precision = 1) Truncate the current instance century with given precision.\\\\n @method $this floorCenturies(int|float $precision = 1) Truncate the current instance century with given precision.\\\\n @method $this ceilCentury(int|float $precision = 1) Ceil the current instance century with given precision.\\\\n @method $this ceilCenturies(int|float $precision = 1) Ceil the current instance century with given precision.\\\\n @method $this roundDecade(int|float $precision = 1, string $function = ""round"") Round the current instance decade with given precision using the given function.\\\\n @method $this roundDecades(int|float $precision = 1, string $function = ""round"") Round the current instance decade with given precision using the given function.\\\\n @method $this floorDecade(int|float $precision = 1) Truncate the current instance decade with given precision.\\\\n @method $this floorDecades(int|float $precision = 1) Truncate the current instance decade with given precision.\\\\n @method $this ceilDecade(int|float $precision = 1) Ceil the current instance decade with given precision.\\\\n @method $this ceilDecades(int|float $precision = 1) Ceil the current instance decade with given precision.\\\\n @method $this roundQuarter(int|float $precision = 1, string $function = ""round"") Round the current instance quarter with given precision using the given function.\\\\n @method $this roundQuarters(int|float $precision = 1, string $function = ""round"") Round the current instance quarter with given precision using the given function.\\\\n @method $this floorQuarter(int|float $precision = 1) Truncate the current instance quarter with given precision.\\\\n @method $this floorQuarters(int|float $precision = 1) Truncate the current instance quarter with given precision.\\\\n @method $this ceilQuarter(int|float $precision = 1) Ceil the current instance quarter with given precision.\\\\n @method $this ceilQuarters(int|float $precision = 1) Ceil the current instance quarter with given precision.\\\\n @method $this roundMillisecond(int|float $precision = 1, string $function = ""round"") Round the current instance millisecond with given precision using the given function.\\\\n @method $this roundMilliseconds(int|float $precision = 1, string $function = ""round"") Round the current instance millisecond with given precision using the given function.\\\\n @method $this floorMillisecond(int|float $precision = 1) Truncate the current instance millisecond with given precision.\\\\n @method $this floorMilliseconds(int|float $precision = 1) Truncate the current instance millisecond with given precision.\\\\n @method $this ceilMillisecond(int|float $precision = 1) Ceil the current instance millisecond with given precision.\\\\n @method $this ceilMilliseconds(int|float $precision = 1) Ceil the current instance millisecond with given precision.\\\\n @method $this roundMicrosecond(int|float $precision = 1, string $function = ""round"") Round the current instance microsecond with given precision using the given function.\\\\n @method $this roundMicroseconds(int|float $precision = 1, string $function = ""round"") Round the current instance microsecond with given precision using the given function.\\\\n @method $this floorMicrosecond(int|float $precision = 1) Truncate the current instance microsecond with given precision.\\\\n @method $this floorMicroseconds(int|float $precision = 1) Truncate the current instance microsecond with given precision.\\\\n @method $this ceilMicrosecond(int|float $precision = 1) Ceil the current instance microsecond with given precision.\\\\n @method $this ceilMicroseconds(int|float $precision = 1) Ceil the current instance microsecond with given precision.\\\\n",Jednostavno API proöirenje za DateInterval.,"class CarbonInterval extends DateInterval implements CarbonConverterInterface{    use IntervalRounding;    use IntervalStep;    use Mixin {        Mixin::mixin as baseMixin;    }    use Options;    /**     * Interval spec period designators     */    const PERIOD_PREFIX = 'P';    const PERIOD_YEARS = 'Y';    const PERIOD_MONTHS = 'M';    const PERIOD_DAYS = 'D';    const PERIOD_TIME_PREFIX = 'T';    const PERIOD_HOURS = 'H';    const PERIOD_MINUTES = 'M';    const PERIOD_SECONDS = 'S';    /**     * A translator to ... er ... translate stuff     *     * @var \Symfony\Component\Translation\TranslatorInterface     */    protected static $translator;    /**     * @var array|null     */    protected static $cascadeFactors;    /**     * @var array     */    protected static $formats = [        'y' => 'y',        'Y' => 'y',        'o' => 'y',        'm' => 'm',        'n' => 'm',        'W' => 'weeks',        'd' => 'd',        'j' => 'd',        'z' => 'd',        'h' => 'h',        'g' => 'h',        'H' => 'h',        'G' => 'h',        'i' => 'i',        's' => 's',        'u' => 'micro',        'v' => 'milli',    ];    /**     * @var array|null     */    private static $flipCascadeFactors;    /**     * The registered macros.     *     * @var array     */    protected static $macros = [];    /**     * Timezone handler for settings() method.     *     * @var mixed     */    protected $tzName;    /**     * Set the instance's timezone from a string or object and add/subtract the offset difference.     *     * @param \DateTimeZone|string $tzName     *     * @return static     */    public function shiftTimezone($tzName)    {        $this->tzName = $tzName;        return $this;    }    /**     * Mapping of units and factors for cascading.     *     * Should only be modified by changing the factors or referenced constants.     *     * @return array     */    public static function getCascadeFactors()    {        return static::$cascadeFactors ?: [            'milliseconds' => [Carbon::MICROSECONDS_PER_MILLISECOND, 'microseconds'],            'seconds' => [Carbon::MILLISECONDS_PER_SECOND, 'milliseconds'],            'minutes' => [Carbon::SECONDS_PER_MINUTE, 'seconds'],            'hours' => [Carbon::MINUTES_PER_HOUR, 'minutes'],            'dayz' => [Carbon::HOURS_PER_DAY, 'hours'],            'weeks' => [Carbon::DAYS_PER_WEEK, 'dayz'],            'months' => [Carbon::WEEKS_PER_MONTH, 'weeks'],            'years' => [Carbon::MONTHS_PER_YEAR, 'months'],        ];    }    private static function standardizeUnit($unit)    {        $unit = rtrim($unit, 'sz').'s';        return $unit === 'days' ? 'dayz' : $unit;    }    private static function getFlipCascadeFactors()    {        if (!self::$flipCascadeFactors) {            self::$flipCascadeFactors = [];            foreach (static::getCascadeFactors() as $to => [$factor, $from]) {                self::$flipCascadeFactors[self::standardizeUnit($from)] = [self::standardizeUnit($to), $factor];            }        }        return self::$flipCascadeFactors;    }    /**     * Set default cascading factors for ->cascade() method.     *     * @param array $cascadeFactors     */    public static function setCascadeFactors(array $cascadeFactors)    {        self::$flipCascadeFactors = null;        static::$cascadeFactors = $cascadeFactors;    }    ///////////////////////////////////////////////////////////////////    //////////////////////////// CONSTRUCTORS /////////////////////////    ///////////////////////////////////////////////////////////////////    /**     * Create a new CarbonInterval instance.     *     * @param int|null $years     * @param int|null $months     * @param int|null $weeks     * @param int|null $days     * @param int|null $hours     * @param int|null $minutes     * @param int|null $seconds     * @param int|null $microseconds     *     * @throws Exception when the interval_spec (passed as $years) cannot be parsed as an interval.     */    public function __construct($years = 1, $months = null, $weeks = null, $days = null, $hours = null, $minutes = null, $seconds = null, $microseconds = null)    {        if ($years instanceof Closure) {            $this->step = $years;            $years = null;        }        if ($years instanceof DateInterval) {            parent::__construct(static::getDateIntervalSpec($years));            $this->f = $years->f;            static::copyNegativeUnits($years, $this);            return;        }        $spec = $years;        if (!\is_string($spec) || \floatval($years) || preg_match('/^[0-9.]/', $years)) {            $spec = static::PERIOD_PREFIX;            $spec .= $years > 0 ? $years.static::PERIOD_YEARS : '';            $spec .= $months > 0 ? $months.static::PERIOD_MONTHS : '';            $specDays = 0;            $specDays += $weeks > 0 ? $weeks * static::getDaysPerWeek() : 0;            $specDays += $days > 0 ? $days : 0;            $spec .= $specDays > 0 ? $specDays.static::PERIOD_DAYS : '';            if ($hours > 0 || $minutes > 0 || $seconds > 0) {                $spec .= static::PERIOD_TIME_PREFIX;                $spec .= $hours > 0 ? $hours.static::PERIOD_HOURS : '';                $spec .= $minutes > 0 ? $minutes.static::PERIOD_MINUTES : '';                $spec .= $seconds > 0 ? $seconds.static::PERIOD_SECONDS : '';            }            if ($spec === static::PERIOD_PREFIX) {                // Allow the zero interval.                $spec .= '0'.static::PERIOD_YEARS;            }        }        parent::__construct($spec);        if (!\is_null($microseconds)) {            $this->f = $microseconds / Carbon::MICROSECONDS_PER_SECOND;        }    }    /**     * Returns the factor for a given source-to-target couple.     *     * @param string $source     * @param string $target     *     * @return int|null     */    public static function getFactor($source, $target)    {        $source = self::standardizeUnit($source);        $target = self::standardizeUnit($target);        $factors = static::getFlipCascadeFactors();        if (isset($factors[$source])) {            [$to, $factor] = $factors[$source];            if ($to === $target) {                return $factor;            }            return $factor * static::getFactor($to, $target);        }        return null;    }    /**     * Returns current config for days per week.     *     * @return int     */    public static function getDaysPerWeek()    {        return static::getFactor('dayz', 'weeks') ?: Carbon::DAYS_PER_WEEK;    }    /**     * Returns current config for hours per day.     *     * @return int     */    public static function getHoursPerDay()    {        return static::getFactor('hours', 'dayz') ?: Carbon::HOURS_PER_DAY;    }    /**     * Returns current config for minutes per hour.     *     * @return int     */    public static function getMinutesPerHour()    {        return static::getFactor('minutes', 'hours') ?: Carbon::MINUTES_PER_HOUR;    }    /**     * Returns current config for seconds per minute.     *     * @return int     */    public static function getSecondsPerMinute()    {        return static::getFactor('seconds', 'minutes') ?: Carbon::SECONDS_PER_MINUTE;    }    /**     * Returns current config for microseconds per second.     *     * @return int     */    public static function getMillisecondsPerSecond()    {        return static::getFactor('milliseconds', 'seconds') ?: Carbon::MILLISECONDS_PER_SECOND;    }    /**     * Returns current config for microseconds per second.     *     * @return int     */    public static function getMicrosecondsPerMillisecond()    {        return static::getFactor('microseconds', 'milliseconds') ?: Carbon::MICROSECONDS_PER_MILLISECOND;    }    /**     * Create a new CarbonInterval instance from specific values.     * This is an alias for the constructor that allows better fluent     * syntax as it allows you to do CarbonInterval::create(1)->fn() rather than     * (new CarbonInterval(1))->fn().     *     * @param int $years     * @param int $months     * @param int $weeks     * @param int $days     * @param int $hours     * @param int $minutes     * @param int $seconds     * @param int $microseconds     *     * @throws Exception when the interval_spec (passed as $years) cannot be parsed as an interval.     *     * @return static     */    public static function create($years = 1, $months = null, $weeks = null, $days = null, $hours = null, $minutes = null, $seconds = null, $microseconds = null)    {        return new static($years, $months, $weeks, $days, $hours, $minutes, $seconds, $microseconds);    }    /**     * Parse a string into a new CarbonInterval object according to the specified format.     *     * @example     * ```     * echo Carboninterval::createFromFormat('H:i', '1:30');     * ```     *     * @param string $format   Format of the $interval input string     * @param string $interval Input string to convert into an interval     *     * @throws Exception when the $interval cannot be parsed as an interval.     *     * @return static     */    public static function createFromFormat(string $format, ?string $interval)    {        $instance = new static(0);        $length = mb_strlen($format);        if (preg_match('/s([,.])([uv])$/', $format, $match)) {            $interval = explode($match[1], $interval);            $index = \count($interval) - 1;            $interval[$index] = str_pad($interval[$index], $match[2] === 'v' ? 3 : 6, '0');            $interval = implode($match[1], $interval);        }        $interval = $interval ?? '';        for ($index = 0; $index < $length; $index++) {            $expected = mb_substr($format, $index, 1);            $nextCharacter = mb_substr($interval, 0, 1);            $unit = static::$formats[$expected] ?? null;            if ($unit) {                if (!preg_match('/^-?\d+/', $interval, $match)) {                    throw new ParseErrorException('number', $nextCharacter);                }                $interval = mb_substr($interval, mb_strlen($match[0]));                $instance->$unit += \intval($match[0]);                continue;            }            if ($nextCharacter !== $expected) {                throw new ParseErrorException(                    ""'$expected'"",                    $nextCharacter,                    'Allowed substitutes for interval formats are '.implode(', ', array_keys(static::$formats)).""\n"".                    'See https://php.net/manual/en/function.date.php for their meaning'                );            }            $interval = mb_substr($interval, 1);        }        if ($interval !== '') {            throw new ParseErrorException(                'end of string',                $interval            );        }        return $instance;    }    /**     * Get a copy of the instance.     *     * @return static     */    public function copy()    {        $date = new static(0);        $date->copyProperties($this);        $date->step = $this->step;        return $date;    }    /**     * Get a copy of the instance.     *     * @return static     */    public function clone()    {        return $this->copy();    }    /**     * Provide static helpers to create instances.  Allows CarbonInterval::years(3).     *     * Note: This is done using the magic method to allow static and instance methods to     *       have the same names.     *     * @param string $method     magic method name called     * @param array  $parameters parameters list     *     * @return static|null     */    public static function __callStatic($method, $parameters)    {        try {            $interval = new static(0);            $localStrictModeEnabled = $interval->localStrictModeEnabled;            $interval->localStrictModeEnabled = true;            $result = static::hasMacro($method)                ? static::bindMacroContext(null, function () use (&$method, &$parameters, &$interval) {                    return $interval->callMacro($method, $parameters);                })                : $interval->$method(...$parameters);            $interval->localStrictModeEnabled = $localStrictModeEnabled;            return $result;        } catch (BadFluentSetterException $exception) {            if (Carbon::isStrictModeEnabled()) {                throw new BadFluentConstructorException($method, 0, $exception);            }            return null;        }    }    /**     * Return the current context from inside a macro callee or a new one if static.     *     * @return static     */    protected static function this()    {        return end(static::$macroContextStack) ?: new static(0);    }    /**     * Creates a CarbonInterval from string.     *     * Format:     *     * Suffix | Unit    | Example | DateInterval expression     * -------|---------|---------|------------------------     * y      | years   |   1y    | P1Y     * mo     | months  |   3mo   | P3M     * w      | weeks   |   2w    | P2W     * d      | days    |  28d    | P28D     * h      | hours   |   4h    | PT4H     * m      | minutes |  12m    | PT12M     * s      | seconds |  59s    | PT59S     *     * e. g. `1w 3d 4h 32m 23s` is converted to 10 days 4 hours 32 minutes and 23 seconds.     *     * Special cases:     *  - An empty string will return a zero interval     *  - Fractions are allowed for weeks, days, hours and minutes and will be converted     *    and rounded to the next smaller value (caution: 0.5w = 4d)     *     * @param string $intervalDefinition     *     * @return static     */    public static function fromString($intervalDefinition)    {        if (empty($intervalDefinition)) {            return new static(0);        }        $years = 0;        $months = 0;        $weeks = 0;        $days = 0;        $hours = 0;        $minutes = 0;        $seconds = 0;        $milliseconds = 0;        $microseconds = 0;        $pattern = '/(\d+(?:\.\d+)?)\h*([^\d\h]*)/i';        preg_match_all($pattern, $intervalDefinition, $parts, PREG_SET_ORDER);        while ([$part, $value, $unit] = array_shift($parts)) {            $intValue = \intval($value);            $fraction = \floatval($value) - $intValue;            // Fix calculation precision            switch (round($fraction, 6)) {                case 1:                    $fraction = 0;                    $intValue++;                    break;                case 0:                    $fraction = 0;                    break;            }            switch ($unit === '¬µs' ? '¬µs' : strtolower($unit)) {                case 'millennia':                case 'millennium':                    $years += $intValue * CarbonInterface::YEARS_PER_MILLENNIUM;                    break;                case 'century':                case 'centuries':                    $years += $intValue * CarbonInterface::YEARS_PER_CENTURY;                    break;                case 'decade':                case 'decades':                    $years += $intValue * CarbonInterface::YEARS_PER_DECADE;                    break;                case 'year':                case 'years':                case 'y':                    $years += $intValue;                    break;                case 'quarter':                case 'quarters':                    $months += $intValue * CarbonInterface::MONTHS_PER_QUARTER;                    break;                case 'month':                case 'months':                case 'mo':                    $months += $intValue;                    break;                case 'week':                case 'weeks':                case 'w':                    $weeks += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getDaysPerWeek(), 'd'];                    }                    break;                case 'day':                case 'days':                case 'd':                    $days += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getHoursPerDay(), 'h'];                    }                    break;                case 'hour':                case 'hours':                case 'h':                    $hours += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getMinutesPerHour(), 'm'];                    }                    break;                case 'minute':                case 'minutes':                case 'm':                    $minutes += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getSecondsPerMinute(), 's'];                    }                    break;                case 'second':                case 'seconds':                case 's':                    $seconds += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getMillisecondsPerSecond(), 'ms'];                    }                    break;                case 'millisecond':                case 'milliseconds':                case 'milli':                case 'ms':                    $milliseconds += $intValue;                    if ($fraction) {                        $microseconds += round($fraction * static::getMicrosecondsPerMillisecond());                    }                    break;                case 'microsecond':                case 'microseconds':                case 'micro':                case '¬µs':                    $microseconds += $intValue;                    break;                default:                    throw new InvalidIntervalException(                        sprintf('Invalid part %s in definition %s', $part, $intervalDefinition)                    );            }        }        return new static($years, $months, $weeks, $days, $hours, $minutes, $seconds, $milliseconds * Carbon::MICROSECONDS_PER_MILLISECOND + $microseconds);    }    /**     * Creates a CarbonInterval from string using a different locale.     *     * @param string      $interval interval string in the given language (may also contain English).     * @param string|null $locale   if locale is null or not specified, current global locale will be used instead.     *     * @return static     */    public static function parseFromLocale($interval, $locale = null)    {        return static::fromString(Carbon::translateTimeString($interval, $locale ?: static::getLocale(), 'en'));    }    private static function castIntervalToClass(DateInterval $interval, string $className)    {        $mainClass = DateInterval::class;        if (!is_a($className, $mainClass, true)) {            throw new InvalidCastException(""$className is not a sub-class of $mainClass."");        }        $microseconds = $interval->f;        $instance = new $className(static::getDateIntervalSpec($interval));        if ($microseconds) {            $instance->f = $microseconds;        }        if ($interval instanceof self && is_a($className, self::class, true)) {            static::copyStep($interval, $instance);        }        static::copyNegativeUnits($interval, $instance);        return $instance;    }    private static function copyNegativeUnits(DateInterval $from, DateInterval $to): void    {        $to->invert = $from->invert;        foreach (['y', 'm', 'd', 'h', 'i', 's'] as $unit) {            if ($from->$unit < 0) {                $to->$unit *= -1;            }        }    }    private static function copyStep(self $from, self $to): void    {        $to->setStep($from->getStep());    }    /**     * Cast the current instance into the given class.     *     * @param string $className The $className::instance() method will be called to cast the current object.     *     * @return DateInterval     */    public function cast(string $className)    {        return self::castIntervalToClass($this, $className);    }    /**     * Create a CarbonInterval instance from a DateInterval one.  Can not instance     * DateInterval objects created from DateTime::diff() as you can't externally     * set the $days field.     *     * @param DateInterval $interval     *     * @return static     */    public static function instance(DateInterval $interval)    {        return self::castIntervalToClass($interval, static::class);    }    /**     * Make a CarbonInterval instance from given variable if possible.     *     * Always return a new instance. Parse only strings and only these likely to be intervals (skip dates     * and recurrences). Throw an exception for invalid format, but otherwise return null.     *     * @param mixed|int|DateInterval|string|Closure|null $interval interval or number of the given $unit     * @param string|null                                $unit     if specified, $interval must be an integer     *     * @return static|null     */    public static function make($interval, $unit = null)    {        if ($unit) {            $interval = ""$interval "".Carbon::pluralUnit($unit);        }        if ($interval instanceof DateInterval) {            return static::instance($interval);        }        if ($interval instanceof Closure) {            return new static($interval);        }        if (!\is_string($interval)) {            return null;        }        return static::makeFromString($interval);    }    protected static function makeFromString(string $interval)    {        $interval = preg_replace('/\s+/', ' ', trim($interval));        if (preg_match('/^P[T0-9]/', $interval)) {            return new static($interval);        }        if (preg_match('/^(?:\h*\d+(?:\.\d+)?\h*[a-z]+)+$/i', $interval)) {            return static::fromString($interval);        }        /** @var static $interval */        $interval = static::createFromDateString($interval);        return !$interval || $interval->isEmpty() ? null : $interval;    }    protected function resolveInterval($interval)    {        if (!($interval instanceof self)) {            return self::make($interval);        }        return $interval;    }    /**     * Sets up a DateInterval from the relative parts of the string.     *     * @param string $time     *     * @return static     *     * @link https://php.net/manual/en/dateinterval.createfromdatestring.php     */    #[ReturnTypeWillChange]    public static function createFromDateString($time)    {        $interval = @parent::createFromDateString(strtr($time, [            ',' => ' ',            ' and ' => ' ',        ]));        if ($interval instanceof DateInterval) {            $interval = static::instance($interval);        }        return $interval;    }    ///////////////////////////////////////////////////////////////////    ///////////////////////// GETTERS AND SETTERS /////////////////////    ///////////////////////////////////////////////////////////////////    /**     * Get a part of the CarbonInterval object.     *     * @param string $name     *     * @throws UnknownGetterException     *     * @return int|float|string     */    public function get($name)    {        if (substr($name, 0, 5) === 'total') {            return $this->total(substr($name, 5));        }        switch ($name) {            case 'years':                return $this->y;            case 'months':                return $this->m;            case 'dayz':                return $this->d;            case 'hours':                return $this->h;            case 'minutes':                return $this->i;            case 'seconds':                return $this->s;            case 'milli':            case 'milliseconds':                return (int) (round($this->f * Carbon::MICROSECONDS_PER_SECOND) / Carbon::MICROSECONDS_PER_MILLISECOND);            case 'micro':            case 'microseconds':                return (int) round($this->f * Carbon::MICROSECONDS_PER_SECOND);            case 'microExcludeMilli':                return (int) round($this->f * Carbon::MICROSECONDS_PER_SECOND) % Carbon::MICROSECONDS_PER_MILLISECOND;            case 'weeks':                return (int) ($this->d / static::getDaysPerWeek());            case 'daysExcludeWeeks':            case 'dayzExcludeWeeks':                return $this->d % static::getDaysPerWeek();            case 'locale':                return $this->getTranslatorLocale();            default:                throw new UnknownGetterException($name);        }    }    /**     * Get a part of the CarbonInterval object.     *     * @param string $name     *     * @throws UnknownGetterException     *     * @return int|float|string     */    public function __get($name)    {        return $this->get($name);    }    /**     * Set a part of the CarbonInterval object.     *     * @param string|array $name     * @param int          $value     *     * @throws UnknownSetterException     *     * @return $this     */    public function set($name, $value = null)    {        $properties = \is_array($name) ? $name : [$name => $value];        foreach ($properties as $key => $value) {            switch (Carbon::singularUnit(rtrim($key, 'z'))) {                case 'year':                    $this->y = $value;                    break;                case 'month':                    $this->m = $value;                    break;                case 'week':                    $this->d = $value * static::getDaysPerWeek();                    break;                case 'day':                    $this->d = $value;                    break;                case 'daysexcludeweek':                case 'dayzexcludeweek':                    $this->d = $this->weeks * static::getDaysPerWeek() + $value;                    break;                case 'hour':                    $this->h = $value;                    break;                case 'minute':                    $this->i = $value;                    break;                case 'second':                    $this->s = $value;                    break;                case 'milli':                case 'millisecond':                    $this->microseconds = $value * Carbon::MICROSECONDS_PER_MILLISECOND + $this->microseconds % Carbon::MICROSECONDS_PER_MILLISECOND;                    break;                case 'micro':                case 'microsecond':                    $this->f = $value / Carbon::MICROSECONDS_PER_SECOND;                    break;                default:                    if ($this->localStrictModeEnabled ?? Carbon::isStrictModeEnabled()) {                        throw new UnknownSetterException($key);                    }                    $this->$key = $value;            }        }        return $this;    }    /**     * Set a part of the CarbonInterval object.     *     * @param string $name     * @param int    $value     *     * @throws UnknownSetterException     */    public function __set($name, $value)    {        $this->set($name, $value);    }    /**     * Allow setting of weeks and days to be cumulative.     *     * @param int $weeks Number of weeks to set     * @param int $days  Number of days to set     *     * @return static     */    public function weeksAndDays($weeks, $days)    {        $this->dayz = ($weeks * static::getDaysPerWeek()) + $days;        return $this;    }    /**     * Returns true if the interval is empty for each unit.     *     * @return bool     */    public function isEmpty()    {        return $this->years === 0 &&            $this->months === 0 &&            $this->dayz === 0 &&            !$this->days &&            $this->hours === 0 &&            $this->minutes === 0 &&            $this->seconds === 0 &&            $this->microseconds === 0;    }    /**     * Register a custom macro.     *     * @example     * ```     * CarbonInterval::macro('twice', function () {     *   return $this->times(2);     * });     * echo CarbonInterval::hours(2)->twice();     * ```     *     * @param string          $name     * @param object|callable $macro     *     * @return void     */    public static function macro($name, $macro)    {        static::$macros[$name] = $macro;    }    /**     * Register macros from a mixin object.     *     * @example     * ```     * CarbonInterval::mixin(new class {     *   public function daysToHours() {     *     return function () {     *       $this->hours += $this->days;     *       $this->days = 0;     *     *       return $this;     *     };     *   }     *   public function hoursToDays() {     *     return function () {     *       $this->days += $this->hours;     *       $this->hours = 0;     *     *       return $this;     *     };     *   }     * });     * echo CarbonInterval::hours(5)->hoursToDays() . ""\n"";     * echo CarbonInterval::days(5)->daysToHours() . ""\n"";     * ```     *     * @param object|string $mixin     *     * @throws ReflectionException     *     * @return void     */    public static function mixin($mixin)    {        static::baseMixin($mixin);    }    /**     * Check if macro is registered.     *     * @param string $name     *     * @return bool     */    public static function hasMacro($name)    {        return isset(static::$macros[$name]);    }    /**     * Call given macro.     *     * @param string $name     * @param array  $parameters     *     * @return mixed     */    protected function callMacro($name, $parameters)    {        $macro = static::$macros[$name];        if ($macro instanceof Closure) {            $boundMacro = @$macro->bindTo($this, static::class) ?: @$macro->bindTo(null, static::class);            return ($boundMacro ?: $macro)(...$parameters);        }        return $macro(...$parameters);    }    /**     * Allow fluent calls on the setters... CarbonInterval::years(3)->months(5)->day().     *     * Note: This is done using the magic method to allow static and instance methods to     *       have the same names.     *     * @param string $method     magic method name called     * @param array  $parameters parameters list     *     * @throws BadFluentSetterException|Throwable     *     * @return static     */    public function __call($method, $parameters)    {        if (static::hasMacro($method)) {            return static::bindMacroContext($this, function () use (&$method, &$parameters) {                return $this->callMacro($method, $parameters);            });        }        $roundedValue = $this->callRoundMethod($method, $parameters);        if ($roundedValue !== null) {            return $roundedValue;        }        if (preg_match('/^(?<method>add|sub)(?<unit>[A-Z].*)$/', $method, $match)) {            return $this->{$match['method']}($parameters[0], $match['unit']);        }        try {            $this->set($method, \count($parameters) === 0 ? 1 : $parameters[0]);        } catch (UnknownSetterException $exception) {            if ($this->localStrictModeEnabled ?? Carbon::isStrictModeEnabled()) {                throw new BadFluentSetterException($method, 0, $exception);            }        }        return $this;    }    protected function getForHumansInitialVariables($syntax, $short)    {        if (\is_array($syntax)) {            return $syntax;        }        if (\is_int($short)) {            return [                'parts' => $short,                'short' => false,            ];        }        if (\is_bool($syntax)) {            return [                'short' => $syntax,                'syntax' => CarbonInterface::DIFF_ABSOLUTE,            ];        }        return [];    }    /**     * @param mixed $syntax     * @param mixed $short     * @param mixed $parts     * @param mixed $options     *     * @return array     */    protected function getForHumansParameters($syntax = null, $short = false, $parts = -1, $options = null)    {        $optionalSpace = ' ';        $default = $this->getTranslationMessage('list.0') ?? $this->getTranslationMessage('list') ?? ' ';        $join = $default === '' ? '' : ' ';        $altNumbers = false;        $aUnit = false;        $minimumUnit = 's';        extract($this->getForHumansInitialVariables($syntax, $short));        if (\is_null($syntax)) {            $syntax = CarbonInterface::DIFF_ABSOLUTE;        }        if ($parts === -1) {            $parts = INF;        }        if (\is_null($options)) {            $options = static::getHumanDiffOptions();        }        if ($join === false) {            $join = ' ';        } elseif ($join === true) {            $join = [                $default,                $this->getTranslationMessage('list.1') ?? $default,            ];        }        if ($altNumbers) {            if ($altNumbers !== true) {                $language = new Language($this->locale);                $altNumbers = \in_array($language->getCode(), (array) $altNumbers);            }        }        if (\is_array($join)) {            [$default, $last] = $join;            if ($default !== ' ') {                $optionalSpace = '';            }            $join = function ($list) use ($default, $last) {                if (\co",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
briannesbitt_Carbon_CarbonInterval_211, Mapping of units and factors for cascading.\\n\\n Should only be modified by changing the factors or referenced constants.\\n\\n @return array\\n,Mapiranje jedinica i faktora za kaskadno.,"    public static function getCascadeFactors()    {        return static::$cascadeFactors ?: [            'milliseconds' => [Carbon::MICROSECONDS_PER_MILLISECOND, 'microseconds'],            'seconds' => [Carbon::MILLISECONDS_PER_SECOND, 'milliseconds'],            'minutes' => [Carbon::SECONDS_PER_MINUTE, 'seconds'],            'hours' => [Carbon::MINUTES_PER_HOUR, 'minutes'],            'dayz' => [Carbon::HOURS_PER_DAY, 'hours'],            'weeks' => [Carbon::DAYS_PER_WEEK, 'dayz'],            'months' => [Carbon::WEEKS_PER_MONTH, 'weeks'],            'years' => [Carbon::MONTHS_PER_YEAR, 'months'],        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_212, Set default cascading factors for ->cascade() method.\\\\n\\\\n @param array $cascadeFactors\\\\n, Postavlja podrazumevane kaskadne faktore za metodu ->cascade().,    public static function setCascadeFactors(array $cascadeFactors)    {        self::$flipCascadeFactors = null;        static::$cascadeFactors = $cascadeFactors;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_213, Returns the factor for a given source-to-target couple.\\\\n\\\\n @param string $source\\\\n @param string $target\\\\n\\\\n @return int|null\\\\n,Vrac?a faktor za zadati par izvor-cilj.,"    public static function getFactor($source, $target)    {        $source = self::standardizeUnit($source);        $target = self::standardizeUnit($target);        $factors = static::getFlipCascadeFactors();        if (isset($factors[$source])) {            [$to, $factor] = $factors[$source];            if ($to === $target) {                return $factor;            }            return $factor * static::getFactor($to, $target);        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_215, Returns current config for hours per day.\n\n @return int\n,Prikazuje trenutnu konfiguraciju za sate po danu.,"    public static function getHoursPerDay()    {        return static::getFactor('hours', 'dayz') ?: Carbon::HOURS_PER_DAY;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_216, Returns current config for minutes per hour.\\\\n\\\\n @return int\\\\n,Prikazuje trenutnu konfiguraciju za minute na sat.,"    public static function getMinutesPerHour()    {        return static::getFactor('minutes', 'hours') ?: Carbon::MINUTES_PER_HOUR;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_217, Returns current config for seconds per minute.\\\\n\\\\n @return int\\\\n,Prikazuje trenutnu konfiguraciju za sekunde u minuti.,"    public static function getSecondsPerMinute()    {        return static::getFactor('seconds', 'minutes') ?: Carbon::SECONDS_PER_MINUTE;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_218, Returns current config for microseconds per second.\\n\\n @return int\\n,Prikazuje trenutnu konfiguraciju za mikrosekunde u sekundi.,"    public static function getMillisecondsPerSecond()    {        return static::getFactor('milliseconds', 'seconds') ?: Carbon::MILLISECONDS_PER_SECOND;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_219, Returns current config for microseconds per second.\\\\n\\\\n @return int\\\\n,Prikazuje trenutnu konfiguraciju za mikrosekunde u sekundi.,"    public static function getMicrosecondsPerMillisecond()    {        return static::getFactor('microseconds', 'milliseconds') ?: Carbon::MICROSECONDS_PER_MILLISECOND;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_220," Parse a string into a new CarbonInterval object according to the specified format.\\\\n\\\\n @example\\\\n ```\\\\n echo Carboninterval::createFromFormat('H:i', '1:30');\\\\n ```\\\\n\\\\n @param string $format   Format of the $interval input string\\\\n @param string $interval Input string to convert into an interval\\\\n\\\\n @throws Exception when the $interval cannot be parsed as an interval.\\\\n\\\\n @return static\\\\n", Parsira string u novi CarbonInterval objekat u slakdu sa navedenim formatom. ,"    public static function createFromFormat(string $format, ?string $interval)    {        $instance = new static(0);        $length = mb_strlen($format);        if (preg_match('/s([,.])([uv])$/', $format, $match)) {            $interval = explode($match[1], $interval);            $index = \count($interval) - 1;            $interval[$index] = str_pad($interval[$index], $match[2] === 'v' ? 3 : 6, '0');            $interval = implode($match[1], $interval);        }        $interval = $interval ?? '';        for ($index = 0; $index < $length; $index++) {            $expected = mb_substr($format, $index, 1);            $nextCharacter = mb_substr($interval, 0, 1);            $unit = static::$formats[$expected] ?? null;            if ($unit) {                if (!preg_match('/^-?\d+/', $interval, $match)) {                    throw new ParseErrorException('number', $nextCharacter);                }                $interval = mb_substr($interval, mb_strlen($match[0]));                $instance->$unit += \intval($match[0]);                continue;            }            if ($nextCharacter !== $expected) {                throw new ParseErrorException(                    ""'$expected'"",                    $nextCharacter,                    'Allowed substitutes for interval formats are '.implode(', ', array_keys(static::$formats)).""\n"".                    'See https://php.net/manual/en/function.date.php for their meaning'                );            }            $interval = mb_substr($interval, 1);        }        if ($interval !== '') {            throw new ParseErrorException(                'end of string',                $interval            );        }        return $instance;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterval_221, Get a copy of the instance.\n\n @return static\n, Vra?a kopiju instance. ,    public function copy()    {        $date = new static(0);        $date->copyProperties($this);        $date->step = $this->step;        return $date;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
