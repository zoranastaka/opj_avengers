,pair_id,comment,Komentar,code,"upit
","pretvaranje int u string
","red sa prioritetom
","pretvaranje string u datum
","sortiranje string liste
","čuvanje liste u datoteku
","postgresql konekcija
","konfuziona matrica
","postavljanje radnog direktorijuma
","grupisanje po izbrojanim podacima
","binomna raspodela
","aes šifrovanje
","linearna regresija
","vreme tolerisanja za prijem na soketu
","upisivanje u csv datoteku
","pretvaranje decimalnog u heksadecimalni broj
","izvoz podataka u excel
","dijagram rasejanja
","pretvaranje json u csv
","lepo ispiši json
","zamena delova datoteke
","klasterizacija metodom k-srednjih vrednosti
","povezivanje na sql server
","html šifrovan string
","određivanje proteklog vremena korišćenjem časovnika
","parsiranje binarne datoteke u prilagođenu klasu
","dohvatanje trenutne ip adrese
","pretvaranje int u bool
","isčitavanje tekstualne datoteke liniju po liniju
","dohvatanje putanje izvršavanja
","odprema json datoteke pomoću HttpClient POST zahteva
","dohvatanje unutrašnjeg svojstva html taga
","pretvaranje string u broj
","formatiranje datuma
","nepromenjivi (readonly) niz
","filtriranje niza
","mapa u json
","parsiranje json datoteke
","dohvati trenutnu vrednost posmatrača
","dohvati naziv za vrednost enumerisanog tipa podatka
","šifriraj url
","kreiraj kolačić
","kako isprazniti niz
","kako dohvatiti današnji datum
","kako štiklirati checkbox
","inicijalizacija niza
","kako obrnuti string
","pročitaj svojstva datoteke
","prekopiraj u klibord
","pretvaranje html stranice u pdf
","konverzija json u xml datoteku
","kako nasumično izabrati broj
","normalna raspodela
","Nelder-Mead optimizacija
","hashset za određivanje broja različitih elemenata
","kako dohvatiti naziv tabele iz baze
","deserializacija json-a
","pronađi int unutar stringa
","dohvatanje jedinstvenog identifikatora trenutnog procesa
","regex ne razlikuje velika i mala slova
","prilagođeni http odgovor greške
","kako odrediti da li je string valida reč
","zamena http entiteta
","sakrij atribute datoteke
","sortiraj više nizova na osnovu redosleda drugih sortiranih nizova
","levenshteinova slicnost stringova
","kako dohvatiti html kod sa veb sajta
","baferisano čitanje teksta čitačem fajlova
","aes šifrovanje u ctr načinu rada
","matrica množenja
","štampanje rezimea modela
","jedinstveni elementi
","izvlačenje podataka iz sadržaja html koda
",toplotna mapa iz 3d koordinata,"dohvatanje svih roditelja xml čvora
","kako rekurzivno raspakovati zip datoteku
","podvuci tekst u label vidžetu
","raspakivanje velikih datoteka
","kopiranje putanje fajla
","dohvati opis http statusnog koda
","nasumično izvuci x stavki iz liste
","konvertuj string datum u yyyymmdd format
","pretvoriti utc vreme u epohu
","sve permutacije liste
","izvuci geografsku širinu i dužinu iz datog unosa
","kako proveriti da je checkbox štikliran
",pretvoriti uint8 niz u sliku,"memoizacija na disk - persistentna memoizacija
","parsiranje argumenata komandne linije
","kako pročitati sadržaj iz .gz zapakovanog fajla
","slanje binarnih podataka preko seriske veze
","otpakovanje podataka iz tekstualne datoteke
","pozicije podstingova u stringu
","čitanje elemenata iz html-a - <td>
","oduzimanje medijana iz svake kolone
","uklanjanja zaglavlja prilikom spajanja nekoliko datoteka
","parsiranje query stringa u url-u
","rangiranje fazi članova na osnovu stepena podudaranja
","izlaz u html datoteku
",kako efikasno pročitati .csv datoteku
0,BookStackApp_BookStack_ActivityService_740, Get a new activity instance for the current user.\n,Daj novu instancu aktivnosti za trenutnog korisnika.,"    protected function newActivityForUser(string $type): Activity    {        return $this->activity->newInstance()->forceFill([            'type'     => strtolower($type),            'user_id' => user()->id,        ]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
1,BookStackApp_BookStack_CommentRepo_753, Update an existing comment.\n,Osveži postojeći komentar.,"    public function update(Comment $comment, string $text): Comment    {        $comment->updated_by = user()->id;        $comment->text = $text;        $comment->html = $this->commentToHtml($text);        $comment->save();        return $comment;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
2,BookStackApp_BookStack_CommentRepo_754, Delete a comment from the system.\n,Obriši komentar iz sistema.,    public function delete(Comment $comment)    {        $comment->delete();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
3,BookStackApp_BookStack_Comment_747, Check if a comment has been updated since creation.\n,Provera da li je komentar menjan od kada je napravljen,    public function isUpdated(): bool    {        return $this->updated_at->timestamp > $this->created_at->timestamp;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
4,BookStackApp_BookStack_helpers_731, Check if current user is a signed in user.\n,Provera da li je korisnik prijavljen,function signedInUser(): bool{    return auth()->user() && !auth()->user()->isDefault();},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
5,DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_7039," This concrete command tweaks receiver to add current date to messages\n invoker just knows that it can call ""execute""\n",Ova konkretna komanda menja prijemnika tako da dodaje trenutni datum u poruke kako bi prizivač znao da može da pozove “execute”,"class AddMessageDateCommand implements UndoableCommand{    /**     * Each concrete command is built with different receivers.     * There can be one, many or completely no receivers, but there can be other commands in the parameters.     */    public function __construct(private Receiver $output)    {    }    /**     * Execute and make receiver to enable displaying messages date.     */    public function execute()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->enableDate();    }    /**     * Undo the command and make receiver to disable displaying messages date.     */    public function undo()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->disableDate();    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
6,DesignPatternsPHP_DesignPatternsPHP_HelloCommand_6673," execute and output ""Hello World"".\n",Izvrši i ispiši “Zdravo svete”,"    public function execute()    {        // sometimes, there is no receiver and this is the command which does all the work        $this->output->write('Hello World');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
7,DesignPatternsPHP_DesignPatternsPHP_PostId_6684, This is a perfect example of a value object that is identifiable by it's value alone and\n is guaranteed to be valid each time an instance is created. Another important property of value objects\n is immutability.\n\n Notice also the use of a named constructor (fromInt) which adds a little context when creating an instance.\n,Ovo je savršeni primer vrednosti objekta koja je prepoznatljiva već po svojoj vrednosti i garantovano je važeća svaki put kada se napravi instanca. Još jedno bitno svojstvo vrednostnih objekata je nepromenljivost. Primetite takođe i upotrebu nazvanog konstruktora (fromInt) koji dodaje još malo konkteksta prilikom kreiranja instance.,class PostId{    public static function fromInt(int $id): PostId    {        self::ensureIsValid($id);        return new self($id);    }    private function __construct(private int $id)    {    }    public function toInt(): int    {        return $this->id;    }    private static function ensureIsValid(int $id)    {        if ($id <= 0) {            throw new InvalidArgumentException('Invalid PostId given');        }    }},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
8,DesignPatternsPHP_DesignPatternsPHP_Receiver_6406, Disable receiver to display message date\n,Onemogući prijemniku da prikazuje datum.,    public function disableDate()    {        $this->enableDate = false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
9,Intervention_image_AbstractColor_403, Initiates color object from integer\n\n @param  int $value\n @return \\Intervention\\Image\\AbstractColor\n,Inicijalizuje objekat boje od celog broja.,    abstract public function initFromInteger($value);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
10,Intervention_image_AbstractColor_407," Initiates color object from given R, G and B values\n\n @param  int $r\n @param  int $g\n @param  int $b\n @return \\Intervention\\Image\\AbstractColor\n","Inicijalizuje objekat boje od zadate R, G i B vrednosti.","    abstract public function initFromRgb($r, $g, $b);",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
11,Intervention_image_AbstractColor_408," Initiates color object from given R, G, B and A values\\n\\n @param  int $r\\n @param  int $g\\n @param  int $b\\n @param  float   $a\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n","Inicijalizu objekat boje od zadatih R, G, B i A Vrednosti.","    abstract public function initFromRgba($r, $g, $b, $a);",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
12,Intervention_image_AbstractColor_409, Calculates integer value of current color instance\\\\n\\\\n @return int\\\\n,Računa celobrojnu vrednost trenutne instance boje.,    abstract public function getInt();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
13,Intervention_image_AbstractColor_410, Calculates hexadecimal value of current color instance\n\n @param  string $prefix\n @return string\n,Računa heksadecimalnu vrednost trenutne instance boje.,    abstract public function getHex($prefix);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
14,Intervention_image_AbstractColor_411, Calculates RGB(A) in array format of current color instance\n\n @return array\n,Računa RGB(A) u obliku niza za trenutnu instancu boje.,    abstract public function getArray();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
15,Intervention_image_AbstractDecoder_417, Initiates new image from binary data\n\n @param  string $data\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku od binarnih podataka,    abstract public function initFromBinary($data);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
16,Intervention_image_AbstractDecoder_418, Initiates new image from GD resource\n\n @param  Resource $resource\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku od GD resursa,    abstract public function initFromGdResource($resource);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
17,Intervention_image_AbstractDriver_437, Creates new image instance\\\\n\\\\n @param  int     $width\\\\n @param  int     $height\\\\n @param  string  $background\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Napravi novu instancu slike,"    abstract public function newImage($width, $height, $background);",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
18,Intervention_image_BlurCommand_594, Applies blur effect on image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Primeni efekat zamućivanja na sliku.,"public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(1);        for ($i=0; $i < intval($amount); $i++) {            imagefilter($image->getCore(), IMG_FILTER_GAUSSIAN_BLUR);        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
19,Intervention_image_BrightnessCommand_595, Changes image brightness\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Promeni osvetljenost slike,"public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return imagefilter($image->getCore(), IMG_FILTER_BRIGHTNESS, ($level * 2.55));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
20,Intervention_image_Color_569, Calculates integer value of current color instance\\n\\n @return int\\n,Izračunaj celobrojnu vrednost trenutne instance boje,public function getInt()    {        return ($this->a << 24) + ($this->r << 16) + ($this->g << 8) + $this->b;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
21,Intervention_image_Color_634, Calculates RGB(A) in array format of current color instance\\n\\n @return array\\n,Izračunaj RGB(A) u obliku niza za trenutnu instancu boje,"    public function getArray()    {        return [            $this->getRedValue(),            $this->getGreenValue(),            $this->getBlueValue(),            $this->getAlphaValue()        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
22,Intervention_image_FilterInterface_563, Applies filter to given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Primeni filter na datu sliku,    public function applyFilter(Image $image);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
23,Intervention_image_GammaCommand_603, Applies gamma correction to a given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Primeni gama korekciju na zadatu sliku,"public function execute($image)    {        $gamma = $this->argument(0)->type('numeric')->required()->value();        return imagegammacorrect($image->getCore(), 1, $gamma);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
24,PHPOffice_PHPExcel_Calculation_156,Ensure that paired matrix operands are both matrices of the same size\\\\\\\\n\\\\\\\\n @param    mixed        &$matrix1    First matrix operand\\\\\\\\n @param    mixed        &$matrix2    Second matrix operand\\\\\\\\n @param    integer        $matrix1Rows    Row size of first matrix operand\\\\\\\\n @param    integer        $matrix1Columns    Column size of first matrix operand\\\\\\\\n @param    integer        $matrix2Rows    Row size of second matrix operand\\\\\\\\n @param    integer        $matrix2Columns    Column size of second matrix operand\\\\\\\\n,Pobrini se da su oba člana operacije matrica matrice iste veličine,"private static function resizeMatricesExtend(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $x = $matrix2[$i][$matrix2Columns-1];                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        $matrix2[$i][$j] = $x;                    }                }            }            if ($matrix2Rows < $matrix1Rows) {                $x = $matrix2[$matrix2Rows-1];                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $matrix2[$i] = $x;                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $x = $matrix1[$i][$matrix1Columns-1];                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        $matrix1[$i][$j] = $x;                    }                }            }            if ($matrix1Rows < $matrix2Rows) {                $x = $matrix1[$matrix1Rows-1];                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $matrix1[$i] = $x;                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
25,PHPOffice_PHPExcel_Calculation_159,Compare two strings in the same way as strcmp() except that lowercase come before uppercase letters\\\\\\\\n @param    string    $str1    First string value for the comparison\\\\\\\\n @param    string    $str2    Second string value for the comparison\\\\\\\\n @return   integer\\\\\\\\n,"Uporedi dva stringa na isti način kao strcmp(), ali da sva slova budu velika.","private function strcmpLowercaseFirst($str1, $str2)    {        $inversedStr1 = PHPExcel_Shared_String::StrCaseReverse($str1);        $inversedStr2 = PHPExcel_Shared_String::StrCaseReverse($str2);        return strcmp($inversedStr1, $inversedStr2);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
26,PHPOffice_PHPExcel_Cell_176,    Does this cell contain a Hyperlink?\\n\\n    @return boolean\\n    @throws    PHPExcel_Exception\\n,Da li ova ćelija sadrži vezu?,    public function hasHyperlink()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot check for hyperlink when cell is not bound to a worksheet');        }        return $this->getWorksheet()->hyperlinkExists($this->getCoordinate());    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
27,PHPOffice_PHPExcel_Cell_185,    Build range from coordinate strings\\n\\n    @param    array    $pRange    Array containg one or more arrays containing one or two coordinate strings\\n    @return    string    String representation of $pRange\\n    @throws    PHPExcel_Exception\\n,Napravi raspon od koordinata stringova.,"public static function buildRange($pRange)    {        // Verify range        if (!is_array($pRange) || empty($pRange) || !is_array($pRange[0])) {            throw new PHPExcel_Exception('Range does not contain any information');        }        // Build range        $imploded = array();        $counter = count($pRange);        for ($i = 0; $i < $counter; ++$i) {            $pRange[$i] = implode(':', $pRange[$i]);        }        $imploded = implode(',', $pRange);        return $imploded;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
28,PHPOffice_PHPExcel_Cell_186,"Compare 2 cells\\\\n\\\\n @param    PHPExcel_Cell    $a    Cell a\\\\n @param    PHPExcel_Cell    $b    Cell b\\\\n @return    int        Result of comparison (always -1 or 1, never zero!)\\\\n",Uporedi dve ćelije,"public static function compareCells(PHPExcel_Cell $a, PHPExcel_Cell $b)    {        if ($a->getRow() < $b->getRow()) {            return -1;        } elseif ($a->getRow() > $b->getRow()) {            return 1;        } elseif (self::columnIndexFromString($a->getColumn()) < self::columnIndexFromString($b->getColumn())) {            return -1;        } else {            return 1;        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
29,PHPOffice_PHPExcel_Cell_192, Convert to string\\\\n\\\\n @return string\\\\n,Prevedi u string.,    public function __toString()    {        return (string) $this->getValue();    },0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
30,PHPOffice_PHPWord_TemplateProcessorTest_1027, XSL stylesheet can be applied.\\n\\n @test\\n @covers ::applyXslStyleSheet\\n @depends testTemplateCanBeSavedInTemporaryLocation\\n\\n @param string $actualDocumentFqfn\\n\\n @throws \\\\Exception\\n,Proveri da li XSL stylesheet može da se primeni.,"final public function testXslStyleSheetCanBeApplied($actualDocumentFqfn)    {        $expectedDocumentFqfn = __DIR__ . '/_files/documents/without_table_macros.docx';        $actualDocumentZip = new \ZipArchive();        $actualDocumentZip->open($actualDocumentFqfn);        $actualHeaderXml = $actualDocumentZip->getFromName('word/header1.xml');        $actualMainPartXml = $actualDocumentZip->getFromName('word/document.xml');        $actualFooterXml = $actualDocumentZip->getFromName('word/footer1.xml');        if (false === $actualDocumentZip->close()) {            throw new \Exception(""Could not close zip file \""{$actualDocumentFqfn}\""."");        }        $expectedDocumentZip = new \ZipArchive();        $expectedDocumentZip->open($expectedDocumentFqfn);        $expectedHeaderXml = $expectedDocumentZip->getFromName('word/header1.xml');        $expectedMainPartXml = $expectedDocumentZip->getFromName('word/document.xml');        $expectedFooterXml = $expectedDocumentZip->getFromName('word/footer1.xml');        if (false === $expectedDocumentZip->close()) {            throw new \Exception(""Could not close zip file \""{$expectedDocumentFqfn}\""."");        }        $this->assertXmlStringEqualsXmlString($expectedHeaderXml, $actualHeaderXml);        $this->assertXmlStringEqualsXmlString($expectedMainPartXml, $actualMainPartXml);        $this->assertXmlStringEqualsXmlString($expectedFooterXml, $actualFooterXml);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
31,PHPOffice_PHPWord_TemplateProcessor_964," Raplaces variables with values from array, array keys are the variable names\\n\\n @param array $variableReplacements\\n @param string $xmlBlock\\n\\n @return string[]\\n",Menja promenljive vrednostima iz niza gde su ključevi niza nazivi promenljivih.,"    protected function replaceClonedVariables($variableReplacements, $xmlBlock)    {        $results = array();        foreach ($variableReplacements as $replacementArray) {            $localXmlBlock = $xmlBlock;            foreach ($replacementArray as $search => $replacement) {                $localXmlBlock = $this->setValueForPart(self::ensureMacroCompleted($search), $replacement, $localXmlBlock, self::MAXIMUM_REPLACEMENTS_DEFAULT);            }            $results[] = $localXmlBlock;        }        return $results;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
32,PrestaShop_PrestaShop_Address_782, Check if Address is used (at least one order placed).\\n\\n @return int Order count for this Address\\n,Proveri da li je adresa u upotrebi (bar jedna narudžba je napravljena sa adrese),public function isUsed()    {        if ((int) $this->id <= 0) {            return false;        }        $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT COUNT(`id_order`) AS usedFROM `' . _DB_PREFIX_ . 'orders`WHERE `id_address_delivery` = ' . (int) $this->id . 'OR `id_address_invoice` = ' . (int) $this->id);        return $result > 0 ? (int) $result : false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
33,Sylius_Sylius_LaminasPriorityQueueStub_1187," Remove an item from the queue\n\n This is different than {@link extract()}; its purpose is to dequeue an\n item.\n\n This operation is potentially expensive, as it requires\n re-initialization and re-population of the inner queue.\n\n Note: this removes the first item matching the provided item found. If\n the same item has been added multiple times, it will not remove other\n instances.\n\n @param  mixed $datum\n @return bool False if the item was not found, true otherwise.\n\n @psalm-param T $datum\n","Izbaci obejkat iz reda. Ovo je drugačije od extract jer objekat više neće biti u redu. Ova operacija je potencijalno skupa jer zahteva reinicijalizaciju i ponovnu populaciju unutrašnjeg reda. Napomena: ovo izbacuje prvi pronađeni objekat koji se poklapa sa datim objektom. Ukoliko ih ima više, ostali neće biti izbačeni.","    public function remove($datum)    {        $found = false;        foreach ($this->items as $key => $item) {            if ($item['data'] === $datum) {                $found = true;                break;            }        }        if ($found) {            unset($this->items[$key]);            $this->queue = null;            if (! $this->isEmpty()) {                $queue = $this->getQueue();                foreach ($this->items as $item) {                    $queue->insert($item['data'], $item['priority']);                }            }            return true;        }        return false;    }",0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
34,Sylius_Sylius_LaminasPriorityQueueStub_1188, Is the queue empty?\n\n @return bool\n,Da li je red prazan?,public function isEmpty()    {        return (0 === $this->count());    },0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
35,Sylius_Sylius_LaminasPriorityQueueStub_1189, How many items are in the queue?\n\n @return int\n,Koliko stavki postoji u redu?,    public function count()    {        return count($this->items);    },0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
36,Sylius_Sylius_LaminasPriorityQueueStub_1198, Get the inner priority queue instance\n\n @throws Exception\\DomainException\n @return SplPriorityQueue\n,Vraća instancu unutrašnjeg reda sa prioritetom.,"    protected function getQueue()    {        if (null === $this->queue) {            $this->queue = new $this->queueClass();            if (! $this->queue instanceof \SplPriorityQueue) {                throw new Exception\DomainException(sprintf(                    'PriorityQueue expects an internal queue of type SplPriorityQueue; received ""%s""',                    get_class($this->queue)                ));            }        }        return $this->queue;    }",0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
37,Sylius_Sylius_LaminasPriorityQueueStub_462, Does the queue have an item with the given priority?\\n\\n @param  int $priority\\n @return bool\\n,Da li red sadrži objekat sa datim prioritetom?,    public function hasPriority($priority)    {        foreach ($this->items as $item) {            if ($item['priority'] === $priority) {                return true;            }        }        return false;    },0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
38,TheAlgorithms_PHP_BinaryToDecimal_2053, This function converts the\n submitted Decimal Number to\n Binary Number.\n\n @param string $decimalNumber\n @return string\n,Ova funkcija pretvara dati decimalni broj u binarni broj.,function decimalToBinary($decimalNumber){    if (!is_numeric($decimalNumber)) {        throw new \Exception('Please pass a valid Decimal Number for Converting it to a Binary Number.');    }    $binaryNumber = '';    while ($decimalNumber > 0) {        $binaryNumber = ($decimalNumber % 2) . $binaryNumber;        $decimalNumber /= 2;    }    return $binaryNumber;},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
39,TheAlgorithms_PHP_CheckPrime_2060, This function check whether\n the provided integer is a prime\n number or not.\n\n @param Integer $number An integer input\n @return boolean whether the number is prime or not\n,Ova funkcija proverava da li je dati ceo broj prost broj ili ne.,function isPrime(int $number){    if ($number === 2) {        return true;    }    if ($number % 2 === 0 or $number < 2) {        return false;    }    $i = 3;    while ($i <= sqrt($number)) {        if ($number % $i === 0) {            return false;        }        $i += 2;    }    return true;},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
40,TheAlgorithms_PHP_OctalToDecimal_2057, This function converts the\n submitted Decimal Number to\n Octal Number.\n\n @param string $decimalNumber\n @return string\n,Ova funkcija pretvara dati decimalni broj u oktalni broj.,function decimalToOctal($decimalNumber){    if (!is_numeric($decimalNumber)) {        throw new \Exception('Please pass a valid Decimal Number for Converting it to an Octal Number.');    }    $octalNumber = '';    while ($decimalNumber > 0) {        $octalNumber = ($decimalNumber % 8) . $octalNumber;        $decimalNumber /= 8;    }    return $octalNumber;},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
41,TheAlgorithms_PHP_PerfectSquare_2063, This function check whether\n the provided number is a\n perfect square or not.\n\n @param Decimal $number A decimal input\n @return boolean whether the number is perfect square or not\n,Funkcija proverava da li dati broj savršeni kvadrat ili ne.,function is_perfect_square($number){    $root = (int) sqrt($number);    return (($root * $root) === $number); // If number's square root is an integer then it's a perfect square else not},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
42,YOURLS_YOURLS_functions-auth_647, Check a submitted password sent in plain text against stored password which can be a salted hash\n\n,Proverava da li je podneta lozinka koja je u formi teksta ista kao lozinka koja je heširana.,"function yourls_check_password_hash( $user, $submitted_password ) {",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
43,YOURLS_YOURLS_functions-formatting_686," Make sure a date is m(m)/d(d)/yyyy, return false otherwise\n\n","Proveri da li je datum u m(m)/d(d)/yyyy formatu, inače vrati false","function yourls_sanitize_date( $date ) {if( !preg_match( '!^\d{1,2}/\d{1,2}/\d{4}$!' , $date ) ) {return false;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
44,bobthecow_psysh_ConfigPaths_1463," Get potential config directory paths.\n\n Returns `~/.psysh`, `%APPDATA%/PsySH` (when on Windows), and all\n XDG Base Directory config directories:\n\n     http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\n\n @return string[]\n",Vrati potencijalne putanje do direktorijuma koji bi mogli da sadrže konfiguraciju.,"    public function configDirs()    {        if ($this->configDir !== null) {            return [$this->configDir];        }        $configDirs = $this->getEnvArray('XDG_CONFIG_DIRS') ?: ['/etc/xdg'];        return $this->allDirNames(\array_merge([$this->homeConfigDir()], $configDirs));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
45,bobthecow_psysh_ConfigPaths_1466," Get the current home config directory.\n\n Returns the highest precedence home config directory which actually\n exists. If none of them exists, returns the highest precedence home\n config directory (`%APPDATA%/PsySH` on Windows, `~/.config/psysh`\n everywhere else).\n\n @see self::homeConfigDir\n\n @return string\n","Vrati trenutnu putanju do home direktorijuma. Vraća najviši direktorijum koji trenutno postoji. Ako nijedan ne postoji, vraća direktorijum u zavisnosti od operativnog sistema.",public function currentConfigDir()    {        if ($this->configDir !== null) {            return $this->configDir;        }        $configDirs = $this->allDirNames([$this->homeConfigDir()]);        foreach ($configDirs as $configDir) {            if (@\is_dir($configDir)) {                return $configDir;            }        }        return $configDirs[0];    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
46,bobthecow_psysh_ConfigPaths_1471, Find real data files in config directories.\n\n @param string[] $names Config file names\n\n @return string[]\n,Nalazi stvarne fajlove u konfiguracionim direktorijima.,"    public function dataFiles(array $names)    {        return $this->allRealFiles($this->dataDirs(), $names);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
47,bobthecow_psysh_ConfigPaths_1475," Given a list of directories, and a list of filenames, find the ones that\n are real files.\n\n @return string[]\n","Za listu direktorijuma i listu nazia fajlova, nalazi one koji su zaista fajlovi.","    private function allRealFiles(array $dirNames, array $fileNames)    {        $files = [];        foreach ($dirNames as $dir) {            foreach ($fileNames as $name) {                $file = $dir.'/'.$name;                if (@\is_file($file)) {                    $files[] = $file;                }            }        }        return $files;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
48,botman_botman_BotMan_553, Return a random message.\\n @param array $messages\\n @return $this\\n,Vrati nasumičnu poruku,    public function randomReply(array $messages)    {        return $this->reply($messages[array_rand($messages)]);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
49,briannesbitt_Carbon_CarbonImmutable_4, Create a very old date representing start of time.\\n\\n @return static\\n,Napravi jako stari datum koji predstavlja početak vremena,public static function startOfTime(): self    {        $date = static::parse('0001-01-01')->years(self::getStartOfTimeYear());        $date->startOfTime = true;        return $date;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
50,briannesbitt_Carbon_CarbonInterface_107, Prepare the object for JSON serialization.\n\n @return array|string\n,Pripremi objekat za JSON serijalizaciju.,    public function jsonSerialize();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
51,briannesbitt_Carbon_CarbonInterface_108,Determines if the instance is less (before) than another\\n\\n @example\\n ```\\n Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:15'); // false\\n Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:16'); // false\\n Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:17'); // true\\n ```\\n\\n @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date\\n\\n @return bool\\n,Proveri da li je instanca pre neke druge. Na primer Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:15');,    public function lessThan($date): bool;,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
52,briannesbitt_Carbon_CarbonInterface_125, Go forward to the next weekday.\\n\\n @return static\\n,Idi na sledeći radni dan,    public function nextWeekday();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
53,briannesbitt_Carbon_CarbonInterface_133, Go backward to the previous weekday.\\n\\n @return static\\n,Idi nazad na prethodni radni dan.,    public function previousWeekday();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
54,briannesbitt_Carbon_CarbonInterface_143,The number of seconds until 23:59:59.\\\\n\\\\n @return int\\\\n,Broj sekundi do kraja dana,    public function secondsUntilEndOfDay();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
55,briannesbitt_Carbon_CarbonInterface_146," Set the date with gregorian year, month and day numbers.\\n\\n @see https://php.net/manual/en/datetime.setdate.php\\n\\n @param int $year\\n @param int $month\\n @param int $day\\n\\n @return static\\n",Postavi datum pomoću gregorijanskih godina meseci i dana.,"    public function setDate($year, $month, $day);",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
56,briannesbitt_Carbon_CarbonInterface_152, Set the time by time string.\n\n @param string $time\n\n @return static\n,Postavi datum pomoću stringa.,    public function setTimeFromTimeString($time);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
79,composer_composer_Config_2510, Turns relative paths in absolute paths without realpath()\n\n Since the dirs might not exist yet we can not call realpath or it will fail.\n\n @param  string $path\n @return string\n,Pretvara relativne putanje u apsolutne putanje bez realpath(). S obzirom da možda ne postoje svi direktorijumi realpath() ne sme da se pozove jer može da pukne.,"private function realpath($path)    {        if (preg_match('{^(?:/|[a-z]:|[a-z0-9.]+://)}i', $path)) {            return $path;        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
80,composer_composer_InstalledVersions_2525, Returns a list of all package names with a specific type e.g. 'library'\n\n @param  string   $type\n @return string[]\n @psalm-return list<string>\n,"Vraća listu naziva svih paketa određenog tipa, npr ‘biblioteka’.",    public static function getInstalledPackagesByType($type)    {        $packagesByType = array();        foreach (self::getInstalled() as $installed) {            foreach ($installed['versions'] as $name => $package) {                if (isset($package['type']) && $package['type'] === $type) {                    $packagesByType[] = $name;                }            }        }        return $packagesByType;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
81,danielstjules_Stringy_Stringy_10262," Trims the string and replaces consecutive whitespace characters with a\n single space. This includes tabs and newline characters, as well as\n multibyte whitespace such as the thin space and ideographic space.\n\n @return static Object with a trimmed $str and condensed whitespace\n","Skraćuje string i menja uzastopne razmake sa pojedinačnim razmacima. Razmaci uključuju tabove i karaktere za novi red, kao i višebajtovske razmake.","    public function collapseWhitespace()    {        return $this->regexReplace('[[:space:]]+', ' ')->trim();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
82,danielstjules_Stringy_Stringy_10266," Ensures that the string begins with $substring. If it doesn't, it's\n prepended.\n\n @param  string $substring The substring to add if not present\n @return static Object with its $str prefixed by the $substring\n","Proverava da li string počinje sa podstringom, ako ne, dodaje ga na početak.","    public function ensureLeft($substring)    {        $stringy = static::create($this->str, $this->encoding);        if (!$stringy->startsWith($substring)) {            $stringy->str = $substring . $stringy->str;        }        return $stringy;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
83,danielstjules_Stringy_Stringy_10272," Returns true if the string contains an upper case char, false\n otherwise.\n\n @return bool Whether or not the string contains an upper case character.\n",Vraća tačno ukoliko string sadrži veliko slovo.,    public function hasUpperCase()    {        return $this->matchesPattern('.*[[:upper:]]');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
84,danielstjules_Stringy_Stringy_10274, Inserts $substring into the string at the $index provided.\n\n @param  string $substring String to be inserted\n @param  int    $index     The index at which to insert the substring\n @return static Object with the resulting $str after the insertion\n,Ubacuje podstring u string na željenu poziciju.,"public function insert($substring, $index)    {        $stringy = static::create($this->str, $this->encoding);        if ($index > $stringy->length()) {            return $stringy;        }        $start = \mb_substr($stringy->str, 0, $index, $stringy->encoding);        $end = \mb_substr($stringy->str, $index, $stringy->length(),            $stringy->encoding);        $stringy->str = $start . $substring . $end;        return $stringy;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
85,danielstjules_Stringy_Stringy_10279,"Returns true if the string is JSON, false otherwise. Unlike json_decode\n in PHP 5.x, this method is consistent with PHP 7 and other JSON parsers,\n in that an empty string is not considered valid JSON.\n\n @return bool Whether or not $str is JSON\n","Vraća tačno ukoliko je string JSON, a inače netačno. Ovaj metod je konzistantan sa PHP 7 i drugim JSON parserima u tome da se prazan string ne računa kao ispravan JSON.",    public function isJson()    {        if (!$this->length()) {            return false;        }        json_decode($this->str);        return (json_last_error() === JSON_ERROR_NONE);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
86,danielstjules_Stringy_Stringy_10285, Returns the length of the string. An alias for PHP's mb_strlen() function.\n\n @return int The number of characters in $str given the encoding\n,Vraća dužinu stringa. Menja PHPovu mb_strlen() funkciju.,"    public function length()    {        return \mb_strlen($this->str, $this->encoding);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
87,danielstjules_Stringy_Stringy_10296," Returns a new string with the prefix $substring removed, if present.\n\n @param  string $substring The prefix to remove\n @return static Object having a $str without the prefix $substring\n",Vraća novi string kome je prefiks u obliku podstringa uklonjen ukoliko postoji.,"    public function removeLeft($substring)    {        $stringy = static::create($this->str, $this->encoding);        if ($stringy->startsWith($substring)) {            $substringLength = \mb_strlen($substring, $stringy->encoding);            return $stringy->substr($substringLength);        }        return $stringy;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
88,danielstjules_Stringy_Stringy_10300, Returns a reversed string. A multibyte version of strrev().\n\n @return static Object with a reversed $str\n,Obrće string unazad.,"public function reverse()    {        $strLength = $this->length();        $reversed = '';        // Loop from last index of string to first        for ($i = $strLength - 1; $i >= 0; $i--) {            $reversed .= \mb_substr($this->str, $i, 1, $this->encoding);        }        return static::create($reversed, $this->encoding);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
89,dompdf_dompdf_Cpdf_339,draw a bezier curve based on 4 control points\n\n @param $x0\n @param $y0\n @param $x1\n @param $y1\n @param $x2\n @param $y2\n @param $x3\n @param $y3\n,Crta bezier-ovu krivu zasnovanu na četiri kontrolne tačke.,"function curve($x0, $y0, $x1, $y1, $x2, $y2, $x3, $y3)    {        // in the current line style, draw a bezier curve from (x0,y0) to (x3,y3) using the other two points        // as the control points for the curve.        $this->addContent(            sprintf(""\n%.3F %.3F m %.3F %.3F %.3F %.3F %.3F %.3F c S"", $x0, $y0, $x1, $y1, $x2, $y2, $x3, $y3)        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
90,dompdf_dompdf_Cpdf_345,"a filled rectangle, note that it is the width and height of the rectangle which are the secondary parameters, not\n the coordinates of the upper-right corner\n\n @param $x1\n @param $y1\n @param $width\n @param $height\n","Ispunjen pravougaonik. Obratiti pažnju da su širina i visina sekundarni parametri, a ne koordinate gornjeg desnog ugla.","function filledRectangle($x1, $y1, $width, $height)    {        $this->addContent(sprintf(""\n%.3F %.3F %.3F %.3F re f"", $x1, $y1, $width, $height));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
91,dompdf_dompdf_Cpdf_362, apply graphic transformations\n\n @param array $tm transformation matrix\n,Primeni grafičku transformaciju.,"function transform($tm)    {        $this->addContent(vsprintf(""\n %.3F %.3F %.3F %.3F %.3F %.3F cm"", $tm));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
92,dompdf_dompdf_Cpdf_377, extract an integer from a position in a byte stream\n\n @param $data\n @param $pos\n @param $num\n @return int\n,Vrati ceo broj sa pozicije u toku bajtova.,"private function getBytes(&$data, $pos, $num)    {        // return the integer represented by $num bytes from $pos within $data        $ret = 0;        for ($i = 0; $i < $num; $i++) {            $ret *= 256;            $ret += ord($data[$pos + $i]);        }        return $ret;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
93,dompdf_dompdf_JavascriptEmbedder_623, Embeds Javascript into the PDF document\n\n @package dompdf\n,Usađuje javascript u PDF dokument,class JavascriptEmbedder{    /**     * @var Dompdf     */    protected $_dompdf;    /**     * JavascriptEmbedder constructor.     *     * @param Dompdf $dompdf     */    public function __construct(Dompdf $dompdf)    {        $this->_dompdf = $dompdf;    }    /**     * @param $script     */    public function insert($script)    {        $this->_dompdf->getCanvas()->javascript($script);    }    /**     * @param Frame $frame     */    public function render(Frame $frame)    {        if (!$this->_dompdf->getOptions()->getIsJavascriptEnabled()) {            return;        }        $this->insert($frame->get_node()->nodeValue);    }},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
94,filp_whoops_FrameCollection_6736," Returns an array with all frames, does not affect\n the internal array.\n\n @todo   If this gets any more complex than this,\n         have getIterator use this method.\n @see    FrameCollection::getIterator\n @return array\n","Vraća niz sa svim frejmovima, bez da utiče na lokalni niz.",    public function getArray()    {        return $this->frames;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
95,filp_whoops_FrameCollection_7500, Count the frames that belongs to the application.\n\n @return int\n,Izbroj frejmove koji pripadaju aplikaciji.,"    public function countIsApplication()    {        return count(array_filter($this->frames, function (Frame $f) {            return $f->isApplication();        }));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
96,filp_whoops_Frame_7102, Compares Frame against one another\n @param  Frame $frame\n @return bool\n,Proverava da li su dva frejma jednaka,    public function equals(Frame $frame)    {        if (!$this->getFile() || $this->getFile() === 'Unknown' || !$this->getLine()) {            return false;        }        return $frame->getFile() === $this->getFile() && $frame->getLine() === $this->getLine();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
97,fzaninotto_Faker_Iban_929, Checks whether an IBAN has a valid checksum\\\\n\\\\n @param string $iban\\\\n @return boolean\\\\n,Proverava da li IBAN ima validnu checksumu,"public static function isValid($iban)    {        return self::checksum($iban) === substr($iban, 2, 2);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
98,getgrav_grav_Cache_1469, Returns a boolean state of whether or not the item exists in the cache based on id key\n\n @param string $id    the id of the cached data entry\n @return bool         true if the cached items exists\n,Vraća logičko stanje toga da li stavka postoji u kešu za zadati id ključ.,    public function contains($id)    {        if ($this->enabled) {            return $this->driver->contains(($id));        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
99,getgrav_grav_Grav_1202, Measure how long it takes to do an action.\\n\\n @param string $timerId\\n @param string $timerTitle\\n @param callable $callback\\n @return mixed   Returns value returned by the callable.\\n,Meri koliko vremena traje određena akcija.,"    public function measureTime(string $timerId, string $timerTitle, callable $callback)    {        $debugger = $this['debugger'];        $debugger->startTimer($timerId, $timerTitle);        $result = $callback();        $debugger->stopTimer($timerId);        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
100,getgrav_grav_Grav_1205," This attempts to find media, other files, and download them\\n\\n @param string $path\\n @return PageInterface|false\\n",Pokušava da nađe medije i druge fajlove i da ih preuzme.,"    public function fallbackUrl($path)    {        $this->fireEvent('onPageFallBackUrl');        /** @var Uri $uri */        $uri = $this['uri'];        /** @var Config $config */        $config = $this['config'];        $uri_extension = strtolower($uri->extension());        $fallback_types = $config->get('system.media.allowed_fallback_types', null);        $supported_types = $config->get('media.types');        // Check whitelist first, then ensure extension is a valid media type        if (!empty($fallback_types) && !in_array($uri_extension, $fallback_types, true)) {            return false;        }        if (!array_key_exists($uri_extension, $supported_types)) {            return false;        }        $path_parts = pathinfo($path);        /** @var Pages $pages */        $pages = $this['pages'];        $page = $pages->find($path_parts['dirname'], true);        if ($page) {            $media = $page->media()->all();            $parsed_url = parse_url(rawurldecode($uri->basename()));            $media_file = $parsed_url['path'];            // if this is a media object, try actions first            if (isset($media[$media_file])) {                /** @var Medium $medium */                $medium = $media[$media_file];                foreach ($uri->query(null, true) as $action => $params) {                    if (in_array($action, ImageMedium::$magic_actions, true)) {                        call_user_func_array([&$medium, $action], explode(',', $params));                    }                }                Utils::download($medium->path(), false);            }            // unsupported media type, try to download it...            if ($uri_extension) {                $extension = $uri_extension;            } else {                if (isset($path_parts['extension'])) {                    $extension = $path_parts['extension'];                } else {                    $extension = null;                }            }            if ($extension) {                $download = true;                if (in_array(ltrim($extension, '.'), $config->get('system.media.unsupported_inline_types', []), true)) {                    $download = false;                }                Utils::download($page->path() . DIRECTORY_SEPARATOR . $uri->basename(), $download);            }            // Nothing found            return false;        }        return $page;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
101,googleapis_google-api-php-client_Model_665, Convert a string to camelCase\n @param  string $value\n @return string\n,Prevodi string u camelCase,"private function camelCase($value)  {    $value = ucwords(str_replace(array('-', '_'), ' ', $value));    $value = str_replace(' ', '', $value);    $value[0] = strtolower($value[0]);    return $value;  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
102,hamcrest_hamcrest-php_Hamcrest_1806, Evaluates to true if any item in an array satisfies the given matcher.\n\n @param mixed $item as a {@link Hamcrest\\Matcher} or a value.\n\n @return \\Hamcrest\\Arrays\\IsArrayContaining\n,Vraća tačno ukoliko bar jedan objekat u nizu zadovoljava uslov.,    function hasItemInArray($item)    {        return \Hamcrest\Arrays\IsArrayContaining::hasItemInArray($item);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
103,hamcrest_hamcrest-php_Hamcrest_1808, An array with elements that match the given matchers.\\n,Niz elemenata koji se podudaraju sa datim šablonima,"    function arrayContainingInAnyOrder(/* args... */)    {        $args = func_get_args();        return call_user_func_array(array('\Hamcrest\Arrays\IsArrayContainingInAnyOrder', 'arrayContainingInAnyOrder'), $args);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
104,hamcrest_hamcrest-php_Hamcrest_1814, Test if an array has both an key and value in parity with each other.\\n,Proveri da li niz sadrži i ključ i vrednost koji su upareni.,"    function hasKeyValuePair($key, $value)    {        return \Hamcrest\Arrays\IsArrayContainingKeyValuePair::hasKeyValuePair($key, $value);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
105,hamcrest_hamcrest-php_Hamcrest_1817, Matches an empty array.\\n,Podudara se sa praznim nizom,    function emptyArray()    {        return \Hamcrest\Arrays\IsArrayWithSize::emptyArray();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
106,hamcrest_hamcrest-php_Hamcrest_1833," Is the value equal to another value, as tested by the use of the ""==""\n comparison operator?\n","Da li je jedna vrednost jednaka drugoj vrednosti, kao kad bi bio korišćen operator ==.",    function equalTo($item)    {        return \Hamcrest\Core\IsEqual::equalTo($item);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
107,hamcrest_hamcrest-php_Hamcrest_1834," Tests of the value is identical to $value as tested by the ""==="" operator.\\n","Proverava da li su dve vrednosti identične, kao kada bi bio korišćen operator ===.",    function identicalTo($value)    {        return \Hamcrest\Core\IsIdentical::identicalTo($value);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
108,hamcrest_hamcrest-php_Hamcrest_1836," Is the value an instance of a particular type?\\n This version assumes no relationship between the required type and\\n the signature of the method that sets it up, for example in\\n <code>assertThat($anObject, anInstanceOf('Thing'));</code>\\n",Proverava da li je vrednost instance određenog tipa. Ova verzija ne podrazumeva nikakav odnos između traženog tipa i potpisa metoda koji ga postavlja.,    function any($theClass)    {        return \Hamcrest\Core\IsInstanceOf::anInstanceOf($theClass);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
109,hamcrest_hamcrest-php_Hamcrest_1860, Matches if value is a string that matches regular expression $pattern.\n,Podudara se ako je vrednost string koji se podudara sa regularnim izrazom.,    function matchesPattern($pattern)    {        return \Hamcrest\Text\MatchesPattern::matchesPattern($pattern);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
110,hamcrest_hamcrest-php_Hamcrest_1861, Matches if value is a string that contains $substring.\n,Podudara se ako je vrednost string koji sadržei podstring.,    function containsString($substring)    {        return \Hamcrest\Text\StringContains::containsString($substring);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
111,hamcrest_hamcrest-php_Hamcrest_1862, Matches if value is a string that contains $substring regardless of the case.\n,"Slaže se ukoliko string sadrži podstring, bez obzira na mala i velika slova.",    function containsStringIgnoringCase($substring)    {        return \Hamcrest\Text\StringContainsIgnoringCase::containsStringIgnoringCase($substring);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
112,hamcrest_hamcrest-php_Hamcrest_1865, Matches if value is a string that starts with $substring.\\n,Slaže se ukoliko string počinje podstringom,    function startsWith($substring)    {        return \Hamcrest\Text\StringStartsWith::startsWith($substring);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
113,hamcrest_hamcrest-php_Hamcrest_1866, Is the value an array?\n,Proverava da li je vrednost niz,    function arrayValue()    {        return \Hamcrest\Type\IsArray::arrayValue();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
114,hamcrest_hamcrest-php_Hamcrest_1868, Is the value a boolean?\n,Proverava da li je vrednost logička,    function boolValue()    {        return \Hamcrest\Type\IsBoolean::booleanValue();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
115,hamcrest_hamcrest-php_Hamcrest_1875, Is the value an object?\\n,Proverava da li je vrednost objekat.,    function objectValue()    {        return \Hamcrest\Type\IsObject::objectValue();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
116,hamcrest_hamcrest-php_Hamcrest_2366, Matches if value is a non-zero-length string.\n,Slaže se ukoliko je vrednost string nenulte dužine.,    function isNonEmptyString()    {        return \Hamcrest\Text\IsEmptyString::isNonEmptyString();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
117,jorgecasas_php-ml_AdaBoost_840, Returns the classifier with the lowest error rate with the\n consideration of current sample weights\n,Vrati klasifikator sa najmanjom greškom uz razmatranje težina trenutnog uzorka,"protected function getBestClassifier(): Classifier    {        $ref = new ReflectionClass($this->baseClassifier);        /** @var Classifier $classifier */        $classifier = count($this->classifierOptions) === 0 ? $ref->newInstance() : $ref->newInstanceArgs($this->classifierOptions);        if ($classifier instanceof WeightedClassifier) {            $classifier->setSampleWeights($this->weights);            $classifier->train($this->samples, $this->targets);        } else {            [$samples, $targets] = $this->resample();            $classifier->train($samples, $targets);        }        return $classifier;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
118,jorgecasas_php-ml_Adaline_852, Adapts the weights with respect to given samples and targets\n by use of gradient descent learning rule\n,Prilagođava težine uzimajući u obzir date uzorke i ciljeve koristeći gradijentni spust.,"protected function runTraining(array $samples, array $targets): void    {        // The cost function is the sum of squares        $callback = function ($weights, $sample, $target): array {            $this->weights = $weights;            $output = $this->output($sample);            $gradient = $output - $target;            $error = $gradient ** 2;            return [$error, $gradient];        };        $isBatch = $this->trainingType == self::BATCH_TRAINING;        parent::runGradientDescent($samples, $targets, $callback, $isBatch);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
119,jorgecasas_php-ml_ConjugateGradient_931, Executes the callback function for the problem and returns\n sum of the gradient for all samples & targets.\n,Izvršava funkciju povratnog poziva i vraća sumu gradijenta za sve uzorke i ciljeve,"protected function gradient(array $theta): array    {        [, $updates, $penalty] = parent::gradient($theta);        // Calculate gradient for each dimension        $gradient = [];        for ($i = 0; $i <= $this->dimensions; ++$i) {            if ($i === 0) {                $gradient[$i] = array_sum($updates);            } else {                $col = array_column($this->samples, $i - 1);                $error = 0;                foreach ($col as $index => $val) {                    $error += $val * $updates[$index];                }                $gradient[$i] = $error + $penalty * $theta[$i];            }        }        return $gradient;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
120,jorgecasas_php-ml_ConjugateGradient_943, Element-wise <b>subtraction</b> of a vector with a scalar\n,Oduzimanje skalara od vektora. Od svakog elementa vektora se oduzima vrednost skalara.,"public static function subs(array $m1, float $m2): array    {        return self::adds($m1, $m2, -1);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
121,jorgecasas_php-ml_DecisionStump_857, Returns the probability of the sample of belonging to the given label\n\n Probability of a sample is calculated as the proportion of the label\n within the labels of the training samples in the decision node\n\n @param mixed $label\n,Vraća verovatnoću da uzorak pripada datom cilju. Verovatnoća uzorka se računa kao odnos cilj među ciljevima uzoraka iz skupa za obučavanje za čvor odlučivanja.,"protected function predictProbability(array $sample, $label): float    {        $predicted = $this->predictSampleBinary($sample);        if ((string) $predicted == (string) $label) {            return $this->prob[$label];        }        return 0.0;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
122,jorgecasas_php-ml_EigenTransformerBase_897, Class to compute eigen pairs (values & vectors) of a given matrix\n with the consideration of numFeatures or totalVariance to be preserved\n\n @author hp\n,Klasa za računanje sopstvenih parova (vrednosti i vektora) date matrice sa obaziranjem da numFeatures ili totalVariance budu očuvane.,abstract class EigenTransformerBase{    /**     * Total variance to be conserved after the reduction     *     * @var float     */    public $totalVariance = 0.9;    /**     * Number of features to be preserved after the reduction     *     * @var int     */    public $numFeatures = null;    /**     * Top eigenvectors of the matrix     *     * @var array     */    protected $eigVectors = [];    /**     * Top eigenValues of the matrix     *     * @var array     */    protected $eigValues = [];    /**     * Calculates eigenValues and eigenVectors of the given matrix. Returns     * top eigenVectors along with the largest eigenValues. The total explained variance     * of these eigenVectors will be no less than desired $totalVariance value     */    protected function eigenDecomposition(array $matrix): void    {        $eig = new EigenvalueDecomposition($matrix);        $eigVals = $eig->getRealEigenvalues();        $eigVects = $eig->getEigenvectors();        $totalEigVal = array_sum($eigVals);        // Sort eigenvalues in descending order        arsort($eigVals);        $explainedVar = 0.0;        $vectors = [];        $values = [];        foreach ($eigVals as $i => $eigVal) {            $explainedVar += $eigVal / $totalEigVal;            $vectors[] = $eigVects[$i];            $values[] = $eigVal;            if ($this->numFeatures !== null) {                if (count($vectors) == $this->numFeatures) {                    break;                }            } else {                if ($explainedVar >= $this->totalVariance) {                    break;                }            }        }        $this->eigValues = $values;        $this->eigVectors = $vectors;    }    /**     * Returns the reduced data     */    protected function reduce(array $data): array    {        $m1 = new Matrix($data);        $m2 = new Matrix($this->eigVectors);        return $m1->multiply($m2->transpose())->toArray();    }},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
123,jorgecasas_php-ml_EigenvalueDecomposition_1002, Performs complex division.\n\n @param int|float $xr\n @param int|float $xi\n @param int|float $yr\n @param int|float $yi\n,Izvršava deljenje dva kompleksna broja.,"    private function cdiv($xr, $xi, $yr, $yi): void    {        if (abs($yr) > abs($yi)) {            $r = $yi / $yr;            $d = $yr + $r * $yi;            $this->cdivr = ($xr + $r * $xi) / $d;            $this->cdivi = ($xi - $r * $xr) / $d;        } else {            $r = $yr / $yi;            $d = $yi + $r * $yr;            $this->cdivr = ($r * $xr + $xi) / $d;            $this->cdivi = ($r * $xi - $xr) / $d;        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
124,jorgecasas_php-ml_EigenvalueDecomposition_995, Return the eigenvector matrix\n,Vraća matricu sopstvenih vektora.,"public function getEigenvectors(): array    {        $vectors = $this->V;        // Always return the eigenvectors of length 1.0        $vectors = new Matrix($vectors);        $vectors = array_map(function ($vect) {            $sum = 0;            $count = count($vect);            for ($i = 0; $i < $count; ++$i) {                $sum += $vect[$i] ** 2;            }            $sum **= .5;            for ($i = 0; $i < $count; ++$i) {                $vect[$i] /= $sum;            }            return $vect;        }, $vectors->transpose()->toArray());        return $vectors;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
125,jorgecasas_php-ml_FuzzyCMeans_877, The objective is to minimize the distance between all data points\n and all cluster centers. This method returns the summation of all\n these distances\n,Cilj je minimizacija udaljenost između svih tačaka i svih centara grupa. Metod vraća sumu svih ovih udaljenosti.,"protected function getObjective(): float    {        $sum = 0.0;        $distance = new Euclidean();        for ($i = 0; $i < $this->clustersNumber; ++$i) {            $clust = $this->clusters[$i]->getCoordinates();            for ($k = 0; $k < $this->sampleCount; ++$k) {                $point = $this->samples[$k];                $sum += $distance->distance($clust, $point);            }        }        return $sum;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
126,jorgecasas_php-ml_LDA_910, Calculates mean of each column for each class and returns\n n by m matrix where n is number of labels and m is number of columns\n,"Računa srednju svake kolone za svaku klasu i vraća nxm matricu gde je n broj labela, a m broj kolona.","protected function calculateMeans(array $data, array $classes): array    {        $means = [];        $counts = [];        $overallMean = array_fill(0, count($data[0]), 0.0);        foreach ($data as $index => $row) {            $label = array_search($classes[$index], $this->labels, true);            foreach ($row as $col => $val) {                if (!isset($means[$label][$col])) {                    $means[$label][$col] = 0.0;                }                $means[$label][$col] += $val;                $overallMean[$col] += $val;            }            if (!isset($counts[$label])) {                $counts[$label] = 0;            }            ++$counts[$label];        }        foreach ($means as $index => $row) {            foreach ($row as $col => $sum) {                $means[$index][$col] = $sum / $counts[$index];            }        }        // Calculate overall mean of the dataset for each column        $numElements = array_sum($counts);        $map = function ($el) use ($numElements) {            return $el / $numElements;        };        $this->overallMean = array_map($map, $overallMean);        $this->counts = $counts;        return $means;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
127,jorgecasas_php-ml_LogisticRegression_869, Returns the probability of the sample of belonging to the given label.\n\n The probability is simply taken as the distance of the sample\n to the decision plane.\n\n @param mixed $label\n,Vraća verovatnoću da dat uzorak pripada zadatom cilju. Verovatnoća se prosto uzima kao udaljenost uzorka do ravni odlučivanja.,"protected function predictProbability(array $sample, $label): float    {        $sample = $this->checkNormalizedSample($sample);        $probability = $this->output($sample);        if (array_search($label, $this->labels, true) > 0) {            return $probability;        }        return 1 - $probability;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
128,jorgecasas_php-ml_Matrix_964, Element-wise subtracting of another matrix from this one\n,Oduzimanje druge matrice od ove po elementima.,"public function subtract(self $other): self    {        return $this->sum($other, -1);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
129,jorgecasas_php-ml_Matrix_967," Returns the dot product of two arrays<br>\n Matrix::dot(x, y) ==> x.y'\n",Vraća skalarni proizvod dva niza.,"public static function dot(array $array1, array $array2): array    {        $m1 = new self($array1, false);        $m2 = new self($array2, false);        return $m1->multiply($m2->transpose())->toArray()[0];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
130,jorgecasas_php-ml_PCA_914, Takes a data and returns a lower dimensional version\n of this data while preserving $totalVariance or $numFeatures. <br>\n $data is an n-by-m matrix and returned array is\n n-by-k matrix where k <= m\n,Uzima podatke i vraća njihovu niže dimenzionalnu verzija sa učanjem ukupne varijanse ili broja odlika. Podaci su nxm matrica a vraćena matrica je nxk matrica gde je k <= m.,"public function fit(array $data): array    {        $n = count($data[0]);        $data = $this->normalize($data, $n);        $covMatrix = Covariance::covarianceMatrix($data, array_fill(0, $n, 0));        $this->eigenDecomposition($covMatrix);        $this->fit = true;        return $this->reduce($data);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
131,jorgecasas_php-ml_PCA_916, Normalization of the data includes subtracting mean from\n each dimension therefore dimensions will be centered to zero\n,"Normalizacija koja podrazumeva oduzimanje srednje vrednosti od svake dimenzije, tako da su sve dimenzije centrirane na nulu.","protected function normalize(array $data, int $n): array    {        if (count($this->means) === 0) {            $this->calculateMeans($data, $n);        }        // Normalize data        foreach (array_keys($data) as $i) {            for ($k = 0; $k < $n; ++$k) {                $data[$i][$k] -= $this->means[$k];            }        }        return $data;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
132,jorgecasas_php-ml_Set_982, Removes duplicates and rewrites index.\n\n @param string[]|int[]|float[]|bool[] $elements\n\n @return string[]|int[]|float[]|bool[]\n,Briše duplikate I prepisuje indekse.,"    private static function sanitize(array $elements): array    {        sort($elements, SORT_ASC);        return array_values(array_unique($elements, SORT_ASC));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
133,jorgecasas_php-ml_StandardDeviation_1020, Sum of squares deviations\n ∑⟮xᵢ - μ⟯²\n\n @param float[]|int[] $numbers\n,Suma kvadrata devijacija.,"public static function sumOfSquares(array $numbers): float    {        if (count($numbers) === 0) {            throw new InvalidArgumentException('The array has zero elements');        }        $mean = Mean::arithmetic($numbers);        return array_sum(array_map(            static function ($val) use ($mean): float {                return ($val - $mean) ** 2;            },            $numbers        ));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
134,jorgecasas_php-ml_StochasticGD_949, Stochastic Gradient Descent optimization method\n to find a solution for the equation A.ϴ = y where\n  A (samples) and y (targets) are known and ϴ is unknown.\n,"Stohastični gradijentni spust kao metod optimizacija za nalaženje rešenja jednačine Atheta=y gde su A (uzorci) i y (ciljevi) poznati, a theta nije poznato.","class StochasticGD extends Optimizer{    /**     * A (samples)     *     * @var array     */    protected $samples = [];    /**     * y (targets)     *     * @var array     */    protected $targets = [];    /**     * Callback function to get the gradient and cost value     * for a specific set of theta (ϴ) and a pair of sample & target     *     * @var \Closure|null     */    protected $gradientCb;    /**     * Maximum number of iterations used to train the model     *     * @var int     */    protected $maxIterations = 1000;    /**     * Learning rate is used to control the speed of the optimization.<br>     *     * Larger values of lr may overshoot the optimum or even cause divergence     * while small values slows down the convergence and increases the time     * required for the training     *     * @var float     */    protected $learningRate = 0.001;    /**     * Minimum amount of change in the weights and error values     * between iterations that needs to be obtained to continue the training     *     * @var float     */    protected $threshold = 1e-4;    /**     * Enable/Disable early stopping by checking the weight & cost values     * to see whether they changed large enough to continue the optimization     *     * @var bool     */    protected $enableEarlyStop = true;    /**     * List of values obtained by evaluating the cost function at each iteration     * of the algorithm     *     * @var array     */    protected $costValues = [];    /**     * Initializes the SGD optimizer for the given number of dimensions     */    public function __construct(int $dimensions)    {        // Add one more dimension for the bias        parent::__construct($dimensions + 1);        $this->dimensions = $dimensions;    }    public function setTheta(array $theta): Optimizer    {        if (count($theta) !== $this->dimensions + 1) {            throw new InvalidArgumentException(sprintf('Number of values in the weights array should be %s', $this->dimensions + 1));        }        $this->theta = $theta;        return $this;    }    /**     * Sets minimum value for the change in the theta values     * between iterations to continue the iterations.<br>     *     * If change in the theta is less than given value then the     * algorithm will stop training     *     * @return $this     */    public function setChangeThreshold(float $threshold = 1e-5)    {        $this->threshold = $threshold;        return $this;    }    /**     * Enable/Disable early stopping by checking at each iteration     * whether changes in theta or cost value are not large enough     *     * @return $this     */    public function setEarlyStop(bool $enable = true)    {        $this->enableEarlyStop = $enable;        return $this;    }    /**     * @return $this     */    public function setLearningRate(float $learningRate)    {        $this->learningRate = $learningRate;        return $this;    }    /**     * @return $this     */    public function setMaxIterations(int $maxIterations)    {        $this->maxIterations = $maxIterations;        return $this;    }    /**     * Optimization procedure finds the unknow variables for the equation A.ϴ = y     * for the given samples (A) and targets (y).<br>     *     * The cost function to minimize and the gradient of the function are to be     * handled by the callback function provided as the third parameter of the method.     */    public function runOptimization(array $samples, array $targets, Closure $gradientCb): array    {        $this->samples = $samples;        $this->targets = $targets;        $this->gradientCb = $gradientCb;        $currIter = 0;        $bestTheta = null;        $bestScore = 0.0;        $this->costValues = [];        while ($this->maxIterations > $currIter++) {            $theta = $this->theta;            // Update the guess            $cost = $this->updateTheta();            // Save the best theta in the ""pocket"" so that            // any future set of theta worse than this will be disregarded            if ($bestTheta === null || $cost <= $bestScore) {                $bestTheta = $theta;                $bestScore = $cost;            }            // Add the cost value for this iteration to the list            $this->costValues[] = $cost;            // Check for early stop            if ($this->enableEarlyStop && $this->earlyStop($theta)) {                break;            }        }        $this->clear();        // Solution in the pocket is better than or equal to the last state        // so, we use this solution        return $this->theta = (array) $bestTheta;    }    /**     * Returns the list of cost values for each iteration executed in     * last run of the optimization     */    public function getCostValues(): array    {        return $this->costValues;    }    protected function updateTheta(): float    {        $jValue = 0.0;        $theta = $this->theta;        if ($this->gradientCb === null) {            throw new InvalidOperationException('Gradient callback is not defined');        }        foreach ($this->samples as $index => $sample) {            $target = $this->targets[$index];            $result = ($this->gradientCb)($theta, $sample, $target);            [$error, $gradient, $penalty] = array_pad($result, 3, 0);            // Update bias            $this->theta[0] -= $this->learningRate * $gradient;            // Update other values            for ($i = 1; $i <= $this->dimensions; ++$i) {                $this->theta[$i] -= $this->learningRate *                    ($gradient * $sample[$i - 1] + $penalty * $this->theta[$i]);            }            // Sum error rate            $jValue += $error;        }        return $jValue / count($this->samples);    }    /**     * Checks if the optimization is not effective enough and can be stopped     * in case large enough changes in the solution do not happen     */    protected function earlyStop(array $oldTheta): bool    {        // Check for early stop: No change larger than threshold (default 1e-5)        $diff = array_map(            function ($w1, $w2) {                return abs($w1 - $w2) > $this->threshold ? 1 : 0;            },            $oldTheta,            $this->theta        );        if (array_sum($diff) == 0) {            return true;        }        // Check if the last two cost values are almost the same        $costs = array_slice($this->costValues, -2);        if (count($costs) === 2 && abs($costs[1] - $costs[0]) < $this->threshold) {            return true;        }        return false;    }    /**     * Clears the optimizer internal vars after the optimization process.     */    protected function clear(): void    {        $this->samples = [];        $this->targets = [];        $this->gradientCb = null;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
135,lcobucci_jwt_Decoder_3360," Decodes from JSON, validating the errors\n\n @return mixed\n\n @throws CannotDecodeContent When something goes wrong while decoding.\n",Dekodira JSON I validira greške,    public function jsonDecode(string $json);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
136,lcobucci_jwt_Encoder_3363,Encodes to base64url\n\n @link http://tools.ietf.org/html/rfc4648#section-5\n,Enkodira podatke kao base64url.,public function base64UrlEncode(string $data): string;,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
137,lcobucci_jwt_Signer_3367, Returns if the expected hash matches with the data and key\n\n @throws InvalidKeyProvided When issue key is invalid/incompatible.\n @throws ConversionFailed   When signature could not be converted.\n,Proverava da li se hash poklapa sa podacima i datim ključem.,"    public function verify(string $expected, string $payload, Key $key): bool;",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
138,magento_magento2_Archive_2849, Check file is TAR.\n\n @param string $file\n @return boolean\n,Proverava da li je Fajl TAR.,public function isTar($file)    {        $archivers = $this->_getArchivers($file);        if (count($archivers) == 1 && $archivers[0] == self::TAPE_ARCHIVER) {            return true;        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
139,magento_magento2_CanViewNotification_2792, Validate if notification popup can be shown and set the notification flag\n\n @param array $arguments Attributes from element node.\n @inheritdoc\n,Potvrdi da li je moguće prikazati iskačuće obaveštenje i postavi flag.,"    public function isVisible(array $arguments): bool    {        $cacheKey = self::$cachePrefix;        $value = $this->cacheStorage->load($cacheKey);        if ($value !== 'log-exists') {            $logExists = $this->viewerLogger->checkLogExists();            if ($logExists) {                $this->cacheStorage->save('log-exists', $cacheKey);            }            return !$logExists;        }        return false;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
140,magento_magento2_processor_2883, Retrieve client IP address\n\n @return string\n,Dohvati klijentsu IP adresu.,    protected function _getClientIp()    {        return (isset($_SERVER['REMOTE_ADDR'])) ? $_SERVER['REMOTE_ADDR'] : 'undefined';    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
141,markrogoyski_math-php_Algebra_2490,"Least common multiple\n The smallest positive integer that is divisible by both a and b.\n For example, the LCM of 5 and 2 is 10.\n https://en.wikipedia.org/wiki/Least_common_multiple\n\n              |a ⋅ b|\n lcm(a, b) = ---------\n             gcd(a, b)\n\n @param  int $a\n @param  int $b\n\n @return int\n","Najmanji zajednički sadržalac. Najmanji pozitivni ceo broj koji je deljiv i sa a i sa b. Na primer, NZS brojeva 5 i 2 je 10.","public static function lcm(int $a, int $b): int    {        // Special case        if ($a === 0 || $b === 0) {            return 0;        }        return \abs($a * $b) / Algebra::gcd($a, $b);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
142,markrogoyski_math-php_Algebra_2493,Discriminant\\n https://en.wikipedia.org/wiki/Discriminant\\n\\n Δ = b² - 4ac\\n\\n @param  float $a x² coefficient\\n @param  float $b x coefficient\\n @param  float $c constant coefficient\\n\\n @return float\\n,Diskriminanta.,"public static function discriminant(float $a, float $b, float $c): float    {        return $b ** 2 - (4 * $a * $c);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
143,markrogoyski_math-php_ArbitraryInteger_2900,String representation - Display the number in base 10\\n\\n @return string\\n\\n @throws Exception\\\\BadParameterException\\n,"Predstavi broj u bazi 10, kao string.","public function __toString(): string    {        $sign = $this->isPositive ? '' : '-';        return $sign . BaseEncoderDecoder::toBase($this, 10);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
144,markrogoyski_math-php_ArbitraryInteger_2902,"Negate - Multiply by -1\\n\\n If $this is zero, then do nothing\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n",Negacija - množenje sa -1,"public function negate(): ArbitraryInteger    {        return self::fromBinary($this->base256, $this->base256 == \chr(0) ? true : !$this->isPositive);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
145,markrogoyski_math-php_ArbitraryInteger_2905, Factorial\\n\\n Calculate the factorial of an ArbitraryInteger\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n,Faktorijel. Izračunaj faktorijel za ArbitraryInteger.,public function fact(): ArbitraryInteger    {        $result = new ArbitraryInteger(1);        $i_obj  = new ArbitraryInteger(0);        for ($i = 1; !$this->lessThan($i); $i++) {            $i_obj  = $i_obj->add(1);            $result = $result->multiply($i_obj);        }        return $result;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
146,markrogoyski_math-php_ArbitraryInteger_2908," Multiply\\n Return the result of multiplying two ArbitraryIntegers, or an ArbitraryInteger and an integer.\\n @todo use Karatsuba algorithm\\n\\n @param int|string|ArbitraryInteger $number\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n",Množenje. Vrati rezultat množenja dva ArbitratyIntegera.,"public function multiply($number): ArbitraryInteger    {        $number_obj  = self::create($number);        $number  = $number_obj->toBinary();        $length  = \strlen($number);        $product = new ArbitraryInteger(0);        for ($i = 1; $i <= $length; $i++) {            $this_len      = \strlen($this->base256);            $base_digit    = \ord(\substr($number, -1 * $i, 1));            $carry         = 0;            $inner_product = '';            for ($j = 1; $j <= $this_len; $j++) {                $digit         = \ord(\substr($this->base256, -1 * $j, 1));                $step_product  = $digit * $base_digit + $carry;                $mod           = $step_product % 256;                $carry         = \intdiv($step_product, 256);                $inner_product = \chr($mod) . $inner_product;            }            if ($carry > 0) {                $inner_product = \chr($carry) . $inner_product;            }            $inner_product = $inner_product . \str_repeat(\chr(0), $i - 1);            $inner_obj     = self::fromBinary($inner_product, true);            $product       = $product->add($inner_obj);        }        return ($this->isPositive ^ $number_obj->isPositive()) ? $product->negate() : $product;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
147,markrogoyski_math-php_ArbitraryInteger_2913, Left Shift\\n\\n Shift the bits of $this $bits steps to the left\\n @param int|string|ArbitraryInteger $bits\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n,Pomeranje bitova objekta za bits koraka u levo.,"public function leftShift($bits)    {        $bits           = self::create($bits);        $shifted_string = '';        $length         = \strlen($this->base256);        [$bytes, $bits] = $bits->fullIntdiv(8);        $bits           = $bits->toInt();        $carry          = 0;        for ($i = 0; $i < $length; $i++) {            $chr = \ord($this->base256[$i]);            // If $shifted string is empty, don’t add 0x00.            $new_value = \chr($carry + \intdiv($chr << $bits, 256));            if ($shifted_string !== """" || $new_value !== \chr(0)) {                $shifted_string .= $new_value;            }            $carry = ($chr << $bits) % 256;        }        $shifted_string .= \chr($carry);        // Pad $bytes of 0x00 on the right.        $shifted_string = $shifted_string . \str_repeat(\chr(0), $bytes->toInt());        return self::fromBinary($shifted_string, true);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
148,markrogoyski_math-php_Average_3437, Calculate the mean average of a list of numbers\\n\\n     ∑⟮xᵢ⟯\\n x̄ = -----\\n       n\\n\\n @param float[] $numbers\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n,Računa srednju vrednost liste brojeva.,    public static function mean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the average of an empty list of numbers');        }        return \array_sum($numbers) / \count($numbers);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
149,markrogoyski_math-php_Average_3440,"Return the kth smallest value in an array\n Uses a linear-time algorithm: O(n) time in worst case.\n\n if $a = [1,2,3,4,6,7]\n\n kthSmallest($a, 4) = 6\n\n Algorithm:\n  1) If n is small, just sort and return\n  2) Otherwise, group into 5-element subsets and mind the median\n  3) Find the median of the medians\n  4) Find L and U sets\n     - L is numbers lower than the median of medians\n     - U is numbers higher than the median of medians\n  5) Recursive step\n     - if k is the median of medians, return that\n     - Otherwise, recursively search in smaller group.\n\n @param float[] $numbers\n @param int    $k zero indexed - must be less than n (count of $numbers)\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n @throws Exception\\OutOfBoundsException if k ≥ n\n",Vraća k-tu najmanju vrednost u nizu. Koristi algoritam linearne složenosti O(n) u najgorem slučaju.,"public static function kthSmallest(array $numbers, int $k): float    {        $n = \count($numbers);        if ($n === 0) {            throw new Exception\BadDataException('Cannot find the k-th smallest of an empty list of numbers');        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException('k cannot be greater than or equal to the count of numbers');        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // If the array is 5 elements or smaller, use quicksort and return the element of interest.        if ($n <= 5) {            \sort($numbers);            return $numbers[$k];        }        // Otherwise, we are going to slice $numbers into 5-element slices and find the median of each.        $num_slices = \ceil($n / 5);        $median_array = [];        for ($i = 0; $i < $num_slices; $i++) {            $median_array[] = self::median(\array_slice($numbers, 5 * $i, 5));        }        // Then we find the median of the medians.        $median_of_medians = self::median($median_array);        // Next we walk the array and separate it into values that are greater than or less than this ""median of medians"".        $lower_upper   = self::splitAtValue($numbers, $median_of_medians);        $lower_number = \count($lower_upper['lower']);        $equal_number = $lower_upper['equal'];        // Lastly, we find which group of values our value of interest is in, and find it in the smaller array.        if ($k < $lower_number) {            return self::kthSmallest($lower_upper['lower'], $k);        } elseif ($k < ($lower_number + $equal_number)) {            return $median_of_medians;        } else {            return self::kthSmallest($lower_upper['upper'], $k - $lower_number - $equal_number);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
150,markrogoyski_math-php_Average_3443, Geometric mean\n A type of mean which indicates the central tendency or typical value of a set of numbers\n by using the product of their values (as opposed to the arithmetic mean which uses their sum).\n https://en.wikipedia.org/wiki/Geometric_mean\n                    __________\n Geometric mean = ⁿ√a₀a₁a₂ ⋯\n\n @param  float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n,Geometrijska sredina. Tip sredine koji ukazuje centralnu naklonost ili tipičnu vrednost skipa brojeva koristeći proizvod njihovih vrednosti. (Za razliku od aritmetičke sredine koja koristi njihovu sumu).,"public static function geometricMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the geometric mean of an empty list of numbers');        }        $n       = \count($numbers);        $a₀a₁a₂⋯ = \array_reduce(            $numbers,            function ($carry, $a) {                return $carry * $a;            },            1        );        $ⁿ√a₀a₁a₂⋯ = \pow($a₀a₁a₂⋯, 1 / $n);        return $ⁿ√a₀a₁a₂⋯;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
151,markrogoyski_math-php_Average_3465," Get a report of all the averages over a list of numbers\\n Includes mean, median mode, geometric mean, harmonic mean, quardratic mean\\n\\n @param array $numbers\\n\\n @return array [ mean, median, mode, geometric_mean, harmonic_mean,\\n                 contraharmonic_mean, quadratic_mean, trimean, iqm, cubic_mean ]\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\OutOfBoundsException\\n","Napravi izveštaj za sve proseke liste brojeva. Uključuje srednju vrednost, harmonijsku sredinu, kvadratnu sredinu, kontraharmonijsku sredinu, trimijansku sredinu i inverznu kvadratnu sredinu.","    public static function describe(array $numbers): array    {        return [            'mean'                => self::mean($numbers),            'median'              => self::median($numbers),            'mode'                => self::mode($numbers),            'geometric_mean'      => self::geometricMean($numbers),            'harmonic_mean'       => self::harmonicMean($numbers),            'contraharmonic_mean' => self::contraharmonicMean($numbers),            'quadratic_mean'      => self::quadraticMean($numbers),            'trimean'             => self::trimean($numbers),            'iqm'                 => self::iqm($numbers),            'cubic_mean'          => self::cubicMean($numbers),        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
152,markrogoyski_math-php_Basic_3391,"Digit sum (sum of digits)\n https://en.wikipedia.org/wiki/Digit_sum\n https://oeis.org/A007953\n\n Example\n  n = 11\n  Sequence:    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1\n  Array index: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1\n\n @param  int $n How many numbers in the sequence\n\n @return array Indexed from 0 (indexes are the n in the digitSum(n))\n",Suma cifara.,public static function digitSum(int $n): array    {        if ($n <= 0) {            return [];        }        $digit_sums = [];        for ($i = 0; $i < $n; $i++) {            $digit_sums[] = Arithmetic::digitSum($i);        }        return $digit_sums;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
153,markrogoyski_math-php_Bernoulli_3208, Bernoulli distribution\\n\\n https://en.wikipedia.org/wiki/Bernoulli_distribution\\n,Bernulijeva raspodela.,"class Bernoulli extends Discrete{    /**     * Distribution parameter bounds limits     * p ∈ (0,1)     * @var array     */    public const PARAMETER_LIMITS = [        'p' => '(0,1)',        'q' => '[0,1)',    ];    /**     * Distribution support bounds limits     * k ∈ [0,1]     * p ∈ (0,1)     * @var array     */    public const SUPPORT_LIMITS = [        'k' => '[0,1]',    ];    /** @var float probability of success */    protected $p;    /** @var float */    protected $q;    /**     * Constructor     *     * @param float $p success probability  0 < p < 1     */    public function __construct(float $p)    {        $q = 1 - $p;        parent::__construct($p, $q);    }    /**     * Probability mass function     *     * q = (1 - p)  for k = 0     * p            for k = 1     *     * @param  int $k number of successes  k ∈ {0, 1}     *     * @return float     */    public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        if ($k === 0) {            return $this->q;        } else {            return $this->p;        }    }    /**     * Cumulative distribution function     *     * 0      for k < 0     * 1 - p  for 0 ≤ k < 1     * 1      for k ≥ 1     *     * @param  int $k number of successes  k ∈ {0, 1}     *     * @return float     */    public function cdf(int $k): float    {        if ($k < 0) {            return 0;        }        if ($k < 1) {            return 1 - $this->p;        }        return 1;    }    /**     * Mean of the distribution     *     * μ = p     *     * @return float     */    public function mean(): float    {        return $this->p;    }    /**     * Median of the distribution     *     * 0    for p < ½     * ½    for p = ½     * 1    for p > ½     *     * @return float     */    public function median(): float    {        $p = $this->p;        $½ = 0.5;        if ($p < $½) {            return 0;        }        if ($p == $½) {            return $½;        }        return 1;    }    /**     * Mode of the distribution     *     * 0    for p < ½     * 0,1  for p = ½     * 1    for p > ½     *     * @return float[]     */    public function mode(): array    {        $p = $this->p;        $½ = 0.5;        if ($p < $½) {            return [0];        }        if ($p == $½) {            return [0, 1];        }        return [1];    }    /**     * Variance of the distribution     *     * σ² = p(1 - p) = pq     *     * @return float     */    public function variance(): float    {        return $this->p * $this->q;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
154,markrogoyski_math-php_Bernoulli_3210,"Probability mass function\\n\\n q = (1 - p)  for k = 0\\n p            for k = 1\\n\\n @param  int $k number of successes  k ∈ {0, 1}\\n\\n @return float\\n",Gustina verovatnoće,"public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        if ($k === 0) {            return $this->q;        } else {            return $this->p;        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
155,markrogoyski_math-php_Bernoulli_3211,"Cumulative distribution function\n\n 0      for k < 0\n 1 - p  for 0 ≤ k < 1\n 1      for k ≥ 1\n\n @param  int $k number of successes  k ∈ {0, 1}\n\n @return float\n",Kumulativna raspodela,public function cdf(int $k): float    {        if ($k < 0) {            return 0;        }        if ($k < 1) {            return 1 - $this->p;        }        return 1;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
156,markrogoyski_math-php_Bernoulli_3212, Mean of the distribution\n\n μ = p\n\n @return float\n,Srednja vrednost raspodele.,    public function mean(): float    {        return $this->p;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
157,markrogoyski_math-php_Bernoulli_3213,Median of the distribution\n\n 0    for p < ½\n ½    for p = ½\n 1    for p > ½\n\n @return float\n,Medijana raspodele.,public function median(): float    {        $p = $this->p;        $½ = 0.5;        if ($p < $½) {            return 0;        }        if ($p == $½) {            return $½;        }        return 1;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
158,markrogoyski_math-php_Binomial_3216, Binomial distribution - probability mass function\\n\\n https://en.wikipedia.org/wiki/Binomial_distribution\\n,Binomijalna raspodela - funkcija gustine verovatnoće,"class Binomial extends Discrete{    /**     * Distribution parameter bounds limits     * n ∈ [0,∞)     * p ∈ [0,1]     * @var array     */    public const PARAMETER_LIMITS = [        'n' => '[0,∞)',        'p' => '[0,1]',    ];    /**     * Distribution support bounds limits     * r ∈ [0,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'r' => '[0,∞)',    ];    /** @var int number of events */    protected $n;    /** @var float probability of success */    protected $p;    /**     * Constructor     *     * @param int   $n number of events n >= 0     * @param float $p probability of success 0 <= p <= 1     */    public function __construct(int $n, float $p)    {        parent::__construct($n, $p);    }    /**     * Probability mass function     *     * P(X = r) = nCr pʳ (1 - p)ⁿ⁻ʳ     *     * If n is large, combinatorial factorial blows up,     * so use the multiplication method instead.     *     * @param  int $r number of successful events     *     * @return float     */    public function pmf(int $r): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['r' => $r]);        return $this->n < 150            ? $this->combinatorialMethod($r)            : $this->multiplicationMethod($r, $this->n, $this->p);    }    /**     * PMF combinatorial method     *     * P(X = r) = nCr pʳ (1 - p)ⁿ⁻ʳ     *     * @param int $r number of successful events     *     * @return float     *     * @throws \MathPHP\Exception\OutOfBoundsException     */    private function combinatorialMethod(int $r): float    {        $n = $this->n;        $p = $this->p;        $nCr       = Combinatorics::combinations($n, $r);        $pʳ        = \pow($p, $r);        $⟮1 − p⟯ⁿ⁻ʳ = \pow(1 - $p, $n - $r);        return $nCr * $pʳ * $⟮1 − p⟯ⁿ⁻ʳ;    }    /**     * PMF multiplication method     *     * Evaluate binomial probabilities using a method that avoids unnecessary overflow and underflow     * Catherine Loader: http://octave.1599824.n4.nabble.com/attachment/3829107/0/loader2000Fast.pdf     *     *               x             x   n-x     *              __  n - x + i __   __     * p(x; n, p) = ||  --------- || p ||  (1 - p)     *              ⁱ⁼¹     i     ⁱ⁼¹  ⁱ⁼¹     *     * @param int   $r number of successful events     * @param int   $n number of events     * @param float $p probability of success     *     * @return float     */    private function multiplicationMethod(int $r, int $n, float $p): float    {        if (2 * $r > $n) {            return $this->multiplicationMethod($n - $r, $n, 1 - $p);        }        [$j₀, $j₁, $j₂] = [0, 0, 0];        $f = 1;        while (($j₀ < $r) | ($j₁ < $r) | ($j₂ < $n - $r)) {            if (($j₀ < $r) && ($f < 1)) {                $j₀++;                $f *= ($n - $r + $j₀) / $j₀;            } elseif ($j₁ < $r) {                $j₁++;                $f *= $p;            } else {                $j₂++;                $f *= 1 - $p;            }        }        return $f;    }    /**     * Cumulative distribution function     * Computes and sums the binomial distribution at each of the values in r.     *     * @param  int $r number of successful events     *     * @return float     */    public function cdf(int $r): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['r' => $r]);        $cdf = 0;        for ($i = $r; $i >= 0; $i--) {            $cdf += $this->pmf($i);        }        return $cdf;    }    /**     * Mean of the distribution     *     * μ = np     *     * @return float     */    public function mean(): float    {        return $this->n * $this->p;    }    /**     * Variance of the distribution     *     * σ² = np(1 - p)     *     * @return float     */    public function variance(): float    {        $n = $this->n;        $p = $this->p;        return $n * $p * (1 - $p);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
159,markrogoyski_math-php_Binomial_3222, Mean of the distribution\\n\\n μ = np\\n\\n @return float\\n,Srednja vrednost raspodele.,    public function mean(): float    {        return $this->n * $this->p;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
160,markrogoyski_math-php_Binomial_3223,Variance of the distribution\\n\\n σ² = np(1 - p)\\n\\n @return float\\n,Varijansa raspodele.,public function variance(): float    {        $n = $this->n;        $p = $this->p;        return $n * $p * (1 - $p);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
161,markrogoyski_math-php_Cauchy_3065, Cauchy distribution\n https://en.wikipedia.org/wiki/Cauchy_distribution\n,Košijeva raspodela.,"class Cauchy extends Continuous{    /**     * Distribution parameter bounds limits     * x₀ ∈ (-∞,∞)     * γ  ∈ (0,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'x₀' => '(-∞,∞)',        'γ'  => '(0,∞)',    ];    /**     * Distribution support bounds limits     * x  ∈ (-∞,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x'  => '(-∞,∞)',    ];    /** @var number Location Parameter */    protected $x₀;    /** @var number Scale Parameter */    protected $γ;    /**     * Constructor     *     * @param float $x₀ location parameter     * @param float $γ  scale parameter γ > 0     */    public function __construct(float $x₀, float $γ)    {        parent::__construct($x₀, $γ);    }    /**     * Probability density function     *     *                1     *    --------------------------     *       ┌        / x - x₀ \ ² ┐     *    πγ | 1  +  | ---------|  |     *       └        \    γ   /   ┘     *     * @param float $x     *     * @return float     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π  = \M_PI;        return 1 / ($π * $γ * (1 + (($x - $x₀) / $γ) ** 2));    }    /**     * Cumulative distribution function     * Calculate the cumulative value value up to a point, left tail.     *     * @param float $x     *     * @return float     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π  = \M_PI;        return 1 / $π * \atan(($x - $x₀) / $γ) + .5;    }    /**     * Inverse CDF (Quantile function)     *     * Q(p;x₀,γ) = x₀ + γ tan[π(p - ½)]     *     * @param float $p     *     * @return float     */    public function inverse(float $p): float    {        Support::checkLimits(['p' => '[0,1]'], ['p' => $p]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π = \M_PI;        return $x₀ + $γ * \tan($π * ($p - .5));    }    /**     * Mean of the distribution (undefined)     *     * μ is undefined     *     * @return float \NAN     */    public function mean(): float    {        return \NAN;    }    /**     * Median of the distribution     *     * @return float x₀     */    public function median(): float    {        return $this->x₀;    }    /**     * Mode of the distribution     *     * @return float x₀     */    public function mode(): float    {        return $this->x₀;    }    /**     * Variance of the distribution (undefined)     *     * @return float     */    public function variance(): float    {        return \NAN;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
162,markrogoyski_math-php_Cauchy_3068," Cumulative distribution function\\n Calculate the cumulative value value up to a point, left tail.\\n\\n @param float $x\\n\\n @return float\\n",Kumulativna raspodela,"public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π  = \M_PI;        return 1 / $π * \atan(($x - $x₀) / $γ) + .5;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
163,markrogoyski_math-php_Combinatorics_3047,Factorial (iterative)\n Represents the number of ways to arrange n things (permutations)\n n! = n(n - 1)(n - 2) ・・・ (n - (n - 1))\n\n @param  int $n\n\n @return float number of permutations of n\n\n @throws Exception\\OutOfBoundsException if n < 0\n,Faktorijel. Predstavlja broj načina da se n stvari rasporedi. n!=n(n-1)(n-2)…(n-(n-1)),public static function factorial(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute factorial of a negative number.');        }        $factorial = 1;        while ($n > 1) {            $factorial *= $n;            --$n;        }        return $factorial;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
164,markrogoyski_math-php_ComplexMatrix_2609, Validate the matrix is entirely complex\n\n @throws Exception\\IncorrectTypeException if all elements are not complex\n,Potvrdi da li je matrica u potpunosti kompleksna.,"    protected function validateComplexData(array $A)    {        foreach ($A as $i => $row) {            foreach ($row as $object) {                if (!$object instanceof Complex) {                    throw new Exception\IncorrectTypeException(""All elements in the complex matrix must be complex. Got "" . \get_class($object));                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
165,markrogoyski_math-php_Complex_2917,"Complex Numbers\\n\\n A complex number is a number that can be expressed in the form a + bi,\\n where a and b are real numbers and i is the imaginary unit, satisfying the\\n equation i² = −1. In this expression, a is the real part and b is the imaginary\\n part of the complex number.\\n https://en.wikipedia.org/wiki/Complex_number\\n\\n @property-read number $r\\n @property-read number $i\\n","Kompleksni brojevi. Kompleksni broj je onaj broj koji se može izraziti u formi a + bi gde su a i b realni brojevi, a i je imaginarna jedinica koja zadovoljava jednakost i^2=-1. U ovom izrazu, a je realni deo, a b je imaginarni deo kompleksnog broja.","class Complex implements ObjectArithmetic{    /**     * Real part of the complex number     * @var number     */    protected $r;    /**     * Imaginary part fo the complex number     * @var number     */    protected $i;    /**     * Floating-point range near zero to consider insignificant.     */    private const EPSILON = 1e-6;    /**     * Constructor     *     * @param number $r Real part     * @param number $i Imaginary part     */    public function __construct($r, $i)    {        $this->r = $r;        $this->i = $i;    }    /**     * Creates 0 + 0i     *     * @return Complex     */    public static function createZeroValue(): ObjectArithmetic    {        return new Complex(0, 0);    }    /**     * String representation of a complex number     * a + bi, a - bi, etc.     *     * @return string     */    public function __toString(): string    {        if ($this->r == 0 & $this->i == 0) {            return '0';        } elseif ($this->r == 0) {            return ""$this->i"" . 'i';        } elseif ($this->i == 0) {            return ""$this->r"";        } elseif ($this->i > 0) {            return ""$this->r"" . ' + ' . ""$this->i"" . 'i';        } else {            return ""$this->r"" . ' - ' . (string) \abs($this->i) . 'i';        }    }    /**     * Get r or i     *     * @param string $part     *     * @return number     *     * @throws Exception\BadParameterException if something other than r or i is attempted     */    public function __get(string $part)    {        switch ($part) {            case 'r':            case 'i':                return $this->$part;            default:                throw new Exception\BadParameterException(""The $part property does not exist in Complex number"");        }    }    /**************************************************************************     * UNARY FUNCTIONS     **************************************************************************/    /**     * The conjugate of a complex number     *     * https://en.wikipedia.org/wiki/Complex_number#Conjugate     *     * @return Complex     */    public function complexConjugate(): Complex    {        return new Complex($this->r, -1 * $this->i);    }    /**     * The absolute value (magnitude) of a complex number (modulus)     * https://en.wikipedia.org/wiki/Complex_number#Absolute_value_and_argument     *     * If z = a + bi     *        _______     * |z| = √a² + b²     *     * @return number     */    public function abs()    {        return \sqrt($this->r ** 2 + $this->i ** 2);    }    /**     * The argument (phase) of a complex number     * The argument of z is the angle of the radius OP with the positive real axis, and is written as arg(z).     * https://en.wikipedia.org/wiki/Complex_number#Absolute_value_and_argument     *     * If z = a + bi     * arg(z) = atan(b, a)     *     * @return number     */    public function arg()    {        return \atan2($this->i, $this->r);    }    /**     * The square root of a complex number     * https://en.wikipedia.org/wiki/Complex_number#Square_root     *     * The roots of a + bi (with b ≠ 0) are ±(γ + δi), where     *     *         ____________     *        /     _______     *       / a + √a² + b²     * γ =  /  ------------     *     √         2     *     *               ____________     *              /      _______     *             / -a + √a² + b²     * δ = sgn(b) /  -------------     *           √         2     *     * The square root returns the positive root.     *     * @return Complex (positive root)     */    public function sqrt(): Complex    {        return $this->roots()[0];    }    /**     * The roots of a complex number     * https://en.wikipedia.org/wiki/Complex_number#Square_root     *     * The roots of a + bi (with b ≠ 0) are ±(γ + δi), where     *     *         ____________     *        /     _______     *       / a + √a² + b²     * γ =  /  ------------     *     √         2     *     *               ____________     *              /      _______     *             / -a + √a² + b²     * δ = sgn(b) /  -------------     *           √         2     *     *     * @return array Complex[] (two roots)     */    public function roots(): array    {        $sgn = Special::sgn($this->i) >= 0 ? 1 : -1;        $γ   = \sqrt(($this->r + $this->abs()) / 2);        $δ   = $sgn * \sqrt((-$this->r + $this->abs()) / 2);        $z₁ = new Complex($γ, $δ);        $z₂ = new Complex(-$γ, -$δ);        return [$z₁, $z₂];    }    /**     * The inverse of a complex number (reciprocal)     *     * https://en.wikipedia.org/wiki/Complex_number#Reciprocal     *     * @return Complex     *     * @throws Exception\BadDataException if = to 0 + 0i     */    public function inverse(): Complex    {        if ($this->r == 0 && $this->i == 0) {            throw new Exception\BadDataException('Cannot take inverse of 0 + 0i');        }        return $this->complexConjugate()->divide($this->abs() ** 2);    }    /**     * Negate the complex number     * Switches the signs of both the real and imaginary parts.     *     * @return Complex     */    public function negate(): Complex    {        return new Complex(-$this->r, -$this->i);    }    /**     * Polar form     * https://en.wikipedia.org/wiki/Complex_number#Polar_form     *     * z = a + bi = r(cos(θ) + i  sin(θ))     * Where     *  r = |z|     *  θ = arg(z) (in radians)     *     * @return Complex     */    public function polarForm(): Complex    {        $r = $this->abs();        $θ = $this->arg();        return new Complex($r * \cos($θ), $r * \sin($θ));    }    /**************************************************************************     * BINARY FUNCTIONS     **************************************************************************/    /**     * Complex addition     * https://en.wikipedia.org/wiki/Complex_number#Addition_and_subtraction     *     * (a + bi) + (c + di) = (a + c) + (b + d)i     *     * @param mixed $c     *     * @return Complex     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Complex.     */    public function add($c): Complex    {        if (\is_numeric($c)) {            $r = $this->r + $c;            $i = $this->i;        } elseif ($c instanceof Complex) {            $r = $this->r + $c->r;            $i = $this->i + $c->i;        } else {            throw new Exception\IncorrectTypeException('Argument must be real or complex number');        }        return new Complex($r, $i);    }    /**     * Complex subtraction     * https://en.wikipedia.org/wiki/Complex_number#Addition_and_subtraction     *     * (a + bi) - (c + di) = (a - c) + (b - d)i     *     * @param mixed $c     *     * @return Complex     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Complex.     */    public function subtract($c): Complex    {        if (\is_numeric($c)) {            $r = $this->r - $c;            $i = $this->i;        } elseif ($c instanceof Complex) {            $r = $this->r - $c->r;            $i = $this->i - $c->i;        } else {            throw new Exception\IncorrectTypeException('Argument must be real or complex number');        }        return new Complex($r, $i);    }    /**     * Complex multiplication     * https://en.wikipedia.org/wiki/Complex_number#Multiplication_and_division     *     * (a + bi)(c + di) = (ac - bd) + (bc + ad)i     *     * @param mixed $c     *     * @return Complex     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Complex.     */    public function multiply($c): Complex    {        if (\is_numeric($c)) {            $r = $c * $this->r;            $i = $c * $this->i;        } elseif ($c instanceof Complex) {            $r = $this->r * $c->r - $this->i * $c->i;            $i = $this->i * $c->r + $this->r * $c->i;        } else {            throw new Exception\IncorrectTypeException('Argument must be real or complex number');        }        return new Complex($r, $i);    }    /**     * Complex division     * Dividing two complex numbers is accomplished by multiplying the first by the inverse of the second     * https://en.wikipedia.org/wiki/Complex_number#Multiplication_and_division     *     * @param mixed $c     *     * @return Complex     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Complex.     */    public function divide($c): Complex    {        if (\is_numeric($c)) {            $r = $this->r / $c;            $i = $this->i / $c;            return new Complex($r, $i);        } elseif ($c instanceof Complex) {            return $this->multiply($c->inverse());        } else {            throw new Exception\IncorrectTypeException('Argument must be real or complex number');        }    }    /**************************************************************************     * COMPARISON FUNCTIONS     **************************************************************************/    /**     * Test for equality     * Two complex numbers are equal if and only if both their real and imaginary parts are equal.     *     * https://en.wikipedia.org/wiki/Complex_number#Equality     *     * @param Complex $c     *     * @return bool     */    public function equals(Complex $c): bool    {        return \abs($this->r - $c->r) < self::EPSILON && \abs($this->i - $c->i) < self::EPSILON;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
166,markrogoyski_math-php_Complex_2923, The absolute value (magnitude) of a complex number (modulus)\\n https://en.wikipedia.org/wiki/Complex_number#Absolute_value_and_argument\\n\\n If z = a + bi\\n        _______\\n |z| = √a² + b²\\n\\n @return number\\n,Apsolutna vrednost (magnituda) kompleksnog broja (moduo).,public function abs()    {        return \sqrt($this->r ** 2 + $this->i ** 2);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
167,markrogoyski_math-php_Complex_2925,"The square root of a complex number\n https://en.wikipedia.org/wiki/Complex_number#Square_root\n\n The roots of a + bi (with b ≠ 0) are ±(γ + δi), where\n\n         ____________\n        /     _______\n       / a + √a² + b²\n γ =  /  ------------\n     √         2\n\n               ____________\n              /      _______\n             / -a + √a² + b²\n δ = sgn(b) /  -------------\n           √         2\n\n The square root returns the positive root.\n\n @return Complex (positive root)\n",Kvadratni koren kompleksnog broja.,public function sqrt(): Complex    {        return $this->roots()[0];    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
168,markrogoyski_math-php_Complex_2928, Negate the complex number\n Switches the signs of both the real and imaginary parts.\n\n @return Complex\n,Negacija kompleksnog broja. Menja znakove i realnog i imaginarnog dela.,"    public function negate(): Complex    {        return new Complex(-$this->r, -$this->i);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
169,markrogoyski_math-php_Complex_2934, Test for equality\n Two complex numbers are equal if and only if both their real and imaginary parts are equal.\n\n https://en.wikipedia.org/wiki/Complex_number#Equality\n\n @param Complex $c\n\n @return bool\n,Proverava jednakost. Dva kompleksna broja su jednaka ako i samo ako su njihovi i realni i imaginarni delovi jednaki.,    public function equals(Complex $c): bool    {        return \abs($this->r - $c->r) < self::EPSILON && \abs($this->i - $c->i) < self::EPSILON;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
170,markrogoyski_math-php_Correlation_3473, Statistical correlation\n  - covariance\n  - correlation coefficient (r)\n  - coefficient of determination (R²)\n  - Kendall's tau (τ)\n  - Spearman's rho (ρ)\n  - confidence ellipse\n,Statistička korelacija - kovarijansa - korelacioni koeficijent - koeficijent odlučnosti - Kendalovo Tau - Spirmanovo rho - elipsa sigurnosti.,"class Correlation{    private const X = 0;    private const Y = 1;    /**     * Covariance     * Convenience method to access population and sample covariance.     *     * A measure of how much two random variables change together.     * Average product of their deviations from their respective means.     * The population covariance is defined in terms of the sample means x, y     * https://en.wikipedia.org/wiki/Covariance     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param bool $population Optional flag for population or sample covariance     *     * @return float     *     * @throws Exception\BadDataException     */    public static function covariance(array $X, array $Y, bool $population = false): float    {        return $population            ? self::populationCovariance($X, $Y)            : self::sampleCovariance($X, $Y);    }    /**     * Population Covariance     * A measure of how much two random variables change together.     * Average product of their deviations from their respective means.     * The population covariance is defined in terms of the population means μx, μy     * https://en.wikipedia.org/wiki/Covariance     *     * cov(X, Y) = σxy = E[⟮X - μx⟯⟮Y - μy⟯]     *     *                   ∑⟮xᵢ - μₓ⟯⟮yᵢ - μy⟯     * cov(X, Y) = σxy = -----------------     *                           N     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException if X and Y do not have the same number of elements     */    public static function populationCovariance(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('X and Y must have the same number of elements.');        }        $μₓ = Average::mean($X);        $μy = Average::mean($Y);        $∑⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ = \array_sum(\array_map(            function ($xᵢ, $yᵢ) use ($μₓ, $μy) {                return ( $xᵢ - $μₓ ) * ( $yᵢ - $μy );            },            $X,            $Y        ));        $N = \count($X);        return $∑⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ / $N;    }    /**     * Sample covariance     * A measure of how much two random variables change together.     * Average product of their deviations from their respective means.     * The population covariance is defined in terms of the sample means x, y     * https://en.wikipedia.org/wiki/Covariance     *     * cov(X, Y) = Sxy = E[⟮X - x⟯⟮Y - y⟯]     *     *                   ∑⟮xᵢ - x⟯⟮yᵢ - y⟯     * cov(X, Y) = Sxy = ---------------     *                         n - 1     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException if X and Y do not have the same number of elements     */    public static function sampleCovariance(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('X and Y must have the same number of elements.');        }        $x = Average::mean($X);        $y = Average::mean($Y);        $∑⟮xᵢ − x⟯⟮yᵢ − y⟯ = \array_sum(\array_map(            function ($xᵢ, $yᵢ) use ($x, $y) {                return ( $xᵢ - $x ) * ( $yᵢ - $y );            },            $X,            $Y        ));        $n = \count($X);        return $∑⟮xᵢ − x⟯⟮yᵢ − y⟯ / ($n - 1);    }    /**     * Weighted covariance     * A measure of how much two random variables change together with weights.     * https://en.wikipedia.org/wiki/Pearson_correlation_coefficient#Weighted_correlation_coefficient     *     *                       ∑wᵢ⟮xᵢ - μₓ⟯⟮yᵢ - μy⟯     * cov(X, Y, w) = sxyw = --------------------     *                              ∑wᵢ     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param array $w values for weights     *     * @return float     *     * @throws Exception\BadDataException if X and Y do not have the same number of elements     */    public static function weightedCovariance(array $X, array $Y, array $w): float    {        if (\count($X) !== \count($Y) || \count($X) !== \count($w)) {            throw new Exception\BadDataException('X, Y and w must have the same number of elements.');        }        $μₓ = Average::weightedMean($X, $w);        $μy = Average::weightedMean($Y, $w);        $∑wᵢ⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ = \array_sum(\array_map(            function ($xᵢ, $yᵢ, $wᵢ) use ($μₓ, $μy) {                return $wᵢ * ( $xᵢ - $μₓ ) * ( $yᵢ - $μy );            },            $X,            $Y,            $w        ));        $∑wᵢ = \array_sum($w);        return $∑wᵢ⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ / $∑wᵢ;    }    /**     * r - correlation coefficient     * Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r)     *     * Convenience method for population and sample correlationCoefficient     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param bool $population Optional flag for population or sample covariance     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function r(array $X, array $Y, bool $population = false): float    {        return $population            ? self::populationCorrelationCoefficient($X, $Y)            : self::sampleCorrelationCoefficient($X, $Y);    }    /**     * Population correlation coefficient     * Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r)     *     * A normalized measure of the linear correlation between two variables X and Y,     * giving a value between +1 and −1 inclusive, where 1 is total positive correlation,     * 0 is no correlation, and −1 is total negative correlation.     * It is widely used in the sciences as a measure of the degree of linear dependence     * between two variables.     * https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient     *     * The correlation coefficient of two variables in a data sample is their covariance     * divided by the product of their individual standard deviations.     *     *        cov(X,Y)     * ρxy = ----------     *         σx σy     *     *  conv(X,Y) is the population covariance     *  σx is the population standard deviation of X     *  σy is the population standard deviation of Y     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function populationCorrelationCoefficient(array $X, array $Y): float    {        $cov⟮X，Y⟯ = self::populationCovariance($X, $Y);        $σx      = Descriptive::standardDeviation($X, true);        $σy      = Descriptive::standardDeviation($Y, true);        return $cov⟮X，Y⟯ / ( $σx * $σy );    }    /**     * Sample correlation coefficient     * Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r)     *     * A normalized measure of the linear correlation between two variables X and Y,     * giving a value between +1 and −1 inclusive, where 1 is total positive correlation,     * 0 is no correlation, and −1 is total negative correlation.     * It is widely used in the sciences as a measure of the degree of linear dependence     * between two variables.     * https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient     *     * The correlation coefficient of two variables in a data sample is their covariance     * divided by the product of their individual standard deviations.     *     *          Sxy     * rxy = ----------     *         sx sy     *     *  Sxy is the sample covariance     *  σx is the sample standard deviation of X     *  σy is the sample standard deviation of Y     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function sampleCorrelationCoefficient(array $X, array $Y): float    {        $Sxy = self::sampleCovariance($X, $Y);        $sx  = Descriptive::standardDeviation($X, Descriptive::SAMPLE);        $sy  = Descriptive::standardDeviation($Y, Descriptive::SAMPLE);        return $Sxy / ( $sx * $sy );    }    /**     * R² - coefficient of determination     * Convenience wrapper for coefficientOfDetermination     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param bool $popluation     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function r2(array $X, array $Y, bool $popluation = false): float    {        return \pow(self::r($X, $Y, $popluation), 2);    }    /**     * R² - coefficient of determination     *     * Indicates the proportion of the variance in the dependent variable     * that is predictable from the independent variable.     * Range of 0 - 1. Close to 1 means the regression line is a good fit     * https://en.wikipedia.org/wiki/Coefficient_of_determination     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param bool $popluation     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function coefficientOfDetermination(array $X, array $Y, bool $popluation = false): float    {        return \pow(self::r($X, $Y, $popluation), 2);    }    /**     * Weighted correlation coefficient     * Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r) width weighted values     *     * A normalized measure of the linear correlation between two variables X and Y,     * giving a value between +1 and −1 inclusive, where 1 is total positive correlation,     * 0 is no correlation, and −1 is total negative correlation.     * It is widely used in the sciences as a measure of the degree of linear dependence between two variables.     * https://en.wikipedia.org/wiki/Pearson_correlation_coefficient#Weighted_correlation_coefficient     *     * The weighted correlation coefficient of two variables in a data sample is their covariance     * divided by the product of their individual standard deviations.     *     *          cov(X,Y,w)     * ρxyw = -------------     *          √(sxw syw)     *     *  conv(X,Y, w) is the weighted covariance     *  sxw is the weighted variance of X     *  syw is the weighted variance of Y     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param array $w values for weights     *     * @return float     *     * @throws Exception\BadDataException     */    public static function weightedCorrelationCoefficient(array $X, array $Y, array $w): float    {        $cov⟮X，Y，w⟯ = self::weightedCovariance($X, $Y, $w);        $sxw         = Descriptive::weightedSampleVariance($X, $w, true);        $syw         = Descriptive::weightedSampleVariance($Y, $w, true);        return $cov⟮X，Y，w⟯ / \sqrt($sxw * $syw);    }    /**     * τ - Kendall rank correlation coefficient (Kendall's tau)     *     * A statistic used to measure the ordinal association between two     * measured quantities. It is a measure of rank correlation:     * the similarity of the orderings of the data when ranked by each     * of the quantities.     * https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient     * https://onlinecourses.science.psu.edu/stat509/node/158     *     * tau-a (no rank ties):     *     *        nc - nd     *   τ = ----------     *       n(n - 1)/2     *     *   Where     *     nc: number of concordant pairs     *     nd: number of discordant pairs     *     * tau-b (rank ties exist):     *     *                 nc - nd     *   τ = -----------------------------     *       √(nc + nd + X₀)(nc + nd + Y₀)     *     *   Where     *     X₀: number of pairs tied only on the X variable     *     Y₀: number of pairs tied only on the Y variable     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @todo Implement with algorithm faster than O(n²)     *     * @return float     *     * @throws Exception\BadDataException if both random variables do not have the same number of elements     */    public static function kendallsTau(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('Both random variables must have the same number of elements');        }        $n = \count($X);        // Match X and Y pairs and sort by X rank        $xy = \array_map(            function ($x, $y) {                return [$x, $y];            },            $X,            $Y        );        \usort($xy, function ($a, $b) {            return $a[0] <=> $b[0];        });        // Initialize counters        $nc      = 0;  // concordant pairs        $nd      = 0;  // discordant pairs        $ties_x  = 0;  // ties xᵢ = xⱼ        $ties_y  = 0;  // ties yᵢ = yⱼ        $ties_xy = 0;  // ties xᵢ = xⱼ and yᵢ = yⱼ        // Tally concordant, discordant, and tied pairs        for ($i = 0; $i < $n; $i++) {            for ($j = $i + 1; $j < $n; $j++) {                // xᵢ = xⱼ and yᵢ = yⱼ -- neither concordant or discordant                if ($xy[$i][self::X] == $xy[$j][self::X] && $xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_xy++;                // xᵢ = xⱼ -- neither concordant or discordant                } elseif ($xy[$i][self::X] == $xy[$j][self::X]) {                    $ties_x++;                // yᵢ = yⱼ -- neither concordant or discordant                } elseif ($xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_y++;                // xᵢ < xⱼ and yᵢ < yⱼ -- concordant                } elseif ($xy[$i][self::X] < $xy[$j][self::X] && $xy[$i][self::Y] < $xy[$j][self::Y]) {                    $nc++;                // xᵢ > xⱼ and yᵢ < yⱼ or  xᵢ < xⱼ and yᵢ > yⱼ -- discordant                } else {                    $nd++;                }            }        }        // Numerator: (number of concordant pairs) - (number of discordant pairs)        $⟮nc − nd⟯ = $nc - $nd;        /* tau-a (no rank ties):         *         *        nc - nd         *   τ = ----------         *       n(n - 1)/2         */        if ($ties_x == 0 && $ties_y == 0) {            return $⟮nc − nd⟯ / (($n * ($n - 1)) / 2);        }        /* tau-b (rank ties exist):         *         *                 nc - nd         *   τ = -----------------------------         *       √(nc + nd + X₀)(nc + nd + Y₀)         */        return $⟮nc − nd⟯ / \sqrt(($nc + $nd + $ties_x) * ($nc + $nd + $ties_y));    }    /**     * ρ - Spearman's rank correlation coefficient (Spearman's rho)     *     * https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient     *     *     cov(rgᵪ, rgᵧ)     * ρ = ------------     *        σᵣᵪσᵣᵧ     *     *   Where     *    cov(rgᵪ, rgᵧ): covariance of the rank variables     *    σᵣᵪ and σᵣᵧ:   standard deviations of the rank variables     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException if both random variables do not have the same number of elements     * @throws Exception\OutOfBoundsException if one of the random variables is empty     */    public static function spearmansRho(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('Both random variables for spearmansRho must have the same number of elements');        }        $rgᵪ         = Distribution::fractionalRanking($X);        $rgᵧ         = Distribution::fractionalRanking($Y);        $cov⟮rgᵪ、rgᵧ⟯ = Correlation::covariance($rgᵪ, $rgᵧ);        $σᵣᵪ         = Descriptive::sd($rgᵪ);        $σᵣᵧ         = Descriptive::sd($rgᵧ);        return $cov⟮rgᵪ、rgᵧ⟯  / ($σᵣᵪ * $σᵣᵧ);    }    /**     * Descriptive correlation report about two random variables     *     * @param  array $X values for random variable X     * @param  array $Y values for random variable Y     * @param  bool $population Optional flag if all samples of a population are present     *     * @return array [cov, r, R2, tau, rho]     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function describe(array $X, array $Y, bool $population = false): array    {        return [            'cov' => self::covariance($X, $Y, $population),            'r'   => self::r($X, $Y, $population),            'r2'  => self::r2($X, $Y, $population),            'tau' => self::kendallsTau($X, $Y),            'rho' => self::spearmansRho($X, $Y),        ];    }    /**     * Confidence ellipse (error ellipse)     * Given the data in $X and $Y, create an ellipse     * surrounding the data at $z standard deviations.     *     * The function will return $num_points pairs of X,Y data     * http://stackoverflow.com/questions/3417028/ellipse-around-the-data-in-matlab     *     * @param array $X an array of independent data     * @param array $Y an array of dependent data     * @param float $z the number of standard deviations to encompass     * @param int $num_points the number of points to include around the ellipse. The actual array     *                          will be one larger because the first point and last will be repeated     *                          to ease display.     *     * @return array paired x and y points on an ellipse aligned with the data provided     *     * @throws Exception\BadDataException     * @throws Exception\BadParameterException     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     */    public static function confidenceEllipse(array $X, array $Y, float $z, int $num_points = 11): array    {        $standardNormal = new StandardNormal();        $p  = 2 * $standardNormal->cdf($z) - 1;        $chiSquared = new ChiSquared(2);        $χ² = $chiSquared->inverse($p);        $data_array[] = $X;        $data_array[] = $Y;        $data_matrix  = new NumericMatrix($data_array);        $covariance_matrix = $data_matrix->covarianceMatrix();        // Scale the data by the confidence interval        $cov         = $covariance_matrix->scalarMultiply($χ²);        $eigenvalues = Eigenvalue::closedFormPolynomialRootMethod($cov);        // Sort the eigenvalues from highest to lowest        \rsort($eigenvalues);        $V = Eigenvector::eigenvectors($cov, $eigenvalues);        // Make ia diagonal matrix of the eigenvalues        $D = MatrixFactory::diagonal($eigenvalues);        $D = $D->map('\sqrt');        $transformation_matrix = $V->multiply($D);        $x_bar = Average::mean($X);        $y_bar = Average::mean($Y);        $translation_matrix = new NumericMatrix([[$x_bar],[$y_bar]]);        // We add a row to allow the transformation matrix to also traslate the ellipse to a different location        $transformation_matrix = $transformation_matrix->augment($translation_matrix);        $unit_circle = new NumericMatrix(Trigonometry::unitCircle($num_points));        // We add a column of ones to allow us to translate the ellipse        $unit_circle_with_ones = $unit_circle->augment(MatrixFactory::one($num_points, 1));        // The unit circle is rotated, stretched, and translated to the appropriate ellipse by the translation matrix.        $ellipse = $transformation_matrix->multiply($unit_circle_with_ones->transpose())->transpose();        return $ellipse->getMatrix();    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
171,markrogoyski_math-php_Correlation_3477,"Population correlation coefficient\\n Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r)\\n\\n A normalized measure of the linear correlation between two variables X and Y,\\n giving a value between +1 and −1 inclusive, where 1 is total positive correlation,\\n 0 is no correlation, and −1 is total negative correlation.\\n It is widely used in the sciences as a measure of the degree of linear dependence\\n between two variables.\\n https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\\n\\n The correlation coefficient of two variables in a data sample is their covariance\\n divided by the product of their individual standard deviations.\\n\\n        cov(X,Y)\\n ρxy = ----------\\n         σx σy\\n\\n  conv(X,Y) is the population covariance\\n  σx is the population standard deviation of X\\n  σy is the population standard deviation of Y\\n\\n @param array $X values for random variable X\\n @param array $Y values for random variable Y\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\OutOfBoundsException\\n","Populacioni korelacioni koeficijent. Pirsonov proizvod. Normalizovana mera linearne korelacije između dve promenljive X i Y koja vraća vrednost između 1 i -1 gde je 1 potpuno pozitivna korelacija, 0 predstavlja nedostatak korelacije, a -1 je potpuna negativna korelacija. Koristi se u nauci kao mera linearne zavisnosti između dve promenljive.","    public static function populationCorrelationCoefficient(array $X, array $Y): float    {        $cov⟮X，Y⟯ = self::populationCovariance($X, $Y);        $σx      = Descriptive::standardDeviation($X, true);        $σy      = Descriptive::standardDeviation($Y, true);        return $cov⟮X，Y⟯ / ( $σx * $σy );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
172,markrogoyski_math-php_Descriptive_3482, Descriptive statistics\n Summary statistics that quantitatively describe or summarize features of a collection of information.\n https://en.wikipedia.org/wiki/Descriptive_statistics\n,Deskriptivna statistika. Sažetak koji kvantitativno opisuje ili sumira obeležja skupa informacija.,"class Descriptive{    public const POPULATION = true;    public const SAMPLE     = false;    /**     * Range - the difference between the largest and smallest values     * It is the size of the smallest interval which contains all the data.     * It provides an indication of statistical dispersion.     * (https://en.wikipedia.org/wiki/Range_(statistics))     *     * R = max x - min x     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function range(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the range of an empty list of numbers');        }        return \max($numbers) - \min($numbers);    }    /**     * Midrange - the mean of the largest and smallest values     * It is the midpoint of the range; as such, it is a measure of central tendency.     * (https://en.wikipedia.org/wiki/Mid-range)     *     *     max x + min x     * M = -------------     *           2     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function midrange(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the midrange of an empty list of numbers');        }        return Average::mean([\min($numbers), \max($numbers)]);    }    /**     * Variance     *     * Variance measures how far a set of numbers are spread out.     * A variance of zero indicates that all the values are identical.     * Variance is always non-negative: a small variance indicates that the data points     * tend to be very close to the mean (expected value) and hence to each other.     * A high variance indicates that the data points are very spread out around the mean     * and from each other.     * (https://en.wikipedia.org/wiki/Variance)     *     *      ∑⟮xᵢ - μ⟯²     * σ² = ----------     *          ν     *     * Generalized method that allows setting the degrees of freedom.     * For population variance, set d.f. (ν) to n     * For sample variance, set d.f (ν) to n - 1     * Or use populationVariance or sampleVariance convenience methods.     *     * μ is the population mean     * ν is the degrees of freedom, which usually is     *   the number of numbers in the population set or n - 1 for sample set.     *     * @param float[] $numbers     * @param int     $ν degrees of freedom     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function variance(array $numbers, int $ν): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the variance of an empty list of numbers');        }        if ($ν <= 0) {            throw new Exception\OutOfBoundsException('Degrees of freedom must be > 0');        }        $∑⟮xᵢ − μ⟯² = RandomVariable::sumOfSquaresDeviations($numbers);        return $∑⟮xᵢ − μ⟯² / $ν;    }    /**     * Population variance - Use when all possible observations of the system are present.     * If used with a subset of data (sample variance), it will be a biased variance.     *     *      ∑⟮xᵢ - μ⟯²     * σ² = ----------     *          N     *     * μ is the population mean     * N is the number of numbers in the population set     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function populationVariance(array $numbers): float    {        $N = \count($numbers);        return self::variance($numbers, $N);    }    /**     * Unbiased sample variance     * Use when only a subset of all possible observations of the system are present.     *     *      ∑⟮xᵢ - x̄⟯²     * S² = ----------     *        n - 1     *     * x̄ is the sample mean     * n is the number of numbers in the sample set     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function sampleVariance(array $numbers): float    {        if (\count($numbers) == 1) {            return 0;        }        $n = \count($numbers);        return self::variance($numbers, $n - 1);    }    /**     * Weighted sample variance     *     * Biased case     *     *       ∑wᵢ⟮xᵢ - μw⟯²     * σ²w = ----------     *           ∑wᵢ     *     * Unbiased estimator for frequency weights     *     *       ∑wᵢ⟮xᵢ - μw⟯²     * σ²w = ----------     *         ∑wᵢ - 1     *     * μw is the weighted mean     *     * https://en.wikipedia.org/wiki/Weighted_arithmetic_mean#Weighted_sample_variance     *     * @param float[] $numbers     * @param float[] $weights     * @param bool    $biased     *     * @return float     *     * @throws Exception\BadDataException if the number of numbers and weights are not equal     */    public static function weightedSampleVariance(array $numbers, array $weights, bool $biased = false): float    {        if (\count($numbers) === 1) {            return 0;        }        if (\count($numbers) !== \count($weights)) {            throw new Exception\BadDataException('Numbers and weights must have the same number of elements.');        }        $μw           = Average::weightedMean($numbers, $weights);        $∑wᵢ⟮xᵢ − μw⟯² = \array_sum(\array_map(            function ($xᵢ, $wᵢ) use ($μw) {                return $wᵢ * \pow(($xᵢ - $μw), 2);            },            $numbers,            $weights        ));        $∑wᵢ = $biased            ? \array_sum($weights)            : \array_sum($weights) - 1;        return $∑wᵢ⟮xᵢ − μw⟯² / $∑wᵢ;    }    /**     * Standard deviation     * A measure that is used to quantify the amount of variation or dispersion of a set of data values.     * A low standard deviation indicates that the data points tend to be close to the mean     * (also called the expected value) of the set.     * A high standard deviation indicates that the data points are spread out over a wider range of values.     * (https://en.wikipedia.org/wiki/Standard_deviation)     *     * σ   = √⟮σ²⟯ = √⟮variance⟯     * SD+ = √⟮σ²⟯ = √⟮sample variance⟯     *     * @param float[] $numbers     * @param bool    $SD＋ : true returns SD+ (uses population variance);     *                false returns SD (uses sample variance);     *                Default is false (SD (sample variance))     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function standardDeviation(array $numbers, bool $SD＋ = false): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the standard deviation of an empty list of numbers');        }        return $SD＋            ? \sqrt(self::populationVariance($numbers))            : \sqrt(self::sampleVariance($numbers));    }    /**     * sd - Standard deviation - convenience method     *     * @param float[] $numbers     * @param bool    $SD＋ : true returns SD+ (uses population variance);     *                false returns SD (uses sample variance);     *                Default is false (SD (sample variance))     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function sd(array $numbers, bool $SD＋ = false): float    {        return self::standardDeviation($numbers, $SD＋);    }    /**     * MAD - mean absolute deviation     *     * The average of the absolute deviations from a central point.     * It is a summary statistic of statistical dispersion or variability.     * (https://en.wikipedia.org/wiki/Average_absolute_deviation)     *     *       ∑|xᵢ - x̄|     * MAD = ---------     *           N     *     * x̄ is the mean     * N is the number of numbers in the population set     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function meanAbsoluteDeviation(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the mean absolute deviation of an empty list of numbers');        }        $x         = Average::mean($numbers);        $∑│xᵢ − x│ = \array_sum(\array_map(            function ($xᵢ) use ($x) {                return \abs($xᵢ - $x);            },            $numbers        ));        $N = \count($numbers);        return $∑│xᵢ − x│ / $N;    }    /**     * MAD - median absolute deviation     *     * The average of the absolute deviations from a central point.     * It is a summary statistic of statistical dispersion or variability.     * It is a robust measure of the variability of a univariate sample of quantitative data.     * (https://en.wikipedia.org/wiki/Median_absolute_deviation)     *     * MAD = median(|xᵢ - x̄|)     *     * x̄ is the median     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function medianAbsoluteDeviation(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median absolute deviation of an empty list of numbers');        }        $x = Average::median($numbers);        return Average::median(\array_map(            function ($xᵢ) use ($x) {                return \abs($xᵢ - $x);            },            $numbers        ));    }    /**     * Quartiles     * Three points that divide the data set into four equal groups, each group comprising a quarter of the data.     * https://en.wikipedia.org/wiki/Quartile     *     * There are multiple methods for computing quartiles:     *  - Inclusive     *  - Exclusive     *     * @param float[] $numbers     * @param string  $method What quartile method to use (optional - default: exclusive)     *     * @return float[] (0%, Q1, Q2, Q3, 100%, IQR)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quartiles(array $numbers, string $method = 'exclusive'): array    {        switch (strtolower($method)) {            case 'inclusive':                return self::quartilesInclusive($numbers);            case 'exclusive':                return self::quartilesExclusive($numbers);            default:                return self::quartilesExclusive($numbers);        }    }    /**     * Quartiles - Exclusive method     * Three points that divide the data set into four equal groups, each group comprising a quarter of the data.     * https://en.wikipedia.org/wiki/Quartile     *     * 0% is smallest number     * Q1 (25%) is first quartile (lower quartile, 25th percentile)     * Q2 (50%) is second quartile (median, 50th percentile)     * Q3 (75%) is third quartile (upper quartile, 75th percentile)     * 100% is largest number     * interquartile_range is the difference between the upper and lower quartiles. (IQR = Q₃ - Q₁)     *     * Method used     *  - Use the median to divide the ordered data set into two halves.     *   - If there are an odd number of data points in the original ordered data set, do not include the median     *     (the central value in the ordered list) in either half.     *   - If there are an even number of data points in the original ordered data set,     *     split this data set exactly in half.     *  - The lower quartile value is the median of the lower half of the data.     *    The upper quartile value is the median of the upper half of the data.     *     * This rule is employed by the TI-83 calculator boxplot and ""1-Var Stats"" functions.     * This is the most basic method that is commonly taught in math textbooks.     *     * @param float[] $numbers     *     * @return array (0%, Q1, Q2, Q3, 100%, IQR)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quartilesExclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        if (\count($numbers) === 1) {            $number = \array_pop($numbers);            return [                '0%'   => $number,                'Q1'   => $number,                'Q2'   => $number,                'Q3'   => $number,                '100%' => $number,                'IQR'  => 0,            ];        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }    /**     * Quartiles - Inclusive method (R method)     * Three points that divide the data set into four equal groups, each group comprising a quarter of the data.     * https://en.wikipedia.org/wiki/Quartile     *     * 0% is smallest number     * Q1 (25%) is first quartile (lower quartile, 25th percentile)     * Q2 (50%) is second quartile (median, 50th percentile)     * Q3 (75%) is third quartile (upper quartile, 75th percentile)     * 100% is largest number     * interquartile_range is the difference between the upper and lower quartiles. (IQR = Q₃ - Q₁)     *     * Method used     *  - Use the median to divide the ordered data set into two halves.     *   - If there are an odd number of data points in the original ordered data set,     *     include the median (the central value in the ordered list) in both halves.     *   - If there are an even number of data points in the original ordered data set,     *     split this data set exactly in half.     *  - The lower quartile value is the median of the lower half of the data.     *    The upper quartile value is the median of the upper half of the data.     *     * The values found by this method are also known as ""Tukey's hinges"".     * This is the method that the programming language R uses by default.     *     * @param float[] $numbers     *     * @return array (0%, Q1, Q2, Q3, 100%, IQR)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quartilesInclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);            // Add median to both halves            $median = Average::median($numbers);            \array_push($lower_half, $median);            \array_unshift($upper_half, $median);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }    /**     * IQR - Interquartile range (midspread, middle fifty)     * A measure of statistical dispersion.     * Difference between the upper and lower quartiles.     * https://en.wikipedia.org/wiki/Interquartile_range     *     * IQR = Q₃ - Q₁     *     * @param float[] $numbers     * @param string  $method What quartile method to use (optional - default: exclusive)     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function interquartileRange(array $numbers, string $method = 'exclusive'): float    {        return self::quartiles($numbers, $method)['IQR'];    }    /**     * IQR - Interquartile range (midspread, middle fifty)     * Convenience wrapper function for interquartileRange.     *     * @param float[] $numbers     * @param string  $method What quartile method to use (optional - default: exclusive)     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function iqr(array $numbers, string $method = 'exclusive'): float    {        return self::quartiles($numbers, $method)['IQR'];    }    /**     * Compute the P-th percentile of a list of numbers     *     * Linear interpolation between closest ranks method - Second variant, C = 1     * P-th percentile (0 <= P <= 100) of a list of N ordered values (sorted from least to greatest)     * Similar method used in NumPy and Excel     * https://en.wikipedia.org/wiki/Percentile#Second_variant.2C_.7F.27.22.60UNIQ--postMath-00000043-QINU.60.22.27.7F     *     *      P     * x - --- (N - 1) + 1     *     100     *     * P = percentile     * N = number of elements in list     *     * ν(x) = νₓ + x％1(νₓ₊₁ - νₓ)     *     * ⌊x⌋  = integer part of x     * x％1 = fraction part of x     * νₓ   = number in position x in sorted list of numbers     * νₓ₊₁ = number in position x + 1 in sorted list of number     *     * @param float[] $numbers     * @param float   $P percentile to calculate     *     * @return float in list corresponding to P percentile     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if $P percentile is not between 0 and 100     */    public static function percentile(array $numbers, float $P): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the P-th percentile of an empty list of numbers');        }        if ($P < 0 || $P > 100) {            throw new Exception\OutOfBoundsException('Percentile P must be between 0 and 100.');        }        $N = \count($numbers);        if ($N === 1) {            return \array_shift($numbers);        }        \sort($numbers);        if ($P == 100) {            return  $numbers[$N - 1];        }        $x    = ($P / 100) * ($N - 1) + 1;        $⌊x⌋  = \intval($x);        $x％1 = $x - $⌊x⌋;        $νₓ   = $numbers[$⌊x⌋ - 1];        $νₓ₊₁ = $numbers[$⌊x⌋];        return $νₓ + $x％1 * ($νₓ₊₁ - $νₓ);    }    /**     * Midhinge     * The average of the first and third quartiles and is thus a measure of location.     * Equivalently, it is the 25% trimmed mid-range or 25% midsummary; it is an L-estimator.     * https://en.wikipedia.org/wiki/Midhinge     *     * Midhinge = (first quartile, third quartile) / 2     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function midhinge(array $numbers): float    {        $quartiles = self::quartiles($numbers);        $Q1        = $quartiles['Q1'];        $Q2        = $quartiles['Q3'];        return Average::mean([$Q1, $Q2]);    }    /**     * Coefficient of variation (cᵥ)     * Also known as relative standard deviation (RSD)     *     * A standardized measure of dispersion of a probability distribution or     * frequency distribution. It is often expressed as a percentage.     * The ratio of the standard deviation to the mean.     * https://en.wikipedia.org/wiki/Coefficient_of_variation     *     *      σ     * cᵥ = -     *      μ     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function coefficientOfVariation(array $numbers): float    {        $σ = self::standardDeviation($numbers);        $μ = Average::mean($numbers);        return $σ / $μ;    }    /**     * Get a report of all the descriptive statistics over a list of numbers     * Includes mean, median, mode, range, midrange, variance, standard deviation, quartiles, etc.     *     * @param float[] $numbers     * @param bool    $population : true means all possible observations of the system are present;     *                           false means a sample is used.     *     * @return array [n, mean, median, mode, range, midrange, variance, sd, CV, mean_mad,     *                median_mad, quartiles, skewness, kurtosis, sem, ci_95, ci_99]     *     * @throws Exception\OutOfBoundsException     * @throws Exception\BadDataException     */    public static function describe(array $numbers, bool $population = false): array    {        $n = \count($numbers);        $μ = Average::mean($numbers);        $σ = self::standardDeviation($numbers, $population);        return [            'n'                  => $n,            'min'                => \min($numbers),            'max'                => \max($numbers),            'mean'               => $μ,            'median'             => Average::median($numbers),            'mode'               => Average::mode($numbers),            'range'              => self::range($numbers),            'midrange'           => self::midrange($numbers),            'variance'           => $population ? self::populationVariance($numbers) : self::sampleVariance($numbers),            'sd'                 => $σ,            'cv'                 => $μ ? $σ / $μ : \NAN,            'mean_mad'           => self::meanAbsoluteDeviation($numbers),            'median_mad'         => self::medianAbsoluteDeviation($numbers),            'quartiles'          => self::quartiles($numbers),            'midhinge'           => self::midhinge($numbers),            'skewness'           => $population                ? ($n > 0 ? RandomVariable::populationSkewness($numbers) : null)                : ($n >= 3 ? RandomVariable::skewness($numbers) : null),            'ses'                => $n > 2 ? RandomVariable::ses($n) : null,            'kurtosis'           => $population                ? ($n > 3 ? RandomVariable::populationKurtosis($numbers) : null)                : ($n > 0 ? RandomVariable::sampleKurtosis($numbers) : null),            'sek'                => $n > 3 ? RandomVariable::sek($n) : null,            'sem'                => RandomVariable::standardErrorOfTheMean($numbers),            'ci_95'              => RandomVariable::confidenceInterval($μ, $n, $σ, '95'),            'ci_99'              => RandomVariable::confidenceInterval($μ, $n, $σ, '99'),        ];    }    /**     * Five number summary     * A descriptive statistic that provides information about a set of observations.     * It consists of the five most important sample percentiles:     *  1) the sample minimum (smallest observation)     *  2) the lower quartile or first quartile     *  3) the median (middle value)     *  4) the upper quartile or third quartile     *  5) the sample maximum (largest observation)     *     * https://en.wikipedia.org/wiki/Five-number_summary     *     * @param  array  $numbers     *     * @return array [min, Q1, median, Q3, max]     *     * @throws Exception\BadDataException     */    public static function fiveNumberSummary(array $numbers): array    {        $quartiles = self::quartiles($numbers);        return [            'min'    => \min($numbers),            'Q1'     => $quartiles['Q1'],            'median' => Average::median($numbers),            'Q3'     => $quartiles['Q3'],            'max'    => \max($numbers),        ];    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
173,markrogoyski_math-php_Descriptive_3484,"Midrange - the mean of the largest and smallest values\n It is the midpoint of the range; as such, it is a measure of central tendency.\n (https://en.wikipedia.org/wiki/Mid-range)\n\n     max x + min x\n M = -------------\n           2\n\n @param float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n",Sredina - pola puta između najveće i najmanje vrednosti. Mera je centralne tendencije.,"    public static function midrange(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the midrange of an empty list of numbers');        }        return Average::mean([\min($numbers), \max($numbers)]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
174,markrogoyski_math-php_Descriptive_3486,"Population variance - Use when all possible observations of the system are present.\n If used with a subset of data (sample variance), it will be a biased variance.\n\n      ∑⟮xᵢ - μ⟯²\n σ² = ----------\n          N\n\n μ is the population mean\n N is the number of numbers in the population set\n\n @param float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n @throws Exception\\OutOfBoundsException if degrees of freedom is ≤ 0\n",Varijansa populacije - Koristi se kada su sva merenja dostupna. Ako se koristi na podskupu podataka može biti pristrasna varijansa. ,"    public static function populationVariance(array $numbers): float    {        $N = \count($numbers);        return self::variance($numbers, $N);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
175,markrogoyski_math-php_Distance_3502," Manhattan distance (Taxicab geometry)\n\n https://en.wikipedia.org/wiki/Taxicab_geometry\n\n The taxicab metric is also known as rectilinear distance, L₁ distance, L¹ distance , snake distance, city block\n distance, Manhattan distance or Manhattan length, with corresponding variations in the name of the geometry.\n\n Σ|xᵢ - yᵢ|\n\n @param float[] $xs input array\n @param float[] $ys input array\n\n @return float\n\n @throws Exception\\BadDataException if p and q do not have the same number of elements\n",Manhattan udaljenost (udaljenost na mreži) odnosno gradskih blokova. Ima i druge nazive.,"public static function manhattan(array $xs, array $ys): float    {        return self::minkowski($xs, $ys, 1);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
176,markrogoyski_math-php_Divergence_3516,"Kullback-Leibler divergence\\n (also known as: discrimination information, information divergence, information gain, relative entropy, KLIC, KL divergence)\\n A measure of the difference between two probability distributions P and Q.\\n https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\\n\\n                       P(i)\\n Dkl(P‖Q) = ∑ P(i) log ----\\n            ⁱ\\u2009         Q(i)\\n\\n\\n\\n @param  array  $p distribution p\\n @param  array  $q distribution q\\n\\n @return float difference between distributions\\n\\n @throws Exception\\\\BadDataException if p and q do not have the same number of elements\\n @throws Exception\\\\BadDataException if p and q are not probability distributions that add up to 1\\n","Kulbak-Leiblerova divergencija, odnosno relativna entropija je mera razlike između dve raspodele verovatnoća.","public static function kullbackLeibler(array $p, array $q): float    {        // Arrays must have the same number of elements        if (\count($p) !== \count($q)) {            throw new Exception\BadDataException('p and q must have the same number of elements');        }        // Probability distributions must add up to 1.0        if ((\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) || (\abs(\array_sum($q) - 1) > self::ONE_TOLERANCE)) {            throw new Exception\BadDataException('Distributions p and q must add up to 1');        }        // Defensive measures against taking the log of 0 which would be -∞ or dividing by 0        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        $q = \array_map(            function ($qᵢ) {                return $qᵢ == 0 ? 1e-15 : $qᵢ;            },            $q        );        // ∑ P(i) log(P(i)/Q(i))        $Dkl⟮P‖Q⟯ = \array_sum(\array_map(            function ($P, $Q) {                return $P * \log($P / $Q);            },            $p,            $q        ));        return $Dkl⟮P‖Q⟯;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
177,markrogoyski_math-php_Eigenvector_2616," Count the number of rows that contain all zeroes, starting at the bottom.\n In reduced row echelon form, all the rows of zero will be on the bottom.\n\n @param NumericMatrix $M\n\n @return int\n","Broj redova koji sadrže sve nule, počevši od dna.","private static function countSolutions(NumericMatrix $M): int    {        $number_of_solutions = 0;        // There are solutions to be found.        $more_solutions = true;        $m = $M->getM();        // We will count the number of rows with all zeros, starting at the bottom.        for ($i = $m - 1; $i >= 0 && $more_solutions; $i--) {            // Every row of zeros is a degree of freedom (a solution) with that eigenvalue            if ($M->getRow($i) == \array_fill(0, $m, 0)) {                $number_of_solutions++;            } else {                 // Once we find a row with nonzero values, there are no more.                 $more_solutions = false;            }        }        return $number_of_solutions;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
178,markrogoyski_math-php_Geometric_3229, Geometric distribution\\n\\n https://en.wikipedia.org/wiki/Geometric_distribution\\n,Geometrijska raspodela,"class Geometric extends Discrete{    /**     * Distribution parameter bounds limits     * p ∈ (0,1]     * @var array     */    public const PARAMETER_LIMITS = [        'p' => '(0,1]',    ];    /**     * Distribution parameter bounds limits     * k ∈ [1,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'k' => '[1,∞)',    ];    /** @var float success probability  0 < p ≤ 1 */    protected $p;    /**     * Constructor     *     * @param float $p success probability  0 < p ≤ 1     */    public function __construct(float $p)    {        parent::__construct($p);    }    /**     * Probability mass function     *     * The probability distribution of the number Y = X − 1 of failures     * before the first success, supported on the set { 0, 1, 2, 3, ... }     *     * k failures where k ∈ {0, 1, 2, 3, ...}     *     * pmf = (1 - p)ᵏp     *     * @param  int   $k number of trials     k ≥ 1     *     * @return float     */    public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ = \pow(1 - $p, $k);        return $⟮1 − p⟯ᵏ * $p;    }    /**     * Cumulative distribution function (lower cumulative)     *     * The probability distribution of the number Y = X − 1 of failures     * before the first success, supported on the set { 0, 1, 2, 3, ... }     *     * k failures where k ∈ {0, 1, 2, 3, ...}     *     * pmf = 1 - (1 - p)ᵏ⁺¹     *     * @param  int   $k number of trials     k ≥ 0     *     * @return float     */    public function cdf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ⁺¹ = \pow(1 - $p, $k + 1);        return 1 - $⟮1 − p⟯ᵏ⁺¹;    }    /**     * Mean of the distribution     *     *     1 - p     * μ = -----     *       p     *     * @return float     */    public function mean(): float    {        return (1 - $this->p) / $this->p;    }    /**     * Median of the distribution     *     *           _           _     *          |     -1      |     * median = | ----------- | - 1     *          | log₂(1 - p) |     *     * @return float     */    public function median(): float    {        $log₂⟮1 − p⟯ = \log(1 - $this->p, 2);        return \ceil(-1 / $log₂⟮1 − p⟯) - 1;    }    /**     * Mode of the distribution     *     * mode = 0     *     * @return int     */    public function mode(): int    {        return 0;    }    /**     * Variance of the distribution     *     *      1 - p     * σ² = -----     *        p²     *     * @return float     */    public function variance(): float    {        return (1 - $this->p) / $this->p ** 2;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
179,markrogoyski_math-php_Geometric_3232,"Cumulative distribution function (lower cumulative)\\n\\n The probability distribution of the number Y = X − 1 of failures\\n before the first success, supported on the set { 0, 1, 2, 3, ... }\\n\\n k failures where k ∈ {0, 1, 2, 3, ...}\\n\\n pmf = 1 - (1 - p)ᵏ⁺¹\\n\\n @param  int   $k number of trials     k ≥ 0\\n\\n @return float\\n",Kumulativna raspodela,"public function cdf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ⁺¹ = \pow(1 - $p, $k + 1);        return 1 - $⟮1 − p⟯ᵏ⁺¹;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
180,markrogoyski_math-php_HanesWoolf_3571, Calculate the regression parameters by least squares on linearized data\\n x / y = x / V + K / V\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\MathException\\n,Izračunaj regresione parametre metodom najmanjih kvadrata na linearizovanim podacima.,"public function calculate(): void    {        // Linearize the relationship by dividing x by y        $y’ = Multi::divide($this->xs, $this->ys);        // Perform Least Squares Fit        $linear_parameters = $this->leastSquares($y’, $this->xs)->getColumn(0);        $V = 1 / $linear_parameters[1];        $K = $linear_parameters[0] * $V;        $this->parameters = [$V, $K];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
181,markrogoyski_math-php_Integer_2965," Detect if an integer is a perfect number.\\n A perfect number is a positive integer that is equal to the sum of its proper positive divisors,\\n that is, the sum of its positive divisors excluding the number itself\\n\\n @see    https://en.wikipedia.org/wiki/Perfect_number\\n\\n @param  int $n\\n\\n @return bool\\n",Proverava da li je ceo broj savršen broj. Savršen broj je pozitivan ceo broj koji je jednak sumi svojih pozitivnih delilaca.,public static function isPerfectNumber(int $n): bool    {        if ($n <= 1) {            return false;        }        return $n === self::aliquotSum($n);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
182,markrogoyski_math-php_Integer_2978,"Prime factorization\n The prime factors of an integer.\n https://en.wikipedia.org/wiki/Prime_factor\n\n Algorithm\n  1) Let n be the ongoing remainder\n  2) Try prime factoring n with 2 and 3\n  3) Try prime factoring n with increasing ℕ of the form 6𝑘±1 up through √n (all other ℕ are divisible by 2 and/or 3)\n  4) If n is still > 1, the remainder is a prime factor\n\n @param  int $n\n\n @return int[] of prime factors\n\n @throws Exception\\OutOfBoundsException if n is < 1.\n",Faktorizacija na proste činioce. ,"public static function primeFactorization(int $n): array    {        if ($n < 1) {            throw new Exception\OutOfBoundsException(""n must be ≥ 1. ($n provided)"");        }        $remainder = $n;        $factors   = [];        foreach ([2, 3] as $divisor) {            while ($remainder % $divisor === 0) {                $factors[] = $divisor;                $remainder = \intdiv($remainder, $divisor);            }        }        $divisor = 5;        $√n = \sqrt($remainder);        while ($divisor <= $√n) {            while ($remainder % $divisor === 0) {                $factors[] = $divisor;                $remainder = \intdiv($remainder, $divisor);                $√n        = \sqrt($remainder);            }            $divisor += 2;            while ($remainder % $divisor === 0) {                $factors[] = $divisor;                $remainder = \intdiv($remainder, $divisor);                $√n        = \sqrt($remainder);            }            $divisor += 4;        }        if ($remainder > 1) {            $factors[] = $remainder;        }        return $factors;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
183,markrogoyski_math-php_Integer_2982, Odd number\\n\\n @param  int $x\\n\\n @return bool true if x is odd; false otherwise\\n,Neparan broj. Proverava da li je broj neparan.,public static function isOdd(int $x): bool    {        return (\abs($x) % 2) === 1;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
184,markrogoyski_math-php_Interpolation_2989, Sorts our coordinates (arrays) by their x-component (first number) such\n that consecutive coordinates have an increasing x-component.\n\n @param  array $points\n\n @return array[]\n,Sortira koordinate prema njihovoj x komponenti u rastućem poretku.,"    protected static function sort(array $points): array    {        \usort($points, function (array $a, array $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
185,markrogoyski_math-php_Matrix_2648, Interchange two rows\\n\\n Row mᵢ changes to position mⱼ\\n Row mⱼ changes to position mᵢ\\n\\n @param int $mᵢ Row to swap into row position mⱼ\\n @param int $mⱼ Row to swap into row position mᵢ\\n\\n @return Matrix with rows mᵢ and mⱼ interchanged\\n\\n @throws Exception\\\\MatrixException if row to interchange does not exist\\n @throws Exception\\\\IncorrectTypeException\\n,Zameni mesta dvaju redova u matrici. Red mj menja poziciju na mi i obrnuto.,"public function rowInterchange(int $mᵢ, int $mⱼ): Matrix    {        if ($mᵢ >= $this->m || $mⱼ >= $this->m) {            throw new Exception\MatrixException('Row to interchange does not exist');        }        $m = $this->m;        $R = [];        for ($i = 0; $i < $m; $i++) {            switch ($i) {                case $mᵢ:                    $R[$i] = $this->A[$mⱼ];                    break;                case $mⱼ:                    $R[$i] = $this->A[$mᵢ];                    break;                default:                    $R[$i] = $this->A[$i];            }        }        return MatrixFactory::create($R, $this->ε);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
186,markrogoyski_math-php_Matrix_2650, Interchange two columns\n\n Column nᵢ changes to position nⱼ\n Column nⱼ changes to position nᵢ\n\n @param int $nᵢ Column to swap into column position nⱼ\n @param int $nⱼ Column to swap into column position nᵢ\n\n @return Matrix with columns nᵢ and nⱼ interchanged\n\n @throws Exception\\MatrixException if column to interchange does not exist\n @throws Exception\\IncorrectTypeException\n,Zameni mesta dvema kolonama. Kolona nj Menja pozociju na ni i obrnuto.,"public function columnInterchange(int $nᵢ, int $nⱼ): Matrix    {        if ($nᵢ >= $this->n || $nⱼ >= $this->n) {            throw new Exception\MatrixException('Column to interchange does not exist');        }        $m = $this->m;        $n = $this->n;        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                switch ($j) {                    case $nᵢ:                        $R[$i][$j] = $this->A[$i][$nⱼ];                        break;                    case $nⱼ:                        $R[$i][$j] = $this->A[$i][$nᵢ];                        break;                    default:                        $R[$i][$j] = $this->A[$i][$j];                }            }        }        return MatrixFactory::create($R, $this->ε);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
187,markrogoyski_math-php_NegativeBinomial_3244, Negative binomial distribution (Pascal distribution)\\n https://en.wikipedia.org/wiki/Negative_binomial_distribution\\n,Negativna binomijalna raspodela (Paskalova raspodela),"class NegativeBinomial extends Discrete{    /**     * Distribution parameter bounds limits     * r ∈ [0,∞)     * p ∈ [0,1]     * @var array     */    public const PARAMETER_LIMITS = [        'r' => '[0,∞)',        'p' => '[0,1]',    ];    /**     * Distribution support bounds limits     * x ∈ [0,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '[0,∞)',    ];    /** @var int number of successful events */    protected $r;    /** @var float probability of success on an individual trial */    protected $p;    /**     * Constructor     *     * @param  int   $r number of failures until the experiment is stopped     * @param  float $p probability of success on an individual trial     */    public function __construct(int $r, float $p)    {        parent::__construct($r, $p);    }    /**     * Probability mass function     *     *               / x + r - 1 \     * b(k; r, p) = |             | (1 - p)ˣ pʳ     *               \     x     /     *     *     *            = ₓ₊ᵣ₋₁Cₓ (1 - p)ˣ pʳ     *     * @param  int $x number of successes     *     * @return float     *     * @throws MathException     */    public function pmf(int $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $r = $this->r;        $p = $this->p;        $ₓ₊ᵣ₋₁Cₓ = Combinatorics::combinations($x + $r - 1, $x);        $⟮1 − p⟯ˣ = \pow(1 - $p, $x);        $pʳ      = \pow($p, $r);        return $ₓ₊ᵣ₋₁Cₓ * $⟮1 − p⟯ˣ * $pʳ;    }    /**     * Cumulative distribution function (lower cumulative distribution)     *     *               ₓ     * P(x; r, p) =  Σ pmf(k, r, p)     *              ᵏ⁼⁰     *     * @param int $x number of successes     *     * @return float     *     * @throws MathException     */    public function cdf(int $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        return \array_sum(            \array_map(                [$this, 'pmf'],                \range(0, $x)            )        );    }    /**     * Mean of the distribution     *     *       pr     * μ = -----     *     1 - p     *     * @return float     */    public function mean(): float    {        return ($this->p * $this->r) / (1 - $this->p);    }    /**     * Mode of the distribution     *     *        | p(r - 1) |     * mode = | -------- |  for r > 1     *        |_  1 - p _|     *     * mode = 0             for r ≤ 1     *     * @return float     */    public function mode(): float    {        if ($this->r <= 1) {            return 0;        }        $r = $this->r;        $p = $this->p;        return \floor(($p * ($r - 1)) / (1 - $p));    }    /**     * Variance of the distribution     *     *         pr     * σ² = --------     *      (1 - p)²     *     * @return float     */    public function variance(): float    {        return ($this->p * $this->r) / (1 - $this->p) ** 2;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
188,markrogoyski_math-php_NegativeBinomial_3246,"Probability mass function\\n\\n               / x + r - 1 \\\\\\n b(k; r, p) = |             | (1 - p)ˣ pʳ\\n               \\\\     x     /\\n\\n\\n            = ₓ₊ᵣ₋₁Cₓ (1 - p)ˣ pʳ\\n\\n @param  int $x number of successes\\n\\n @return float\\n\\n @throws MathException\\n",Funkcija gustine verovatnoće,"public function pmf(int $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $r = $this->r;        $p = $this->p;        $ₓ₊ᵣ₋₁Cₓ = Combinatorics::combinations($x + $r - 1, $x);        $⟮1 − p⟯ˣ = \pow(1 - $p, $x);        $pʳ      = \pow($p, $r);        return $ₓ₊ᵣ₋₁Cₓ * $⟮1 − p⟯ˣ * $pʳ;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
189,markrogoyski_math-php_NegativeBinomial_3250,Variance of the distribution\\n\\n         pr\\n σ² = --------\\n      (1 - p)²\\n\\n @return float\\n,Varijansa raspodele.,public function variance(): float    {        return ($this->p * $this->r) / (1 - $this->p) ** 2;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
190,markrogoyski_math-php_NewtonsMethod_3040," Newton's Method (also known as the Newton–Raphson method)\\n\\n In numerical analysis, Newton's method is a method for finding successively better\\n approximations to the roots (or zeroes) of a real-valued function.\\n","Njutnov metod, takođe poznat kao Njutn-Rapsonov metod. U numeričkoj analizi, Njutnov metod je metod za nalaženje iterativno boljih aproksimacija korena funkcije.","class NewtonsMethod{    /**     * Use Newton's Method to find the x which produces $target = $function(x) value     * $args is an array of parameters to pass to $function, but having the element that     * will be changed and serve as the initial guess in position $position.     *     * @param callable $function     f(x) callback function     * @param array    $args         Parameters to pass to callback function. The initial value for the     *                               parameter of interest must be in this array.     * @param number   $target       Value of f(x) we a trying to solve for     * @param float    $tol          Tolerance; How close to the actual solution we would like.     * @param int      $position     Which element in the $args array will be changed; also serves as initial guess     * @param int      $iterations     *     * @return number     *     * @throws Exception\OutOfBoundsException if the tolerance is not valid     */    public static function solve(callable $function, array $args, $target, float $tol, int $position = 0, int $iterations = 100)    {        Validation::tolerance($tol);        // Initialize        $args1 = $args;        $guess = $args[$position];        $i     = 0;        do {            $args1[$position] = $guess + $tol; // load the initial guess into the arguments            $args[$position]  = $guess;        // load the initial guess into the arguments            $y                = $function(...$args);            $y_at_xplusdelx   = $function(...$args1);            $slope            = ($y_at_xplusdelx - $y) / $tol;            $del_y            = $target - $y;            if (\abs($slope) < $tol) {                return \NAN;            }            $guess            = $del_y / $slope + $guess;            $dif              = \abs($del_y);            $i++;        } while ($dif > $tol && $i < $iterations);        if ($dif > $tol) {            return \NAN;        }        return $guess;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
191,markrogoyski_math-php_Normal_3164, Normal distribution\n https://en.wikipedia.org/wiki/Normal_distribution\n,Normalna raspodela.,"class Normal extends Continuous{    /**     * Distribution parameter bounds limits     * μ ∈ (-∞,∞)     * σ ∈ (0,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'μ' => '(-∞,∞)',        'σ' => '(0,∞)',    ];    /**     * Distribution support bounds limits     * x ∈ (-∞,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '(-∞,∞)',    ];    /** @var float Mean Parameter */    protected $μ;    /** @var float Standard Deviation Parameter */    protected $σ;    /**     * Normal constructor     *     * @param float $μ     * @param float $σ     */    public function __construct(float $μ, float $σ)    {        parent::__construct($μ, $σ);    }    /**     * Probability density function     *     *              1     * f(x|μ,σ) = ----- ℯ^−⟮x − μ⟯²∕2σ²     *            σ√⟮2π⟯     *     * @param float $x random variable     *     * @return float f(x|μ,σ)     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ     = $this->μ;        $σ     = $this->σ;        $π     = \M_PI;        $σ√⟮2π⟯ = $σ * \sqrt(2 * $π);        $⟮x − μ⟯²∕2σ² = \pow(($x - $μ), 2) / (2 * $σ ** 2);        $ℯ＾−⟮x − μ⟯²∕2σ² = \exp(-$⟮x − μ⟯²∕2σ²);        return ( 1 / $σ√⟮2π⟯ ) * $ℯ＾−⟮x − μ⟯²∕2σ²;    }    /**     * Cumulative distribution function     * Probability of being below X.     * Area under the normal distribution from -∞ to X.     *             _                  _     *          1 |         / x - μ \  |     * cdf(x) = - | 1 + erf|  ----- |  |     *          2 |_        \  σ√2  / _|     *     * @param float $x upper bound     *     * @return float cdf(x) below     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ = $this->μ;        $σ = $this->σ;        return 1 / 2 * ( 1 + Special::erf(($x - $μ) / ($σ * \sqrt(2))) );    }    /**     * Inverse CDF (quantile)     *     * @param float $p     *     * @return float     */    public function inverse(float $p): float    {        if ($p == 0) {            return -\INF;        }        if ($p == 1) {            return \INF;        }        return parent::inverse($p);    }    /**     * Mean of the distribution     *     * μ = μ     *     * @return float     */    public function mean(): float    {        return $this->μ;    }    /**     * Median of the distribution     *     * median = μ     *     * @return float     */    public function median(): float    {        return $this->μ;    }    /**     * Mode of the distribution     *     * mode = μ     *     * @return float     */    public function mode(): float    {        return $this->μ;    }    /**     * Variance of the distribution     *     * var[X] = σ²     *     * @return float     */    public function variance(): float    {        return $this->σ ** 2;    }    /**     * Random number - Box–Muller transform     *     * https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform     */    public function rand()    {        $rand1 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        $rand2 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        return \sqrt(-2 * \log($rand1)) * \cos(2 * pi() * $rand2) * $this->σ + $this->μ;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
192,markrogoyski_math-php_Normal_3166,"Probability density function\\n\\n              1\\n f(x|μ,σ) = ----- ℯ^−⟮x − μ⟯²∕2σ²\\n            σ√⟮2π⟯\\n\\n @param float $x random variable\\n\\n @return float f(x|μ,σ)\\n",Funkcija gustine verovatnoće-,"public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ     = $this->μ;        $σ     = $this->σ;        $π     = \M_PI;        $σ√⟮2π⟯ = $σ * \sqrt(2 * $π);        $⟮x − μ⟯²∕2σ² = \pow(($x - $μ), 2) / (2 * $σ ** 2);        $ℯ＾−⟮x − μ⟯²∕2σ² = \exp(-$⟮x − μ⟯²∕2σ²);        return ( 1 / $σ√⟮2π⟯ ) * $ℯ＾−⟮x − μ⟯²∕2σ²;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
193,markrogoyski_math-php_NumericDiagonalMatrix_2704, Diagonal matrix\n Elements along the main diagonal are the only non-zero elements (may also be zero).\n The off-diagonal elements are all zero\n,"Dijagonalna matrica. Elementi duž glavne dijagonale su jedini nenulti elementi, mada mogu imati nulte vrednosti. Svi elementi van glavne dijagonale su nule.","class NumericDiagonalMatrix extends NumericSquareMatrix{    /**     * Constructor     *     * @param array $A     */    public function __construct(array $A)    {        parent::__construct($A);        if (!parent::isLowerTriangular() || !parent::isUpperTriangular()) {            throw new MatrixException('Trying to construct DiagonalMatrix with non-diagonal elements: ' . \print_r($this->A, true));        }    }    /**     * Diagonal matrix must be symmetric     * @inheritDoc     */    public function isSymmetric(): bool    {        return true;    }    /**     * Diagonal matrix must be lower triangular     * @inheritDoc     */    public function isLowerTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be upper triangular     * @inheritDoc     */    public function isUpperTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be triangular     * @inheritDoc     */    public function isTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be diagonal     * @inheritDoc     */    public function isDiagonal(): bool    {        return true;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
194,markrogoyski_math-php_NumericMatrix_2714, Get the type of objects that are stored in the matrix\n\n @return string The class of the objects\n,Vrati tip objekata koji su skladišteni u matrici.,    public function getObjectType(): string    {        return 'number';    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
195,markrogoyski_math-php_NumericMatrix_2717, Is this matrix equal to some other matrix?\\n\\n @param NumericMatrix $B\\n\\n @return bool\\n,Da li je matrica jednaka nekoj drugoj matrici?,"public function isEqual(NumericMatrix $B): bool    {        if (!$this->isEqualSizeAndType($B)) {            return false;        }        $m = $this->m;        $n = $this->n;        $ε = $this->ε;        // All elements are the same        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if (Support::isNotEqual($this->A[$i][$j], $B[$i][$j], $ε)) {                    return false;                }            }        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
196,markrogoyski_math-php_NumericMatrix_2750, Direct sum of two matrices: A ⊕ B\n The direct sum of any pair of matrices A of size m × n and B of size p × q\n is a matrix of size (m + p) × (n + q)\n https://en.wikipedia.org/wiki/Matrix_addition#Direct_sum\n\n @param  NumericMatrix $B Matrix to add to this matrix\n\n @return NumericMatrix\n\n @throws Exception\\IncorrectTypeException\n,"Direktna suma dve matrice. Direktna suma bilo koja dva para matrica A, veličine mxn i B, veličine pxq je matrica veličine (m+p)x(n+q).","public function directSum(NumericMatrix $B): NumericMatrix    {        $m = $this->m + $B->getM();        $n = $this->n + $B->getN();        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 0;            }        }        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j];            }        }        $m = $B->getM();        $n = $B->getN();        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i + $this->m][$j + $this->n] = $B[$i][$j];            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
197,markrogoyski_math-php_NumericMatrix_2752, Subtract two matrices - Entrywise subtraction\n Adds each element of one matrix to the same element in the other matrix.\n Returns a new matrix.\n https://en.wikipedia.org/wiki/Matrix_addition#Entrywise_sum\n\n @param NumericMatrix $B Matrix to subtract from this matrix\n\n @return NumericMatrix\n\n @throws Exception\\MatrixException if matrices have a different number of rows or columns\n @throws Exception\\IncorrectTypeException\n,Razlika dve matrice. Oduzima svaki element jedne matrice odgovarajućem elementu druge matrice. Vraća novu matricu.,"public function subtract($B): NumericMatrix    {        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices have different number of rows');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices have different number of columns');        }        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] - $B[$i][$j];            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
198,markrogoyski_math-php_NumericMatrix_2754, Scalar matrix multiplication\\n https://en.wikipedia.org/wiki/Matrix_multiplication#Scalar_multiplication\\n\\n @param  float $λ\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\BadParameterException if λ is not a number\\n @throws Exception\\\\IncorrectTypeException\\n,Skalarno množenje matrica.,"public function scalarMultiply(float $λ): NumericMatrix    {        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] * $λ;            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
199,markrogoyski_math-php_NumericMatrix_2756,Scalar matrix division\\n\\n @param  float $λ\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\BadParameterException if λ is not a number\\n @throws Exception\\\\BadParameterException if λ is 0\\n @throws Exception\\\\IncorrectTypeException\\n,Skalarno deljenje matrica,"public function scalarDivide(float $λ): NumericMatrix    {        if ($λ == 0) {            throw new Exception\BadParameterException('Parameter λ cannot equal 0');        }        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] / $λ;            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
200,markrogoyski_math-php_NumericMatrix_2771," Sums of each column, returned as a Vector\n\n @return Vector\n","Suma svih kolona, u obliku vektora.","public function columnSums(): Vector    {        $sums = [];        for ($i = 0; $i < $this->n; $i++) {            $sums[] = \array_sum(\array_column($this->A, $i));        }        return new Vector($sums);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
201,markrogoyski_math-php_PCA_3564, Principal component analysis\\n\\n PCA uses the correlation between data vectors to find a transformation that minimizes variability.\\n\\n https://en.wikipedia.org/wiki/Principal_component_analysis\\n,Analiza osnovnih komponenti. PCA koristi korelaciju između vektora da nađe transformaciju koja minimizuje varijabilnost.,"class PCA{    /** @var NumericMatrix Dataset */    private $data;    /** @var Vector Means */    private $center;    /** @var Vector Scale */    private $scale;    /** @var Vector $EVal Eigenvalues of the correlation Matrix - Also the Loading Matrix for the PCA */    private $EVal = null;    /** @var NumericMatrix $EVec Eigenvectors of the correlation matrix */    private $EVec = null;    /**     * Constructor     *     * @param NumericMatrix $M      each row is a sample, each column is a variable     * @param bool          $center - Sets if the columns are to be centered to μ = 0     * @param bool          $scale  - Sets if the columns are to be scaled to σ  = 1     *     * @throws Exception\BadDataException if any rows have a different column count     * @throws Exception\MathException     */    public function __construct(NumericMatrix $M, bool $center = true, bool $scale = true)    {        // Check that there is enough data: at least two columns and rows        if (!($M->getM() > 1) || !($M->getN() > 1)) {            throw new Exception\BadDataException('Data matrix must be at least 2x2.');        }        $this->center = $center === true            ? $this->center = $M->columnMeans()            : $this->center = new Vector(\array_fill(0, $M->getN(), 0));        if ($scale === true) {            $scaleArray = [];            for ($i = 0; $i < $M->getN(); $i++) {                $scaleArray[] = Descriptive::standardDeviation($M->getColumn($i));            }            $this->scale = new Vector($scaleArray);        } else {            $this->scale = new Vector(\array_fill(0, $M->getN(), 1));        }        // Save the source data to the class        $this->data = $M;        // Center and scale the data as needed        $this->data = $this->standardizeData();        // Create the correlation / variance-covarience Matrix        $samples       = $M->getM();        $corrCovMatrix = $this->data->transpose()->multiply($this->data)->scalarDivide($samples - 1);        // Eigenvalues and vectors        $this->EVal = new Vector($corrCovMatrix->eigenvalues(Eigenvalue::JACOBI_METHOD));        $this->EVec = $corrCovMatrix->eigenvectors(Eigenvalue::JACOBI_METHOD);    }    /**     * Verify that the matrix has the same number of columns as the original data     *     * @param NumericMatrix $newData     *     * @throws Exception\BadDataException if the matrix is not square     */    private function checkNewData(NumericMatrix $newData): void    {        if ($newData->getN() !== $this->data->getN()) {            throw new Exception\BadDataException('Data does not have the same number of columns');        }    }    /**     * Standardize the data     * Use the object $center and $scale Vectors to transform the provided data     *     * @param NumericMatrix $new_data - An optional Matrix of new data which is standardized against the original data     *     * @return NumericMatrix     *     * @throws Exception\MathException     */    public function standardizeData(NumericMatrix $new_data = null): NumericMatrix    {        if ($new_data === null) {            $X = $this->data;        } else {            $this->checkNewData($new_data);            $X = $new_data;        }        $ones_column = MatrixFactory::one($X->getM(), 1);        // Create a matrix the same dimensions as $new_data, each element is the average of that column in the original data.        $center_matrix = $ones_column->multiply(MatrixFactory::create([$this->center->getVector()]));        $scale_matrix  = MatrixFactory::diagonal($this->scale->getVector())->inverse();        // scaled data: ($X - μ) / σ        return $X->subtract($center_matrix)->multiply($scale_matrix);    }    /**     * The loadings are the unit eigenvectors of the correlation matrix     *     * @return NumericMatrix     */    public function getLoadings(): NumericMatrix    {        return $this->EVec;    }    /**     * The eigenvalues of the correlation matrix     *     * @return Vector     *     * @throws Exception\MathException     */    public function getEigenvalues(): Vector    {        $EV = [];        for ($i = 0; $i < $this->data->getN(); $i++) {            $EV[] = Descriptive::standardDeviation($this->getScores()->getColumn($i)) ** 2;        }        return new Vector($EV);    }    /**     * Get Scores     *     * Transform the standardized data with the loadings matrix     *     * @param NumericMatrix|null $new_data     *     * @return NumericMatrix     *     * @throws Exception\MathException     */    public function getScores(NumericMatrix $new_data = null): NumericMatrix    {        if ($new_data === null) {            $scaled_data = $this->data;        } else {            $this->checkNewData($new_data);            $scaled_data = $this->standardizeData($new_data);        }        return $scaled_data->multiply($this->EVec);    }    /**     * Get R² Values     *     * R² for each component is eigenvalue divided by the sum of all eigenvalues     *     * @return float[]     */    public function getR2(): array    {        $total_variance = $this->EVal->sum();        return $this->EVal->scalarDivide($total_variance)->getVector();    }    /**     * Get the cumulative R²     *     * @return float[]     */    public function getCumR2(): array    {        $result = [];        $sum    = 0;        foreach ($this->getR2() as $R²value) {            $sum += $R²value;            $result[] = $sum;        }        return $result;    }    /**     * Get the Q Residuals     *     * The Q residual is the error in the model at a given model complexity.     * For each row (i) in the data Matrix x, and retained components (j):     * Qᵢ = eᵢ'eᵢ = xᵢ(I-PⱼPⱼ')xᵢ'     *     * @param NumericMatrix $new_data - An optional Matrix of new data which is standardized against the original data     *     * @return NumericMatrix of Q residuals     *     * @throws Exception\MathException     */    public function getQResiduals(NumericMatrix $new_data = null): NumericMatrix    {        $vars = $this->data->getN();        if ($new_data === null) {            $X = $this->data;        } else {            $this->checkNewData($new_data);            $X = $this->standardizeData($new_data);        }        $X′ = $X->transpose();        $I  = MatrixFactory::identity($vars);        // Initial element with initialization of result matrix        $P  = $this->EVec->submatrix(0, 0, $vars - 1, 0);  // Get the first column of the loading matrix        $P′ = $P->transpose();        $Q  = MatrixFactory::create([$X->multiply($I->subtract($P->multiply($P′)))->multiply($X′)->getDiagonalElements()])->transpose();        for ($i = 1; $i < $vars; $i++) {            // Get the first $i+1 columns of the loading matrix            $P  = $this->EVec->submatrix(0, 0, $vars - 1, $i);            $P′ = $P->transpose();            $Qᵢ = MatrixFactory::create([$X->multiply($I->subtract($P->multiply($P′)))->multiply($X′)->getDiagonalElements()])->transpose();            $Q  = $Q->augment($Qᵢ);        }        return $Q;    }    /**     * Get the T² Distance     *     * Get the distance from the score to the center of the model plane.     * For each row (i) in the data matrix, and retained componenets (j)     * Tᵢ² = XᵢPⱼΛⱼ⁻¹Pⱼ'Xᵢ'     *     * @param NumericMatrix $new_data - An optional Matrix of new data which is standardized against the original data     *     * @return NumericMatrix     *     * @throws Exception\MathException     */    public function getT2Distances(NumericMatrix $new_data = null): NumericMatrix    {        $vars = $this->data->getN();        if ($new_data === null) {            $X = $this->data;        } else {            $this->checkNewData($new_data);            $X = $this->standardizeData($new_data);        }        $X′ = $X->transpose();        // Initial element with initialization of result matrix        $P    = $this->EVec->submatrix(0, 0, $vars - 1, 0); // // Get the first column of the loading matrix        $P′   = $P->transpose();        $Λⱼ⁻¹ = MatrixFactory::diagonal(\array_slice($this->EVal->getVector(), 0, 0 + 1))->inverse();        $T²   = MatrixFactory::create([$X->multiply($P)->multiply($Λⱼ⁻¹)->multiply($P′)->multiply($X′)->getDiagonalElements()])->transpose();        for ($i = 1; $i < $this->data->getN(); $i++) {            // Get the first $i+1 columns of the loading matrix            $P    = $this->EVec->submatrix(0, 0, $vars - 1, $i);            $P′   = $P->transpose();            $Λⱼ⁻¹ = MatrixFactory::diagonal(\array_slice($this->EVal->getVector(), 0, $i + 1))->inverse();            $Tᵢ²  = MatrixFactory::create([$X->multiply($P)->multiply($Λⱼ⁻¹)->multiply($P′)->multiply($X′)->getDiagonalElements()])->transpose();            $T²   = $T²->augment($Tᵢ²);        }        return $T²;    }    /**     * Calculate the critical limits of T²     *     * @param float $alpha the probability limit of the critical value     *     * @return float[] Critical values for each model complexity     */    public function getCriticalT2(float $alpha = .05): array    {        $samp = $this->data->getM();        $vars = $this->data->getN();        $T²Critical = [];        for ($i = 1; $i <= $vars; $i++) {            $F = new F($i, $samp - $i);            $T = $i * ($samp - 1) * $F->inverse(1 - $alpha) / ($samp - $i);            $T²Critical[] = $T;        }        return $T²Critical;    }    /**     * Calculate the critical limits of Q     *     * @param float $alpha the probability limit of the critical value     *     * @return float[] Critical values for each model complexity     *     * @throws Exception\MathException     */    public function getCriticalQ(float $alpha = .05): array    {        $vars  = $this->data->getN();        $QCritical = [];        for ($i = 0; $i < $vars - 1; $i++) {            $evals = \array_slice($this->getEigenvalues()->getVector(), $i + 1);            $t1 = \array_sum($evals);            $t2 = \array_sum(Single::square($evals));            $t3 = \array_sum(Single::pow($evals, 3));            $h0 = 1 - 2 * $t1 * $t3 / 3 / $t2 ** 2;            if ($h0 < .001) {                $h0 = .001;            }            $normal = new StandardNormal();            $ca     = $normal->inverse(1 - $alpha);            $h1 = $ca * \sqrt(2 * $t2 * $h0 ** 2) / $t1;            $h2 = $t2 * $h0 * ($h0 - 1) / $t1 ** 2;            $QCritical[] = $t1 * (1 + $h1 + $h2) ** (1 / $h0);        }        // The final value is always zero since the model is perfectly fit.        $QCritical[] = 0;        return $QCritical;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
202,markrogoyski_math-php_Rational_2945,"String representation of a rational number\n 5 6/7, 456079/13745859, etc.\n\n @return string\n",Predstava racionalnog broja stringom. Na primer 6/7 ili 456079/13745859,public function __toString(): string    {        $sign     = '';        $whole    = '';        $fraction = '';        if (Special::sgn($this->whole) === -1 || Special::sgn($this->numerator) === -1) {            $sign = '-';        }        if ($this->whole !== 0) {            $whole = \abs($this->whole);        }        if ($this->numerator !== 0) {            if ($this->whole !== 0) {                $whole .= ' ';            }            $fraction = $this->numeratorToSuperscript() . '/' . $this->denominatorToSubscript();        }        $string = $sign . $whole . $fraction;        if ($string == '') {            $string = '0';        }        return $string;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
203,markrogoyski_math-php_RectangleMethod_3025," Rectangle Method\n\n In numerical analysis, the rectangle method is a technique for approximating\n the definite integral of a function.\n\n The rectangle method belongs to the closed Newton-Cotes formulas, a group of\n methods for numerical integration which approximate the integral of a function.\n We can either directly supply a set of inputs and their corresponding outputs\n for said function, or if we explicitly know the function, we can define it as a\n callback function and then generate a set of points by evaluating that function\n at n points between a start and end point. We then use these values to\n interpolate a Lagrange polynomial. Finally, we integrate the Lagrange\n polynomial to approximate the integral of our original function.\n\n The rectangle method is produced by integrating the zero-th degree Lagrange Polynomial\n\n https://en.wikipedia.org/wiki/Rectangle_method\n http://www.efunda.com/math/num_integration/num_int_newton.cfm\n","Pravougaoni metod. U numeričkoj analizi, metod pravougaonika je tehnika za aproksimaciju određenog integrala funkcije. Ovaj metod pripada Njutn-Kotovim formulama, grupi metoda numeričke integracije koje aproksimiraju integram funkcije. Možemo da dostavimo skip ulaza i njihovih odgovarajućih izlaza za datu funkciju ili, ukoliko eksplicitno znamo funkciju, možemo je definisati kao callback funkciju i generisati skup tačaka na kojima ćemo uzeti njenu vrednost. Ove vrednosti zatim koristimo da interpoliramo Lagranžov polinom. Konačno, integralimo Lagranžov polinom da aproksimiramo integral naše originalne funkcije.","class RectangleMethod extends NumericalIntegration{    /**     * Use the Rectangle Method to approximate the definite integral of a     * function f(x). Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose definite integral we     * are approximating.     *     * The bounds of the definite integral to which we are approximating is     * determined by the our inputs.     *     * Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite     * integral of the function that produces these coordinates with a lower     * bound of 0, and an upper bound of 10.     *     * Example: approximate(function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Rectangle Rule:     *     * xn        ⁿ⁻¹ xᵢ₊₁     * ∫ f(x)dx = ∑   ∫ f(x)dx     * x₁        ⁱ⁼¹  xᵢ     *     *            ⁿ     *          = ∑   h [f(xᵢ)] + O(h³f″(x))     *           ⁱ⁼¹     *     *  where h = xᵢ₊₁ - xᵢ     *  note: this implementation does not compute the error term.     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4]].     *                                Example callback: function($x) {return $x**2;}     * @param number         ...$args The arguments of our callback function: start,     *                                end, and n. Example: approximate($source, 0, 8, 5).     *                                If $source is a set of points, do not input any     *                                $args. Example: approximate($source).     *     * @return float                  The approximation to the integral of f(x)     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     */    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         *   ⁿ         * = ∑   h [f(xᵢ)] + O(h³f″(x))         *  ⁱ⁼¹         * where h = xᵢ₊₁ - xᵢ         */        for ($i = 0; $i < $steps; $i++) {            $xᵢ             = $sorted[$i][$x];            $xᵢ₊₁           = $sorted[$i + 1][$x];            $f⟮xᵢ⟯           = $sorted[$i][$y];   // yᵢ            $lagrange       = LagrangePolynomial::interpolate([[$xᵢ, $f⟮xᵢ⟯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xᵢ₊₁) - $integral($xᵢ); // definite integral of lagrange polynomial        }        return $approximation;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
204,markrogoyski_math-php_RegularGridInterpolator_3004, Dynamically accessing multidimensional array value.\n\n @param array $data\n @param array $keys\n\n @return array|mixed\n,Dinamički pristup vrednosti višedimenzionalnog niza.,"    private function flatCall(array $data, array $keys)    {        $current = $data;        foreach ($keys as $key) {            $current = $current[$key];        }        return $current;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
205,markrogoyski_math-php_Search_2508, Search Sorted\\n Find the array indices where items should be inserted to maintain sorted order.\\n\\n Inspired by and similar to Python NumPy's searchsorted\\n\\n @param float[]|int[] $haystack Sorted array with standard increasing numerical array keys\\n @param float         $needle   Item wanting to insert\\n\\n @return int Index of where you would insert the needle and maintain sorted order\\n,Traži u sortiranom. Nađi indeks niza gde treba dodati vrednosti kako bi se očuvao redosled. Inspirisano Python funkcijom searchsorted.,"public static function sorted(array $haystack, float $needle): int    {        if (empty($haystack)) {            return 0;        }        $index = 0;        foreach ($haystack as $i => $val) {            if ($needle > $val) {                $index++;            } else {                return $index;            }        }        return $index;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
206,markrogoyski_math-php_Search_2509," ArgMax\\n Find the array index of the maximum value.\\n\\n In case of the maximum value appearing multiple times, the index of the first occurrence is returned.\\n In the case NAN is present, the index of the first NAN is returned.\\n\\n Inspired by and similar to Python NumPy's argmax\\n\\n @param float[]|int[] $values\\n\\n @return int Index of the first occurrence of the maximum value\\n\\n @throws Exception\\\\BadDataException if the array of values is empty\\n","Nađi indeks maksimalne vrednosti niza. U slučaju da se maksimalna vrednost pojavljuje više puta, vraća se indeks prvog pojavljivanja.","public static function argMax(array $values): int    {        if (empty($values)) {            throw new Exception\BadDataException('Cannot find the argMax of an empty array');        }        // Special case: NAN wins if present        $nanPresent = \array_filter(            $values,            function ($value) {                return \is_float($value) && \is_nan($value);            }        );        if (\count($nanPresent) > 0) {            foreach ($values as $i => $v) {                if (\is_nan($v)) {                    return $i;                }            }        }        // Standard case: Find max and return index        return self::baseArgMax($values);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
207,markrogoyski_math-php_Search_2514," Base argMin calculation\n Find the array index of the minimum value.\n\n In case of the maximum value appearing multiple times, the index of the first occurrence is returned.\n\n @param float[]|int[] $values\n\n @return int Index of the first occurrence of the minimum value\n","Nađi indeks minimalne vrednosti niza. U slučaju da se minimalna vrednost pojavljuje više puta, vraća se indeks prvog pojavljivanja.",    private static function baseArgMin(array $values): int    {        $max = \min($values);        foreach ($values as $i => $v) {            if ($v === $max) {                return $i;            }        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
208,markrogoyski_math-php_Set_3408, Add an element to the set\\n Does nothing if element already exists in the set.\\n\\n @param mixed $x\\n\\n @return Set (this set)\\n,Dodaj element u skup. Ne radi ništa ukoliko element već postoji u skupu.,    public function add($x): Set    {        $this->A[$this->getKey($x)] = $x;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
209,markrogoyski_math-php_Set_3409, Add an array of elements to the set\n Does nothing if element already exists in the set.\n\n @param array $members\n\n @return Set (this set)\n,Dodaj niz elemenata u skup. Ne radi ništa ukoliko element već postoji u skupu.,    public function addMulti(array $members): Set    {        foreach ($members as $member) {            $this->A[$this->getKey($member)] = $member;        }        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
210,markrogoyski_math-php_Set_3414," Subset (A ⊆ B)\\n Is the set a subset of the other set?\\n In other words, does the other set contain all the elements of the set?\\n\\n @param  Set $B\\n\\n @return boolean\\n","Podskup. Proverava da li je skup podskup drugog skupa. U drugim rečima, da li drugi skup sadrži sve elemente prvog skupa","    public function isSubset(Set $B): bool    {        $B_array  = $B->asArray();        $A∩B = \array_intersect_key($this->A, $B_array);        $A∖B = \array_diff_key($this->A, $B_array);        return (\count($A∩B) === \count($this->A)) && (empty($A∖B));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
211,markrogoyski_math-php_Special_2559," Beta function\\n\\n https://en.wikipedia.org/wiki/Beta_function\\n\\n           Γ(x)Γ(y)\\n β(x, y) = --------\\n           Γ(x + y)\\n\\n @param  float $x\\n @param  float $y\\n\\n @return float\\n\\n @throws Exception\\\\OutOfBoundsException\\n",Beta funkcija,"public static function beta(float $x, float $y): float    {        if ($x == 0 || $y == 0) {            return \INF;        }        $Γ⟮x⟯Γ⟮y⟯   = self::gamma($x) * self::gamma($y);        $Γ⟮x ＋ y⟯ = self::gamma($x + $y);        return $Γ⟮x⟯Γ⟮y⟯ / $Γ⟮x ＋ y⟯;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
212,markrogoyski_math-php_Validation_3045, Verify that the start and end of of an interval are distinct numbers.\\n\\n @param number $a The start of the interval\\n @param number $b The end of the interval\\n\\n @throws Exception\\\\BadDataException if $a = $b\\n,Potvrdi da su početak i kraj intervala jedinstveni brojevi.,"    public static function interval($a, $b)    {        if ($a === $b) {            throw new Exception\BadDataException('Start point and end point of interval cannot be the same.');        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
213,markrogoyski_math-php_Vector_2840, Outer product (A⨂B)\\n https://en.wikipedia.org/wiki/Outer_product\\n Same as direct product.\\n\\n @param Vector $B\\n\\n @return NumericMatrix\\n,Spoljašnji proizvod dva vektora.,public function outerProduct(Vector $B): NumericMatrix    {        $m = $this->n;        $n = $B->getN();        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $this->A[$i] * $B[$j];            }        }        return MatrixFactory::create($R);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
214,matomo-org_matomo_Access_36," If the user doesn't have an ADMIN access for at least one website, throws an exception\\n\\n @throws \\\\Piwik\\\\NoAccessException\\n","Ukoliko korisnik nema ADMIN pristup za bar jedan sajt, podiže izuzetak.","    public function checkUserHasSomeAdminAccess()    {        if (!$this->isUserHasSomeAdminAccess()) {            $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilegeAtLeastOneWebsite', array('admin')));        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
215,matomo-org_matomo_Access_43," Returns the level of access the current user has to the given site.\\n\\n @param int $idSite The site to check.\\n @return string The access level, eg, 'view', 'admin', 'noaccess'.\\n",Vraća nivo pristupa koji tretnutni koristnik ima na zadatom sajtu.,"    public function getRoleForSite($idSite)    {        if ($this->hasSuperUserAccess            || in_array($idSite, $this->getSitesIdWithAdminAccess())        ) {            return 'admin';        }        if (in_array($idSite, $this->getSitesIdWithWriteAccess())) {            return 'write';        }        if (in_array($idSite, $this->getSitesIdWithViewAccess())) {            return 'view';        }        return 'noaccess';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
216,matomo-org_matomo_Access_46, Returns true if the current user is logged in or not.\\n\\n @return bool\\n,Vraća tačno ukoliko je koristnik prijavljen,    public function isUserLoggedIn()    {        return !empty($this->login);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
217,matomo-org_matomo_Archive_792, Returns an array describing what metadata to use when indexing a query result.\n For use with DataCollection.\n\n @return array\n,Vraća niz koji opisuje koju metadatu treba koristiti kada se indeksira rezultat upita.,private function getResultIndices()    {        $indices = array();        if (count($this->params->getIdSites()) > 1            || $this->forceIndexedBySite        ) {            $indices['site'] = 'idSite';        }        if (count($this->params->getPeriods()) > 1            || $this->forceIndexedByDate        ) {            $indices['period'] = 'date';        }        return $indices;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
218,matomo-org_matomo_AssetManager_87, Check if the merged file directory exists and is writable.\\n\\n @return string The directory location\\n @throws Exception if directory is not writable.\\n,Proverava da li direktorijum u koji će se upisati fajl postoji i da li imamo dozvolu da upisujemo u njega.,"    public function getAssetDirectory()    {        $mergedFileDirectory = StaticContainer::get('path.tmp') . '/assets';        if (!is_dir($mergedFileDirectory)) {            Filesystem::mkdir($mergedFileDirectory);        }        if (!is_writable($mergedFileDirectory)) {            throw new Exception(""Directory "" . $mergedFileDirectory . "" has to be writable."");        }        return $mergedFileDirectory;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
219,matomo-org_matomo_CliMulti_127, Remove files older than one week. They should be cleaned up automatically after each request but for whatever\\n reason there can be always some files left.\\n,"Obriši fajlove koji su stariji od jedne nedelje. Trebalo bi da se obrišu automatski posle svakog zahteva, međutim iz nekog razloga uvek neki ostanu.",public static function cleanupNotRemovedFiles()    {        $timeOneWeekAgo = strtotime('-1 week');        $files = _glob(self::getTmpPath() . '/*');        if (empty($files)) {            return;        }        foreach ($files as $file) {            if (file_exists($file)) {                $timeLastModified = filemtime($file);                if ($timeLastModified !== false && $timeOneWeekAgo > $timeLastModified) {                    unlink($file);                }            }        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
220,matomo-org_matomo_Common2_134,"Base class for HTML classes\\n\\n Implements methods for working with HTML attributes, parsing and generating\\n attribute strings. Port of HTML_Common class for PHP4 originally written by\\n Adam Daniel with contributions from numerous other developers.\\n\\n @category   HTML\\n @package    HTML_Common2\\n @author     Alexey Borzov <avb@php.net>\\n @version    Release: @package_version@\\n","Osnovna klasa za HTML klase. Implementira metode za rad za HTML atributima, parsiranje i generisanje stringova atributa. Port je HTML_Common klase za PHP4 koju je originalno napisao Adam Daniel uz doprinose mnogobrojnih razvijača.","abstract class HTML_Common2{   /**    * Associative array of attributes    * @var array    */    protected $attributes = array();   /**    * List of attribites changes to which will be announced via onAttributeChange()    * method rather than performed by HTML_Common2 class itself    * @var array    * @see onAttributeChange()    */    protected $watchedAttributes = array();   /**    * Indentation level of the element    * @var int    */    private $_indentLevel = 0;   /**    * Comment associated with the element    * @var string    */    private $_comment = null;   /**    * Global options for all elements generated by subclasses of HTML_Common2    *    * Preset options are    * - 'charset': charset parameter used in htmlspecialchars() calls,    *   defaults to 'ISO-8859-1'    * - 'indent': string used to indent HTML elements, defaults to ""\11""    * - 'linebreak': string used to indicate linebreak, defaults to ""\12""    *    * @var array    */    private static $_options = array(        'charset'   => 'ISO-8859-1',        'indent'    => ""\11"",        'linebreak' => ""\12""    );   /**    * Sets global option(s)    *    * @param    string|array    Option name or array ('option name' => 'option value')    * @param    mixed           Option value, if first argument is not an array    */    public static function setOption($nameOrOptions, $value = null)    {        if (is_array($nameOrOptions)) {            foreach ($nameOrOptions as $k => $v) {                self::setOption($k, $v);            }        } else {            $linebreaks = array('win' => ""\15\12"", 'unix' => ""\12"", 'mac' => ""\15"");            if ('linebreak' == $nameOrOptions && isset($linebreaks[$value])) {                $value = $linebreaks[$value];            }            self::$_options[$nameOrOptions] = $value;        }    }   /**    * Returns global option(s)    *    * @param    string  Option name    * @return   mixed   Option value, null if option does not exist,    *                   array of all options if $name is not given    */    public static function getOption($name = null)    {        if (null === $name) {            return self::$_options;        } else {            return isset(self::$_options[$name])? self::$_options[$name]: null;        }    }   /**    * Parses the HTML attributes given as string    *    * @param    string  HTML attribute string    * @return   array   An associative aray of attributes    */    protected static function parseAttributes($attrString)    {        $attributes = array();        if (preg_match_all(                ""/(([A-Za-z_:]|[^\\x00-\\x7F])([A-Za-z0-9_:.-]|[^\\x00-\\x7F])*)"" .                ""([ \\n\\t\\r]+)?(=([ \\n\\t\\r]+)?(\""[^\""]*\""|'[^']*'|[^ \\n\\t\\r]*))?/"",                $attrString,                $regs           )) {            for ($i = 0; $i < count($regs[1]); $i++) {                $name  = trim($regs[1][$i]);                $check = trim($regs[0][$i]);                $value = trim($regs[7][$i]);                if ($name == $check) {                    $attributes[strtolower($name)] = strtolower($name);                } else {                    if (!empty($value) && ($value[0] == '\'' || $value[0] == '""')) {                        $value = substr($value, 1, -1);                    }                    $attributes[strtolower($name)] = $value;                }            }        }        return $attributes;    }   /**    * Creates a valid attribute array from either a string or an array    *    * @param    mixed   Array of attributes or HTML attribute string    * @return   array   An associative aray of attributes    */    protected static function prepareAttributes($attributes)    {        $prepared = array();        if (is_string($attributes)) {            return self::parseAttributes($attributes);        } elseif (is_array($attributes)) {            foreach ($attributes as $key => $value) {                if (is_int($key)) {                    $key = strtolower($value);                    $prepared[$key] = $key;                } else {                    $prepared[strtolower($key)] = (string)$value;                }            }        }        return $prepared;    }   /**    * Removes an attribute from an attribute array    *    * @param    array   Attribute array    * @param    string  Name of attribute to remove    */    protected static function removeAttributeArray(&$attributes, $name)    {        unset($attributes[strtolower($name)]);    }   /**    * Creates HTML attribute string from array    *    * @param    array   Attribute array    * @return   string  Attribute string    */    protected static function getAttributesString($attributes)    {        $str = '';        if (is_array($attributes)) {            $charset = self::getOption('charset');            foreach ($attributes as $key => $value) {                $str .= ' ' . $key . '=""' . htmlspecialchars($value, ENT_QUOTES, $charset) . '""';            }        }        return $str;    }   /**    * Class constructor, sets default attributes    *    * @param    mixed   Array of attribute 'name' => 'value' pairs or HTML attribute string    */    public function __construct($attributes = null)    {        $this->mergeAttributes($attributes);    }   /**    * Sets the value of the attribute    *    * @param    string  Attribute name    * @param    string  Attribute value (will be set to $name if omitted)    * @return   HTML_Common2    */    public function setAttribute($name, $value = null)    {        $name = strtolower($name);        if (is_null($value)) {            $value = $name;        }        if (in_array($name, $this->watchedAttributes)) {            $this->onAttributeChange($name, $value);        } else {            $this->attributes[$name] = (string)$value;        }        return $this;    }   /**    * Returns the value of an attribute    *    * @param    string  Attribute name    * @return   string  Attribute value, null if attribute does not exist    */    public function getAttribute($name)    {        $name = strtolower($name);        return isset($this->attributes[$name])? $this->attributes[$name]: null;    }   /**    * Sets the attributes    *    * @param    mixed   Array of attribute 'name' => 'value' pairs or HTML attribute string    * @return   HTML_Common2    */    public function setAttributes($attributes)    {        $attributes = self::prepareAttributes($attributes);        $watched    = array();        foreach ($this->watchedAttributes as $watchedKey) {            if (isset($attributes[$watchedKey])) {                $this->setAttribute($watchedKey, $attributes[$watchedKey]);                unset($attributes[$watchedKey]);            } else {                $this->removeAttribute($watchedKey);            }            if (isset($this->attributes[$watchedKey])) {                $watched[$watchedKey] = $this->attributes[$watchedKey];            }        }        $this->attributes = array_merge($watched, $attributes);        return $this;    }   /**    * Returns the attribute array or string    *    * @param    bool    Whether to return attributes as string    * @return   mixed   Either an array or string of attributes    */    public function getAttributes($asString = false)    {        if ($asString) {            return self::getAttributesString($this->attributes);        } else {            return $this->attributes;        }    }   /**    * Merges the existing attributes with the new ones    *    * @param    mixed   Array of attribute 'name' => 'value' pairs or HTML attribute string    * @return   HTML_Common2    */    public function mergeAttributes($attributes)    {        $attributes = self::prepareAttributes($attributes);        foreach ($this->watchedAttributes as $watchedKey) {            if (isset($attributes[$watchedKey])) {                $this->onAttributeChange($watchedKey, $attributes[$watchedKey]);                unset($attributes[$watchedKey]);            }        }        $this->attributes = array_merge($this->attributes, $attributes);        return $this;    }   /**    * Removes an attribute    *    * @param    string  Name of attribute to remove    * @return   HTML_Common2    */    public function removeAttribute($attribute)    {        if (in_array(strtolower($attribute), $this->watchedAttributes)) {            $this->onAttributeChange(strtolower($attribute), null);        } else {            self::removeAttributeArray($this->attributes, $attribute);        }        return $this;    }   /**    * Sets the indentation level    *    * @param    int    * @return   HTML_Common2    */    public function setIndentLevel($level)    {        $level = intval($level);        if (0 <= $level) {            $this->_indentLevel = $level;        }        return $this;    }   /**    * Gets the indentation level    *    * @return   int    */    public function getIndentLevel()    {        return $this->_indentLevel;    }   /**    * Returns the string to indent the element    *    * @return   string    */    protected function getIndent()    {        return str_repeat(self::getOption('indent'), $this->getIndentLevel());    }   /**    * Sets the comment for the element    *    * @param    string    * @return   HTML_Common2    */    public function setComment($comment)    {        $this->_comment = $comment;        return $this;    }   /**    * Returns the comment associated with the element    *    * @return   string    */    public function getComment()    {        return $this->_comment;    }   /**    * Checks whether the element has given CSS class    *    * @param    string  Class name    * @return   bool    */    public function hasClass($class)    {        $regex = '/(^|\s)' . preg_quote($class, '/') . '(\s|$)/';        return (bool)preg_match($regex, $this->getAttribute('class'));    }   /**    * Adds the given CSS class(es) to the element    *    * @param    string|array    Class name, multiple class names separated by    *                           whitespace, array of class names    * @return   HTML_Common2    */    public function addClass($class)    {        if (!is_array($class)) {            $class = preg_split('/\s+/', $class, null, PREG_SPLIT_NO_EMPTY);        }        $curClass = preg_split('/\s+/', $this->getAttribute('class'),                               null, PREG_SPLIT_NO_EMPTY);        foreach ($class as $c) {            if (!in_array($c, $curClass)) {                $curClass[] = $c;            }        }        $this->setAttribute('class', implode(' ', $curClass));        return $this;    }   /**    * Removes the given CSS class(es) from the element    *    * @param    string|array    Class name, multiple class names separated by    *                           whitespace, array of class names    * @return   HTML_Common2    */    public function removeClass($class)    {        if (!is_array($class)) {            $class = preg_split('/\s+/', $class, null, PREG_SPLIT_NO_EMPTY);        }        $curClass = array_diff(            preg_split('/\s+/', $this->getAttribute('class'),                       null, PREG_SPLIT_NO_EMPTY),            $class        );        if (0 == count($curClass)) {            $this->removeAttribute('class');        } else {            $this->setAttribute('class', implode(' ', $curClass));        }        return $this;    }   /**    * Returns the HTML representation of the element    *    * This magic method allows using the instances of HTML_Common2 in string    * contexts    *    * @return string    */    abstract public function __toString();   /**    * Called if trying to change an attribute with name in $watchedAttributes    *    * This method is called for each attribute whose name is in the    * $watchedAttributes array and which is being changed by setAttribute(),    * setAttributes() or mergeAttributes() or removed via removeAttribute().    * Note that the operation for the attribute is not carried on after calling    * this method, it is the responsibility of this method to change or remove    * (or not) the attribute.    *    * @param    string  Attribute name    * @param    string  Attribute value, null if attribute is being removed    */    protected function onAttributeChange($name, $value = null)    {    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0
221,matomo-org_matomo_Common2_883, Checks whether the element has given CSS class\n\n @param    string  Class name\n @return   bool\n,Proverava da li element ima zadatu CSS klasu.,"    public function hasClass($class)    {        $regex = '/(^|\s)' . preg_quote($class, '/') . '(\s|$)/';        return (bool)preg_match($regex, $this->getAttribute('class'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
222,matomo-org_matomo_Container_168, Returns the number of elements in the container\\n\\n @return    int\\n,Vraća broj elemenata u kontejneru.,    public function count()    {        return count($this->elements);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
223,matomo-org_matomo_Container_901, Returns an array of elements which name corresponds to element\n\n @param    string  Elements name to find\n @return   array\n,Vrača niz elemenata čije ime odgovara elementu.,    public function getElementsByName($name)    {        $found = array();        foreach ($this->getRecursiveIterator() as $element) {            if ($element->getName() == $name) {                $found[] = $element;            }        }        return $found;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
224,matomo-org_matomo_Controller_921,"Handles an action\n\n This will be called if the page itself does not have a handler for a\n specific action. The method also loads and uses default handlers for\n common actions, if specific ones were not added.\n\n @param    HTML_QuickForm2_Controller_Page form page\n @param    string                          action name\n @throws   HTML_QuickForm2_NotFoundException   if handler for an action is missing\n","Rukuje akcijama. Ovo će se pozvati ukoliko stranica nema način da upravlja određenom akcijom. Takođe, metod učitava i koristi podrazumevane upravljače za česte akcije ukoliko drugi nisu dodati.","public function handle(HTML_QuickForm2_Controller_Page $page, $actionName)    {        if (!isset($this->handlers[$actionName])            && in_array($actionName, array('next', 'back', 'submit', 'display', 'jump'))        ) {            $className = 'HTML_QuickForm2_Controller_Action_' . ucfirst($actionName);            if (!class_exists($className)) {                HTML_QuickForm2_Loader::loadClass($className);            }            $this->addHandler($actionName, new $className());        }        if (isset($this->handlers[$actionName])) {            return $this->handlers[$actionName]->perform($page, $actionName);        } else {            throw new HTML_QuickForm2_NotFoundException(                ""Unhandled action '{$actionName}' for page '{$page->getForm()->getId()}'""            );        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
225,matomo-org_matomo_Controller_929," Merges two arrays\n\n Merges two arrays like the PHP function array_merge_recursive does,\n the difference being that existing integer keys will not be renumbered.\n\n @param    array\n @param    array\n @return   array   resulting array\n",Spaja dva niza. Spaja dva niza kao php funkcija array_merge_recursive. Razlika je što trenutni celobrojni indeksi neće biti ponovno prebrojeni.,"    protected static function arrayMerge($a, $b)    {        foreach ($b as $k => $v) {            if (!is_array($v) || isset($a[$k]) && !is_array($a[$k])) {                $a[$k] = $v;            } else {                $a[$k] = self::arrayMerge(isset($a[$k])? $a[$k]: array(), $v);            }        }        return $a;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
226,matomo-org_matomo_Element_935,Renders the element using the given renderer\n\n @param    HTML_QuickForm2_Renderer    Renderer instance\n @return   HTML_QuickForm2_Renderer\n,Renderuje element pomoću zadatog renderera.,public function render(HTML_QuickForm2_Renderer $renderer)    {        foreach ($this->rules as $rule) {            if ($rule[1] & HTML_QuickForm2_Rule::RUNAT_CLIENT) {                $renderer->getJavascriptBuilder()->addRule($rule[0]);            }        }        $renderer->renderElement($this);        return $renderer;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
227,matomo-org_matomo_Exception_939,"Exception that denotes invalid arguments were passed\n\n One example is trying to create an element of type which is unknown to Factory\n <code>\n try {\n     $el = HTML_QuickForm2_Factory::createElement(\'unknown\');\n } catch (HTML_QuickForm2_InvalidArgumentException $e) {\n     echo $e->getMessage();\n }\n </code>\n This code will output ""Element type \'unknown\' is not known""\n\n @category   HTML\n @package    HTML_QuickForm2\n @version    Release: @package_version@\n",Izuzetak koji označava da su neispravni argumenti dati. Jedan primer je pokušavaj kreiranja elementa čiji je tip nepoznat.,class HTML_QuickForm2_InvalidArgumentException extends HTML_QuickForm2_Exception{},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
228,matomo-org_matomo_ManyVisitsWithGeoIP_1006,Adds one new website and tracks 35 visits from 18 visitors with geolocation using\n free GeoIP databases. The GeoIP databases are downloaded if they do not exist already.\n,Dodaje jedan novi sajt i prati 35 poseta od 18 korisnika sa geolokacijom koristeći besplatne GeoIP baze koje su preuzete ukoliko već ne postoje.,"class ManyVisitsWithGeoIP extends Fixture{    const GEOIP_IMPL_TO_TEST = 'geoip2php';    public $idSite = 1;    public $dateTime = '2010-01-03 11:22:33';    public $ips = array(        '194.57.91.215', // in Besançon, FR (unicode city name)        '::ffff:137.82.130.49', // in British Columbia (mapped ipv4)        '137.82.130.0', // anonymization tests        '137.82.0.0',        '2003:f6:93bf:26f:9ec7:a6ff:fe29:27df', // ipv6 in US (without region or city)        '113.62.1.1', // in Lhasa, Tibet        '151.100.101.92', // in Rome, Italy (using country DB, so only Italy will show)        '103.29.196.229', // in Indonesia, Central Java (Bali)    );    public $userAgents = array(        'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.136 Mobile Safari/537.36',        'Mozilla/5.0 (Linux; U; Android 2.3.7; fr-fr; HTC Desire Build/GRI40; MildWild CM-8.0 JG Stable) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1',        'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.76 Safari/537.36',        'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; GTB6.3; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; OfficeLiveConnector.1.4; OfficeLivePatch.1.3)',        'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; MDDSJS; rv:11.0) like Gecko',        'Mozilla/5.0 (Linux; Android 4.1.1; SGPT13 Build/TJDS0170) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.114 Safari/537.36',        'Mozilla/5.0 (Linux; U; Android 4.3; zh-cn; SM-N9006 Build/JSS15J) AppleWebKit/537.36 (KHTML, like Gecko)Version/4.0 MQQBrowser/5.0 Mobile Safari/537.36',        'Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9.0.14) Gecko/2009090216 Ubuntu/9.04 (jaunty) Firefox/3.0.14'    );    protected $idGoal;    protected $idGoal2;    public function setUp(): void    {        // set option, so tracked data for the past won't get converted        Option::set(GeoIp2::SWITCH_TO_ISO_REGIONS_OPTION_NAME, 1);        $this->setUpWebsitesAndGoals();        $this->setMockLocationProvider();        $this->trackVisits(9, false);        $this->setLocationProvider('GeoIP2-City.mmdb');        $this->trackVisits(2, true, $useLocal = false);        $this->trackVisits(4, true, $useLocal = false, $doBulk = true);        $this->setLocationProvider('GeoIP2-Country.mmdb');        $this->trackVisits(2, true);        $this->trackOtherVisits();        $this->setLocationProvider('GeoIP2-City.mmdb');    }    public function tearDown(): void    {        $this->unsetLocationProvider();    }    private function setUpWebsitesAndGoals()    {        if (!self::siteCreated($idSite = 1)) {            self::createWebsite($this->dateTime, 0, ""Site 1"");        }        if (!self::goalExists($idSite = 1, $idGoal = 1)) {            $this->idGoal = API::getInstance()->addGoal($this->idSite, 'all', 'url', 'http', 'contains', false, 5);        }        if (!self::goalExists($idSite = 1, $idGoal = 2)) {            $this->idGoal2 = API::getInstance()->addGoal($this->idSite, 'two', 'url', 'xxxxxxxxxxxxx', 'contains', false, 5, false, 'twodesc');        }    }    protected $calledCounter = 0;    private function trackVisits($visitorCount, $setIp = false, $useLocal = true, $doBulk = false)    {        $this->calledCounter++;        $dateTime = $this->dateTime;        $idSite = $this->idSite;        if ($useLocal) {            Cache::getTransientCache()->flushAll(); // make sure dimension cache is empty between local tracking runs            Visit::$dimensions = null;        }        // use local tracker so mock location provider can be used        $t = self::getTracker($idSite, $dateTime, $defaultInit = true, $useLocal);        if ($doBulk) {            $t->enableBulkTracking();        }        $t->setTokenAuth(self::getTokenAuth());        for ($i = 0; $i != $visitorCount; ++$i) {            $this->trackVisit($t, $this->calledCounter, $i, $doBulk, array('setIp' => $setIp));        }        if ($doBulk) {            self::checkBulkTrackingResponse($t->doBulkTrack());        }    }    /**     * Insert a new visit into the database.     * @param \MatomoTracker $t          The tracker to record the visits on     * @param int $fixtureCounter       Number of times this fixture has been run      * @param int $visitorCounter       Visitor counter within this execution of the fixture     * @param boolean $doBulk           Should this visit be left for bulk insert later, or processed now?     * @param array $params             Other params as required to set up the visit     */    protected function trackVisit(\MatomoTracker $t, $fixtureCounter, $visitorCounter, $doBulk, array $params)    {        $setIp = isset($params['setIp']) && $params['setIp'];        // NOTE: floor() is so some visits share the same visit ID        $t->setVisitorId( substr(md5(floor($visitorCounter / 2) + $fixtureCounter * 1000), 0, $t::LENGTH_VISITOR_ID));        $userAgent = null;        if ($setIp) {            $userAgent = current($this->userAgents);            $t->setIp(current($this->ips));            $t->setUserAgent($userAgent);            next($this->userAgents);            next($this->ips);        } else {            $t->setIp(""1.2.4.$visitorCounter"");        }        // first visit        $date = Date::factory($this->dateTime)->addDay($visitorCounter);        $t->setForceVisitDateTime($date->getDatetime());        $t->setUrl(""http://piwik.net/grue/lair"");        $t->setCustomVariable(1, 'Cvar 1 name', 'Cvar1 value is ' .$visitorCounter , 'visit');        $t->setCustomVariable(5, 'Cvar 5 name', 'Cvar5 value is ' .$visitorCounter , 'visit');        $t->setCustomVariable(2, 'Cvar 2 PAGE name', 'Cvar2 PAGE value is ' .$visitorCounter, 'page');        $t->setCustomVariable(5, 'Cvar 5 PAGE name', 'Cvar5 PAGE value is ' .$visitorCounter, 'page');        $r = $t->doTrackPageView('It\'s <script> pitch black...');        if (!$doBulk) {            self::checkResponse($r);        }        // second visit        if ($userAgent) {            $t->setUserAgent($userAgent); // unset in doTrack...        }        $date = $date->addHour(1);        $t->setForceVisitDateTime($date->getDatetime());        $t->setUrl(""http://piwik.net/space/quest/iv"");        // Manually record some data        $r = $t->doTrackPageView(""Space Quest XII"");        if (!$doBulk) {            self::checkResponse($r);        }        if ($userAgent) {            $t->setUserAgent($userAgent); // unset in doTrack...        }        // Track site search (for AutoSuggestAPI test)        // Only for half visitors so they don't all have a ""site search"" as last action and some of them have a standard page view as last action        $date = $date->addHour(0.1);        $t->setForceVisitDateTime($date->getDatetime());        if( ($visitorCounter % 2) == 0) {            $r = $t->doTrackSiteSearch('Bring on the party', 'CAT', $visitorCounter*6);        }        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.2);        $t->setForceVisitDateTime($date->getDatetime());        $r = $t->doTrackGoal($this->idGoal2);        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.05);        $t->setForceVisitDateTime($date->getDatetime());        $t->doTrackAction('http://example.org/path/file' . $visitorCounter . '.zip', ""download"" );        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.05);        $t->setForceVisitDateTime($date->getDatetime());        $r = $t->doTrackAction('http://example-outlink.org/' . $visitorCounter . '.html', ""link"" );        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.05);        $t->setForceVisitDateTime($date->getDatetime());        $r = $t->doTrackEvent('Cat' . $visitorCounter,             'Action' . $visitorCounter,             'Name' . $visitorCounter,             345.678 + $visitorCounter        );        if (!$doBulk) {            self::checkResponse($r);        }    }    private function trackOtherVisits()    {        $dateTime = $this->dateTime;        $idSite = $this->idSite;        $t = self::getTracker($idSite, $dateTime, $defaultInit = true);        $t->setVisitorId('fed33392d3a48ab2');        $t->setTokenAuth(self::getTokenAuth());        $t->setForceVisitDateTime(Date::factory($dateTime)->addDay(20)->getDatetime());        $t->setIp('194.57.91.215');        $t->setUserId('userid.email@example.org');        $t->setCountry('us');        $t->setRegion('CA');        $t->setCity('not a city');        $t->setLatitude(1);        $t->setLongitude(2);        $t->setUrl(""http://piwik.net/grue/lair"");        $t->setUrlReferrer('http://google.com/?q=Wikileaks FTW');        $t->setUserAgent(""Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) AppleWebKit/522+ (KHTML, like Gecko) Safari/419.3 (.NET CLR 3.5.30729)"");        self::checkResponse($t->doTrackPageView('It\'s pitch black...'));    }    public function setLocationProvider($file)    {        GeoIp2::$dbNames['loc'] = array($file);        LocationProvider::$providers = null;        LocationProvider::setCurrentProvider(self::GEOIP_IMPL_TO_TEST);        if (LocationProvider::getCurrentProviderId() !== self::GEOIP_IMPL_TO_TEST) {            throw new Exception(""Failed to set the current location provider to '"" . self::GEOIP_IMPL_TO_TEST . ""'."");        }        $possibleFiles = GeoIp2::$dbNames['loc'];        if (GeoIp2::getPathToGeoIpDatabase($possibleFiles) === false) {            throw new Exception(""The GeoIP2 location provider cannot find the '$file' file! Tests will fail."");        }    }    private function setMockLocationProvider()    {        LocationProvider::$providers = array();        LocationProvider::$providers[] = new MockLocationProvider();        LocationProvider::setCurrentProvider('mock_provider');        MockLocationProvider::$locations = array(            self::makeLocation('Stratford-upon-Avon', 'WAR', 'gb', 123.456, 21.321), // template location            // same region, different city, same country            self::makeLocation('Nuneaton and Bedworth', 'WAR', 'gb', $isp = 'comcast.net'),            // same region, city & country (different lat/long)            self::makeLocation('Stratford-upon-Avon', 'WAR', 'gb', 124.456, 22.231, $isp = 'comcast.net'),            // same country, different region & city            self::makeLocation('London', 'LND', 'gb'),            // same country, different region, same city            self::makeLocation('Stratford-upon-Avon', 'KEN', 'gb', $lat = null, $long = null, $isp = 'awesomeisp.com'),            // different country, diff region, same city            self::makeLocation('Stratford-upon-Avon', 'SPE', 'ru'),            // different country, diff region (same as last), different city            self::makeLocation('Hluboká nad Vltavou', 'SPE', 'ru'),            // different country, diff region (same as last), same city            self::makeLocation('Stratford-upon-Avon', '18', 'mk'),            // unknown location            self::makeLocation(null, null, null),        );    }    public static function unsetLocationProvider()    {        try {            LocationProvider::setCurrentProvider('default');        } catch(Exception $e) {            // ignore error        }    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
229,matomo-org_matomo_ProcessedReport_236, Verfies whether the given metric belongs to the given report.\\n\\n @param int $idSite\\n @param string $metric     For example 'nb_visits'\\n @param string $apiMethodUniqueId  For example 'MultiSites_getAll'\\n\\n @return bool\\n,Proverava da li zadata metrika pripada datom izveštaju.,"    public function isValidMetricForReport($metric, $idSite, $apiMethodUniqueId)    {        $translation = $this->translateMetric($metric, $idSite, $apiMethodUniqueId);        return !empty($translation);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
230,nikic_PHP-Parser_Comment_52," Gets the reformatted comment text.\\\\n\\\\n ""Reformatted"" here means that we try to clean up the whitespace at the\\\\n starts of the lines. This is necessary because we receive the comments\\\\n without trailing whitespace on the first line, but with trailing whitespace\\\\n on all subsequent lines.\\\\n\\\\n @return mixed|string\\\\n",Vraća reformatiran tekst komentara. Reformatiran ovde znači da pokušavamo da očistimo razmake ne početku redova. Ovo je neophodno jer primamo koemntare bez pratećih razmaka na prvoj liniji ali sa pratećim razmacima na scim narednim linijama.,    public function getReformattedText() {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
231,pagekit_pagekit_ExtensionTranslateCommand_891," Extracts translateable strings from a given file.\\n\\n @param  string $file Path to the file\\n @return array Array of strings to be translated, grouped by message domain.\\n               Example:\\n               ['messages' = ['Hello' => 'Hello', 'Apple' => 'Apple'], 'customdomain' => ['One' => 'One']]\\n",Izvlači prevodive stringove iz datog fajla.,"protected function extractStrings($file)    {        $content = file_get_contents($file);        // collect pairs of [$domain, string] from all matches        $pairs = [];        // vue matches {{ 'foo' | trans [args] }}        preg_match_all('/({{\s*(\'|"")((?:(?!\2).)+)\2\s*\|\s*trans\s+([^\s]+\s+((\'|"")((?:(?!\6).)+)\6))?.*}})/', $content, $matches);        foreach ($matches[3] as $i => $string) {            $domain = $matches[7][$i] ?: 'messages';            $pairs[] = [$domain, $string];        }        // vue matches {{ 'foo' | transChoice [args] }}        preg_match_all('/({{\s*(\'|"")((?:(?!\2).)+)\2\s*\|\s*transChoice\s+([^\s]+\s+[^\s]+\s+((\'|"")((?:(?!\6).)+)\6))?.*}})/', $content, $matches);        foreach ($matches[3] as $i => $string) {            $domain = $matches[7][$i] ?: 'messages';            $pairs[] = [$domain, $string];        }        // vue, js files        // $trans('foo', [args])        // $transChoice('foo'[, args])        preg_match_all('/\$trans(Choice)?\((\'|"")((?:(?!\2).)+)\2/', $content, $matches);        foreach ($matches[3] as $i => $string) {            $domain = 'messages'; // TODO: allow custom domain            $pairs[] = [$domain, $string];        }        // php matches ...->trans('foo'[, args]) or __('foo'[, args])        // php matches ...->transChoice('foo'[, args]) or _c('foo'[, args])        $this->visitor->traverse([$file]);        foreach ($this->visitor->results as $domain => $strings) {            foreach ($strings as $string => $attr) {                $pairs[] = [$domain, $string];            }        }        // group strings by message domain        $messages = [];        foreach ($pairs as $pair) {            list($domain, $string) = $pair;            if (!isset($messages[$domain])) {                $messages[$domain] = [];            }            $messages[$domain][$string] = $string;        }        return $messages;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
232,paragonie_random_compat_libsodium_735,Generate an unbiased random integer between 0 and a specified value\n /dev/urandom\n\n @param int $upperBoundNonInclusive\n @return int\n,Proizvodi nepristrasan nasumičan ceo broj između 0 i zadate vrednosti.,        function randombytes_uniform(,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
233,paragonie_random_compat_random_int_729, Fetch a random integer between $min and $max inclusive\\n\\n @param int $min\\n @param int $max\\n\\n @throws Exception\\n\\n @return int\\n,Dostavlja nasumičan ceo broj između i uključujući min i max ,"function random_int($min, $max)    {        /**         * Type and input logic checks         *         * If you pass it a float in the range (~PHP_INT_MAX, PHP_INT_MAX)         * (non-inclusive), it will sanely cast it to an int. If you it's equal to         * ~PHP_INT_MAX or PHP_INT_MAX, we let it fail as not an integer. Floats         * lose precision, so the <= and => operators might accidentally let a float         * through.         */        try {            /** @var int $min */            $min = RandomCompat_intval($min);        } catch (TypeError $ex) {            throw new TypeError(                'random_int(): $min must be an integer'            );        }        try {            /** @var int $max */            $max = RandomCompat_intval($max);        } catch (TypeError $ex) {            throw new TypeError(                'random_int(): $max must be an integer'            );        }        /**         * Now that we've verified our weak typing system has given us an integer,         * let's validate the logic then we can move forward with generating random         * integers along a given range.         */        if ($min > $max) {            throw new Error(                'Minimum value must be less than or equal to the maximum value'            );        }        if ($max === $min) {            return (int) $min;        }        /**         * Initialize variables to 0         *         * We want to store:         * $bytes => the number of random bytes we need         * $mask => an integer bitmask (for use with the &) operator         *          so we can minimize the number of discards         */        $attempts = $bits = $bytes = $mask = $valueShift = 0;        /** @var int $attempts */        /** @var int $bits */        /** @var int $bytes */        /** @var int $mask */        /** @var int $valueShift */        /**         * At this point, $range is a positive number greater than 0. It might         * overflow, however, if $max - $min > PHP_INT_MAX. PHP will cast it to         * a float and we will lose some precision.         *         * @var int|float $range         */        $range = $max - $min;        /**         * Test for integer overflow:         */        if (!is_int($range)) {            /**             * Still safely calculate wider ranges.             * Provided by @CodesInChaos, @oittaa             *             * @ref https://gist.github.com/CodesInChaos/03f9ea0b58e8b2b8d435             *             * We use ~0 as a mask in this case because it generates all 1s             *             * @ref https://eval.in/400356 (32-bit)             * @ref http://3v4l.org/XX9r5  (64-bit)             */            $bytes = PHP_INT_SIZE;            /** @var int $mask */            $mask = ~0;        } else {            /**             * $bits is effectively ceil(log($range, 2)) without dealing with             * type juggling             */            while ($range > 0) {                if ($bits % 8 === 0) {                    ++$bytes;                }                ++$bits;                $range >>= 1;                /** @var int $mask */                $mask = $mask << 1 | 1;            }            $valueShift = $min;        }        /** @var int $val */        $val = 0;        /**         * Now that we have our parameters set up, let's begin generating         * random integers until one falls between $min and $max         */        /** @psalm-suppress RedundantCondition */        do {            /**             * The rejection probability is at most 0.5, so this corresponds             * to a failure probability of 2^-128 for a working RNG             */            if ($attempts > 128) {                throw new Exception(                    'random_int: RNG is broken - too many rejections'                );            }            /**             * Let's grab the necessary number of random bytes             */            $randomByteString = random_bytes($bytes);            /**             * Let's turn $randomByteString into an integer             *             * This uses bitwise operators (<< and |) to build an integer             * out of the values extracted from ord()             *             * Example: [9F] | [6D] | [32] | [0C] =>             *   159 + 27904 + 3276800 + 201326592 =>             *   204631455             */            $val &= 0;            for ($i = 0; $i < $bytes; ++$i) {                $val |= ord($randomByteString[$i]) << ($i * 8);            }            /** @var int $val */            /**             * Apply mask             */            $val &= $mask;            $val += $valueShift;            ++$attempts;            /**             * If $val overflows to a floating point number,             * ... or is larger than $max,             * ... or smaller than $min,             * then try again.             */        } while (!is_int($val) || $val > $max || $val < $min);        return (int) $val;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
234,phacility_phabricator_AphrontRequest_648," Determine if security policy rules will allow cookies to be set when\\n responding to the request.\\n\\n @return bool True if setCookie() will succeed. If this method returns\\n              false, setCookie() will throw.\\n\\n @task cookie\\n",Proveri da li bezbednosna politika dozvoljava postavljanje kolačića prilikom odgovora na zahtev.,  public function canSetCookies() {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
235,phacility_phabricator_AphrontRequest_649," Set a cookie which does not expire for a long time.\\n\\n To set a temporary cookie, see @{method:setTemporaryCookie}.\\n\\n @param string  Cookie name.\\n @param string  Cookie value.\\n @return this\\n @task cookie\\n",Postavi kolačić koji neće isteći dugo vremena. Za postavljanje privremenog kolačića pogledaj metod setTemporaryCookie,"  public function setCookie($name, $value) {",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
236,phacility_phabricator_AphrontRequest_650," Set a cookie which expires soon.\n\n To set a durable cookie, see @{method:setCookie}.\n\n @param string  Cookie name.\n @param string  Cookie value.\n @return this\n @task cookie\n",Postavi kolačić koji će uskoro isteći. Za postavljanje dugotrajnog kolačića pogledaj setCookie.,"  public function setTemporaryCookie($name, $value) {",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
237,phacility_phabricator_Figlet_519, Function loads one character in the internal array from file\n\n @param resource &$fp handle of font file\n\n @return mixed lines of the character or false if foef occured\n @access private\n,Funkcija učitava jedan karakter u svoj niz iz fajla.,"function _char(&$fp)    {        $out = array();        for ($i = 0; $i < $this->height; $i++) {            if (feof($fp)) {                return false;            }            $line = rtrim(fgets($fp, 2048), ""\r\n"");            if (preg_match('/(.){1,2}$/', $line, $r)) {                $line = str_replace($r[1], '', $line);            }            $line .= ""\x00"";            $out[] = $line;        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
238,phacility_phabricator_class.phpmailer-lite_525,"Check that a string looks roughly like an email address should\n Static so it can be used without instantiation\n Tries to use PHP built-in validator in the filter extension (from PHP 5.2), falls back to a reasonably competent regex validator\n Conforms approximately to RFC2822\n @link http://www.hexillion.com/samples/#Regex Original pattern found here\n @param string $address The email address to check\n @return boolean\n @static\n @access public\n","Proveri da li string izgleda otprilike kako bi email adresa trebalo da izgleda. Statičan kako bi mogao da se koristi bez instanciranja. Pokušava da koristi ugrađeni validator, ali u slučaju da ne može da ga koristi, uzima razumno složen regex validator.","public static function ValidateAddress($address) {    if (function_exists('filter_var')) { //Introduced in PHP 5.2      if(filter_var($address, FILTER_VALIDATE_EMAIL) === FALSE) {        return false;      } else {        return true;      }    } else {      return preg_match('/^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!\.)){0,61}[a-zA-Z0-9_-]?\.)+[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!$)){0,61}[a-zA-Z0-9_]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/', $address);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
239,phacility_phabricator_class.phpmailer-lite_536, Assembles the message body.  Returns an empty string on failure.\\n @access public\\n @return string The assembled message body\\n,"Sastavlja telo poruke. Ako ne uspe, vraća prazan string.",  public function CreateBody() {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
240,phacility_phabricator_class.phpmailer-lite_540,  Returns a formatted header line.\n @access public\n @return string\n,Vraća formatirano zaglavlje.,"  public function HeaderLine($name, $value) {",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
241,phacility_phabricator_class.phpmailer-lite_543," Attaches all fs, string, and binary attachments to the message.\\n Returns an empty string on failure.\\n @access private\\n @return string\\n","Spaja sve funkcije, stringove i binarne priloge u poruci.",  private function AttachAll() {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
242,phacility_phabricator_class.phpmailer-lite_544, Checks if a string contains multibyte characters.\n @access public\n @param string $str multi-byte text to wrap encode\n @return bool\n,Proverava da li string sadrži višebajtske karaktere,"  public function HasMultiBytes($str) {    if (function_exists('mb_strlen')) {      return (strlen($str) > mb_strlen($str, $this->CharSet));    } else { // Assume no multibytes (we can't handle without mbstring functions anyway)      return false;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
243,phacility_phabricator_diff_match_patch_448,Compute the number of bits in an int.\n The normal answer for JavaScript is 32.\n @return {number} Max bits\n,Računa broj bitova u celom broju. Uobičajen odgovor za javascript je 32,function getMaxBits() {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
244,phacility_phabricator_diff_match_patch_451, Split a text into an array of strings.  Reduce the texts to a string of\n hashes where each Unicode character represents one line.\n Modifies linearray and linehash through being a closure.\n @param {string} text String to encode\n @return {string} Encoded string\n @private\n,Deli tekst u niz stringova. Zatim smanjuje tekst u string hešova gde svaki karakter odgovara jednoj liniji.,"function diff_linesToCharsMunge($text, &$lineArray, &$lineHash) {",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
245,phacility_phabricator_diff_match_patch_453,Explore the intersection points between the two texts.\n @param {string} text1 Old string to be diffed.\n @param {string} text2 New string to be diffed.\n @return {Array.<Array.<number|string>>?} Array of diff tuples or null if no\n     diff available.\n @private\n,Razmatra presek između dva teksta.,"function diff_map($text1, $text2) {",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
246,phacility_phabricator_diff_match_patch_456,Determine the common prefix of two strings\\n @param {string} text1 First string.\\n @param {string} text2 Second string.\\n @return {number} The number of characters common to the start of each\\n     string.\\n,Nalazi zajednički prefiks za dva stringa.,"function diff_commonPrefix($text1, $text2) {for ($i = 0; 1; $i++) {$t1 = mb_substr($text1, $i, 1);$t2 = mb_substr($text2, $i, 1);if($t1==='' || $t2==='' || $t1 !== $t2 ){return $i;}}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
247,phacility_phabricator_diff_match_patch_466, Convert a diff array into a pretty HTML report.\n @param {Array.<Array.<number|string>>} diffs Array of diff tuples.\n @return {string} HTML representation.\n,Prevara razliku nizova u lep HTML izveštaj,function diff_prettyHtml($diffs) {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
248,phacility_phabricator_diff_match_patch_469," Compute the Levenshtein distance; the number of inserted, deleted or\\n substituted characters.\\n @param {Array.<Array.<number|string>>} diffs Array of diff tuples.\\n @return {number} Number of changes.\\n","Računa levenshteinovu udaljenost. To je broj dodatih, obrisanih ili zamenjenih karaktera.",function diff_levenshtein($diffs) {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
249,phacility_phabricator_diff_match_patch_470,"Crush the diff into an encoded string which describes the operations\n required to transform text1 into text2.\n E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n Operations are tab-separated.  Inserted text is escaped using %xx notation.\n @param {Array.<Array.<number|string>>} diffs Array of diff tuples.\n @return {string} Delta text.\n","Predstavlja razliku kao enkodovan string koji opisuje operacije potrebne da se tekst1 transformiše u tekst2. Na primer =3\\t-2\\t+ing znači zadrži 3 karaktera, obriši dva karaktera i dodaj ing. Operacije su odvojene tabovima.",function diff_toDelta($diffs) {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
250,phacility_phabricator_diff_match_patch_471,"Given the original text1, and an encoded string which describes the\n operations required to transform text1 into text2, compute the full diff.\n @param {string} text1 Source string for the diff.\n @param {string} delta Delta text.\n @return {Array.<Array.<number|string>>} Array of diff tuples.\n @throws {Error} If invalid input.\n",Za originalni tekst i enkodiran string razlika računa razliku između dva teksta.,"function diff_fromDelta($text1, $delta) {",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
251,phalcon_cphalcon_Optimized_172, Delete all files in target directories\n,Obriši sve fajlove u ciljnim direktorijima.,    public function cleanBuildDirectories()    {        foreach ($this->settings as $setting) {            Util::cleanDirectory($setting['dir']);        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
252,phalcon_cphalcon_Util_1227, Recursively deletes everything in the directory\\n\\n @param string $dir\\n,Rekurzivno briše sve u direktorijumu.,    public static function cleanDirectory(string $dir): void    {        $iterator = new DirectoryIterator($dir);        foreach ($iterator as $entry) {            /** @var $entry DirectoryIterator */            if ($entry->isDot() || $entry->getBasename() == 'tests') {                continue;            }            if ($entry->isDir() && !$entry->isLink()) {                self::cleanDirectory($entry->getPathname());                rmdir($entry->getPathname());            } else {                if (is_writable($dir)) {                    unlink($entry->getPathname());                }            }        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
253,php-fig_http-message_MessageInterface_2409,"Retrieves the HTTP protocol version as a string.\\n\\n The string MUST contain only the HTTP version number (e.g., ""1.1"", ""1.0"").\\n\\n @return string HTTP protocol version.\\n","Dohvata HTTP protokol verziju kao string. String mora da sadrži samo verziju HTTP-a, na primer 1.1 ili 1.0.",    public function getProtocolVersion();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
254,php-fig_http-message_MessageInterface_2412, Checks if a header exists by the given case-insensitive name.\\n\\n @param string $name Case-insensitive header field name.\\n @return bool Returns true if any header names match the given header\\n     name using a case-insensitive string comparison. Returns false if\\n     no matching header name is found in the message.\\n,Proverava da li zaglavlje postoji za dato ime nevezano za mala ili velika slova.,    public function hasHeader($name);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
255,php-fig_http-message_ResponseInterface_2425,Gets the response status code.\n\n The status code is a 3-digit integer result code of the server's attempt\n to understand and satisfy the request.\n\n @return int Status code.\n,Vraća status odgovora. Status je trocifreni ceo broj i rezultat je pokušaja servera da razume i zadovolji zahtev.,    public function getStatusCode();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
256,predis_predis_Client_2129, Closes the underlying connection and disconnects from the server.\n,Zatvara osnovnu vezu i otkačuje se sa servera.,    public function disconnect()    {        $this->connection->disconnect();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
257,predis_predis_Client_2131, Returns the current state of the underlying connection.\n\n @return bool\n,Vraća trenutno stanje osnovne veze.,    public function isConnected()    {        return $this->connection->isConnected();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
258,predis_predis_CommunicationException_2151, Base exception class for network-related errors.\n\n @author Daniele Alessandri <suppakilla@gmail.com>\n,Osnovna klasa izuzetaka za greške vezane za mrežu.,"abstract class CommunicationException extends PredisException{    private $connection;    /**     * @param NodeConnectionInterface $connection     Connection that generated the exception.     * @param string                  $message        Error message.     * @param int                     $code           Error code.     * @param \Exception              $innerException Inner exception for wrapping the original error.     */    public function __construct(        NodeConnectionInterface $connection,        $message = null,        $code = null,        \Exception $innerException = null    ) {        $this->connection = $connection;        parent::__construct($message, $code, $innerException);    }    /**     * Gets the connection that generated the exception.     *     * @return NodeConnectionInterface     */    public function getConnection()    {        return $this->connection;    }    /**     * Indicates if the receiver should reset the underlying connection.     *     * @return bool     */    public function shouldResetConnection()    {        return true;    }    /**     * Helper method to handle exceptions generated by a connection object.     *     * @param CommunicationException $exception Exception.     *     * @throws CommunicationException     */    public static function handle(CommunicationException $exception)    {        if ($exception->shouldResetConnection()) {            $connection = $exception->getConnection();            if ($connection->isConnected()) {                $connection->disconnect();            }        }        throw $exception;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
259,sebastianbergmann_comparator_ArrayComparator_2322, Compares arrays for equality.\\n\\n Arrays are equal if they contain the same key-value pairs.\\n The order of the keys does not matter.\\n The types of key-value pairs do not matter.\\n,Poredi nizove. Nizovi su jednaki ako sadrže iste ključ-vrednost parove. Redosled ključeva nije bitan. Tipovi ključ-vrednost parova nisu bitni.,"class ArrayComparator extends Comparator{    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return is_array($expected) && is_array($actual);    }    /**     * Asserts that two arrays are equal.     *     * @param mixed $expected     First value to compare     * @param mixed $actual       Second value to compare     * @param float $delta        Allowed numerical distance between two values to consider them equal     * @param bool  $canonicalize Arrays are sorted before comparison when set to true     * @param bool  $ignoreCase   Case is ignored when set to true     * @param array $processed    List of already processed elements (used to prevent infinite recursion)     *     * @throws ComparisonFailure     */    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false, array &$processed = [])/*: void*/    {        if ($canonicalize) {            sort($expected);            sort($actual);        }        $remaining        = $actual;        $actualAsString   = ""Array (\n"";        $expectedAsString = ""Array (\n"";        $equal            = true;        foreach ($expected as $key => $value) {            unset($remaining[$key]);            if (!array_key_exists($key, $actual)) {                $expectedAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $this->exporter->shortenedExport($value)                );                $equal = false;                continue;            }            try {                $comparator = $this->factory->getComparatorFor($value, $actual[$key]);                $comparator->assertEquals($value, $actual[$key], $delta, $canonicalize, $ignoreCase, $processed);                $expectedAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $this->exporter->shortenedExport($value)                );                $actualAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $this->exporter->shortenedExport($actual[$key])                );            } catch (ComparisonFailure $e) {                $expectedAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $e->getExpectedAsString() ? $this->indent($e->getExpectedAsString()) : $this->exporter->shortenedExport($e->getExpected())                );                $actualAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $e->getActualAsString() ? $this->indent($e->getActualAsString()) : $this->exporter->shortenedExport($e->getActual())                );                $equal = false;            }        }        foreach ($remaining as $key => $value) {            $actualAsString .= sprintf(                ""    %s => %s\n"",                $this->exporter->export($key),                $this->exporter->shortenedExport($value)            );            $equal = false;        }        $expectedAsString .= ')';        $actualAsString .= ')';        if (!$equal) {            throw new ComparisonFailure(                $expected,                $actual,                $expectedAsString,                $actualAsString,                false,                'Failed asserting that two arrays are equal.'            );        }    }    protected function indent($lines)    {        return trim(str_replace(""\n"", ""\n    "", $lines));    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
260,sebastianbergmann_comparator_DateTimeComparator_2336,Returns an ISO 8601 formatted string representation of a datetime or\n 'Invalid DateTimeInterface object' if the provided DateTimeInterface was not properly\n initialized.\n,"Vraća ISO 8601 formatiran string koji predstavlja datum i vreme, odnosno ‘Invalid DateTimeInterface object’ ukoliko dat DateTimeInterface nije pravilno inicijalizovan.",    private function dateTimeToString(DateTimeInterface $datetime): string    {        $string = $datetime->format('Y-m-d\TH:i:s.uO');        return $string ?: 'Invalid DateTimeInterface object';    },0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
261,sebastianbergmann_exporter_Exporter_1036," Converts an object to an array containing all of its private, protected\\\\n and public properties.\\\\n","Pretvara objekat u niz koji sadrži sve privatne, zaštićene i javne osobine.","public function toArray(mixed $value): array    {        if (!is_object($value)) {            return (array) $value;        }        $array = [];        foreach ((array) $value as $key => $val) {            // Exception traces commonly reference hundreds to thousands of            // objects currently loaded in memory. Including them in the result            // has a severe negative performance impact.            if (""\0Error\0trace"" === $key || ""\0Exception\0trace"" === $key) {                continue;            }            // properties are transformed to keys in the following way:            // private   $property => ""\0Classname\0property""            // protected $property => ""\0*\0property""            // public    $property => ""property""            if (preg_match('/^\0.+\0(.+)$/', (string) $key, $matches)) {                $key = $matches[1];            }            // See https://github.com/php/php-src/commit/5721132            if ($key === ""\0gcdata"") {                continue;            }            $array[$key] = $val;        }        // Some internal classes like SplObjectStorage don't work with the        // above (fast) mechanism nor with reflection in Zend.        // Format the output similarly to print_r() in this case        if ($value instanceof SplObjectStorage) {            foreach ($value as $_value) {                $array[spl_object_hash($_value)] = [                    'obj' => $_value,                    'inf' => $value->getInfo(),                ];            }        }        return $array;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
262,serbanghita_Mobile-Detect_Mobile_Detect_1133," Retrieves a particular header. If it doesn\\\'t exist, no exception/error is caused.\\n Simply null is returned.\\n\\n @param string $header The name of the header to retrieve. Can be HTTP compliant such as\\n                       ""User-Agent"" or ""X-Device-User-Agent"" or can be php-esque with the\\n                       all-caps, HTTP_ prefixed, underscore seperated awesomeness.\\n\\n @return string|null The value of the header.\\n","Vraća određeno zaglavlje. Ako ne postoji, ne prijavljuje se greška ili izuzetak već se jednostavno vrati null vrednost.","    public function getHttpHeader($header)    {        // are we using PHP-flavored headers?        if (strpos($header, '_') === false) {            $header = str_replace('-', '_', $header);            $header = strtoupper($header);        }        // test the alternate, too        $altHeader = 'HTTP_' . $header;        //Test both the regular and the HTTP_ prefix        if (isset($this->httpHeaders[$header])) {            return $this->httpHeaders[$header];        } elseif (isset($this->httpHeaders[$altHeader])) {            return $this->httpHeaders[$altHeader];        }        return null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
263,serbanghita_Mobile-Detect_Mobile_Detect_1147, Check the HTTP headers for signs of mobile.\\n This is the fastest mobile check possible; it's used\\n inside isMobile() method.\\n\\n @return bool\\n,Proveri HTTP zaglavlja za znak mobilnosti. Ovo je najvbrža provera mobilnosti.,"    public function checkHttpHeadersForMobile()    {        foreach ($this->getMobileHeaders() as $mobileHeader => $matchType) {            if (isset($this->httpHeaders[$mobileHeader])) {                if (isset($matchType['matches']) && is_array($matchType['matches'])) {                    foreach ($matchType['matches'] as $_match) {                        if (strpos($this->httpHeaders[$mobileHeader], $_match) !== false) {                            return true;                        }                    }                    return false;                } else {                    return true;                }            }        }        return false;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
264,slimphp_Slim_PhpFunctionOverrides_2774, Have headers been sent?\n\n @return false\n,Da li su zaglavlja već poslata?,function headers_sent(){    return false;},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
265,slimphp_Slim_PhpFunctionOverrides_2775, Allows the mocking of invalid HTTP states.\n\n @return int\n,Omogućava oponašanje nevažećih HTTP stanja,function connection_status(){    if (isset($GLOBALS['connection_status_return'])) {        return $GLOBALS['connection_status_return'];    }    return \connection_status();},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
266,squizlabs_PHP_CodeSniffer_File_925, Remove vars stored in this file that are no longer required.\\\\n\\\\n @return void\\\\n,Uklanja promenljive sačuvane u ovom fajlu koje više nisu potrebne.,    public function cleanUp()    {        $this->listenerTimes = null;        $this->content       = null;        $this->tokens        = null;        $this->metricTokens  = null;        $this->tokenizer     = null;        $this->fixer         = null;        $this->config        = null;        $this->ruleset       = null;    }//end cleanUp(),0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
267,squizlabs_PHP_CodeSniffer_Runner_912," Converts all PHP errors into exceptions.\\\\n\\\\n This method forces a sniff to stop processing if it is not\\\\n able to handle a specific piece of code, instead of continuing\\\\n and potentially getting into a loop.\\\\n\\\\n @param int    $code    The level of error raised.\\\\n @param string $message The error message.\\\\n @param string $file    The path of the file that raised the error.\\\\n @param int    $line    The line number the error was raised at.\\\\n\\\\n @return void\\\\n @throws \\\\\\\\PHP_CodeSniffer\\\\\\\\Exceptions\\\\\\\\RuntimeException\\\\n",Pretvara sve PHP greške u izuzetke. Ovaj metod prisiljava sniff da prestane procesiranje ako nije u stanju da rukuje specifičnim delom koda umesto da nastavlja i potencijalno upadne u petlju.,"public function handleErrors($code, $message, $file, $line)    {        if ((error_reporting() & $code) === 0) {            // This type of error is being muted.            return true;        }        throw new RuntimeException(""$message in $file on line $line"");    }//end handleErrors()",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
268,swiftmailer_swiftmailer_AddressEncoder_1289, Encodes an email address.\\n\\n @throws Swift_AddressEncoderException if the email cannot be represented in\\n                                       the encoding implemented by this class\\n,Enkodira email adresu.,    public function encodeString(string $address): string;,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
269,swiftmailer_swiftmailer_CharacterReader_1621,Returns an integer which specifies how many more bytes to read.\n\n A positive integer indicates the number of more bytes to fetch before invoking\n this method again.\n\n A value of zero means this is already a valid character.\n A value of -1 means this cannot possibly be a valid character.\n\n @param int[] $bytes\n @param int   $size\n\n @return int\n,"Vraća ceo broj koji govori koliko je još bajtova ostalo da se pročita. Pozitivan ceo broj govori koliko još bajtova treba dohvatiti pre ponovnog poziva ovog metoda. Vrednost nula govori da je u pitanju validan karakter, a vrednost -1 govori da nema šanse da je u pitanju validan karakter.","    public function validateByteSequence($bytes, $size);",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
270,symfony_debug_ExceptionHandler_1747, Gets the HTML content associated with the given exception.\n\n @return string The content as a string\n,Dohvata HTML sadržaj koji odgovara datom izuzetku.,"public function getContent(FlattenException $exception)    {        switch ($exception->getStatusCode()) {            case 404:                $title = 'Sorry, the page you are looking for could not be found.';                break;            default:                $title = $this->debug ? $this->escapeHtml($exception->getMessage()) : 'Whoops, looks like something went wrong.';        }        if (!$this->debug) {            return <<<EOF                <div class=""container"">                    <h1>$title</h1>                </div>EOF;        }        $content = '';        try {            $count = \count($exception->getAllPrevious());            $total = $count + 1;            foreach ($exception->toArray() as $position => $e) {                $ind = $count - $position + 1;                $class = $this->formatClass($e['class']);                $message = nl2br($this->escapeHtml($e['message']));                $content .= sprintf(<<<'EOF'                    <div class=""trace trace-as-html"">                        <table class=""trace-details"">                            <thead class=""trace-head""><tr><th>                                <h3 class=""trace-class"">                                    <span class=""text-muted"">(%d/%d)</span>                                    <span class=""exception_title"">%s</span>                                </h3>                                <p class=""break-long-words trace-message"">%s</p>                            </th></tr></thead>                            <tbody>EOF                    , $ind, $total, $class, $message);                foreach ($e['trace'] as $trace) {                    $content .= '<tr><td>';                    if ($trace['function']) {                        $content .= sprintf('at <span class=""trace-class"">%s</span><span class=""trace-type"">%s</span><span class=""trace-method"">%s</span>', $this->formatClass($trace['class']), $trace['type'], $trace['function']);                        if (isset($trace['args'])) {                            $content .= sprintf('(<span class=""trace-arguments"">%s</span>)', $this->formatArgs($trace['args']));                        }                    }                    if (isset($trace['file']) && isset($trace['line'])) {                        $content .= $this->formatPath($trace['file'], $trace['line']);                    }                    $content .= ""</td></tr>\n"";                }                $content .= ""</tbody>\n</table>\n</div>\n"";            }        } catch (\Exception $e) {            // something nasty happened and we cannot throw an exception anymore            if ($this->debug) {                $e = FlattenException::create($e);                $title = sprintf('Exception thrown when handling an exception (%s: %s)', $e->getClass(), $this->escapeHtml($e->getMessage()));            } else {                $title = 'Whoops, looks like something went wrong.';            }        }        $symfonyGhostImageContents = $this->getSymfonyGhostAsSvg();        return <<<EOF            <div class=""exception-summary"">                <div class=""container"">                    <div class=""exception-message-wrapper"">                        <h1 class=""break-long-words exception-message"">$title</h1>                        <div class=""exception-illustration hidden-xs-down"">$symfonyGhostImageContents</div>                    </div>                </div>            </div>            <div class=""container"">                $content            </div>EOF;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
271,symfony_debug_ExceptionHandler_1750, HTML-encodes a string.\n,Enkodira string za HTML.,"    private function escapeHtml(string $str): string    {        return htmlspecialchars($str, \ENT_COMPAT | \ENT_SUBSTITUTE, $this->charset);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
272,symfony_finder_Finder_1094," Excludes ""hidden"" directories and files (starting with a dot).\n\n This option is enabled by default.\n\n @return $this\n\n @see ExcludeDirectoryFilterIterator\n",Odstranjuje skrivene direktorijume i fajlove (sve koji počinju tačkom). Ova opcija je podrazumevano omogućena.,    public function ignoreDotFiles(bool $ignoreDotFiles)    {        if ($ignoreDotFiles) {            $this->ignore |= static::IGNORE_DOT_FILES;        } else {            $this->ignore &= ~static::IGNORE_DOT_FILES;        }        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
273,symfony_finder_Finder_1099," Sorts files and directories by type (directories before files), then by name.\n\n This can be slow as all the matching files and directories must be retrieved for comparison.\n\n @return $this\n\n @see SortableIterator\n","Sortira fajlove i direktorijume po tipu (direktorijumi pre fajlova), pa onda po imenu. Ovo može biti sporo jer svi fajlovi i direktorijumi moraju biti dohvaćeni zarad poređenja.",    public function sortByType()    {        $this->sort = Iterator\SortableIterator::SORT_BY_TYPE;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
274,symfony_finder_MultiplePcreFilterIterator_1155," Checks whether the string is accepted by the regex filters.\n\n If there is no regexps defined in the class, this method will accept the string.\n Such case can be handled by child classes before calling the method if they want to\n apply a different behavior.\n\n @return bool\n","Proverava da li je string prihvaćen od regex filtera. Ako nema regexps definisanih u klasi, ovaj metod će prihvatiti string. ","    protected function isAccepted(string $string)    {        // should at least not match one rule to exclude        foreach ($this->noMatchRegexps as $regex) {            if (preg_match($regex, $string)) {                return false;            }        }        // should at least match one rule        if ($this->matchRegexps) {            foreach ($this->matchRegexps as $regex) {                if (preg_match($regex, $string)) {                    return true;                }            }            return false;        }        // If there is no match rules, the file is accepted        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
275,symfony_finder_MultiplePcreFilterIterator_1156, Checks whether the string is a regex.\n\n @return bool\n,Proverava da li je string regex.,"protected function isRegex(string $str)    {        if (preg_match('/^(.{3,}?)[imsxuADU]*$/', $str, $m)) {            $start = substr($m[1], 0, 1);            $end = substr($m[1], -1);            if ($start === $end) {                return !preg_match('/[*?[:alnum:] \\\\]/', $start);            }            foreach ([['{', '}'], ['(', ')'], ['[', ']'], ['<', '>']] as $delimiters) {                if ($start === $delimiters[0] && $end === $delimiters[1]) {                    return true;                }            }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
276,symfony_finder_MultiplePcreFilterIterator_1157, Converts string into regexp.\n\n @return string\n,Pretvara string u regexp.,    abstract protected function toRegex(string $str);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
277,symfony_finder_SplFileInfo_1119, Returns the contents of the file.\n\n @return string the contents of the file\n\n @throws \\RuntimeException\n,Vraća sadržaj fajla.,"    public function getContents()    {        set_error_handler(function ($type, $msg) use (&$error) { $error = $msg; });        $content = file_get_contents($this->getPathname());        restore_error_handler();        if (false === $content) {            throw new \RuntimeException($error);        }        return $content;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
278,symfony_finder_SplFileInfo_383, Returns the relative path name.\\n\\n This path contains the file name.\\n\\n @return string the relative path name\\n,Vraća relativan naziv putanje. Ovaj naziv sadrži naziv fajla.,    public function getRelativePathname()    {        return $this->relativePathname;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
279,symfony_http-foundation_AcceptHeaderItem_9687, Returns header value's string representation.\n\n @return string\n,Vraća vrednost zaglavlja u obliku stringa.,"public function __toString()    {        $string = $this->value.($this->quality < 1 ? ';q='.$this->quality : '');        if (\count($this->attributes) > 0) {            $string .= '; '.HeaderUtils::toString($this->attributes, ';');        }        return $string;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
280,symfony_http-foundation_AcceptHeader_8728, Tests if header has given value.\n\n @return bool\n,Proverava da li zaglavlje sadrži datu vrednost.,    public function has(string $value)    {        return isset($this->items[$value]);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
281,symfony_http-foundation_IpUtils_8806,Anonymizes an IP/IPv6.\n\n Removes the last byte for v4 and the last 8 bytes for v6 IPs\n,"Anonimizira IP/IPv6. Uklanja poslednji bajt za v4, a poslednjih 8 bajtova za v6 IP-jeve.","public static function anonymize(string $ip): string    {        $wrappedIPv6 = false;        if ('[' === substr($ip, 0, 1) && ']' === substr($ip, -1, 1)) {            $wrappedIPv6 = true;            $ip = substr($ip, 1, -1);        }        $packedAddress = inet_pton($ip);        if (4 === \strlen($packedAddress)) {            $mask = '255.255.255.0';        } elseif ($ip === inet_ntop($packedAddress & inet_pton('::ffff:ffff:ffff'))) {            $mask = '::ffff:ffff:ff00';        } elseif ($ip === inet_ntop($packedAddress & inet_pton('::ffff:ffff'))) {            $mask = '::ffff:ff00';        } else {            $mask = 'ffff:ffff:ffff:ffff:0000:0000:0000:0000';        }        $ip = inet_ntop($packedAddress & inet_pton($mask));        if ($wrappedIPv6) {            $ip = '['.$ip.']';        }        return $ip;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
282,symfony_http-foundation_JsonResponse_7891, Returns options used while encoding data to JSON.\n\n @return int\n,Vraća koje su opcije korišćene kada su podaci enkodirani u JSON.,    public function getEncodingOptions()    {        return $this->encodingOptions;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
283,symfony_http-foundation_JsonResponse_9757, Response represents an HTTP response in JSON format.\n\n Note that this class does not force the returned JSON content to be an\n object. It is however recommended that you do return an object as it\n protects yourself against XSSI and JSON-JavaScript Hijacking.\n\n @see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside\n\n @author Igor Wiedler <igor@wiedler.ch>\n,"Predstava HTTP odgovora u JSON formatu. Bitno je naglasiti da ova klasa ne zahteva da JSON sadržaj bude objekat, ali je preporučljivo da vratite objekat kako bi se izbeglo XSSI i JSON-JavaScript otimanje.","class JsonResponse extends Response{    protected $data;    protected $callback;    // Encode <, >, ', &, and "" characters in the JSON, making it also safe to be embedded into HTML.    // 15 === JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT    public const DEFAULT_ENCODING_OPTIONS = 15;    protected $encodingOptions = self::DEFAULT_ENCODING_OPTIONS;    /**     * @param mixed $data    The response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     * @param bool  $json    If the data is already a JSON string     */    public function __construct($data = null, int $status = 200, array $headers = [], bool $json = false)    {        parent::__construct('', $status, $headers);        if ($json && !\is_string($data) && !is_numeric($data) && !\is_callable([$data, '__toString'])) {            throw new \TypeError(sprintf('""%s"": If $json is set to true, argument $data must be a string or object implementing __toString(), ""%s"" given.', __METHOD__, get_debug_type($data)));        }        if (null === $data) {            $data = new \ArrayObject();        }        $json ? $this->setJson($data) : $this->setData($data);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::create(['key' => 'value'])     *         ->setSharedMaxAge(300);     *     * @param mixed $data    The JSON response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     *     * @return static     *     * @deprecated since Symfony 5.1, use __construct() instead.     */    public static function create($data = null, int $status = 200, array $headers = [])    {        trigger_deprecation('symfony/http-foundation', '5.1', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($data, $status, $headers);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::fromJsonString('{""key"": ""value""}')     *         ->setSharedMaxAge(300);     *     * @param string $data    The JSON response string     * @param int    $status  The response status code     * @param array  $headers An array of response headers     *     * @return static     */    public static function fromJsonString(string $data, int $status = 200, array $headers = [])    {        return new static($data, $status, $headers, true);    }    /**     * Sets the JSONP callback.     *     * @param string|null $callback The JSONP callback or null to use none     *     * @return $this     *     * @throws \InvalidArgumentException When the callback name is not valid     */    public function setCallback(string $callback = null)    {        if (null !== $callback) {            // partially taken from https://geekality.net/2011/08/03/valid-javascript-identifier/            // partially taken from https://github.com/willdurand/JsonpCallbackValidator            //      JsonpCallbackValidator is released under the MIT License. See https://github.com/willdurand/JsonpCallbackValidator/blob/v1.1.0/LICENSE for details.            //      (c) William Durand <william.durand1@gmail.com>            $pattern = '/^[$_\p{L}][$_\p{L}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\x{200C}\x{200D}]*(?:\[(?:""(?:\\\.|[^""\\\])*""|\'(?:\\\.|[^\'\\\])*\'|\d+)\])*?$/u';            $reserved = [                'break', 'do', 'instanceof', 'typeof', 'case', 'else', 'new', 'var', 'catch', 'finally', 'return', 'void', 'continue', 'for', 'switch', 'while',                'debugger', 'function', 'this', 'with', 'default', 'if', 'throw', 'delete', 'in', 'try', 'class', 'enum', 'extends', 'super',  'const', 'export',                'import', 'implements', 'let', 'private', 'public', 'yield', 'interface', 'package', 'protected', 'static', 'null', 'true', 'false',            ];            $parts = explode('.', $callback);            foreach ($parts as $part) {                if (!preg_match($pattern, $part) || \in_array($part, $reserved, true)) {                    throw new \InvalidArgumentException('The callback name is not valid.');                }            }        }        $this->callback = $callback;        return $this->update();    }    /**     * Sets a raw string containing a JSON document to be sent.     *     * @return $this     */    public function setJson(string $json)    {        $this->data = $json;        return $this->update();    }    /**     * Sets the data to be sent as JSON.     *     * @param mixed $data     *     * @return $this     *     * @throws \InvalidArgumentException     */    public function setData($data = [])    {        try {            $data = json_encode($data, $this->encodingOptions);        } catch (\Exception $e) {            if ('Exception' === \get_class($e) && 0 === strpos($e->getMessage(), 'Failed calling ')) {                throw $e->getPrevious() ?: $e;            }            throw $e;        }        if (\PHP_VERSION_ID >= 70300 && (\JSON_THROW_ON_ERROR & $this->encodingOptions)) {            return $this->setJson($data);        }        if (\JSON_ERROR_NONE !== json_last_error()) {            throw new \InvalidArgumentException(json_last_error_msg());        }        return $this->setJson($data);    }    /**     * Returns options used while encoding data to JSON.     *     * @return int     */    public function getEncodingOptions()    {        return $this->encodingOptions;    }    /**     * Sets options used while encoding data to JSON.     *     * @return $this     */    public function setEncodingOptions(int $encodingOptions)    {        $this->encodingOptions = $encodingOptions;        return $this->setData(json_decode($this->data));    }    /**     * Updates the content and headers according to the JSON data and callback.     *     * @return $this     */    protected function update()    {        if (null !== $this->callback) {            // Not using application/javascript for compatibility reasons with older browsers.            $this->headers->set('Content-Type', 'text/javascript');            return $this->setContent(sprintf('/**/%s(%s);', $this->callback, $this->data));        }        // Only set the header when there is none or when it equals 'text/javascript' (from a previous update with callback)        // in order to not overwrite a custom definition.        if (!$this->headers->has('Content-Type') || 'text/javascript' === $this->headers->get('Content-Type')) {            $this->headers->set('Content-Type', 'application/json');        }        return $this->setContent($this->data);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
284,symfony_http-foundation_RequestMatcher_9850,Adds a check for the client IP.\n\n @param string $ip A specific IP address or a range specified using IP/netmask like 192.168.1.0/24\n,Dodaje proveru klijentskog IP-ja.,    public function matchIp(string $ip)    {        $this->matchIps($ip);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
285,symfony_http-foundation_Response_8917,"Prepares the Response before it is sent to the client.\n\n This method tweaks the Response to ensure that it is\n compliant with RFC 2616. Most of the changes are based on\n the Request that is ""associated"" with this Response.\n\n @return $this\n",Priprema odgovor pre nego što se pošalje klijentu. Ovaj metod menja odgovor kako bi osigurao da je u skladu sa RFC 2616. Većina izmena su zasnovane na zahtevu koji je povezan sa ovim zahtevom.,"public function prepare(Request $request)    {        $headers = $this->headers;        if ($this->isInformational() || $this->isEmpty()) {            $this->setContent(null);            $headers->remove('Content-Type');            $headers->remove('Content-Length');            // prevent PHP from sending the Content-Type header based on default_mimetype            ini_set('default_mimetype', '');        } else {            // Content-type based on the Request            if (!$headers->has('Content-Type')) {                $format = $request->getRequestFormat(null);                if (null !== $format && $mimeType = $request->getMimeType($format)) {                    $headers->set('Content-Type', $mimeType);                }            }            // Fix Content-Type            $charset = $this->charset ?: 'UTF-8';            if (!$headers->has('Content-Type')) {                $headers->set('Content-Type', 'text/html; charset='.$charset);            } elseif (0 === stripos($headers->get('Content-Type'), 'text/') && false === stripos($headers->get('Content-Type'), 'charset')) {                // add the charset                $headers->set('Content-Type', $headers->get('Content-Type').'; charset='.$charset);            }            // Fix Content-Length            if ($headers->has('Transfer-Encoding')) {                $headers->remove('Content-Length');            }            if ($request->isMethod('HEAD')) {                // cf. RFC2616 14.13                $length = $headers->get('Content-Length');                $this->setContent(null);                if ($length) {                    $headers->set('Content-Length', $length);                }            }        }        // Fix protocol        if ('HTTP/1.0' != $request->server->get('SERVER_PROTOCOL')) {            $this->setProtocolVersion('1.1');        }        // Check if we need to send extra expire info headers        if ('1.0' == $this->getProtocolVersion() && false !== strpos($headers->get('Cache-Control'), 'no-cache')) {            $headers->set('pragma', 'no-cache');            $headers->set('expires', -1);        }        $this->ensureIEOverSSLCompatibility($request);        if ($request->isSecure()) {            foreach ($headers->getCookies() as $cookie) {                $cookie->setSecureDefault(true);            }        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
286,w7corp_easywechat_Client_2076, Text content security check.\\n\\n @param string $text\\n\\n @return array|\\\\EasyWeChat\\\\Kernel\\\\Support\\\\Collection|object|\\\\Psr\\\\Http\\\\Message\\\\ResponseInterface|string\\n\\n @throws \\\\EasyWeChat\\\\Kernel\\\\Exceptions\\\\InvalidConfigException\\n @throws \\\\GuzzleHttp\\\\Exception\\\\GuzzleException\\n,Bezbednosna provera sadržaja teksta.,"    public function checkText(string $text)    {        $params = [            'content' => $text,        ];        return $this->httpPostJson('msg_sec_check', $params);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
287,w7corp_easywechat_Client_2077, Image security check.\n\n @param string $path\n\n @return array|\\EasyWeChat\\Kernel\\Support\\Collection|object|\\Psr\\Http\\Message\\ResponseInterface|string\n\n @throws \\EasyWeChat\\Kernel\\Exceptions\\InvalidConfigException\n @throws \\GuzzleHttp\\Exception\\GuzzleException\n,Bezbednosna provera slike.,"    public function checkImage(string $path)    {        return $this->httpUpload('img_sec_check', ['media' => $path]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
288,w7corp_easywechat_Client_2093, Upload image.\n\n @param string $path\n\n @return \\Psr\\Http\\Message\\ResponseInterface|\\EasyWeChat\\Kernel\\Support\\Collection|array|object|string\n\n @throws \\EasyWeChat\\Kernel\\Exceptions\\InvalidArgumentException\n @throws \\EasyWeChat\\Kernel\\Exceptions\\InvalidConfigException\n @throws \\GuzzleHttp\\Exception\\GuzzleException\n,Uploaduj sliku.,"    public function uploadImage($path)    {        return $this->upload('image', $path);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
289,woocommerce_woocommerce_support_2031, Compare two strings containing YAML to ensure that @a $actualYaml contains at\n least what the YAML string @a $expectedYaml contains.\n\n @return whether or not @a $actualYaml contains @a $expectedJson\n     @retval true  @a $actualYaml contains @a $expectedJson\n     @retval false @a $actualYaml does not contain @a $expectedJson\n\n @param[in] $actualYaml   the YAML string to be tested\n @param[in] $expectedYaml the expected YAML string\n,Upoređivanje dva stringa koji sadrže YAML kako bi osigurali da @a $actualYaml sadrži bar ono što YAML string @a $expectedYaml sadrži.,"function checkThatYamlStringContainsYamlString( $actualYaml, $expectedYaml ) {",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
290,yiisoft_yii2_ActionFilter_1015, Returns a value indicating whether the filter is active for the given action.\\\\n @param Action $action the action being filtered\\\\n @return bool whether the filter is active for the given action.\\\\n,Vraća vrednost koja ukazuje da li je filter aktivan za datu akciju.,"    protected function isActive($action)    {        $id = $this->getActionId($action);        if (empty($this->only)) {            $onlyMatch = true;        } else {            $onlyMatch = false;            foreach ($this->only as $pattern) {                if (StringHelper::matchWildcard($pattern, $id)) {                    $onlyMatch = true;                    break;                }            }        }        $exceptMatch = false;        foreach ($this->except as $pattern) {            if (StringHelper::matchWildcard($pattern, $id)) {                $exceptMatch = true;                break;            }        }        return !$exceptMatch && $onlyMatch;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
291,yiisoft_yii2_Application_1023,"Runs the application.\n This is the main entrance of an application.\n @return int the exit status (0 means normal, non-zero values mean abnormal)\n",Pokreće aplikaciju. Ovo je glavni ulaz u aplikaciju.,"    public function run()    {        try {            $this->state = self::STATE_BEFORE_REQUEST;            $this->trigger(self::EVENT_BEFORE_REQUEST);            $this->state = self::STATE_HANDLING_REQUEST;            $response = $this->handleRequest($this->getRequest());            $this->state = self::STATE_AFTER_REQUEST;            $this->trigger(self::EVENT_AFTER_REQUEST);            $this->state = self::STATE_SENDING_RESPONSE;            $response->send();            $this->state = self::STATE_END;            return $response->exitStatus;        } catch (ExitException $e) {            $this->end($e->statusCode, isset($response) ? $response : null);            return $e->statusCode;        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
414,thephpleague_csv_AbstractCsv_184, An abstract class to enable CSV document loading.,Apstraktna klasa koja omogućava učitavanja CSV dokumenata.,"abstract class AbstractCsv implements ByteSequence{    protected const STREAM_FILTER_MODE = STREAM_FILTER_READ;    /**     * collection of stream filters.     *     * @var bool[]     */    protected $stream_filters = [];    /**     * The CSV document BOM sequence.     *     * @var string|null     */    protected $input_bom = null;    /**     * The Output file BOM character.     *     * @var string     */    protected $output_bom = '';    /**     * the field delimiter (one character only).     *     * @var string     */    protected $delimiter = ',';    /**     * the field enclosure character (one character only).     *     * @var string     */    protected $enclosure = '""';    /**     * the field escape character (one character only).     *     * @var string     */    protected $escape = '\\';    /**     * The CSV document.     *     * @var SplFileObject|Stream     */    protected $document;    /**     * Tells whether the Input BOM must be included or skipped.     *     * @var bool     */    protected $is_input_bom_included = false;    /**     * New instance.     *     * @param SplFileObject|Stream $document The CSV Object instance     */    protected function __construct($document)    {        $this->document = $document;        [$this->delimiter, $this->enclosure, $this->escape] = $this->document->getCsvControl();        $this->resetProperties();    }    /**     * Reset dynamic object properties to improve performance.     */    abstract protected function resetProperties(): void;    /**     * {@inheritdoc}     */    public function __destruct()    {        unset($this->document);    }    /**     * {@inheritdoc}     */    public function __clone()    {        throw UnavailableStream::dueToForbiddenCloning(static::class);    }    /**     * Return a new instance from a SplFileObject.     *     * @return static     */    public static function createFromFileObject(SplFileObject $file)    {        return new static($file);    }    /**     * Return a new instance from a PHP resource stream.     *     * @param resource $stream     *     * @return static     */    public static function createFromStream($stream)    {        return new static(new Stream($stream));    }    /**     * Return a new instance from a string.     *     * @return static     */    public static function createFromString(string $content = '')    {        return new static(Stream::createFromString($content));    }    /**     * Return a new instance from a file path.     *     * @param resource|null $context the resource context     *     * @return static     */    public static function createFromPath(string $path, string $open_mode = 'r+', $context = null)    {        return new static(Stream::createFromPath($path, $open_mode, $context));    }    /**     * Returns the current field delimiter.     */    public function getDelimiter(): string    {        return $this->delimiter;    }    /**     * Returns the current field enclosure.     */    public function getEnclosure(): string    {        return $this->enclosure;    }    /**     * Returns the pathname of the underlying document.     */    public function getPathname(): string    {        return $this->document->getPathname();    }    /**     * Returns the current field escape character.     */    public function getEscape(): string    {        return $this->escape;    }    /**     * Returns the BOM sequence in use on Output methods.     */    public function getOutputBOM(): string    {        return $this->output_bom;    }    /**     * Returns the BOM sequence of the given CSV.     */    public function getInputBOM(): string    {        if (null !== $this->input_bom) {            return $this->input_bom;        }        $this->document->setFlags(SplFileObject::READ_CSV);        $this->document->rewind();        $this->input_bom = Info::fetchBOMSequence((string) $this->document->fread(4)) ?? '';        return $this->input_bom;    }    /**     * DEPRECATION WARNING! This method will be removed in the next major point release.     *     * @deprecated since version 9.7.0     * @see AbstractCsv::supportsStreamFilterOnRead     * @see AbstractCsv::supportsStreamFilterOnWrite     *     * Returns the stream filter mode.     */    public function getStreamFilterMode(): int    {        return static::STREAM_FILTER_MODE;    }    /**     * DEPRECATION WARNING! This method will be removed in the next major point release.     *     * @deprecated since version 9.7.0     * @see AbstractCsv::supportsStreamFilterOnRead     * @see AbstractCsv::supportsStreamFilterOnWrite     *     * Tells whether the stream filter capabilities can be used.     */    public function supportsStreamFilter(): bool    {        return $this->document instanceof Stream;    }    /**     * Tells whether the stream filter read capabilities can be used.     */    public function supportsStreamFilterOnRead(): bool    {        return $this->document instanceof Stream            && ((static::STREAM_FILTER_MODE & STREAM_FILTER_READ) === STREAM_FILTER_READ);    }    /**     * Tells whether the stream filter write capabilities can be used.     */    public function supportsStreamFilterOnWrite(): bool    {        return $this->document instanceof Stream            && ((static::STREAM_FILTER_MODE & STREAM_FILTER_WRITE) === STREAM_FILTER_WRITE);    }    /**     * Tell whether the specify stream filter is attach to the current stream.     */    public function hasStreamFilter(string $filtername): bool    {        return $this->stream_filters[$filtername] ?? false;    }    /**     * Tells whether the BOM can be stripped if presents.     */    public function isInputBOMIncluded(): bool    {        return $this->is_input_bom_included;    }    /**     * Returns the CSV document as a Generator of string chunk.     *     * @param int $length number of bytes read     *     * @throws Exception if the number of bytes is lesser than 1     */    public function chunk(int $length): Generator    {        if ($length < 1) {            throw InvalidArgument::dueToInvalidChunkSize($length, __METHOD__);        }        $input_bom = $this->getInputBOM();        $this->document->rewind();        $this->document->setFlags(0);        $this->document->fseek(strlen($input_bom));        /** @var  array<int, string> $chunks */        $chunks = str_split($this->output_bom.$this->document->fread($length), $length);        foreach ($chunks as $chunk) {            yield $chunk;        }        while ($this->document->valid()) {            yield $this->document->fread($length);        }    }    /**     * DEPRECATION WARNING! This method will be removed in the next major point release.     *     * @deprecated since version 9.1.0     * @see AbstractCsv::toString     *     * Retrieves the CSV content     */    public function __toString(): string    {        return $this->toString();    }    /**     * Retrieves the CSV content.     *     * DEPRECATION WARNING! This method will be removed in the next major point release     *     * @deprecated since version 9.7.0     * @see AbstractCsv::toString     */    public function getContent(): string    {        return $this->toString();    }    /**     * Retrieves the CSV content.     *     * @throws Exception If the string representation can not be returned     */    public function toString(): string    {        $raw = '';        foreach ($this->chunk(8192) as $chunk) {            $raw .= $chunk;        }        return $raw;    }    /**     * Outputs all data on the CSV file.     *     * @return int Returns the number of characters read from the handle     *             and passed through to the output.     */    public function output(string $filename = null): int    {        if (null !== $filename) {            $this->sendHeaders($filename);        }        $this->document->rewind();        if (!$this->is_input_bom_included) {            $this->document->fseek(strlen($this->getInputBOM()));        }        echo $this->output_bom;        return strlen($this->output_bom) + (int) $this->document->fpassthru();    }    /**     * Send the CSV headers.     *     * Adapted from Symfony\Component\HttpFoundation\ResponseHeaderBag::makeDisposition     *     * @throws Exception if the submitted header is invalid according to RFC 6266     *     * @see https://tools.ietf.org/html/rfc6266#section-4.3     */    protected function sendHeaders(string $filename): void    {        if (strlen($filename) != strcspn($filename, '\\/')) {            throw InvalidArgument::dueToInvalidHeaderFilename($filename);        }        $flag = FILTER_FLAG_STRIP_LOW;        if (strlen($filename) !== mb_strlen($filename)) {            $flag |= FILTER_FLAG_STRIP_HIGH;        }        /** @var string $filtered_name */        $filtered_name = filter_var($filename, FILTER_SANITIZE_STRING, $flag);        $filename_fallback = str_replace('%', '', $filtered_name);        $disposition = sprintf('attachment; filename=""%s""', str_replace('""', '\\""', $filename_fallback));        if ($filename !== $filename_fallback) {            $disposition .= sprintf(""; filename*=utf-8''%s"", rawurlencode($filename));        }        header('Content-Type: text/csv');        header('Content-Transfer-Encoding: binary');        header('Content-Description: File Transfer');        header('Content-Disposition: '.$disposition);    }    /**     * Sets the field delimiter.     *     * @throws InvalidArgument If the Csv control character is not one character only.     *     * @return static     */    public function setDelimiter(string $delimiter): self    {        if ($delimiter === $this->delimiter) {            return $this;        }        if (1 !== strlen($delimiter)) {            throw InvalidArgument::dueToInvalidDelimiterCharacter($delimiter, __METHOD__);        }        $this->delimiter = $delimiter;        $this->resetProperties();        return $this;    }    /**     * Sets the field enclosure.     *     * @throws InvalidArgument If the Csv control character is not one character only.     *     * @return static     */    public function setEnclosure(string $enclosure): self    {        if ($enclosure === $this->enclosure) {            return $this;        }        if (1 !== strlen($enclosure)) {            throw InvalidArgument::dueToInvalidEnclosureCharacter($enclosure, __METHOD__);        }        $this->enclosure = $enclosure;        $this->resetProperties();        return $this;    }    /**     * Sets the field escape character.     *     * @throws InvalidArgument If the Csv control character is not one character only.     *     * @return static     */    public function setEscape(string $escape): self    {        if ($escape === $this->escape) {            return $this;        }        if ('' !== $escape && 1 !== strlen($escape)) {            throw InvalidArgument::dueToInvalidEscapeCharacter($escape, __METHOD__);        }        $this->escape = $escape;        $this->resetProperties();        return $this;    }    /**     * Enables BOM Stripping.     *     * @return static     */    public function skipInputBOM(): self    {        $this->is_input_bom_included = false;        return $this;    }    /**     * Disables skipping Input BOM.     *     * @return static     */    public function includeInputBOM(): self    {        $this->is_input_bom_included = true;        return $this;    }    /**     * Sets the BOM sequence to prepend the CSV on output.     *     * @return static     */    public function setOutputBOM(string $str): self    {        $this->output_bom = $str;        return $this;    }    /**     * append a stream filter.     *     * @param null|mixed $params     *     * @throws InvalidArgument    If the stream filter API can not be appended     * @throws UnavailableFeature If the stream filter API can not be used     *     * @return static     */    public function addStreamFilter(string $filtername, $params = null): self    {        if (!$this->document instanceof Stream) {            throw UnavailableFeature::dueToUnsupportedStreamFilterApi(get_class($this->document));        }        $this->document->appendFilter($filtername, static::STREAM_FILTER_MODE, $params);        $this->stream_filters[$filtername] = true;        $this->resetProperties();        $this->input_bom = null;        return $this;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0
415,thephpleague_csv_AbstractCsv_191, Returns the current field delimiter.\n,Vrati trenutni razdvojni karakter.,    public function getDelimiter(): string    {        return $this->delimiter;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
416,thephpleague_csv_AbstractCsv_193, Returns the pathname of the underlying document.,Vrati putanju do dokumenta,    public function getPathname(): string    {        return $this->document->getPathname();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
417,thephpleague_csv_AbstractCsv_203,Returns the CSV document as a Generator of string chunk.\n\n @param int $length number of bytes read\n\n @throws Exception if the number of bytes is lesser than 1\n,Vraća CSV dokument kao generator komada stringova.,"public function chunk(int $length): Generator    {        if ($length < 1) {            throw InvalidArgument::dueToInvalidChunkSize($length, __METHOD__);        }        $input_bom = $this->getInputBOM();        $this->document->rewind();        $this->document->setFlags(0);        $this->document->fseek(strlen($input_bom));        /** @var  array<int, string> $chunks */        $chunks = str_split($this->output_bom.$this->document->fread($length), $length);        foreach ($chunks as $chunk) {            yield $chunk;        }        while ($this->document->valid()) {            yield $this->document->fread($length);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
418,thephpleague_csv_AbstractCsv_206, Retrieves the CSV content.\n\n @throws Exception If the string representation can not be returned\n,Vraća sadržaj CSV fajla.,public function toString(): string    {        $raw = '';        foreach ($this->chunk(8192) as $chunk) {            $raw .= $chunk;        }        return $raw;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0
419,thephpleague_csv_CannotInsertRecord_245, Thrown when a data is not added to the Csv Document.\n,Izuzetak koji se podiže kada podaci nisu dodati u CSV dokument.,"class CannotInsertRecord extends Exception{    /**     * The record submitted for insertion.     *     * @var array     */    protected $record;    /**     * Validator which did not validated the data.     *     * @var string     */    protected $name = '';    /**     * Create an Exception from a record insertion into a stream.     */    public static function triggerOnInsertion(array $record): self    {        $exception = new self('Unable to write record to the CSV document');        $exception->record = $record;        return $exception;    }    /**     * Create an Exception from a Record Validation.     */    public static function triggerOnValidation(string $name, array $record): self    {        $exception = new self('Record validation failed');        $exception->name = $name;        $exception->record = $record;        return $exception;    }    /**     * return the validator name.     *     */    public function getName(): string    {        return $this->name;    }    /**     * return the invalid data submitted.     *     */    public function getRecord(): array    {        return $this->record;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
420,thephpleague_csv_CharsetConverter_260,Convert Csv records collection into UTF-8.\n,Pretvara csv strukturu kolekcija u utf-8,"    public function convert(iterable $records): iterable    {        if ($this->output_encoding === $this->input_encoding) {            return $records;        }        if (is_array($records)) {            return array_map($this, $records);        }        /* @var \Traversable $records */        return new MapIterator($records, $this);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
421,thephpleague_csv_ColumnConsistency_276, Validates column consistency when inserting records into a CSV document.\n,Proverava konzistentnost kolona prilikom upisa zapisa u CSV dokument,"class ColumnConsistency{    /**     * The number of column per record.     *     * @var int     */    protected $columns_count;    /**     * New Instance.     *     * @throws InvalidArgument if the column count is lesser than -1     */    public function __construct(int $columns_count = -1)    {        if ($columns_count < -1) {            throw InvalidArgument::dueToInvalidColumnCount($columns_count, __METHOD__);        }        $this->columns_count = $columns_count;    }    /**     * Returns the column count.     */    public function getColumnCount(): int    {        return $this->columns_count;    }    /**     * Tell whether the submitted record is valid.     */    public function __invoke(array $record): bool    {        $count = count($record);        if (-1 === $this->columns_count) {            $this->columns_count = $count;            return true;        }        return $count === $this->columns_count;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
422,thephpleague_csv_ColumnConsistency_277, Returns the column count.\n,Vraća broj kolona,    public function getColumnCount(): int    {        return $this->columns_count;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
423,thephpleague_csv_ColumnConsistency_278, Tell whether the submitted record is valid.\n,Reci da li je poslat zapis validan.,public function __invoke(array $record): bool    {        $count = count($record);        if (-1 === $this->columns_count) {            $this->columns_count = $count;            return true;        }        return $count === $this->columns_count;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
424,thephpleague_csv_HTMLConverter_310, Converts tabular data into an HTML Table string.\n,Pretvara tabelarne podatke u string koji je HTML tabela.,"class HTMLConverter{    /**     * table class attribute value.     *     * @var string     */    protected $class_name = 'table-csv-data';    /**     * table id attribute value.     *     * @var string     */    protected $id_value = '';    /**     * @var XMLConverter     */    protected $xml_converter;    public static function create(): self    {        return new self();    }    /**     * DEPRECATION WARNING! This method will be removed in the next major point release.     *     * @deprecated since version 9.7.0     * @see HTMLConverterTest::create()     */    public function __construct()    {        $this->xml_converter = XMLConverter::create()            ->rootElement('table')            ->recordElement('tr')            ->fieldElement('td')        ;    }    /**     * Converts a tabular data collection into a HTML table string.     *     * @param string[] $header_record An optional array of headers outputted using the`<thead>` section     * @param string[] $footer_record An optional array of footers to output to the table using `<tfoot>` and `<th>` elements     */    public function convert(iterable $records, array $header_record = [], array $footer_record = []): string    {        $doc = new DOMDocument('1.0');        if ([] === $header_record && [] === $footer_record) {            $table = $this->xml_converter->import($records, $doc);            $this->addHTMLAttributes($table);            $doc->appendChild($table);            /** @var string $content */            $content = $doc->saveHTML();            return $content;        }        $table = $doc->createElement('table');        $this->addHTMLAttributes($table);        $this->appendHeaderSection('thead', $header_record, $table);        $this->appendHeaderSection('tfoot', $footer_record, $table);        $table->appendChild($this->xml_converter->rootElement('tbody')->import($records, $doc));        $doc->appendChild($table);        /** @var string $content */        $content = $doc->saveHTML();        return $content;    }    /**     * Creates a DOMElement representing a HTML table heading section.     */    protected function appendHeaderSection(string $node_name, array $record, DOMElement $table): void    {        if ([] === $record) {            return;        }        /** @var DOMDocument $ownerDocument */        $ownerDocument = $table->ownerDocument;        $node = $this->xml_converter            ->rootElement($node_name)            ->recordElement('tr')            ->fieldElement('th')            ->import([$record], $ownerDocument)        ;        /** @var DOMElement $element */        foreach ($node->getElementsByTagName('th') as $element) {            $element->setAttribute('scope', 'col');        }        $table->appendChild($node);    }    /**     * Adds class and id attributes to an HTML tag.     */    protected function addHTMLAttributes(DOMElement $node): void    {        $node->setAttribute('class', $this->class_name);        $node->setAttribute('id', $this->id_value);    }    /**     * HTML table class name setter.     *     * @throws DOMException if the id_value contains any type of whitespace     */    public function table(string $class_name, string $id_value = ''): self    {        if (1 === preg_match("",\s,"", $id_value)) {            throw new DOMException(""the id attribute's value must not contain whitespace (spaces, tabs etc.)"");        }        $clone = clone $this;        $clone->class_name = $class_name;        $clone->id_value = $id_value;        return $clone;    }    /**     * HTML tr record offset attribute setter.     */    public function tr(string $record_offset_attribute_name): self    {        $clone = clone $this;        $clone->xml_converter = $this->xml_converter->recordElement('tr', $record_offset_attribute_name);        return $clone;    }    /**     * HTML td field name attribute setter.     */    public function td(string $fieldname_attribute_name): self    {        $clone = clone $this;        $clone->xml_converter = $this->xml_converter->fieldElement('td', $fieldname_attribute_name);        return $clone;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
425,thephpleague_csv_HTMLConverter_313, Adds class and id attributes to an HTML tag.\n,Dodaje klasu i id atribute u html tag.,"    protected function addHTMLAttributes(DOMElement $node): void    {        $node->setAttribute('class', $this->class_name);        $node->setAttribute('id', $this->id_value);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
426,thephpleague_csv_HTMLConverter_315, HTML td field name attribute setter.\n,Postavlja naziv HTML td polja. ,"    public function td(string $fieldname_attribute_name): self    {        $clone = clone $this;        $clone->xml_converter = $this->xml_converter->fieldElement('td', $fieldname_attribute_name);        return $clone;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
427,thephpleague_csv_Reader_346, A class to parse and read records from a CSV document.\n,Klasa koja parsira i čita zapise iz CSV dokumenta.,"class Reader extends AbstractCsv implements TabularDataReader, JsonSerializable{    protected const STREAM_FILTER_MODE = STREAM_FILTER_READ;    /**     * header offset.     *     * @var int|null     */    protected $header_offset;    /**     * header record.     *     * @var string[]     */    protected $header = [];    /**     * records count.     *     * @var int     */    protected $nb_records = -1;    /**     * @var bool     */    protected $is_empty_records_included = false;    /**     * {@inheritdoc}     */    public static function createFromPath(string $path, string $open_mode = 'r', $context = null)    {        return parent::createFromPath($path, $open_mode, $context);    }    /**     * {@inheritdoc}     */    protected function resetProperties(): void    {        $this->nb_records = -1;        $this->header = [];    }    /**     * Returns the header offset.     *     * If no CSV header offset is set this method MUST return null     *     */    public function getHeaderOffset(): ?int    {        return $this->header_offset;    }    /**     * {@inheritDoc}     */    public function getHeader(): array    {        if (null === $this->header_offset) {            return $this->header;        }        if ([] !== $this->header) {            return $this->header;        }        $this->header = $this->setHeader($this->header_offset);        return $this->header;    }    /**     * Determine the CSV record header.     *     * @throws Exception If the header offset is set and no record is found or is the empty array     *     * @return string[]     */    protected function setHeader(int $offset): array    {        $header = $this->seekRow($offset);        if (in_array($header, [[], [null]], true)) {            throw SyntaxError::dueToHeaderNotFound($offset);        }        if (0 !== $offset) {            return $header;        }        $header = $this->removeBOM($header, mb_strlen($this->getInputBOM()), $this->enclosure);        if ([''] === $header) {            throw SyntaxError::dueToHeaderNotFound($offset);        }        return $header;    }    /**     * Returns the row at a given offset.     */    protected function seekRow(int $offset): array    {        foreach ($this->getDocument() as $index => $record) {            if ($offset === $index) {                return $record;            }        }        return [];    }    /**     * Returns the document as an Iterator.     */    protected function getDocument(): Iterator    {        if (70400 > PHP_VERSION_ID && '' === $this->escape) {            $this->document->setCsvControl($this->delimiter, $this->enclosure);            return EmptyEscapeParser::parse($this->document);        }        $this->document->setFlags(SplFileObject::READ_CSV | SplFileObject::READ_AHEAD);        $this->document->setCsvControl($this->delimiter, $this->enclosure, $this->escape);        $this->document->rewind();        return $this->document;    }    /**     * Strip the BOM sequence from a record.     *     * @param string[] $record     *     * @return string[]     */    protected function removeBOM(array $record, int $bom_length, string $enclosure): array    {        if (0 === $bom_length) {            return $record;        }        $record[0] = mb_substr($record[0], $bom_length);        if ($enclosure.$enclosure != substr($record[0].$record[0], strlen($record[0]) - 1, 2)) {            return $record;        }        $record[0] = substr($record[0], 1, -1);        return $record;    }    /**     * {@inheritdoc}     */    public function fetchColumn($index = 0): Iterator    {        return ResultSet::createFromTabularDataReader($this)->fetchColumn($index);    }    /**     * {@inheritdoc}     */    public function fetchOne(int $nth_record = 0): array    {        return ResultSet::createFromTabularDataReader($this)->fetchOne($nth_record);    }    /**     * {@inheritdoc}     */    public function fetchPairs($offset_index = 0, $value_index = 1): Iterator    {        return ResultSet::createFromTabularDataReader($this)->fetchPairs($offset_index, $value_index);    }    /**     * {@inheritdoc}     */    public function count(): int    {        if (-1 === $this->nb_records) {            $this->nb_records = iterator_count($this->getRecords());        }        return $this->nb_records;    }    /**     * {@inheritdoc}     */    public function getIterator(): Iterator    {        return $this->getRecords();    }    /**     * {@inheritdoc}     */    public function jsonSerialize(): array    {        return iterator_to_array($this->getRecords(), false);    }    /**     * {@inheritDoc}     */    public function getRecords(array $header = []): Iterator    {        $header = $this->computeHeader($header);        $normalized = function ($record): bool {            return is_array($record) && ($this->is_empty_records_included || $record != [null]);        };        $bom = '';        if (!$this->is_input_bom_included) {            $bom = $this->getInputBOM();        }        $document = $this->getDocument();        $records = $this->stripBOM(new CallbackFilterIterator($document, $normalized), $bom);        if (null !== $this->header_offset) {            $records = new CallbackFilterIterator($records, function (array $record, int $offset): bool {                return $offset !== $this->header_offset;            });        }        if ($this->is_empty_records_included) {            $normalized_empty_records = static function (array $record): array {                if ([null] === $record) {                    return [];                }                return $record;            };            return $this->combineHeader(new MapIterator($records, $normalized_empty_records), $header);        }        return $this->combineHeader($records, $header);    }    /**     * Returns the header to be used for iteration.     *     * @param string[] $header     *     * @throws Exception If the header contains non unique column name     *     * @return string[]     */    protected function computeHeader(array $header)    {        if ([] === $header) {            $header = $this->getHeader();        }        if ($header !== ($filtered_header = array_filter($header, 'is_string'))) {            throw SyntaxError::dueToInvalidHeaderColumnNames();        }        if ($header !== array_unique($filtered_header)) {            throw SyntaxError::dueToDuplicateHeaderColumnNames($header);        }        return $header;    }    /**     * Combine the CSV header to each record if present.     *     * @param string[] $header     */    protected function combineHeader(Iterator $iterator, array $header): Iterator    {        if ([] === $header) {            return $iterator;        }        $field_count = count($header);        $mapper = static function (array $record) use ($header, $field_count): array {            if (count($record) != $field_count) {                $record = array_slice(array_pad($record, $field_count, null), 0, $field_count);            }            /** @var array<string|null> $assocRecord */            $assocRecord = array_combine($header, $record);            return $assocRecord;        };        return new MapIterator($iterator, $mapper);    }    /**     * Strip the BOM sequence from the returned records if necessary.     */    protected function stripBOM(Iterator $iterator, string $bom): Iterator    {        if ('' === $bom) {            return $iterator;        }        $bom_length = mb_strlen($bom);        $mapper = function (array $record, int $index) use ($bom_length): array {            if (0 !== $index) {                return $record;            }            $record = $this->removeBOM($record, $bom_length, $this->enclosure);            if ([''] === $record) {                return [null];            }            return $record;        };        $filter = function (array $record): bool {            return $this->is_empty_records_included || $record != [null];        };        return new CallbackFilterIterator(new MapIterator($iterator, $mapper), $filter);    }    /**     * Selects the record to be used as the CSV header.     *     * Because the header is represented as an array, to be valid     * a header MUST contain only unique string value.     *     * @param int|null $offset the header record offset     *     * @throws Exception if the offset is a negative integer     *     * @return static     */    public function setHeaderOffset(?int $offset): self    {        if ($offset === $this->header_offset) {            return $this;        }        if (null !== $offset && 0 > $offset) {            throw InvalidArgument::dueToInvalidHeaderOffset($offset, __METHOD__);        }        $this->header_offset = $offset;        $this->resetProperties();        return $this;    }    /**     * Enable skipping empty records.     */    public function skipEmptyRecords(): self    {        if ($this->is_empty_records_included) {            $this->is_empty_records_included = false;            $this->nb_records = -1;        }        return $this;    }    /**     * Disable skipping empty records.     */    public function includeEmptyRecords(): self    {        if (!$this->is_empty_records_included) {            $this->is_empty_records_included = true;            $this->nb_records = -1;        }        return $this;    }    /**     * Tells whether empty records are skipped by the instance.     */    public function isEmptyRecordsIncluded(): bool    {        return $this->is_empty_records_included;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0
428,thephpleague_csv_Reader_352, Returns the document as an Iterator.\n,Vraća dokument kao iterator.,"protected function getDocument(): Iterator    {        if (70400 > PHP_VERSION_ID && '' === $this->escape) {            $this->document->setCsvControl($this->delimiter, $this->enclosure);            return EmptyEscapeParser::parse($this->document);        }        $this->document->setFlags(SplFileObject::READ_CSV | SplFileObject::READ_AHEAD);        $this->document->setCsvControl($this->delimiter, $this->enclosure, $this->escape);        $this->document->rewind();        return $this->document;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
429,thephpleague_csv_Reader_357, Returns the header to be used for iteration.\n\n @param string[] $header\n\n @throws Exception If the header contains non unique column name\n\n @return string[]\n,Vraća zaglavlje kako bi se koristilo za iteraciju.,"    protected function computeHeader(array $header)    {        if ([] === $header) {            $header = $this->getHeader();        }        if ($header !== ($filtered_header = array_filter($header, 'is_string'))) {            throw SyntaxError::dueToInvalidHeaderColumnNames();        }        if ($header !== array_unique($filtered_header)) {            throw SyntaxError::dueToDuplicateHeaderColumnNames($header);        }        return $header;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
430,thephpleague_csv_Reader_358, Combine the CSV header to each record if present.\n\n @param string[] $header\n,Kombinuje CSV zaglavlje sa svakim zapisom ako je prisutno.,"protected function combineHeader(Iterator $iterator, array $header): Iterator    {        if ([] === $header) {            return $iterator;        }        $field_count = count($header);        $mapper = static function (array $record) use ($header, $field_count): array {            if (count($record) != $field_count) {                $record = array_slice(array_pad($record, $field_count, null), 0, $field_count);            }            /** @var array<string|null> $assocRecord */            $assocRecord = array_combine($header, $record);            return $assocRecord;        };        return new MapIterator($iterator, $mapper);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
431,thephpleague_csv_Reader_361, Enable skipping empty records.\n,Omogućava preskakanje praznih zapisa.,public function skipEmptyRecords(): self    {        if ($this->is_empty_records_included) {            $this->is_empty_records_included = false;            $this->nb_records = -1;        }        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
432,thephpleague_csv_Statement_435, Sort the Iterator.\n,Sortiraj iteratore,"protected function buildOrderBy(Iterator $iterator): Iterator    {        if ([] === $this->order_by) {            return $iterator;        }        $compare = function (array $record_a, array $record_b): int {            foreach ($this->order_by as $callable) {                if (0 !== ($cmp = $callable($record_a, $record_b))) {                    return $cmp;                }            }            return $cmp ?? 0;        };        $it = new ArrayIterator();        foreach ($iterator as $offset => $value) {            $it[$offset] = $value;        }        $it->uasort($compare);        return $it;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
433,thephpleague_csv_Stream_450, Retrieves the current line as a CSV Record.\n\n @return array|false\n,Vraća trenutnu liniju kao CSV zapis.,"private function getCurrentRecord()    {        $flag = 0 !== ($this->flags & SplFileObject::SKIP_EMPTY);        do {            $ret = fgetcsv($this->stream, 0, $this->delimiter, $this->enclosure, $this->escape);        } while ($flag && is_array($ret) && null === $ret[0]);        return $ret;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
434,thephpleague_csv_Stream_453, Read from file.\n\n @see http://php.net/manual/en/SplFileObject.fread.php\n\n @param int $length The number of bytes to read\n\n @return string|false\n,Čitaj iz fajla.,"    public function fread(int $length)    {        return fread($this->stream, $length);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0
435,thephpleague_csv_Stream_454, Gets a line from file.\n\n @see http://php.net/manual/en/SplFileObject.fgets.php\n\n @return string|false\n,Dohvati liniju iz fajla.,    public function fgets()    {        return fgets($this->stream);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
436,thephpleague_csv_Stream_455, Flushes the output to a file.\n\n @see http://php.net/manual/en/SplFileObject.fwrite.php\n,Isprazi izlaz u fajl.,    public function fflush(): bool    {        return fflush($this->stream);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
437,thephpleague_csv_TabularDataReader_480, Returns the tabular data records as an iterator object.\n\n Each record is represented as a simple array containing strings or null values.\n\n If the CSV document has a header record then each record is combined\n to the header record and the header record is removed from the iterator.\n\n If the CSV document is inconsistent. Missing record fields are\n filled with null values while extra record fields are strip from\n the returned object.\n,"Vraća tabelarne zapise kao iterator. Svaki zapis je reprezentovan kao jednostavan niz koji sadrži stringove ili null vrednosti. Ako CSV dokument ima zapis zaglavlje, onda se svaki zapis kombinuje sa zapisom zaglavlja i zapis zaglavlja se izbacuje iz iteratora. Ako CSV dokument nije konzistentan, nedostajuća polja se dopunjuju pomoću null vrednosti, dok se polja koja su višak sklanjaju iz vraćenog objekta.",    public function getIterator(): Iterator;,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
438,thephpleague_csv_Writer_483, A class to insert records into a CSV Document.\n,Klasa koja upisuje zapise u CSV dokument.,"class Writer extends AbstractCsv{    protected const STREAM_FILTER_MODE = STREAM_FILTER_WRITE;    /**     * callable collection to format the record before insertion.     *     * @var callable[]     */    protected $formatters = [];    /**     * callable collection to validate the record before insertion.     *     * @var callable[]     */    protected $validators = [];    /**     * newline character.     *     * @var string     */    protected $newline = ""\n"";    /**     * Insert records count for flushing.     *     * @var int     */    protected $flush_counter = 0;    /**     * Buffer flush threshold.     *     * @var int|null     */    protected $flush_threshold;    /**     * Regular expression used to detect if RFC4180 formatting is necessary.     *     * @var string     */    protected $rfc4180_regexp;    /**     * double enclosure for RFC4180 compliance.     *     * @var string     */    protected $rfc4180_enclosure;    /**     * {@inheritdoc}     */    protected function resetProperties(): void    {        $characters = preg_quote($this->delimiter, '/').'|'.preg_quote($this->enclosure, '/');        $this->rfc4180_regexp = '/[\s|'.$characters.']/x';        $this->rfc4180_enclosure = $this->enclosure.$this->enclosure;    }    /**     * Returns the current newline sequence characters.     */    public function getNewline(): string    {        return $this->newline;    }    /**     * Get the flush threshold.     *     * @return int|null     */    public function getFlushThreshold()    {        return $this->flush_threshold;    }    /**     * Adds multiple records to the CSV document.     *     * @see Writer::insertOne     */    public function insertAll(iterable $records): int    {        $bytes = 0;        foreach ($records as $record) {            $bytes += $this->insertOne($record);        }        $this->flush_counter = 0;        $this->document->fflush();        return $bytes;    }    /**     * Adds a single record to a CSV document.     *     * A record is an array that can contains scalar types values, NULL values     * or objects implementing the __toString method.     *     * @throws CannotInsertRecord If the record can not be inserted     */    public function insertOne(array $record): int    {        $method = 'addRecord';        if (70400 > PHP_VERSION_ID && '' === $this->escape) {            $method = 'addRFC4180CompliantRecord';        }        $record = array_reduce($this->formatters, [$this, 'formatRecord'], $record);        $this->validateRecord($record);        $bytes = $this->$method($record);        if (false === $bytes || 0 >= $bytes) {            throw CannotInsertRecord::triggerOnInsertion($record);        }        return $bytes + $this->consolidate();    }    /**     * Adds a single record to a CSV Document using PHP algorithm.     *     * @see https://php.net/manual/en/function.fputcsv.php     *     * @return int|false     */    protected function addRecord(array $record)    {        return $this->document->fputcsv($record, $this->delimiter, $this->enclosure, $this->escape);    }    /**     * Adds a single record to a CSV Document using RFC4180 algorithm.     *     * @see https://php.net/manual/en/function.fputcsv.php     * @see https://php.net/manual/en/function.fwrite.php     * @see https://tools.ietf.org/html/rfc4180     * @see http://edoceo.com/utilitas/csv-file-format     *     * String conversion is done without any check like fputcsv.     *     *     - Emits E_NOTICE on Array conversion (returns the 'Array' string)     *     - Throws catchable fatal error on objects that can not be converted     *     - Returns resource id without notice or error (returns 'Resource id #2')     *     - Converts boolean true to '1', boolean false to the empty string     *     - Converts null value to the empty string     *     * Fields must be delimited with enclosures if they contains :     *     *     - Embedded whitespaces     *     - Embedded delimiters     *     - Embedded line-breaks     *     - Embedded enclosures.     *     * Embedded enclosures must be doubled.     *     * The LF character is added at the end of each record to mimic fputcsv behavior     *     * @return int|false     */    protected function addRFC4180CompliantRecord(array $record)    {        foreach ($record as &$field) {            $field = (string) $field;            if (1 === preg_match($this->rfc4180_regexp, $field)) {                $field = $this->enclosure.str_replace($this->enclosure, $this->rfc4180_enclosure, $field).$this->enclosure;            }        }        unset($field);        return $this->document->fwrite(implode($this->delimiter, $record).""\n"");    }    /**     * Format a record.     *     * The returned array must contain     *   - scalar types values,     *   - NULL values,     *   - or objects implementing the __toString() method.     */    protected function formatRecord(array $record, callable $formatter): array    {        return $formatter($record);    }    /**     * Validate a record.     *     * @throws CannotInsertRecord If the validation failed     */    protected function validateRecord(array $record): void    {        foreach ($this->validators as $name => $validator) {            if (true !== $validator($record)) {                throw CannotInsertRecord::triggerOnValidation($name, $record);            }        }    }    /**     * Apply post insertion actions.     */    protected function consolidate(): int    {        $bytes = 0;        if (""\n"" !== $this->newline) {            $this->document->fseek(-1, SEEK_CUR);            /** @var int $newlineBytes */            $newlineBytes = $this->document->fwrite($this->newline, strlen($this->newline));            $bytes =  $newlineBytes - 1;        }        if (null === $this->flush_threshold) {            return $bytes;        }        ++$this->flush_counter;        if (0 === $this->flush_counter % $this->flush_threshold) {            $this->flush_counter = 0;            $this->document->fflush();        }        return $bytes;    }    /**     * Adds a record formatter.     */    public function addFormatter(callable $formatter): self    {        $this->formatters[] = $formatter;        return $this;    }    /**     * Adds a record validator.     */    public function addValidator(callable $validator, string $validator_name): self    {        $this->validators[$validator_name] = $validator;        return $this;    }    /**     * Sets the newline sequence.     */    public function setNewline(string $newline): self    {        $this->newline = $newline;        return $this;    }    /**     * Set the flush threshold.     *     * @param ?int $threshold     *     * @throws InvalidArgument if the threshold is a integer lesser than 1     */    public function setFlushThreshold(?int $threshold): self    {        if ($threshold === $this->flush_threshold) {            return $this;        }        if (null !== $threshold && 1 > $threshold) {            throw InvalidArgument::dueToInvalidThreshold($threshold, __METHOD__);        }        $this->flush_threshold = $threshold;        $this->flush_counter = 0;        $this->document->fflush();        return $this;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
439,thephpleague_csv_Writer_487, Adds multiple records to the CSV document.\n\n @see Writer::insertOne\n,Dodaje više zapisa u CSV dokument.,public function insertAll(iterable $records): int    {        $bytes = 0;        foreach ($records as $record) {            $bytes += $this->insertOne($record);        }        $this->flush_counter = 0;        $this->document->fflush();        return $bytes;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
440,thephpleague_csv_Writer_488," Adds a single record to a CSV document.\n\n A record is an array that can contains scalar types values, NULL values\n or objects implementing the __toString method.\n\n @throws CannotInsertRecord If the record can not be inserted\n","Dodaje jedan zapis u CSV dokument. Zapis je niz koji može da sadrži skalarne vrednosti, null vrednosti ili objekte koji imaju implementiran __toString metod.","public function insertOne(array $record): int    {        $method = 'addRecord';        if (70400 > PHP_VERSION_ID && '' === $this->escape) {            $method = 'addRFC4180CompliantRecord';        }        $record = array_reduce($this->formatters, [$this, 'formatRecord'], $record);        $this->validateRecord($record);        $bytes = $this->$method($record);        if (false === $bytes || 0 >= $bytes) {            throw CannotInsertRecord::triggerOnInsertion($record);        }        return $bytes + $this->consolidate();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
441,thephpleague_csv_Writer_489, Adds a single record to a CSV Document using PHP algorithm.\n\n @see https://php.net/manual/en/function.fputcsv.php\n\n @return int|false\n,Dodaje jedan zapis u CSV dokument koristeći PHP algoritam.,"    protected function addRecord(array $record)    {        return $this->document->fputcsv($record, $this->delimiter, $this->enclosure, $this->escape);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
442,thephpleague_csv_XMLConverter_515, Filter XML element name.\n\n @throws DOMException If the Element name is invalid\n,Filtrira XML element po nazivu.,    protected function filterElementName(string $value): string    {        return (new DOMElement($value))->tagName;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
443,thephpleague_csv_XMLConverter_516, Filter XML attribute name.\n\n @param string $value Element name\n\n @throws DOMException If the Element attribute name is invalid\n,Filtrira XML atribut po nazivu.,    protected function filterAttributeName(string $value): string    {        if ('' === $value) {            return $value;        }        return (new DOMAttr($value))->name;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
444,thephpleague_csv_EmptyEscapeParser_525, Filters the submitted document.\n\n @return SplFileObject|Stream\n,Filtrira dostavljeni dokument.,"private static function filterDocument(object $document)    {        if ($document instanceof Stream || $document instanceof SplFileObject) {            return $document;        }        throw new TypeError(__METHOD__.' expects parameter 1 to be a '.Stream::class.' or a SplFileObject object, '.get_class($document).' given.');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
445,thephpleague_csv_EmptyEscapeParser_526, Extracts a record form the CSV document.\n,Izvlači zapis iz CSV dokumenta.,"private static function extractRecord(): array    {        $record = [];        self::$line = self::$document->fgets();        do {            $is_field_enclosed = false;            $buffer = '';            if (false !== self::$line) {                $buffer = ltrim(self::$line, self::$trim_mask);            }            if (($buffer[0] ?? '') === self::$enclosure) {                $is_field_enclosed = true;                self::$line = $buffer;            }            $record[] = $is_field_enclosed ? self::extractEnclosedFieldContent() : self::extractFieldContent();        } while (false !== self::$line);        return $record;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0
446,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_540, Set the connection name to use in the next query\n\n @param string $name\n\n @return $this\n @throws Exception\n,Postavlja ime konekcije koja će se koristiti u sledećem upitu.,    public function connection($name)    {        if (!isset($this->connectionsSettings[$name]))            throw new Exception('Connection ' . $name . ' was not added.');        $this->defConnectionName = $name;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
447,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_542, A method to get mysqli object or create it in case needed\n\n @return mysqli\n @throws Exception\n,Metod koji dogvara mysqli objekat ili ga pravi u slučaju da je potrebno.,    public function mysqli()    {        if (!isset($this->_mysqli[$this->defConnectionName])) {            $this->connect($this->defConnectionName);        }        return $this->_mysqli[$this->defConnectionName];    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
448,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_545, Helper function to create dbObject with JSON return type\n\n @return MysqliDb\n,Pomoćna funkcija koja pravi dbObject koji vraća JSON.,    public function jsonBuilder()    {        $this->returnType = 'json';        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
449,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_550, This method allows you to specify multiple (method chaining optional) options for SQL queries.\n\n @uses $MySqliDb->setQueryOption('name');\n\n @param string|array $options The options name of the query.\n\n @throws Exception\n @return MysqliDb\n,Ovaj metod omogućava specifikaciju višestrukih opcija za SQL upit.,"    public function setQueryOption($options)    {        $allowedOptions = Array('ALL', 'DISTINCT', 'DISTINCTROW', 'HIGH_PRIORITY', 'STRAIGHT_JOIN', 'SQL_SMALL_RESULT',            'SQL_BIG_RESULT', 'SQL_BUFFER_RESULT', 'SQL_CACHE', 'SQL_NO_CACHE', 'SQL_CALC_FOUND_ROWS',            'LOW_PRIORITY', 'IGNORE', 'QUICK', 'MYSQLI_NESTJOIN', 'FOR UPDATE', 'LOCK IN SHARE MODE');        if (!is_array($options)) {            $options = Array($options);        }        foreach ($options as $option) {            $option = strtoupper($option);            if (!in_array($option, $allowedOptions)) {                throw new Exception('Wrong query option: ' . $option);            }            if ($option == 'MYSQLI_NESTJOIN') {                $this->_nestJoin = true;            } elseif ($option == 'FOR UPDATE') {                $this->_forUpdate = true;            } elseif ($option == 'LOCK IN SHARE MODE') {                $this->_lockInShareMode = true;            } else {                $this->_queryOptions[] = $option;            }        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
450,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_554," A convenient function that returns TRUE if exists at least an element that\n satisfy the where condition specified calling the ""where"" method before this one.\n\n @param string $tableName The name of the database table to work with.\n\n @return bool\n @throws Exception\n",Zgodna funkcija koja vraća tačno ukoliko postoji bar jedan element koji ispinjava “gde” upit koji je definisan “gde” metodom.,"public function has($tableName)    {        $this->getOne($tableName, '1');        return $this->count >= 1;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
451,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_557, Locks a table for R/W action.\n\n @author Jonas Barascu\n\n @param string|array $table The table to be locked. Can be a table or a view.\n\n @return bool if succeeded;\n @throws Exception\n,Zaključava tabelu za upis i ispis.,"public function lock($table){// Main Query$this->_query = ""LOCK TABLES"";// Is the table an array?if(gettype($table) == ""array"") {// Loop trough it and attach it to the queryforeach($table as $key => $value) {if(gettype($value) == ""string"") {if($key > 0) {$this->_query .= "","";}$this->_query .= "" "".self::$prefix.$value."" "".$this->_tableLockMethod;}}}else{// Build the table prefix$table = self::$prefix . $table;// Build the query$this->_query = ""LOCK TABLES "".$table."" "".$this->_tableLockMethod;}// Execute the query unprepared because LOCK only works with unprepared statements.$result = $this->queryUnprepared($this->_query);        $errno  = $this->mysqli()->errno;// Reset the query$this->reset();// Are there rows modified?if($result) {// Return true// We can't return ourself because if one table gets locked, all other ones get unlocked!return true;}// Something went wrongelse {throw new Exception(""Locking of table "".$table."" failed"", $errno);}// Return the success valuereturn false;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
452,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_558, Unlocks all tables in a database.\n Also commits transactions.\n\n @author Jonas Barascu\n @return MysqliDb\n @throws Exception\n,Otključava sve tabele u bazi.,"public function unlock(){// Build the query$this->_query = ""UNLOCK TABLES"";// Execute the query unprepared because UNLOCK and LOCK only works with unprepared statements.$result = $this->queryUnprepared($this->_query);        $errno  = $this->mysqli()->errno;// Reset the query$this->reset();// Are there rows modified?if($result) {// return selfreturn $this;}// Something went wrongelse {throw new Exception(""Unlocking of tables failed"", $errno);}// Return selfreturn $this;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
453,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_559, This methods returns the ID of the last inserted item\n\n @return int The last inserted item ID.\n @throws Exception\n,Ovaj metod vraća ID poslednje dodate stavke.,    public function getInsertId()    {        return $this->mysqli()->insert_id;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
454,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_560, Escape harmful characters which might affect a query.\n\n @param string $str The string to escape.\n\n @return string The escaped string.\n @throws Exception\n,Izbegava opasne karaktere koji bi mogli da utiču na upit.,    public function escape($str)    {        return $this->mysqli()->real_escape_string($str);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
455,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_573, Abstraction method that will build the GROUP BY part of the WHERE statement\n\n @return void\n,Apstraktni metod koji pravi deo “gde” izjave za grupisanje.,"    protected function _buildGroupBy()    {        if (empty($this->_groupBy)) {            return;        }        $this->_query .= "" GROUP BY "";        foreach ($this->_groupBy as $key => $value) {            $this->_query .= $value . "", "";        }        $this->_query = rtrim($this->_query, ', ') . "" "";    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
456,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_576, Method attempts to prepare the SQL query\n and throws an error if there was a problem.\n\n @return mysqli_stmt\n @throws Exception\n,Metod pokušava da pripremi SQL upit i izbacuje grešku ako ima problema.,"protected function _prepareQuery()    {        $stmt = $this->mysqli()->prepare($this->_query);        if ($stmt !== false) {            if ($this->traceEnabled)                $this->traceStartQ = microtime(true);            return $stmt;        }        if ($this->mysqli()->errno === 2006 && $this->autoReconnect === true && $this->autoReconnectCount === 0) {            $this->connect($this->defConnectionName);            $this->autoReconnectCount++;            return $this->_prepareQuery();        }        $error = $this->mysqli()->error;        $query = $this->_query;        $errno = $this->mysqli()->errno;        $this->reset();        throw new Exception(sprintf('%s query: %s', $error, $query), $errno);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
457,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_579, Method returns last executed query\n\n @return string\n,Metod vraća poslednji izvršeni upit.,    public function getLastQuery()    {        return $this->_lastQuery;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
458,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_581, Method returns mysql error code\n\n @return int\n,Metod vraća kod mysql greške.,    public function getLastErrno () {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
459,ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_589, Method to check if needed table is created\n\n @param array $tables Table name or an Array of table names to check\n\n @return bool True if table exists\n @throws Exception\n,Metod koji proverava da li je potrebna tabela napravljena.,"public function tableExists($tables)    {        $tables = !is_array($tables) ? Array($tables) : $tables;        $count = count($tables);        if ($count == 0) {            return false;        }        foreach ($tables as $i => $value)            $tables[$i] = self::$prefix . $value;        $db = isset($this->connectionsSettings[$this->defConnectionName]) ? $this->connectionsSettings[$this->defConnectionName]['db'] : null;        $this->where('table_schema', $db);        $this->where('table_name', $tables, 'in');        $this->get('information_schema.tables', $count);        return $this->count == $count;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
460,ThingEngineer_PHP-MySQLi-Database-Class_dbObject_605, Function to get a total records count\n\n @return int\n,Funkcija koja vraća ukupan broj zapisa.,    protected function count () {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
461,ThingEngineer_PHP-MySQLi-Database-Class_dbObject_609, Converts object data to a JSON string.\n\n @return string Converted data\n,Pretvara podatke objekta u JSON string.,    public function toJson () {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
462,ircmaxell_RandomLib_AbstractMcryptMixer_624, Encrypts a block using the suppied key\n\n @param string $input Plaintext to encrypt\n @param string $key   Encryption key\n\n @return string Resulting ciphertext\n,Enkriiptuje blok koristeći dostavljen ključ,"    private function encryptBlock($input, $key)    {        if (!$input && !$key) {            return '';        }        $this->prepareCipher($key);        $result = mcrypt_generic($this->mcrypt, $input);        mcrypt_generic_deinit($this->mcrypt);        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
463,ircmaxell_RandomLib_AbstractMcryptMixer_625, Derypts a block using the suppied key\n\n @param string $input Ciphertext to decrypt\n @param string $key   Encryption key\n\n @return string Resulting plaintext\n,Dekriptuje blok koristeći dostavljeni ključ.,"    private function decryptBlock($input, $key)    {        if (!$input && !$key) {            return '';        }        $this->prepareCipher($key);        $result = mdecrypt_generic($this->mcrypt, $input);        mcrypt_generic_deinit($this->mcrypt);        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
464,ircmaxell_RandomLib_AbstractMixer_631, Mix the provided array of strings into a single output of the same size\n\n All elements of the array should be the same size.\n\n @param array $parts The parts to be mixed\n\n @return string The mixed result\n,Meša dati niz stringova u jedan izlaz iste veličine. Svi elementi niza bi trebalo da su iste veličine.,"public function mix(array $parts)    {        if (empty($parts)) {            return '';        }        $len        = Util::safeStrlen($parts[0]);        $parts      = $this->normalizeParts($parts);        $stringSize = count($parts[0]);        $partsSize  = count($parts);        $result     = '';        $offset     = 0;        for ($i = 0; $i < $stringSize; $i++) {            $stub = $parts[$offset][$i];            for ($j = 1; $j < $partsSize; $j++) {                $newKey = $parts[($j + $offset) % $partsSize][$i];                //Alternately mix the output for each source                if ($j % 2 == 1) {                    $stub ^= $this->mixParts1($stub, $newKey);                } else {                    $stub ^= $this->mixParts2($stub, $newKey);                }            }            $result .= $stub;            $offset  = ($offset + 1) % $partsSize;        }        return Util::safeSubstr($result, 0, $len);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
465,ircmaxell_RandomLib_AbstractSource_634, Return an instance of Strength indicating the strength of the source\n\n @return \\SecurityLib\\Strength An instance of one of the strength classes\n,Vraća instancu objekta Strength koji ukazuje na jačinu izvora.,    public static function getStrength()    {        return new Strength(Strength::VERYLOW);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
466,ircmaxell_RandomLib_AbstractSource_636," Returns a string of zeroes, useful when no entropy is available.\n\n @param int $size The size of the requested random string\n\n @return string A string of the requested size\n",Vraća string nula. Koristno kada nema entropije.,"protected static function emptyValue($size)    {        return str_repeat(chr(0), $size);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
467,ircmaxell_RandomLib_Factory_637," The Random Factory\n\n Use this factory to instantiate random number generators, sources and mixers.\n\n @category   PHPPasswordLib\n @package    Random\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n","Nasumična fabrika. Koristiti je da se instanciraju generatori nsumičnih brojeva, izvori i mešalice.","class Factory extends \SecurityLib\AbstractFactory{    /**     * @var array A list of available random number mixing strategies     */    protected $mixers = array();    /**     * @var array A list of available random number sources     */    protected $sources = array();    /**     * Build a new instance of the factory, loading core mixers and sources     *     * @return void     */    public function __construct()    {        $this->loadMixers();        $this->loadSources();    }    /**     * Get a generator for the requested strength     *     * @param Strength $strength The requested strength of the random number     *     * @throws RuntimeException If an appropriate mixing strategy isn't found     *     * @return Generator The instantiated generator     */    public function getGenerator(\SecurityLib\Strength $strength)    {        $sources = $this->findSources($strength);        $mixer   = $this->findMixer($strength);        return new Generator($sources, $mixer);    }    /**     * Get a high strength random number generator     *     * High Strength keys should ONLY be used for generating extremely strong     * cryptographic keys.  Generating them is very resource intensive and may     * take several minutes or more depending on the requested size.     *     * @return Generator The instantiated generator     */    public function getHighStrengthGenerator()    {        return $this->getGenerator(new Strength(Strength::HIGH));    }    /**     * Get a low strength random number generator     *     * Low Strength should be used anywhere that random strings are needed in a     * non-cryptographical setting.  They are not strong enough to be used as     * keys or salts.  They are however useful for one-time use tokens.     *     * @return Generator The instantiated generator     */    public function getLowStrengthGenerator()    {        return $this->getGenerator(new Strength(Strength::LOW));    }    /**     * Get a medium strength random number generator     *     * Medium Strength should be used for most needs of a cryptographic nature.     * They are strong enough to be used as keys and salts.  However, they do     * take some time and resources to generate, so they should not be over-used     *     * @return Generator The instantiated generator     */    public function getMediumStrengthGenerator()    {        return $this->getGenerator(new Strength(Strength::MEDIUM));    }    /**     * Get all loaded mixing strategies     *     * @return array An array of mixers     */    public function getMixers()    {        return $this->mixers;    }    /**     * Get all loaded random number sources     *     * @return array An array of sources     */    public function getSources()    {        return $this->sources;    }    /**     * Register a mixing strategy for this factory instance     *     * @param string $name  The name of the stategy     * @param string $class The class name of the implementation     *     * @return Factory $this The current factory instance     */    public function registerMixer($name, $class)    {        $this->registerType(            'mixers',            __NAMESPACE__ . '\\Mixer',            $name,            $class        );        return $this;    }    /**     * Register a random number source for this factory instance     *     * Note that this class must implement the Source interface     *     * @param string $name  The name of the stategy     * @param string $class The class name of the implementation     *     * @return Factory $this The current factory instance     */    public function registerSource($name, $class)    {        $this->registerType(            'sources',            __NAMESPACE__ . '\\Source',            $name,            $class        );        return $this;    }    /**     * Find a sources based upon the requested strength     *     * @param Strength $strength The strength mixer to find     *     * @throws RuntimeException if a valid source cannot be found     *     * @return Source The found source     */    protected function findSources(\SecurityLib\Strength $strength)    {        $sources = array();        foreach ($this->getSources() as $source) {            if ($strength->compare($source::getStrength()) <= 0 && $source::isSupported()) {                $sources[] = new $source();            }        }        if (0 === count($sources)) {            throw new \RuntimeException('Could not find sources');        }        return $sources;    }    /**     * Find a mixer based upon the requested strength     *     * @param Strength $strength The strength mixer to find     *     * @throws RuntimeException if a valid mixer cannot be found     *     * @return Mixer The found mixer     */    protected function findMixer(\SecurityLib\Strength $strength)    {        $newMixer = null;        $fallback = null;        foreach ($this->getMixers() as $mixer) {            if (!$mixer::test()) {                continue;            }            if ($strength->compare($mixer::getStrength()) == 0) {                $newMixer = new $mixer();            } elseif ($strength->compare($mixer::getStrength()) == 1) {                $fallback = new $mixer();            }        }        if (is_null($newMixer)) {            if (is_null($fallback)) {                throw new \RuntimeException('Could not find mixer');            }            return $fallback;        }        return $newMixer;    }    /**     * Load all core mixing strategies     *     * @return void     */    protected function loadMixers()    {        $this->loadFiles(            __DIR__ . '/Mixer',            __NAMESPACE__ . '\\Mixer\\',            array($this, 'registerMixer')        );    }    /**     * Load all core random number sources     *     * @return void     */    protected function loadSources()    {        $this->loadFiles(            __DIR__ . '/Source',            __NAMESPACE__ . '\\Source\\',            array($this, 'registerSource')        );    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
468,ircmaxell_RandomLib_Generator_651, The Random Number Generator Class\n\n Use this factory to generate cryptographic quality random numbers (strings)\n\n @category   PHPPasswordLib\n @package    Random\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @author     Timo Hamina\n,Klasa generatora nsaumičnih brojeva. Koristiti ovu fabriku za generisanje nasumičnih brojeva kriptografskog kvaliteta.,"class Generator{    /**     * @const Flag for uppercase letters     */    const CHAR_UPPER = 1;    /**     * @const Flag for lowercase letters     */    const CHAR_LOWER = 2;    /**     * @const Flag for alpha characters (combines UPPER + LOWER)     */    const CHAR_ALPHA = 3; // CHAR_UPPER | CHAR_LOWER    /**     * @const Flag for digits     */    const CHAR_DIGITS = 4;    /**     * @const Flag for alpha numeric characters     */    const CHAR_ALNUM = 7; // CHAR_ALPHA | CHAR_DIGITS    /**     * @const Flag for uppercase hexadecimal symbols     */    const CHAR_UPPER_HEX = 12; // 8 | CHAR_DIGITS    /**     * @const Flag for lowercase hexidecimal symbols     */    const CHAR_LOWER_HEX = 20; // 16 | CHAR_DIGITS    /**     * @const Flag for base64 symbols     */    const CHAR_BASE64 = 39; // 32 | CHAR_ALNUM    /**     * @const Flag for additional symbols accessible via the keyboard     */    const CHAR_SYMBOLS = 64;    /**     * @const Flag for brackets     */    const CHAR_BRACKETS = 128;    /**     * @const Flag for punctuation marks     */    const CHAR_PUNCT = 256;    /**     * @const Flag for upper/lower-case and digits but without ""B8G6I1l|0OQDS5Z2""     */    const EASY_TO_READ = 512;    /**     * @var Mixer The mixing strategy to use for this generator instance     */    protected $mixer = null;    /**     * @var array An array of random number sources to use for this generator     */    protected $sources = array();    /**     * @var array The different characters, by Flag     */    protected $charArrays = array(        self::CHAR_UPPER     => 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',        self::CHAR_LOWER     => 'abcdefghijklmnopqrstuvwxyz',        self::CHAR_DIGITS    => '0123456789',        self::CHAR_UPPER_HEX => 'ABCDEF',        self::CHAR_LOWER_HEX => 'abcdef',        self::CHAR_BASE64    => '+/',        self::CHAR_SYMBOLS   => '!""#$%&\'()* +,-./:;<=>?@[\]^_`{|}~',        self::CHAR_BRACKETS  => '()[]{}<>',        self::CHAR_PUNCT     => ',.;:',    );    /**     * @internal     * @private     * @const string Ambiguous characters for ""Easy To Read"" sets     */    const AMBIGUOUS_CHARS = 'B8G6I1l|0OQDS5Z2()[]{}:;,.';    /**     * Build a new instance of the generator     *     * @param array $sources An array of random data sources to use     * @param Mixer $mixer   The mixing strategy to use for this generator     */    public function __construct(array $sources, Mixer $mixer)    {        foreach ($sources as $source) {            $this->addSource($source);        }        $this->mixer = $mixer;    }    /**     * Add a random number source to the generator     *     * @param Source $source The random number source to add     *     * @return Generator $this The current generator instance     */    public function addSource(Source $source)    {        $this->sources[] = $source;        return $this;    }    /**     * Generate a random number (string) of the requested size     *     * @param int $size The size of the requested random number     *     * @return string The generated random number (string)     */    public function generate($size)    {        $seeds = array();        foreach ($this->sources as $source) {            $seeds[] = $source->generate($size);        }        return $this->mixer->mix($seeds);    }    /**     * Generate a random integer with the given range     *     * @param int $min The lower bound of the range to generate     * @param int $max The upper bound of the range to generate     *     * @return int The generated random number within the range     */    public function generateInt($min = 0, $max = PHP_INT_MAX)    {        $tmp   = (int) max($max, $min);        $min   = (int) min($max, $min);        $max   = $tmp;        $range = $max - $min;        if ($range == 0) {            return $max;        } elseif ($range > PHP_INT_MAX || is_float($range) || $range < 0) {            /**             * This works, because PHP will auto-convert it to a float at this point,             * But on 64 bit systems, the float won't have enough precision to             * actually store the difference, so we need to check if it's a float             * and hence auto-converted...             */            throw new \RangeException(                'The supplied range is too great to generate'            );        }        $bits  = $this->countBits($range) + 1;        $bytes = (int) max(ceil($bits / 8), 1);        if ($bits == 63) {            /**             * Fixes issue #22             *             * @see https://github.com/ircmaxell/RandomLib/issues/22             */            $mask = 0x7fffffffffffffff;        } else {            $mask = (int) (pow(2, $bits) - 1);        }        /**         * The mask is a better way of dropping unused bits.  Basically what it does         * is to set all the bits in the mask to 1 that we may need.  Since the max         * range is PHP_INT_MAX, we will never need negative numbers (which would         * have the MSB set on the max int possible to generate).  Therefore we         * can just mask that away.  Since pow returns a float, we need to cast         * it back to an int so the mask will work.         *         * On a 64 bit platform, that means that PHP_INT_MAX is 2^63 - 1.  Which         * is also the mask if 63 bits are needed (by the log(range, 2) call).         * So if the computed result is negative (meaning the 64th bit is set), the         * mask will correct that.         *         * This turns out to be slightly better than the shift as we don't need to         * worry about ""fixing"" negative values.         */        do {            $test   = $this->generate($bytes);            $result = hexdec(bin2hex($test)) & $mask;        } while ($result > $range);        return $result + $min;    }    /**     * Generate a random string of specified length.     *     * This uses the supplied character list for generating the new result     * string.     *     * @param int   $length     The length of the generated string     * @param mixed $characters String: An optional list of characters to use     *                          Integer: Character flags     *     * @return string The generated random string     */    public function generateString($length, $characters = '')    {        if (is_int($characters)) {            // Combine character sets            $characters = $this->expandCharacterSets($characters);        }        if ($length == 0 || strlen($characters) == 1) {            return '';        } elseif (empty($characters)) {            // Default to base 64            $characters = $this->expandCharacterSets(self::CHAR_BASE64);        }        // determine how many bytes to generate        // This is basically doing floor(log(strlen($characters)))        // But it's fixed to work properly for all numbers        $len   = strlen($characters);        // The max call here fixes an issue where we under-generate in cases        // where less than 8 bits are needed to represent $len        $bytes = $length * ceil(($this->countBits($len)) / 8);        // determine mask for valid characters        $mask   = 256 - (256 % $len);        $result = '';        do {            $rand = $this->generate($bytes);            for ($i = 0; $i < $bytes; $i++) {                if (ord($rand[$i]) >= $mask) {                    continue;                }                $result .= $characters[ord($rand[$i]) % $len];            }        } while (strlen($result) < $length);        // We may over-generate, since we always use the entire buffer        return substr($result, 0, $length);    }    /**     * Get the Mixer used for this instance     *     * @return Mixer the current mixer     */    public function getMixer()    {        return $this->mixer;    }    /**     * Get the Sources used for this instance     *     * @return Source[] the current mixer     */    public function getSources()    {        return $this->sources;    }    /**     * Count the minimum number of bits to represent the provided number     *     * This is basically floor(log($number, 2))     * But avoids float precision issues     *     * @param int $number The number to count     *     * @return int The number of bits     */    protected function countBits($number)    {        $log2 = 0;        while ($number >>= 1) {            $log2++;        }        return $log2;    }    /**     * Expand a character set bitwise spec into a string character set     *     * This will also replace EASY_TO_READ characters if the flag is set     *     * @param int $spec The spec to expand (bitwise combination of flags)     *     * @return string The expanded string     */    protected function expandCharacterSets($spec)    {        $combined = '';        if ($spec == self::EASY_TO_READ) {            $spec |= self::CHAR_ALNUM;        }        foreach ($this->charArrays as $flag => $chars) {            if ($flag == self::EASY_TO_READ) {                // handle this later                continue;            }            if (($spec & $flag) === $flag) {                $combined .= $chars;            }        }        if ($spec & self::EASY_TO_READ) {            // remove ambiguous characters            $combined = str_replace(str_split(self::AMBIGUOUS_CHARS), '', $combined);        }        return count_chars($combined, 3);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
469,ircmaxell_RandomLib_Generator_654, Generate a random number (string) of the requested size\n\n @param int $size The size of the requested random number\n\n @return string The generated random number (string)\n,Generiši string nasumičnog broja tražene veličine.,    public function generate($size)    {        $seeds = array();        foreach ($this->sources as $source) {            $seeds[] = $source->generate($size);        }        return $this->mixer->mix($seeds);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
470,ircmaxell_RandomLib_Source_664," Generate a random string of the specified size\n\n Note: If the source fails to generate enough data, the result must be\n padded to the requested length.\n\n @param int $size The size of the requested random string\n\n @return string A string of the requested size\n","Generiši nasumičan string tražene veličine. Napomena: Ako izvor ne uspe da generiše dovoljno podataka, rezultat će biti dopunjen do tražene dužine.",    public function generate($size);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
471,ircmaxell_RandomLib_CAPICOM_680, The Capicom Random Number Source\n\n This uses the Windows CapiCom Com object to generate random numbers\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,Capicom generator nasumičnih brojeva. Koristi Windows CapiCom Com objekat da generiše nasumične brojeve.,"class CAPICOM extends \RandomLib\AbstractSource{    /**     * Return an instance of Strength indicating the strength of the source     *     * @return \SecurityLib\Strength An instance of one of the strength classes     */    public static function getStrength()    {        return new Strength(Strength::MEDIUM);    }    /**     * If the source is currently available.     * Reasons might be because the library is not installed     *     * @return bool     */    public static function isSupported()    {        return class_exists('\\COM', false);    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        try {            $util = new \COM('CAPICOM.Utilities.1');            $data = base64_decode($util->GetRandom($size, 0));            return str_pad($data, $size, chr(0));        } catch (\Exception $e) {            unset($e);            return static::emptyValue($size);        }    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
472,ircmaxell_RandomLib_MicroTime_687, The Microtime Random Number Source\n\n This uses the current micro-second (looped several times) for a  random number source.  This is only useful when combined with several other\n stronger sources\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,Microtime generator nasumičnih brojeva. Koristi trenutno vreme u mikrosekundama kao izvor nasumičnih brojeva. Ovo je jedino korisno kada se kombinuje sa više drugih jačih izvora.,"final class MicroTime extends \RandomLib\AbstractSource{    /**     * A static counter to ensure unique hashes and prevent state collisions     *     * @var int A counter     */    private static $counter = null;    /**     * The current state of the random number generator.     *     * @var string The state of the PRNG     */    private static $state = '';    public function __construct()    {        $state = self::$state;        if (function_exists('posix_times')) {            $state .= serialize(posix_times());        }        if (!defined('HHVM_VERSION') && function_exists('zend_thread_id')) {            $state .= zend_thread_id();        }        if (function_exists('hphp_get_thread_id')) {            $state .= hphp_get_thread_id();        }        $state      .= getmypid() . memory_get_usage();        $state      .= serialize($_ENV);        $state      .= serialize($_SERVER);        $state      .= count(debug_backtrace(false));        self::$state = hash('sha512', $state, true);        if (is_null(self::$counter)) {            list(, self::$counter) = unpack(""i"", Util::safeSubstr(self::$state, 0, 4));            $seed = $this->generate(Util::safeStrlen(dechex(PHP_INT_MAX)));            list(, self::$counter) = unpack(""i"", $seed);        }    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        $result      = '';        $seed        = microtime() . memory_get_usage();        self::$state = hash('sha512', self::$state . $seed, true);        /**         * Make the generated randomness a bit better by forcing a GC run which         * should complete in a indeterminate amount of time, hence improving         * the strength of the randomness a bit. It's still not crypto-safe,         * but at least it's more difficult to predict.         */        gc_collect_cycles();        for ($i = 0; $i < $size; $i += 8) {            $seed = self::$state .                    microtime() .                    pack('Ni', $i, self::counter());            self::$state = hash('sha512', $seed, true);            /**             * We only use the first 8 bytes here to prevent exposing the state             * in its entirety, which could potentially expose other random             * generations in the future (in the same process)...             */            $result .= Util::safeSubstr(self::$state, 0, 8);        }        return Util::safeSubstr($result, 0, $size);    }    private static function counter()    {        if (self::$counter >= PHP_INT_MAX) {            self::$counter = -1 * PHP_INT_MAX - 1;        } else {            self::$counter++;        }        return self::$counter;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
473,ircmaxell_RandomLib_OpenSSL_689, The OpenSSL Random Number Source\n\n This uses the OS's secure generator to generate high strength numbers\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,OpenSSL generator nasumičnih brojeva. Koristi bezbedan generator operativnog sistema da generiše jake brojeve.,"class OpenSSL extends \RandomLib\AbstractSource{    /**     * Return an instance of Strength indicating the strength of the source     *     * @return \SecurityLib\Strength An instance of one of the strength classes     */    public static function getStrength()    {        /**         * Prior to PHP 5.6.12 (see https://bugs.php.net/bug.php?id=70014) the ""openssl_random_pseudo_bytes""         * was using ""RAND_pseudo_bytes"" (predictable) instead of ""RAND_bytes"" (unpredictable).         * Release notes: http://php.net/ChangeLog-5.php#5.6.12         */        if (PHP_VERSION_ID >= 50612) {            return new Strength(Strength::HIGH);        }                /**         * Prior to PHP 5.5.28 (see https://bugs.php.net/bug.php?id=70014) the ""openssl_random_pseudo_bytes""         * was using ""RAND_pseudo_bytes"" (predictable) instead of ""RAND_bytes"" (unpredictable).         * Release notes: http://php.net/ChangeLog-5.php#5.5.28         */        if (PHP_VERSION_ID >= 50528 && PHP_VERSION_ID < 50600) {            return new Strength(Strength::HIGH);        }                /**         * Prior to PHP 5.4.44 (see https://bugs.php.net/bug.php?id=70014) the ""openssl_random_pseudo_bytes""         * was using ""RAND_pseudo_bytes"" (predictable) instead of ""RAND_bytes"" (unpredictable).         * Release notes: http://php.net/ChangeLog-5.php#5.4.44         */        if (PHP_VERSION_ID >= 50444 && PHP_VERSION_ID < 50500) {            return new Strength(Strength::HIGH);        }                return new Strength(Strength::MEDIUM);    }    /**     * If the source is currently available.     * Reasons might be because the library is not installed     *     * @return bool     */    public static function isSupported()    {        return function_exists('openssl_random_pseudo_bytes');    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        if ($size < 1) {            return str_repeat(chr(0), $size);        }        /**         * Note, normally we would check the return of of $crypto_strong to         * ensure that we generated a good random string.  However, since we're         * using this as one part of many sources a low strength random number         * shouldn't be much of an issue.         */        return openssl_random_pseudo_bytes($size);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
474,ircmaxell_RandomLib_Rand_693, The Rand Random Number Source\n\n This source generates low strength random numbers by using the internal\n rand() function.  By itself it is quite weak.  However when combined with\n other sources it does provide significant benefit.\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,"Rand izvor nasumičnih brojeva. Ovaj izvor generiše nasumične brojeve slabe snage koristeći unutrašnju rand funkciju. Sam po sebi je dosta slab, ali kada se kombinuje sa drugim izvorima donosi dosta prednosti.",class Rand extends \RandomLib\AbstractSource{    /**     * Return an instance of Strength indicating the strength of the source     *     * @return \SecurityLib\Strength An instance of one of the strength classes     */    public static function getStrength()    {        // Detect if Suhosin Hardened PHP patch is applied        if (defined('S_ALL')) {            return new Strength(Strength::LOW);        } else {            return new Strength(Strength::VERYLOW);        }    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        $result = '';        for ($i = 0; $i < $size; $i++) {            $result .= chr((rand() ^ rand()) % 256);        }        return $result;    }},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
475,ircmaxell_RandomLib_RandomBytes_699, If the source is currently available.\n Reasons might be because the library is not installed\n\n @return bool\n,Proverava da li je izvor dostupan. Razlozi mogu biti da neka biblioteka nije instalirana.,    public static function isSupported()    {        return function_exists('random_bytes');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
476,ircmaxell_RandomLib_UniqID_710, The UniqID Random Number Source\n\n This uses the internal `uniqid()` function to generate low strength random\n numbers.\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,UniqID izvor nasumičnih brojeva. Koristi unutrašnju uniqid() funkciju da generiše slabe nasumične brojeve.,"class UniqID extends \RandomLib\AbstractSource{    /**     * Return an instance of Strength indicating the strength of the source     *     * @return \SecurityLib\Strength An instance of one of the strength classes     */    public static function getStrength()    {        return new Strength(Strength::LOW);    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        $result = '';        while (Util::safeStrlen($result) < $size) {            $result = uniqid($result, true);        }        return Util::safeSubstr($result, 0, $size);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
477,denissimon_prediction-builder_PredictionBuilder_739, Reads the data from a given array\n \n @param array $data\n\n @throws \\InvalidArgumentException\n,Čita podatke iz datog niza.,    public function readFromArray(array $data) {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
478,denissimon_prediction-builder_PredictionBuilder_743, Sum of the vector values\n \n @param array $vector\n\n @return number\n,Suma vrednosti vektora.,    private function sum(array $vector) {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
479,denissimon_prediction-builder_PredictionBuilder_744, Sum of the vector squared values\n\n @param array $vector\n\n @return number\n,Suma kvadrata vrednosti vektora.,    private function sumSquared(array $vector) {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
480,denissimon_prediction-builder_PredictionBuilder_750, Creats a linear model that fits the data.\n The resulting equation has the form: h(x) = a + bx\n\n @param float $a\n @param float $b\n\n @return \\Closure\n,Pravi linearni model koji odgovara podacima. Rezultujuća jednačina ima formu h(x)=a+bx.,"    private function createModel($a, $b) {        return function($x) use ($a, $b) {             return $a + $b*$x;        };",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
481,denissimon_prediction-builder_PredictionBuilder_752," Builds a prediction of the expected value of y for a given x, based on a linear regression model.\n\n @return \\stdClass\n\n @throws \\InvalidArgumentException\n",Pravi predviđanje očekivane vrednosti y za dato x zasnovano na modelu linearne regresije.,    public function build() {,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
482,src_Clusterers_DBSCAN_760, Return the string representation of the object.\n\n @return string\n,Vraća tekstualnu reprezentaciju objekta u vidu stringa.,    public function __toString() : string    {        return 'DBSCAN (' . Params::stringify($this->params()) . ')';    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
483,src_Clusterers_FuzzyCMeans_766, Has the learner been trained?\n\n @return bool\n,Da li je učenik obučen?,    public function trained() : bool    {        return !empty($this->centroids);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
484,src_Clusterers_FuzzyCMeans_767, Return the computed cluster centroids of the training data.\n\n @return array[]\n,Vraća izračunate centroide klastera podataka za obučavanje.,    public function centroids() : array    {        return $this->centroids;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
485,src_Clusterers_FuzzyCMeans_769, Return the loss for each epoch from the last training session.\n\n @return float[]|null\n,Vraća gubitak svake epohe iz prethodne obučavajuće sesije.,    public function losses() : ?array    {        return $this->losses;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
486,src_Clusterers_FuzzyCMeans_770, Train the learner with a dataset.\n\n @param \\Rubix\\ML\\Datasets\\Dataset $dataset\n,Obuči učenika pomoću skupa podataka.,"public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),        ])->check();        if ($this->logger) {            $this->logger->info(""$this initialized"");        }        $this->centroids = $this->seeder->seed($dataset, $this->c);        $this->losses = [];        $features = $dataset->features();        $prevLoss = INF;        for ($epoch = 1; $epoch <= $this->epochs; ++$epoch) {            $memberships = array_map([$this, 'probaSample'], $dataset->samples());            $loss = $this->inertia($dataset->samples(), $memberships);            if (is_nan($loss)) {                if ($this->logger) {                    $this->logger->info('Numerical instability detected');                }                break;            }            $loss /= $dataset->numSamples();            $this->losses[$epoch] = $loss;            if ($this->logger) {                $this->logger->info(""Epoch $epoch - Inertia: $loss"");            }            foreach ($this->centroids as $cluster => &$centroid) {                $means = [];                foreach ($features as $column => $values) {                    $sigma = $total = 0.0;                    foreach ($memberships as $i => $probabilities) {                        $weight = $probabilities[$cluster] ** $this->fuzz;                        $sigma += $weight * $values[$i];                        $total += $weight;                    }                    $means[] = $sigma / $total;                }                $centroid = $means;            }            if ($loss <= 0.0) {                break;            }            if (abs($prevLoss - $loss) < $this->minChange) {                break;            }            $prevLoss = $loss;        }        if ($this->logger) {            $this->logger->info('Training complete');        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
487,src_Clusterers_FuzzyCMeans_772, Predict a single sample and return the result.\n\n @internal\n\n @param (int|float)[] $sample\n @return int\n,Predvidi jedan uzorak i vrati rezultat.,    public function predictSample(array $sample) : int    {        return argmax($this->probaSample($sample));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
488,src_Clusterers_FuzzyCMeans_773, Estimate the joint probabilities for each possible outcome.\n\n @param \\Rubix\\ML\\Datasets\\Dataset $dataset\n @throws \\Rubix\\ML\\Exceptions\\RuntimeException\n @return list<float[]>\n,Proceni združene verovatnoće za svaki mogući rezultat.,"    public function proba(Dataset $dataset) : array    {        if (empty($this->centroids)) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'probaSample'], $dataset->samples());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
489,src_Clusterers_KMeans_798,K Means\n\n A fast online centroid-based hard clustering algorithm capable of grouping linearly\n separable data points given some prior knowledge of the target number of clusters\n (defined by  minimizes the inertia cost function. Inertia is defined as the average sum of distances\n between each sample and its nearest cluster centroid.\n\n References:\n [1] D. Sculley. (2010). Web-Scale K-Means Clustering.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n,K means. Brzi online algoritam za klastering zasnovan na centroidima sposoban da grupiše linearno separabilne uzorke za dato prethodno znanje o ciljanom broju klastera. Definisan je funkcijom inercije. Inercija se definiše kao prosečna suma udaljenost između svakog uzorka i njegovog najbližeg centroida grupe.,"class KMeans implements Estimator, Learner, Online, Probabilistic, Verbose, Persistable{    use AutotrackRevisions, LoggerAware;    /**     * The target number of clusters.     *     * @var int     */    protected int $k;    /**     * The size of each mini batch in samples.     *     * @var int     */    protected int $batchSize;    /**     * The maximum number of iterations to run until the algorithm terminates.     *     * @var int     */    protected int $epochs;    /**     * The minimum change in the inertia for training to continue.     *     * @var float     */    protected float $minChange;    /**     * The number of epochs without improvement in the training loss to wait before considering an early stop.     *     * @var int     */    protected int $window;    /**     * The distance function to use when computing the distances.     *     * @var \Rubix\ML\Kernels\Distance\Distance     */    protected \Rubix\ML\Kernels\Distance\Distance $kernel;    /**     * The cluster centroid seeder.     *     * @var \Rubix\ML\Clusterers\Seeders\Seeder     */    protected \Rubix\ML\Clusterers\Seeders\Seeder $seeder;    /**     * The computed centroid vectors of the training data.     *     * @var array[]     */    protected array $centroids = [        //    ];    /**     * The number of training samples contained within each cluster centroid.     *     * @var int[]     */    protected array $sizes = [        //    ];    /**     * The loss at each epoch from the last training session.     *     * @var float[]|null     */    protected ?array $losses = null;    /**     * @param int $k     * @param int $batchSize     * @param int $epochs     * @param float $minChange     * @param int $window     * @param \Rubix\ML\Kernels\Distance\Distance|null $kernel     * @param \Rubix\ML\Clusterers\Seeders\Seeder|null $seeder     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(        int $k,        int $batchSize = 128,        int $epochs = 1000,        float $minChange = 1e-4,        int $window = 5,        ?Distance $kernel = null,        ?Seeder $seeder = null    ) {        if ($k < 1) {            throw new InvalidArgumentException('K must be greater'                . "" than 0, $k given."");        }        if ($batchSize < 1) {            throw new InvalidArgumentException('Batch size must be'                . "" greater than 0, $batchSize given."");        }        if ($epochs < 1) {            throw new InvalidArgumentException('Number of epochs'                . "" must be greater than 0, $epochs given."");        }        if ($minChange < 0.0) {            throw new InvalidArgumentException('Minimum change must be'                . "" greater than 0, $minChange given."");        }        if ($window < 1) {            throw new InvalidArgumentException('Window must be'                . "" greater than 0, $window given."");        }        $this->k = $k;        $this->batchSize = $batchSize;        $this->epochs = $epochs;        $this->minChange = $minChange;        $this->window = $window;        $this->kernel = $kernel ?? new Euclidean();        $this->seeder = $seeder ?? new PlusPlus($kernel);    }    /**     * Return the estimator type.     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::clusterer();    }    /**     * Return the data types that the estimator is compatible with.     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @return mixed[]     */    public function params() : array    {        return [            'k' => $this->k,            'batch size' => $this->batchSize,            'epochs' => $this->epochs,            'min change' => $this->minChange,            'window' => $this->window,            'kernel' => $this->kernel,            'seeder' => $this->seeder,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return !empty($this->centroids);    }    /**     * Return the computed cluster centroids of the training data.     *     * @return array[]     */    public function centroids() : array    {        return $this->centroids;    }    /**     * Return the number of training samples each centroid is responsible for.     *     * @return int[]     */    public function sizes() : array    {        return $this->sizes;    }    /**     * Return an iterable progress table with the steps from the last training session.     *     * @return \Generator<mixed[]>     */    public function steps() : Generator    {        if (!$this->losses) {            return;        }        foreach ($this->losses as $epoch => $loss) {            yield [                'epoch' => $epoch,                'loss' => $loss,            ];        }    }    /**     * Return the loss for each epoch from the last training session.     *     * @return float[]|null     */    public function losses() : ?array    {        return $this->losses;    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     */    public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),        ])->check();        $this->centroids = $this->seeder->seed($dataset, $this->k);        $sizes = array_fill(0, $this->k, 0);        $sizes[0] = $dataset->numSamples();        $this->sizes = $sizes;        $this->partial($dataset);    }    /**     * Perform a partial train on the learner.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     */    public function partial(Dataset $dataset) : void    {        if (empty($this->centroids) or empty($this->sizes)) {            $this->train($dataset);            return;        }        SpecificationChain::with([            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new DatasetHasDimensionality($dataset, count(current($this->centroids))),        ])->check();        if ($this->logger) {            $this->logger->info(""$this initialized"");        }        $labels = array_fill(0, $dataset->numSamples(), 0);        $dataset = Labeled::quick($dataset->samples(), $labels);        $prevLoss = $bestLoss = INF;        $delta = 0;        $this->losses = [];        for ($epoch = 1; $epoch <= $this->epochs; ++$epoch) {            $batches = $dataset->randomize()->batch($this->batchSize);            $loss = 0.0;            foreach ($batches as $i => &$batch) {                $assignments = array_map([$this, 'predictSample'], $batch->samples());                $labels = $batch->labels();                foreach ($assignments as $j => $cluster) {                    $expected = $labels[$j];                    if ($cluster !== $expected) {                        $labels[$j] = $cluster;                        --$this->sizes[$expected];                        ++$this->sizes[$cluster];                    }                }                $batch = Labeled::quick($batch->samples(), $labels);                $loss += $this->inertia($batch->samples(), $labels);                if (is_nan($loss)) {                    if ($this->logger) {                        $this->logger->info('Numerical instability detected');                    }                    break;                }                foreach ($batch->stratify() as $cluster => $stratum) {                    $centroid = &$this->centroids[$cluster];                    $means = array_map([Stats::class, 'mean'], $stratum->features());                    $weight = 1.0 / (1 + $this->sizes[$cluster]);                    foreach ($centroid as $i => &$mean) {                        $mean = (1.0 - $weight) * $mean + $weight * $means[$i];                    }                }            }            $loss /= $dataset->numSamples();            $this->losses[$epoch] = $loss;            if ($this->logger) {                $this->logger->info(""Epoch $epoch - Inertia: $loss"");            }            if ($loss <= 0.0) {                break;            }            if (abs($prevLoss - $loss) < $this->minChange) {                break;            }            if ($loss < $bestLoss) {                $bestLoss = $loss;                $delta = 0;            } else {                ++$delta;            }            if ($delta >= $this->window) {                break;            }            $dataset = Labeled::stack($batches);            $prevLoss = $loss;        }        if ($this->logger) {            $this->logger->info('Training complete');        }    }    /**     * Cluster the dataset by assigning a label to each sample.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int>     */    public function predict(Dataset $dataset) : array    {        if (!$this->centroids) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }    /**     * Label a given sample based on its distance from a particular centroid.     *     * @internal     *     * @param list<int|float> $sample     * @return int     */    public function predictSample(array $sample) : int    {        $bestDistance = INF;        $bestCluster = -1;        foreach ($this->centroids as $cluster => $centroid) {            $distance = $this->kernel->compute($sample, $centroid);            if ($distance < $bestDistance) {                $bestDistance = $distance;                $bestCluster = $cluster;            }        }        return (int) $bestCluster;    }    /**     * Estimate the joint probabilities for each possible outcome.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<float[]>     */    public function proba(Dataset $dataset) : array    {        if (!$this->centroids) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'probaSample'], $dataset->samples());    }    /**     * Return the membership of a sample to each of the k centroids.     *     * @internal     *     * @param list<int|float> $sample     * @return float[]     */    public function probaSample(array $sample) : array    {        $distances = $dist = [];        foreach ($this->centroids as $centroid) {            $distances[] = $this->kernel->compute($sample, $centroid) ?: EPSILON;        }        foreach ($distances as $distanceA) {            $sigma = 0.0;            foreach ($distances as $distanceB) {                $sigma += $distanceA / $distanceB;            }            $dist[] = 1.0 / $sigma;        }        return $dist;    }    /**     * Calculate the average sum of distances between all samples and their closest     * centroid.     *     * @param list<list<int|float>> $samples     * @param list<int> $labels     * @return float     */    protected function inertia(array $samples, array $labels) : float    {        $inertia = 0.0;        foreach ($samples as $i => $sample) {            $centroid = $this->centroids[$labels[$i]];            $inertia += $this->kernel->compute($sample, $centroid);        }        return $inertia;    }    /**     * Return an associative array containing the data used to serialize the object.     *     * @return mixed[]     */    public function __serialize() : array    {        $properties = get_object_vars($this);        unset($properties['losses']);        return $properties;    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'K Means (' . Params::stringify($this->params()) . ')';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
490,src_Clusterers_KMeans_805, Return the number of training samples each centroid is responsible for.\n\n @return int[]\n,Vraća broj obučavajućih uzoraka za koje je svaki centroid zadužen.,    public function sizes() : array    {        return $this->sizes;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
491,src_Clusterers_KMeans_810, Cluster the dataset by assigning a label to each sample.\n\n @param \\Rubix\\ML\\Datasets\\Dataset $dataset\n @throws \\Rubix\\ML\\Exceptions\\RuntimeException\n @return list<int>\n,Grupiši skup podataka dodeljivanjem labele svakom uzorku.,"    public function predict(Dataset $dataset) : array    {        if (!$this->centroids) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
492,src_Clusterers_KMeans_811, Label a given sample based on its distance from a particular centroid.\n\n @internal\n\n @param list<int|float> $sample\n @return int\n,Označi zadati uzorak u zavisnosti od udaljenosti od određenog centroida.,"public function predictSample(array $sample) : int    {        $bestDistance = INF;        $bestCluster = -1;        foreach ($this->centroids as $cluster => $centroid) {            $distance = $this->kernel->compute($sample, $centroid);            if ($distance < $bestDistance) {                $bestDistance = $distance;                $bestCluster = $cluster;            }        }        return (int) $bestCluster;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
493,src_Clusterers_KMeans_813, Return the membership of a sample to each of the k centroids.\n\n @internal\n\n @param list<int|float> $sample\n @return float[]\n,Vrati pripadnost uzorka svakog od k centroida.,"public function probaSample(array $sample) : array    {        $distances = $dist = [];        foreach ($this->centroids as $centroid) {            $distances[] = $this->kernel->compute($sample, $centroid) ?: EPSILON;        }        foreach ($distances as $distanceA) {            $sigma = 0.0;            foreach ($distances as $distanceB) {                $sigma += $distanceA / $distanceB;            }            $dist[] = 1.0 / $sigma;        }        return $dist;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
494,src_Clusterers_MeanShift_817,Mean Shift\n\n A hierarchical clustering algorithm that uses peak finding to locate the candidate centroids of a\n training set given a radius constraint. Near-duplicate candidates are merged together in a final\n post-processing step.\n\n References:\n [1] M. A. Carreira-Perpinan et al. (2015). A Review of Mean-shift Algorithms for Clustering.\n [2] D. Comaniciu et al. (2012). Mean Shift: A Robust Approach Toward Feature Space Analysis.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n,Mean Shift. Hijerarhijski algoritam za klasterizaciju koji koristi pronalazak vrhova da locira kandidate centroida obučavajućeg skopa za zadato ograničenje prečnika. Bliski centroidi su združeni u finalnom koraku.,"class MeanShift implements Estimator, Learner, Probabilistic, Verbose, Persistable{    use AutotrackRevisions, LoggerAware;    /**     * The minimum number of initial centroids.     *     * @var int     */    protected const MIN_SEEDS = 20;    /**     * The maximum distance between two points to be considered neighbors.     *     * @var float     */    protected float $radius;    /**     * The precomputed denominator of the weight calculation.     *     * @var float     */    protected float $delta;    /**     * The ratio of samples from the training set to use as initial centroids.     *     * @var float     */    protected float $ratio;    /**     * The maximum number of iterations to run until the algorithm terminates.     *     * @var int     */    protected int $epochs;    /**     * The minimum shift in the position of the centroids necessary to continue training.     *     * @var float     */    protected float $minShift;    /**     * The spatial tree used to run range searches.     *     * @var \Rubix\ML\Graph\Trees\Spatial     */    protected \Rubix\ML\Graph\Trees\Spatial $tree;    /**     * The cluster centroid seeder.     *     * @var \Rubix\ML\Clusterers\Seeders\Seeder     */    protected \Rubix\ML\Clusterers\Seeders\Seeder $seeder;    /**     * The computed centroid vectors of the training data.     *     * @var array[]     */    protected array $centroids = [        //    ];    /**     * The loss at each epoch from the last training session.     *     * @var float[]|null     */    protected ?array $losses = null;    /**     * Estimate the radius of a cluster that encompasses a certain percentage of     * the training samples.     *     * > **Note**: Since radius estimation scales quadratically in the number of     * samples, for large datasets you can speed up the process by running it on     * a smaller subset of the training data.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @param float $percentile     * @param \Rubix\ML\Kernels\Distance\Distance|null $kernel     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     * @return float     */    public static function estimateRadius(        Dataset $dataset,        float $percentile = 30.0,        ?Distance $kernel = null    ) : float {        if ($percentile < 0.0 or $percentile > 100.0) {            throw new InvalidArgumentException('Percentile must be'                . "" between 0 and 100, $percentile given."");        }        $kernel = $kernel ?? new Euclidean();        $samples = $dataset->samples();        $distances = [];        foreach ($samples as $i => $sampleA) {            foreach ($samples as $j => $sampleB) {                if ($i !== $j) {                    $distances[] = $kernel->compute($sampleA, $sampleB);                }            }        }        return Stats::quantile($distances, $percentile / 100.0);    }    /**     * @param float $radius     * @param float $ratio     * @param int $epochs     * @param float $minShift     * @param \Rubix\ML\Graph\Trees\Spatial|null $tree     * @param \Rubix\ML\Clusterers\Seeders\Seeder|null $seeder     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(        float $radius,        float $ratio = 0.1,        int $epochs = 100,        float $minShift = 1e-4,        ?Spatial $tree = null,        ?Seeder $seeder = null    ) {        if ($radius <= 0.0) {            throw new InvalidArgumentException('Radius must be'                . "" greater than 0, $radius given."");        }        if ($ratio <= 0.0 or $ratio > 1.0) {            throw new InvalidArgumentException('Ratio must be'                . "" between 0 and 1, $ratio given."");        }        if ($epochs < 1) {            throw new InvalidArgumentException('Number of epochs'                . "" must be greater than 0, $epochs given."");        }        if ($minShift < 0.0) {            throw new InvalidArgumentException('Minimum shift must be'                . "" greater than 0, $minShift given."");        }        $this->radius = $radius;        $this->delta = 2.0 * $radius ** 2;        $this->ratio = $ratio;        $this->epochs = $epochs;        $this->minShift = $minShift;        $this->tree = $tree ?? new BallTree();        $this->seeder = $seeder ?? new Random();    }    /**     * Return the estimator type.     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::clusterer();    }    /**     * Return the data types that the estimator is compatible with.     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @return mixed[]     */    public function params() : array    {        return [            'radius' => $this->radius,            'ratio' => $this->ratio,            'epochs' => $this->epochs,            'min shift' => $this->minShift,            'tree' => $this->tree,            'seeder' => $this->seeder,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return !empty($this->centroids);    }    /**     * Return the computed cluster centroids of the training data.     *     * @return array[]     */    public function centroids() : array    {        return $this->centroids;    }    /**     * Return an iterable progress table with the steps from the last training session.     *     * @return \Generator<mixed[]>     */    public function steps() : Generator    {        if (!$this->losses) {            return;        }        foreach ($this->losses as $epoch => $loss) {            yield [                'epoch' => $epoch,                'loss' => $loss,            ];        }    }    /**     * Return the amount of centroid shift at each epoch of training.     *     * @return float[]|null     */    public function losses() : ?array    {        return $this->losses;    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     */    public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),        ])->check();        if ($this->logger) {            $this->logger->info(""$this initialized"");        }        $n = $dataset->numSamples();        $labels = range(0, $n - 1);        $dataset = Labeled::quick($dataset->samples(), $labels);        $k = max(self::MIN_SEEDS, (int) round($this->ratio * $n));        $centroids = $this->seeder->seed($dataset, $k);        $this->tree->grow($dataset);        $this->losses = [];        $previous = $centroids;        for ($epoch = 1; $epoch <= $this->epochs; ++$epoch) {            foreach ($centroids as $i => &$centroidA) {                [$samples, $indices, $distances] = $this->tree->range($centroidA, $this->radius);                $means = array_map([Stats::class, 'mean'], array_transpose($samples));                $mu2 = Stats::mean($distances) ** 2;                $weight = exp(-$mu2 / $this->delta);                foreach ($centroidA as $column => &$mean) {                    $mean = ($weight * $means[$column]) / $weight;                }                foreach ($centroids as $j => $centroidB) {                    if ($i !== $j) {                        $distance = $this->tree->kernel()->compute($centroidA, $centroidB);                        if ($distance < $this->radius) {                            unset($centroids[$j]);                        }                    }                }            }            $loss = $this->shift($centroids, $previous);            if (is_nan($loss)) {                if ($this->logger) {                    $this->logger->info('Numerical instability detected');                }                break;            }            $loss /= $n;            $this->losses[$epoch] = $loss;            if ($this->logger) {                $this->logger->info(""Epoch $epoch - loss: $loss"");            }            if ($loss < $this->minShift) {                break;            }            $previous = $centroids;        }        $this->centroids = array_values($centroids);        $this->tree->destroy();        if ($this->logger) {            $this->logger->info('Training complete');        }    }    /**     * Cluster the dataset by assigning a label to each sample.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int>     */    public function predict(Dataset $dataset) : array    {        if (empty($this->centroids)) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }    /**     * Label a given sample based on its distance from a particular centroid.     *     * @internal     *     * @param list<int|float> $sample     * @return int     */    public function predictSample(array $sample) : int    {        $bestDistance = INF;        $bestCluster = -1;        foreach ($this->centroids as $cluster => $centroid) {            $distance = $this->tree->kernel()->compute($sample, $centroid);            if ($distance < $bestDistance) {                $bestDistance = $distance;                $bestCluster = $cluster;            }        }        return (int) $bestCluster;    }    /**     * Estimate the joint probabilities for each possible outcome.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<float[]>     */    public function proba(Dataset $dataset) : array    {        if (empty($this->centroids)) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'probaSample'], $dataset->samples());    }    /**     * Return the membership of a sample to each of the centroids.     *     * @param list<int|float> $sample     * @return float[]     */    public function probaSample(array $sample) : array    {        $distances = $dist = [];        foreach ($this->centroids as $centroid) {            $distances[] = $this->tree->kernel()->compute($sample, $centroid) ?: EPSILON;        }        foreach ($distances as $distanceA) {            $sigma = 0.0;            foreach ($distances as $distanceB) {                $sigma += $distanceA / $distanceB;            }            $dist[] = 1.0 / $sigma;        }        return $dist;    }    /**     * Calculate the amount of centroid shift from the previous epoch.     *     * @param array[] $current     * @param array[] $previous     * @return float     */    protected function shift(array $current, array $previous) : float    {        $shift = 0.0;        foreach ($current as $cluster => $centroid) {            $prevCentroid = $previous[$cluster];            foreach ($centroid as $column => $mean) {                $shift += abs($prevCentroid[$column] - $mean);            }        }        return $shift;    }    /**     * Return an associative array containing the data used to serialize the object.     *     * @return mixed[]     */    public function __serialize() : array    {        $properties = get_object_vars($this);        unset($properties['losses']);        return $properties;    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'Mean Shift (' . Params::stringify($this->params()) . ')';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
495,src_Clusterers_MeanShift_832, Calculate the amount of centroid shift from the previous epoch.\n\n @param array[] $current\n @param array[] $previous\n @return float\n,Izračunaj količinu pomeraja centroida od prethodne epohe.,"protected function shift(array $current, array $previous) : float    {        $shift = 0.0;        foreach ($current as $cluster => $centroid) {            $prevCentroid = $previous[$cluster];            foreach ($centroid as $column => $mean) {                $shift += abs($prevCentroid[$column] - $mean);            }        }        return $shift;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
496,src_Clusterers_KMC2_835,K-MC2\n\n A fast Plus Plus approximator that replaces the brute force method with a substantially\n faster Markov Chain Monte Carlo (MCMC) sampling procedure with comparable results.\n\n References:\n [1] O. Bachem et al. (2016). Approximate K-Means++ in Sublinear Time.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n,K-MC2 Brzi plus plus aproksimator koji menja brute force metod značajno bržio MCMC procedurom odabiranja sa uporedivim rezultatima. Aproksimativni K Means algoritam.,"class KMC2 implements Seeder{    /**     * The number of candidate nodes in the Markov Chain.     *     * @var int     */    protected int $m;    /**     * The distance kernel used to compute the distance between samples.     *     * @var \Rubix\ML\Kernels\Distance\Distance     */    protected \Rubix\ML\Kernels\Distance\Distance $kernel;    /**     * @param int $m     * @param \Rubix\ML\Kernels\Distance\Distance|null $kernel     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(int $m = 50, ?Distance $kernel = null)    {        if ($m < 1) {            throw new InvalidArgumentException('M must be greater'                . "" than 0, $m given."");        }        $this->m = $m;        $this->kernel = $kernel ?? new Euclidean();    }    /**     * Seed k cluster centroids from a dataset.     *     * @internal     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @param int $k     * @return list<list<string|int|float>>     */    public function seed(Dataset $dataset, int $k) : array    {        DatasetIsNotEmpty::with($dataset)->check();        $centroids = $dataset->randomSubset(1)->samples();        $max = getrandmax();        while (count($centroids) < $k) {            $candidates = $dataset->randomSubsetWithReplacement($this->m)->samples();            $x = array_pop($candidates) ?? [];            $target = end($centroids) ?: [];            $xDistance = $this->kernel->compute($x, $target) ?: EPSILON;            foreach ($candidates as $candidate) {                $yDistance = $this->kernel->compute($candidate, $target);                $density = min(1.0, $yDistance / $xDistance);                $threshold = rand() / $max;                if ($density > $threshold) {                    $xDistance = $yDistance;                    $x = $candidate;                }            }            $centroids[] = $x;        }        return $centroids;    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return ""KMC2 (m: {$this->m}, kernel: {$this->kernel})"";    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
497,src_Clusterers_KMC2_836, Seed k cluster centroids from a dataset.\n\n @internal\n\n @param \\Rubix\\ML\\Datasets\\Dataset $dataset\n @param int $k\n @return list<list<string|int|float>>\n,Posej centroide k klastera iz skupa podataka.,"public function seed(Dataset $dataset, int $k) : array    {        DatasetIsNotEmpty::with($dataset)->check();        $centroids = $dataset->randomSubset(1)->samples();        $max = getrandmax();        while (count($centroids) < $k) {            $candidates = $dataset->randomSubsetWithReplacement($this->m)->samples();            $x = array_pop($candidates) ?? [];            $target = end($centroids) ?: [];            $xDistance = $this->kernel->compute($x, $target) ?: EPSILON;            foreach ($candidates as $candidate) {                $yDistance = $this->kernel->compute($candidate, $target);                $density = min(1.0, $yDistance / $xDistance);                $threshold = rand() / $max;                if ($density > $threshold) {                    $xDistance = $yDistance;                    $x = $candidate;                }            }            $centroids[] = $x;        }        return $centroids;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
498,V1beta1_ClassificationEvaluationMetrics_ConfusionMatrix_874,Confusion matrix of the model running the classification.\n\n Generated from protobuf message <code>google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix</code>\n,Konfuziona matrica modela koji vrši klasifikaciju. Generiše se od protobuf poruke.,"class ConfusionMatrix extends \Google\Protobuf\Internal\Message{    /**     * Output only. IDs of the annotation specs used in the confusion matrix.     * For Tables CLASSIFICATION     * [prediction_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type]     * only list of [annotation_spec_display_name-s][] is populated.     *     * Generated from protobuf field <code>repeated string annotation_spec_id = 1;</code>     */    private $annotation_spec_id;    /**     * Output only. Display name of the annotation specs used in the confusion     * matrix, as they were at the moment of the evaluation. For Tables     * CLASSIFICATION     * [prediction_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type],     * distinct values of the target column at the moment of the model     * evaluation are populated here.     *     * Generated from protobuf field <code>repeated string display_name = 3;</code>     */    private $display_name;    /**     * Output only. Rows in the confusion matrix. The number of rows is equal to     * the size of `annotation_spec_id`.     * `row[i].example_count[j]` is the number of examples that have ground     * truth of the `annotation_spec_id[i]` and are predicted as     * `annotation_spec_id[j]` by the model being evaluated.     *     * Generated from protobuf field <code>repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row row = 2;</code>     */    private $row;    /**     * Constructor.     *     * @param array $data {     *     Optional. Data for populating the Message object.     *     *     @type string[]|\Google\Protobuf\Internal\RepeatedField $annotation_spec_id     *           Output only. IDs of the annotation specs used in the confusion matrix.     *           For Tables CLASSIFICATION     *           [prediction_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type]     *           only list of [annotation_spec_display_name-s][] is populated.     *     @type string[]|\Google\Protobuf\Internal\RepeatedField $display_name     *           Output only. Display name of the annotation specs used in the confusion     *           matrix, as they were at the moment of the evaluation. For Tables     *           CLASSIFICATION     *           [prediction_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type],     *           distinct values of the target column at the moment of the model     *           evaluation are populated here.     *     @type \Google\Cloud\AutoMl\V1beta1\ClassificationEvaluationMetrics\ConfusionMatrix\Row[]|\Google\Protobuf\Internal\RepeatedField $row     *           Output only. Rows in the confusion matrix. The number of rows is equal to     *           the size of `annotation_spec_id`.     *           `row[i].example_count[j]` is the number of examples that have ground     *           truth of the `annotation_spec_id[i]` and are predicted as     *           `annotation_spec_id[j]` by the model being evaluated.     * }     */    public function __construct($data = NULL) {        \GPBMetadata\Google\Cloud\Automl\V1Beta1\Classification::initOnce();        parent::__construct($data);    }    /**     * Output only. IDs of the annotation specs used in the confusion matrix.     * For Tables CLASSIFICATION     * [prediction_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type]     * only list of [annotation_spec_display_name-s][] is populated.     *     * Generated from protobuf field <code>repeated string annotation_spec_id = 1;</code>     * @return \Google\Protobuf\Internal\RepeatedField     */    public function getAnnotationSpecId()    {        return $this->annotation_spec_id;    }    /**     * Output only. IDs of the annotation specs used in the confusion matrix.     * For Tables CLASSIFICATION     * [prediction_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type]     * only list of [annotation_spec_display_name-s][] is populated.     *     * Generated from protobuf field <code>repeated string annotation_spec_id = 1;</code>     * @param string[]|\Google\Protobuf\Internal\RepeatedField $var     * @return $this     */    public function setAnnotationSpecId($var)    {        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);        $this->annotation_spec_id = $arr;        return $this;    }    /**     * Output only. Display name of the annotation specs used in the confusion     * matrix, as they were at the moment of the evaluation. For Tables     * CLASSIFICATION     * [prediction_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type],     * distinct values of the target column at the moment of the model     * evaluation are populated here.     *     * Generated from protobuf field <code>repeated string display_name = 3;</code>     * @return \Google\Protobuf\Internal\RepeatedField     */    public function getDisplayName()    {        return $this->display_name;    }    /**     * Output only. Display name of the annotation specs used in the confusion     * matrix, as they were at the moment of the evaluation. For Tables     * CLASSIFICATION     * [prediction_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type],     * distinct values of the target column at the moment of the model     * evaluation are populated here.     *     * Generated from protobuf field <code>repeated string display_name = 3;</code>     * @param string[]|\Google\Protobuf\Internal\RepeatedField $var     * @return $this     */    public function setDisplayName($var)    {        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);        $this->display_name = $arr;        return $this;    }    /**     * Output only. Rows in the confusion matrix. The number of rows is equal to     * the size of `annotation_spec_id`.     * `row[i].example_count[j]` is the number of examples that have ground     * truth of the `annotation_spec_id[i]` and are predicted as     * `annotation_spec_id[j]` by the model being evaluated.     *     * Generated from protobuf field <code>repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row row = 2;</code>     * @return \Google\Protobuf\Internal\RepeatedField     */    public function getRow()    {        return $this->row;    }    /**     * Output only. Rows in the confusion matrix. The number of rows is equal to     * the size of `annotation_spec_id`.     * `row[i].example_count[j]` is the number of examples that have ground     * truth of the `annotation_spec_id[i]` and are predicted as     * `annotation_spec_id[j]` by the model being evaluated.     *     * Generated from protobuf field <code>repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row row = 2;</code>     * @param \Google\Cloud\AutoMl\V1beta1\ClassificationEvaluationMetrics\ConfusionMatrix\Row[]|\Google\Protobuf\Internal\RepeatedField $var     * @return $this     */    public function setRow($var)    {        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Google\Cloud\AutoMl\V1beta1\ClassificationEvaluationMetrics\ConfusionMatrix\Row::class);        $this->row = $arr;        return $this;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
499,src_Regressors_KNNRegressor_944," KNN Regressor\n\n A version of the K Nearest Neighbors algorithm that uses the average (mean) outcome of\n the  predictions suitable for regression problems.\n\n >  of its computation during inference. For a fast spatial tree-accelerated version, see\n KD Neighbors Regressor.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n",KNN regresor. Verzija algoritma K najbližih suseda koja koristi prosek (srednju vrednost) ishoda predviđanja pogodnih za regresione probleme.,"class KNNRegressor implements Estimator, Learner, Online, Persistable{    use AutotrackRevisions;    /**     * The number of neighbors to consider when making a prediction.     *     * @var int     */    protected int $k;    /**     * Should we consider the distances of our nearest neighbors when making predictions?     *     * @var bool     */    protected bool $weighted;    /**     * The distance kernel to use when computing the distances.     *     * @var \Rubix\ML\Kernels\Distance\Distance     */    protected \Rubix\ML\Kernels\Distance\Distance $kernel;    /**     * The training samples.     *     * @var list<array>     */    protected array $samples = [        //    ];    /**     * The training labels.     *     * @var list<int|float>     */    protected array $labels = [        //    ];    /**     * @param int $k     * @param bool $weighted     * @param \Rubix\ML\Kernels\Distance\Distance|null $kernel     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(int $k = 5, bool $weighted = false, ?Distance $kernel = null)    {        if ($k < 1) {            throw new InvalidArgumentException('At least 1 neighbor is required'                . "" to make a prediction, $k given."");        }        $this->k = $k;        $this->weighted = $weighted;        $this->kernel = $kernel ?? new Euclidean();    }    /**     * Return the estimator type.     *     * @internal     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::regressor();    }    /**     * Return the data types that the estimator is compatible with.     *     * @internal     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return $this->kernel->compatibility();    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @internal     *     * @return mixed[]     */    public function params() : array    {        return [            'k' => $this->k,            'weighted' => $this->weighted,            'kernel' => $this->kernel,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return $this->samples and $this->labels;    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function train(Dataset $dataset) : void    {        $this->samples = $this->labels = [];        $this->partial($dataset);    }    /**     * Perform a partial train on the learner.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function partial(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsLabeled($dataset),            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new LabelsAreCompatibleWithLearner($dataset, $this),        ])->check();        $this->samples = array_merge($this->samples, $dataset->samples());        $this->labels = array_merge($this->labels, $dataset->labels());    }    /**     * Make a prediction based on the nearest neighbors.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int|float>     */    public function predict(Dataset $dataset) : array    {        if (!$this->samples or !$this->labels) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->samples)))->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }    /**     * Predict a single sample and return the result.     *     * @internal     *     * @param list<string|int|float> $sample     * @return int|float     */    public function predictSample(array $sample)    {        [$labels, $distances] = $this->nearest($sample);        if ($this->weighted) {            $weights = [];            foreach ($distances as $distance) {                $weights[] = 1.0 / (1.0 + $distance);            }            return Stats::weightedMean(array_values($labels), $weights);        }        return Stats::mean($labels);    }    /**     * Find the K nearest neighbors to the given sample vector using     * the brute force method.     *     * @param (string|int|float)[] $sample     * @return array[]     */    protected function nearest(array $sample) : array    {        $distances = [];        foreach ($this->samples as $neighbor) {            $distances[] = $this->kernel->compute($sample, $neighbor);        }        asort($distances);        $distances = array_slice($distances, 0, $this->k, true);        $labels = array_intersect_key($this->labels, $distances);        return [$labels, $distances];    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'KNN Regressor (' . Params::stringify($this->params()) . ')';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
500,src_Regressors_KNNRegressor_953, Find the K nearest neighbors to the given sample vector using\n the brute force method.\n\n @param (string|int|float)[] $sample\n @return array[]\n,Naži K najbližih suseda za vektor uzorka koristeći brute force metod.,"protected function nearest(array $sample) : array    {        $distances = [];        foreach ($this->samples as $neighbor) {            $distances[] = $this->kernel->compute($sample, $neighbor);        }        asort($distances);        $distances = array_slice($distances, 0, $this->k, true);        $labels = array_intersect_key($this->labels, $distances);        return [$labels, $distances];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
501,src_Regressors_MLPRegressor_955,"MLP Regressor\n\n A multilayer feed forward neural network with a continuous output layer suitable for\n regression problems. Like the Multilayer Perceptron classifier, the MLP Regressor is\n able to handle complex non-linear regression problems by forming higher-order\n representations of the input features using intermediate hidden layers.\n\n References:\n [1] G. E. Hinton. (1989). Connectionist learning procedures.\n [2] L. Prechelt. (1997). Early Stopping - but when?\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n","MLP regresor. Višeslojna neuralna mreža sa kontinualnim izlaznim slojem pogodna za regresione probleme. Kao višeslojni perceptronski klasifikator, MLP regresor je sposovan da rešava nelinearne regresione probleme tako što pravi reprezentacije ulaznih obeležja višeg reda pomoću skrivenih slojeva.","class MLPRegressor implements Estimator, Learner, Online, Verbose, Persistable{    use AutotrackRevisions, LoggerAware;    /**     * An array composing the user-specified hidden layers of the network in order.     *     * @var \Rubix\ML\NeuralNet\Layers\Hidden[]     */    protected array $hiddenLayers = [        //    ];    /**     * The number of training samples to process at a time.     *     * @var int     */    protected int $batchSize;    /**     * The gradient descent optimizer used to update the network parameters.     *     * @var \Rubix\ML\NeuralNet\Optimizers\Optimizer     */    protected \Rubix\ML\NeuralNet\Optimizers\Optimizer $optimizer;    /**     * The amount of L2 regularization applied to the weights of the output layer.     *     * @var float     */    protected float $alpha;    /**     * The maximum number of training epochs. i.e. the number of times to iterate     * over the entire training set before terminating.     *     * @var int     */    protected int $epochs;    /**     * The minimum change in the training loss necessary to continue training.     *     * @var float     */    protected float $minChange;    /**     * The number of epochs without improvement in the validation score to wait before considering an early stop.     *     * @var int     */    protected int $window;    /**     * The proportion of training samples to use for validation and progress monitoring.     *     * @var float     */    protected float $holdOut;    /**     * The function that computes the loss associated with an erroneous activation during training.     *     * @var \Rubix\ML\NeuralNet\CostFunctions\RegressionLoss     */    protected \Rubix\ML\NeuralNet\CostFunctions\RegressionLoss $costFn;    /**     * The metric used to score the generalization performance of the model during training.     *     * @var \Rubix\ML\CrossValidation\Metrics\Metric     */    protected \Rubix\ML\CrossValidation\Metrics\Metric $metric;    /**     * The underlying neural network instance.     *     * @var \Rubix\ML\NeuralNet\FeedForward|null     */    protected ?\Rubix\ML\NeuralNet\FeedForward $network = null;    /**     * The validation scores at each epoch from the last training session.     *     * @var float[]|null     */    protected ?array $scores = null;    /**     * The loss at each epoch from the last training session.     *     * @var float[]|null     */    protected ?array $losses = null;    /**     * @param \Rubix\ML\NeuralNet\Layers\Hidden[] $hiddenLayers     * @param int $batchSize     * @param \Rubix\ML\NeuralNet\Optimizers\Optimizer|null $optimizer     * @param float $alpha     * @param int $epochs     * @param float $minChange     * @param int $window     * @param float $holdOut     * @param \Rubix\ML\NeuralNet\CostFunctions\RegressionLoss|null $costFn     * @param \Rubix\ML\CrossValidation\Metrics\Metric|null $metric     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(        array $hiddenLayers = [],        int $batchSize = 128,        ?Optimizer $optimizer = null,        float $alpha = 1e-4,        int $epochs = 1000,        float $minChange = 1e-4,        int $window = 3,        float $holdOut = 0.1,        ?RegressionLoss $costFn = null,        ?Metric $metric = null    ) {        foreach ($hiddenLayers as $layer) {            if (!$layer instanceof Hidden) {                throw new InvalidArgumentException('Hidden layer'                    . ' must implement the Hidden interface.');            }        }        if ($batchSize < 1) {            throw new InvalidArgumentException('Batch size must be'                . "" greater than 0, $batchSize given."");        }        if ($alpha < 0.0) {            throw new InvalidArgumentException('Alpha must be'                . "" greater than 0, $alpha given."");        }        if ($epochs < 1) {            throw new InvalidArgumentException('Number of epochs'                . "" must be greater than 0, $epochs given."");        }        if ($minChange < 0.0) {            throw new InvalidArgumentException('Minimum change must be'                . "" greater than 0, $minChange given."");        }        if ($window < 1) {            throw new InvalidArgumentException('Window must be'                . "" greater than 0, $window given."");        }        if ($holdOut < 0.0 or $holdOut > 0.5) {            throw new InvalidArgumentException('Hold out ratio must be'                . "" between 0 and 0.5, $holdOut given."");        }        if ($metric) {            EstimatorIsCompatibleWithMetric::with($this, $metric)->check();        }        $this->hiddenLayers = $hiddenLayers;        $this->batchSize = $batchSize;        $this->optimizer = $optimizer ?? new Adam();        $this->alpha = $alpha;        $this->epochs = $epochs;        $this->minChange = $minChange;        $this->window = $window;        $this->holdOut = $holdOut;        $this->costFn = $costFn ?? new LeastSquares();        $this->metric = $metric ?? new RMSE();    }    /**     * Return the estimator type.     *     * @internal     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::regressor();    }    /**     * Return the data types that the estimator is compatible with.     *     * @internal     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @internal     *     * @return mixed[]     */    public function params() : array    {        return [            'hidden layers' => $this->hiddenLayers,            'batch size' => $this->batchSize,            'optimizer' => $this->optimizer,            'alpha' => $this->alpha,            'epochs' => $this->epochs,            'min change' => $this->minChange,            'window' => $this->window,            'hold out' => $this->holdOut,            'cost fn' => $this->costFn,            'metric' => $this->metric,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return isset($this->network);    }    /**     * Return an iterable progress table with the steps from the last training session.     *     * @return \Generator<mixed[]>     */    public function steps() : Generator    {        if (!$this->losses) {            return;        }        foreach ($this->losses as $epoch => $loss) {            yield [                'epoch' => $epoch,                'score' => $this->scores[$epoch] ?? null,                'loss' => $loss,            ];        }    }    /**     * Return the validation score at each epoch.     *     * @return float[]|null     */    public function scores() : ?array    {        return $this->scores;    }    /**     * Return the training loss at each epoch.     *     * @return float[]|null     */    public function losses() : ?array    {        return $this->losses;    }    /**     * Return the underlying neural network instance or null if not trained.     *     * @return \Rubix\ML\NeuralNet\FeedForward|null     */    public function network() : ?FeedForward    {        return $this->network;    }    /**     * Train the estimator with a dataset.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function train(Dataset $dataset) : void    {        DatasetIsNotEmpty::with($dataset)->check();        $hiddenLayers = $this->hiddenLayers;        $hiddenLayers[] = new Dense(1, $this->alpha, true, new Xavier2());        $this->network = new FeedForward(            new Placeholder1D($dataset->numFeatures()),            $hiddenLayers,            new Continuous($this->costFn),            $this->optimizer        );        $this->network->initialize();        $this->partial($dataset);    }    /**     * Train the network using mini-batch gradient descent with backpropagation.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     */    public function partial(Dataset $dataset) : void    {        if (!$this->network) {            $this->train($dataset);            return;        }        SpecificationChain::with([            new DatasetIsLabeled($dataset),            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new LabelsAreCompatibleWithLearner($dataset, $this),            new DatasetHasDimensionality($dataset, $this->network->input()->width()),        ])->check();        if ($this->logger) {            $this->logger->info(""$this initialized"");        }        [$testing, $training] = $dataset->randomize()->split($this->holdOut);        [$min, $max] = $this->metric->range()->list();        $bestScore = $min;        $bestEpoch = $delta = 0;        $snapshot = null;        $prevLoss = INF;        $this->scores = $this->losses = [];        for ($epoch = 1; $epoch <= $this->epochs; ++$epoch) {            $batches = $training->randomize()->batch($this->batchSize);            $loss = 0.0;            $score = null;            foreach ($batches as $batch) {                $loss += $this->network->roundtrip($batch);            }            if (is_nan($loss)) {                if ($this->logger) {                    $this->logger->info('Numerical instability detected');                }                break;            }            $loss /= count($batches);            $this->losses[$epoch] = $loss;            if (!$testing->empty()) {                $predictions = $this->predict($testing);                $score = $this->metric->score($predictions, $testing->labels());                $this->scores[$epoch] = $score;            }            if ($this->logger) {                $this->logger->info(""Epoch $epoch - {$this->metric}: ""                    . ($score ?? 'n/a') . "", {$this->costFn}: $loss"");            }            if (isset($score)) {                if ($score >= $max) {                    break;                }                if ($score > $bestScore) {                    $bestScore = $score;                    $bestEpoch = $epoch;                    $snapshot = Snapshot::take($this->network);                    $delta = 0;                } else {                    ++$delta;                }                if ($delta >= $this->window) {                    break;                }            }            if ($loss <= 0.0) {                break;            }            if (abs($prevLoss - $loss) < $this->minChange) {                break;            }            $prevLoss = $loss;        }        if ($snapshot and end($this->scores) < $bestScore) {            $snapshot->restore();            if ($this->logger) {                $this->logger->info(""Network restored from snapshot at epoch $bestEpoch"");            }        }        if ($this->logger) {            $this->logger->info('Training complete');        }    }    /**     * Feed a sample through the network and make a prediction based on the     * activation of the output neuron.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int|float>     */    public function predict(Dataset $dataset) : array    {        if (!$this->network) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, $this->network->input()->width())->check();        $activations = $this->network->infer($dataset);        $activations = array_column($activations->asArray(), 0);        return $activations;    }    /**     * Return an associative array containing the data used to serialize the object.     *     * @return mixed[]     */    public function __serialize() : array    {        $properties = get_object_vars($this);        unset($properties['losses'], $properties['scores']);        return $properties;    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'MLP Regressor (' . Params::stringify($this->params()) . ')';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
502,src_Regressors_RegressionTree_980,Regression Tree\n\n A decision tree based on the CART ( algorithm that performs greedy splitting by minimizing the variance of the labels\n at each node split.\n\n References:\n [1] W. Y. Loh. (2011). Classification and Regression Trees.\n [2] K. Alsabti. et al. (1998). CLOUDS: A Decision Tree Classifier for Large Datasets.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n,Regresiono stablo. Stablo odlučivanja zasnovano na CART algoritmu koji izvodi pohlepno deljenje minimizacijom varijanse labela na svakom čvoru.,"class RegressionTree extends CART implements Estimator, Learner, RanksFeatures, Persistable{    use AutotrackRevisions;    /**     * @param int $maxHeight     * @param int $maxLeafSize     * @param float $minPurityIncrease     * @param int|null $maxFeatures     */    public function __construct(        int $maxHeight = PHP_INT_MAX,        int $maxLeafSize = 3,        float $minPurityIncrease = 1e-7,        ?int $maxFeatures = null    ) {        parent::__construct($maxHeight, $maxLeafSize, $minPurityIncrease, $maxFeatures);    }    /**     * Return the estimator type.     *     * @internal     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::regressor();    }    /**     * Return the data types that the estimator is compatible with.     *     * @internal     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::categorical(),            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @internal     *     * @return mixed[]     */    public function params() : array    {        return [            'max height' => $this->maxHeight,            'max leaf size' => $this->maxLeafSize,            'max features' => $this->maxFeatures,            'min purity increase' => $this->minPurityIncrease,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return !$this->bare();    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsLabeled($dataset),            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new LabelsAreCompatibleWithLearner($dataset, $this),        ])->check();        $this->grow($dataset);    }    /**     * Make a prediction based on the value of a terminal node in the tree.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int|float>     */    public function predict(Dataset $dataset) : array    {        if ($this->bare() or !$this->featureCount) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, $this->featureCount)->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }    /**     * Predict a single sample and return the result.     *     * @internal     *     * @param list<string|int|float> $sample     * @return int|float     */    public function predictSample(array $sample)    {        /** @var \Rubix\ML\Graph\Nodes\Average $node */        $node = $this->search($sample);        return $node->outcome();    }    /**     * Terminate the branch with the most likely Average.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     * @return \Rubix\ML\Graph\Nodes\Average     */    protected function terminate(Labeled $dataset) : Average    {        [$mean, $variance] = Stats::meanVar($dataset->labels());        return new Average($mean, $variance, $dataset->numSamples());    }    /**     * Calculate the impurity of a set of labels.     *     * @param list<int|float> $labels     * @return float     */    protected function impurity(array $labels) : float    {        return Stats::variance($labels);    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'Regression Tree (' . Params::stringify($this->params()) . ')';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
503,src_Regressors_Ridge_992,"Ridge\n\n L2 regularized least squares linear model solved using a closed-form solution. The addition\n of regularization, controlled by the  than ordinary linear regression.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n",Grebeno regularizovani linearni model zasnovan na metodi najmanjih kvadrata. Osim regularizacije isti kao običan linearni model.,"class Ridge implements Estimator, Learner, RanksFeatures, Persistable{    use AutotrackRevisions;    /**     * The strength of the L2 regularization penalty.     *     * @var float     */    protected float $alpha;    /**     * The y intercept i.e. the bias added to the decision function.     *     * @var float|null     */    protected ?float $bias = null;    /**     * The computed coefficients of the regression line.     *     * @var \Tensor\Vector|null     */    protected ?\Tensor\Vector $coefficients = null;    /**     * @param float $alpha     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(float $alpha = 1.0)    {        if ($alpha < 0.0) {            throw new InvalidArgumentException('Alpha must be'                . "" greater than 0, $alpha given."");        }        $this->alpha = $alpha;    }    /**     * Return the estimator type.     *     * @internal     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::regressor();    }    /**     * Return the data types that the estimator is compatible with.     *     * @internal     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @internal     *     * @return mixed[]     */    public function params() : array    {        return [            'alpha' => $this->alpha,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return $this->coefficients and isset($this->bias);    }    /**     * Return the weights of features in the decision function.     *     * @return (int|float)[]|null     */    public function coefficients() : ?array    {        return $this->coefficients ? $this->coefficients->asArray() : null;    }    /**     * Return the bias added to the decision function.     *     * @return float|null     */    public function bias() : ?float    {        return $this->bias;    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsLabeled($dataset),            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new LabelsAreCompatibleWithLearner($dataset, $this),        ])->check();        $biases = Matrix::ones($dataset->numSamples(), 1);        $x = Matrix::build($dataset->samples())->augmentLeft($biases);        $y = Vector::build($dataset->labels());        $alphas = array_fill(0, $x->n() - 1, $this->alpha);        array_unshift($alphas, 0.0);        $penalties = Matrix::diagonal($alphas);        $xT = $x->transpose();        $coefficients = $xT->matmul($x)            ->add($penalties)            ->inverse()            ->dot($xT->dot($y))            ->asArray();        $this->bias = (float) array_shift($coefficients);        $this->coefficients = Vector::quick($coefficients);    }    /**     * Make a prediction based on the line calculated from the training data.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int|float>     */    public function predict(Dataset $dataset) : array    {        if (!$this->coefficients or is_null($this->bias)) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count($this->coefficients))->check();        return Matrix::build($dataset->samples())            ->dot($this->coefficients)            ->add($this->bias)            ->asArray();    }    /**     * Return the importance scores of each feature column of the training set.     *     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return float[]     */    public function featureImportances() : array    {        if (is_null($this->coefficients)) {            throw new RuntimeException('Learner has not been trained.');        }        return $this->coefficients->abs()->asArray();    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'Ridge (' . Params::stringify($this->params()) . ')';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
0,PrestaShop_PrestaShop_Alias_808, Class AliasCore.\\\\n,Glavna klasa za pseudonim.,"class AliasCore extends ObjectModel{    public $alias;    public $search;    public $active = true;    /**     * @see ObjectModel::$definition     */    public static $definition = [        'table' => 'alias',        'primary' => 'id_alias',        'fields' => [            'search' => ['type' => self::TYPE_STRING, 'validate' => 'isValidSearch', 'required' => true, 'size' => 255],            'alias' => ['type' => self::TYPE_STRING, 'validate' => 'isValidSearch', 'required' => true, 'size' => 255],            'active' => ['type' => self::TYPE_BOOL, 'validate' => 'isBool'],        ],    ];    /**     * AliasCore constructor.     *     * @param int|null $id Alias ID     * @param string|null $alias Alias     * @param string|null $search Search string     * @param int|null $idLang Language ID     */    public function __construct($id = null, $alias = null, $search = null, $idLang = null)    {        $this->def = Alias::getDefinition($this);        $this->setDefinitionRetrocompatibility();        if ($id) {            parent::__construct($id);        } elseif ($alias && Validate::isValidSearch($alias)) {            if (!Alias::isFeatureActive()) {                $this->alias = trim($alias);                $this->search = trim($search);            } else {                $row = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT a.id_alias, a.search, a.aliasFROM `' . _DB_PREFIX_ . 'alias` aWHERE `alias` = \'' . pSQL($alias) . '\' AND `active` = 1');                if ($row) {                    $this->id = (int) $row['id_alias'];                    $this->search = $search ? trim($search) : $row['search'];                    $this->alias = $row['alias'];                } else {                    $this->alias = trim($alias);                    $this->search = trim($search);                }            }        }    }    /**     * @see ObjectModel::add();     */    public function add($autoDate = true, $nullValues = false)    {        $this->alias = Tools::replaceAccentedChars($this->alias);        $this->search = Tools::replaceAccentedChars($this->search);        if (parent::add($autoDate, $nullValues)) {            // Set cache of feature detachable to true            Configuration::updateGlobalValue('PS_ALIAS_FEATURE_ACTIVE', '1');            return true;        }        return false;    }    /**     * @see ObjectModel::delete();     */    public function delete()    {        if (parent::delete()) {            // Refresh cache of feature detachable            Configuration::updateGlobalValue('PS_ALIAS_FEATURE_ACTIVE', Alias::isCurrentlyUsed($this->def['table'], true));            return true;        }        return false;    }    /**     * Get all found aliases from DB with search query.     *     * @return string Comma separated aliases     */    public function getAliases()    {        if (!Alias::isFeatureActive()) {            return '';        }        $aliases = Db::getInstance()->executeS('SELECT a.aliasFROM `' . _DB_PREFIX_ . 'alias` aWHERE `search` = \'' . pSQL($this->search) . '\'');        $aliases = array_map('implode', $aliases);        return implode(', ', $aliases);    }    /**     * This method is allow to know if a feature is used or active.     *     * @since 1.5.0.1     *     * @return bool     */    public static function isFeatureActive()    {        return Configuration::get('PS_ALIAS_FEATURE_ACTIVE');    }    /**     * This method is allow to know if a alias exist for AdminImportController.     *     * @param int $idAlias Alias ID     *     * @return bool     *     * @since 1.5.6.0     */    public static function aliasExists($idAlias)    {        $sql = new DbQuery();        $sql->select('a.`id_alias`');        $sql->from('alias', 'a');        $sql->where('a.`id_alias` = ' . (int) $idAlias);        $row = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow($sql, false);        return isset($row['id_alias']);    }}",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
1,PrestaShop_PrestaShop_Attachment_813, Class AttachmentCore.\n,Glavna klasa za priložene fajlove.,"class AttachmentCore extends ObjectModel{    public $file;    public $file_name;    public $file_size;    public $name;    public $mime;    public $description;    /** @var int position Position */    public $position;    /**     * @see ObjectModel::$definition     */    public static $definition = [        'table' => 'attachment',        'primary' => 'id_attachment',        'multilang' => true,        'fields' => [            'file' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName', 'required' => true, 'size' => 40],            'mime' => ['type' => self::TYPE_STRING, 'validate' => 'isCleanHtml', 'required' => true, 'size' => 128],            'file_name' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName', 'size' => 128],            'file_size' => ['type' => self::TYPE_INT, 'validate' => 'isUnsignedId'],            /* Lang fields */            'name' => ['type' => self::TYPE_STRING, 'lang' => true, 'validate' => 'isGenericName', 'required' => true, 'size' => 32],            'description' => ['type' => self::TYPE_STRING, 'lang' => true, 'validate' => 'isCleanHtml'],        ],        'associations' => [            'products' => ['type' => self::HAS_MANY, 'field' => 'id_product', 'object' => 'Product', 'association' => 'product_attachment'],        ],    ];    protected $webserviceParameters = [        'objectNodeNames' => 'attachments',        'hidden_fields' => [],        'fields' => [            'file' => [],            'file_name' => [],            'file_size' => [],            'mime' => [],        ],        'associations' => [            'products' => [                'resource' => 'product',                'api' => 'products',                'fields' => [                    'id' => ['required' => true],                ],            ],        ],    ];    /**     * @see ObjectModel::add()     */    public function add($autoDate = true, $nullValues = false)    {        if (file_exists(_PS_DOWNLOAD_DIR_ . $this->file)) {            $this->file_size = filesize(_PS_DOWNLOAD_DIR_ . $this->file);        }        return parent::add($autoDate, $nullValues);    }    /**     * @see ObjectModel::update()     */    public function update($nullValues = false)    {        if (file_exists(_PS_DOWNLOAD_DIR_ . $this->file)) {            $this->file_size = filesize(_PS_DOWNLOAD_DIR_ . $this->file);        }        return parent::update($nullValues);    }    /**     * @see ObjectModel::delete()     */    public function delete()    {        if (file_exists(_PS_DOWNLOAD_DIR_ . $this->file)) {            @unlink(_PS_DOWNLOAD_DIR_ . $this->file);        }        $sql = new DbQuery();        $sql->select('pa.`id_product`');        $sql->from('product_attachment', 'pa');        $sql->where('pa.`id_attachment` = ' . (int) $this->id);        $products = Db::getInstance()->executeS($sql);        Db::getInstance()->delete(            'product_attachment',            '`id_attachment` = ' . (int) $this->id        );        foreach ($products as $product) {            Product::updateCacheAttachment((int) $product['id_product']);        }        return parent::delete();    }    /**     * Delete selection of attachments.     *     * @param array $attachments Attachments     *     * @return bool|int Whether the selection has been successfully deleted     * @todo: Find out if $return can be initialized with true. (breaking change)     */    public function deleteSelection($attachments)    {        $return = 1;        foreach ($attachments as $idAttachment) {            $attachment = new Attachment((int) $idAttachment);            $return &= $attachment->delete();        }        return $return;    }    /**     * Get attachments.     *     * @param int $idLang Language ID     * @param int $idProduct Product ID     * @param bool $include Whether the attachments are included or excluded from the Product ID     *     * @return array|false|mysqli_result|PDOStatement|resource|null Database query result     */    public static function getAttachments($idLang, $idProduct, $include = true)    {        return Db::getInstance()->executeS(            'SELECT *FROM ' . _DB_PREFIX_ . 'attachment aLEFT JOIN ' . _DB_PREFIX_ . 'attachment_lang alON (a.id_attachment = al.id_attachment AND al.id_lang = ' . (int) $idLang . ')WHERE a.id_attachment ' . ($include ? 'IN' : 'NOT IN') . ' (SELECT pa.id_attachmentFROM ' . _DB_PREFIX_ . 'product_attachment paWHERE id_product = ' . (int) $idProduct . ')'        );    }    /**     * Unassociate all products from the current object     *     * @param bool $updateAttachmentCache [default=true] If set to false attachment cache will not be updated     *     * @return bool Deletion result     */    public function deleteAttachments(bool $updateAttachmentCache = true): bool    {        if (0 >= (int) $this->id) {            // Can not delete attachement without id            return false;        }        $res = Db::getInstance()->execute(            'DELETE FROM `' . _DB_PREFIX_ . 'product_attachment` ' .            'WHERE `id_attachment` = ' . (int) $this->id        );        if ($updateAttachmentCache === true) {            $productIds = Db::getInstance()->executeS(                'SELECT `id_product` FROM `' . _DB_PREFIX_ . 'product_attachment` ' .                'WHERE `id_attachment` = ' . (int) $this->id            );            foreach ($productIds as $productId) {                Product::updateCacheAttachment((int) $productId);            }        }        return $res;    }    /**     * Delete Product attachments for the given Product ID.     *     * @param int $idProduct Product ID     *     * @return bool     */    public static function deleteProductAttachments($idProduct)    {        $res = Db::getInstance()->execute('DELETE FROM ' . _DB_PREFIX_ . 'product_attachmentWHERE id_product = ' . (int) $idProduct);        Product::updateCacheAttachment((int) $idProduct);        return $res;    }    /**     * Associate $id_product to the current object.     *     * @param int $idProduct id of the product to associate     *     * @return bool true if success     */    public function attachProduct($idProduct)    {        return static::associateProductAttachment((int) $idProduct, (int) $this->id);    }    /**     * @param int $productId     * @param int $attachmentId     *     * @return bool true if success     */    public static function associateProductAttachment(int $productId, int $attachmentId): bool    {        $res = Db::getInstance()->execute('INSERT INTO ' . _DB_PREFIX_ . 'product_attachment(id_attachment, id_product) VALUES(' . $attachmentId . ', ' . $productId . ')');        Product::updateCacheAttachment($productId);        return $res;    }    /**     * Associate an array of id_attachment $array to the product $id_product     * and remove eventual previous association.     *     * @param int $idProduct Product ID     * @param array $array Attachment IDs     *     * @return bool Whether the attachments have been successfully associated with the Product     */    public static function attachToProduct($idProduct, $array)    {        $result1 = Attachment::deleteProductAttachments($idProduct);        if (is_array($array)) {            $ids = [];            foreach ($array as $idAttachment) {                if ((int) $idAttachment > 0) {                    $ids[] = ['id_product' => (int) $idProduct, 'id_attachment' => (int) $idAttachment];                }            }            if (!empty($ids)) {                $result2 = Db::getInstance()->insert('product_attachment', $ids);            }        }        Product::updateCacheAttachment((int) $idProduct);        if (is_array($array)) {            return $result1 && (!isset($result2) || $result2);        }        return $result1;    }    /**     * Get Attachment IDs for the given Product within the given range of attachment IDs.     *     * @param int $idLang Language ID     * @param array $list List of attachment IDs in which to search     *     * @return array|bool List of attachment IDs found. False if nothing found.     */    public static function getProductAttached($idLang, $list)    {        if (!is_array($list)) {            return false;        }        $idsAttachments = array_column($list, 'id_attachment');        $sql = 'SELECT * FROM `' . _DB_PREFIX_ . 'product_attachment` pa ' .             'LEFT JOIN `' . _DB_PREFIX_ . 'product_lang` pl ON (pa.`id_product` = pl.`id_product`' . Shop::addSqlRestrictionOnLang('pl') . ') ' .             'WHERE `id_attachment` IN (' . implode(',', array_map('intval', $idsAttachments)) . ') ' .             'AND pl.`id_lang` = ' . (int) $idLang;        $tmp = Db::getInstance()->executeS($sql);        $productAttachments = [];        foreach ($tmp as $t) {            $productAttachments[$t['id_attachment']][] = $t['name'];        }        return $productAttachments;    }    /**     * Get attachment products ids of current attachment for association.     *     * @return array<int, array{ id: string }> An array of product ids     */    public function getWsProducts(): array    {        return Db::getInstance()->executeS(            'SELECT p.`id_product` AS id ' .            'FROM `' . _DB_PREFIX_ . 'product_attachment` pa ' .            'INNER JOIN `' . _DB_PREFIX_ . 'product` p ON (p.id_product = pa.id_product) ' .            '' . Shop::addSqlAssociation('product', 'p') . ' ' .            'WHERE pa.`id_attachment` = ' . (int) $this->id        );    }    /**     * Set products ids of current attachment for association.     *     * @param array<int, array{id: int|string }> $products Products ids     *     * @return bool     */    public function setWsProducts(array $products): bool    {        $this->deleteAttachments(true);        foreach ($products as $product) {            Db::getInstance()->execute('INSERT INTO `' . _DB_PREFIX_ . 'product_attachment` (`id_product`, `id_attachment`) VALUES (' . (int) $product['id'] . ', ' . (int) $this->id . ')');            Product::updateCacheAttachment((int) $product['id']);        }        return true;    }}",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
2,PrestaShop_PrestaShop_AddressFormat_806, Get Address format from DB.\\n\\n @param int $idCountry Country ID\\n\\n @return false|string|null Address format\\n\\n @since 1.7.0\\n,Dohvati format adrese iz baze podataka.,"    protected function getFormatDB($idCountry)    {        if (!Cache::isStored('AddressFormat::getFormatDB' . $idCountry)) {            $format = Db::getInstance()->getValue('SELECT formatFROM `' . _DB_PREFIX_ . $this->def['table'] . '`WHERE `id_country` = ' . (int) $idCountry);            $format = trim($format);            Cache::store('AddressFormat::getFormatDB' . $idCountry, $format);            return $format;        }        return Cache::retrieve('AddressFormat::getFormatDB' . $idCountry);    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
3,PrestaShop_PrestaShop_Address_779, Get Zone ID for a given address.\\\\n\\\\n @param int $id_address Address ID for which we want to get the Zone ID\\\\n\\\\n @return int Zone ID\\\\n,Dohvati identifikator zone na osnovu adrese.,"    public static function getZoneById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        if (isset(self::$_idZones[$id_address])) {            return self::$_idZones[$id_address];        }        $id_zone = Hook::exec('actionGetIDZoneByAddressID', ['id_address' => $id_address]);        if (is_numeric($id_zone)) {            self::$_idZones[$id_address] = (int) $id_zone;            return self::$_idZones[$id_address];        }        $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT s.`id_zone` AS id_zone_state, c.`id_zone`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`LEFT JOIN `' . _DB_PREFIX_ . 'state` s ON s.`id_state` = a.`id_state`WHERE a.`id_address` = ' . (int) $id_address);        if (empty($result['id_zone_state']) && empty($result['id_zone'])) {            return false;        }        self::$_idZones[$id_address] = !empty($result['id_zone_state'])            ? (int) $result['id_zone_state']            : (int) $result['id_zone'];        return self::$_idZones[$id_address];    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
4,PrestaShop_PrestaShop_Address_781, Request to check if DNI field is required\\\\\\\\n depending on the current selected country.\\\\\\\\n\\\\\\\\n @param int $idCountry\\\\\\\\n\\\\\\\\n @return bool\\\\\\\\n,Pošalji zahtev za proveru da li je potreno polje za DNS u zavisnosti od trenutno izabrane države.,    public static function dniRequired($idCountry)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT c.`need_identification_number` ' .            'FROM `' . _DB_PREFIX_ . 'country` c ' .            'WHERE c.`id_country` = ' . (int) $idCountry        );    },3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
5,briannesbitt_Carbon_CarbonTimeZone_361, Convert a total minutes offset into a standardized timezone offset string.\\\\n\\\\n @param float $minutes number of total minutes of the timezone shift.\\\\n\\\\n @return string\\\\n,Konvertuj ukupan broj minuta u string pomeraj vremenske zone.,"    public static function getOffsetNameFromMinuteOffset(float $minutes): string    {        $minutes = round($minutes);        $unsignedMinutes = abs($minutes);        return ($minutes < 0 ? '-' : '+').            str_pad((string) floor($unsignedMinutes / 60), 2, '0', STR_PAD_LEFT).            ':'.            str_pad((string) ($unsignedMinutes % 60), 2, '0', STR_PAD_LEFT);    }",0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
6,dompdf_dompdf_Helpers_613, Converts decimal numbers to roman numerals\n\n @param int $num\n\n @throws Exception\n @return string\n,Pretvori decimalane u rimske brojeve.,"    public static function dec2roman($num)    {        static $ones = ["""", ""i"", ""ii"", ""iii"", ""iv"", ""v"", ""vi"", ""vii"", ""viii"", ""ix""];        static $tens = ["""", ""x"", ""xx"", ""xxx"", ""xl"", ""l"", ""lx"", ""lxx"", ""lxxx"", ""xc""];        static $hund = ["""", ""c"", ""cc"", ""ccc"", ""cd"", ""d"", ""dc"", ""dcc"", ""dccc"", ""cm""];        static $thou = ["""", ""m"", ""mm"", ""mmm""];        if (!is_numeric($num)) {            throw new Exception(""dec2roman() requires a numeric argument."");        }        if ($num > 4000 || $num < 0) {            return ""(out of range)"";        }        $num = strrev((string)$num);        $ret = """";        switch (mb_strlen($num)) {            /** @noinspection PhpMissingBreakStatementInspection */            case 4:                $ret .= $thou[$num[3]];            /** @noinspection PhpMissingBreakStatementInspection */            case 3:                $ret .= $hund[$num[2]];            /** @noinspection PhpMissingBreakStatementInspection */            case 2:                $ret .= $tens[$num[1]];            /** @noinspection PhpMissingBreakStatementInspection */            case 1:                $ret .= $ones[$num[0]];            default:                break;        }        return $ret;    }",0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
7,firefly-iii_firefly-iii_AccountController_772, Class AccountController\n,Klasa za upravljanje nalogom.,"class AccountController extends Controller{    use AccountFilter;    private array                      $balanceTypes;    private AccountRepositoryInterface $repository;    /**     * AccountController constructor.     */    public function __construct()    {        parent::__construct();        $this->middleware(            function ($request, $next) {                /** @var User $user */                $user             = auth()->user();                $this->repository = app(AccountRepositoryInterface::class);                $this->repository->setUser($user);                return $next($request);            }        );        $this->balanceTypes = [AccountType::ASSET, AccountType::LOAN, AccountType::DEBT, AccountType::MORTGAGE,];    }    /**     * @param AutocompleteRequest $request     *     * @return JsonResponse     */    public function accounts(AutocompleteRequest $request): JsonResponse    {        $data  = $request->getData();        $types = $data['types'];        $query = $data['query'];        $date  = $data['date'] ?? today(config('app.timezone'));        $return          = [];        $result          = $this->repository->searchAccount((string)$query, $types, $data['limit']);        $defaultCurrency = app('amount')->getDefaultCurrency();        /** @var Account $account */        foreach ($result as $account) {            $nameWithBalance = $account->name;            $currency        = $this->repository->getAccountCurrency($account) ?? $defaultCurrency;            if (in_array($account->accountType->type, $this->balanceTypes, true)) {                $balance         = app('steam')->balance($account, $date);                $nameWithBalance = sprintf('%s (%s)', $account->name, app('amount')->formatAnything($currency, $balance, false));            }            $return[] = [                'id'                      => (string)$account->id,                'name'                    => $account->name,                'name_with_balance'       => $nameWithBalance,                'type'                    => $account->accountType->type,                'currency_id'             => $currency->id,                'currency_name'           => $currency->name,                'currency_code'           => $currency->code,                'currency_symbol'         => $currency->symbol,                'currency_decimal_places' => $currency->decimal_places,            ];        }        // custom order.        $order = [AccountType::ASSET, AccountType::REVENUE, AccountType::EXPENSE];        usort(            $return, function ($a, $b) use ($order) {            $pos_a = array_search($a['type'], $order);            $pos_b = array_search($b['type'], $order);            return $pos_a - $pos_b;        }        );        return response()->json($return);    }}",0.0,1.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
8,paragonie_random_compat_random_bytes_com_dotnet_724," Windows with PHP < 5.3.0 will not have the function\n openssl_random_pseudo_bytes() available, so let's use\n CAPICOM to work around this deficiency.\n\n @param int $bytes\n\n @throws Exception\n\n @return string\n",Funkcija koja ispravlja nedostatak nepodržavanja funkcionalnosti za generisanje openssl slučajnog pseudo bajta na Windows PHP verziji manjoj od 5.3.0,"    function random_bytes($bytes)    {        try {            /** @var int $bytes */            $bytes = RandomCompat_intval($bytes);        } catch (TypeError $ex) {            throw new TypeError(                'random_bytes(): $bytes must be an integer'            );        }        if ($bytes < 1) {            throw new Error(                'Length must be greater than 0'            );        }        /** @var string $buf */        $buf = '';        if (!class_exists('COM')) {            throw new Error(                'COM does not exist'            );        }        /** @var COM $util */        $util = new COM('CAPICOM.Utilities.1');        $execCount = 0;        /**         * Let's not let it loop forever. If we run N times and fail to         * get N bytes of random data, then CAPICOM has failed us.         */        do {            $buf .= base64_decode((string) $util->GetRandom($bytes, 0));            if (RandomCompat_strlen($buf) >= $bytes) {                /**                 * Return our random entropy buffer here:                 */                return (string) RandomCompat_substr($buf, 0, $bytes);            }            ++$execCount;        } while ($execCount < $bytes);        /**         * If we reach here, PHP has failed us.         */        throw new Exception(            'Could not gather sufficient random data'        );    }",0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
9,fzaninotto_Faker_Inn_930, Generates INN Checksum\\n\\n https://ru.wikipedia.org/wiki/%D0%98%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BD%D0%BE%D0%BC%D0%B5%D1%80_%D0%BD%D0%B0%D0%BB%D0%BE%D0%B3%D0%BE%D0%BF%D0%BB%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%89%D0%B8%D0%BA%D0%B0\\n\\n @param string $inn\\n @return string Checksum (one digit)\\n,Generiši GNI kontrolnu sumu.,"    public static function checksum($inn)    {        $multipliers = array(1 => 2, 2 => 4, 3 => 10, 4 => 3, 5 => 5, 6 => 9, 7 => 4, 8 => 6, 9 => 8);        $sum = 0;        for ($i = 1; $i <= 9; $i++) {            $sum += intval(substr($inn, $i-1, 1)) * $multipliers[$i];        }        return strval(($sum % 11) % 10);    }",0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
10,hamcrest_hamcrest-php_FactoryParameter_2309, Compute the declaration code.\n\n @return string\n,Izvuci kod deklaracije,"    public function getDeclaration()    {        $code = $this->getTypeCode() . $this->getInvocation();        if ($this->reflector->isOptional()) {            $default = $this->reflector->getDefaultValue();            if (is_null($default)) {                $default = 'null';            } elseif (is_bool($default)) {                $default = $default ? 'true' : 'false';            } elseif (is_string($default)) {                $default = ""'"" . $default . ""'"";            } elseif (is_numeric($default)) {                $default = strval($default);            } elseif (is_array($default)) {                $default = 'array()';            } else {                echo 'Warning: unknown default type for ' . $this->getMethod()->getFullName() . ""\n"";                var_dump($default);                $default = 'null';            }            $code .= ' = ' . $default;        }        return $code;    }",0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
11,markrogoyski_math-php_Distribution_3514," Assign an ordinal ranking to data - (""1234"" ranking)\\n https://en.wikipedia.org/wiki/Ranking\\n\\n Similar to R: rank(values, ties.method=\\\'first\\\')\\n\\n @param array $values to be ranked\\n\\n @return array Rankings of the data in the same order the values were input\\n",Dodeli redni broj podacima,    public static function ordinalRanking(array $values): array    {        $Xs = $values;        \sort($Xs);        $rankingâŸ®XâŸ¯ = [];        foreach ($Xs as $i => $x) {            $rankingâŸ®XâŸ¯[\strval($x)][] = $i + 1;        }        // Map ranks to values in order they were originally input        $rankedValues = [];        foreach ($values as $value) {            $rankedValues[] = \array_shift($rankingâŸ®XâŸ¯[\strval($value)]);        }        return $rankedValues;    },0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
12,Sylius_Sylius_LaminasPriorityQueueStub_452," Remove an item from the queue\\n\\n This is different than {@link extract()}; its purpose is to dequeue an\\n item.\\n\\n This operation is potentially expensive, as it requires\\n re-initialization and re-population of the inner queue.\\n\\n Note: this removes the first item matching the provided item found. If\\n the same item has been added multiple times, it will not remove other\\n instances.\\n\\n @param  mixed $datum\\n @return bool False if the item was not found, true otherwise.\\n\\n @psalm-param T $datum\\n",Ukloni stavku iz reda. Operacija je potencijalno spora jer zahteva ponovnu inicijalizaciju i popunjavanje reda. Napomena: Ovo uklanja prvu pronađenu stavku koja se podudara sa datom stavkom. ,"    public function remove($datum)    {        $found = false;        foreach ($this->items as $key => $item) {            if ($item['data'] === $datum) {                $found = true;                break;            }        }        if ($found) {            unset($this->items[$key]);            $this->queue = null;            if (! $this->isEmpty()) {                $queue = $this->getQueue();                foreach ($this->items as $item) {                    $queue->insert($item['data'], $item['priority']);                }            }            return true;        }        return false;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
13,Sylius_Sylius_LaminasPriorityQueueStub_1190," Peek at the top node in the queue, based on priority.\n\n @return mixed\n",Zaviri u vrh reda u zavisnosti od prioriteta.,    public function top()    {        return $this->getIterator()->top();    },0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
14,Sylius_Sylius_LaminasPriorityQueueStub_453, Is the queue empty?\\n\\n @return bool\\n,Proveri da li je red prazan.,    public function isEmpty()    {        return (0 === $this->count());    },0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
15,Sylius_Sylius_LaminasPriorityQueueStub_454, How many items are in the queue?\\n\\n @return int\\n,Dohvati broj elemenata u redu.,    public function count()    {        return count($this->items);    },0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
16,Sylius_Sylius_LaminasPriorityQueueStub_456, Extract a node from the inner queue and sift up\\n\\n @return mixed\\n,Izdvoji čvor iz unutrašnjeg reda i prosej ga.,    public function extract()    {        $value = $this->getQueue()->extract();        $keyToRemove = null;        $highestPriority = null;        foreach ($this->items as $key => $item) {            if ($item['data'] !== $value) {                continue;            }            if (null === $highestPriority) {                $highestPriority = $item['priority'];                $keyToRemove = $key;                continue;            }            if ($highestPriority >= $item['priority']) {                continue;            }            $highestPriority = $item['priority'];            $keyToRemove = $key;        }        if ($keyToRemove !== null) {            unset($this->items[$keyToRemove]);        }        return $value;    },0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
17,Sylius_Sylius_LaminasPriorityQueueStub_459, Unserialize a string into a PriorityQueue object\\n\\n Serialization format is compatible with {@link Laminas\\\\Stdlib\\\\SplPriorityQueue}\\n\\n @param  string $data\\n @return void\\n,Deserializuj string u objekat prioritetnog reda.,"    public function unserialize($data)    {        foreach (unserialize($data) as $item) {            $this->insert($item['data'], $item['priority']);        }    }",0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
18,symfony_symfony_RegisterEventListenersAndSubscribersPass_1848," Finds and orders all service tags with the given name by their priority.\n\n The order of additions must be respected for services having the same priority,\n and knowing that the \\SplPriorityQueue class does not respect the FIFO method,\n we should not use this class.\n\n @see https://bugs.php.net/53710\n @see https://bugs.php.net/60926\n",Pronađi i uredi sve servisne oznake sa datim imenom prema prioritetu. Redosled dodavanja mora se poštovati za usluge koje imaju isti prioritet.,"    private function findAndSortTags(array $tagNames, ContainerBuilder $container): array    {        $sortedTags = [];        foreach ($tagNames as $tagName) {            foreach ($container->findTaggedServiceIds($tagName, true) as $serviceId => $tags) {                foreach ($tags as $attributes) {                    $priority = $attributes['priority'] ?? 0;                    $sortedTags[$priority][] = [$tagName, $serviceId, $attributes];                }            }        }        if ($sortedTags) {            krsort($sortedTags);            $sortedTags = array_merge(...$sortedTags);        }        return $sortedTags;    }",0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
19,briannesbitt_Carbon_CarbonPeriod_314, Return the current date.\\\\n\\\\n @return CarbonInterface|null\\\\n,Dohvati trenutni datum,    public function current()    {        return $this->valid()            ? $this->prepareForReturn($this->current)            : null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
20,briannesbitt_Carbon_CarbonPeriod_354, Keep incrementing the current date until a valid date is found or the iteration is ended.\\n\\n @throws RuntimeException\\n\\n @return void\\n,Nastavi da uvećavaš trenutni datum dok se ne pronađe važeći datum ili se iteracija ne završi.,    protected function incrementCurrentDateUntilValid()    {        $attempts = 0;        do {            $this->current = $this->current->add($this->dateInterval);            $this->validationResult = null;            if (++$attempts > static::NEXT_MAX_ATTEMPTS) {                throw new UnreachableException('Could not find next valid date.');            }        } while ($this->validateCurrentDate() === false);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
21,briannesbitt_Carbon_CarbonPeriod_316, Rewind to the start date.\n\n Iterating over a date in the UTC timezone avoids bug during backward DST change.\n\n @see https://bugs.php.net/bug.php?id=72255\n @see https://bugs.php.net/bug.php?id=74274\n @see https://wiki.php.net/rfc/datetime_and_daylight_saving_time\n\n @throws RuntimeException\n\n @return void\n,"Pozicioniraj se nazad na početni datum. Korišćenjem datuma sa vremenskom zonom UTC, iteracija unazad prolazi bez greške koja bi inače nastala zbog promene u letnjem ralunanju vremena. ","    public function rewind()    {        $this->key = 0;        $this->current = ([$this->dateClass, 'make'])($this->startDate);        $settings = $this->getSettings();        if ($this->hasLocalTranslator()) {            $settings['locale'] = $this->getTranslatorLocale();        }        $this->current->settings($settings);        $this->timezone = static::intervalHasTime($this->dateInterval) ? $this->current->getTimezone() : null;        if ($this->timezone) {            $this->current = $this->current->utc();        }        $this->validationResult = null;        if ($this->isStartExcluded() || $this->validateCurrentDate() === false) {            $this->incrementCurrentDateUntilValid();        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
22,botman_botman_CodeIgniterCache_571, Store an item in the cache.\\n\\n @param  string $key\\n @param  mixed $value\\n @param  \\\\DateTime|int $minutes\\n @return void\\n,Sačuvaj podatak u keš memoriji.,"    public function put($key, $value, $minutes)    {        if ($minutes instanceof \Datetime) {            $seconds = $minutes->getTimestamp() - time();        } else {            $seconds = $minutes * 60;        }        $this->cache->save($key, $value, $seconds);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
23,briannesbitt_Carbon_CarbonImmutable_5, Create a very far date representing end of time.\\n\\n @return static\\n,Kreiraj jako udaljen datum koji će da predstavlja kraj vremena.,    public static function endOfTime(): self    {        $date = static::parse('9999-12-31 23:59:59.999999')->years(self::getEndOfTimeYear());        $date->endOfTime = true;        return $date;    },0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
24,getgrav_grav_Cache_1967, The GravCache object is used throughout Grav to store and retrieve cached data.\n It uses DoctrineCache library and supports a variety of caching mechanisms. Those include:\n\n APCu\n RedisCache\n MemCache\n MemCacheD\n FileSystem\n,Klasa GravCache se širom Grav-a za čuvanje i preuzimanje predmemoiranih podataka.Koristi biblioteku DoctrineCache i podržava razne vrste kašnjenja.,"class Cache extends Getters{    /** @var string Cache key. */    protected $key;    /** @var int */    protected $lifetime;    /** @var int */    protected $now;    /** @var Config $config */    protected $config;    /** @var DoctrineCache\CacheProvider */    protected $driver;    /** @var CacheInterface */    protected $simpleCache;    /** @var string */    protected $driver_name;    /** @var string */    protected $driver_setting;    /** @var bool */    protected $enabled;    /** @var string */    protected $cache_dir;    protected static $standard_remove = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'cache://images',        'asset://',    ];    protected static $standard_remove_no_images = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'asset://',    ];    protected static $all_remove = [        'cache://',        'cache://images',        'asset://',        'tmp://'    ];    protected static $assets_remove = [        'asset://'    ];    protected static $images_remove = [        'cache://images'    ];    protected static $cache_remove = [        'cache://'    ];    protected static $tmp_remove = [        'tmp://'    ];    /**     * Constructor     *     * @param Grav $grav     */    public function __construct(Grav $grav)    {        $this->init($grav);    }    /**     * Initialization that sets a base key and the driver based on configuration settings     *     * @param  Grav $grav     * @return void     */    public function init(Grav $grav)    {        $this->config = $grav['config'];        $this->now = time();        if (null === $this->enabled) {            $this->enabled = (bool)$this->config->get('system.cache.enabled');        }        /** @var Uri $uri */        $uri = $grav['uri'];        $prefix = $this->config->get('system.cache.prefix');        $uniqueness = substr(md5($uri->rootUrl(true) . $this->config->key() . GRAV_VERSION), 2, 8);        // Cache key allows us to invalidate all cache on configuration changes.        $this->key = ($prefix ? $prefix : 'g') . '-' . $uniqueness;        $this->cache_dir = $grav['locator']->findResource('cache://doctrine/' . $uniqueness, true, true);        $this->driver_setting = $this->config->get('system.cache.driver');        $this->driver = $this->getCacheDriver();        $this->driver->setNamespace($this->key);        /** @var EventDispatcher $dispatcher */        $dispatcher = Grav::instance()['events'];        $dispatcher->addListener('onSchedulerInitialized', [$this, 'onSchedulerInitialized']);    }    /**     * @return CacheInterface     */    public function getSimpleCache()    {        if (null === $this->simpleCache) {            $cache = new \Grav\Framework\Cache\Adapter\DoctrineCache($this->driver, '', $this->getLifetime());            // Disable cache key validation.            $cache->setValidation(false);            $this->simpleCache = $cache;        }        return $this->simpleCache;    }    /**     * Deletes the old out of date file-based caches     *     * @return int     */    public function purgeOldCache()    {        $cache_dir = dirname($this->cache_dir);        $current = basename($this->cache_dir);        $count = 0;        foreach (new DirectoryIterator($cache_dir) as $file) {            $dir = $file->getBasename();            if ($dir === $current || $file->isDot() || $file->isFile()) {                continue;            }            Folder::delete($file->getPathname());            $count++;        }        return $count;    }    /**     * Public accessor to set the enabled state of the cache     *     * @param bool|int $enabled     * @return void     */    public function setEnabled($enabled)    {        $this->enabled = (bool)$enabled;    }    /**     * Returns the current enabled state     *     * @return bool     */    public function getEnabled()    {        return $this->enabled;    }    /**     * Get cache state     *     * @return string     */    public function getCacheStatus()    {        return 'Cache: [' . ($this->enabled ? 'true' : 'false') . '] Setting: [' . $this->driver_setting . '] Driver: [' . $this->driver_name . ']';    }    /**     * Automatically picks the cache mechanism to use.  If you pick one manually it will use that     * If there is no config option for $driver in the config, or it's set to 'auto', it will     * pick the best option based on which cache extensions are installed.     *     * @return DoctrineCache\CacheProvider  The cache driver to use     */    public function getCacheDriver()    {        $setting = $this->driver_setting;        $driver_name = 'file';        // CLI compatibility requires a non-volatile cache driver        if ($this->config->get('system.cache.cli_compatibility') && (            $setting === 'auto' || $this->isVolatileDriver($setting))) {            $setting = $driver_name;        }        if (!$setting || $setting === 'auto') {            if (extension_loaded('apcu')) {                $driver_name = 'apcu';            } elseif (extension_loaded('wincache')) {                $driver_name = 'wincache';            }        } else {            $driver_name = $setting;        }        $this->driver_name = $driver_name;        switch ($driver_name) {            case 'apc':            case 'apcu':                $driver = new DoctrineCache\ApcuCache();                break;            case 'wincache':                $driver = new DoctrineCache\WinCacheCache();                break;            case 'memcache':                if (extension_loaded('memcache')) {                    $memcache = new \Memcache();                    $memcache->connect(                        $this->config->get('system.cache.memcache.server', 'localhost'),                        $this->config->get('system.cache.memcache.port', 11211)                    );                    $driver = new DoctrineCache\MemcacheCache();                    $driver->setMemcache($memcache);                } else {                    throw new LogicException('Memcache PHP extension has not been installed');                }                break;            case 'memcached':                if (extension_loaded('memcached')) {                    $memcached = new \Memcached();                    $memcached->addServer(                        $this->config->get('system.cache.memcached.server', 'localhost'),                        $this->config->get('system.cache.memcached.port', 11211)                    );                    $driver = new DoctrineCache\MemcachedCache();                    $driver->setMemcached($memcached);                } else {                    throw new LogicException('Memcached PHP extension has not been installed');                }                break;            case 'redis':                if (extension_loaded('redis')) {                    $redis = new \Redis();                    $socket = $this->config->get('system.cache.redis.socket', false);                    $password = $this->config->get('system.cache.redis.password', false);                    $databaseId = $this->config->get('system.cache.redis.database', 0);                    if ($socket) {                        $redis->connect($socket);                    } else {                        $redis->connect(                            $this->config->get('system.cache.redis.server', 'localhost'),                            $this->config->get('system.cache.redis.port', 6379)                        );                    }                    // Authenticate with password if set                    if ($password && !$redis->auth($password)) {                        throw new \RedisException('Redis authentication failed');                    }                    // Select alternate ( !=0 ) database ID if set                    if ($databaseId && !$redis->select($databaseId)) {                        throw new \RedisException('Could not select alternate Redis database ID');                    }                    $driver = new DoctrineCache\RedisCache();                    $driver->setRedis($redis);                } else {                    throw new LogicException('Redis PHP extension has not been installed');                }                break;            default:                $driver = new DoctrineCache\FilesystemCache($this->cache_dir);                break;        }        return $driver;    }    /**     * Gets a cached entry if it exists based on an id. If it does not exist, it returns false     *     * @param  string $id the id of the cached entry     * @return mixed|bool     returns the cached entry, can be any type, or false if doesn't exist     */    public function fetch($id)    {        if ($this->enabled) {            return $this->driver->fetch($id);        }        return false;    }    /**     * Stores a new cached entry.     *     * @param  string       $id       the id of the cached entry     * @param  array|object|int $data     the data for the cached entry to store     * @param  int|null     $lifetime the lifetime to store the entry in seconds     */    public function save($id, $data, $lifetime = null)    {        if ($this->enabled) {            if ($lifetime === null) {                $lifetime = $this->getLifetime();            }            $this->driver->save($id, $data, $lifetime);        }    }    /**     * Deletes an item in the cache based on the id     *     * @param string $id    the id of the cached data entry     * @return bool         true if the item was deleted successfully     */    public function delete($id)    {        if ($this->enabled) {            return $this->driver->delete($id);        }        return false;    }    /**     * Deletes all cache     *     * @return bool     */    public function deleteAll()    {        if ($this->enabled) {            return $this->driver->deleteAll();        }        return false;    }    /**     * Returns a boolean state of whether or not the item exists in the cache based on id key     *     * @param string $id    the id of the cached data entry     * @return bool         true if the cached items exists     */    public function contains($id)    {        if ($this->enabled) {            return $this->driver->contains(($id));        }        return false;    }    /**     * Getter method to get the cache key     *     * @return string     */    public function getKey()    {        return $this->key;    }    /**     * Setter method to set key (Advanced)     *     * @param string $key     * @return void     */    public function setKey($key)    {        $this->key = $key;        $this->driver->setNamespace($this->key);    }    /**     * Helper method to clear all Grav caches     *     * @param string $remove standard|all|assets-only|images-only|cache-only     * @return array     */    public static function clearCache($remove = 'standard')    {        $locator = Grav::instance()['locator'];        $output = [];        $user_config = USER_DIR . 'config/system.yaml';        switch ($remove) {            case 'all':                $remove_paths = self::$all_remove;                break;            case 'assets-only':                $remove_paths = self::$assets_remove;                break;            case 'images-only':                $remove_paths = self::$images_remove;                break;            case 'cache-only':                $remove_paths = self::$cache_remove;                break;            case 'tmp-only':                $remove_paths = self::$tmp_remove;                break;            case 'invalidate':                $remove_paths = [];                break;            default:                if (Grav::instance()['config']->get('system.cache.clear_images_by_default')) {                    $remove_paths = self::$standard_remove;                } else {                    $remove_paths = self::$standard_remove_no_images;                }        }        // Delete entries in the doctrine cache if required        if (in_array($remove, ['all', 'standard'])) {            $cache = Grav::instance()['cache'];            $cache->driver->deleteAll();        }        // Clearing cache event to add paths to clear        Grav::instance()->fireEvent('onBeforeCacheClear', new Event(['remove' => $remove, 'paths' => &$remove_paths]));        foreach ($remove_paths as $stream) {            // Convert stream to a real path            try {                $path = $locator->findResource($stream, true, true);                if ($path === false) {                    continue;                }                $anything = false;                $files = glob($path . '/*');                if (is_array($files)) {                    foreach ($files as $file) {                        if (is_link($file)) {                            $output[] = '<yellow>Skipping symlink:  </yellow>' . $file;                        } elseif (is_file($file)) {                            if (@unlink($file)) {                                $anything = true;                            }                        } elseif (is_dir($file)) {                            if (Folder::delete($file, false)) {                                $anything = true;                            }                        }                    }                }                if ($anything) {                    $output[] = '<red>Cleared:  </red>' . $path . '/*';                }            } catch (Exception $e) {                // stream not found or another error while deleting files.                $output[] = '<red>ERROR: </red>' . $e->getMessage();            }        }        $output[] = '';        if (($remove === 'all' || $remove === 'standard') && file_exists($user_config)) {            touch($user_config);            $output[] = '<red>Touched: </red>' . $user_config;            $output[] = '';        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }        Grav::instance()->fireEvent('onAfterCacheClear', new Event(['remove' => $remove, 'output' => &$output]));        return $output;    }    /**     * @return void     */    public static function invalidateCache()    {        $user_config = USER_DIR . 'config/system.yaml';        if (file_exists($user_config)) {            touch($user_config);        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }    }    /**     * Set the cache lifetime programmatically     *     * @param int $future timestamp     * @return void     */    public function setLifetime($future)    {        if (!$future) {            return;        }        $interval = (int)($future - $this->now);        if ($interval > 0 && $interval < $this->getLifetime()) {            $this->lifetime = $interval;        }    }    /**     * Retrieve the cache lifetime (in seconds)     *     * @return int     */    public function getLifetime()    {        if ($this->lifetime === null) {            $this->lifetime = (int)($this->config->get('system.cache.lifetime') ?: 604800); // 1 week default        }        return $this->lifetime;    }    /**     * Returns the current driver name     *     * @return string     */    public function getDriverName()    {        return $this->driver_name;    }    /**     * Returns the current driver setting     *     * @return string     */    public function getDriverSetting()    {        return $this->driver_setting;    }    /**     * is this driver a volatile driver in that it resides in PHP process memory     *     * @param string $setting     * @return bool     */    public function isVolatileDriver($setting)    {        if (in_array($setting, ['apc', 'apcu', 'xcache', 'wincache'])) {            return true;        }        return false;    }    /**     * Static function to call as a scheduled Job to purge old Doctrine files     *     * @param bool $echo     *     * @return string|void     */    public static function purgeJob($echo = false)    {        /** @var Cache $cache */        $cache = Grav::instance()['cache'];        $deleted_folders = $cache->purgeOldCache();        $msg = 'Purged ' . $deleted_folders . ' old cache folders...';        if ($echo) {            echo $msg;        } else {            return $msg;        }    }    /**     * Static function to call as a scheduled Job to clear Grav cache     *     * @param string $type     * @return void     */    public static function clearJob($type)    {        $result = static::clearCache($type);        static::invalidateCache();        echo strip_tags(implode(""\n"", $result));    }    /**     * @param Event $event     * @return void     */    public function onSchedulerInitialized(Event $event)    {        /** @var Scheduler $scheduler */        $scheduler = $event['scheduler'];        $config = Grav::instance()['config'];        // File Cache Purge        $at = $config->get('system.cache.purge_at');        $name = 'cache-purge';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::purgeJob', [true], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');        // Cache Clear        $at = $config->get('system.cache.clear_at');        $clear_type = $config->get('system.cache.clear_job_type');        $name = 'cache-clear';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::clearJob', [$clear_type], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
25,googleapis_google-api-php-client_Client_607, Attempt to exchange a code for an valid authentication token.\\\\n Helper wrapped around the OAuth 2.0 implementation.\\\\n\\\\n @param $code string code from accounts.google.com\\\\n @return array access token\\\\n,Pokušaj razmeniti kod za važeći autentikacioni token. Omotačka pomoćna metoda implementacije OAuth2.0.,"  public function fetchAccessTokenWithAuthCode($code)  {    if (strlen($code) == 0) {      throw new InvalidArgumentException(""Invalid code"");    }    $auth = $this->getOAuth2Service();    $auth->setCode($code);    $auth->setRedirectUri($this->getRedirectUri());    $httpHandler = HttpHandlerFactory::build($this->getHttpClient());    $creds = $auth->fetchAuthToken($httpHandler);    if ($creds && isset($creds['access_token'])) {      $creds['created'] = time();      $this->setAccessToken($creds);    }    return $creds;  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
26,symfony_http-foundation_BinaryFileResponse_7831, Automatically sets the Last-Modified header according the file modification date.\n,Automatski postavi datumom prilikom poslednje promene u heder poslednje-modifikovano.,"    public function setAutoLastModified()    {        $this->setLastModified(\DateTime::createFromFormat('U', $this->file->getMTime()));        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
27,symfony_http-kernel_ConfigDataCollector_3168," Tries to retrieve information about the current Symfony version.\n\n @return string One of: dev, stable, eom, eol\n",Pokušaj dohvatiti informacije trenutne verzije Symphony,"    private function determineSymfonyState(): string    {        $now = new \DateTime();        $eom = \DateTime::createFromFormat('d/m/Y', '01/'.Kernel::END_OF_MAINTENANCE)->modify('last day of this month');        $eol = \DateTime::createFromFormat('d/m/Y', '01/'.Kernel::END_OF_LIFE)->modify('last day of this month');        if ($now > $eol) {            $versionState = 'eol';        } elseif ($now > $eom) {            $versionState = 'eom';        } elseif ('' !== Kernel::EXTRA_VERSION) {            $versionState = 'dev';        } else {            $versionState = 'stable';        }        return $versionState;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
28,symfony_http-foundation_Response_8034," Determines if the Response validators (ETag, Last-Modified) match\n a conditional value specified in the Request.\n\n If the Response is not modified, it sets the status code to 304 and\n removes the actual content by calling the setNotModified() method.\n\n @return bool true if the Response validators match the Request, false otherwise\n\n @final\n","Utvrdi da li se validatori odgovora(ETag, last-modified) podudaraju sa uslovnom vrednošću navedenom u zahtevu. Ako odgovor nije modifikovan postavi statusni kod na 304 i ukloni stvarni sadržaj pozivanjem metode setNotModified().","    public function isNotModified(Request $request): bool    {        if (!$request->isMethodCacheable()) {            return false;        }        $notModified = false;        $lastModified = $this->headers->get('Last-Modified');        $modifiedSince = $request->headers->get('If-Modified-Since');        if ($etags = $request->getETags()) {            $notModified = \in_array($this->getEtag(), $etags) || \in_array('*', $etags);        }        if ($modifiedSince && $lastModified) {            $notModified = strtotime($modifiedSince) >= strtotime($lastModified) && (!$etags || $notModified);        }        if ($notModified) {            $this->setNotModified();        }        return $notModified;    }",0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
29,barryvdh_laravel-debugbar_LaravelDebugbar_111, Collects the data from the collectors\n\n @return array\n,Sakupi podatke iz kolekcije.,"    public function collect()    {        /** @var Request $request */        $request = $this->app['request'];        $this->data = [            '__meta' => [                'id' => $this->getCurrentRequestId(),                'datetime' => date('Y-m-d H:i:s'),                'utime' => microtime(true),                'method' => $request->getMethod(),                'uri' => $request->getRequestUri(),                'ip' => $request->getClientIp()            ]        ];        foreach ($this->collectors as $name => $collector) {            $this->data[$name] = $collector->collect();        }        // Remove all invalid (non UTF-8) characters        array_walk_recursive(            $this->data,            function (&$item) {                if (is_string($item) && !mb_check_encoding($item, 'UTF-8')) {                    $item = mb_convert_encoding($item, 'UTF-8', 'UTF-8');                }            }        );        if ($this->storage !== null) {            $this->storage->save($this->getCurrentRequestId(), $this->data);        }        return $this->data;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
30,guzzle_guzzle_MessageFormatter_20," Formats log messages using variable substitutions for requests, responses,\\n and other transactional data.\\n\\n The following variable substitutions are supported:\\n\\n - {request}:        Full HTTP request message\\n - {response}:       Full HTTP response message\\n - {ts}:             ISO 8601 date in GMT\\n - {date_iso_8601}   ISO 8601 date in GMT\\n - {date_common_log} Apache common log date using the configured timezone.\\n - {host}:           Host of the request\\n - {method}:         Method of the request\\n - {uri}:            URI of the request\\n - {version}:        Protocol version\\n - {target}:         Request target of the request (path + query + fragment)\\n - {hostname}:       Hostname of the machine that sent the request\\n - {code}:           Status code of the response (if available)\\n - {phrase}:         Reason phrase of the response  (if available)\\n - {error}:          Any error messages (if available)\\n - {req_header_ - {res_header_ - {req_headers}:    Request headers\\n - {res_headers}:    Response headers\\n - {req_body}:       Request body\\n - {res_body}:       Response body\\n\\n @final\\n","Formatiraj poruke dnevnika koristeći promeljive zamene u zahtevima, odgovorima i druge podatke transakcije.","class MessageFormatter implements MessageFormatterInterface{    /**     * Apache Common Log Format.     *     * @link https://httpd.apache.org/docs/2.4/logs.html#common     *     * @var string     */    public const CLF = ""{hostname} {req_header_User-Agent} - [{date_common_log}] \""{method} {target} HTTP/{version}\"" {code} {res_header_Content-Length}"";    public const DEBUG = "">>>>>>>>\n{request}\n<<<<<<<<\n{response}\n--------\n{error}"";    public const SHORT = '[{ts}] ""{method} {target} HTTP/{version}"" {code}';    /**     * @var string Template used to format log messages     */    private $template;    /**     * @param string $template Log message template     */    public function __construct(?string $template = self::CLF)    {        $this->template = $template ?: self::CLF;    }    /**     * Returns a formatted message string.     *     * @param RequestInterface       $request  Request that was sent     * @param ResponseInterface|null $response Response that was received     * @param \Throwable|null        $error    Exception that was received     */    public function format(RequestInterface $request, ?ResponseInterface $response = null, ?\Throwable $error = null): string    {        $cache = [];        /** @var string */        return \preg_replace_callback(            '/{\s*([A-Za-z_\-\.0-9]+)\s*}/',            function (array $matches) use ($request, $response, $error, &$cache) {                if (isset($cache[$matches[1]])) {                    return $cache[$matches[1]];                }                $result = '';                switch ($matches[1]) {                    case 'request':                        $result = Psr7\Message::toString($request);                        break;                    case 'response':                        $result = $response ? Psr7\Message::toString($response) : '';                        break;                    case 'req_headers':                        $result = \trim($request->getMethod()                                . ' ' . $request->getRequestTarget())                            . ' HTTP/' . $request->getProtocolVersion() . ""\r\n""                            . $this->headers($request);                        break;                    case 'res_headers':                        $result = $response ?                            \sprintf(                                'HTTP/%s %d %s',                                $response->getProtocolVersion(),                                $response->getStatusCode(),                                $response->getReasonPhrase()                            ) . ""\r\n"" . $this->headers($response)                            : 'NULL';                        break;                    case 'req_body':                        $result = $request->getBody()->__toString();                        break;                    case 'res_body':                        if (!$response instanceof ResponseInterface) {                            $result = 'NULL';                            break;                        }                        $body = $response->getBody();                        if (!$body->isSeekable()) {                            $result = 'RESPONSE_NOT_LOGGEABLE';                            break;                        }                        $result = $response->getBody()->__toString();                        break;                    case 'ts':                    case 'date_iso_8601':                        $result = \gmdate('c');                        break;                    case 'date_common_log':                        $result = \date('d/M/Y:H:i:s O');                        break;                    case 'method':                        $result = $request->getMethod();                        break;                    case 'version':                        $result = $request->getProtocolVersion();                        break;                    case 'uri':                    case 'url':                        $result = $request->getUri();                        break;                    case 'target':                        $result = $request->getRequestTarget();                        break;                    case 'req_version':                        $result = $request->getProtocolVersion();                        break;                    case 'res_version':                        $result = $response                            ? $response->getProtocolVersion()                            : 'NULL';                        break;                    case 'host':                        $result = $request->getHeaderLine('Host');                        break;                    case 'hostname':                        $result = \gethostname();                        break;                    case 'code':                        $result = $response ? $response->getStatusCode() : 'NULL';                        break;                    case 'phrase':                        $result = $response ? $response->getReasonPhrase() : 'NULL';                        break;                    case 'error':                        $result = $error ? $error->getMessage() : 'NULL';                        break;                    default:                        // handle prefixed dynamic headers                        if (\strpos($matches[1], 'req_header_') === 0) {                            $result = $request->getHeaderLine(\substr($matches[1], 11));                        } elseif (\strpos($matches[1], 'res_header_') === 0) {                            $result = $response                                ? $response->getHeaderLine(\substr($matches[1], 11))                                : 'NULL';                        }                }                $cache[$matches[1]] = $result;                return $result;            },            $this->template        );    }    /**     * Get headers from message as string     */    private function headers(MessageInterface $message): string    {        $result = '';        foreach ($message->getHeaders() as $name => $values) {            $result .= $name . ': ' . \implode(', ', $values) . ""\r\n"";        }        return \trim($result);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
31,getgrav_grav_Debugger_1159, Initialize the debugger\n\n @return $this\n @throws DebugBarException\n,Inicijalizuj objekat klase debager.,"    public function init()    {        if ($this->initialized) {            return $this;        }        $this->grav = Grav::instance();        $this->config = $this->grav['config'];        // Enable/disable debugger based on configuration.        $this->enabled = (bool)$this->config->get('system.debugger.enabled');        $this->censored = (bool)$this->config->get('system.debugger.censored', false);        if ($this->enabled) {            $this->initialized = true;            $clockwork = $debugbar = null;            switch ($this->config->get('system.debugger.provider', 'debugbar')) {                case 'clockwork':                    $this->clockwork = $clockwork = new Clockwork();                    break;                default:                    $this->debugbar = $debugbar = new DebugBar();            }            $plugins_config = (array)$this->config->get('plugins');            ksort($plugins_config);            if ($clockwork) {                $log = $this->grav['log'];                $clockwork->setStorage(new FileStorage('cache://clockwork'));                if (extension_loaded('xdebug')) {                    $clockwork->addDataSource(new XdebugDataSource());                }                if ($log instanceof Logger) {                    $clockwork->addDataSource(new MonologDataSource($log));                }                $timeline = $clockwork->timeline();                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Server');                    $event->finalize($this->requestTime, GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Loading');                    $event->finalize(GRAV_REQUEST_TIME, $this->currentTime);                }                $event = $timeline->event('Site Setup');                $event->finalize($this->currentTime, microtime(true));            }            if ($this->censored) {                $censored = ['CENSORED' => true];            }            if ($debugbar) {                $debugbar->addCollector(new PhpInfoCollector());                $debugbar->addCollector(new MessagesCollector());                if (!$this->censored) {                    $debugbar->addCollector(new RequestDataCollector());                }                $debugbar->addCollector(new TimeDataCollector($this->requestTime));                $debugbar->addCollector(new MemoryCollector());                $debugbar->addCollector(new ExceptionsCollector());                $debugbar->addCollector(new ConfigCollector($censored ?? (array)$this->config->get('system'), 'Config'));                $debugbar->addCollector(new ConfigCollector($censored ?? $plugins_config, 'Plugins'));                $debugbar->addCollector(new ConfigCollector($this->config->get('streams.schemes'), 'Streams'));                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Server', $debugbar['time']->getRequestStartTime(), GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Loading', GRAV_REQUEST_TIME, $this->currentTime);                }                $debugbar['time']->addMeasure('Site Setup', $this->currentTime, microtime(true));            }            $this->addMessage('Grav v' . GRAV_VERSION . ' - PHP ' . PHP_VERSION);            $this->config->debug();            if ($clockwork) {                $clockwork->info('System Configuration', $censored ?? $this->config->get('system'));                $clockwork->info('Plugins Configuration', $censored ?? $plugins_config);                $clockwork->info('Streams', $this->config->get('streams.schemes'));            }        }        return $this;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
32,getgrav_grav_Debugger_1156, Class Debugger\\n @package Grav\\\\Common\\n,Klasa debager,"class Debugger{    /** @var static */    protected static $instance;    /** @var Grav|null */    protected $grav;    /** @var Config|null */    protected $config;    /** @var JavascriptRenderer|null */    protected $renderer;    /** @var DebugBar|null */    protected $debugbar;    /** @var Clockwork|null */    protected $clockwork;    /** @var bool */    protected $enabled = false;    /** @var bool */    protected $initialized = false;    /** @var array */    protected $timers = [];    /** @var array */    protected $deprecations = [];    /** @var callable|null */    protected $errorHandler;    /** @var float */    protected $requestTime;    /** @var float */    protected $currentTime;    /** @var int */    protected $profiling = 0;    /** @var bool */    protected $censored = false;    /**     * Debugger constructor.     */    public function __construct()    {        static::$instance = $this;        $this->currentTime = microtime(true);        if (!defined('GRAV_REQUEST_TIME')) {            define('GRAV_REQUEST_TIME', $this->currentTime);        }        $this->requestTime = $_SERVER['REQUEST_TIME_FLOAT'] ?? GRAV_REQUEST_TIME;        // Set deprecation collector.        $this->setErrorHandler();    }    /**     * @return Clockwork|null     */    public function getClockwork(): ?Clockwork    {        return $this->enabled ? $this->clockwork : null;    }    /**     * Initialize the debugger     *     * @return $this     * @throws DebugBarException     */    public function init()    {        if ($this->initialized) {            return $this;        }        $this->grav = Grav::instance();        $this->config = $this->grav['config'];        // Enable/disable debugger based on configuration.        $this->enabled = (bool)$this->config->get('system.debugger.enabled');        $this->censored = (bool)$this->config->get('system.debugger.censored', false);        if ($this->enabled) {            $this->initialized = true;            $clockwork = $debugbar = null;            switch ($this->config->get('system.debugger.provider', 'debugbar')) {                case 'clockwork':                    $this->clockwork = $clockwork = new Clockwork();                    break;                default:                    $this->debugbar = $debugbar = new DebugBar();            }            $plugins_config = (array)$this->config->get('plugins');            ksort($plugins_config);            if ($clockwork) {                $log = $this->grav['log'];                $clockwork->setStorage(new FileStorage('cache://clockwork'));                if (extension_loaded('xdebug')) {                    $clockwork->addDataSource(new XdebugDataSource());                }                if ($log instanceof Logger) {                    $clockwork->addDataSource(new MonologDataSource($log));                }                $timeline = $clockwork->timeline();                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Server');                    $event->finalize($this->requestTime, GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Loading');                    $event->finalize(GRAV_REQUEST_TIME, $this->currentTime);                }                $event = $timeline->event('Site Setup');                $event->finalize($this->currentTime, microtime(true));            }            if ($this->censored) {                $censored = ['CENSORED' => true];            }            if ($debugbar) {                $debugbar->addCollector(new PhpInfoCollector());                $debugbar->addCollector(new MessagesCollector());                if (!$this->censored) {                    $debugbar->addCollector(new RequestDataCollector());                }                $debugbar->addCollector(new TimeDataCollector($this->requestTime));                $debugbar->addCollector(new MemoryCollector());                $debugbar->addCollector(new ExceptionsCollector());                $debugbar->addCollector(new ConfigCollector($censored ?? (array)$this->config->get('system'), 'Config'));                $debugbar->addCollector(new ConfigCollector($censored ?? $plugins_config, 'Plugins'));                $debugbar->addCollector(new ConfigCollector($this->config->get('streams.schemes'), 'Streams'));                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Server', $debugbar['time']->getRequestStartTime(), GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Loading', GRAV_REQUEST_TIME, $this->currentTime);                }                $debugbar['time']->addMeasure('Site Setup', $this->currentTime, microtime(true));            }            $this->addMessage('Grav v' . GRAV_VERSION . ' - PHP ' . PHP_VERSION);            $this->config->debug();            if ($clockwork) {                $clockwork->info('System Configuration', $censored ?? $this->config->get('system'));                $clockwork->info('Plugins Configuration', $censored ?? $plugins_config);                $clockwork->info('Streams', $this->config->get('streams.schemes'));            }        }        return $this;    }    public function finalize(): void    {        if ($this->clockwork && $this->enabled) {            $this->stopProfiling('Profiler Analysis');            $this->addMeasures();            $deprecations = $this->getDeprecations();            $count = count($deprecations);            if (!$count) {                return;            }            /** @var UserData $userData */            $userData = $this->clockwork->userData('Deprecated');            $userData->counters([                'Deprecated' => count($deprecations)            ]);            /*            foreach ($deprecations as &$deprecation) {                $d = $deprecation;                unset($d['message']);                $this->clockwork->log('deprecated', $deprecation['message'], $d);            }            unset($deprecation);             */            $userData->table('Your site is using following deprecated features', $deprecations);        }    }    public function logRequest(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface    {        if (!$this->enabled || !$this->clockwork) {            return $response;        }        $clockwork = $this->clockwork;        $this->finalize();        $clockwork->timeline()->finalize($request->getAttribute('request_time'));        if ($this->censored) {            $censored = 'CENSORED';            $request = $request                ->withCookieParams([$censored => ''])                ->withUploadedFiles([])                ->withHeader('cookie', $censored);            $request = $request->withParsedBody([$censored => '']);        }        $clockwork->addDataSource(new PsrMessageDataSource($request, $response));        $clockwork->resolveRequest();        $clockwork->storeRequest();        $clockworkRequest = $clockwork->getRequest();        $response = $response            ->withHeader('X-Clockwork-Id', $clockworkRequest->id)            ->withHeader('X-Clockwork-Version', $clockwork::VERSION);        $grav = Grav::instance();        $basePath = $this->grav['base_url_relative'] . $grav['pages']->base();        if ($basePath) {            $response = $response->withHeader('X-Clockwork-Path', $basePath . '/__clockwork/');        }        return $response->withHeader('Server-Timing', ServerTiming::fromRequest($clockworkRequest)->value());    }    public function debuggerRequest(RequestInterface $request): Response    {        $clockwork = $this->clockwork;        $headers = [            'Content-Type' => 'application/json',            'Grav-Internal-SkipShutdown' => 1        ];        $path = $request->getUri()->getPath();        $clockworkDataUri = '#/__clockwork(?:/(?<id>[0-9-]+))?(?:/(?<direction>(?:previous|next)))?(?:/(?<count>\d+))?#';        if (preg_match($clockworkDataUri, $path, $matches) === false) {            $response = ['message' => 'Bad Input'];            return new Response(400, $headers, json_encode($response));        }        $id = $matches['id'] ?? null;        $direction = $matches['direction'] ?? null;        $count = $matches['count'] ?? null;        $storage = $clockwork->getStorage();        if ($direction === 'previous') {            $data = $storage->previous($id, $count);        } elseif ($direction === 'next') {            $data = $storage->next($id, $count);        } elseif ($id === 'latest') {            $data = $storage->latest();        } else {            $data = $storage->find($id);        }        if (preg_match('#(?<id>[0-9-]+|latest)/extended#', $path)) {            $clockwork->extendRequest($data);        }        if (!$data) {            $response = ['message' => 'Not Found'];            return new Response(404, $headers, json_encode($response));        }        $data = is_array($data) ? array_map(function ($item) {            return $item->toArray();        }, $data) : $data->toArray();        return new Response(200, $headers, json_encode($data));    }    /**     * @return void     */    protected function addMeasures(): void    {        if (!$this->enabled) {            return;        }        $nowTime = microtime(true);        $clkTimeLine = $this->clockwork ? $this->clockwork->timeline() : null;        $debTimeLine = $this->debugbar ? $this->debugbar['time'] : null;        foreach ($this->timers as $name => $data) {            $description = $data[0];            $startTime = $data[1] ?? null;            $endTime = $data[2] ?? $nowTime;            if ($clkTimeLine) {                $event = $clkTimeLine->event($description);                $event->finalize($startTime, $endTime);            } elseif ($debTimeLine) {                if ($endTime - $startTime < 0.001) {                    continue;                }                $debTimeLine->addMeasure($description ?? $name, $startTime, $endTime);            }        }        $this->timers = [];    }    /**     * Set/get the enabled state of the debugger     *     * @param bool|null $state If null, the method returns the enabled value. If set, the method sets the enabled state     * @return bool     */    public function enabled($state = null)    {        if ($state !== null) {            $this->enabled = (bool)$state;        }        return $this->enabled;    }    /**     * Add the debugger assets to the Grav Assets     *     * @return $this     */    public function addAssets()    {        if ($this->enabled) {            // Only add assets if Page is HTML            $page = $this->grav['page'];            if ($page->templateFormat() !== 'html') {                return $this;            }            /** @var Assets $assets */            $assets = $this->grav['assets'];            // Clockwork specific assets            if ($this->clockwork) {                $assets->addCss('/system/assets/debugger/clockwork.css', ['loading' => 'inline']);                $assets->addJs('/system/assets/debugger/clockwork.js', ['loading' => 'inline']);            }            // Debugbar specific assets            if ($this->debugbar) {                // Add jquery library                $assets->add('jquery', 101);                $this->renderer = $this->debugbar->getJavascriptRenderer();                $this->renderer->setIncludeVendors(false);                [$css_files, $js_files] = $this->renderer->getAssets(null, JavascriptRenderer::RELATIVE_URL);                foreach ((array)$css_files as $css) {                    $assets->addCss($css);                }                $assets->addCss('/system/assets/debugger/phpdebugbar.css', ['loading' => 'inline']);                foreach ((array)$js_files as $js) {                    $assets->addJs($js);                }            }        }        return $this;    }    /**     * @param int $limit     * @return array     */    public function getCaller($limit = 2)    {        $trace = debug_backtrace(false, $limit);        return array_pop($trace);    }    /**     * Adds a data collector     *     * @param DataCollectorInterface $collector     * @return $this     * @throws DebugBarException     */    public function addCollector($collector)    {        if ($this->debugbar && !$this->debugbar->hasCollector($collector->getName())) {            $this->debugbar->addCollector($collector);        }        return $this;    }    /**     * Returns a data collector     *     * @param string $name     * @return DataCollectorInterface|null     * @throws DebugBarException     */    public function getCollector($name)    {        if ($this->debugbar && $this->debugbar->hasCollector($name)) {            return $this->debugbar->getCollector($name);        }        return null;    }    /**     * Displays the debug bar     *     * @return $this     */    public function render()    {        if ($this->enabled && $this->debugbar) {            // Only add assets if Page is HTML            $page = $this->grav['page'];            if (!$this->renderer || $page->templateFormat() !== 'html') {                return $this;            }            $this->addMeasures();            $this->addDeprecations();            echo $this->renderer->render();        }        return $this;    }    /**     * Sends the data through the HTTP headers     *     * @return $this     */    public function sendDataInHeaders()    {        if ($this->enabled && $this->debugbar) {            $this->addMeasures();            $this->addDeprecations();            $this->debugbar->sendDataInHeaders();        }        return $this;    }    /**     * Returns collected debugger data.     *     * @return array|null     */    public function getData()    {        if (!$this->enabled || !$this->debugbar) {            return null;        }        $this->addMeasures();        $this->addDeprecations();        $this->timers = [];        return $this->debugbar->getData();    }    /**     * Hierarchical Profiler support.     *     * @param callable $callable     * @param string|null $message     * @return mixed     */    public function profile(callable $callable, string $message = null)    {        $this->startProfiling();        $response = $callable();        $this->stopProfiling($message);        return $response;    }    public function addTwigProfiler(Environment $twig): void    {        $clockwork = $this->getClockwork();        if ($clockwork) {            $source = new TwigClockworkDataSource($twig);            $source->listenToEvents();            $clockwork->addDataSource($source);        }    }    /**     * Start profiling code.     *     * @return void     */    public function startProfiling(): void    {        if ($this->enabled && extension_loaded('tideways_xhprof')) {            $this->profiling++;            if ($this->profiling === 1) {                // @phpstan-ignore-next-line                \tideways_xhprof_enable(TIDEWAYS_XHPROF_FLAGS_NO_BUILTINS);            }        }    }    /**     * Stop profiling code. Returns profiling array or null if profiling couldn't be done.     *     * @param string|null $message     * @return array|null     */    public function stopProfiling(string $message = null): ?array    {        $timings = null;        if ($this->enabled && extension_loaded('tideways_xhprof')) {            $profiling = $this->profiling - 1;            if ($profiling === 0) {                // @phpstan-ignore-next-line                $timings = \tideways_xhprof_disable();                $timings = $this->buildProfilerTimings($timings);                if ($this->clockwork) {                    /** @var UserData $userData */                    $userData = $this->clockwork->userData('Profiler');                    $userData->counters([                        'Calls' => count($timings)                    ]);                    $userData->table('Profiler', $timings);                } else {                    $this->addMessage($message ?? 'Profiler Analysis', 'debug', $timings);                }            }            $this->profiling = max(0, $profiling);        }        return $timings;    }    /**     * @param array $timings     * @return array     */    protected function buildProfilerTimings(array $timings): array    {        // Filter method calls which take almost no time.        $timings = array_filter($timings, function ($value) {            return $value['wt'] > 50;        });        uasort($timings, function (array $a, array $b) {            return $b['wt'] <=> $a['wt'];        });        $table = [];        foreach ($timings as $key => $timing) {            $parts = explode('==>', $key);            $method = $this->parseProfilerCall(array_pop($parts));            $context = $this->parseProfilerCall(array_pop($parts));            // Skip redundant method calls.            if ($context === 'Grav\Framework\RequestHandler\RequestHandler::handle()') {                continue;            }            // Do not profile library calls.            if (strpos($context, 'Grav\\') !== 0) {                continue;            }            $table[] = [                'Context' => $context,                'Method' => $method,                'Calls' => $timing['ct'],                'Time (ms)' => $timing['wt'] / 1000,            ];        }        return $table;    }    /**     * @param string|null $call     * @return mixed|string|null     */    protected function parseProfilerCall(?string $call)    {        if (null === $call) {            return '';        }        if (strpos($call, '@')) {            [$call,] = explode('@', $call);        }        if (strpos($call, '::')) {            [$class, $call] = explode('::', $call);        }        if (!isset($class)) {            return $call;        }        // It is also possible to display twig files, but they are being logged in views.        /*        if (strpos($class, '__TwigTemplate_') === 0 && class_exists($class)) {            $env = new Environment();            / ** @var Template $template * /            $template = new $class($env);            return $template->getTemplateName();        }        */        return ""{$class}::{$call}()"";    }    /**     * Start a timer with an associated name and description     *     * @param string      $name     * @param string|null $description     * @return $this     */    public function startTimer($name, $description = null)    {        $this->timers[$name] = [$description, microtime(true)];        return $this;    }    /**     * Stop the named timer     *     * @param string $name     * @return $this     */    public function stopTimer($name)    {        if (isset($this->timers[$name])) {            $endTime = microtime(true);            $this->timers[$name][] = $endTime;        }        return $this;    }    /**     * Dump variables into the Messages tab of the Debug Bar     *     * @param mixed  $message     * @param string $label     * @param mixed|bool $isString     * @return $this     */    public function addMessage($message, $label = 'info', $isString = true)    {        if ($this->enabled) {            if ($this->censored) {                if (!is_scalar($message)) {                    $message = 'CENSORED';                }                if (!is_scalar($isString)) {                    $isString = ['CENSORED'];                }            }            if ($this->debugbar) {                if (is_array($isString)) {                    $message = $isString;                    $isString = false;                } elseif (is_string($isString)) {                    $message = $isString;                    $isString = true;                }                $this->debugbar['messages']->addMessage($message, $label, $isString);            }            if ($this->clockwork) {                $context = $isString;                if (!is_scalar($message)) {                    $context = $message;                    $message = gettype($context);                }                if (is_bool($context)) {                    $context = [];                } elseif (!is_array($context)) {                    $type = gettype($context);                    $context = [$type => $context];                }                $this->clockwork->log($label, $message, $context);            }        }        return $this;    }    /**     * @param string $name     * @param object $event     * @param EventDispatcherInterface $dispatcher     * @param float|null $time     * @return $this     */    public function addEvent(string $name, $event, EventDispatcherInterface $dispatcher, float $time = null)    {        if ($this->enabled && $this->clockwork) {            $time = $time ?? microtime(true);            $duration = (microtime(true) - $time) * 1000;            $data = null;            if ($event && method_exists($event, '__debugInfo')) {                $data = $event;            }            $listeners = [];            foreach ($dispatcher->getListeners($name) as $listener) {                $listeners[] = $this->resolveCallable($listener);            }            $this->clockwork->addEvent($name, $data, $time, ['listeners' => $listeners, 'duration' => $duration]);        }        return $this;    }    /**     * Dump exception into the Messages tab of the Debug Bar     *     * @param Throwable $e     * @return Debugger     */    public function addException(Throwable $e)    {        if ($this->initialized && $this->enabled) {            if ($this->debugbar) {                $this->debugbar['exceptions']->addThrowable($e);            }            if ($this->clockwork) {                /** @var UserData $exceptions */                $exceptions = $this->clockwork->userData('Exceptions');                $exceptions->data(['message' => $e->getMessage()]);                $this->clockwork->alert($e->getMessage(), ['exception' => $e]);            }        }        return $this;    }    /**     * @return void     */    public function setErrorHandler()    {        $this->errorHandler = set_error_handler(            [$this, 'deprecatedErrorHandler']        );    }    /**     * @param int $errno     * @param string $errstr     * @param string $errfile     * @param int $errline     * @return bool     */    public function deprecatedErrorHandler($errno, $errstr, $errfile, $errline)    {        if ($errno !== E_USER_DEPRECATED && $errno !== E_DEPRECATED) {            if ($this->errorHandler) {                return call_user_func($this->errorHandler, $errno, $errstr, $errfile, $errline);            }            return true;        }        if (!$this->enabled) {            return true;        }        // Figure out error scope from the error.        $scope = 'unknown';        if (stripos($errstr, 'grav') !== false) {            $scope = 'grav';        } elseif (strpos($errfile, '/twig/') !== false) {            $scope = 'twig';        } elseif (stripos($errfile, '/yaml/') !== false) {            $scope = 'yaml';        } elseif (strpos($errfile, '/vendor/') !== false) {            $scope = 'vendor';        }        // Clean up backtrace to make it more useful.        $backtrace = debug_backtrace(DEBUG_BACKTRACE_PROVIDE_OBJECT);        // Skip current call.        array_shift($backtrace);        // Find yaml file where the error happened.        if ($scope === 'yaml') {            foreach ($backtrace as $current) {                if (isset($current['args'])) {                    foreach ($current['args'] as $arg) {                        if ($arg instanceof SplFileInfo) {                            $arg = $arg->getPathname();                        }                        if (is_string($arg) && preg_match('/.+\.(yaml|md)$/i', $arg)) {                            $errfile = $arg;                            $errline = 0;                            break 2;                        }                    }                }            }        }        // Filter arguments.        $cut = 0;        $previous = null;        foreach ($backtrace as $i => &$current) {            if (isset($current['args'])) {                $args = [];                foreach ($current['args'] as $arg) {                    if (is_string($arg)) {                        $arg = ""'"" . $arg . ""'"";                        if (mb_strlen($arg) > 100) {                            $arg = 'string';                        }                    } elseif (is_bool($arg)) {                        $arg = $arg ? 'true' : 'false';                    } elseif (is_scalar($arg)) {                        $arg = $arg;                    } elseif (is_object($arg)) {                        $arg = get_class($arg) . ' $object';                    } elseif (is_array($arg)) {                        $arg = '$array';                    } else {                        $arg = '$object';                    }                    $args[] = $arg;                }                $current['args'] = $args;            }            $object = $current['object'] ?? null;            unset($current['object']);            $reflection = null;            if ($object instanceof TemplateWrapper) {                $reflection = new ReflectionObject($object);                $property = $reflection->getProperty('template');                $property->setAccessible(true);                $object = $property->getValue($object);            }            if ($object instanceof Template) {                $file = $current['file'] ?? null;                if (preg_match('`(Template.php|TemplateWrapper.php)$`', $file)) {                    $current = null;                    continue;                }                $debugInfo = $object->getDebugInfo();                $line = 1;                if (!$reflection) {                    foreach ($debugInfo as $codeLine => $templateLine) {                        if ($codeLine <= $current['line']) {                            $line = $templateLine;                            break;                        }                    }                }                $src = $object->getSourceContext();                //$code = preg_split('/\r\n|\r|\n/', $src->getCode());                //$current['twig']['twig'] = trim($code[$line - 1]);                $current['twig']['file'] = $src->getPath();                $current['twig']['line'] = $line;                $prevFile = $previous['file'] ?? null;                if ($prevFile && $file === $prevFile) {                    $prevLine = $previous['line'];                    $line = 1;                    foreach ($debugInfo as $codeLine => $templateLine) {                        if ($codeLine <= $prevLine) {                            $line = $templateLine;                            break;                        }                    }                    //$previous['twig']['twig'] = trim($code[$line - 1]);                    $previous['twig']['file'] = $src->getPath();                    $previous['twig']['line'] = $line;                }                $cut = $i;            } elseif ($object instanceof ProcessorInterface) {                $cut = $cut ?: $i;                break;            }            $previous = &$backtrace[$i];        }        unset($current);        if ($cut) {            $backtrace = array_slice($backtrace, 0, $cut + 1);        }        $backtrace = array_values(array_filter($backtrace));        // Skip vendor libraries and the method where error was triggered.        foreach ($backtrace as $i => $current) {            if (!isset($current['file'])) {                continue;            }            if (strpos($current['file'], '/vendor/') !== false) {                $cut = $i + 1;                continue;            }            if (isset($current['function']) && ($current['function'] === 'user_error' || $current['function'] === 'trigger_error')) {                $cut = $i + 1;                continue;            }            break;        }        if ($cut) {            $backtrace = array_slice($backtrace, $cut);        }        $backtrace = array_values(array_filter($backtrace));        $current = reset($backtrace);        // If the issue happened inside twig file, change the file and line to match that file.        $file = $current['twig']['file'] ?? '';        if ($file) {            $errfile = $file;            $errline = $current['twig']['line'] ?? 0;        }        $deprecation = [            'scope' => $scope,            'message' => $errstr,            'file' => $errfile,            'line' => $errline,            'trace' => $backtrace,            'count' => 1        ];        $this->deprecations[] = $deprecation;        // Do not pass forward.        return true;    }    /**     * @return array     */    protected function getDeprecations(): array    {        if (!$this->deprecations) {            return [];        }        $list = [];        /** @var array $deprecated */        foreach ($this->deprecations as $deprecated) {            $list[] = $this->getDepracatedMessage($deprecated)[0];        }        return $list;    }    /**     * @return void     * @throws DebugBarException     */    protected function addDeprecations()    {        if (!$this->deprecations) {            return;        }        $collector = new MessagesCollector('deprecated');        $this->addCollector($collector);        $collector->addMessage('Your site is using following deprecated features:');        /** @var array $deprecated */        foreach ($this->deprecations as $deprecated) {            list($message, $scope) = $this->getDepracatedMessage($deprecated);            $collector->addMessage($message, $scope);        }    }    /**     * @param array $deprecated     * @return array     */    protected function getDepracatedMessage($deprecated)    {        $scope = $deprecated['scope'];        $trace = [];        if (isset($deprecated['trace'])) {            foreach ($deprecated['trace'] as $current) {                $class = $current['class'] ?? '';                $type = $current['type'] ?? '';                $function = $this->getFunction($current);                if (isset($current['file'])) {                    $current['file'] = str_replace(GRAV_ROOT . '/', '', $current['file']);                }                unset($current['class'], $current['type'], $current['function'], $current['args']);                if (isset($current['twig'])) {                    $trace[] = $current['twig'];                } else {                    $trace[] = ['call' => $class . $type . $function] + $current;                }            }        }        $array = [            'message' => $deprecated['message'],            'file' => $deprecated['file'],            'line' => $deprecated['line'],            'trace' => $trace        ];        return [            array_filter($array),            $scope        ];    }    /**     * @param array $trace     * @return string     */    protected function getFunction($trace)    {        if (!isset($trace['function'])) {            return '';        }        return $trace['function'] . '(' . implode(', ', $trace['args'] ?? []) . ')';    }    /**     * @param callable $callable     * @return string     */    protected function resolveCallable(callable $callable)    {        if (is_array($callable)) {            return get_class($callable[0]) . '->' . $callable[1] . '()';        }        return 'unknown';    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,2.0,0.0,0.0,0.0,0.0,2.0,2.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
33,hamcrest_hamcrest-php_FactoryGenerator_1797, Controls the process of extracting @factory doctags\\n and generating factory method files.\\n\\n Uses File_Iterator to scan for PHP files.\\n,Klasa koja kontroliše postupak izdvajanja i generisanja datoteka fabričkih metoda.,"class FactoryGenerator{    /**     * Path to the Hamcrest PHP files to process.     *     * @var string     */    private $path;    /**     * @var array of FactoryFile     */    private $factoryFiles;    public function __construct($path)    {        $this->path = $path;        $this->factoryFiles = array();    }    public function addFactoryFile(FactoryFile $factoryFile)    {        $this->factoryFiles[] = $factoryFile;    }    public function generate()    {        $classes = $this->getClassesWithFactoryMethods();        foreach ($classes as $class) {            foreach ($class->getMethods() as $method) {                foreach ($method->getCalls() as $call) {                    foreach ($this->factoryFiles as $file) {                        $file->addCall($call);                    }                }            }        }    }    public function write()    {        foreach ($this->factoryFiles as $file) {            $file->build();            $file->write();        }    }    public function getClassesWithFactoryMethods()    {        $classes = array();        $files = $this->getSortedFiles();        foreach ($files as $file) {            $class = $this->getFactoryClass($file);            if ($class !== null) {                $classes[] = $class;            }        }        return $classes;    }    public function getSortedFiles()    {        $iter = $this->getFileIterator();        $files = array();        foreach ($iter as $file) {            $files[] = $file;        }        sort($files, SORT_STRING);        return $files;    }    private function getFileIterator()    {        $factoryClass = class_exists('File_Iterator_Factory') ? 'File_Iterator_Factory' : 'SebastianBergmann\FileIterator\Factory';        $factory = new $factoryClass();        return $factory->getFileIterator($this->path, '.php');    }    public function getFactoryClass($file)    {        $name = $this->getFactoryClassName($file);        if ($name !== null) {            require_once $file;            if (class_exists($name)) {                $class = new FactoryClass(substr($file, strpos($file, 'Hamcrest/')), new ReflectionClass($name));                if ($class->isFactory()) {                    return $class;                }            }        }        return null;    }    public function getFactoryClassName($file)    {        $content = file_get_contents($file);        if (preg_match('/namespace\s+(.+);/', $content, $namespace)            && preg_match('/\n\s*class\s+(\w+)\s+extends\b/', $content, $className)            && preg_match('/@factory\b/', $content)        ) {            return $namespace[1] . '\\' . $className[1];        }        return null;    }}",0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
34,jorgecasas_php-ml_DecisionTree_822," Returns available features/columns to the tree for the decision making\n process. <br>\n\n If a number is given with setNumFeatures() method, then a random selection\n of features up to this number is returned. <br>\n\n If some features are manually selected by use of setSelectedFeatures(),\n then only these features are returned <br>\n\n If any of above methods were not called beforehand, then all features\n are returned by default.\n",Vraća dostupne funkcije/kolone u stablo za proces donešenja odluka. Ako je broj dobijen metodom setNumFeatures vraća se slučajan izbor odlike do tog broja.  Ako su neke odlike ručno izabrane sa metodom setSelectedFeature onda se vraćaju ove odlike. Ako bilo koja metoda od gore navedenih metoda nije predhodno pozvana tada se podrazumevano vraćaju sve odlike.,"    protected function getSelectedFeatures(): array    {        $allFeatures = range(0, $this->featureCount - 1);        if ($this->numUsableFeatures === 0 && count($this->selectedFeatures) === 0) {            return $allFeatures;        }        if (count($this->selectedFeatures) > 0) {            return $this->selectedFeatures;        }        $numFeatures = $this->numUsableFeatures;        if ($numFeatures > $this->featureCount) {            $numFeatures = $this->featureCount;        }        shuffle($allFeatures);        $selectedFeatures = array_slice($allFeatures, 0, $numFeatures);        sort($selectedFeatures);        return $selectedFeatures;    }",0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
35,markrogoyski_math-php_Average_3440," Return the kth smallest value in an array\\n Uses a linear-time algorithm: O(n) time in worst case.\\n\\n if $a = [1,2,3,4,6,7]\\n\\n kthSmallest($a, 4) = 6\\n\\n Algorithm:\\n  1) If n is small, just sort and return\\n  2) Otherwise, group into 5-element subsets and mind the median\\n  3) Find the median of the medians\\n  4) Find L and U sets\\n     - L is numbers lower than the median of medians\\n     - U is numbers higher than the median of medians\\n  5) Recursive step\\n     - if k is the median of medians, return that\\n     - Otherwise, recursively search in smaller group.\\n\\n @param float[] $numbers\\n @param int    $k zero indexed - must be less than n (count of $numbers)\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if k â‰¥ n\\n","Vrati k-ti najmanju vrednost iz niza. Algoritam je linearne slozenosti O(n) u najgorem slučaju. Ukoliko je $a = [1,2,3,4,6,7] kthSmallest($a, 4) = 6.\n    1) Ako je n malo, sortiraj niz i vrati broj.\n    2) U suprotnom grupiši elemente niza u podgrupu od pet elemenata i pronadji medijan.\n    3) Pronađi median mediana.\n    4) Pronađi L i U skupove, gde je L broj manji od vrednosti srednjeg člana mediana.\n    5) Rekurzivni korak. Ukoliko je k srednji član mediana vrati ga, u suprotnom rekurzivno pretraži menje grupe.","    public static function kthSmallest(array $numbers, int $k): float    {        $n = \count($numbers);        if ($n === 0) {            throw new Exception\BadDataException('Cannot find the k-th smallest of an empty list of numbers');        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException('k cannot be greater than or equal to the count of numbers');        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // If the array is 5 elements or smaller, use quicksort and return the element of interest.        if ($n <= 5) {            \sort($numbers);            return $numbers[$k];        }        // Otherwise, we are going to slice $numbers into 5-element slices and find the median of each.        $num_slices = \ceil($n / 5);        $median_array = [];        for ($i = 0; $i < $num_slices; $i++) {            $median_array[] = self::median(\array_slice($numbers, 5 * $i, 5));        }        // Then we find the median of the medians.        $median_of_medians = self::median($median_array);        // Next we walk the array and separate it into values that are greater than or less than this ""median of medians"".        $lower_upper   = self::splitAtValue($numbers, $median_of_medians);        $lower_number = \count($lower_upper['lower']);        $equal_number = $lower_upper['equal'];        // Lastly, we find which group of values our value of interest is in, and find it in the smaller array.        if ($k < $lower_number) {            return self::kthSmallest($lower_upper['lower'], $k);        } elseif ($k < ($lower_number + $equal_number)) {            return $median_of_medians;        } else {            return self::kthSmallest($lower_upper['upper'], $k - $lower_number - $equal_number);        }    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
36,dompdf_dompdf_FontMetrics_553, Saves the stored font family cache\n\n The name and location of the cache file are determined by {@link\n FontMetrics::CACHE_FILE}. This file should be writable by the\n webserver process.\n\n @see FontMetrics::loadFontFamilies()\n,Sačuvaj keširanu familiju fontova u fajl. Ime i lokacija fajla je određena parametrom FontMetrics::CACHE_FILE. Upisivanje u fajl bi trebalo da bude u webserver procesu.,"    public function saveFontFamilies()    {        // replace the path to the DOMPDF font directories with the corresponding constants (allows for more portability)        $cacheData = sprintf(""<?php return array (%s"", PHP_EOL);        foreach ($this->fontLookup as $family => $variants) {            $cacheData .= sprintf(""  '%s' => array(%s"", addslashes($family), PHP_EOL);            foreach ($variants as $variant => $path) {                $path = sprintf(""'%s'"", $path);                $path = str_replace('\'' . $this->getOptions()->getFontDir() , '$fontDir . \'' , $path);                $path = str_replace('\'' . $this->getOptions()->getRootDir() , '$rootDir . \'' , $path);                $cacheData .= sprintf(""    '%s' => %s,%s"", $variant, $path, PHP_EOL);            }            $cacheData .= sprintf(""  ),%s"", PHP_EOL);        }        $cacheData .= "") ?>"";        file_put_contents($this->getCacheFile(), $cacheData);    }",0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
37,phalcon_cphalcon_Optimized_1228, Uses previously generated safe universal build and generates optimized build for a specific platform\n,Klasa koja koristi predhodno generisan siguran bild i koristi ga za generisanje optimizovan bild za ciljnu platformu.,"class Generator_Optimized{    /**     * Directory, where safe universal build files are generated     *     * @var string     */    protected string $sourceBuildDir;    /**     * Platform settings for supported optimized builds     *     * @var array     */    protected array $settings;    /**     * Filters for processing (optimizing) lines from safe universal phalcon.c     *     * @var array     */    protected array $filters;    /**     * @param string $sourceBuildDir     * @param string $output32Dir     * @param string $output64Dir     */    public function __construct(string $sourceBuildDir, string $output32Dir, string $output64Dir)    {        $this->sourceBuildDir = $sourceBuildDir;        $this->settings = $this->getPlatformsSettings($output32Dir, $output64Dir);        $this->filters = $this->getFilters();    }    /**     * Return array of supported platform settings for optimized builds     *     * @param string $output32Dir     * @param string $output64Dir     * @return array     */    protected function getPlatformsSettings(string $output32Dir, string $output64Dir)    {        return array(            '32bit' => array(                'dir' => $output32Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey32($string) . 'UL';                }            ),            '64bit' => array(                'dir' => $output64Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey64($string) . 'UL';                }            ),        );    }    /**     * Return filters for processing lines from safe universal phalcon.c     *     * @return array     */    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }    /**     * Run generation process     */    public function run()    {        echo 'Generating builds, optimized for 32-bit and 64-bit platforms... ';        $this->cleanBuildDirectories();        $this->copyFilesFromSourceBuildDir();        $this->copyAndOptimizePhalconC();        echo ""OK\n"";    }    /**     * Delete all files in target directories     */    public function cleanBuildDirectories()    {        foreach ($this->settings as $setting) {            Util::cleanDirectory($setting['dir']);        }    }    /**     * Copy all files from the original safe universal build directory     */    protected function copyFilesFromSourceBuildDir()    {        $files = glob($this->sourceBuildDir . '/*.*');        foreach ($files as $file) {            // phalcon.c is processed in a separate optimization func            if (basename($file) == 'phalcon.zep.c') {                continue;            }            foreach ($this->settings as $setting) {                copy($file, $setting['dir'] . '/' . basename($file));            }        }    }    /**     * Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.     * Precalculation is, actually, the optimization being performed.     */    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }    /**     * Pass line through filters and add the processed result to platform builds     *     * @param string $line     * @param array $result     */    protected function filterLine($line, &$result)    {        /** @var callable|null $func */        $func = null;        foreach ($this->filters as $filter) {            if (!preg_match($filter['regexp'], $line, $matches)) {                continue;            }            $func = $filter['func'];            break; // We don't expect more than one replacement to be made on the same line        }        foreach ($this->settings as $platform => $setting) {            $result[$platform] .= $func ? $func($line, $matches, $setting['hashFunc']) : $line;        }    }}",0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
38,phalcon_cphalcon_Optimized_2072," Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.\n Precalculation is, actually, the optimization being performed.\n",Prekopiraj phalcon.c i optimizuj ga zamenivši stringove sa prekalkulisanim heš vrednostima. Prekalkulacija je zapravo optimizacija koja se primenjuje.,"    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }",0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
39,symfony_http-kernel_CacheWarmerAggregate_3111, Warms up the cache.\n\n @return string[] A list of classes or files to preload on PHP 7.4+\n,Ažuriraj keš.,"    public function warmUp(string $cacheDir)    {        if ($collectDeprecations = $this->debug && !\defined('PHPUNIT_COMPOSER_INSTALL')) {            $collectedLogs = [];            $previousHandler = set_error_handler(function ($type, $message, $file, $line) use (&$collectedLogs, &$previousHandler) {                if (\E_USER_DEPRECATED !== $type && \E_DEPRECATED !== $type) {                    return $previousHandler ? $previousHandler($type, $message, $file, $line) : false;                }                if (isset($collectedLogs[$message])) {                    ++$collectedLogs[$message]['count'];                    return null;                }                $backtrace = debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS, 3);                // Clean the trace by removing first frames added by the error handler itself.                for ($i = 0; isset($backtrace[$i]); ++$i) {                    if (isset($backtrace[$i]['file'], $backtrace[$i]['line']) && $backtrace[$i]['line'] === $line && $backtrace[$i]['file'] === $file) {                        $backtrace = \array_slice($backtrace, 1 + $i);                        break;                    }                }                $collectedLogs[$message] = [                    'type' => $type,                    'message' => $message,                    'file' => $file,                    'line' => $line,                    'trace' => $backtrace,                    'count' => 1,                ];                return null;            });        }        $preload = [];        try {            foreach ($this->warmers as $warmer) {                if (!$this->optionalsEnabled && $warmer->isOptional()) {                    continue;                }                if ($this->onlyOptionalsEnabled && !$warmer->isOptional()) {                    continue;                }                $preload[] = array_values((array) $warmer->warmUp($cacheDir));            }        } finally {            if ($collectDeprecations) {                restore_error_handler();                if (is_file($this->deprecationLogsFilepath)) {                    $previousLogs = unserialize(file_get_contents($this->deprecationLogsFilepath));                    $collectedLogs = array_merge($previousLogs, $collectedLogs);                }                file_put_contents($this->deprecationLogsFilepath, serialize(array_values($collectedLogs)));            }        }        return array_values(array_unique(array_merge([], ...$preload)));    }",0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
40,phalcon_cphalcon_Safe_1241, Resolves headers in the php_phalcon.h file\\n,Razreši hedere u php_phalcon.h fajlu.,"    protected function processKernelGlobals()    {        $lines = [];        foreach (file($this->outputDir . '/php_phalcon.h') as $line) {            if (preg_match('@^#include ""(kernel/.+)""@', $line, $matches)) {                $content = file_get_contents($this->sourceDir . DIRECTORY_SEPARATOR . $matches[1]);                $lines[] = $content . PHP_EOL;            } else {                $lines[] = $line;            }        }        file_put_contents($this->outputDir . '/php_phalcon.h', join('', $lines));    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
41,wallabag_wallabag_Version20160401000000_2382, Initial database structure.\n,Inicijalna struktura baze podataka.,"class Version20160401000000 extends WallabagMigration{    public function up(Schema $schema)    {        $this->skipIf($schema->hasTable($this->getTable('entry')), 'Database already initialized');        switch ($this->connection->getDatabasePlatform()->getName()) {            case 'sqlite':                $sql = <<<SQLCREATE TABLE {$this->getTable('craue_config_setting')} (name VARCHAR(255) NOT NULL, value VARCHAR(255) DEFAULT NULL, section VARCHAR(255) DEFAULT NULL, PRIMARY KEY(name));CREATE UNIQUE INDEX UNIQ_5D9649505E237E06 ON {$this->getTable('craue_config_setting')} (name);CREATE TABLE {$this->getTable('tagging_rule')} (id INTEGER NOT NULL, config_id INTEGER DEFAULT NULL, rule VARCHAR(255) NOT NULL, tags CLOB NOT NULL, PRIMARY KEY(id), CONSTRAINT FK_2D9B3C5424DB0683 FOREIGN KEY (config_id) REFERENCES {$this->getTable('config')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE INDEX IDX_2D9B3C5424DB0683 ON {$this->getTable('tagging_rule')} (config_id);CREATE TABLE {$this->getTable('tag')} (id INTEGER NOT NULL, label CLOB NOT NULL, slug VARCHAR(128) NOT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_4CA58A8C989D9B62 ON {$this->getTable('tag')} (slug);CREATE TABLE {$this->getTable('entry')} (id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, title CLOB DEFAULT NULL, url CLOB DEFAULT NULL, is_archived BOOLEAN NOT NULL, is_starred BOOLEAN NOT NULL, content CLOB DEFAULT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, mimetype CLOB DEFAULT NULL, language CLOB DEFAULT NULL, reading_time INTEGER DEFAULT NULL, domain_name CLOB DEFAULT NULL, preview_picture CLOB DEFAULT NULL, is_public BOOLEAN DEFAULT '0', PRIMARY KEY(id), CONSTRAINT FK_F4D18282A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE INDEX IDX_F4D18282A76ED395 ON {$this->getTable('entry')} (user_id);CREATE TABLE {$this->getTable('entry_tag')} (entry_id INTEGER NOT NULL, tag_id INTEGER NOT NULL, PRIMARY KEY(entry_id, tag_id), CONSTRAINT FK_C9F0DD7CBA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_C9F0DD7CBAD26311 FOREIGN KEY (tag_id) REFERENCES {$this->getTable('tag')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE INDEX IDX_C9F0DD7CBA364942 ON {$this->getTable('entry_tag')} (entry_id);CREATE INDEX IDX_C9F0DD7CBAD26311 ON {$this->getTable('entry_tag')} (tag_id);CREATE TABLE {$this->getTable('config')} (id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, theme VARCHAR(255) NOT NULL, items_per_page INTEGER NOT NULL, language VARCHAR(255) NOT NULL, rss_token VARCHAR(255) DEFAULT NULL, rss_limit INTEGER DEFAULT NULL, reading_speed DOUBLE PRECISION DEFAULT NULL, PRIMARY KEY(id), CONSTRAINT FK_87E64C53A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE UNIQUE INDEX UNIQ_87E64C53A76ED395 ON {$this->getTable('config')} (user_id);CREATE TABLE {$this->getTable('oauth2_refresh_tokens')} (id INTEGER NOT NULL, client_id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INTEGER DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id), CONSTRAINT FK_20C9FB2419EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_20C9FB24A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE UNIQUE INDEX UNIQ_20C9FB245F37A13B ON {$this->getTable('oauth2_refresh_tokens')} (token);CREATE INDEX IDX_20C9FB2419EB6921 ON {$this->getTable('oauth2_refresh_tokens')} (client_id);CREATE INDEX IDX_20C9FB24A76ED395 ON {$this->getTable('oauth2_refresh_tokens')} (user_id);CREATE TABLE {$this->getTable('oauth2_access_tokens')} (id INTEGER NOT NULL, client_id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INTEGER DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id), CONSTRAINT FK_368A420919EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_368A4209A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE UNIQUE INDEX UNIQ_368A42095F37A13B ON {$this->getTable('oauth2_access_tokens')} (token);CREATE INDEX IDX_368A420919EB6921 ON {$this->getTable('oauth2_access_tokens')} (client_id);CREATE INDEX IDX_368A4209A76ED395 ON {$this->getTable('oauth2_access_tokens')} (user_id);CREATE TABLE {$this->getTable('oauth2_auth_codes')} (id INTEGER NOT NULL, client_id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, token VARCHAR(255) NOT NULL, redirect_uri CLOB NOT NULL, expires_at INTEGER DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id), CONSTRAINT FK_EE52E3FA19EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_EE52E3FAA76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE UNIQUE INDEX UNIQ_EE52E3FA5F37A13B ON {$this->getTable('oauth2_auth_codes')} (token);CREATE INDEX IDX_EE52E3FA19EB6921 ON {$this->getTable('oauth2_auth_codes')} (client_id);CREATE INDEX IDX_EE52E3FAA76ED395 ON {$this->getTable('oauth2_auth_codes')} (user_id);CREATE TABLE {$this->getTable('oauth2_clients')} (id INTEGER NOT NULL, random_id VARCHAR(255) NOT NULL, redirect_uris CLOB NOT NULL, secret VARCHAR(255) NOT NULL, allowed_grant_types CLOB NOT NULL, PRIMARY KEY(id));CREATE TABLE {$this->getTable('user')} (id INTEGER NOT NULL, username VARCHAR(180) NOT NULL, username_canonical VARCHAR(180) NOT NULL, email VARCHAR(180) NOT NULL, email_canonical VARCHAR(180) NOT NULL, enabled BOOLEAN NOT NULL, salt VARCHAR(255) NOT NULL, password VARCHAR(255) NOT NULL, last_login DATETIME DEFAULT NULL, locked BOOLEAN NOT NULL, expired BOOLEAN NOT NULL, expires_at DATETIME DEFAULT NULL, confirmation_token VARCHAR(255) DEFAULT NULL, password_requested_at DATETIME DEFAULT NULL, roles CLOB NOT NULL, credentials_expired BOOLEAN NOT NULL, credentials_expire_at DATETIME DEFAULT NULL, name CLOB DEFAULT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, authCode INTEGER DEFAULT NULL, twoFactorAuthentication BOOLEAN NOT NULL, trusted CLOB DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_1D63E7E592FC23A8 ON {$this->getTable('user')} (username_canonical);CREATE UNIQUE INDEX UNIQ_1D63E7E5A0D96FBF ON {$this->getTable('user')} (email_canonical);CREATE UNIQUE INDEX UNIQ_1D63E7E5C05FB297 ON {$this->getTable('user')} (confirmation_token);CREATE TABLE {$this->getTable('annotation')} (id INTEGER NOT NULL, user_id INTEGER DEFAULT NULL, entry_id INTEGER DEFAULT NULL, text CLOB NOT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, quote VARCHAR(255) NOT NULL, ranges CLOB NOT NULL, PRIMARY KEY(id), CONSTRAINT FK_A7AED006A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE, CONSTRAINT FK_A7AED006BA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE);CREATE INDEX IDX_A7AED006A76ED395 ON {$this->getTable('annotation')} (user_id);CREATE INDEX IDX_A7AED006BA364942 ON {$this->getTable('annotation')} (entry_id);SQL                ;                foreach (explode(""\n"", $sql) as $query) {                    $this->addSql($query);                }                break;            case 'mysql':                $sql = <<<SQLCREATE TABLE {$this->getTable('craue_config_setting')} (name VARCHAR(255) NOT NULL, value VARCHAR(255) DEFAULT NULL, section VARCHAR(255) DEFAULT NULL, UNIQUE INDEX UNIQ_5D9649505E237E06 (name), PRIMARY KEY(name)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('entry')} (id INT AUTO_INCREMENT NOT NULL, user_id INT DEFAULT NULL, title LONGTEXT DEFAULT NULL, url LONGTEXT DEFAULT NULL, is_archived TINYINT(1) NOT NULL, is_starred TINYINT(1) NOT NULL, content LONGTEXT DEFAULT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, mimetype LONGTEXT DEFAULT NULL, language LONGTEXT DEFAULT NULL, reading_time INT DEFAULT NULL, domain_name LONGTEXT DEFAULT NULL, preview_picture LONGTEXT DEFAULT NULL, is_public TINYINT(1) DEFAULT '0', INDEX IDX_F4D18282A76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('entry_tag')} (entry_id INT NOT NULL, tag_id INT NOT NULL, INDEX IDX_C9F0DD7CBA364942 (entry_id), INDEX IDX_C9F0DD7CBAD26311 (tag_id), PRIMARY KEY(entry_id, tag_id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('config')} (id INT AUTO_INCREMENT NOT NULL, user_id INT DEFAULT NULL, theme VARCHAR(255) NOT NULL, items_per_page INT NOT NULL, language VARCHAR(255) NOT NULL, rss_token VARCHAR(255) DEFAULT NULL, rss_limit INT DEFAULT NULL, reading_speed DOUBLE PRECISION DEFAULT NULL, UNIQUE INDEX UNIQ_87E64C53A76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('tagging_rule')} (id INT AUTO_INCREMENT NOT NULL, config_id INT DEFAULT NULL, rule VARCHAR(255) NOT NULL, tags LONGTEXT NOT NULL COMMENT '(DC2Type:simple_array)', INDEX IDX_2D9B3C5424DB0683 (config_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('tag')} (id INT AUTO_INCREMENT NOT NULL, `label` LONGTEXT NOT NULL, slug VARCHAR(128) NOT NULL, UNIQUE INDEX UNIQ_4CA58A8C989D9B62 (slug), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('oauth2_clients')} (id INT AUTO_INCREMENT NOT NULL, random_id VARCHAR(255) NOT NULL, redirect_uris LONGTEXT NOT NULL COMMENT '(DC2Type:array)', secret VARCHAR(255) NOT NULL, allowed_grant_types LONGTEXT NOT NULL COMMENT '(DC2Type:array)', PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('oauth2_access_tokens')} (id INT AUTO_INCREMENT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, UNIQUE INDEX UNIQ_368A42095F37A13B (token), INDEX IDX_368A420919EB6921 (client_id), INDEX IDX_368A4209A76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('oauth2_refresh_tokens')} (id INT AUTO_INCREMENT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, UNIQUE INDEX UNIQ_20C9FB245F37A13B (token), INDEX IDX_20C9FB2419EB6921 (client_id), INDEX IDX_20C9FB24A76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('oauth2_auth_codes')} (id INT AUTO_INCREMENT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, redirect_uri LONGTEXT NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, UNIQUE INDEX UNIQ_EE52E3FA5F37A13B (token), INDEX IDX_EE52E3FA19EB6921 (client_id), INDEX IDX_EE52E3FAA76ED395 (user_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('user')} (id INT AUTO_INCREMENT NOT NULL, username VARCHAR(180) NOT NULL, username_canonical VARCHAR(180) NOT NULL, email VARCHAR(180) NOT NULL, email_canonical VARCHAR(180) NOT NULL, enabled TINYINT(1) NOT NULL, salt VARCHAR(255) NOT NULL, password VARCHAR(255) NOT NULL, last_login DATETIME DEFAULT NULL, locked TINYINT(1) NOT NULL, expired TINYINT(1) NOT NULL, expires_at DATETIME DEFAULT NULL, confirmation_token VARCHAR(255) DEFAULT NULL, password_requested_at DATETIME DEFAULT NULL, roles LONGTEXT NOT NULL COMMENT '(DC2Type:array)', credentials_expired TINYINT(1) NOT NULL, credentials_expire_at DATETIME DEFAULT NULL, name LONGTEXT DEFAULT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, authCode INT DEFAULT NULL, twoFactorAuthentication TINYINT(1) NOT NULL, trusted LONGTEXT DEFAULT NULL COMMENT '(DC2Type:json_array)', UNIQUE INDEX UNIQ_1D63E7E592FC23A8 (username_canonical), UNIQUE INDEX UNIQ_1D63E7E5A0D96FBF (email_canonical), UNIQUE INDEX UNIQ_1D63E7E5C05FB297 (confirmation_token), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;CREATE TABLE {$this->getTable('annotation')} (id INT AUTO_INCREMENT NOT NULL, user_id INT DEFAULT NULL, entry_id INT DEFAULT NULL, text LONGTEXT NOT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, quote VARCHAR(255) NOT NULL, ranges LONGTEXT NOT NULL COMMENT '(DC2Type:array)', INDEX IDX_A7AED006A76ED395 (user_id), INDEX IDX_A7AED006BA364942 (entry_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB;ALTER TABLE {$this->getTable('entry')} ADD CONSTRAINT FK_F4D18282A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('entry_tag')} ADD CONSTRAINT FK_C9F0DD7CBA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id);ALTER TABLE {$this->getTable('entry_tag')} ADD CONSTRAINT FK_C9F0DD7CBAD26311 FOREIGN KEY (tag_id) REFERENCES {$this->getTable('tag')} (id);ALTER TABLE {$this->getTable('config')} ADD CONSTRAINT FK_87E64C53A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('tagging_rule')} ADD CONSTRAINT FK_2D9B3C5424DB0683 FOREIGN KEY (config_id) REFERENCES {$this->getTable('config')} (id);ALTER TABLE {$this->getTable('oauth2_access_tokens')} ADD CONSTRAINT FK_368A420919EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id);ALTER TABLE {$this->getTable('oauth2_access_tokens')} ADD CONSTRAINT FK_368A4209A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('oauth2_refresh_tokens')} ADD CONSTRAINT FK_20C9FB2419EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id);ALTER TABLE {$this->getTable('oauth2_refresh_tokens')} ADD CONSTRAINT FK_20C9FB24A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('oauth2_auth_codes')} ADD CONSTRAINT FK_EE52E3FA19EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id);ALTER TABLE {$this->getTable('oauth2_auth_codes')} ADD CONSTRAINT FK_EE52E3FAA76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('annotation')} ADD CONSTRAINT FK_A7AED006A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id);ALTER TABLE {$this->getTable('annotation')} ADD CONSTRAINT FK_A7AED006BA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id);SQL                ;                foreach (explode(""\n"", $sql) as $query) {                    $this->addSql($query);                }                break;            case 'postgresql':                $sql = <<<SQLCREATE TABLE {$this->getTable('craue_config_setting')} (name VARCHAR(255) NOT NULL, value VARCHAR(255) DEFAULT NULL, section VARCHAR(255) DEFAULT NULL, PRIMARY KEY(name));CREATE UNIQUE INDEX UNIQ_5D9649505E237E06 ON {$this->getTable('craue_config_setting')} (name);CREATE TABLE {$this->getTable('entry')} (id INT NOT NULL, user_id INT DEFAULT NULL, title TEXT DEFAULT NULL, url TEXT DEFAULT NULL, is_archived BOOLEAN NOT NULL, is_starred BOOLEAN NOT NULL, content TEXT DEFAULT NULL, created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, updated_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, mimetype TEXT DEFAULT NULL, language TEXT DEFAULT NULL, reading_time INT DEFAULT NULL, domain_name TEXT DEFAULT NULL, preview_picture TEXT DEFAULT NULL, is_public BOOLEAN DEFAULT 'false', PRIMARY KEY(id));CREATE INDEX IDX_F4D18282A76ED395 ON {$this->getTable('entry')} (user_id);CREATE TABLE {$this->getTable('entry_tag')} (entry_id INT NOT NULL, tag_id INT NOT NULL, PRIMARY KEY(entry_id, tag_id));CREATE INDEX IDX_C9F0DD7CBA364942 ON {$this->getTable('entry_tag')} (entry_id);CREATE INDEX IDX_C9F0DD7CBAD26311 ON {$this->getTable('entry_tag')} (tag_id);CREATE TABLE {$this->getTable('config')} (id INT NOT NULL, user_id INT DEFAULT NULL, theme VARCHAR(255) NOT NULL, items_per_page INT NOT NULL, language VARCHAR(255) NOT NULL, rss_token VARCHAR(255) DEFAULT NULL, rss_limit INT DEFAULT NULL, reading_speed DOUBLE PRECISION DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_87E64C53A76ED395 ON {$this->getTable('config')} (user_id);CREATE TABLE {$this->getTable('tagging_rule')} (id INT NOT NULL, config_id INT DEFAULT NULL, rule VARCHAR(255) NOT NULL, tags TEXT NOT NULL, PRIMARY KEY(id));CREATE INDEX IDX_2D9B3C5424DB0683 ON {$this->getTable('tagging_rule')} (config_id);COMMENT ON COLUMN {$this->getTable('tagging_rule')}.tags IS '(DC2Type:simple_array)';CREATE TABLE {$this->getTable('tag')} (id INT NOT NULL, label TEXT NOT NULL, slug VARCHAR(128) NOT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_4CA58A8C989D9B62 ON {$this->getTable('tag')} (slug);CREATE TABLE {$this->getTable('oauth2_clients')} (id INT NOT NULL, random_id VARCHAR(255) NOT NULL, redirect_uris TEXT NOT NULL, secret VARCHAR(255) NOT NULL, allowed_grant_types TEXT NOT NULL, PRIMARY KEY(id));COMMENT ON COLUMN {$this->getTable('oauth2_clients')}.redirect_uris IS '(DC2Type:array)';COMMENT ON COLUMN {$this->getTable('oauth2_clients')}.allowed_grant_types IS '(DC2Type:array)';CREATE TABLE {$this->getTable('oauth2_access_tokens')} (id INT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_368A42095F37A13B ON {$this->getTable('oauth2_access_tokens')} (token);CREATE INDEX IDX_368A420919EB6921 ON {$this->getTable('oauth2_access_tokens')} (client_id);CREATE INDEX IDX_368A4209A76ED395 ON {$this->getTable('oauth2_access_tokens')} (user_id);CREATE TABLE {$this->getTable('oauth2_refresh_tokens')} (id INT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_20C9FB245F37A13B ON {$this->getTable('oauth2_refresh_tokens')} (token);CREATE INDEX IDX_20C9FB2419EB6921 ON {$this->getTable('oauth2_refresh_tokens')} (client_id);CREATE INDEX IDX_20C9FB24A76ED395 ON {$this->getTable('oauth2_refresh_tokens')} (user_id);CREATE TABLE {$this->getTable('oauth2_auth_codes')} (id INT NOT NULL, client_id INT NOT NULL, user_id INT DEFAULT NULL, token VARCHAR(255) NOT NULL, redirect_uri TEXT NOT NULL, expires_at INT DEFAULT NULL, scope VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_EE52E3FA5F37A13B ON {$this->getTable('oauth2_auth_codes')} (token);CREATE INDEX IDX_EE52E3FA19EB6921 ON {$this->getTable('oauth2_auth_codes')} (client_id);CREATE INDEX IDX_EE52E3FAA76ED395 ON {$this->getTable('oauth2_auth_codes')} (user_id);CREATE TABLE {$this->getTable('user')} (id INT NOT NULL, username VARCHAR(180) NOT NULL, username_canonical VARCHAR(180) NOT NULL, email VARCHAR(180) NOT NULL, email_canonical VARCHAR(180) NOT NULL, enabled BOOLEAN NOT NULL, salt VARCHAR(255) NOT NULL, password VARCHAR(255) NOT NULL, last_login TIMESTAMP(0) WITHOUT TIME ZONE DEFAULT NULL, locked BOOLEAN NOT NULL, expired BOOLEAN NOT NULL, expires_at TIMESTAMP(0) WITHOUT TIME ZONE DEFAULT NULL, confirmation_token VARCHAR(255) DEFAULT NULL, password_requested_at TIMESTAMP(0) WITHOUT TIME ZONE DEFAULT NULL, roles TEXT NOT NULL, credentials_expired BOOLEAN NOT NULL, credentials_expire_at TIMESTAMP(0) WITHOUT TIME ZONE DEFAULT NULL, name TEXT DEFAULT NULL, created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, updated_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, authCode INT DEFAULT NULL, twoFactorAuthentication BOOLEAN NOT NULL, trusted TEXT DEFAULT NULL, PRIMARY KEY(id));CREATE UNIQUE INDEX UNIQ_1D63E7E592FC23A8 ON {$this->getTable('user')} (username_canonical);CREATE UNIQUE INDEX UNIQ_1D63E7E5A0D96FBF ON {$this->getTable('user')} (email_canonical);CREATE UNIQUE INDEX UNIQ_1D63E7E5C05FB297 ON {$this->getTable('user')} (confirmation_token);COMMENT ON COLUMN {$this->getTable('user')}.roles IS '(DC2Type:array)';COMMENT ON COLUMN {$this->getTable('user')}.trusted IS '(DC2Type:json_array)';CREATE TABLE {$this->getTable('annotation')} (id INT NOT NULL, user_id INT DEFAULT NULL, entry_id INT DEFAULT NULL, text TEXT NOT NULL, created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, updated_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, quote VARCHAR(255) NOT NULL, ranges TEXT NOT NULL, PRIMARY KEY(id));CREATE INDEX IDX_A7AED006A76ED395 ON {$this->getTable('annotation')} (user_id);CREATE INDEX IDX_A7AED006BA364942 ON {$this->getTable('annotation')} (entry_id);COMMENT ON COLUMN {$this->getTable('annotation')}.ranges IS '(DC2Type:array)';CREATE SEQUENCE ""entry_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE ""config_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE ""tagging_rule_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE ""tag_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE oauth2_clients_id_seq INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE oauth2_access_tokens_id_seq INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE oauth2_refresh_tokens_id_seq INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE oauth2_auth_codes_id_seq INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE ""user_id_seq"" INCREMENT BY 1 MINVALUE 1 START 1;CREATE SEQUENCE annotation_id_seq INCREMENT BY 1 MINVALUE 1 START 1;ALTER TABLE {$this->getTable('entry')} ADD CONSTRAINT FK_F4D18282A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('entry_tag')} ADD CONSTRAINT FK_C9F0DD7CBA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('entry_tag')} ADD CONSTRAINT FK_C9F0DD7CBAD26311 FOREIGN KEY (tag_id) REFERENCES {$this->getTable('tag')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('config')} ADD CONSTRAINT FK_87E64C53A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('tagging_rule')} ADD CONSTRAINT FK_2D9B3C5424DB0683 FOREIGN KEY (config_id) REFERENCES {$this->getTable('config')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_access_tokens')} ADD CONSTRAINT FK_368A420919EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_access_tokens')} ADD CONSTRAINT FK_368A4209A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_refresh_tokens')} ADD CONSTRAINT FK_20C9FB2419EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_refresh_tokens')} ADD CONSTRAINT FK_20C9FB24A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_auth_codes')} ADD CONSTRAINT FK_EE52E3FA19EB6921 FOREIGN KEY (client_id) REFERENCES {$this->getTable('oauth2_clients')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('oauth2_auth_codes')} ADD CONSTRAINT FK_EE52E3FAA76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('annotation')} ADD CONSTRAINT FK_A7AED006A76ED395 FOREIGN KEY (user_id) REFERENCES {$this->getTable('user')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;ALTER TABLE {$this->getTable('annotation')} ADD CONSTRAINT FK_A7AED006BA364942 FOREIGN KEY (entry_id) REFERENCES {$this->getTable('entry')} (id) NOT DEFERRABLE INITIALLY IMMEDIATE;SQL                ;                foreach (explode(""\n"", $sql) as $query) {                    $this->addSql($query);                }                break;        }    }    public function down(Schema $schema)    {        $this->addSql(""DROP TABLE {$this->getTable('craue_config_setting')}"");        $this->addSql(""DROP TABLE {$this->getTable('tagging_rule')}"");        $this->addSql(""DROP TABLE {$this->getTable('config')}"");        $this->addSql(""DROP TABLE {$this->getTable('entry')}"");        $this->addSql(""DROP TABLE {$this->getTable('entry_tag')}"");        $this->addSql(""DROP TABLE {$this->getTable('tag')}"");        $this->addSql(""DROP TABLE {$this->getTable('oauth2_refresh_tokens')}"");        $this->addSql(""DROP TABLE {$this->getTable('oauth2_access_tokens')}"");        $this->addSql(""DROP TABLE {$this->getTable('oauth2_clients')}"");        $this->addSql(""DROP TABLE {$this->getTable('oauth2_auth_codes')}"");        $this->addSql(""DROP TABLE {$this->getTable('user')}"");        $this->addSql(""DROP TABLE {$this->getTable('annotation')}"");    }}",1.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
42,phalcon_cphalcon_functions_1259, Get postgresql db options\\n,Dohvati opcije za postgresql.,"    function getOptionsPostgresql(): array    {        return [            'host'     => env('DATA_POSTGRES_HOST'),            'username' => env('DATA_POSTGRES_USER'),            'password' => env('DATA_POSTGRES_PASS'),            'port'     => env('DATA_POSTGRES_PORT'),            'dbname'   => env('DATA_POSTGRES_NAME'),            'schema'   => env('DATA_POSTGRES_SCHEMA'),        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
43,markrogoyski_math-php_Matrix_2623, m x n Matrix\\n,Klasa m x n matrice.,"abstract class Matrix implements \ArrayAccess, \JsonSerializable{    /** @var int Number of rows */    protected $m;    /** @var int Number of columns */    protected $n;    /** @var array[] Matrix array of arrays */    protected $A;    /** @var MatrixCatalog */    protected $catalog;    /** @var float|null Error/zero tolerance */    protected $Îµ;    /**************************************************************************     * ABSTRACT METHODS     *  - getObjectType     **************************************************************************/    /**     * What type of data does the matrix contain     *     * @return string the type of data in the Matrix     */    abstract public function getObjectType(): string;    /**************************************************************************     * BASIC MATRIX GETTERS     *  - getMatrix     *  - getM     *  - getN     *  - getRow     *  - getColumn     *  - get     *  - getDiagonalElements     *  - getSuperdiagonalElements     *  - getSubdiagonalElements     *  - asVectors     **************************************************************************/    /**     * Get matrix     * @return array[] of arrays     */    public function getMatrix(): array    {        return $this->A;    }    /**     * Get row count (m)     * @return int number of rows     */    public function getM(): int    {        return $this->m;    }    /**     * Get column count (n)     * @return int number of columns     */    public function getN(): int    {        return $this->n;    }    /**     * Get single row from the matrix     *     * @param  int    $i row index (from 0 to m - 1)     * @return array     *     * @throws Exception\MatrixException if row i does not exist     */    public function getRow(int $i): array    {        if ($i >= $this->m) {            throw new Exception\MatrixException(""Row $i does not exist"");        }        return $this->A[$i];    }    /**     * Get single column from the matrix     *     * @param  int   $j column index (from 0 to n - 1)     * @return array     *     * @throws Exception\MatrixException if column j does not exist     */    public function getColumn(int $j): array    {        if ($j >= $this->n) {            throw new Exception\MatrixException(""Column $j does not exist"");        }        return \array_column($this->A, $j);    }    /**     * Get a specific value at row i, column j     *     * @param  int    $i row index     * @param  int    $j column index     * @return number     *     * @throws Exception\MatrixException if row i or column j does not exist     */    public function get(int $i, int $j)    {        if ($i >= $this->m) {            throw new Exception\MatrixException(""Row $i does not exist"");        }        if ($j >= $this->n) {            throw new Exception\MatrixException(""Column $j does not exist"");        }        return $this->A[$i][$j];    }    /**     * Returns the elements on the diagonal of a square matrix as an array     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     * getDiagonalElements($A) = [1, 5, 9]     *     * @return array     */    public function getDiagonalElements(): array    {        $diagonal = [];        for ($i = 0; $i < \min($this->m, $this->n); $i++) {            $diagonal[] = $this->A[$i][$i];        }        return $diagonal;    }    /**     * Returns the elements on the superdiagonal of a square matrix as an array     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     * getSuperdiagonalElements($A) = [2, 6]     *     * http://mathworld.wolfram.com/Superdiagonal.html     *     * @return array     */    public function getSuperdiagonalElements(): array    {        $superdiagonal = [];        if ($this->isSquare()) {            for ($i = 0; $i < $this->m - 1; $i++) {                $superdiagonal[] = $this->A[$i][$i + 1];            }        }        return $superdiagonal;    }    /**     * Returns the elements on the subdiagonal of a square matrix as an array     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     * getSubdiagonalElements($A) = [4, 8]     *     * http://mathworld.wolfram.com/Subdiagonal.html     *     * @return array     */    public function getSubdiagonalElements(): array    {        $subdiagonal = [];        if ($this->isSquare()) {            for ($i = 1; $i < $this->m; $i++) {                $subdiagonal[] = $this->A[$i][$i - 1];            }        }        return $subdiagonal;    }    /**     * Returns an array of vectors from the columns of the matrix.     * Each column of the matrix becomes a vector.     *     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     *           [1] [2] [3]     * Vectors = [4] [5] [6]     *           [7] [8] [9]     *     * @return Vector[]     */    public function asVectors(): array    {        $n       = $this->n;        $vectors = [];        for ($j = 0; $j < $n; $j++) {            $vectors[] = new Vector(\array_column($this->A, $j));        }        return $vectors;    }    /**     * Returns an array of vectors from the columns of the matrix.     * Each column of the matrix becomes a vector.     *     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     *           [1] [4] [7]     * Vectors = [2] [5] [8]     *           [3] [6] [9]     *     * @return Vector[]     */    public function asRowVectors(): array    {        return \array_map(            function (array $row) {                return new Vector($row);            },            $this->A        );    }    /***************************************************************************     * MATRIX COMPARISONS     *  - isEqualSizeAndType     ***************************************************************************/    /**     * Is this matrix the same size and type as some other matrix?     *     * @param Matrix $B     *     * @return bool     */    protected function isEqualSizeAndType(Matrix $B): bool    {        if ($this->getObjectType() !== $B->getObjectType()) {            return false;        }        $m = $this->m;        $n = $this->n;        // Same dimensions        if ($m != $B->m || $n != $B->n) {            return false;        }        return true;    }    /**************************************************************************     * MATRIX PROPERTIES     *  - isSquare     **************************************************************************/    /**     * Is the matrix a square matrix?     * Do rows m = columns n?     *     * @return bool true if square; false otherwise.     */    public function isSquare(): bool    {        return $this->m === $this->n;    }    /**************************************************************************     * MATRIX AUGMENTATION - Return a Matrix     *  - augment     *  - augmentBelow     *  - augmentAbove     *  - augmentLeft     **************************************************************************/    /**     * Augment a matrix     * An augmented matrix is a matrix obtained by appending the columns of two given matrices     *     *     [1, 2, 3]     * A = [2, 3, 4]     *     [3, 4, 5]     *     *     [4]     * B = [5]     *     [6]     *     *         [1, 2, 3 | 4]     * (A|B) = [2, 3, 4 | 5]     *         [3, 4, 5 | 6]     *     * @param  Matrix $B Matrix columns to add to matrix A     *     * @return Matrix     *     * @throws Exception\MatrixException if matrices do not have the same number of rows     * @throws Exception\IncorrectTypeException     */    public function augment(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of rows');        }        $m    = $this->m;        $A    = $this->A;        $B    = $B->getMatrix();        $âŸ®Aâˆ£BâŸ¯ = [];        for ($i = 0; $i < $m; $i++) {            $âŸ®Aâˆ£BâŸ¯[$i] = \array_merge($A[$i], $B[$i]);        }        return MatrixFactory::create($âŸ®Aâˆ£BâŸ¯, $this->Îµ);    }    /**     * Augment a matrix on the left     * An augmented matrix is a matrix obtained by preprending the columns of two given matrices     *     *     [1, 2, 3]     * A = [2, 3, 4]     *     [3, 4, 5]     *     *     [4]     * B = [5]     *     [6]     *     *         [4 | 1, 2, 3]     * (A|B) = [5 | 2, 3, 4]     *         [6 | 3, 4, 5]     *     * @param  Matrix $B Matrix columns to add to matrix A     *     * @return Matrix     *     * @throws Exception\MatrixException if matrices do not have the same number of rows     * @throws Exception\IncorrectTypeException     */    public function augmentLeft(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of rows');        }        $m    = $this->m;        $A    = $this->A;        $B    = $B->getMatrix();        $âŸ®Bâˆ£AâŸ¯ = [];        for ($i = 0; $i < $m; $i++) {            $âŸ®Bâˆ£AâŸ¯[$i] = \array_merge($B[$i], $A[$i]);        }        return MatrixFactory::create($âŸ®Bâˆ£AâŸ¯, $this->Îµ);    }    /**     * Augment a matrix from below     * An augmented matrix is a matrix obtained by appending the rows of two given matrices     *     *     [1, 2, 3]     * A = [2, 3, 4]     *     [3, 4, 5]     *     * B = [4, 5, 6]     *     *         [1, 2, 3]     * (A_B) = [2, 3, 4]     *         [3, 4, 5]     *         [4, 5, 6]     *     * @param  Matrix $B Matrix rows to add to matrix A     *     * @return Matrix     *     * @throws Exception\MatrixException if matrices do not have the same number of columns     * @throws Exception\IncorrectTypeException     */    public function augmentBelow(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of columns');        }        $âŸ®Aâˆ£BâŸ¯ = \array_merge($this->A, $B->getMatrix());        return MatrixFactory::create($âŸ®Aâˆ£BâŸ¯, $this->Îµ);    }    /**     * Augment a matrix from above     * An augmented matrix is a matrix obtained by prepending the rows of two given matrices     *     *     [1, 2, 3]     * A = [2, 3, 4]     *     [3, 4, 5]     *     * B = [4, 5, 6]     *     *         [4, 5, 6]     *         [1, 2, 3]     * (A_B) = [2, 3, 4]     *         [3, 4, 5]     *     * @param  Matrix $B Matrix rows to add to matrix A     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public function augmentAbove(Matrix $B): Matrix    {        if ($this->getObjectType() !== $B->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices to augment do not have the same number of columns');        }        $âŸ®Aâˆ£BâŸ¯ = \array_merge($B->getMatrix(), $this->A);        return MatrixFactory::create($âŸ®Aâˆ£BâŸ¯, $this->Îµ);    }    /**************************************************************************     * MATRIX OPERATIONS - Return a Matrix     *  - transpose     *  - submatrix     *  - insert     **************************************************************************/    /**     * Transpose matrix     *     * The transpose of a matrix A is another matrix Aáµ€:     *  - reflect A over its main diagonal (which runs from top-left to bottom-right) to obtain AT     *  - write the rows of A as the columns of AT     *  - write the columns of A as the rows of AT     * Formally, the i th row, j th column element of Aáµ€ is the j th row, i th column element of A.     * If A is an m Ã— n matrix then Aáµ€ is an n Ã— m matrix.     * https://en.wikipedia.org/wiki/Transpose     *     * @return Matrix     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     */    public function transpose(): Matrix    {        if ($this->catalog->hasTranspose()) {            return $this->catalog->getTranspose();        }        $Aáµ€ = [];        for ($i = 0; $i < $this->n; $i++) {            $Aáµ€[$i] = $this->getColumn($i);        }        $this->catalog->addTranspose(MatrixFactory::create($Aáµ€, $this->Îµ));        return $this->catalog->getTranspose();    }    /**     * Submatrix     *     * Return an arbitrary subset of a Matrix as a new Matrix.     *     * @param int $mâ‚ Starting row     * @param int $nâ‚ Starting column     * @param int $mâ‚‚ Ending row     * @param int $nâ‚‚ Ending column     *     * @return Matrix     *     * @throws Exception\MatrixException     */    public function submatrix(int $mâ‚, int $nâ‚, int $mâ‚‚, int $nâ‚‚): Matrix    {        if ($mâ‚ >= $this->m || $mâ‚ < 0 || $mâ‚‚ >= $this->m || $mâ‚‚ < 0) {            throw new Exception\MatrixException('Specified Matrix row does not exist');        }        if ($nâ‚ >= $this->n || $nâ‚ < 0 || $nâ‚‚ >= $this->n || $nâ‚‚ < 0) {            throw new Exception\MatrixException('Specified Matrix column does not exist');        }        if ($mâ‚‚ < $mâ‚) {            throw new Exception\MatrixException('Ending row must be greater than beginning row');        }        if ($nâ‚‚ < $nâ‚) {            throw new Exception\MatrixException('Ending column must be greater than the beginning column');        }        $A = [];        for ($i = 0; $i <= $mâ‚‚ - $mâ‚; $i++) {            for ($j = 0; $j <= $nâ‚‚ - $nâ‚; $j++) {                $A[$i][$j] = $this->A[$i + $mâ‚][$j + $nâ‚];            }        }        return MatrixFactory::create($A, $this->Îµ);    }    /**     * Insert     * Insert a smaller matrix within a larger matrix starting at a specified position     *     * @param Matrix $small the smaller matrix to embed     * @param int    $m     Starting row     * @param int    $n     Starting column     *     * @return Matrix     *     * @throws Exception\MatrixException     */    public function insert(Matrix $small, int $m, int $n): Matrix    {        if ($this->getObjectType() !== $small->getObjectType()) {            throw new Exception\MatrixException('Matrices must be the same type.');        }        if ($small->getM() + $m > $this->m || $small->getN() + $n > $this->n) {            throw new Exception\MatrixException('Inner matrix exceeds the bounds of the outer matrix');        }        $new_array = $this->A;        for ($i = 0; $i < $small->getM(); $i++) {            for ($j = 0; $j < $small->getN(); $j++) {                $new_array[$i + $m][$j + $n] = $small[$i][$j];            }        }        return MatrixFactory::create($new_array, $this->Îµ);    }    /**************************************************************************     * MATRIX MAPPING     *  - map     *  - mapRows     **************************************************************************/    /**     * Map a function over all elements of the matrix     *     * @param  callable $func takes a matrix item as input     *     * @return Matrix     *     * @throws Exception\IncorrectTypeException     */    public function map(callable $func): Matrix    {        $m = $this->m;        $n = $this->n;        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $func($this->A[$i][$j]);            }        }        return MatrixFactory::create($R, $this->Îµ);    }    /**     * Map a function over the rows of the matrix     *     * @param callable $func     *     * @return array|array[] Depends on the function     */    public function mapRows(callable $func): array    {        return \array_map(            $func,            $this->A        );    }    /**     * Walk a function over all elements of the matrix     *     * @param callable $func     */    public function walk(callable $func): void    {        $m = $this->m;        $n = $this->n;        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $func($this->A[$i][$j]);            }        }    }    /**************************************************************************     * ROW OPERATIONS - Return a Matrix     *  - rowInterchange     *  - rowExclude     **************************************************************************/    /**     * Interchange two rows     *     * Row máµ¢ changes to position mâ±¼     * Row mâ±¼ changes to position máµ¢     *     * @param int $máµ¢ Row to swap into row position mâ±¼     * @param int $mâ±¼ Row to swap into row position máµ¢     *     * @return Matrix with rows máµ¢ and mâ±¼ interchanged     *     * @throws Exception\MatrixException if row to interchange does not exist     * @throws Exception\IncorrectTypeException     */    public function rowInterchange(int $máµ¢, int $mâ±¼): Matrix    {        if ($máµ¢ >= $this->m || $mâ±¼ >= $this->m) {            throw new Exception\MatrixException('Row to interchange does not exist');        }        $m = $this->m;        $R = [];        for ($i = 0; $i < $m; $i++) {            switch ($i) {                case $máµ¢:                    $R[$i] = $this->A[$mâ±¼];                    break;                case $mâ±¼:                    $R[$i] = $this->A[$máµ¢];                    break;                default:                    $R[$i] = $this->A[$i];            }        }        return MatrixFactory::create($R, $this->Îµ);    }    /**     * Exclude a row from the result matrix     *     * @param int $máµ¢ Row to exclude     *     * @return Matrix with row máµ¢ excluded     *     * @throws Exception\MatrixException if row to exclude does not exist     * @throws Exception\IncorrectTypeException     */    public function rowExclude(int $máµ¢): Matrix    {        if ($máµ¢ >= $this->m || $máµ¢ < 0) {            throw new Exception\MatrixException('Row to exclude does not exist');        }        $m = $this->m;        $R = [];        for ($i = 0; $i < $m; $i++) {            if ($i === $máµ¢) {                continue;            }            $R[$i] = $this->A[$i];        }        return MatrixFactory::create(\array_values($R), $this->Îµ);    }    /**************************************************************************     * COLUMN OPERATIONS - Return a Matrix     *  - columnInterchange     *  - columnExclude     **************************************************************************/    /**     * Interchange two columns     *     * Column náµ¢ changes to position nâ±¼     * Column nâ±¼ changes to position náµ¢     *     * @param int $náµ¢ Column to swap into column position nâ±¼     * @param int $nâ±¼ Column to swap into column position náµ¢     *     * @return Matrix with columns náµ¢ and nâ±¼ interchanged     *     * @throws Exception\MatrixException if column to interchange does not exist     * @throws Exception\IncorrectTypeException     */    public function columnInterchange(int $náµ¢, int $nâ±¼): Matrix    {        if ($náµ¢ >= $this->n || $nâ±¼ >= $this->n) {            throw new Exception\MatrixException('Column to interchange does not exist');        }        $m = $this->m;        $n = $this->n;        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                switch ($j) {                    case $náµ¢:                        $R[$i][$j] = $this->A[$i][$nâ±¼];                        break;                    case $nâ±¼:                        $R[$i][$j] = $this->A[$i][$náµ¢];                        break;                    default:                        $R[$i][$j] = $this->A[$i][$j];                }            }        }        return MatrixFactory::create($R, $this->Îµ);    }    /**     * Exclude a column from the result matrix     *     * @param int $náµ¢ Column to exclude     *     * @return Matrix with column náµ¢ excluded     *     * @throws Exception\MatrixException if column to exclude does not exist     * @throws Exception\IncorrectTypeException     */    public function columnExclude(int $náµ¢): Matrix    {        if ($náµ¢ >= $this->n || $náµ¢ < 0) {            throw new Exception\MatrixException('Column to exclude does not exist');        }        $m = $this->m;        $n = $this->n;        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if ($j === $náµ¢) {                    continue;                }                $R[$i][$j] = $this->A[$i][$j];            }        }        // Reset column indexes        for ($i = 0; $i < $m; $i++) {            $R[$i] = \array_values($R[$i]);        }        return MatrixFactory::create($R, $this->Îµ);    }    /**************************************************************************     * MATRIX OPERATIONS - Return a Matrix     *  - conjugateTranspose     *  - minorMatrix     *  - leadingPrincipalMinor     **************************************************************************/    /**     * Conjugate Transpose - Aá´´, also denoted as A*     *     * Returns the complex conjugate of the transpose. For a real matrix, this is the same as the transpose.     *     * https://en.wikipedia.org/wiki/Conjugate_transpose     *     * @return Matrix     */    public function conjugateTranspose(): Matrix    {        return $this->transpose();    }    /**     * Minor matrix     * Submatrix formed by deleting the iáµ—Ê° row and jáµ—Ê° column.     * Used in computing the minor Máµ¢â±¼.     *     * @param int $máµ¢ Row to exclude     * @param int $nâ±¼ Column to exclude     *     * @return Matrix with row máµ¢ and column nâ±¼ removed     *     * @throws Exception\MatrixException if matrix is not square     * @throws Exception\MatrixException if row to exclude for minor matrix does not exist     * @throws Exception\MatrixException if column to exclude for minor matrix does not exist     * @throws Exception\IncorrectTypeException     */    public function minorMatrix(int $máµ¢, int $nâ±¼): Matrix    {        if (!$this->isSquare()) {            throw new Exception\MatrixException('Matrix is not square; cannot get minor Matrix of a non-square matrix');        }        if ($máµ¢ >= $this->m || $máµ¢ < 0) {            throw new Exception\MatrixException('Row to exclude for minor Matrix does not exist');        }        if ($nâ±¼ >= $this->n || $nâ±¼ < 0) {            throw new Exception\MatrixException('Column to exclude for minor Matrix does not exist');        }        return $this->rowExclude($máµ¢)->columnExclude($nâ±¼);    }    /**     * Leading principal minor     * The leading principal minor of A of order k is the minor of order k     * obtained by deleting the last n âˆ’ k rows and columns.     *     * Example:     *     *     [1 2 3]     * A = [4 5 6]     *     [7 8 9]     *     * 1st order (k = 1): [1]     *     *                    [1 2]     * 2nd order (k = 2): [4 5]     *     *                    [1 2 3]     * 3rd order (k = 3): [4 5 6]     *                    [7 8 9]     *     * @param  int $k Order of the leading principal minor     *     * @return Matrix     *     * @throws Exception\OutOfBoundsException if k â‰¤ 0     * @throws Exception\OutOfBoundsException if k > n     * @throws Exception\MatrixException if matrix is not square     * @throws Exception\IncorrectTypeException     */    public function leadingPrincipalMinor(int $k): Matrix    {        if ($k <= 0) {            throw new Exception\OutOfBoundsException(""k is â‰¤ 0: $k"");        }        if ($k > $this->n) {            throw new Exception\OutOfBoundsException(""k ($k) leading principal minor is larger than size of Matrix: "" . $this->n);        }        if (!$this->isSquare()) {            throw new Exception\MatrixException('Matrix is not square; cannot get leading principal minor Matrix of a non-square matrix');        }        $R = [];        for ($i = 0; $i < $k; $i++) {            for ($j = 0; $j < $k; $j++) {                $R[$i][$j] = $this->A[$i][$j];            }        }        return MatrixFactory::create($R, $this->Îµ);    }    /**************************************************************************     * MATRIX OPERATIONS - Return a value     *  - minor     **************************************************************************/    /**     * Minor (first minor)     * The determinant of some smaller square matrix, cut down from A by removing one of its rows and columns.     *     *        [1 4  7]     * If A = [3 0  5]     *        [1 9 11]     *     *                [1 4 -]       [1 4]     * Then Mâ‚â‚‚ = det [- - -] = det [1 9] = 13     *                [1 9 -]     *     * https://en.wikipedia.org/wiki/Minor_(linear_algebra)     *     * @param int $máµ¢ Row to exclude     * @param int $nâ±¼ Column to exclude     *     * @return number     *     * @throws Exception\MatrixException if matrix is not square     * @throws Exception\MatrixException if row to exclude for minor does not exist     * @throws Exception\MatrixException if column to exclude for minor does not exist     * @throws Exception\IncorrectTypeException     * @throws Exception\BadParameterException     */    public function minor(int $máµ¢, int $nâ±¼)    {        if (!$this->isSquare()) {            throw new Exception\MatrixException('Matrix is not square; cannot get minor of a non-square matrix');        }        if ($máµ¢ >= $this->m || $máµ¢ < 0) {            throw new Exception\MatrixException('Row to exclude for minor does not exist');        }        if ($nâ±¼ >= $this->n || $nâ±¼ < 0) {            throw new Exception\MatrixException('Column to exclude for minor does not exist');        }        return $this->minorMatrix($máµ¢, $nâ±¼)->det();    }    /**************************************************************************     * ArrayAccess INTERFACE     **************************************************************************/    /**     * @param mixed $i     * @return bool     */    public function offsetExists($i): bool    {        return isset($this->A[$i]);    }    /**     * @param mixed $i     * @return mixed     */    public function offsetGet($i)    {        return $this->A[$i];    }    /**     * @param  mixed $i     * @param  mixed $value     * @throws Exception\MatrixException     */    public function offsetSet($i, $value)    {        throw new Exception\MatrixException('Matrix class does not allow setting values');    }    /**     * @param  mixed $i     * @throws Exception\MatrixException     */    public function offsetUnset($i)    {        throw new Exception\MatrixException('Matrix class does not allow unsetting values');    }    /**************************************************************************     * JsonSerializable INTERFACE     **************************************************************************/    /**     * @return array     */    public function jsonSerialize()    {        return $this->A;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
44,markrogoyski_math-php_Binomial_3220," PMF multiplication method\\n\\n Evaluate binomial probabilities using a method that avoids unnecessary overflow and underflow\\n Catherine Loader: http://octave.1599824.n4.nabble.com/attachment/3829107/0/loader2000Fast.pdf\\n\\n               x             x   n-x\\n              __  n - x + i __   __\\n p(x; n, p) = ||  --------- || p ||  (1 - p)\\n              â±â¼Â¹     i     â±â¼Â¹  â±â¼Â¹\\n\\n @param int   $r number of successful events\\n @param int   $n number of events\\n @param float $p probability of success\\n\\n @return float\\n",PMF multiplikaciona metoda. Procenite binomnu verovatnoću koristeći metodu koja izbegava nepotrebne preterane i nedovoljne prilagođenosti.,"private function multiplicationMethod(int $r, int $n, float $p): float	{	    if (2 * $r > $n) {	        return $this->multiplicationMethod($n - $r, $n, 1 - $p);	    }		    [$j₀, $j₁, $j₂] = [0, 0, 0];	    $f = 1;		    while (($j₀ < $r) | ($j₁ < $r) | ($j₂ < $n - $r)) {	        if (($j₀ < $r) && ($f < 1)) {	            $j₀++;	            $f *= ($n - $r + $j₀) / $j₀;	        } elseif ($j₁ < $r) {	            $j₁++;	            $f *= $p;	        } else {	            $j₂++;	            $f *= 1 - $p;	        }	    }		    return $f;	}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
45,markrogoyski_math-php_Binomial_3221, Cumulative distribution function\\n Computes and sums the binomial distribution at each of the values in r.\\n\\n @param  int $r number of successful events\\n\\n @return float\\n,Funkcija kumulativne raspodele. Izračunava i sabira binomnu raspodelu pri svakoj vrednosti od 0 do r.,"    public function cdf(int $r): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['r' => $r]);        $cdf = 0;        for ($i = $r; $i >= 0; $i--) {            $cdf += $this->pmf($i);        }        return $cdf;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
46,markrogoyski_math-php_Pascal_3251, Pascal distribution (alias class for negative binomial distribution)\\n https://en.wikipedia.org/wiki/Negative_binomial_distribution\\n,Klasa Paskalne raspodela ( pseudonim klasa za negativnu binomnu raspodelu) https://en.wikipedia.org/wiki/Negative_binomial_distribution,class Pascal extends NegativeBinomial{},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
47,markrogoyski_math-php_ANOVA_3433, ANOVA (Analysis of Variance)\n,Klasa za analizu varijansi ANOVA,"class ANOVA{    /**     * One-way ANOVA     * Technique used to compare means of three or more samples     * (using the F distribution).     * https://en.wikipedia.org/wiki/One-way_analysis_of_variance     *     * Produces the following analysis of the data:     *     * ANOVA hypothesis test summary data     *     *           | SS | df | MS | F | P |     * Treatment |    |    |    |   |   |     * Error     |    |    |    |     * Total     |    |    |     *     *  where:     *   Treament is between groups     *   Error is within groups     *   SS = Sum of squares     *   df = Degrees of freedom     *   MS = Mean squares     *   F  = F statistic     *   P  = P value     *     * Data summary table     *     *       | N | Sum | Mean | SS | Variance | SD | SEM |     * 0     |   |     |      |    |          |    |     |     * 1     |   |     |      |    |          |    |     |     * ...   |   |     |      |    |          |    |     |     * Total |   |     |      |    |          |    |     |     *     *  where:     *   Each row is the summary for a sample, numbered from 0 to m - 1     *   m   = Number of samples     *   N   = Sample size     *   SS  = Sum of squares     *   SD  = Standard deviation     *   SEM = Standard error of the mean     *     * Calculations     *     * Sum of Squares     * SST (sum of squares total)     * âˆ‘âŸ®xáµ¢Â âˆ’Â Î¼âŸ¯Â²     *  where:     *   xáµ¢ = each element of all samples     *   Î¼  = mean total of all elements of all samples     *     * SSB (sum of squares between - treatment)     * âˆ‘n(x - Î¼)Â²     *  where:     *   n = sample size     *   x = sample mean     *   Î¼  = mean total of all elements of all samples     *     * SSW (sum of squares within - error)     * âˆ‘âˆ‘âŸ®xáµ¢Â âˆ’Â Î¼âŸ¯Â²  Sum of sum of squared deviations of each sample     *  where:     *   xáµ¢ = each element of the sample     *   Î¼  = mean of the sample     *     * Degrees of Freedom     * dfT (degrees of freedom for the total)     * mn - 1     *     * dfB (degrees of freedom between - treatment)     * m - 1     *     * dfW (degrees of freedom within - error)     * m(n - 1)     *     *  where:     *   m = number of samples     *   n = number of elements in each sample     *     * Mean Squares     * MSB (Mean squares between - treatment)     * SSB / dfB     *     * MSW (Mean squares within - error)     * SSW / dfW     *     * Test Statistics     * F = MSB / MSW     * P = F distribution CDF above F with degrees of freedom dfB and dfW     *     * @param  array[] ...$samples Samples to analyze (at least 3 or more samples)     *     * @return array [     *                 ANOVA => [     *                   treatment => [SS, df, MS, F, P],     *                   error     => [SS, df, MS],     *                   total     => [SS, df],     *                 ],     *                 total_summary => [n, sum, mean, SS, variance, sd, sem],     *                 data_summary  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ]     *               ]     *     * @throws Exception\BadDataException if less than three samples, or if all samples don't have the same number of values     * @throws Exception\OutOfBoundsException     */    public static function oneWay(array ...$samples): array    {        // Must have at least three samples        $m = \count($samples);        if ($m < 3) {            throw new Exception\BadDataException('Must have at least three samples');        }        // All samples must have the same number of items        $n = \count($samples[0]);        for ($i = 1; $i < $m; $i++) {            if (\count($samples[$i]) !== $n) {                throw new Exception\BadDataException('All samples must have the same number of values');            }        }        // Summary data for each sample        $summary_data = [];        foreach ($samples as $i => $sample) {            $summary_data[$i]             = [];            $summary_data[$i]['n']        = $n;            $summary_data[$i]['sum']      = \array_sum($sample);            $summary_data[$i]['mean']     = Average::mean($sample);            $summary_data[$i]['SS']       = RandomVariable::sumOfSquares($sample);            $summary_data[$i]['variance'] = Descriptive::sampleVariance($sample);            $summary_data[$i]['sd']       = Descriptive::sd($sample);            $summary_data[$i]['sem']      = RandomVariable::standardErrorOfTheMean($sample);        }        // Totals summary        $all_elements = \array_reduce(            $samples,            function ($merged, $sample) {                return \array_merge($merged, $sample);            },            array()        );        $Î¼     = Average::mean($all_elements);        $total = [            'n'        => \count($all_elements),            'sum'      => \array_sum($all_elements),            'mean'     => $Î¼,            'SS'       => RandomVariable::sumOfSquares($all_elements),            'variance' => Descriptive::sampleVariance($all_elements),            'sd'       => Descriptive::sd($all_elements),            'sem'      => RandomVariable::standardErrorOfTheMean($all_elements),        ];        // ANOVA sum of squares        $SST = RandomVariable::sumOfSquaresDeviations($all_elements);        $SSB = \array_sum(\array_map(            function ($sample) use ($n, $Î¼) {                return $n * (Average::mean($sample) - $Î¼) ** 2;            },            $samples        ));        $SSW = \array_sum(\array_map(            'MathPHP\Statistics\RandomVariable::sumOfSquaresDeviations',            $samples        ));        // ANOVA degrees of freedom        $dfT = $m * $n - 1;        $dfB = $m - 1;        $dfW = $m * ($n - 1);        // ANOVA mean squares        $MSB = $SSB / $dfB;        $MSW = $SSW / $dfW;        // Test statistics        $F = $MSB / $MSW;        $fDist = new F($dfB, $dfW);        $P = $fDist->above($F);        // Return ANOVA report        return [            'ANOVA' => [                'treatment' => [                    'SS' => $SSB,                    'df' => $dfB,                    'MS' => $MSB,                    'F'  => $F,                    'P'  => $P,                ],                'error' => [                    'SS' => $SSW,                    'df' => $dfW,                    'MS' => $MSW,                ],                'total' => [                    'SS' => $SST,                    'df' => $dfT,                ],            ],            'total_summary' => $total,            'data_summary'  => $summary_data,        ];    }    /**     * Two-way ANOVA     * Examines the influence of two different categorical independent variables on     * one continuous dependent variable. The two-way ANOVA not only aims at assessing     * the main effect of each independent variable but also if there is any interaction     * between them (using the F distribution).     * https://en.wikipedia.org/wiki/Two-way_analysis_of_variance     *     * Produces the following analysis of the data:     *     * ANOVA hypothesis test summary data     *     *             | SS | df | MS | F | P |     * Factor A    |    |    |    |   |   |     * Factor B    |    |    |    |   |   |     * Interaction |    |    |    |   |   |     * Error       |    |    |    |     * Total       |    |    |     *     *  where:     *   Interaction = Factor A X Factor B working together     *   Error is within groups     *   SS = Sum of squares     *   df = Degrees of freedom     *   MS = Mean squares     *   F  = F statistic     *   P  = P value     *     * Data summary tables for:     *   Factor A     *   Factor B     *   Factor AB (Interaction)     *   Total     *     *       | N | Sum | Mean | SS | Variance | SD | SEM |     * 0     |   |     |      |    |          |    |     |     * 1     |   |     |      |    |          |    |     |     * ...   |   |     |      |    |          |    |     |     * Total |   |     |      |    |          |    |     |     *     *  where:     *   Each row is the summary for a sample, numbered from 0 to m - 1     *   m   = Number of samples     *   N   = Sample size     *   SS  = Sum of squares     *   SD  = Standard deviation     *   SEM = Standard error of the mean     *     * Calculations     *     * Sum of Squares     * SST (sum of squares total)     * âˆ‘âŸ®xáµ¢Â âˆ’Â Î¼âŸ¯Â²     *  where:     *   xáµ¢ = each element of all samples     *   Î¼  = mean total of all elements of all samples     *     * SSA, SSB (sum of squares for each factor A and B)     * âˆ‘n(x - Î¼)Â²     *  where:     *   n = sample size     *   x = sample mean     *   Î¼  = mean total of all elements of all samples     *     * SSW (sum of squares within - error)     * âˆ‘âˆ‘âŸ®xÂ âˆ’Â Î¼âŸ¯Â²  Sum of sum of squared deviations of each sample     *  where:     *   x = mean of each AB     *   Î¼ = mean of the sample     *     * SSAB (sum of squares AB - interaction)     * SSAB = SST - SSA - SSB - SSW;     *     * Degrees of Freedom     * dfT (degrees of freedom for the total)     * n - 1     *     * dfA (degrees of freedom factor A)     * r - 1     *     * dfB (degrees of freedom factor B)     * c - 1     *     * dfAB (degrees of freedom factor AB - interaction)     * (r - 1)(c - 1)     *     * dfW (degrees of freedom within - error)     * n - rc     *     *  where:     *   n = number of samples     *   r = number of rows (number of factor As)     *   c = number of columns (number of factor Bs)     *     * Mean Squares     * MSA (Mean squares factor A)     * SSA / dfA     *     * MSB (Mean squares factor B)     * SSB / dfB     *     * MSAB (Mean squares factor AB - interaction)     * SSAB / dfAB     *     * MSW (Mean squares within - error)     * SSW / dfW     *     * F Test Statistics     * FA  = MSA / MSW     * FB  = MSB / MSW     * FAB = MSAB / MSW     *     * P values     * PA  = F distribution CDF above FA with degrees of freedom dfA and dfW     * PB  = F distribution CDF above FB with degrees of freedom dfA and dfW     * PAB = F distribution CDF above FAB with degrees of freedom dfAB and dfW     *     * Example input data for ...$data parameter:     *             | Factor Bâ‚ | Factor Bâ‚‚ | â‹¯     *   Factor Aâ‚ |  4, 6, 8  |  6, 6, 9  | â‹¯     *   Factor Aâ‚‚ |  4, 8, 9  | 7, 10, 13 | â‹¯     *      â‹®           â‹®           â‹®         â‹®     * @param  array[] ...$data Samples to analyze [     *               // Factor Aâ‚     *               [     *                   [4, 6, 8] // Factor Bâ‚     *                   [6, 6, 9] // Factor Bâ‚‚     *                       â‹®     *               ],     *               // Factor Aâ‚‚     *               [     *                   [4, 8, 9]   // Factor Bâ‚     *                   [7, 10, 13] // Factor Bâ‚‚     *                       â‹®     *               ],     *               ...     *         ]     *     * @return array [     *                 ANOVA => [     *                   factorA  => [SS, df, MS, F, P],     *                   factorB  => [SS, df, MS, F, P],     *                   factorAB => [SS, df, MS, F, P],     *                   error    => [SS, df, MS],     *                   total    => [SS, df],     *                 ],     *                 total_summary => [n, sum, mean, SS, variance, sd, sem],     *                 summary_factorA  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ],     *                 summary_factorB  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ],     *                 summary_factorAB  => [     *                   0     => [n, sum, mean, SS, variance, sd, sem],     *                   1     => [n, sum, mean, SS, variance, sd, sem],     *                   ...     *                 ]     *               ]     * @throws Exception\BadDataException if less than two A factors, or if B factors or values have different number elements     * @throws Exception\OutOfBoundsException     */    public static function twoWay(array ...$data): array    {        // Must have at least two rows (two types of factor A)        $r = \count($data);        if ($r < 2) {            throw new Exception\BadDataException('Must have at least two rows (two types of factor A)');        }        // All samples must have the same number the second factor B        $c = \count($data[0]);        for ($i = 1; $i < $r; $i++) {            if (\count($data[$i]) !== $c) {                throw new Exception\BadDataException('All samples must have the same number of the second factor B');            }        }        // Each AB factor interaction must have the same number of values        $v = \count($data[0][0]);        for ($i = 0; $i < $r; $i++) {            for ($j = 0; $j < $c; $j++) {                if (\count($data[$i][$j]) !== $v) {                    throw new Exception\BadDataException('Each AB factor interaction must have the same number of values');                }            }        }        // Aggregates for all elements, rows (factor A), and columns (factor B)        $all_elements = [];        $A_elements   = [];        $B_elements   = [];        // Summaries for factor A, factor B, and AB        $summary_A     = [];        $summary_B     = [];        $summary_AB    = [];        // Summary data for each AB        // And aggregate all elements and elements for factor A        foreach ($data as $A => $Bs) {            $A_elements[$A] = [];            foreach ($Bs as $B => $values) {                // Aggregates                $all_elements   = \array_merge($all_elements, $values);                $A_elements[$A] = \array_merge($A_elements[$A], $values);                // AB summary                $summary_AB[$A][$B]             = [];                $summary_AB[$A][$B]['n']        = $c;                $summary_AB[$A][$B]['sum']      = \array_sum($values);                $summary_AB[$A][$B]['mean']     = Average::mean($values);                $summary_AB[$A][$B]['SS']       = RandomVariable::sumOfSquares($values);                $summary_AB[$A][$B]['variance'] = Descriptive::sampleVariance($values);                $summary_AB[$A][$B]['sd']       = Descriptive::sd($values);                $summary_AB[$A][$B]['sem']      = RandomVariable::standardErrorOfTheMean($values);            }        }        // Aggregate elements for factor B        for ($B = 0; $B < $c; $B++) {            $B_elements[$B] = [];            foreach ($data as $factor1s) {                $B_elements[$B] = \array_merge($B_elements[$B], $factor1s[$B]);            }        }        // Factor A summary        foreach ($A_elements as $A => $elements) {            $summary_A[$A]             = [];            $summary_A[$A]['n']        = \count($elements);            $summary_A[$A]['sum']      = \array_sum($elements);            $summary_A[$A]['mean']     = Average::mean($elements);            $summary_A[$A]['SS']       = RandomVariable::sumOfSquares($elements);            $summary_A[$A]['variance'] = Descriptive::sampleVariance($elements);            $summary_A[$A]['sd']       = Descriptive::sd($elements);            $summary_A[$A]['sem']      = RandomVariable::standardErrorOfTheMean($elements);        }        // Factor B summary        foreach ($B_elements as $B => $elements) {            $summary_B[$B]             = [];            $summary_B[$B]['n']        = \count($elements);            $summary_B[$B]['sum']      = \array_sum($elements);            $summary_B[$B]['mean']     = Average::mean($elements);            $summary_B[$B]['SS']       = RandomVariable::sumOfSquares($elements);            $summary_B[$B]['variance'] = Descriptive::sampleVariance($elements);            $summary_B[$B]['sd']       = Descriptive::sd($elements);            $summary_B[$B]['sem']      = RandomVariable::standardErrorOfTheMean($elements);        }        // Totals summary        $Î¼             = Average::mean($all_elements);        $summary_total = [            'n'        => \count($all_elements),            'sum'      => \array_sum($all_elements),            'mean'     => $Î¼,            'SS'       => RandomVariable::sumOfSquares($all_elements),            'variance' => Descriptive::sampleVariance($all_elements),            'sd'       => Descriptive::sd($all_elements),            'sem'      => RandomVariable::standardErrorOfTheMean($all_elements),        ];        // Sum of squares factor A        $SSA = \array_sum(\array_map(            function ($f1) use ($Î¼) {                return $f1['n'] * ($f1['mean'] - $Î¼) ** 2;            },            $summary_A        ));        // Sum of squares factor B        $SSB = \array_sum(\array_map(            function ($B) use ($Î¼) {                return $B['n'] * ($B['mean'] - $Î¼) ** 2;            },            $summary_B        ));        // Sum of squares within (error)        $SSW = 0;        foreach ($data as $A => $Bs) {            foreach ($Bs as $B => $values) {                foreach ($values as $value) {                    $SSW += ($value - $summary_AB[$A][$B]['mean']) ** 2;                }            }        }        // Sum of squares total        $SST = 0;        foreach ($data as $A => $Bs) {            foreach ($Bs as $B => $values) {                foreach ($values as $value) {                    $SST += ($value - $Î¼) ** 2;                }            }        }        // Sum of squares AB interaction        $SSAB = $SST - $SSA - $SSB - $SSW;        // Degrees of freedom        $dfA  = $r - 1;        $dfB  = $c - 1;        $dfAB = ($r - 1) * ($c - 1);        $dfW  = $summary_total['n'] - ($r * $c);        $dfT  = $summary_total['n'] - 1;        // Mean squares        $MSA  = $SSA / $dfA;        $MSB  = $SSB / $dfB;        $MSAB = $SSAB / $dfAB;        $MSW  = $SSW / $dfW;        // F test statistics        $FA  = $MSA / $MSW;        $FB  = $MSB / $MSW;        $FAB = $MSAB / $MSW;        // P values        $fDist1 = new F($dfA, $dfW);        $fDist2 = new F($dfB, $dfW);        $fDist3 = new F($dfAB, $dfW);        $PA  = $fDist1->above($FA);        $PB  = $fDist2->above($FB);        $PAB = $fDist3->above($FAB);        // Return ANOVA report        return [            'ANOVA' => [                'factorA' => [                    'SS' => $SSA,                    'df' => $dfA,                    'MS' => $MSA,                    'F'  => $FA,                    'P'  => $PA,                ],                'factorB' => [                    'SS' => $SSB,                    'df' => $dfB,                    'MS' => $MSB,                    'F'  => $FB,                    'P'  => $PB,                ],                'interaction' => [                    'SS' => $SSAB,                    'df' => $dfAB,                    'MS' => $MSAB,                    'F'  => $FAB,                    'P'  => $PAB,                ],                'error' => [                    'SS' => $SSW,                    'df' => $dfW,                    'MS' => $MSW,                ],                'total' => [                    'SS' => $SST,                    'df' => $dfT,                ],            ],            'total_summary'       => $summary_total,            'summary_factorA'     => $summary_A,            'summary_factorB'     => $summary_B,            'summary_interaction' => $summary_AB,        ];    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
48,markrogoyski_math-php_LinearThroughPoint_3579," Linear Regression Through a Fixed Point - least squares method\n\n A model with a single explanatory variable.\n Fits a straight line through the set of n points in such a way that makes\n the sum of squared residuals of the model (that is, vertical distances\n between the points of the data set and the fitted line) as small as possible.\n https://en.wikipedia.org/wiki/Simple_linear_regression\n\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\n Find the equation y = mx + b\n such that the line passes through the point (v,w)\n\n      âˆ‘((x-v)(y-w))\n m =  _____________\n\n         âˆ‘(x-v)Â²\n\n b = w - m ",Linearna regresija kroz fiksnu tačku - metoda najmanjih kvadrata. Model sa jednom promenljivom obješnjenje. Pronalazi linearnu funkciju koja prolazi kroz skup od n tačaka na takav način da je prosečna vrednost kvadrata odstupanja minimalna (odstupanje je razlika između stvarne izlazne vrednosti podataka za obučavanje i vrednosti koja predviđa linearna funkcija).,"class LinearThroughPoint extends ParametricRegression{    use Methods\LeastSquares;    use Models\LinearModel;    /** @var float */    private $v;    /** @var float */    private $w;    /**     * Given a set of data ($points) and a point($force), perform a least squares     * regression of the data, such that the regression is forced to pass through     * the specified point.     *     * This procedure is most frequently used with $force = [0,0], the origin.     *     * @param array $points     * @param array $force Point to force regression line through (default: origin)     */    public function __construct(array $points, array $force = [0,0])    {        $this->v = $force[0];        $this->w = $force[1];        parent::__construct($points);    }    /**     * Calculates the regression parameters.     *     * @throws \MathPHP\Exception\BadDataException     * @throws \MathPHP\Exception\IncorrectTypeException     * @throws \MathPHP\Exception\MatrixException     * @throws \MathPHP\Exception\MathException     */    public function calculate(): void    {        $v = $this->v;        $w = $this->w;        $xâ€™ = Single::subtract($this->xs, $v);        $yâ€™ = Single::subtract($this->ys, $w);        $parameters = $this->leastSquares($yâ€™, $xâ€™, 1, 0)->getColumn(0);        $m = $parameters[0];        $b = $this->w - $m * $this->v;        $this->parameters = [$b, $m];    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
49,markrogoyski_math-php_LinearThroughPoint_3580, Calculates the regression parameters.\\n\\n @throws \\\\MathPHP\\\\Exception\\\\BadDataException\\n @throws \\\\MathPHP\\\\Exception\\\\IncorrectTypeException\\n @throws \\\\MathPHP\\\\Exception\\\\MatrixException\\n @throws \\\\MathPHP\\\\Exception\\\\MathException\\n,Izračunaj parametre regresije.,"    public function calculate(): void    {        $v = $this->v;        $w = $this->w;        $xâ€™ = Single::subtract($this->xs, $v);        $yâ€™ = Single::subtract($this->ys, $w);        $parameters = $this->leastSquares($yâ€™, $xâ€™, 1, 0)->getColumn(0);        $m = $parameters[0];        $b = $this->w - $m * $this->v;        $this->parameters = [$b, $m];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
50,markrogoyski_math-php_Linear_3577, Calculates the regression parameters.\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MatrixException\n @throws Exception\\MathException\n,Izračunaj parametre regresije.,"    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs)->getColumn(0);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
51,markrogoyski_math-php_LineweaverBurk_3583, Calculate the regression parameters by least squares on linearized data\n yâ»Â¹ = K \n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n @throws Exception\\MatrixException\n @throws Exception\\MathException\n,Izračunajte parametre regresije za najmanje kvadrate na linearizovanim podacima.,"public function calculate(): void	{	    // Linearize the relationship by taking the inverse of both x and y	    $x’ = Single::pow($this->xs, -1);	    $y’ = Single::pow($this->ys, -1);		    // Perform Least Squares Fit	    $linearized_parameters = $this->leastSquares($y’, $x’)->getColumn(0);		    // Translate the linearized parameters back.	    $V = 1 / $linearized_parameters[0];	    $K = $linearized_parameters[1] * $V;		    $this->parameters = [$V, $K];	}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
52,markrogoyski_math-php_LineweaverBurk_3584, Evaluate the regression equation at x\\n Uses the instance model's evaluateModel method.\\n\\n @param  float $x\\n\\n @return float\\n,Procenite regresionu jednačinu u k. Koristi instancu metode modela evaulateMethod,"    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
53,markrogoyski_math-php_ParametricRegression_3585, Have the parent separate the points into xs and ys.\\n Calculate the regression parameters\\n\\n @param float[] $points\\n,Pokreni izračunavanje parametara regresije nakon sto nadklasa razdvoji izlazne i ulazne vrednosti skupa za treniranje. ,    public function __construct(array $points)    {        parent::__construct($points);        $this->calculate();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
54,markrogoyski_math-php_WeightedLinear_3603," Weighted linear regression - least squares method\\n\\n A model with a single explanatory variable.\\n Fits a straight line through the set of n points in such a way that makes\\n the sum of squared residuals of the model (that is, vertical distances\\n between the points of the data set and the fitted line) as small as possible.\\n https://en.wikipedia.org/wiki/Simple_linear_regression\\n\\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\\n Find the equation y = mx + b\\n\\n",Ponderisana linearna regresija - metoda njamanjih kvadrata. Model sa jednom promenljivom obješnjenje. Pronalazi linearnu funkciju koja prolazi kroz skup od n tačaka na takav način da je prosečna vrednost kvadrata odstupanja minimalna (odstupanje je razlika između stvarne izlazne vrednosti podataka za obučavanje i vrednosti koja predviđa linearna funkcija).,"class WeightedLinear extends ParametricRegression{    use Models\LinearModel;    use Methods\WeightedLeastSquares;    /**     * Array of weights     * @var array     */    private $ws;    /**     * @param array $points     * @param array $ws     Weights     */    public function __construct(array $points, array $ws)    {        $this->ws = $ws;        parent::__construct($points);    }    /**     * Calculates the regression parameters.     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     */    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs, $this->ws)->getColumn(0);    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
55,PrestaShop_PrestaShop_Access_761, Class AccessCore.\\\\n,Klasa AccessCore.,"class AccessCore extends ObjectModel{    /** @var int Profile id which address belongs to */    public $id_profile = null;    /** @var int AuthorizationRole id which address belongs to */    public $id_authorization_role = null;    /**     * @see ObjectModel::$definition     */    public static $definition = [        'table' => 'access',        'primary' => 'id_profile',        'fields' => [            'id_profile' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_authorization_role' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],        ],    ];    /**     * Is access granted to this Role?     *     * @param string $role Role name (""Superadministrator"", ""sales"", ""translator"", etc.)     * @param int $idProfile Profile ID     *     * @return bool Whether access is granted     *     * @throws Exception     */    public static function isGranted($role, $idProfile)    {        foreach ((array) $role as $currentRole) {            preg_match(                '/ROLE_MOD_(?P<type>[A-Z]+)_(?P<name>[A-Z0-9_]+)_(?P<auth>[A-Z]+)/',                $currentRole,                $matches            );            if (isset($matches['type']) && $matches['type'] == 'TAB') {                $joinTable = _DB_PREFIX_ . 'access';            } elseif (isset($matches['type']) && $matches['type'] == 'MODULE') {                $joinTable = _DB_PREFIX_ . 'module_access';            } else {                throw new Exception('The slug ' . $currentRole . ' is invalid');            }            $currentRole = Db::getInstance()->escape($currentRole);            $isCurrentGranted = (bool) Db::getInstance()->getRow('                SELECT t.`id_authorization_role`                FROM `' . _DB_PREFIX_ . 'authorization_role` t                LEFT JOIN ' . $joinTable . ' j                ON j.`id_authorization_role` = t.`id_authorization_role`                WHERE `slug` = ""' . $currentRole . '""                AND j.`id_profile` = ""' . (int) $idProfile . '""            ');            if (!$isCurrentGranted) {                return false;            }        }        return true;    }    /**     * Get all roles for the Profile ID.     *     * @param int $idProfile Profile ID     *     * @return array Roles     */    public static function getRoles($idProfile)    {        $idProfile = (int) $idProfile;        $accesses = Db::getInstance()->executeS('            SELECT r.`slug`            FROM `' . _DB_PREFIX_ . 'authorization_role` r            INNER JOIN `' . _DB_PREFIX_ . 'access` a ON a.`id_authorization_role` = r.`id_authorization_role`            WHERE a.`id_profile` = ""' . $idProfile . '""        ');        $accessesFromModules = Db::getInstance()->executeS('            SELECT r.`slug`            FROM `' . _DB_PREFIX_ . 'authorization_role` r            INNER JOIN `' . _DB_PREFIX_ . 'module_access` ma ON ma.`id_authorization_role` = r.`id_authorization_role`            WHERE ma.`id_profile` = ""' . $idProfile . '""        ');        $roles = array_merge($accesses, $accessesFromModules);        foreach ($roles as $key => $role) {            $roles[$key] = $role['slug'];        }        return $roles;    }    /**     * Find Tab ID by slug.     *     * @param string $authSlug Slug     *     * @return string Tab ID     * @todo: Find out if we should return an int instead. (breaking change)     */    public static function findIdTabByAuthSlug($authSlug)    {        preg_match(            '/ROLE_MOD_[A-Z]+_(?P<classname>[A-Z]+)_(?P<auth>[A-Z]+)/',            $authSlug,            $matches        );        $result = Db::getInstance()->getRow('            SELECT `id_tab`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE UCASE(`class_name`) = ""' . $matches['classname'] . '""        ');        return $result['id_tab'];    }    /**     * Find slug by Tab ID.     *     * @param int $idTab Tab ID     *     * @return string Full module slug     */    public static function findSlugByIdTab($idTab)    {        $result = Db::getInstance()->getRow('            SELECT `class_name`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE `id_tab` = ""' . (int) $idTab . '""        ');        return self::sluggifyTab($result);    }    /**     * Find slug by Parent Tab ID.     *     * @param int $idParentTab Tab ID     *     * @return string Full module slug     */    public static function findSlugByIdParentTab($idParentTab)    {        return Db::getInstance()->executeS('            SELECT `class_name`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE `id_parent` = ""' . (int) $idParentTab . '""        ');    }    /**     * Find slug by Module ID.     *     * @param int $idModule Module ID     *     * @return string Full module slug     */    public static function findSlugByIdModule($idModule)    {        $result = Db::getInstance()->getRow('            SELECT `name`            FROM `' . _DB_PREFIX_ . 'module`            WHERE `id_module` = ""' . (int) $idModule . '""        ');        return self::sluggifyModule($result);    }    /**     * Sluggify tab.     *     * @param string $tab Tab class name     * @param string $authorization 'CREATE'|'READ'|'UPDATE'|'DELETE'     *     * @return string Full slug for tab     */    public static function sluggifyTab($tab, $authorization = '')    {        return sprintf('ROLE_MOD_TAB_%s_%s', strtoupper($tab['class_name']), $authorization);    }    /**     * Sluggify module.     *     * @param string $module Module name     * @param string $authorization 'CREATE'|'READ'|'UPDATE'|'DELETE'     *     * @return string Full slug for module     */    public static function sluggifyModule($module, $authorization = '')    {        return sprintf('ROLE_MOD_MODULE_%s_%s', strtoupper($module['name']), $authorization);    }    /**     * Get legacy authorization.     *     * @param string $legacyAuth Legacy authorization     *     * @return bool|string|array Authorization     */    public static function getAuthorizationFromLegacy($legacyAuth)    {        $auth = [            'add' => 'CREATE',            'view' => 'READ',            'edit' => 'UPDATE',            'configure' => 'UPDATE',            'delete' => 'DELETE',            'uninstall' => 'DELETE',            'duplicate' => ['CREATE', 'UPDATE'],            'all' => ['CREATE', 'READ', 'UPDATE', 'DELETE'],        ];        return isset($auth[$legacyAuth]) ? $auth[$legacyAuth] : false;    }    /**     * Add access.     *     * @param int $idProfile Profile ID     * @param int $idRole Role ID     *     * @return string Whether access has been successfully granted (""ok"", ""error"")     */    public function addAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }    /**     * Remove access.     *     * @param int $idProfile Profile ID     * @param int $idRole Role ID     *     * @return string Whether access has been successfully removed (""ok"", ""error"")     */    public function removeAccess($idProfile, $idRole)    {        $sql = '            DELETE FROM `' . _DB_PREFIX_ . 'access`            WHERE `id_profile` = ""' . (int) $idProfile . '""            AND `id_authorization_role` = ""' . (int) $idRole . '""        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }    /**     * Add module access.     *     * @param int $idProfile Profile ID     * @param int $idRole Role ID     *     * @return string Whether module access has been successfully granted (""ok"", ""error"")     */    public function addModuleAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'module_access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }    /**     * @param int $idProfile     * @param int $idRole     *     * @return string 'ok'|'error'     */    public function removeModuleAccess($idProfile, $idRole)    {        $sql = '            DELETE FROM `' . _DB_PREFIX_ . 'module_access`            WHERE `id_profile` = ""' . (int) $idProfile . '""            AND `id_authorization_role` = ""' . (int) $idRole . '""        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }    /**     * Update legacy access.     *     * @param int $idProfile Profile ID     * @param int $idTab Tab ID     * @param string $lgcAuth Legacy authorization     * @param int $enabled Whether access should be granted     * @param int $addFromParent Child from parents     *     * @return string Whether legacy access has been successfully updated (""ok"", ""error"")     *     * @throws Exception     */    public function updateLgcAccess($idProfile, $idTab, $lgcAuth, $enabled, $addFromParent = 0)    {        $idProfile = (int) $idProfile;        $idTab = (int) $idTab;        if ($idTab == -1) {            $slug = 'ROLE_MOD_TAB_%_';        } else {            $slug = self::findSlugByIdTab($idTab);        }        $whereClauses = [];        foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {            $slugLike = Db::getInstance()->escape($slug . $auth);            $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';        }        if ($addFromParent == 1) {            foreach (self::findSlugByIdParentTab($idTab) as $child) {                $child = self::sluggifyTab($child);                foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {                    $slugLike = Db::getInstance()->escape($child . $auth);                    $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';                }            }        }        $roles = Db::getInstance()->executeS('            SELECT `id_authorization_role`            FROM `' . _DB_PREFIX_ . 'authorization_role` t            WHERE ' . implode(' OR ', $whereClauses) . '        ');        if (empty($roles)) {            throw new \Exception('Cannot find role slug');        }        $res = [];        foreach ($roles as $role) {            if ($enabled) {                $res[] = $this->addAccess($idProfile, $role['id_authorization_role']);            } else {                $res[] = $this->removeAccess($idProfile, $role['id_authorization_role']);            }        }        return in_array('error', $res) ? 'error' : 'ok';    }    /**     * Update (legacy) Module access.     *     * @param int $idProfile Profile ID     * @param int $idModule Module ID     * @param string $lgcAuth Legacy authorization     * @param int $enabled Whether module access should be granted     *     * @return string Whether module access has been succesfully changed (""ok"", ""error"")     */    public function updateLgcModuleAccess($idProfile, $idModule, $lgcAuth, $enabled)    {        $idProfile = (int) $idProfile;        $idModule = (int) $idModule;        if ($idModule == -1) {            $slug = 'ROLE_MOD_MODULE_%_';        } else {            $slug = self::findSlugByIdModule($idModule);        }        $whereClauses = [];        foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {            $slugLike = Db::getInstance()->escape($slug . $auth);            $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';        }        $roles = Db::getInstance()->executeS('            SELECT `id_authorization_role`            FROM `' . _DB_PREFIX_ . 'authorization_role` t            WHERE ' . implode(' OR ', $whereClauses) . '        ');        $res = [];        foreach ($roles as $role) {            if ($enabled) {                $res[] = $this->addModuleAccess($idProfile, $role['id_authorization_role']);            } else {                $res[] = $this->removeModuleAccess($idProfile, $role['id_authorization_role']);            }        }        return in_array('error', $res) ? 'error' : 'ok';    }}",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
56,PrestaShop_PrestaShop_Access_762," Is access granted to this Role?\\\\n\\\\n @param string $role Role name (""Superadministrator"", ""sales"", ""translator"", etc.)\\\\n @param int $idProfile Profile ID\\\\n\\\\n @return bool Whether access is granted\\\\n\\\\n @throws Exception\\\\n",Da li je pravo pristupa dodeljeno datom objektu uloge.,"    public static function isGranted($role, $idProfile)    {        foreach ((array) $role as $currentRole) {            preg_match(                '/ROLE_MOD_(?P<type>[A-Z]+)_(?P<name>[A-Z0-9_]+)_(?P<auth>[A-Z]+)/',                $currentRole,                $matches            );            if (isset($matches['type']) && $matches['type'] == 'TAB') {                $joinTable = _DB_PREFIX_ . 'access';            } elseif (isset($matches['type']) && $matches['type'] == 'MODULE') {                $joinTable = _DB_PREFIX_ . 'module_access';            } else {                throw new Exception('The slug ' . $currentRole . ' is invalid');            }            $currentRole = Db::getInstance()->escape($currentRole);            $isCurrentGranted = (bool) Db::getInstance()->getRow('                SELECT t.`id_authorization_role`                FROM `' . _DB_PREFIX_ . 'authorization_role` t                LEFT JOIN ' . $joinTable . ' j                ON j.`id_authorization_role` = t.`id_authorization_role`                WHERE `slug` = ""' . $currentRole . '""                AND j.`id_profile` = ""' . (int) $idProfile . '""            ');            if (!$isCurrentGranted) {                return false;            }        }        return true;    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
57,PrestaShop_PrestaShop_Access_763, Get all roles for the Profile ID.\\\\n\\\\n @param int $idProfile Profile ID\\\\n\\\\n @return array Roles\\\\n,Dohvati sve uloge na osnovu jedinstvenog indentifikatora profila.,"    public static function getRoles($idProfile)    {        $idProfile = (int) $idProfile;        $accesses = Db::getInstance()->executeS('            SELECT r.`slug`            FROM `' . _DB_PREFIX_ . 'authorization_role` r            INNER JOIN `' . _DB_PREFIX_ . 'access` a ON a.`id_authorization_role` = r.`id_authorization_role`            WHERE a.`id_profile` = ""' . $idProfile . '""        ');        $accessesFromModules = Db::getInstance()->executeS('            SELECT r.`slug`            FROM `' . _DB_PREFIX_ . 'authorization_role` r            INNER JOIN `' . _DB_PREFIX_ . 'module_access` ma ON ma.`id_authorization_role` = r.`id_authorization_role`            WHERE ma.`id_profile` = ""' . $idProfile . '""        ');        $roles = array_merge($accesses, $accessesFromModules);        foreach ($roles as $key => $role) {            $roles[$key] = $role['slug'];        }        return $roles;    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
58,PrestaShop_PrestaShop_Access_765, Find slug by Tab ID.\n\n @param int $idTab Tab ID\n\n @return string Full module slug\n,Pronađi deo url adrese na osnovu identifikatora tabulara.,"    public static function findSlugByIdTab($idTab)    {        $result = Db::getInstance()->getRow('            SELECT `class_name`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE `id_tab` = ""' . (int) $idTab . '""        ');        return self::sluggifyTab($result);    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
59,PrestaShop_PrestaShop_Access_766, Find slug by Parent Tab ID.\\\\n\\\\n @param int $idParentTab Tab ID\\\\n\\\\n @return string Full module slug\\\\n,Pronađi deo url adrese na osnovu identifikatora roditelj tabulara.,"    public static function findSlugByIdParentTab($idParentTab)    {        return Db::getInstance()->executeS('            SELECT `class_name`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE `id_parent` = ""' . (int) $idParentTab . '""        ');    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
60,PrestaShop_PrestaShop_Access_767, Find slug by Module ID.\\\\\\\\n\\\\\\\\n @param int $idModule Module ID\\\\\\\\n\\\\\\\\n @return string Full module slug\\\\\\\\n,Pronađi deo adrese na osnovu identifikatora modula,"    public static function findSlugByIdModule($idModule)    {        $result = Db::getInstance()->getRow('            SELECT `name`            FROM `' . _DB_PREFIX_ . 'module`            WHERE `id_module` = ""' . (int) $idModule . '""        ');        return self::sluggifyModule($result);    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
61,PrestaShop_PrestaShop_Access_768, Get legacy authorization.\\\\\\\\n\\\\\\\\n @param string $legacyAuth Legacy authorization\\\\\\\\n\\\\\\\\n @return bool|string|array Authorization\\\\\\\\n,Dohvati nasleđeno ovlašćenje.,"    public static function getAuthorizationFromLegacy($legacyAuth)    {        $auth = [            'add' => 'CREATE',            'view' => 'READ',            'edit' => 'UPDATE',            'configure' => 'UPDATE',            'delete' => 'DELETE',            'uninstall' => 'DELETE',            'duplicate' => ['CREATE', 'UPDATE'],            'all' => ['CREATE', 'READ', 'UPDATE', 'DELETE'],        ];        return isset($auth[$legacyAuth]) ? $auth[$legacyAuth] : false;    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
62,PHPOffice_PHPWord_MediaTest_988, Add section media element\\n,Dodaj element za medij odeljka. ,"    public function testAddSectionMediaElement()    {        $local = __DIR__ . '/_files/images/mars.jpg';        $object = __DIR__ . '/_files/documents/sheet.xls';        $remote = self::getRemoteImageUrl();        Media::addElement('section', 'image', $local, new Image($local));        Media::addElement('section', 'image', $local, new Image($local));        Media::addElement('section', 'image', $remote, new Image($local));        Media::addElement('section', 'object', $object);        Media::addElement('section', 'object', $object);        $this->assertCount(3, Media::getElements('section'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
63,PrestaShop_PrestaShop_Address_774, Class AddressCore.\\\\n,Klasa AddressCore,"class AddressCore extends ObjectModel{    /** @var int Customer ID which address belongs to */    public $id_customer = null;    /** @var int Manufacturer ID which address belongs to */    public $id_manufacturer = null;    /** @var int Supplier ID which address belongs to */    public $id_supplier = null;    /**     * @since 1.5.0     *     * @var int Warehouse ID which address belongs to     */    public $id_warehouse = null;    /** @var int Country ID */    public $id_country;    /** @var int State ID */    public $id_state;    /** @var string Country name */    public $country;    /** @var string Alias (eg. Home, Work...) */    public $alias;    /** @var string Company (optional) */    public $company;    /** @var string Lastname */    public $lastname;    /** @var string Firstname */    public $firstname;    /** @var string Address first line */    public $address1;    /** @var string Address second line (optional) */    public $address2;    /** @var string Postal code */    public $postcode;    /** @var string City */    public $city;    /** @var string Any other useful information */    public $other;    /** @var string Phone number */    public $phone;    /** @var string Mobile phone number */    public $phone_mobile;    /** @var string VAT number */    public $vat_number;    /** @var string DNI number */    public $dni;    /** @var string Object creation date */    public $date_add;    /** @var string Object last modification date */    public $date_upd;    /** @var bool True if address has been deleted (staying in database as deleted) */    public $deleted = 0;    /** @var array Zone IDs cache */    protected static $_idZones = [];    /** @var array Country IDs cache */    protected static $_idCountries = [];    /**     * @see ObjectModel::$definition     */    // when you override this class, do not create a field with allow_null=>true    // because it will give you exception on checkout address step    public static $definition = [        'table' => 'address',        'primary' => 'id_address',        'fields' => [            'id_customer' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_manufacturer' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_supplier' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_warehouse' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId', 'copy_post' => false],            'id_country' => ['type' => self::TYPE_INT, 'validate' => 'isUnsignedId', 'required' => true],            'id_state' => ['type' => self::TYPE_INT, 'validate' => 'isNullOrUnsignedId'],            'alias' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName', 'required' => true, 'size' => 32],            'company' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName', 'size' => 255],            'lastname' => ['type' => self::TYPE_STRING, 'validate' => 'isName', 'required' => true, 'size' => 255],            'firstname' => ['type' => self::TYPE_STRING, 'validate' => 'isName', 'required' => true, 'size' => 255],            'vat_number' => ['type' => self::TYPE_STRING, 'validate' => 'isGenericName'],            'address1' => ['type' => self::TYPE_STRING, 'validate' => 'isAddress', 'required' => true, 'size' => 128],            'address2' => ['type' => self::TYPE_STRING, 'validate' => 'isAddress', 'size' => 128],            'postcode' => ['type' => self::TYPE_STRING, 'validate' => 'isPostCode', 'size' => 12],            'city' => ['type' => self::TYPE_STRING, 'validate' => 'isCityName', 'required' => true, 'size' => 64],            'other' => ['type' => self::TYPE_STRING, 'validate' => 'isMessage', 'size' => 300],            'phone' => ['type' => self::TYPE_STRING, 'validate' => 'isPhoneNumber', 'size' => 32],            'phone_mobile' => ['type' => self::TYPE_STRING, 'validate' => 'isPhoneNumber', 'size' => 32],            'dni' => ['type' => self::TYPE_STRING, 'validate' => 'isDniLite', 'size' => 16],            'deleted' => ['type' => self::TYPE_BOOL, 'validate' => 'isBool', 'copy_post' => false],            'date_add' => ['type' => self::TYPE_DATE, 'validate' => 'isDate', 'copy_post' => false],            'date_upd' => ['type' => self::TYPE_DATE, 'validate' => 'isDate', 'copy_post' => false],        ],    ];    /** @var array Web service parameters */    protected $webserviceParameters = [        'objectsNodeName' => 'addresses',        'fields' => [            'id_customer' => ['xlink_resource' => 'customers'],            'id_manufacturer' => ['xlink_resource' => 'manufacturers'],            'id_supplier' => ['xlink_resource' => 'suppliers'],            'id_warehouse' => ['xlink_resource' => 'warehouse'],            'id_country' => ['xlink_resource' => 'countries'],            'id_state' => ['xlink_resource' => 'states'],        ],    ];    /**     * Build an Address.     *     * @param int $id_address Existing Address ID in order to load object (optional)     */    public function __construct($id_address = null, $id_lang = null)    {        parent::__construct($id_address);        /* Get and cache address country name */        if ($this->id) {            $this->country = Country::getNameById($id_lang ? $id_lang : Configuration::get('PS_LANG_DEFAULT'), $this->id_country);        }    }    /**     * reset static cache (eg unit testing purpose).     */    public static function resetStaticCache()    {        static::$_idZones = [];        static::$_idCountries = [];    }    /**     * @see ObjectModel::add()     */    public function add($autodate = true, $null_values = false)    {        if (!parent::add($autodate, $null_values)) {            return false;        }        if (Validate::isUnsignedId($this->id_customer)) {            Customer::resetAddressCache($this->id_customer, $this->id);        }        return true;    }    /**     * @see ObjectModel::update()     */    public function update($null_values = false)    {        // Empty related caches        if (isset(self::$_idCountries[$this->id])) {            unset(self::$_idCountries[$this->id]);        }        if (isset(self::$_idZones[$this->id])) {            unset(self::$_idZones[$this->id]);        }        if (Validate::isUnsignedId($this->id_customer)) {            Customer::resetAddressCache($this->id_customer, $this->id);        }        /* Skip the required fields */        if ($this->isUsed()) {            self::$fieldsRequiredDatabase['Address'] = [];        }        return parent::update($null_values);    }    /**     * @see ObjectModel::delete()     */    public function delete()    {        if (Validate::isUnsignedId($this->id_customer)) {            Customer::resetAddressCache($this->id_customer, $this->id);        }        if (!$this->isUsed()) {            $this->deleteCartAddress();            return parent::delete();        } else {            $this->deleted = true;            return $this->update();        }    }    /**     * removes the address from carts using it, to avoid errors on not existing address     */    protected function deleteCartAddress()    {        // keep pending carts, but unlink it from current address        $sql = 'UPDATE ' . _DB_PREFIX_ . 'cart                    SET id_address_delivery = 0                    WHERE id_address_delivery = ' . $this->id;        Db::getInstance()->execute($sql);        $sql = 'UPDATE ' . _DB_PREFIX_ . 'cart                    SET id_address_invoice = 0                    WHERE id_address_invoice = ' . $this->id;        Db::getInstance()->execute($sql);    }    /**     * Returns fields required for an address in an array hash.     *     * @return array Hash values     */    public static function getFieldsValidate()    {        $tmp_addr = new Address();        $out = $tmp_addr->fieldsValidate;        unset($tmp_addr);        return $out;    }    /**     * Get Zone ID for a given address.     *     * @param int $id_address Address ID for which we want to get the Zone ID     *     * @return int Zone ID     */    public static function getZoneById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        if (isset(self::$_idZones[$id_address])) {            return self::$_idZones[$id_address];        }        $id_zone = Hook::exec('actionGetIDZoneByAddressID', ['id_address' => $id_address]);        if (is_numeric($id_zone)) {            self::$_idZones[$id_address] = (int) $id_zone;            return self::$_idZones[$id_address];        }        $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT s.`id_zone` AS id_zone_state, c.`id_zone`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`LEFT JOIN `' . _DB_PREFIX_ . 'state` s ON s.`id_state` = a.`id_state`WHERE a.`id_address` = ' . (int) $id_address);        if (empty($result['id_zone_state']) && empty($result['id_zone'])) {            return false;        }        self::$_idZones[$id_address] = !empty($result['id_zone_state'])            ? (int) $result['id_zone_state']            : (int) $result['id_zone'];        return self::$_idZones[$id_address];    }    /**     * Check if the Country is active for a given address.     *     * @param int $id_address Address ID for which we want to get the Country status     *     * @return int Country status     */    public static function isCountryActiveById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        $cache_id = 'Address::isCountryActiveById_' . (int) $id_address;        if (!Cache::isStored($cache_id)) {            $result = (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT c.`active`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`WHERE a.`id_address` = ' . (int) $id_address);            Cache::store($cache_id, $result);            return $result;        }        return Cache::retrieve($cache_id);    }    /**     * {@inheritdoc}     */    public function validateField($field, $value, $id_lang = null, $skip = [], $human_errors = false)    {        $error = parent::validateField($field, $value, $id_lang, $skip, $human_errors);        if (true !== $error || 'dni' !== $field) {            return $error;        }        // Special validation for dni, check if the country needs it        if (!$this->deleted && static::dniRequired((int) $this->id_country) && Tools::isEmpty($value)) {            if ($human_errors) {                return $this->trans(                    'The %s field is required.',                    [$this->displayFieldName($field, get_class($this))],                    'Admin.Notifications.Error'                );            }            return $this->trans(                'Property %s is empty.',                [get_class($this) . '->' . $field],                'Admin.Notifications.Error'            );        }        return true;    }    /**     * Request to check if DNI field is required     * depending on the current selected country.     *     * @param int $idCountry     *     * @return bool     */    public static function dniRequired($idCountry)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT c.`need_identification_number` ' .            'FROM `' . _DB_PREFIX_ . 'country` c ' .            'WHERE c.`id_country` = ' . (int) $idCountry        );    }    /**     * Check if Address is used (at least one order placed).     *     * @return int Order count for this Address     */    public function isUsed()    {        if ((int) $this->id <= 0) {            return false;        }        $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT COUNT(`id_order`) AS usedFROM `' . _DB_PREFIX_ . 'orders`WHERE `id_address_delivery` = ' . (int) $this->id . 'OR `id_address_invoice` = ' . (int) $this->id);        return $result > 0 ? (int) $result : false;    }    /**     * Get Country and State of this Address.     *     * @param int $id_address Address ID     *     * @return array     */    public static function getCountryAndState($id_address)    {        if (isset(self::$_idCountries[$id_address])) {            return self::$_idCountries[$id_address];        }        if ($id_address) {            $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT `id_country`, `id_state`, `vat_number`, `postcode` FROM `' . _DB_PREFIX_ . 'address`WHERE `id_address` = ' . (int) $id_address);        } else {            $result = false;        }        self::$_idCountries[$id_address] = $result;        return $result;    }    /**     * Specify if an address is already in base.     *     * @param int $id_address Address id     *     * @return bool The address exists     */    public static function addressExists($id_address)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT `id_address`             FROM ' . _DB_PREFIX_ . 'address a             WHERE a.`id_address` = ' . (int) $id_address,            false        );    }    /**     * Check if the address is valid.     *     * @param int $id_address Address id     *     * @return bool The address is valid     */    public static function isValid($id_address)    {        $id_address = (int) $id_address;        $isValid = Db::getInstance()->getValue('            SELECT `id_address` FROM ' . _DB_PREFIX_ . 'address a            WHERE a.`id_address` = ' . $id_address . ' AND a.`deleted` = 0 AND a.`active` = 1        ');        return (bool) $isValid;    }    /**     * Get the first address id of the customer.     *     * @param int $id_customer Customer id     * @param bool $active Active addresses only     *     * @return bool|int|null     */    public static function getFirstCustomerAddressId($id_customer, $active = true)    {        if (!$id_customer) {            return false;        }        $cache_id = 'Address::getFirstCustomerAddressId_' . (int) $id_customer . '-' . (bool) $active;        if (!Cache::isStored($cache_id)) {            $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(                'SELECT `id_address`FROM `' . _DB_PREFIX_ . 'address`WHERE `id_customer` = ' . (int) $id_customer . ' AND `deleted` = 0' . ($active ? ' AND `active` = 1' : '')            );            Cache::store($cache_id, $result);            return $result;        }        return Cache::retrieve($cache_id);    }    /**     * Initialize an address corresponding to the specified id address or if empty to the     * default shop configuration.     *     * @param int $id_address     * @param bool $with_geoloc     *     * @return Address address     *     * @throws PrestaShopException     */    public static function initialize($id_address = null, $with_geoloc = false)    {        $context = Context::getContext();        if ($id_address) {            $context_hash = (int) $id_address;        } elseif ($with_geoloc && isset($context->customer->geoloc_id_country)) {            $context_hash = md5((int) $context->customer->geoloc_id_country . '-' . (int) $context->customer->id_state . '-' .                                $context->customer->postcode);        } else {            $context_hash = md5((int) $context->country->id);        }        $cache_id = 'Address::initialize_' . $context_hash;        if (!Cache::isStored($cache_id)) {            // if an id_address has been specified retrieve the address            if ($id_address) {                $address = new Address((int) $id_address);                if (!Validate::isLoadedObject($address)) {                    throw new PrestaShopException('Invalid address #' . (int) $id_address);                }            } elseif ($with_geoloc && isset($context->customer->geoloc_id_country)) {                $address = new Address();                $address->id_country = (int) $context->customer->geoloc_id_country;                $address->id_state = (int) $context->customer->id_state;                $address->postcode = $context->customer->postcode;            } elseif ((int) $context->country->id && ((int) $context->country->id != Configuration::get('PS_SHOP_COUNTRY_ID'))) {                $address = new Address();                $address->id_country = (int) $context->country->id;                $address->id_state = 0;                $address->postcode = 0;            } elseif ((int) Configuration::get('PS_SHOP_COUNTRY_ID')) {                // set the default address                $address = new Address();                $address->id_country = Configuration::get('PS_SHOP_COUNTRY_ID');                $address->id_state = Configuration::get('PS_SHOP_STATE_ID');                $address->postcode = Configuration::get('PS_SHOP_CODE');            } else {                // set the default address                $address = new Address();                $address->id_country = Configuration::get('PS_COUNTRY_DEFAULT');                $address->id_state = 0;                $address->postcode = 0;            }            Cache::store($cache_id, $address);            return $address;        }        return Cache::retrieve($cache_id);    }    /**     * Returns Address ID for a given Supplier ID.     *     * @since 1.5.0     *     * @param int $id_supplier Supplier ID     *     * @return int $id_address Address ID     */    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    }    /**     * Check if the alias already exists.     *     * @param string $alias Alias of an address     * @param int $id_address Address id     * @param int $id_customer Customer id     *     * @return false|string|null Amount of aliases found     * @todo: Find out if we shouldn't be returning an int instead? (breaking change)     */    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }    /**     * @see ObjectModel::getFieldsRequiredDB();     */    public function getFieldsRequiredDB()    {        return parent::getCachedFieldsRequiredDatabase();    }}",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
64,PrestaShop_PrestaShop_Address_786, Returns Address ID for a given Supplier ID.\\\\n\\\\n @since 1.5.0\\\\n\\\\n @param int $id_supplier Supplier ID\\\\n\\\\n @return int $id_address Address ID\\\\n,Vraća id adrese na osnovu id nabavljača,    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    },3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
65,PrestaShop_PrestaShop_Address_787, Check if the alias already exists.\\\\\\\\n\\\\\\\\n @param string $alias Alias of an address\\\\\\\\n @param int $id_address Address id\\\\\\\\n @param int $id_customer Customer id\\\\\\\\n\\\\\\\\n @return false|string|null Amount of aliases found\\\\\\\\n @todo: Find out if we shouldn't be returning an int instead? (breaking change)\\\\\\\\n,Proveri da li pseudonim postoji.,"    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
66,PHPOffice_PHPExcel_Cell_170,    Get cell value with formatting\\n\\n    @return    string\\n,Dohvati formatiranu vrednost ćelije.,"    public function getFormattedValue()    {        return (string) PHPExcel_Style_NumberFormat::toFormattedString(            $this->getCalculatedValue(),            $this->getStyle()                ->getNumberFormat()->getFormatCode()        );    }",0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
67,Maatwebsite_Laravel-Excel_QueuedViewExportTest_843, Setup the test environment.\\n,Podesi testno okruženje.,    protected function setUp(): void    {        parent::setUp();        $this->loadLaravelMigrations(['--database' => 'testing']);        $this->withFactories(__DIR__ . '/Data/Stubs/Database/Factories');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
68,Intervention_image_ImageServiceProviderLaravelRecent_519, Bootstrap imagecache\\n\\n @return void\\n,Pokreni imagecache.,"    protected function bootstrapImageCache()    {        $app = $this->app;        $config = __DIR__.'/../../../../imagecache/src/config/config.php';        $this->publishes([            $config => config_path('imagecache.php')        ]);        // merge default config        $this->mergeConfigFrom(            $config,            'imagecache'        );        // imagecache route        if (is_string(config('imagecache.route'))) {            $filename_pattern = '[ \w\\.\\/\\-\\@\(\)]+';            // route to access template applied image file            $app['router']->get(config('imagecache.route').'/{template}/{filename}', [                'uses' => 'Intervention\Image\ImageCacheController@getResponse',                'as' => 'imagecache'            ])->where(['filename' => $filename_pattern]);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
69,CachetHQ_Cachet_helpers_1161, Formats a date with the user timezone and the selected format.\n\n @param string $date\n\n @return \\Jenssegers\\Date\\Date\n,Formatiraj datum koristeći vremnsku zonu i izabrani format korisnika.,"    function formatted_date($date)    {        $dateFormat = Config::get('setting.date_format', 'jS F Y');        return (new Date($date))->format($dateFormat);    }",0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
70,symfony_debug_UndefinedMethodFatalErrorHandler_2285," ErrorHandler for undefined methods.\\n\\n @author GrÃ©goire Pineau <lyrixx@lyrixx.info>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\ErrorEnhancer\\\\UndefinedMethodErrorEnhancer instead.\\n",Rukovodilac greškama za nedefinisane metode.,"class UndefinedMethodFatalErrorHandler implements FatalErrorHandlerInterface{    /**     * {@inheritdoc}     */    public function handleError(array $error, FatalErrorException $exception)    {        preg_match('/^Call to undefined method (.*)::(.*)\(\)$/', $error['message'], $matches);        if (!$matches) {            return null;        }        $className = $matches[1];        $methodName = $matches[2];        $message = sprintf('Attempted to call an undefined method named ""%s"" of class ""%s"".', $methodName, $className);        if ('' === $methodName || !class_exists($className) || null === $methods = get_class_methods($className)) {            // failed to get the class or its methods on which an unknown method was called (for example on an anonymous class)            return new UndefinedMethodException($message, $exception);        }        $candidates = [];        foreach ($methods as $definedMethodName) {            $lev = levenshtein($methodName, $definedMethodName);            if ($lev <= \strlen($methodName) / 3 || false !== strpos($definedMethodName, $methodName)) {                $candidates[] = $definedMethodName;            }        }        if ($candidates) {            sort($candidates);            $last = array_pop($candidates).'""?';            if ($candidates) {                $candidates = 'e.g. ""'.implode('"", ""', $candidates).'"" or ""'.$last;            } else {                $candidates = '""'.$last;            }            $message .= ""\nDid you mean to call "".$candidates;        }        return new UndefinedMethodException($message, $exception);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
71,symfony_http-kernel_ControllerResolver_3124, This implementation uses the '_controller' request attribute to determine\n the controller to execute.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Tobias Schultze <http://tobion.de>\n,Implementacija klase koristi '_controller' atribut zahteva da bi odredio kontroler koji će se koristiti za izvršavanje.,"class ControllerResolver implements ControllerResolverInterface{    private $logger;    public function __construct(LoggerInterface $logger = null)    {        $this->logger = $logger;    }    /**     * {@inheritdoc}     */    public function getController(Request $request)    {        if (!$controller = $request->attributes->get('_controller')) {            if (null !== $this->logger) {                $this->logger->warning('Unable to look for the controller as the ""_controller"" parameter is missing.');            }            return false;        }        if (\is_array($controller)) {            if (isset($controller[0]) && \is_string($controller[0]) && isset($controller[1])) {                try {                    $controller[0] = $this->instantiateController($controller[0]);                } catch (\Error | \LogicException $e) {                    try {                        // We cannot just check is_callable but have to use reflection because a non-static method                        // can still be called statically in PHP but we don't want that. This is deprecated in PHP 7, so we                        // could simplify this with PHP 8.                        if ((new \ReflectionMethod($controller[0], $controller[1]))->isStatic()) {                            return $controller;                        }                    } catch (\ReflectionException $reflectionException) {                        throw $e;                    }                    throw $e;                }            }            if (!\is_callable($controller)) {                throw new \InvalidArgumentException(sprintf('The controller for URI ""%s"" is not callable: ', $request->getPathInfo()).$this->getControllerError($controller));            }            return $controller;        }        if (\is_object($controller)) {            if (!\is_callable($controller)) {                throw new \InvalidArgumentException(sprintf('The controller for URI ""%s"" is not callable: ', $request->getPathInfo()).$this->getControllerError($controller));            }            return $controller;        }        if (\function_exists($controller)) {            return $controller;        }        try {            $callable = $this->createController($controller);        } catch (\InvalidArgumentException $e) {            throw new \InvalidArgumentException(sprintf('The controller for URI ""%s"" is not callable: ', $request->getPathInfo()).$e->getMessage(), 0, $e);        }        if (!\is_callable($callable)) {            throw new \InvalidArgumentException(sprintf('The controller for URI ""%s"" is not callable: ', $request->getPathInfo()).$this->getControllerError($callable));        }        return $callable;    }    /**     * Returns a callable for the given controller.     *     * @return callable A PHP callable     *     * @throws \InvalidArgumentException When the controller cannot be created     */    protected function createController(string $controller)    {        if (false === strpos($controller, '::')) {            $controller = $this->instantiateController($controller);            if (!\is_callable($controller)) {                throw new \InvalidArgumentException($this->getControllerError($controller));            }            return $controller;        }        [$class, $method] = explode('::', $controller, 2);        try {            $controller = [$this->instantiateController($class), $method];        } catch (\Error | \LogicException $e) {            try {                if ((new \ReflectionMethod($class, $method))->isStatic()) {                    return $class.'::'.$method;                }            } catch (\ReflectionException $reflectionException) {                throw $e;            }            throw $e;        }        if (!\is_callable($controller)) {            throw new \InvalidArgumentException($this->getControllerError($controller));        }        return $controller;    }    /**     * Returns an instantiated controller.     *     * @return object     */    protected function instantiateController(string $class)    {        return new $class();    }    private function getControllerError($callable): string    {        if (\is_string($callable)) {            if (false !== strpos($callable, '::')) {                $callable = explode('::', $callable, 2);            } else {                return sprintf('Function ""%s"" does not exist.', $callable);            }        }        if (\is_object($callable)) {            $availableMethods = $this->getClassMethodsWithoutMagicMethods($callable);            $alternativeMsg = $availableMethods ? sprintf(' or use one of the available methods: ""%s""', implode('"", ""', $availableMethods)) : '';            return sprintf('Controller class ""%s"" cannot be called without a method name. You need to implement ""__invoke""%s.', get_debug_type($callable), $alternativeMsg);        }        if (!\is_array($callable)) {            return sprintf('Invalid type for controller given, expected string, array or object, got ""%s"".', get_debug_type($callable));        }        if (!isset($callable[0]) || !isset($callable[1]) || 2 !== \count($callable)) {            return 'Invalid array callable, expected [controller, method].';        }        [$controller, $method] = $callable;        if (\is_string($controller) && !class_exists($controller)) {            return sprintf('Class ""%s"" does not exist.', $controller);        }        $className = \is_object($controller) ? get_debug_type($controller) : $controller;        if (method_exists($controller, $method)) {            return sprintf('Method ""%s"" on class ""%s"" should be public and non-abstract.', $method, $className);        }        $collection = $this->getClassMethodsWithoutMagicMethods($controller);        $alternatives = [];        foreach ($collection as $item) {            $lev = levenshtein($method, $item);            if ($lev <= \strlen($method) / 3 || false !== strpos($item, $method)) {                $alternatives[] = $item;            }        }        asort($alternatives);        $message = sprintf('Expected method ""%s"" on class ""%s""', $method, $className);        if (\count($alternatives) > 0) {            $message .= sprintf(', did you mean ""%s""?', implode('"", ""', $alternatives));        } else {            $message .= sprintf('. Available methods: ""%s"".', implode('"", ""', $collection));        }        return $message;    }    private function getClassMethodsWithoutMagicMethods($classOrObject): array    {        $methods = get_class_methods($classOrObject);        return array_filter($methods, function (string $method) {            return 0 !== strncmp($method, '__', 2);        });    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
72,markrogoyski_math-php_ArbitraryInteger_2897, Convert ArbitraryInteger to an int\n\n @return int\n,Konvertuj ArbitraryInteger u int,    public function toInt(): int    {        $number      = \str_split(\strrev($this->base256));        $place_value = 1;        $int         = \ord($number[0]);        unset($number[0]);        foreach ($number as $digit) {            $place_value *= 256;            $int         += \ord($digit) * $place_value;        }        return $int * ($this->isPositive ? 1 : -1);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
73,symfony_polyfill-mbstring_Mbstring_741," Partial mbstring implementation in PHP, iconv based, UTF-8 centric.\n\n Implemented:\n - mb_chr                  - Returns a specific character from its Unicode code point\n - mb_convert_encoding     - Convert character encoding\n - mb_convert_variables    - Convert character code in variable(s)\n - mb_decode_mimeheader    - Decode string in MIME header field\n - mb_encode_mimeheader    - Encode string for MIME header XXX NATIVE IMPLEMENTATION IS REALLY BUGGED\n - mb_decode_numericentity - Decode HTML numeric string reference to character\n - mb_encode_numericentity - Encode character to HTML numeric string reference\n - mb_convert_case         - Perform case folding on a string\n - mb_detect_encoding      - Detect character encoding\n - mb_get_info             - Get internal settings of mbstring\n - mb_http_input           - Detect HTTP input character encoding\n - mb_http_output          - Set/Get HTTP output character encoding\n - mb_internal_encoding    - Set/Get internal character encoding\n - mb_list_encodings       - Returns an array of all supported encodings\n - mb_ord                  - Returns the Unicode code point of a character\n - mb_output_handler       - Callback function converts character encoding in output buffer\n - mb_scrub                - Replaces ill-formed byte sequences with substitute characters\n - mb_strlen               - Get string length\n - mb_strpos               - Find position of first occurrence of string in a string\n - mb_strrpos              - Find position of last occurrence of a string in a string\n - mb_str_split            - Convert a string to an array\n - mb_strtolower           - Make a string lowercase\n - mb_strtoupper           - Make a string uppercase\n - mb_substitute_character - Set/Get substitution character\n - mb_substr               - Get part of string\n - mb_stripos              - Finds position of first occurrence of a string within another, case insensitive\n - mb_stristr              - Finds first occurrence of a string within another, case insensitive\n - mb_strrchr              - Finds the last occurrence of a character in a string within another\n - mb_strrichr             - Finds the last occurrence of a character in a string within another, case insensitive\n - mb_strripos             - Finds position of last occurrence of a string within another, case insensitive\n - mb_strstr               - Finds first occurrence of a string within another\n - mb_strwidth             - Return width of string\n - mb_substr_count         - Count the number of substring occurrences\n\n Not implemented:\n - mb_convert_kana         - Convert ""kana"" one from another (""zen-kaku"", ""han-kaku"" and more)\n - mb_ereg_ - mb_parse_str            - Parse GET/POST/COOKIE data and set global variable\n - mb_preferred_mime_name  - Get MIME charset string\n - mb_regex_encoding       - Returns current encoding for multibyte regex as string\n - mb_regex_set_options    - Set/Get the default options for mbregex functions\n - mb_send_mail            - Send encoded mail\n - mb_split                - Split multibyte string using regular expression\n - mb_strcut               - Get part of string\n - mb_strimwidth           - Get truncated string with specified width\n\n @author Nicolas Grekas <p@tchwork.com>\n\n @internal\n","Parcijalna implementacija mbstring-a u PHP-u, zasnovana na iconv a usredsređena na UTF-8. Implementirano je sledeće: mb_chr - vraća određen znak sa njegove Unicode kodne tačke. mb_convert_encoding - konvertuj šifrirane karaktere. mb_convert_variables    - Pretvori karaktere promenljivih u kodu. mb_decode_mimeheader    - Dekodiraj string u polju MIME zaglavlja. mb_encode_mimeheader    - Kodiraj string za MIME zaglavlje. mb_decode_numericentity - Dešifruj HTML numeričku string referencu u karakter.mb_encode_numericentity - Kodiraj znak u HTML numeričku string referencu. mb_convert_case - Pronađi preklapanja u stringu. mb_detect_encoding - Detektuj kodirane znakove. mb_get_info - Dohvati podešavanje za interval mbstringa. mb_http_input - Detektuj šifrovani ulazni http karakter. mb_http_output - Postavi / Dohvati šifrovan izlazni http karakter. mb_internal_encoding - Postavi / Dohvati šifrovan ulazni http karakter. mb_list_encodings - Vrati niz svih podržanih šifrovanja. mb_ord - Vrati Unicode kodnu tačku za karakter. mb_output_handler - Funkcija povratnog poziva koja pretvara kodirannje karaktera u izlazni bafer. mb_scrub - zamenjuje loše odlikovane sekvence bajtova zamenskim znakovima. mb_strlen - Dohvati dužinu niza. mb_strpos - Pronađite položaj prvog pojavljivanja reči u stringu. mb_strrpos - Pronađite položaj zadnjeg pojavljivanja reči u stringu. mb_str_split - Pretvori string u niz stringova. mb_strtolower - Smanji sva slova u stringu. mb_strtoupper - Uvećaj sva slova u stringu. mb_substitute_character - Postavi / Dohvati zamenske karaktere. mb_substr - Dohvati deo stringa. mb_stripos - Pronalazi položaj prvog pojavljivanja stringa u drugom, nerazlikujući velika i mala slova. mb_stristr - Pronalazi prvo pojavljivanje stringa u drugom, nerazlikujući velika i mala slova. mb_strrchr - Pronalazi poslednje pojavljivanje karaktera u stringu unutar drugog stringa. mb_strrichr - Pronalazi poslednju pojavu znaka pri traženju stringa u okviru stringa ne razlikujući velika i mala slova. mb_strripos - Pronalazi poslednju poziciju znaka pri traženju stringa u okviru stringa ne razlikujući velika i mala slova. mb_strstr - Pronalazi prvu pojavu stringa u okviru drugog. mb_strwidth - Vraća dužinu stringa. mb_substr_count - Prebroj broj pojavljivanja substringova. Nije implementirano:  mb_convert_kana - Konvertuj ""kana"" iz drugog (""zen-kaku"", ""han-kaku"" and drugih). mb_ereg_* - Regularna izraz sa podrškom više bajtova. mb_parse_str - Analizirati GET/POST/COOKIE podatke i postaviti globalne varijable. mb_preferred_mime_name - Dohvati MIME niz znakoga. mb_regex_encoding - Vrati sadašnje kodiranje za višebajtni regularni izraz u stringu. mb_regex_set_options    - Postavi / Dohvati podrazumevane opcije za mbregex funkcije. mb_send_mail - Pošalji šifrovan mail. mb_split - Podeli višebajtne stringove koristeći regulare izraze. mb_strcut - Dohvati deo stringa. mb_strimwidth - Dohvati skraćeni niz sa naznačenom širinom.","final class Mbstring{    public const MB_CASE_FOLD = \PHP_INT_MAX;    private const CASE_FOLD = [        ['Âµ', 'Å¿', ""\xCD\x85"", 'Ï‚', ""\xCF\x90"", ""\xCF\x91"", ""\xCF\x95"", ""\xCF\x96"", ""\xCF\xB0"", ""\xCF\xB1"", ""\xCF\xB5"", ""\xE1\xBA\x9B"", ""\xE1\xBE\xBE""],        ['Î¼', 's', 'Î¹',        'Ïƒ', 'Î²',        'Î¸',        'Ï†',        'Ï€',        'Îº',        'Ï',        'Îµ',        ""\xE1\xB9\xA1"", 'Î¹'],    ];    private static $encodingList = ['ASCII', 'UTF-8'];    private static $language = 'neutral';    private static $internalEncoding = 'UTF-8';    public static function mb_convert_encoding($s, $toEncoding, $fromEncoding = null)    {        if (\is_array($fromEncoding) || false !== strpos($fromEncoding, ',')) {            $fromEncoding = self::mb_detect_encoding($s, $fromEncoding);        } else {            $fromEncoding = self::getEncoding($fromEncoding);        }        $toEncoding = self::getEncoding($toEncoding);        if ('BASE64' === $fromEncoding) {            $s = base64_decode($s);            $fromEncoding = $toEncoding;        }        if ('BASE64' === $toEncoding) {            return base64_encode($s);        }        if ('HTML-ENTITIES' === $toEncoding || 'HTML' === $toEncoding) {            if ('HTML-ENTITIES' === $fromEncoding || 'HTML' === $fromEncoding) {                $fromEncoding = 'Windows-1252';            }            if ('UTF-8' !== $fromEncoding) {                $s = \iconv($fromEncoding, 'UTF-8//IGNORE', $s);            }            return preg_replace_callback('/[\x80-\xFF]+/', [__CLASS__, 'html_encoding_callback'], $s);        }        if ('HTML-ENTITIES' === $fromEncoding) {            $s = html_entity_decode($s, \ENT_COMPAT, 'UTF-8');            $fromEncoding = 'UTF-8';        }        return \iconv($fromEncoding, $toEncoding.'//IGNORE', $s);    }    public static function mb_convert_variables($toEncoding, $fromEncoding, &...$vars)    {        $ok = true;        array_walk_recursive($vars, function (&$v) use (&$ok, $toEncoding, $fromEncoding) {            if (false === $v = self::mb_convert_encoding($v, $toEncoding, $fromEncoding)) {                $ok = false;            }        });        return $ok ? $fromEncoding : false;    }    public static function mb_decode_mimeheader($s)    {        return \iconv_mime_decode($s, 2, self::$internalEncoding);    }    public static function mb_encode_mimeheader($s, $charset = null, $transferEncoding = null, $linefeed = null, $indent = null)    {        trigger_error('mb_encode_mimeheader() is bugged. Please use iconv_mime_encode() instead', \E_USER_WARNING);    }    public static function mb_decode_numericentity($s, $convmap, $encoding = null)    {        if (null !== $s && !is_scalar($s) && !(\is_object($s) && method_exists($s, '__toString'))) {            trigger_error('mb_decode_numericentity() expects parameter 1 to be string, '.\gettype($s).' given', \E_USER_WARNING);            return null;        }        if (!\is_array($convmap) || (80000 > \PHP_VERSION_ID && !$convmap)) {            return false;        }        if (null !== $encoding && !is_scalar($encoding)) {            trigger_error('mb_decode_numericentity() expects parameter 3 to be string, '.\gettype($s).' given', \E_USER_WARNING);            return '';  // Instead of null (cf. mb_encode_numericentity).        }        $s = (string) $s;        if ('' === $s) {            return '';        }        $encoding = self::getEncoding($encoding);        if ('UTF-8' === $encoding) {            $encoding = null;            if (!preg_match('//u', $s)) {                $s = @\iconv('UTF-8', 'UTF-8//IGNORE', $s);            }        } else {            $s = \iconv($encoding, 'UTF-8//IGNORE', $s);        }        $cnt = floor(\count($convmap) / 4) * 4;        for ($i = 0; $i < $cnt; $i += 4) {            // collector_decode_htmlnumericentity ignores $convmap[$i + 3]            $convmap[$i] += $convmap[$i + 2];            $convmap[$i + 1] += $convmap[$i + 2];        }        $s = preg_replace_callback('/&#(?:0*([0-9]+)|x0*([0-9a-fA-F]+))(?!&);?/', function (array $m) use ($cnt, $convmap) {            $c = isset($m[2]) ? (int) hexdec($m[2]) : $m[1];            for ($i = 0; $i < $cnt; $i += 4) {                if ($c >= $convmap[$i] && $c <= $convmap[$i + 1]) {                    return self::mb_chr($c - $convmap[$i + 2]);                }            }            return $m[0];        }, $s);        if (null === $encoding) {            return $s;        }        return \iconv('UTF-8', $encoding.'//IGNORE', $s);    }    public static function mb_encode_numericentity($s, $convmap, $encoding = null, $is_hex = false)    {        if (null !== $s && !is_scalar($s) && !(\is_object($s) && method_exists($s, '__toString'))) {            trigger_error('mb_encode_numericentity() expects parameter 1 to be string, '.\gettype($s).' given', \E_USER_WARNING);            return null;        }        if (!\is_array($convmap) || (80000 > \PHP_VERSION_ID && !$convmap)) {            return false;        }        if (null !== $encoding && !is_scalar($encoding)) {            trigger_error('mb_encode_numericentity() expects parameter 3 to be string, '.\gettype($s).' given', \E_USER_WARNING);            return null;  // Instead of '' (cf. mb_decode_numericentity).        }        if (null !== $is_hex && !is_scalar($is_hex)) {            trigger_error('mb_encode_numericentity() expects parameter 4 to be boolean, '.\gettype($s).' given', \E_USER_WARNING);            return null;        }        $s = (string) $s;        if ('' === $s) {            return '';        }        $encoding = self::getEncoding($encoding);        if ('UTF-8' === $encoding) {            $encoding = null;            if (!preg_match('//u', $s)) {                $s = @\iconv('UTF-8', 'UTF-8//IGNORE', $s);            }        } else {            $s = \iconv($encoding, 'UTF-8//IGNORE', $s);        }        static $ulenMask = [""\xC0"" => 2, ""\xD0"" => 2, ""\xE0"" => 3, ""\xF0"" => 4];        $cnt = floor(\count($convmap) / 4) * 4;        $i = 0;        $len = \strlen($s);        $result = '';        while ($i < $len) {            $ulen = $s[$i] < ""\x80"" ? 1 : $ulenMask[$s[$i] & ""\xF0""];            $uchr = substr($s, $i, $ulen);            $i += $ulen;            $c = self::mb_ord($uchr);            for ($j = 0; $j < $cnt; $j += 4) {                if ($c >= $convmap[$j] && $c <= $convmap[$j + 1]) {                    $cOffset = ($c + $convmap[$j + 2]) & $convmap[$j + 3];                    $result .= $is_hex ? sprintf('&#x%X;', $cOffset) : '&#'.$cOffset.';';                    continue 2;                }            }            $result .= $uchr;        }        if (null === $encoding) {            return $result;        }        return \iconv('UTF-8', $encoding.'//IGNORE', $result);    }    public static function mb_convert_case($s, $mode, $encoding = null)    {        $s = (string) $s;        if ('' === $s) {            return '';        }        $encoding = self::getEncoding($encoding);        if ('UTF-8' === $encoding) {            $encoding = null;            if (!preg_match('//u', $s)) {                $s = @\iconv('UTF-8', 'UTF-8//IGNORE', $s);            }        } else {            $s = \iconv($encoding, 'UTF-8//IGNORE', $s);        }        if (\MB_CASE_TITLE == $mode) {            static $titleRegexp = null;            if (null === $titleRegexp) {                $titleRegexp = self::getData('titleCaseRegexp');            }            $s = preg_replace_callback($titleRegexp, [__CLASS__, 'title_case'], $s);        } else {            if (\MB_CASE_UPPER == $mode) {                static $upper = null;                if (null === $upper) {                    $upper = self::getData('upperCase');                }                $map = $upper;            } else {                if (self::MB_CASE_FOLD === $mode) {                    $s = str_replace(self::CASE_FOLD[0], self::CASE_FOLD[1], $s);                }                static $lower = null;                if (null === $lower) {                    $lower = self::getData('lowerCase');                }                $map = $lower;            }            static $ulenMask = [""\xC0"" => 2, ""\xD0"" => 2, ""\xE0"" => 3, ""\xF0"" => 4];            $i = 0;            $len = \strlen($s);            while ($i < $len) {                $ulen = $s[$i] < ""\x80"" ? 1 : $ulenMask[$s[$i] & ""\xF0""];                $uchr = substr($s, $i, $ulen);                $i += $ulen;                if (isset($map[$uchr])) {                    $uchr = $map[$uchr];                    $nlen = \strlen($uchr);                    if ($nlen == $ulen) {                        $nlen = $i;                        do {                            $s[--$nlen] = $uchr[--$ulen];                        } while ($ulen);                    } else {                        $s = substr_replace($s, $uchr, $i - $ulen, $ulen);                        $len += $nlen - $ulen;                        $i += $nlen - $ulen;                    }                }            }        }        if (null === $encoding) {            return $s;        }        return \iconv('UTF-8', $encoding.'//IGNORE', $s);    }    public static function mb_internal_encoding($encoding = null)    {        if (null === $encoding) {            return self::$internalEncoding;        }        $normalizedEncoding = self::getEncoding($encoding);        if ('UTF-8' === $normalizedEncoding || false !== @\iconv($normalizedEncoding, $normalizedEncoding, ' ')) {            self::$internalEncoding = $normalizedEncoding;            return true;        }        if (80000 > \PHP_VERSION_ID) {            return false;        }        throw new \ValueError(sprintf('Argument #1 ($encoding) must be a valid encoding, ""%s"" given', $encoding));    }    public static function mb_language($lang = null)    {        if (null === $lang) {            return self::$language;        }        switch ($normalizedLang = strtolower($lang)) {            case 'uni':            case 'neutral':                self::$language = $normalizedLang;                return true;        }        if (80000 > \PHP_VERSION_ID) {            return false;        }        throw new \ValueError(sprintf('Argument #1 ($language) must be a valid language, ""%s"" given', $lang));    }    public static function mb_list_encodings()    {        return ['UTF-8'];    }    public static function mb_encoding_aliases($encoding)    {        switch (strtoupper($encoding)) {            case 'UTF8':            case 'UTF-8':                return ['utf8'];        }        return false;    }    public static function mb_check_encoding($var = null, $encoding = null)    {        if (null === $encoding) {            if (null === $var) {                return false;            }            $encoding = self::$internalEncoding;        }        return self::mb_detect_encoding($var, [$encoding]) || false !== @\iconv($encoding, $encoding, $var);    }    public static function mb_detect_encoding($str, $encodingList = null, $strict = false)    {        if (null === $encodingList) {            $encodingList = self::$encodingList;        } else {            if (!\is_array($encodingList)) {                $encodingList = array_map('trim', explode(',', $encodingList));            }            $encodingList = array_map('strtoupper', $encodingList);        }        foreach ($encodingList as $enc) {            switch ($enc) {                case 'ASCII':                    if (!preg_match('/[\x80-\xFF]/', $str)) {                        return $enc;                    }                    break;                case 'UTF8':                case 'UTF-8':                    if (preg_match('//u', $str)) {                        return 'UTF-8';                    }                    break;                default:                    if (0 === strncmp($enc, 'ISO-8859-', 9)) {                        return $enc;                    }            }        }        return false;    }    public static function mb_detect_order($encodingList = null)    {        if (null === $encodingList) {            return self::$encodingList;        }        if (!\is_array($encodingList)) {            $encodingList = array_map('trim', explode(',', $encodingList));        }        $encodingList = array_map('strtoupper', $encodingList);        foreach ($encodingList as $enc) {            switch ($enc) {                default:                    if (strncmp($enc, 'ISO-8859-', 9)) {                        return false;                    }                    // no break                case 'ASCII':                case 'UTF8':                case 'UTF-8':            }        }        self::$encodingList = $encodingList;        return true;    }    public static function mb_strlen($s, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            return \strlen($s);        }        return @\iconv_strlen($s, $encoding);    }    public static function mb_strpos($haystack, $needle, $offset = 0, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            return strpos($haystack, $needle, $offset);        }        $needle = (string) $needle;        if ('' === $needle) {            if (80000 > \PHP_VERSION_ID) {                trigger_error(__METHOD__.': Empty delimiter', \E_USER_WARNING);                return false;            }            return 0;        }        return \iconv_strpos($haystack, $needle, $offset, $encoding);    }    public static function mb_strrpos($haystack, $needle, $offset = 0, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            return strrpos($haystack, $needle, $offset);        }        if ($offset != (int) $offset) {            $offset = 0;        } elseif ($offset = (int) $offset) {            if ($offset < 0) {                if (0 > $offset += self::mb_strlen($needle)) {                    $haystack = self::mb_substr($haystack, 0, $offset, $encoding);                }                $offset = 0;            } else {                $haystack = self::mb_substr($haystack, $offset, 2147483647, $encoding);            }        }        $pos = '' !== $needle || 80000 > \PHP_VERSION_ID            ? \iconv_strrpos($haystack, $needle, $encoding)            : self::mb_strlen($haystack, $encoding);        return false !== $pos ? $offset + $pos : false;    }    public static function mb_str_split($string, $split_length = 1, $encoding = null)    {        if (null !== $string && !is_scalar($string) && !(\is_object($string) && method_exists($string, '__toString'))) {            trigger_error('mb_str_split() expects parameter 1 to be string, '.\gettype($string).' given', \E_USER_WARNING);            return null;        }        if (1 > $split_length = (int) $split_length) {            if (80000 > \PHP_VERSION_ID) {                trigger_error('The length of each segment must be greater than zero', \E_USER_WARNING);                return false;            }            throw new \ValueError('Argument #2 ($length) must be greater than 0');        }        if (null === $encoding) {            $encoding = mb_internal_encoding();        }        if ('UTF-8' === $encoding = self::getEncoding($encoding)) {            $rx = '/(';            while (65535 < $split_length) {                $rx .= '.{65535}';                $split_length -= 65535;            }            $rx .= '.{'.$split_length.'})/us';            return preg_split($rx, $string, null, \PREG_SPLIT_DELIM_CAPTURE | \PREG_SPLIT_NO_EMPTY);        }        $result = [];        $length = mb_strlen($string, $encoding);        for ($i = 0; $i < $length; $i += $split_length) {            $result[] = mb_substr($string, $i, $split_length, $encoding);        }        return $result;    }    public static function mb_strtolower($s, $encoding = null)    {        return self::mb_convert_case($s, \MB_CASE_LOWER, $encoding);    }    public static function mb_strtoupper($s, $encoding = null)    {        return self::mb_convert_case($s, \MB_CASE_UPPER, $encoding);    }    public static function mb_substitute_character($c = null)    {        if (null === $c) {            return 'none';        }        if (0 === strcasecmp($c, 'none')) {            return true;        }        if (80000 > \PHP_VERSION_ID) {            return false;        }        throw new \ValueError('Argument #1 ($substitute_character) must be ""none"", ""long"", ""entity"" or a valid codepoint');    }    public static function mb_substr($s, $start, $length = null, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            return (string) substr($s, $start, null === $length ? 2147483647 : $length);        }        if ($start < 0) {            $start = \iconv_strlen($s, $encoding) + $start;            if ($start < 0) {                $start = 0;            }        }        if (null === $length) {            $length = 2147483647;        } elseif ($length < 0) {            $length = \iconv_strlen($s, $encoding) + $length - $start;            if ($length < 0) {                return '';            }        }        return (string) \iconv_substr($s, $start, $length, $encoding);    }    public static function mb_stripos($haystack, $needle, $offset = 0, $encoding = null)    {        $haystack = self::mb_convert_case($haystack, self::MB_CASE_FOLD, $encoding);        $needle = self::mb_convert_case($needle, self::MB_CASE_FOLD, $encoding);        return self::mb_strpos($haystack, $needle, $offset, $encoding);    }    public static function mb_stristr($haystack, $needle, $part = false, $encoding = null)    {        $pos = self::mb_stripos($haystack, $needle, 0, $encoding);        return self::getSubpart($pos, $part, $haystack, $encoding);    }    public static function mb_strrchr($haystack, $needle, $part = false, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('CP850' === $encoding || 'ASCII' === $encoding) {            $pos = strrpos($haystack, $needle);        } else {            $needle = self::mb_substr($needle, 0, 1, $encoding);            $pos = \iconv_strrpos($haystack, $needle, $encoding);        }        return self::getSubpart($pos, $part, $haystack, $encoding);    }    public static function mb_strrichr($haystack, $needle, $part = false, $encoding = null)    {        $needle = self::mb_substr($needle, 0, 1, $encoding);        $pos = self::mb_strripos($haystack, $needle, $encoding);        return self::getSubpart($pos, $part, $haystack, $encoding);    }    public static function mb_strripos($haystack, $needle, $offset = 0, $encoding = null)    {        $haystack = self::mb_convert_case($haystack, self::MB_CASE_FOLD, $encoding);        $needle = self::mb_convert_case($needle, self::MB_CASE_FOLD, $encoding);        return self::mb_strrpos($haystack, $needle, $offset, $encoding);    }    public static function mb_strstr($haystack, $needle, $part = false, $encoding = null)    {        $pos = strpos($haystack, $needle);        if (false === $pos) {            return false;        }        if ($part) {            return substr($haystack, 0, $pos);        }        return substr($haystack, $pos);    }    public static function mb_get_info($type = 'all')    {        $info = [            'internal_encoding' => self::$internalEncoding,            'http_output' => 'pass',            'http_output_conv_mimetypes' => '^(text/|application/xhtml\+xml)',            'func_overload' => 0,            'func_overload_list' => 'no overload',            'mail_charset' => 'UTF-8',            'mail_header_encoding' => 'BASE64',            'mail_body_encoding' => 'BASE64',            'illegal_chars' => 0,            'encoding_translation' => 'Off',            'language' => self::$language,            'detect_order' => self::$encodingList,            'substitute_character' => 'none',            'strict_detection' => 'Off',        ];        if ('all' === $type) {            return $info;        }        if (isset($info[$type])) {            return $info[$type];        }        return false;    }    public static function mb_http_input($type = '')    {        return false;    }    public static function mb_http_output($encoding = null)    {        return null !== $encoding ? 'pass' === $encoding : 'pass';    }    public static function mb_strwidth($s, $encoding = null)    {        $encoding = self::getEncoding($encoding);        if ('UTF-8' !== $encoding) {            $s = \iconv($encoding, 'UTF-8//IGNORE', $s);        }        $s = preg_replace('/[\x{1100}-\x{115F}\x{2329}\x{232A}\x{2E80}-\x{303E}\x{3040}-\x{A4CF}\x{AC00}-\x{D7A3}\x{F900}-\x{FAFF}\x{FE10}-\x{FE19}\x{FE30}-\x{FE6F}\x{FF00}-\x{FF60}\x{FFE0}-\x{FFE6}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}]/u', '', $s, -1, $wide);        return ($wide << 1) + \iconv_strlen($s, 'UTF-8');    }    public static function mb_substr_count($haystack, $needle, $encoding = null)    {        return substr_count($haystack, $needle);    }    public static function mb_output_handler($contents, $status)    {        return $contents;    }    public static function mb_chr($code, $encoding = null)    {        if (0x80 > $code %= 0x200000) {            $s = \chr($code);        } elseif (0x800 > $code) {            $s = \chr(0xC0 | $code >> 6).\chr(0x80 | $code & 0x3F);        } elseif (0x10000 > $code) {            $s = \chr(0xE0 | $code >> 12).\chr(0x80 | $code >> 6 & 0x3F).\chr(0x80 | $code & 0x3F);        } else {            $s = \chr(0xF0 | $code >> 18).\chr(0x80 | $code >> 12 & 0x3F).\chr(0x80 | $code >> 6 & 0x3F).\chr(0x80 | $code & 0x3F);        }        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {            $s = mb_convert_encoding($s, $encoding, 'UTF-8');        }        return $s;    }    public static function mb_ord($s, $encoding = null)    {        if ('UTF-8' !== $encoding = self::getEncoding($encoding)) {            $s = mb_convert_encoding($s, 'UTF-8', $encoding);        }        if (1 === \strlen($s)) {            return \ord($s);        }        $code = ($s = unpack('C*', substr($s, 0, 4))) ? $s[1] : 0;        if (0xF0 <= $code) {            return (($code - 0xF0) << 18) + (($s[2] - 0x80) << 12) + (($s[3] - 0x80) << 6) + $s[4] - 0x80;        }        if (0xE0 <= $code) {            return (($code - 0xE0) << 12) + (($s[2] - 0x80) << 6) + $s[3] - 0x80;        }        if (0xC0 <= $code) {            return (($code - 0xC0) << 6) + $s[2] - 0x80;        }        return $code;    }    private static function getSubpart($pos, $part, $haystack, $encoding)    {        if (false === $pos) {            return false;        }        if ($part) {            return self::mb_substr($haystack, 0, $pos, $encoding);        }        return self::mb_substr($haystack, $pos, null, $encoding);    }    private static function html_encoding_callback(array $m)    {        $i = 1;        $entities = '';        $m = unpack('C*', htmlentities($m[0], \ENT_COMPAT, 'UTF-8'));        while (isset($m[$i])) {            if (0x80 > $m[$i]) {                $entities .= \chr($m[$i++]);                continue;            }            if (0xF0 <= $m[$i]) {                $c = (($m[$i++] - 0xF0) << 18) + (($m[$i++] - 0x80) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;            } elseif (0xE0 <= $m[$i]) {                $c = (($m[$i++] - 0xE0) << 12) + (($m[$i++] - 0x80) << 6) + $m[$i++] - 0x80;            } else {                $c = (($m[$i++] - 0xC0) << 6) + $m[$i++] - 0x80;            }            $entities .= '&#'.$c.';';        }        return $entities;    }    private static function title_case(array $s)    {        return self::mb_convert_case($s[1], \MB_CASE_UPPER, 'UTF-8').self::mb_convert_case($s[2], \MB_CASE_LOWER, 'UTF-8');    }    private static function getData($file)    {        if (file_exists($file = __DIR__.'/Resources/unidata/'.$file.'.php')) {            return require $file;        }        return false;    }    private static function getEncoding($encoding)    {        if (null === $encoding) {            return self::$internalEncoding;        }        if ('UTF-8' === $encoding) {            return 'UTF-8';        }        $encoding = strtoupper($encoding);        if ('8BIT' === $encoding || 'BINARY' === $encoding) {            return 'CP850';        }        if ('UTF8' === $encoding) {            return 'UTF-8';        }        return $encoding;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
74,BookStackApp_BookStack_2014_10_12_100000_create_password_resets_table_763, Run the migrations.\n\n @return void\n,Pokreni migraciju,"    public function up()    {        Schema::create('password_resets', function (Blueprint $table) {            $table->string('email')->index();            $table->string('token')->index();            $table->timestamp('created_at');        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
75,BookStackApp_BookStack_2015_07_12_114933_create_books_table_766, Reverse the migrations.\n\n @return void\n,Poništi migracije,    public function down()    {        Schema::drop('books');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
76,BookStackApp_BookStack_2015_07_13_172121_create_images_table_769, Run the migrations.\n\n @return void\n,Pokreni migraciju,"    public function up()    {        Schema::create('images', function (Blueprint $table) {            $table->increments('id');            $table->string('name');            $table->string('url');            $table->nullableTimestamps();        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
77,BookStackApp_BookStack_2015_07_13_172121_create_images_table_770, Reverse the migrations.\n\n @return void\n,Poništi migracije,    public function down()    {        Schema::drop('images');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
78,BookStackApp_BookStack_2015_07_27_172342_create_chapters_table_772, Reverse the migrations.\n\n @return void\n,Poništi migracije,    public function down()    {        Schema::drop('chapters');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
79,BookStackApp_BookStack_2015_08_09_093534_create_page_revisions_table_775, Run the migrations.\n\n @return void\n,Pokreni migraciju,"    public function up()    {        Schema::create('page_revisions', function (Blueprint $table) {            $table->increments('id');            $table->integer('page_id')->indexed();            $table->string('name');            $table->longText('html');            $table->longText('text');            $table->integer('created_by');            $table->nullableTimestamps();        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
80,BookStackApp_BookStack_ActivityService_741, Removes the entity attachment from each of its activities\n and instead uses the 'extra' field with the entities name.\n Used when an entity is deleted.\n,Ukloni entitet dodatak svakom aktivitiju koji ga poseduje i umesto njega koristi polje 'extra' sa imenom entiteta. Koristi se kada je entiti izbrisan.,"    public function removeEntity(Entity $entity)    {        $entity->activity()->update([            'detail'       => $entity->name,            'entity_id'   => null,            'entity_type' => null,        ]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
81,BookStackApp_BookStack_Activity_735, Get the user this activity relates to.\n,Dohvatanje korisnika koji se odnosi na dati aktiviti.,    public function user(): BelongsTo    {        return $this->belongsTo(User::class);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
82,BookStackApp_BookStack_Activity_737, Check if this activity is intended to be for an entity.\n,Proveri da li je ovaj aktiviti namenjen nekom entitetu. ,"    public function isForEntity(): bool    {        return Str::startsWith($this->type, [            'page_', 'chapter_', 'book_', 'bookshelf_'        ]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
83,BookStackApp_BookStack_BrowserKitTest_785, Check if the page contains the given element.\n @param  string  $selector\n,Proveri da li stranica sadrži dati element.,"    protected function pageNotHasElement($selector)    {        $elements = $this->crawler->filter($selector);        $this->assertFalse(count($elements) > 0, ""The page contains "" . count($elements) . "" elements matching "" . $selector);        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
84,BookStackApp_BookStack_CreatesApplication_786, Creates the application.\n\n @return \\Illuminate\\Foundation\\Application\n,Kreiraj aplikaciju.,    public function createApplication()    {        $app = require __DIR__.'/../bootstrap/app.php';        $app->make(Kernel::class)->bootstrap();        return $app;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
85,BookStackApp_BookStack_Tag_759, Get a full URL to start a tag name search for this tag name.\n,Dohvatati te punu URL adresu da biste započeli pretragu imena oznake za daiti naziv oznake. ,    public function nameUrl(): string    {        return url('/search?term=%5B' . urlencode($this->name) .'%5D');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
86,blueimp_jQuery-File-Upload_UploadHandler_1," jQuery File Upload Plugin PHP Class\\n https://github.com/blueimp/jQuery-File-Upload\\n\\n Copyright 2010, Sebastian Tschan\\n https://blueimp.net\\n\\n Licensed under the MIT license:\\n https://opensource.org/licenses/MIT\\n",JQuery dodatak za odpremanje datoteka,"class UploadHandler  {        protected $options;        // PHP File Upload error message codes:      // https://php.net/manual/en/features.file-upload.errors.php      protected $error_messages = array(          1 => 'The uploaded file exceeds the upload_max_filesize directive in php.ini',          2 => 'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form',          3 => 'The uploaded file was only partially uploaded',          4 => 'No file was uploaded',          6 => 'Missing a temporary folder',          7 => 'Failed to write file to disk',          8 => 'A PHP extension stopped the file upload',          'post_max_size' => 'The uploaded file exceeds the post_max_size directive in php.ini',          'max_file_size' => 'File is too big',          'min_file_size' => 'File is too small',          'accept_file_types' => 'Filetype not allowed',          'max_number_of_files' => 'Maximum number of files exceeded',          'invalid_file_type' => 'Invalid file type',          'max_width' => 'Image exceeds maximum width',          'min_width' => 'Image requires a minimum width',          'max_height' => 'Image exceeds maximum height',          'min_height' => 'Image requires a minimum height',          'abort' => 'File upload aborted',          'image_resize' => 'Failed to resize image'      );        const IMAGETYPE_GIF = 'image/gif';      const IMAGETYPE_JPEG = 'image/jpeg';      const IMAGETYPE_PNG = 'image/png';        protected $image_objects = array();      protected $response = array();        public function __construct($options = null, $initialize = true, $error_messages = null) {          $this->options = array(              'script_url' => $this->get_full_url().'/'.$this->basename($this->get_server_var('SCRIPT_NAME')),              'upload_dir' => dirname($this->get_server_var('SCRIPT_FILENAME')).'/files/',              'upload_url' => $this->get_full_url().'/files/',              'input_stream' => 'php://input',              'user_dirs' => false,              'mkdir_mode' => 0755,              'param_name' => 'files',              // Set the following option to 'POST', if your server does not support              // DELETE requests. This is a parameter sent to the client:              'delete_type' => 'DELETE',              'access_control_allow_origin' => '*',              'access_control_allow_credentials' => false,              'access_control_allow_methods' => array(                  'OPTIONS',                  'HEAD',                  'GET',                  'POST',                  'PUT',                  'PATCH',                  'DELETE'              ),              'access_control_allow_headers' => array(                  'Content-Type',                  'Content-Range',                  'Content-Disposition'              ),              // By default, allow redirects to the referer protocol+host:              'redirect_allow_target' => '/^'.preg_quote(                      parse_url($this->get_server_var('HTTP_REFERER'), PHP_URL_SCHEME)                      .'://'                      .parse_url($this->get_server_var('HTTP_REFERER'), PHP_URL_HOST)                      .'/', // Trailing slash to not match subdomains by mistake                      '/' // preg_quote delimiter param                  ).'/',              // Enable to provide file downloads via GET requests to the PHP script:              //     1. Set to 1 to download files via readfile method through PHP              //     2. Set to 2 to send a X-Sendfile header for lighttpd/Apache              //     3. Set to 3 to send a X-Accel-Redirect header for nginx              // If set to 2 or 3, adjust the upload_url option to the base path of              // the redirect parameter, e.g. '/files/'.              'download_via_php' => false,              // Read files in chunks to avoid memory limits when download_via_php              // is enabled, set to 0 to disable chunked reading of files:              'readfile_chunk_size' => 10 * 1024 * 1024, // 10 MiB              // Defines which files can be displayed inline when downloaded:              'inline_file_types' => '/\.(gif|jpe?g|png)$/i',              // Defines which files (based on their names) are accepted for upload.              // By default, only allows file uploads with image file extensions.              // Only change this setting after making sure that any allowed file              // types cannot be executed by the webserver in the files directory,              // e.g. PHP scripts, nor executed by the browser when downloaded,              // e.g. HTML files with embedded JavaScript code.              // Please also read the SECURITY.md document in this repository.              'accept_file_types' => '/\.(gif|jpe?g|png)$/i',              // Replaces dots in filenames with the given string.              // Can be disabled by setting it to false or an empty string.              // Note that this is a security feature for servers that support              // multiple file extensions, e.g. the Apache AddHandler Directive:              // https://httpd.apache.org/docs/current/mod/mod_mime.html#addhandler              // Before disabling it, make sure that files uploaded with multiple              // extensions cannot be executed by the webserver, e.g.              // ""example.php.png"" with embedded PHP code, nor executed by the              // browser when downloaded, e.g. ""example.html.gif"" with embedded              // JavaScript code.              'replace_dots_in_filenames' => '-',              // The php.ini settings upload_max_filesize and post_max_size              // take precedence over the following max_file_size setting:              'max_file_size' => null,              'min_file_size' => 1,              // The maximum number of files for the upload directory:              'max_number_of_files' => null,              // Reads first file bytes to identify and correct file extensions:              'correct_image_extensions' => false,              // Image resolution restrictions:              'max_width' => null,              'max_height' => null,              'min_width' => 1,              'min_height' => 1,              // Set the following option to false to enable resumable uploads:              'discard_aborted_uploads' => true,              // Set to 0 to use the GD library to scale and orient images,              // set to 1 to use imagick (if installed, falls back to GD),              // set to 2 to use the ImageMagick convert binary directly:              'image_library' => 1,              // Uncomment the following to define an array of resource limits              // for imagick:              /*              'imagick_resource_limits' => array(                  imagick::RESOURCETYPE_MAP => 32,                  imagick::RESOURCETYPE_MEMORY => 32              ),              */              // Command or path for to the ImageMagick convert binary:              'convert_bin' => 'convert',              // Uncomment the following to add parameters in front of each              // ImageMagick convert call (the limit constraints seem only              // to have an effect if put in front):              /*              'convert_params' => '-limit memory 32MiB -limit map 32MiB',              */              // Command or path for to the ImageMagick identify binary:              'identify_bin' => 'identify',              'image_versions' => array(                  // The empty image version key defines options for the original image.                  // Keep in mind: these image manipulations are inherited by all other image versions from this point onwards.                  // Also note that the property 'no_cache' is not inherited, since it's not a manipulation.                  '' => array(                      // Automatically rotate images based on EXIF meta data:                      'auto_orient' => true                  ),                  // You can add arrays to generate different versions.                  // The name of the key is the name of the version (example: 'medium').                  // the array contains the options to apply.                  /*                  'medium' => array(                      'max_width' => 800,                      'max_height' => 600                  ),                  */                  'thumbnail' => array(                      // Uncomment the following to use a defined directory for the thumbnails                      // instead of a subdirectory based on the version identifier.                      // Make sure that this directory doesn't allow execution of files if you                      // don't pose any restrictions on the type of uploaded files, e.g. by                      // copying the .htaccess file from the files directory for Apache:                      //'upload_dir' => dirname($this->get_server_var('SCRIPT_FILENAME')).'/thumb/',                      //'upload_url' => $this->get_full_url().'/thumb/',                      // Uncomment the following to force the max                      // dimensions and e.g. create square thumbnails:                      // 'auto_orient' => true,                      // 'crop' => true,                      // 'jpeg_quality' => 70,                      // 'no_cache' => true, (there's a caching option, but this remembers thumbnail sizes from a previous action!)                      // 'strip' => true, (this strips EXIF tags, such as geolocation)                      'max_width' => 80, // either specify width, or set to 0. Then width is automatically adjusted - keeping aspect ratio to a specified max_height.                      'max_height' => 80 // either specify height, or set to 0. Then height is automatically adjusted - keeping aspect ratio to a specified max_width.                  )              ),              'print_response' => true          );          if ($options) {              $this->options = $options + $this->options;          }          if ($error_messages) {              $this->error_messages = $error_messages + $this->error_messages;          }          if ($initialize) {              $this->initialize();          }      }        protected function initialize() {          switch ($this->get_server_var('REQUEST_METHOD')) {              case 'OPTIONS':              case 'HEAD':                  $this->head();                  break;              case 'GET':                  $this->get($this->options['print_response']);                  break;              case 'PATCH':              case 'PUT':              case 'POST':                  $this->post($this->options['print_response']);                  break;              case 'DELETE':                  $this->delete($this->options['print_response']);                  break;              default:                  $this->header('HTTP/1.1 405 Method Not Allowed');          }      }        protected function get_full_url() {          $https = !empty($_SERVER['HTTPS']) && strcasecmp($_SERVER['HTTPS'], 'on') === 0 ||              !empty($_SERVER['HTTP_X_FORWARDED_PROTO']) &&              strcasecmp($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') === 0;          return              ($https ? 'https://' : 'http://').              (!empty($_SERVER['REMOTE_USER']) ? $_SERVER['REMOTE_USER'].'@' : '').              (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : ($_SERVER['SERVER_NAME'].                  ($https && $_SERVER['SERVER_PORT'] === 443 ||                  $_SERVER['SERVER_PORT'] === 80 ? '' : ':'.$_SERVER['SERVER_PORT']))).              substr($_SERVER['SCRIPT_NAME'],0, strrpos($_SERVER['SCRIPT_NAME'], '/'));      }        protected function get_user_id() {          @session_start();          return session_id();      }        protected function get_user_path() {          if ($this->options['user_dirs']) {              return $this->get_user_id().'/';          }          return '';      }        protected function get_upload_path($file_name = null, $version = null) {          $file_name = $file_name ? $file_name : '';          if (empty($version)) {              $version_path = '';          } else {              $version_dir = @$this->options['image_versions'][$version]['upload_dir'];              if ($version_dir) {                  return $version_dir.$this->get_user_path().$file_name;              }              $version_path = $version.'/';          }          return $this->options['upload_dir'].$this->get_user_path()              .$version_path.$file_name;      }        protected function get_query_separator($url) {          return strpos($url, '?') === false ? '?' : '&';      }        protected function get_download_url($file_name, $version = null, $direct = false) {          if (!$direct && $this->options['download_via_php']) {              $url = $this->options['script_url']                  .$this->get_query_separator($this->options['script_url'])                  .$this->get_singular_param_name()                  .'='.rawurlencode($file_name);              if ($version) {                  $url .= '&version='.rawurlencode($version);              }              return $url.'&download=1';          }          if (empty($version)) {              $version_path = '';          } else {              $version_url = @$this->options['image_versions'][$version]['upload_url'];              if ($version_url) {                  return $version_url.$this->get_user_path().rawurlencode($file_name);              }              $version_path = rawurlencode($version).'/';          }          return $this->options['upload_url'].$this->get_user_path()              .$version_path.rawurlencode($file_name);      }        protected function set_additional_file_properties($file) {          $file->deleteUrl = $this->options['script_url']              .$this->get_query_separator($this->options['script_url'])              .$this->get_singular_param_name()              .'='.rawurlencode($file->name);          $file->deleteType = $this->options['delete_type'];          if ($file->deleteType !== 'DELETE') {              $file->deleteUrl .= '&_method=DELETE';          }          if ($this->options['access_control_allow_credentials']) {              $file->deleteWithCredentials = true;          }      }        // Fix for overflowing signed 32 bit integers,      // works for sizes up to 2^32-1 bytes (4 GiB - 1):      protected function fix_integer_overflow($size) {          if ($size < 0) {              $size += 2.0 * (PHP_INT_MAX + 1);          }          return $size;      }        protected function get_file_size($file_path, $clear_stat_cache = false) {          if ($clear_stat_cache) {              if (version_compare(PHP_VERSION, '5.3.0') >= 0) {                  clearstatcache(true, $file_path);              } else {                  clearstatcache();              }          }          return $this->fix_integer_overflow(filesize($file_path));      }        protected function is_valid_file_object($file_name) {          $file_path = $this->get_upload_path($file_name);          if (strlen($file_name) > 0 && $file_name[0] !== '.' && is_file($file_path)) {              return true;          }          return false;      }        protected function get_file_object($file_name) {          if ($this->is_valid_file_object($file_name)) {              $file = new \stdClass();              $file->name = $file_name;              $file->size = $this->get_file_size(                  $this->get_upload_path($file_name)              );              $file->url = $this->get_download_url($file->name);              foreach ($this->options['image_versions'] as $version => $options) {                  if (!empty($version)) {                      if (is_file($this->get_upload_path($file_name, $version))) {                          $file->{$version.'Url'} = $this->get_download_url(                              $file->name,                              $version                          );                      }                  }              }              $this->set_additional_file_properties($file);              return $file;          }          return null;      }        protected function get_file_objects($iteration_method = 'get_file_object') {          $upload_dir = $this->get_upload_path();          if (!is_dir($upload_dir)) {              return array();          }          return array_values(array_filter(array_map(              array($this, $iteration_method),              scandir($upload_dir)          )));      }        protected function count_file_objects() {          return count($this->get_file_objects('is_valid_file_object'));      }        protected function get_error_message($error) {          return isset($this->error_messages[$error]) ?              $this->error_messages[$error] : $error;      }        public function get_config_bytes($val) {          $val = trim($val);          $last = strtolower($val[strlen($val)-1]);          if (is_numeric($val)) {              $val = (int)$val;          } else {              $val = (int)substr($val, 0, -1);          }          switch ($last) {              case 'g':                  $val *= 1024;              case 'm':                  $val *= 1024;              case 'k':                  $val *= 1024;          }          return $this->fix_integer_overflow($val);      }        protected function validate_image_file($uploaded_file, $file, $error, $index) {          if ($this->imagetype($uploaded_file) !== $this->get_file_type($file->name)) {              $file->error = $this->get_error_message('invalid_file_type');              return false;          }          $max_width = @$this->options['max_width'];          $max_height = @$this->options['max_height'];          $min_width = @$this->options['min_width'];          $min_height = @$this->options['min_height'];          if ($max_width || $max_height || $min_width || $min_height) {              list($img_width, $img_height) = $this->get_image_size($uploaded_file);              // If we are auto rotating the image by default, do the checks on              // the correct orientation              if (                  @$this->options['image_versions']['']['auto_orient'] &&                  function_exists('exif_read_data') &&                  ($exif = @exif_read_data($uploaded_file)) &&                  (((int) @$exif['Orientation']) >= 5)              ) {                  $tmp = $img_width;                  $img_width = $img_height;                  $img_height = $tmp;                  unset($tmp);              }              if (!empty($img_width) && !empty($img_height)) {                  if ($max_width && $img_width > $max_width) {                      $file->error = $this->get_error_message('max_width');                      return false;                  }                  if ($max_height && $img_height > $max_height) {                      $file->error = $this->get_error_message('max_height');                      return false;                  }                  if ($min_width && $img_width < $min_width) {                      $file->error = $this->get_error_message('min_width');                      return false;                  }                  if ($min_height && $img_height < $min_height) {                      $file->error = $this->get_error_message('min_height');                      return false;                  }              }          }          return true;      }        protected function validate($uploaded_file, $file, $error, $index, $content_range) {          if ($error) {              $file->error = $this->get_error_message($error);              return false;          }          $content_length = $this->fix_integer_overflow(              (int)$this->get_server_var('CONTENT_LENGTH')          );          $post_max_size = $this->get_config_bytes(ini_get('post_max_size'));          if ($post_max_size && ($content_length > $post_max_size)) {              $file->error = $this->get_error_message('post_max_size');              return false;          }          if (!preg_match($this->options['accept_file_types'], $file->name)) {              $file->error = $this->get_error_message('accept_file_types');              return false;          }          if ($uploaded_file && is_uploaded_file($uploaded_file)) {              $file_size = $this->get_file_size($uploaded_file);          } else {              $file_size = $content_length;          }          if ($this->options['max_file_size'] && (                  $file_size > $this->options['max_file_size'] ||                  $file->size > $this->options['max_file_size'])          ) {              $file->error = $this->get_error_message('max_file_size');              return false;          }          if ($this->options['min_file_size'] &&              $file_size < $this->options['min_file_size']) {              $file->error = $this->get_error_message('min_file_size');              return false;          }          if (is_int($this->options['max_number_of_files']) &&              ($this->count_file_objects() >= $this->options['max_number_of_files']) &&              // Ignore additional chunks of existing files:              !is_file($this->get_upload_path($file->name))) {              $file->error = $this->get_error_message('max_number_of_files');              return false;          }          if (!$content_range && $this->has_image_file_extension($file->name)) {              return $this->validate_image_file($uploaded_file, $file, $error, $index);          }          return true;      }        protected function upcount_name_callback($matches) {          $index = isset($matches[1]) ? ((int)$matches[1]) + 1 : 1;          $ext = isset($matches[2]) ? $matches[2] : '';          return ' ('.$index.')'.$ext;      }        protected function upcount_name($name) {          return preg_replace_callback(              '/(?:(?: \(([\d]+)\))?(\.[^.]+))?$/',              array($this, 'upcount_name_callback'),              $name,              1          );      }        protected function get_unique_filename($file_path, $name, $size, $type, $error,          $index, $content_range) {          while(is_dir($this->get_upload_path($name))) {              $name = $this->upcount_name($name);          }          // Keep an existing filename if this is part of a chunked upload:          $uploaded_bytes = $this->fix_integer_overflow((int)@$content_range[1]);          while (is_file($this->get_upload_path($name))) {              if ($uploaded_bytes === $this->get_file_size(                      $this->get_upload_path($name))) {                  break;              }              $name = $this->upcount_name($name);          }          return $name;      }        protected function get_valid_image_extensions($file_path) {          switch ($this->imagetype($file_path)) {              case self::IMAGETYPE_JPEG:                  return array('jpg', 'jpeg');              case self::IMAGETYPE_PNG:                  return  array('png');              case self::IMAGETYPE_GIF:                  return array('gif');          }      }        protected function fix_file_extension($file_path, $name, $size, $type, $error,          $index, $content_range) {          // Add missing file extension for known image types:          if (strpos($name, '.') === false &&              preg_match('/^image\/(gif|jpe?g|png)/', $type, $matches)) {              $name .= '.'.$matches[1];          }          if ($this->options['correct_image_extensions']) {              $extensions = $this->get_valid_image_extensions($file_path);              // Adjust incorrect image file extensions:              if (!empty($extensions)) {                  $parts = explode('.', $name);                  $extIndex = count($parts) - 1;                  $ext = strtolower(@$parts[$extIndex]);                  if (!in_array($ext, $extensions)) {                      $parts[$extIndex] = $extensions[0];                      $name = implode('.', $parts);                  }              }          }          return $name;      }        protected function trim_file_name($file_path, $name, $size, $type, $error,          $index, $content_range) {          // Remove path information and dots around the filename, to prevent uploading          // into different directories or replacing hidden system files.          // Also remove control characters and spaces (\x00..\x20) around the filename:          $name = trim($this->basename(stripslashes($name)), "".\x00..\x20"");          // Replace dots in filenames to avoid security issues with servers          // that interpret multiple file extensions, e.g. ""example.php.png"":          $replacement = $this->options['replace_dots_in_filenames'];          if (!empty($replacement)) {              $parts = explode('.', $name);              if (count($parts) > 2) {                  $ext = array_pop($parts);                  $name = implode($replacement, $parts).'.'.$ext;              }          }          // Use a timestamp for empty filenames:          if (!$name) {              $name = str_replace('.', '-', microtime(true));          }          return $name;      }        protected function get_file_name($file_path, $name, $size, $type, $error,          $index, $content_range) {          $name = $this->trim_file_name($file_path, $name, $size, $type, $error,              $index, $content_range);          return $this->get_unique_filename(              $file_path,              $this->fix_file_extension($file_path, $name, $size, $type, $error,                  $index, $content_range),              $size,              $type,              $error,              $index,              $content_range          );      }        protected function get_scaled_image_file_paths($file_name, $version) {          $file_path = $this->get_upload_path($file_name);          if (!empty($version)) {              $version_dir = $this->get_upload_path(null, $version);              if (!is_dir($version_dir)) {                  mkdir($version_dir, $this->options['mkdir_mode'], true);              }              $new_file_path = $version_dir.'/'.$file_name;          } else {              $new_file_path = $file_path;          }          return array($file_path, $new_file_path);      }        protected function gd_get_image_object($file_path, $func, $no_cache = false) {          if (empty($this->image_objects[$file_path]) || $no_cache) {              $this->gd_destroy_image_object($file_path);              $this->image_objects[$file_path] = $func($file_path);          }          return $this->image_objects[$file_path];      }        protected function gd_set_image_object($file_path, $image) {          $this->gd_destroy_image_object($file_path);          $this->image_objects[$file_path] = $image;      }        protected function gd_destroy_image_object($file_path) {          $image = (isset($this->image_objects[$file_path])) ? $this->image_objects[$file_path] : null ;          return $image && imagedestroy($image);      }        protected function gd_imageflip($image, $mode) {          if (function_exists('imageflip')) {              return imageflip($image, $mode);          }          $new_width = $src_width = imagesx($image);          $new_height = $src_height = imagesy($image);          $new_img = imagecreatetruecolor($new_width, $new_height);          $src_x = 0;          $src_y = 0;          switch ($mode) {              case '1': // flip on the horizontal axis                  $src_y = $new_height - 1;                  $src_height = -$new_height;                  break;              case '2': // flip on the vertical axis                  $src_x  = $new_width - 1;                  $src_width = -$new_width;                  break;              case '3': // flip on both axes                  $src_y = $new_height - 1;                  $src_height = -$new_height;                  $src_x  = $new_width - 1;                  $src_width = -$new_width;                  break;              default:                  return $image;          }          imagecopyresampled(              $new_img,              $image,              0,              0,              $src_x,              $src_y,              $new_width,              $new_height,              $src_width,              $src_height          );          return $new_img;      }        protected function gd_orient_image($file_path, $src_img) {          if (!function_exists('exif_read_data')) {              return false;          }          $exif = @exif_read_data($file_path);          if ($exif === false) {              return false;          }          $orientation = (int)@$exif['Orientation'];          if ($orientation < 2 || $orientation > 8) {              return false;          }          switch ($orientation) {              case 2:                  $new_img = $this->gd_imageflip(                      $src_img,                      defined('IMG_FLIP_VERTICAL') ? IMG_FLIP_VERTICAL : 2                  );                  break;              case 3:                  $new_img = imagerotate($src_img, 180, 0);                  break;              case 4:                  $new_img = $this->gd_imageflip(                      $src_img,                      defined('IMG_FLIP_HORIZONTAL') ? IMG_FLIP_HORIZONTAL : 1                  );                  break;              case 5:                  $tmp_img = $this->gd_imageflip(                      $src_img,                      defined('IMG_FLIP_HORIZONTAL') ? IMG_FLIP_HORIZONTAL : 1                  );                  $new_img = imagerotate($tmp_img, 270, 0);                  imagedestroy($tmp_img);                  break;              case 6:                  $new_img = imagerotate($src_img, 270, 0);                  break;              case 7:                  $tmp_img = $this->gd_imageflip(                      $src_img,                      defined('IMG_FLIP_VERTICAL') ? IMG_FLIP_VERTICAL : 2                  );                  $new_img = imagerotate($tmp_img, 270, 0);                  imagedestroy($tmp_img);                  break;              case 8:                  $new_img = imagerotate($src_img, 90, 0);                  break;              default:                  return false;          }          $this->gd_set_image_object($file_path, $new_img);          return true;      }        protected function gd_create_scaled_image($file_name, $version, $options) {          if (!function_exists('imagecreatetruecolor')) {              error_log('Function not found: imagecreatetruecolor');              return false;          }          list($file_path, $new_file_path) =              $this->get_scaled_image_file_paths($file_name, $version);          $type = strtolower(substr(strrchr($file_name, '.'), 1));          switch ($type) {              case 'jpg':              case 'jpeg':                  $src_func = 'imagecreatefromjpeg';                  $write_func = 'imagejpeg';                  $image_quality = isset($options['jpeg_quality']) ?                      $options['jpeg_quality'] : 75;                  break;              case 'gif':                  $src_func = 'imagecreatefromgif';                  $write_func = 'imagegif';                  $image_quality = null;                  break;              case 'png':                  $src_func = 'imagecreatefrompng';                  $write_func = 'imagepng';                  $image_quality = isset($options['png_quality']) ?                      $options['png_quality'] : 9;                  break;              default:                  return false;          }          $src_img = $this->gd_get_image_object(              $file_path,              $src_func,              !empty($options['no_cache'])          );          $image_oriented = false;          if (!empty($options['auto_orient']) && $this->gd_orient_image(                  $file_path,                  $src_img              )) {              $image_oriented = true;              $src_img = $this->gd_get_image_object(                  $file_path,                  $src_func              );          }          $max_width = $img_width = imagesx($src_img);          $max_height = $img_height = imagesy($src_img);          if (!empty($options['max_width'])) {              $max_width = $options['max_width'];          }          if (!empty($options['max_height'])) {              $max_height = $options['max_height'];          }          $scale = min(              $max_width / $img_width,              $max_height / $img_height          );          if ($scale >= 1) {              if ($image_oriented) {                  return $write_func($src_img, $new_file_path, $image_quality);              }              if ($file_path !== $new_file_path) {                  return ",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,2.0,0.0,2.0,0.0,0.0,2.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0
87,symfony_http-foundation_HeaderUtils_8792, HTTP header utility functions.\n\n @author Christian Schmidt <github@chsc.dk>\n,Pomoćne funkcije za http heder.,"class HeaderUtils{    public const DISPOSITION_ATTACHMENT = 'attachment';    public const DISPOSITION_INLINE = 'inline';    /**     * This class should not be instantiated.     */    private function __construct()    {    }    /**     * Splits an HTTP header by one or more separators.     *     * Example:     *     *     HeaderUtils::split(""da, en-gb;q=0.8"", "",;"")     *     // => ['da'], ['en-gb', 'q=0.8']]     *     * @param string $separators List of characters to split on, ordered by     *                           precedence, e.g. "","", "";="", or "",;=""     *     * @return array Nested array with as many levels as there are characters in     *               $separators     */    public static function split(string $header, string $separators): array    {        $quotedSeparators = preg_quote($separators, '/');        preg_match_all('            /                (?!\s)                    (?:                        # quoted-string                        ""(?:[^""\\\\]|\\\\.)*(?:""|\\\\|$)                    |                        # token                        [^""'.$quotedSeparators.']+                    )+                (?<!\s)            |                # separator                \s*                (?<separator>['.$quotedSeparators.'])                \s*            /x', trim($header), $matches, \PREG_SET_ORDER);        return self::groupParts($matches, $separators);    }    /**     * Combines an array of arrays into one associative array.     *     * Each of the nested arrays should have one or two elements. The first     * value will be used as the keys in the associative array, and the second     * will be used as the values, or true if the nested array only contains one     * element. Array keys are lowercased.     *     * Example:     *     *     HeaderUtils::combine([[""foo"", ""abc""], [""bar""]])     *     // => [""foo"" => ""abc"", ""bar"" => true]     */    public static function combine(array $parts): array    {        $assoc = [];        foreach ($parts as $part) {            $name = strtolower($part[0]);            $value = $part[1] ?? true;            $assoc[$name] = $value;        }        return $assoc;    }    /**     * Joins an associative array into a string for use in an HTTP header.     *     * The key and value of each entry are joined with ""="", and all entries     * are joined with the specified separator and an additional space (for     * readability). Values are quoted if necessary.     *     * Example:     *     *     HeaderUtils::toString([""foo"" => ""abc"", ""bar"" => true, ""baz"" => ""a b c""], "","")     *     // => 'foo=abc, bar, baz=""a b c""'     */    public static function toString(array $assoc, string $separator): string    {        $parts = [];        foreach ($assoc as $name => $value) {            if (true === $value) {                $parts[] = $name;            } else {                $parts[] = $name.'='.self::quote($value);            }        }        return implode($separator.' ', $parts);    }    /**     * Encodes a string as a quoted string, if necessary.     *     * If a string contains characters not allowed by the ""token"" construct in     * the HTTP specification, it is backslash-escaped and enclosed in quotes     * to match the ""quoted-string"" construct.     */    public static function quote(string $s): string    {        if (preg_match('/^[a-z0-9!#$%&\'*.^_`|~-]+$/i', $s)) {            return $s;        }        return '""'.addcslashes($s, '""\\""').'""';    }    /**     * Decodes a quoted string.     *     * If passed an unquoted string that matches the ""token"" construct (as     * defined in the HTTP specification), it is passed through verbatimly.     */    public static function unquote(string $s): string    {        return preg_replace('/\\\\(.)|""/', '$1', $s);    }    /**     * Generates an HTTP Content-Disposition field-value.     *     * @param string $disposition      One of ""inline"" or ""attachment""     * @param string $filename         A unicode string     * @param string $filenameFallback A string containing only ASCII characters that     *                                 is semantically equivalent to $filename. If the filename is already ASCII,     *                                 it can be omitted, or just copied from $filename     *     * @return string A string suitable for use as a Content-Disposition field-value     *     * @throws \InvalidArgumentException     *     * @see RFC 6266     */    public static function makeDisposition(string $disposition, string $filename, string $filenameFallback = ''): string    {        if (!\in_array($disposition, [self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE])) {            throw new \InvalidArgumentException(sprintf('The disposition must be either ""%s"" or ""%s"".', self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE));        }        if ('' === $filenameFallback) {            $filenameFallback = $filename;        }        // filenameFallback is not ASCII.        if (!preg_match('/^[\x20-\x7e]*$/', $filenameFallback)) {            throw new \InvalidArgumentException('The filename fallback must only contain ASCII characters.');        }        // percent characters aren't safe in fallback.        if (false !== strpos($filenameFallback, '%')) {            throw new \InvalidArgumentException('The filename fallback cannot contain the ""%"" character.');        }        // path separators aren't allowed in either.        if (false !== strpos($filename, '/') || false !== strpos($filename, '\\') || false !== strpos($filenameFallback, '/') || false !== strpos($filenameFallback, '\\')) {            throw new \InvalidArgumentException('The filename and the fallback cannot contain the ""/"" and ""\\"" characters.');        }        $params = ['filename' => $filenameFallback];        if ($filename !== $filenameFallback) {            $params['filename*'] = ""utf-8''"".rawurlencode($filename);        }        return $disposition.'; '.self::toString($params, ';');    }    /**     * Like parse_str(), but preserves dots in variable names.     */    public static function parseQuery(string $query, bool $ignoreBrackets = false, string $separator = '&'): array    {        $q = [];        foreach (explode($separator, $query) as $v) {            if (false !== $i = strpos($v, ""\0"")) {                $v = substr($v, 0, $i);            }            if (false === $i = strpos($v, '=')) {                $k = urldecode($v);                $v = '';            } else {                $k = urldecode(substr($v, 0, $i));                $v = substr($v, $i);            }            if (false !== $i = strpos($k, ""\0"")) {                $k = substr($k, 0, $i);            }            $k = ltrim($k, ' ');            if ($ignoreBrackets) {                $q[$k][] = urldecode(substr($v, 1));                continue;            }            if (false === $i = strpos($k, '[')) {                $q[] = bin2hex($k).$v;            } else {                $q[] = bin2hex(substr($k, 0, $i)).rawurlencode(substr($k, $i)).$v;            }        }        if ($ignoreBrackets) {            return $q;        }        parse_str(implode('&', $q), $q);        $query = [];        foreach ($q as $k => $v) {            if (false !== $i = strpos($k, '_')) {                $query[substr_replace($k, hex2bin(substr($k, 0, $i)).'[', 0, 1 + $i)] = $v;            } else {                $query[hex2bin($k)] = $v;            }        }        return $query;    }    private static function groupParts(array $matches, string $separators, bool $first = true): array    {        $separator = $separators[0];        $partSeparators = substr($separators, 1);        $i = 0;        $partMatches = [];        $previousMatchWasSeparator = false;        foreach ($matches as $match) {            if (!$first && $previousMatchWasSeparator && isset($match['separator']) && $match['separator'] === $separator) {                $previousMatchWasSeparator = true;                $partMatches[$i][] = $match;            } elseif (isset($match['separator']) && $match['separator'] === $separator) {                $previousMatchWasSeparator = true;                ++$i;            } else {                $previousMatchWasSeparator = false;                $partMatches[$i][] = $match;            }        }        $parts = [];        if ($partSeparators) {            foreach ($partMatches as $matches) {                $parts[] = self::groupParts($matches, $partSeparators, false);            }        } else {            foreach ($partMatches as $matches) {                $parts[] = self::unquote($matches[0][0]);            }            if (!$first && 2 < \count($parts)) {                $parts = [                    $parts[0],                    implode($separator, \array_slice($parts, 1)),                ];            }        }        return $parts;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0
88,matomo-org_matomo_LocalTracker_997, Tracker that uses core/Tracker.php directly.\n,Tragač koji direktno koristi glavni Tracker.php,"class Matomo_LocalTracker extends MatomoTracker{    protected function sendRequest($url, $method = 'GET', $data = null, $force = false)    {        self::$DEBUG_LAST_REQUESTED_URL = $url;        if ($this->DEBUG_APPEND_URL) {            $url .= $this->DEBUG_APPEND_URL;        }        // if doing a bulk request, store the url        if ($this->doBulkRequests && !$force) {            $this->storedTrackingActions[] = $url;            return true;        }        if ($method == 'POST') {            $requests = array();            foreach ($this->storedTrackingActions as $action) {                $requests[] = $this->parseUrl($action);            }            $testEnvironmentArgs = array();        } else {            $testEnvironmentArgs = $this->parseUrl($url);            if (!empty($this->token_auth)) {                $testEnvironmentArgs['token_auth'] = $this->token_auth;            }            $requests = array($testEnvironmentArgs);        }        // unset cached values        Cache::$cache = null;        Tracker\Visit::$dimensions = null;        // save some values        $plugins = Config::getInstance()->Plugins['Plugins'];        $oldTrackerConfig = Config::getInstance()->Tracker;        \Piwik\Plugin\Manager::getInstance()->unloadPlugins();        // modify config        \Piwik\SettingsServer::setIsTrackerApiRequest();        $GLOBALS['PIWIK_TRACKER_LOCAL_TRACKING'] = true;        Tracker::$initTrackerMode = false;        Tracker::setTestEnvironment($testEnvironmentArgs, $method);        // set language        $oldLang = isset($_SERVER['HTTP_ACCEPT_LANGUAGE']) ? $_SERVER['HTTP_ACCEPT_LANGUAGE'] : '';        $_SERVER['HTTP_ACCEPT_LANGUAGE'] = $this->acceptLanguage;        // set user agent        $oldUserAgent = isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '';        $_SERVER['HTTP_USER_AGENT'] = $this->userAgent;        // set cookie        $oldCookie = $_COOKIE;//        parse_str(parse_url($this->requestCookie, PHP_URL_QUERY), $_COOKIE);        // do tracking and capture output        ob_start();        $localTracker = new Tracker();        $request = new Tracker\RequestSet();        $request->setRequests($requests);        \Piwik\Plugin\Manager::getInstance()->loadTrackerPlugins();        $handler = Tracker\Handler\Factory::make();        $response = $localTracker->main($handler, $request);        if (!is_null($response)) {            echo $response;        }        $output = ob_get_contents();        ob_end_clean();        // restore vars        Config::getInstance()->Tracker = $oldTrackerConfig;        $_SERVER['HTTP_ACCEPT_LANGUAGE'] = $oldLang;        $_SERVER['HTTP_USER_AGENT'] = $oldUserAgent;        $_COOKIE = $oldCookie;        $GLOBALS['PIWIK_TRACKER_LOCAL_TRACKING'] = false;        \Piwik\SettingsServer::setIsNotTrackerApiRequest();        unset($_GET['bots']);        // reload plugins        \Piwik\Plugin\Manager::getInstance()->loadPlugins($plugins);        return $output;    }    private function parseUrl($url)    {        // parse url        $query = parse_url($url, PHP_URL_QUERY);        if ($query === false) {            return;        }        parse_str($query, $args);        // make sure bots is set if needed        if (isset($args['bots'])) {            $_GET['bots'] = true;        }        return $args;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0
89,dompdf_dompdf_Helpers_612," Builds a HTTP Content-Disposition header string using `$dispositionType`\n and `$filename`.\n\n If the filename contains any characters not in the ISO-8859-1 character\n set, a fallback filename will be included for clients not supporting the\n `filename\n @param string $dispositionType\n @param string $filename\n @return string\n",Izgradi niz Http zaglavlja despozicije sadržaja koristeći tip despozicije i naziv fajla. Ako datoteka sadrži znakove koji nisu u skupu znakova ISO-8859-1 biće zamenjeno rezervnim imenom datoteke za klijente koji ga ne podržavaju.,"    public static function buildContentDispositionHeader($dispositionType, $filename)    {        $encoding = mb_detect_encoding($filename);        $fallbackfilename = mb_convert_encoding($filename, ""ISO-8859-1"", $encoding);        $fallbackfilename = str_replace(""\"""", """", $fallbackfilename);        $encodedfilename = rawurlencode($filename);        $contentDisposition = ""Content-Disposition: $dispositionType; filename=\""$fallbackfilename\"""";        if ($fallbackfilename !== $filename) {            $contentDisposition .= ""; filename*=UTF-8''$encodedfilename"";        }        return $contentDisposition;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
90,BookStackApp_BookStack_helpers_730, Helper method to get the current User.\n Defaults to public 'Guest' user if not logged in.\n,Pomoćna metoda za dohvatanje trenutno prijavljenog korisnika. Podrazumevano vraća javno dostupnog gost korisnika ukoliko nema prijave.,function user(): User{    return auth()->user() ?: User::getDefault();},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
91,BookStackApp_BookStack_helpers_732, Check if the current user has general access.\n,Proveri da li trnutan korisnik ima opšti pristup.,function hasAppAccess(): bool{    return !auth()->guest() || setting('app-public');},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
92,CachetHQ_Cachet_2015_01_05_202609_CreateIncidentsTable_1182, Run the migrations.\n,Pokreni migraciju,"    public function up()    {        Schema::create('incidents', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->integer('component_id')->default(0);            $table->string('name');            $table->integer('status');            $table->longText('message');            $table->integer('user_id');            $table->timestamps();            $table->softDeletes();            $table->index('component_id');            $table->index('status');            $table->index('user_id');        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
93,CachetHQ_Cachet_2015_01_05_202609_CreateIncidentsTable_1183, Reverse the migrations.\n,Poništi migracije,    public function down()    {        Schema::drop('incidents');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
94,CachetHQ_Cachet_2015_01_05_202730_CreateMetricPointsTable_1185, Reverse the migrations.\n,Poništi migracije,    public function down()    {        Schema::drop('metric_points');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
95,CachetHQ_Cachet_2015_01_05_202826_CreateMetricsTable_1186, Run the migrations.\n,Pokreni migraciju,"    public function up()    {        Schema::create('metrics', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->string('name');            $table->string('suffix');            $table->text('description');            $table->decimal('default_value', 10, 3);            $table->tinyInteger('calc_type');            $table->boolean('display_chart')->default(1);            $table->timestamps();            $table->index('display_chart');        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
96,CachetHQ_Cachet_ComponentGroupTest_1213, This is the component group test class.\n\n @author James Brooks <james@alt-three.com>\n @author Graham Campbell <graham@alt-three.com>\n,Ovo je klasa koja ispituje grupaciju komponenti.,"class ComponentGroupTest extends AbstractApiTestCase{    const COMPONENT_GROUP_1_NAME = 'Component Group 1';    const COMPONENT_GROUP_2_NAME = 'Component Group 2';    public function test_can_get_all_component_groups()    {        $groups = factory(ComponentGroup::class, 2)            ->create(['visible' => ComponentGroup::VISIBLE_GUEST]);        $response = $this->json('GET', '/api/v1/components/groups');        $response->assertStatus(200);        $response->assertJsonFragment([            [                'id'                        => $groups[0]->id,                'name'                      => $groups[0]->name,                'created_at'                => (string) $groups[0]->created_at,                'updated_at'                => (string) $groups[0]->updated_at,                'order'                     => $groups[0]->order,                'collapsed'                 => $groups[0]->collapsed,                'visible'                   => $groups[0]->visible,                'enabled_components'        => $groups[0]->enabled_components,                'enabled_components_lowest' => $groups[0]->enabled_components_lowest,                'lowest_human_status'       => $groups[0]->lowest_human_status,            ],        ]);        $response->assertJsonFragment([            [                'id'                        => $groups[1]->id,                'name'                      => $groups[1]->name,                'created_at'                => (string) $groups[1]->created_at,                'updated_at'                => (string) $groups[1]->updated_at,                'order'                     => $groups[1]->order,                'collapsed'                 => $groups[1]->collapsed,                'visible'                   => $groups[1]->visible,                'enabled_components'        => $groups[1]->enabled_components,                'enabled_components_lowest' => $groups[1]->enabled_components_lowest,                'lowest_human_status'       => $groups[1]->lowest_human_status,            ],        ]);    }    public function test_cannot_get_invalid_component_group()    {        $response = $this->json('GET', '/api/v1/components/groups/1');        $response->assertStatus(404);    }    public function test_cannot_create_component_group_without_authorization()    {        $this->doesntExpectEvents(ComponentGroupWasCreatedEvent::class);        $response = $this->json('POST', '/api/v1/components/groups');        $response->assertStatus(401);    }    public function test_cannot_create_component_group_without_data()    {        $this->beUser();        $this->doesntExpectEvents(ComponentGroupWasCreatedEvent::class);        $response = $this->json('POST', '/api/v1/components/groups');        $response->assertStatus(400);    }    public function test_can_create_new_component_group()    {        $this->beUser();        $this->expectsEvents(ComponentGroupWasCreatedEvent::class);        $response = $this->json('POST', '/api/v1/components/groups', [            'name'      => 'Foo',            'order'     => 1,            'collapsed' => 1,            'visible'   => ComponentGroup::VISIBLE_GUEST,        ]);        $response->assertStatus(200);        $response->assertJsonFragment([            'name'      => 'Foo',            'order'     => 1,            'collapsed' => 1,            'visible'   => ComponentGroup::VISIBLE_GUEST,        ]);    }    public function test_can_get_single_component_group()    {        $group = factory(ComponentGroup::class)->create();        $response = $this->json('GET', '/api/v1/components/groups/1');        $response->assertStatus(200);        $response->assertJsonFragment(['name' => $group->name]);    }    public function test_can_update_component_group()    {        $this->beUser();        $group = factory(ComponentGroup::class)->create();        $this->expectsEvents(ComponentGroupWasUpdatedEvent::class);        $response = $this->json('PUT', '/api/v1/components/groups/1', [            'name' => 'Lorem Ipsum Groupous',        ]);        $response->assertStatus(200);        $response->assertJsonFragment(['name' => 'Lorem Ipsum Groupous']);    }    public function test_can_delete_component_group()    {        $this->beUser();        $group = factory(ComponentGroup::class)->create();        $this->expectsEvents(ComponentGroupWasRemovedEvent::class);        $response = $this->json('DELETE', '/api/v1/components/groups/1');        $response->assertStatus(204);    }    public function test_only_public_component_groups_are_shown_for_a_guest()    {        $this->createComponentGroups();        $response = $this->json('GET', '/api/v1/components/groups');        $response->assertStatus(200);        $response->assertJsonFragment(['name' => self::COMPONENT_GROUP_1_NAME]);    }    public function test_all_component_groups_are_displayed_for_logged_in_users()    {        $this->createComponentGroups()            ->signIn();        $response = $this->json('GET', '/api/v1/components/groups');        $response->assertStatus(200);        $response->assertJsonFragment(['name' => self::COMPONENT_GROUP_1_NAME]);    }    /**     * Set up the needed data for the tests.     *     * @return $this     */    protected function createComponentGroups()    {        $this->createComponentGroup(self::COMPONENT_GROUP_1_NAME, ComponentGroup::VISIBLE_GUEST)            ->createComponentGroup(self::COMPONENT_GROUP_2_NAME, ComponentGroup::VISIBLE_AUTHENTICATED);        return $this;    }    /**     * Create a component group.     *     * Also attaches a creator if any given as a parameter or exists in the test class.     *     * @param string $name     * @param string $visible     *     * @return $this     */    protected function createComponentGroup($name, $visible)    {        factory(ComponentGroup::class)            ->create(['name' => $name, 'visible' => $visible]);        return $this;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
97,CachetHQ_Cachet_CreateComponentCommand_1165, This is the create component command class.\n\n @author James Brooks <james@alt-three.com>\n,Ovo je klasa koja pravi komponente naredbi.,"final class CreateComponentCommand{    /**     * The component name.     *     * @var string     */    public $name;    /**     * The component description.     *     * @var string     */    public $description;    /**     * The component status.     *     * @var int     */    public $status;    /**     * The component link.     *     * @var string     */    public $link;    /**     * The component order.     *     * @var int     */    public $order;    /**     * The component group.     *     * @var int     */    public $group_id;    /**     * Is the component enabled?     *     * @var bool     */    public $enabled;    /**     * JSON meta data for the component.     *     * @var array|null     */    public $meta;    /**     * Tags string.     *     * @var string     */    public $tags;    /**     * The validation rules.     *     * @var string[]     */    public $rules = [        'name'        => 'required|string',        'description' => 'nullable|string',        'status'      => 'required|int|min:0|max:4',        'link'        => 'nullable|url',        'order'       => 'nullable|int',        'group_id'    => 'nullable|int',        'enabled'     => 'nullable|bool',        'meta'        => 'nullable|array',        'tags'        => 'nullable|string',    ];    /**     * Create a new add component command instance.     *     * @param string      $name     * @param string      $description     * @param int         $status     * @param string      $link     * @param int         $order     * @param int         $group_id     * @param bool        $enabled     * @param array|null  $meta     * @param string|null $tags     *     * @return void     */    public function __construct($name, $description, $status, $link, $order, $group_id, $enabled, $meta, $tags = null)    {        $this->name = $name;        $this->description = $description;        $this->status = (int) $status;        $this->link = $link;        $this->order = $order;        $this->group_id = $group_id;        $this->enabled = $enabled;        $this->meta = $meta;        $this->tags = $tags;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
98,CachetHQ_Cachet_IncidentTemplateTest_1218, This is the incident template test class.\n\n @author Marc Hagen <hello@marchagen.nl>\n,Ovo je klasa koja ispituje šablon za incident. ,"class IncidentTemplateTest extends AbstractApiTestCase{    public function test_can_get_all_incident_templates()    {        $templates = factory(IncidentTemplate::class, 3)->create();        $response = $this->json('GET', '/api/v1/incidents/templates');        $response->assertJsonFragment(['id' => $templates[0]->id]);        $response->assertJsonFragment(['id' => $templates[1]->id]);        $response->assertJsonFragment(['id' => $templates[2]->id]);        $response->assertStatus(200);    }    public function test_cannot_get_invalid_incident_template()    {        $response = $this->json('GET', '/api/v1/incidents/templates/1');        $response->assertStatus(404);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
99,CachetHQ_Cachet_SmokeTest_1199, This is the smoke test class.\n\n @author James Brooks <james@alt-three.com>\n,Ovo je klasa za smoke testiranje.,"class SmokeTest extends AbstractTestCase{    use DatabaseMigrations;    public function test_setup_page()    {        $this->get('/setup')->assertStatus(200);    }    public function test_status_page()    {        $this->configureApp();        $this->get('/')->assertStatus(200);    }    public function test_single_component_page()    {        $this->configureApp();        $this->get('/incidents/1')->assertStatus(200);    }    public function test_dashboard_auth_page()    {        $this->configureApp();        $this->get('/auth/login')->assertStatus(200);    }    protected function configureApp()    {        factory(Setting::class)->create([            'name'  => 'app_name',            'value' => 'Cachet Test Suite',        ]);        $component = factory(Component::class)->create();        $incident = factory(Incident::class)->create([            'component_id' => $component->id,        ]);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
100,CachetHQ_Cachet_TestListener_1203, A failure occurred.\n,Prijavi grešku.,"    public function addFailure(Test $test, AssertionFailedError $e, float $time): void    {        //    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
101,CachetHQ_Cachet_TestListener_1205, Risky test.\n,Dodaj riskantan test.,"    public function addRiskyTest(Test $test, \Throwable $t, float $time): void    {        //    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
102,CachetHQ_Cachet_TestListener_1206, Skipped test.\n,Dodaj skipped test.,"    public function addSkippedTest(Test $test, \Throwable $t, float $time): void    {        //    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
103,CachetHQ_Cachet_TestListener_1207, A test suite started.\n,Pokreni testni paket.,    public function startTestSuite(TestSuite $suite): void    {        //    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
104,CachetHQ_Cachet_TestListener_1208, A test suite ended.\n,Završi testni paket.,"    public function endTestSuite(TestSuite $suite): void    {        if ($suite->getName() !== 'Cachet Test Suite') {            return;        }        foreach (glob(__DIR__.'/../bootstrap/cache{,t}/*.php', GLOB_BRACE) as $file) {            unlink($file);        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
105,CachetHQ_Cachet_TestListener_1209, A test started.\n,Pokreni test.,    public function startTest(Test $test): void    {        //    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
106,CachetHQ_Cachet_UpdateComponentGroupCommand_1171, Create a add component group command instance.\n\n @param \\CachetHQ\\Cachet\\Models\\ComponentGroup $group\n @param string                                 $name\n @param int                                    $order\n @param int                                    $collapsed\n @param int                                    $visible\n\n @return void\n,Kreiraj instancu naredbe za dodavanje grupe komponenata.,"    public function __construct(ComponentGroup $group, $name, $order, $collapsed, $visible)    {        $this->group = $group;        $this->name = $name;        $this->order = (int) $order;        $this->collapsed = $collapsed;        $this->visible = (int) $visible;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
107,CachetHQ_Cachet_helpers_1162, Darken a color.\n\n @param string $hex\n @param int    $percent\n\n @return string\n,Dohvati tamniju nijansu boje.,"    function color_darken($hex, $percent)    {        $hex = preg_replace('/[^0-9a-f]/i', '', $hex);        $new_hex = '#';        if (strlen($hex) < 6) {            $hex = $hex[0] + $hex[0] + $hex[1] + $hex[1] + $hex[2] + $hex[2];        }        for ($i = 0; $i < 3; $i++) {            $dec = hexdec(substr($hex, $i * 2, 2));            $dec = min(max(0, $dec + $dec * $percent), 255);            $new_hex .= str_pad(dechex($dec), 2, 0, STR_PAD_LEFT);        }        return $new_hex;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
108,DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_6667," Each concrete command is built with different receivers.\n There can be one, many or completely no receivers, but there can be other commands in the parameters.\n","Svaka konkretna naredba izgrađena je sa različitim prijemnicima. Moguće je proslediti jedan, više ili nijedan prijemnik kao parametar funkcije. Takođe mogu se javiti i druge komande kao parametri funkcije.",    public function __construct(private Receiver $output)    {    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
109,DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_7426, Undo the command and make receiver to disable displaying messages date.\n,Poništi poslednju komandu i napravi prijemnik koji će da onemogući prikazivanje datuma poruke.,"    public function undo()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->disableDate();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
110,DesignPatternsPHP_DesignPatternsPHP_EBookAdapter_6689, This class makes the proper translation from one interface to another.\n,Ova klasa omogućava odgovarajuću tranziciju iz jednog interfejsa u drugi.,    public function open()    {        $this->eBook->unlock();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
111,DesignPatternsPHP_DesignPatternsPHP_EBook_6687," returns current page and total number of pages, like [10, 100] is page 10 of 100\n\n @return int[]\n","Vraća trenutnu stranicu i ukupan broj stranica u formatu [10, 100] gde je 10 broj trenutne stranice od njih 100.",    public function getPage(): array;,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
112,DesignPatternsPHP_DesignPatternsPHP_Handler_6665, This approach by using a template method pattern ensures you that\n each subclass will not forget to call the successor\n,Korišćenjem šablonske metode osigurava se da će svaka podklasa pozvati i odgovarajuće metode nadklase.,    final public function handle(RequestInterface $request): ?string    {        $processed = $this->processing($request);        if ($processed === null && $this->successor !== null) {            // the request has not been processed by this handler => see the next            $processed = $this->successor->handle($request);        }        return $processed;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
113,DesignPatternsPHP_DesignPatternsPHP_HelloCommand_6398," This concrete command calls ""print"" on the Receiver, but an external\n invoker just knows that it can call ""execute""\n","Ova konkretna komanda poziva ""ispiši"" metodu na prijemniku. Tada će pozivalac znati da može da pozove ""izvrši"" metodu.","class HelloCommand implements Command{    /**     * Each concrete command is built with different receivers.     * There can be one, many or completely no receivers, but there can be other commands in the parameters     */    public function __construct(private Receiver $output)    {    }    /**     * execute and output ""Hello World"".     */    public function execute()    {        // sometimes, there is no receiver and this is the command which does all the work        $this->output->write('Hello World');    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
114,DesignPatternsPHP_DesignPatternsPHP_Invoker_6676, executes the command; the invoker is the same whatever is the command\n,Ova metoda izvršava komandu. Pozivalac je uvek isti bez obzira na tip komande.,    public function run()    {        $this->command->execute();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
115,DesignPatternsPHP_DesignPatternsPHP_Invoker_7047, Invoker is using the command given to it.\n Example : an Application in SF2.\n,Klasa pozivalac koristi komandu koja mi je prosleđena. Primer:  Aplikacija u SF2,"class Invoker{    private Command $command;    /**     * in the invoker we find this kind of method for subscribing the command     * There can be also a stack, a list, a fixed set ...     */    public function setCommand(Command $cmd)    {        $this->command = $cmd;    }    /**     * executes the command; the invoker is the same whatever is the command     */    public function run()    {        $this->command->execute();    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
116,DesignPatternsPHP_DesignPatternsPHP_Kindle_6418," this is the adapted class. In production code, this could be a class from another package, some vendor code.\n Notice that it uses another naming scheme and the implementation does something similar but in another way\n","Ovo je prilagođena klasa. U kodu za proizvodnju ovo može biti klasa iz drugog paketa, ili nekog vendor koda. Obrati pažnju da koristi drugu šemu imenovanja i da implementacija radi nešto slično samo na drugi način.","class Kindle implements EBook{    private int $page = 1;    private int $totalPages = 100;    public function pressNext()    {        $this->page++;    }    public function unlock()    {    }    /**     * returns current page and total number of pages, like [10, 100] is page 10 of 100     *     * @return int[]     */    public function getPage(): array    {        return [$this->page, $this->totalPages];    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
117,DesignPatternsPHP_DesignPatternsPHP_PostId_6411, This is a perfect example of a value object that is identifiable by it's value alone and\n is guaranteed to be valid each time an instance is created. Another important property of value objects\n is immutability.\n\n Notice also the use of a named constructor (fromInt) which adds a little context when creating an instance.\n,Ovo je odličan primer klase čiji objeki enkapsuliraju vrednost. Objekat je određen samom njegovom vrednošću i njegova validnost je zagarantovana prilikom kreiranja. Driga važna osobina vrednost objekta je nepromenljivost njegovog unutrašnjeg stanja. Obrati pažnju da se koristi imenovan konstruktor(iz int) koja pomalo utiče na kontekst prilikom kreiranja objekta.,class PostId{    public static function fromInt(int $id): PostId    {        self::ensureIsValid($id);        return new self($id);    }    private function __construct(private int $id)    {    }    public function toInt(): int    {        return $this->id;    }    private static function ensureIsValid(int $id)    {        if ($id <= 0) {            throw new InvalidArgumentException('Invalid PostId given');        }    }},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
118,DesignPatternsPHP_DesignPatternsPHP_PostRepository_6410, This class is situated between Entity layer (class Post) and access object layer (Persistence).\n\n Repository encapsulates the set of objects persisted in a data store and the operations performed over them\n providing a more object-oriented view of the persistence layer\n\n Repository also supports the objective of achieving a clean separation and one-way dependency\n between the domain and data mapping layers\n,Ova klasa predstavlja sponu između Entitet sloja (klasa Post) i sloja za pristup objektima (Baza podataka). Repository enkapsulira set objekata koji su smešteni u bazi podataka i operacije koje se izvršavaju nad njima. Ovakav pristup omogućava objektno orijentisanu realizaciju sloja za čuvanje podataka. On takođe doprinosi cilju jasnog razdvajanja logike  domena i sloja za mapiranje podataka i njihovu jednosmernu zavisnost. ,"class PostRepository{    public function __construct(private Persistence $persistence)    {    }    public function generateId(): PostId    {        return PostId::fromInt($this->persistence->generateId());    }    public function findById(PostId $id): Post    {        try {            $arrayData = $this->persistence->retrieve($id->toInt());        } catch (OutOfBoundsException $e) {            throw new OutOfBoundsException(sprintf('Post with id %d does not exist', $id->toInt()), 0, $e);        }        return Post::fromState($arrayData);    }    public function save(Post $post)    {        $this->persistence->persist([            'id' => $post->getId()->toInt(),            'statusId' => $post->getStatus()->toInt(),            'text' => $post->getText(),            'title' => $post->getTitle(),        ]);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
119,DesignPatternsPHP_DesignPatternsPHP_PostStatus_6685," Like PostId, this is a value object which holds the value of the current status of a Post. It can be constructed\n either from a string or int and is able to validate itself. An instance can then be converted back to int or string.\n","Ova klasa, kao i klasa Postid, enkapsulira vrednost u ovom slučaju vrednost statusa klase Post. Konstruiše se iz string ili int tipa pri čemu se vrši validacija kreiranog objekta. Instancirani objekat se može konvertovati nazad u int ili string.","class PostStatus{    const STATE_DRAFT_ID = 1;    const STATE_PUBLISHED_ID = 2;    const STATE_DRAFT = 'draft';    const STATE_PUBLISHED = 'published';    private static array $validStates = [        self::STATE_DRAFT_ID => self::STATE_DRAFT,        self::STATE_PUBLISHED_ID => self::STATE_PUBLISHED,    ];    public static function fromInt(int $statusId)    {        self::ensureIsValidId($statusId);        return new self($statusId, self::$validStates[$statusId]);    }    public static function fromString(string $status)    {        self::ensureIsValidName($status);        $state = array_search($status, self::$validStates);        if ($state === false) {            throw new InvalidArgumentException('Invalid state given!');        }        return new self($state, $status);    }    private function __construct(private int $id, private string $name)    {    }    public function toInt(): int    {        return $this->id;    }    /**     * there is a reason that I avoid using __toString() as it operates outside of the stack in PHP     * and is therefor not able to operate well with exceptions     */    public function toString(): string    {        return $this->name;    }    private static function ensureIsValidId(int $status)    {        if (!in_array($status, array_keys(self::$validStates), true)) {            throw new InvalidArgumentException('Invalid status id given');        }    }    private static function ensureIsValidName(string $status)    {        if (!in_array($status, self::$validStates, true)) {            throw new InvalidArgumentException('Invalid status name given');        }    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
120,DesignPatternsPHP_DesignPatternsPHP_Receiver_6405, Enable receiver to display message date\n,Omogući prijemniku da prikaže datum poruke.,    public function enableDate()    {        $this->enableDate = true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
121,DesignPatternsPHP_DesignPatternsPHP_Receiver_6679, Disable receiver to display message date\n,Onemogući prijemniku da prikaže datum poruke.,    public function disableDate()    {        $this->enableDate = false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
122,DesignPatternsPHP_DesignPatternsPHP_Receiver_7050, Receiver is a specific service with its own contract and can be only concrete.\n,Klasa prijemnik je specfičan servis koji poseduje sopstveni ugovor i može biti jedino konkretan.,"class Receiver{    private bool $enableDate = false;    /**     * @var string[]     */    private array $output = [];    public function write(string $str)    {        if ($this->enableDate) {            $str .= ' ['.date('Y-m-d').']';        }        $this->output[] = $str;    }    public function getOutput(): string    {        return join(""\n"", $this->output);    }    /**     * Enable receiver to display message date     */    public function enableDate()    {        $this->enableDate = true;    }    /**     * Disable receiver to display message date     */    public function disableDate()    {        $this->enableDate = false;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
123,DesignPatternsPHP_DesignPatternsPHP_UndoableCommand_6680, This method is used to undo change made by command execution\n,Ova metoda se koristi da poništi promenu izazvana izvršavanjem poslednje komande.,    public function undo();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
124,FriendsOfPHP_PHP-CS-Fixer_AbstractDoctrineAnnotationFixer_7624, Fixes Doctrine annotations from the given PHPDoc style comment.\n,Ispravlja anotacije doktrine u datom PHPDoc komentaru.,    abstract protected function fixAnnotations(DoctrineAnnotationTokens $doctrineAnnotationTokens): void;,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
125,FriendsOfPHP_PHP-CS-Fixer_AbstractLinesBeforeNamespaceFixer_6607, Make sure # of line breaks prefixing namespace is within given range.\n\n @param int $expectedMin min. # of line breaks\n @param int $expectedMax max. # of line breaks\n,Osiguraj da je # prelamanje linije koji predhodi prefiksu prostora imena u datom opsegu.  ,"    protected function fixLinesBeforeNamespace(Tokens $tokens, int $index, int $expectedMin, int $expectedMax): void    {        // Let's determine the total numbers of new lines before the namespace        // and the opening token        $openingTokenIndex = null;        $precedingNewlines = 0;        $newlineInOpening = false;        $openingToken = null;        for ($i = 1; $i <= 2; ++$i) {            if (isset($tokens[$index - $i])) {                $token = $tokens[$index - $i];                if ($token->isGivenKind(T_OPEN_TAG)) {                    $openingToken = $token;                    $openingTokenIndex = $index - $i;                    $newlineInOpening = false !== strpos($token->getContent(), ""\n"");                    if ($newlineInOpening) {                        ++$precedingNewlines;                    }                    break;                }                if (false === $token->isGivenKind(T_WHITESPACE)) {                    break;                }                $precedingNewlines += substr_count($token->getContent(), ""\n"");            }        }        if ($precedingNewlines >= $expectedMin && $precedingNewlines <= $expectedMax) {            return;        }        $previousIndex = $index - 1;        $previous = $tokens[$previousIndex];        if (0 === $expectedMax) {            // Remove all the previous new lines            if ($previous->isWhitespace()) {                $tokens->clearAt($previousIndex);            }            // Remove new lines in opening token            if ($newlineInOpening) {                $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, rtrim($openingToken->getContent()).' ']);            }            return;        }        $lineEnding = $this->whitespacesConfig->getLineEnding();        $newlinesForWhitespaceToken = $expectedMax;        if (null !== $openingToken) {            // Use the configured line ending for the PHP opening tag            $content = rtrim($openingToken->getContent());            $newContent = $content.$lineEnding;            $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, $newContent]);            --$newlinesForWhitespaceToken;        }        if (0 === $newlinesForWhitespaceToken) {            // We have all the needed new lines in the opening tag            if ($previous->isWhitespace()) {                // Let's remove the previous token containing extra new lines                $tokens->clearAt($previousIndex);            }            return;        }        if ($previous->isWhitespace()) {            // Fix the previous whitespace token            $tokens[$previousIndex] = new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken).substr($previous->getContent(), strrpos($previous->getContent(), ""\n"") + 1)]);        } else {            // Add a new whitespace token            $tokens->insertAt($index, new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken)]));        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
126,FriendsOfPHP_PHP-CS-Fixer_AbstractLinesBeforeNamespaceFixer_7636, This abstract fixer is responsible for ensuring that a certain number of\n lines prefix a namespace declaration.\n\n @author Graham Campbell <graham@alt-three.com>\n\n @internal\n,Ova apstraktna klasa popravljača je odgovorana da se broj linija koja predhodi deklaraciji prostora imena ograniči na određeni broj.,"abstract class AbstractLinesBeforeNamespaceFixer extends AbstractFixer implements WhitespacesAwareFixerInterface{    /**     * Make sure # of line breaks prefixing namespace is within given range.     *     * @param int $expectedMin min. # of line breaks     * @param int $expectedMax max. # of line breaks     */    protected function fixLinesBeforeNamespace(Tokens $tokens, int $index, int $expectedMin, int $expectedMax): void    {        // Let's determine the total numbers of new lines before the namespace        // and the opening token        $openingTokenIndex = null;        $precedingNewlines = 0;        $newlineInOpening = false;        $openingToken = null;        for ($i = 1; $i <= 2; ++$i) {            if (isset($tokens[$index - $i])) {                $token = $tokens[$index - $i];                if ($token->isGivenKind(T_OPEN_TAG)) {                    $openingToken = $token;                    $openingTokenIndex = $index - $i;                    $newlineInOpening = false !== strpos($token->getContent(), ""\n"");                    if ($newlineInOpening) {                        ++$precedingNewlines;                    }                    break;                }                if (false === $token->isGivenKind(T_WHITESPACE)) {                    break;                }                $precedingNewlines += substr_count($token->getContent(), ""\n"");            }        }        if ($precedingNewlines >= $expectedMin && $precedingNewlines <= $expectedMax) {            return;        }        $previousIndex = $index - 1;        $previous = $tokens[$previousIndex];        if (0 === $expectedMax) {            // Remove all the previous new lines            if ($previous->isWhitespace()) {                $tokens->clearAt($previousIndex);            }            // Remove new lines in opening token            if ($newlineInOpening) {                $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, rtrim($openingToken->getContent()).' ']);            }            return;        }        $lineEnding = $this->whitespacesConfig->getLineEnding();        $newlinesForWhitespaceToken = $expectedMax;        if (null !== $openingToken) {            // Use the configured line ending for the PHP opening tag            $content = rtrim($openingToken->getContent());            $newContent = $content.$lineEnding;            $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, $newContent]);            --$newlinesForWhitespaceToken;        }        if (0 === $newlinesForWhitespaceToken) {            // We have all the needed new lines in the opening tag            if ($previous->isWhitespace()) {                // Let's remove the previous token containing extra new lines                $tokens->clearAt($previousIndex);            }            return;        }        if ($previous->isWhitespace()) {            // Fix the previous whitespace token            $tokens[$previousIndex] = new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken).substr($previous->getContent(), strrpos($previous->getContent(), ""\n"") + 1)]);        } else {            // Add a new whitespace token            $tokens->insertAt($index, new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken)]));        }    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
127,FriendsOfPHP_PHP-CS-Fixer_AbstractNoUselessElseFixer_6883," Return the first and last token index of the previous block.\n\n [0] First is either T_IF, T_ELSE or T_ELSEIF\n [1] Last is either '}' or ';' / T_CLOSE_TAG for short notation blocks\n\n @param int $index T_IF, T_ELSE, T_ELSEIF\n\n @return int[]\n","Vrati prvi i poslednji indeks tokena predhodnog bloka. Prvi je T_IF, T_ELSE, ili T_ELSEIF a poslednji '}' ili ';'. T_CLOSE_TAG koristi se za kratke blokove notacije.","    private function getPreviousBlock(Tokens $tokens, int $index): array    {        $close = $previous = $tokens->getPrevMeaningfulToken($index);        // short 'if' detection        if ($tokens[$close]->equals('}')) {            $previous = $tokens->findBlockStart(Tokens::BLOCK_TYPE_CURLY_BRACE, $close);        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
128,FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_6892, This abstract fixer provides a base for fixers to fix types in PHPDoc.\n\n @author Graham Campbell <graham@alt-three.com>\n\n @internal\n,Abstraktna klasa popravljač predstavlja osnovnu klasu za popravljače čiji zadatak će biti ispravljanje tipova u PHPDoc.,"abstract class AbstractPhpdocTypesFixer extends AbstractFixer{    /**     * The annotation tags search inside.     *     * @var string[]     */    protected $tags;    /**     * {@inheritdoc}     */    public function __construct()    {        parent::__construct();        $this->tags = Annotation::getTagsWithTypes();    }    /**     * {@inheritdoc}     */    public function isCandidate(Tokens $tokens): bool    {        return $tokens->isTokenKindFound(T_DOC_COMMENT);    }    /**     * {@inheritdoc}     */    protected function applyFix(\SplFileInfo $file, Tokens $tokens): void    {        foreach ($tokens as $index => $token) {            if (!$token->isGivenKind(T_DOC_COMMENT)) {                continue;            }            $doc = new DocBlock($token->getContent());            $annotations = $doc->getAnnotationsOfType($this->tags);            if (empty($annotations)) {                continue;            }            foreach ($annotations as $annotation) {                $this->fixTypes($annotation);            }            $tokens[$index] = new Token([T_DOC_COMMENT, $doc->getContent()]);        }    }    /**     * Actually normalize the given type.     */    abstract protected function normalize(string $type): string;    /**     * Fix the types at the given line.     *     * We must be super careful not to modify parts of words.     *     * This will be nicely handled behind the scenes for us by the annotation class.     */    private function fixTypes(Annotation $annotation): void    {        $types = $annotation->getTypes();        $new = $this->normalizeTypes($types);        if ($types !== $new) {            $annotation->setTypes($new);        }    }    /**     * @param string[] $types     *     * @return string[]     */    private function normalizeTypes(array $types): array    {        foreach ($types as $index => $type) {            $types[$index] = $this->normalizeType($type);        }        return $types;    }    /**     * Prepare the type and normalize it.     */    private function normalizeType(string $type): string    {        if ('[]' === substr($type, -2)) {            return $this->normalizeType(substr($type, 0, -2)).'[]';        }        return $this->normalize($type);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
129,FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_6896, Actually normalize the given type.\n,Normalizuj vrednost datog tipa.,    abstract protected function normalize(string $type): string;,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
130,FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_6899, Prepare the type and normalize it.\n,Pripremi tip i normalizuj ga.,"    private function normalizeType(string $type): string    {        if ('[]' === substr($type, -2)) {            return $this->normalizeType(substr($type, 0, -2)).'[]';        }        return $this->normalize($type);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
131,Intervention_image_AbstractColor_403, Initiates color object from integer\\\\n\\\\n @param  int $value\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n,Inicijalizuj objekat boje iz celog broja.,    abstract public function initFromInteger($value);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
132,Intervention_image_AbstractColor_404, Initiates color object from given array\\n\\n @param  array $value\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n,Inicijalizuj objekat boje iz datog niza.,    abstract public function initFromArray($value);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
133,Intervention_image_AbstractColor_405, Initiates color object from given string\\\\n\\\\n @param  string $value\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n,Inicijalizuj objekat boje iz datog stringa.,    abstract public function initFromString($value);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
134,Intervention_image_AbstractColor_407," Initiates color object from given R, G and B values\\n\\n @param  int $r\\n @param  int $g\\n @param  int $b\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n","Inicijalizuj objekat boje iz datog R, G i B vrednosti.","    abstract public function initFromRgb($r, $g, $b);",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
135,Intervention_image_AbstractColor_408," Initiates color object from given R, G, B and A values\n\n @param  int $r\n @param  int $g\n @param  int $b\n @param  float   $a\n @return \\Intervention\\Image\\AbstractColor\n","Inicijalizuj objekat boje iz datog R, G, B i A vrednosti.","    abstract public function initFromRgba($r, $g, $b, $a);",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
136,Intervention_image_AbstractColor_409, Calculates integer value of current color instance\n\n @return int\n,Dohvati int vrednost trenutne instance boje.,    abstract public function getInt();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
137,Intervention_image_AbstractColor_410, Calculates hexadecimal value of current color instance\\n\\n @param  string $prefix\\n @return string\\n,Dohvati heksadecimalnu vrednost trnutne instance boje.,    abstract public function getHex($prefix);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
138,Intervention_image_AbstractColor_412, Calculates RGBA in string format of current color instance\n\n @return string\n,Dohvati RGBA vrednosti u string formatu trenutne instance boje.,    abstract public function getRgba();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
139,Intervention_image_AbstractCommand_535, Executes current command on given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return mixed\\n,Izvrši trenuntu komandu na priloženoj slici.,    abstract public function execute($image);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
140,Intervention_image_AbstractCommand_536, Creates new command instance\\\\n\\\\n @param array $arguments\\\\n,Kreiraj novu instancu komande.,    public function __construct($arguments)    {        $this->arguments = $arguments;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
141,Intervention_image_AbstractCommand_538, Returns output data of current command\\n\\n @return mixed\\n,Dohvati izlazne podatke trenutne komande.,    public function getOutput()    {        return $this->output ? $this->output : null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
142,Intervention_image_AbstractCommand_539, Determines if current instance has output data\\\\n\\\\n @return boolean\\\\n,Odredi da li trenutna instanca komande ima izlazne podatke.,    public function hasOutput()    {        return ! is_null($this->output);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
143,Intervention_image_AbstractCommand_540, Sets output data of current command\\n\\n @param mixed $value\\n,Postavi izlazne podatke trenutne komade.,    public function setOutput($value)    {        $this->output = $value;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
144,Intervention_image_AbstractDecoder_416, Initiates new image from path in filesystem\n\n @param  string $path\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku sa date putanje u fajl sistemu.,    abstract public function initFromPath($path);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
145,Intervention_image_AbstractDecoder_417, Initiates new image from binary data\\n\\n @param  string $data\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicijalizuj novu sliku iz binarnog podatka.,    abstract public function initFromBinary($data);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
146,Intervention_image_AbstractDecoder_420, Init from given URL\\n\\n @param  string $url\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicijalizuj sliku iz datog URL-a,"    public function initFromUrl($url)    {                $options = [            'http' => [                'method'=>""GET"",                'header'=>""Accept-language: en\r\n"".                ""User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1216.0 Safari/537.2\r\n""          ]        ];                $context  = stream_context_create($options);                if ($data = @file_get_contents($url, false, $context)) {            return $this->initFromBinary($data);        }        throw new NotReadableException(            ""Unable to init from given url ("".$url."").""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
147,Intervention_image_AbstractDecoder_422, Determines if current source data is GD resource\n\n @return boolean\n,Odredi da li je trenutan izvor podatka slike iz GD resursa.,    public function isGdResource()    {        if (is_resource($this->data)) {            return (get_resource_type($this->data) == 'gd');        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
148,Intervention_image_AbstractDecoder_424, Determines if current source data is Intervention\\\\Image\\\\Image object\\n\\n @return boolean\\n,Odredi da li je trenutan izvor podatka slike intervencija.,"    public function isInterventionImage()    {        return is_a($this->data, '\Intervention\Image\Image');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
149,Intervention_image_AbstractDecoder_426, Determines if current data is Symfony UploadedFile component\\\\n\\\\n @return boolean\\\\n,Odredi da li je trenutan podatak Simfonijski UploadFile komponenta.,"    public function isSymfonyUpload()    {        return is_a($this->data, 'Symfony\Component\HttpFoundation\File\UploadedFile');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
150,Intervention_image_AbstractDecoder_428, Determines if current source data is url\n\n @return boolean\n,Odredi da li je trenutni izvor podatka slike url.,"    public function isUrl()    {        return (bool) filter_var($this->data, FILTER_VALIDATE_URL);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
151,Intervention_image_AbstractDecoder_429, Determines if current source data is a stream resource\\n\\n @return boolean\\n,Odredi da li je trenutni izvor podatka slike resurs toka.,    public function isStream()    {        if ($this->data instanceof StreamInterface) return true;        if (!is_resource($this->data)) return false;        if (get_resource_type($this->data) !== 'stream') return false;        return true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
152,Intervention_image_AbstractDecoder_430, Determines if current source data is binary data\\n\\n @return boolean\\n,Odredi da li je trenutni izvor podatka slike binaran podatak.,"    public function isBinary()    {        if (is_string($this->data)) {            $mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $this->data);            return (substr($mime, 0, 4) != 'text' && $mime != 'application/x-empty');        }        return false;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
153,Intervention_image_AbstractDecoder_431, Determines if current source data is data-url\\\\n\\\\n @return boolean\\\\n,Odredi da li je trenutni izvor podatka slike podatak url.,    public function isDataUrl()    {        $data = $this->decodeDataUrl($this->data);        return is_null($data) ? false : true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
154,Intervention_image_AbstractDecoder_432, Determines if current source data is base64 encoded\n\n @return boolean\n,Odreid da li je trenutan izvor podatka primenjuje base64 šifrovanje.,"    public function isBase64()    {        if (!is_string($this->data)) {            return false;        }        return base64_encode(base64_decode($this->data)) === str_replace([""\n"", ""\r""], '', $this->data);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
155,Intervention_image_AbstractDecoder_433, Initiates new Image from Intervention\\\\\\\\Image\\\\\\\\Image\\\\n\\\\n @param  Image $object\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Inicijalizuj novu sliku iz objekta Intervencije.,    public function initFromInterventionImage($object)    {        return $object;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
156,Intervention_image_AbstractDecoder_434, Parses and decodes binary image data from data-url\\\\n\\\\n @param  string $data_url\\\\n @return string\\\\n,Parsiraj i dekoduj sliku binarne ekstenzije određenog url podatkom.,"    private function decodeDataUrl($data_url)    {        if (!is_string($data_url)) {            return null;        }        $pattern = ""/^data:(?:image\/[a-zA-Z\-\.]+)(?:charset=\"".+\"")?;base64,(?P<data>.+)$/"";        preg_match($pattern, $data_url, $matches);        if (is_array($matches) && array_key_exists('data', $matches)) {            return base64_decode($matches['data']);        }        return null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
157,Intervention_image_AbstractDecoder_435, Initiates new image from mixed data\\n\\n @param  mixed $data\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicijalizuj novu sliku iz mešovitih podataka.,"    public function init($data)    {        $this->data = $data;        switch (true) {            case $this->isGdResource():                return $this->initFromGdResource($this->data);            case $this->isImagick():                return $this->initFromImagick($this->data);            case $this->isInterventionImage():                return $this->initFromInterventionImage($this->data);            case $this->isSplFileInfo():                return $this->initFromPath($this->data->getRealPath());            case $this->isBinary():                return $this->initFromBinary($this->data);            case $this->isUrl():                return $this->initFromUrl($this->data);            case $this->isStream():                return $this->initFromStream($this->data);            case $this->isDataUrl():                return $this->initFromBinary($this->decodeDataUrl($this->data));            case $this->isFilePath():                return $this->initFromPath($this->data);            // isBase64 has to be after isFilePath to prevent false positives            case $this->isBase64():                return $this->initFromBinary(base64_decode($this->data));            default:                throw new NotReadableException(""Image source not readable"");        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
158,Intervention_image_AbstractDecoder_436, Decoder object transforms to string source data\\\\n\\\\n @return string\\\\n,Transofmiši objekat dekodera u string izvorni podatak.,    public function __toString()    {        return (string) $this->data;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
159,Intervention_image_AbstractDriver_437, Creates new image instance\\n\\n @param  int     $width\\n @param  int     $height\\n @param  string  $background\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Kreiraj novu instancu slike.,"    abstract public function newImage($width, $height, $background);",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
160,Intervention_image_AbstractDriver_439, Checks if core module installation is available\n\n @return boolean\n,Proveri da li je dostupna instalacija osnovnog modula. ,    abstract protected function coreAvailable();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
161,Intervention_image_AbstractDriver_440, Returns clone of given core\n\n @return mixed\n,Dohvati kloniran podatak jezgra.,    public function cloneCore($core)    {        return clone $core;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
162,Intervention_image_AbstractDriver_441, Initiates new image from given input\\\\n\\\\n @param  mixed $data\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Inicijalizuj novu sliku iz datog ulaznog podatka.,    public function init($data)    {        return $this->decoder->init($data);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
163,Intervention_image_AbstractDriver_442, Encodes given image\\\\n\\\\n @param  Image   $image\\\\n @param  string  $format\\\\n @param  int     $quality\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Šifriraj datu sliku.,"    public function encode($image, $format, $quality)    {        return $this->encoder->process($image, $format, $quality);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
164,Intervention_image_AbstractDriver_443, Executes named command on given image\\\\n\\\\n @param  Image  $image\\\\n @param  string $name\\\\n @param  array $arguments\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Commands\\\\\\\\AbstractCommand\\\\n,"Izvrši komandu, označenu imenom, nad slikom.","    public function executeCommand($image, $name, $arguments)    {        $commandName = $this->getCommandClassName($name);        $command = new $commandName($arguments);        $command->execute($image);        return $command;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
165,Intervention_image_AbstractEncoder_452, Processes and returns image as WebP encoded string\\\\n\\\\n @return string\\\\n,Precesuiraj i vrati sliku kao WebP enkodovan string.,    abstract protected function processWebp();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
166,Intervention_image_AbstractEncoder_454, Sets image to process\\n\\n @param Image $image\\n,Postavi sliku za procesuiranje.,    protected function setImage($image)    {        $this->image = $image;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
167,Intervention_image_AbstractFont_456, Calculates bounding box of current font setting\n\n @return array\n,Proračunaj ivice kutije za podešavanja fonta.,    abstract public function getBoxSize();,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
168,Intervention_image_AbstractFont_458, Get text to be written\\\\n\\\\n @return String\\\\n,Dohvati text za ispisivanje.,    public function getText()    {        return $this->text;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
169,Intervention_image_AbstractFont_459, Set font size in pixels\\n\\n @param  int $size\\n @return void\\n,Dohvati veličinu fonta u pikselima.,    public function size($size)    {        $this->size = $size;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
170,Intervention_image_AbstractFont_461, Set color of text to be written\\n\\n @param  mixed $color\\n @return void\\n,Postavi boju teksta za ispisivanje.,    public function color($color)    {        $this->color = $color;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
171,Intervention_image_AbstractFont_462, Get color of text\n\n @return mixed\n,Dohvati boju teksta.,    public function getColor()    {        return $this->color;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
172,Intervention_image_AbstractFont_464, Get rotation angle of text\n\n @return int\n,Dohvati ugao rotacije teksta.,    public function getAngle()    {        return $this->angle;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
173,Intervention_image_AbstractFont_467, Set vertical text alignment\n\n @param  string $valign\n @return void\n,Postavi vertikalno poravnanje teksta.,    public function valign($valign)    {        $this->valign = $valign;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
174,Intervention_image_AbstractFont_469, Set path to font file\\n\\n @param  string $file\\n @return void\\n,Postavi putanju do font datoteke.,    public function file($file)    {        $this->file = $file;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
175,Intervention_image_AbstractFont_470, Get path to font file\\n\\n @return string\\n,Dohvati putanju font datoteke.,    public function getFile()    {        return $this->file;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
176,Intervention_image_AbstractFont_471, Checks if current font has access to an applicable font file\\\\n\\\\n @return boolean\\\\n,Proveri da li trenutno izabrani font ima pristup primenjivom fajlu fonta.,    protected function hasApplicableFontFile()    {        if (is_string($this->file)) {            return file_exists($this->file);        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
177,Intervention_image_AbstractFont_472, Counts lines of text to be written\\\\n\\\\n @return int\\\\n,Izbroji linije teksta za ispisivanje.,"    public function countLines()    {        return count(explode(PHP_EOL, $this->text));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
178,Intervention_image_Argument_542, Defines current argument as required\\n\\n @return \\\\Intervention\\\\Image\\\\Commands\\\\Argument\\n,Definiši trenutni argument kao neophodan.,"    public function required()    {        if ( ! array_key_exists($this->key, $this->command->arguments)) {            throw new InvalidArgumentException(                sprintf(""Missing argument %d for %s"", $this->key + 1, $this->getCommandName())            );        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
179,Intervention_image_Argument_545, Determines that current argument must be over a minimum value\n\n @return \\Intervention\\Image\\Commands\\Argument\n,Obezbedi da argument funkcije mora biti veći od minimalne zadate vrednost.,"    public function min($value)    {        $v = $this->type('numeric')->value();        if (is_null($v)) {            return $this;        }        if ($v < $value) {            throw new InvalidArgumentException(                sprintf('Argument %d must be at least %s.', $this->key, $value)            );        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
180,Intervention_image_Argument_546, Determines that current argument must be under a maxiumum value\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Commands\\\\\\\\Argument\\\\n,Obezbedi da argument funkcije mora biti manji od maksimalne zadate vrednost.,"    public function max($value)    {        $v = $this->type('numeric')->value();        if (is_null($v)) {            return $this;        }        if ($v > $value) {            throw new InvalidArgumentException(                sprintf('Argument %d may not be greater than %s.', $this->key, $value)            );        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
181,Intervention_image_Argument_547," Checks if value is ""PHP"" integer (120 but also 120.0)\\n\\n @param  mixed $value\\n @return boolean\\n","Proveri da li je vrednost ""PHP"" int tipa. (120 ali i 120.0)",    private function isDigit($value)    {        return is_numeric($value) ? intval($value) == $value : false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
182,Intervention_image_BlurCommand_594, Applies blur effect on image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Primeni blur efekat na slici.,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(1);        for ($i=0; $i < intval($amount); $i++) {            imagefilter($image->getCore(), IMG_FILTER_GAUSSIAN_BLUR);        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
183,Intervention_image_BrightnessCommand_595, Changes image brightness\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni osvetljenje slike.,"    public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return imagefilter($image->getCore(), IMG_FILTER_BRIGHTNESS, ($level * 2.55));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
184,Intervention_image_ChecksumCommand_548, Calculates checksum of given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Proračunaj kontrolnu sumu date slike.,"    public function execute($image)    {        $colors = [];        $size = $image->getSize();        for ($x=0; $x <= ($size->width-1); $x++) {            for ($y=0; $y <= ($size->height-1); $y++) {                $colors[] = $image->pickColor($x, $y, 'array');            }        }        $this->setOutput(md5(serialize($colors)));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
185,Intervention_image_CircleCommand_549, Draw a circle centered on given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\image $image\\\\n @return boolean\\\\n,Nacrtaj krug sa centrom u datoj slici.,"    public function execute($image)    {        $diameter = $this->argument(0)->type('numeric')->required()->value();        $x = $this->argument(1)->type('numeric')->required()->value();        $y = $this->argument(2)->type('numeric')->required()->value();        $callback = $this->argument(3)->type('closure')->value();        $circle_classname = sprintf('\Intervention\Image\%s\Shapes\CircleShape',            $image->getDriver()->getDriverName());        $circle = new $circle_classname($diameter);        if ($callback instanceof Closure) {            $callback($circle);        }        $circle->applyToImage($image, $x, $y);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
186,Intervention_image_Color_564, Initiates color object from integer\\n\\n @param  int $value\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n,Inicijalizuj objekat boje objekta iz zadate int vrednosti.,    public function initFromInteger($value)    {        $this->a = ($value >> 24) & 0xFF;        $this->r = ($value >> 16) & 0xFF;        $this->g = ($value >> 8) & 0xFF;        $this->b = $value & 0xFF;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
187,Intervention_image_Color_565, Initiates color object from given array\\\\n\\\\n @param  array $value\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n,Inicijalizuj objekat boje iz datog niza.,"    public function initFromArray($array)    {        $array = array_values($array);        if (count($array) == 4) {            // color array with alpha value            list($r, $g, $b, $a) = $array;            $this->a = $this->alpha2gd($a);        } elseif (count($array) == 3) {            // color array without alpha value            list($r, $g, $b) = $array;            $this->a = 0;        }        $this->r = $r;        $this->g = $g;        $this->b = $b;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
188,Intervention_image_Color_567," Initiates color object from given R, G and B values\\\\n\\\\n @param  int $r\\\\n @param  int $g\\\\n @param  int $b\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n","Inicijalizuj objekat boje iz datog R, G i B vrednosti.","    public function initFromRgb($r, $g, $b)    {        $this->r = intval($r);        $this->g = intval($g);        $this->b = intval($b);        $this->a = 0;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
189,Intervention_image_Color_568, Initiates color object from given ImagickPixel object\n\n @param  ImagickPixel $value\n @return \\Intervention\\Image\\AbstractColor\n,Inicijalizuj boju objekta iz datog ImagickPixel objekta.,"    public function initFromObject($value)    {        throw new NotSupportedException(            ""GD colors cannot init from ImagickPixel objects.""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
190,Intervention_image_Color_569, Calculates integer value of current color instance\\\\n\\\\n @return int\\\\n,Dohvati int vrednost trenutne instance boje.,    public function getInt()    {        return ($this->a << 24) + ($this->r << 16) + ($this->g << 8) + $this->b;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
191,Intervention_image_Color_571, Calculates RGBA in string format of current color instance\n\n @return string\n,Dohvati RGBA vrednosti u string formatu trenutne instance boje.,"    public function getRgba()    {        return sprintf('rgba(%d, %d, %d, %.2F)', $this->r, $this->g, $this->b, round(1 - $this->a / 127, 2));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
192,Intervention_image_Color_629, Initiates color object from given string\n\n @param  string $value\n\n @return \\Intervention\\Image\\AbstractColor\n,Inicijalizuj objekat boje iz datog stringa.,"    public function initFromString($value)    {        if ($color = $this->rgbaFromString($value)) {            $this->setPixel($color[0], $color[1], $color[2], $color[3]);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
193,Intervention_image_Color_631," Initiates color object from given R, G and B values\\n\\n @param  int $r\\n @param  int $g\\n @param  int $b\\n\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n","Inicijalizuj objekat boje iz datog R, G i B vrednosti.","    public function initFromRgb($r, $g, $b)    {        $this->setPixel($r, $g, $b);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
194,Intervention_image_Color_633, Calculates integer value of current color instance\\\\n\\\\n @return int\\\\n,Dohvati int vrednost trenutne instance boje.,    public function getInt()    {        $r = $this->getRedValue();        $g = $this->getGreenValue();        $b = $this->getBlueValue();        $a = intval(round($this->getAlphaValue() * 255));        return intval(($a << 24) + ($r << 16) + ($g << 8) + $b);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
195,Intervention_image_Color_635, Calculates RGBA in string format of current color instance\n\n @return string\n,Dohvati RGBA vrednosti u string formatu trenutne instance boje.,"    public function getRgba()    {        return sprintf('rgba(%d, %d, %d, %.2F)',            $this->getRedValue(),            $this->getGreenValue(),            $this->getBlueValue(),            $this->getAlphaValue()        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
196,Intervention_image_Color_636, Returns RGB red value of current color\\n\\n @return int\\n,Dohvati nijansu crvene trenutne boje.,    public function getRedValue()    {        return intval(round($this->pixel->getColorValue(\Imagick::COLOR_RED) * 255));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
197,Intervention_image_Color_637, Returns RGB green value of current color\\\\n\\\\n @return int\\\\n,Dohvati nijansu zelene trenutne boje.,    public function getGreenValue()    {        return intval(round($this->pixel->getColorValue(\Imagick::COLOR_GREEN) * 255));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
198,Intervention_image_Color_638, Returns RGB blue value of current color\\\\n\\\\n @return int\\\\n,Dohvati nijansu plave trenutne boje.,    public function getBlueValue()    {        return intval(round($this->pixel->getColorValue(\Imagick::COLOR_BLUE) * 255));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
199,Intervention_image_Color_640, Returns current color as ImagickPixel\\\\n\\\\n @return \\\\\\\\ImagickPixel\\\\n,Dohvati trenutnu boju kao ImagickPixel,    public function getPixel()    {        return $this->pixel;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
200,Intervention_image_ColorizeCommand_660, Changes balance of different RGB color channels\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni ujednačenost osnovnih elemenata RGB boje.,"    public function execute($image)    {        $red = $this->argument(0)->between(-100, 100)->required()->value();        $green = $this->argument(1)->between(-100, 100)->required()->value();        $blue = $this->argument(2)->between(-100, 100)->required()->value();        // normalize colorize levels        $red = $this->normalizeLevel($red);        $green = $this->normalizeLevel($green);        $blue = $this->normalizeLevel($blue);        $qrange = $image->getCore()->getQuantumRange();        // apply        $image->getCore()->levelImage(0, $red, $qrange['quantumRangeLong'], \Imagick::CHANNEL_RED);        $image->getCore()->levelImage(0, $green, $qrange['quantumRangeLong'], \Imagick::CHANNEL_GREEN);        $image->getCore()->levelImage(0, $blue, $qrange['quantumRangeLong'], \Imagick::CHANNEL_BLUE);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
201,Intervention_image_Constraint_476, Returns current size of constraint\\n\\n @return \\\\Intervention\\\\Image\\\\Size\\n,Dohvati trenutnu veličinu ograničenja.,    public function getSize()    {        return $this->size;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
202,Intervention_image_Constraint_477, Fix the given argument in current constraint\\n\\n @param  int $type\\n @return void\\n,Ispravi argument trenutnim ograničenjem.,    public function fix($type)    {        $this->fixed = ($this->fixed & ~(1 << $type)) | (1 << $type);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
203,Intervention_image_Constraint_478, Checks if given argument is fixed in current constraint\n\n @param  int  $type\n @return boolean\n,Proveri da li je dati argument ispravljen sa trenutnim ograničenjem.,    public function isFixed($type)    {        return (bool) ($this->fixed & (1 << $type));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
204,Intervention_image_ContrastCommand_661, Changes contrast of image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni kontrast slike.,"    public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return $image->getCore()->sigmoidalContrastImage($level > 0, $level / 4, 0);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
205,Intervention_image_Decoder_573, Initiates new image from path in filesystem\n\n @param  string $path\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku sa date putanje u fajl sistemu.,"    public function initFromPath($path)    {        if ( ! file_exists($path)) {            throw new NotReadableException(                ""Unable to find file ({$path}).""            );        }        // get mime type of file        $mime = finfo_file(finfo_open(FILEINFO_MIME_TYPE), $path);        // define core        switch (strtolower($mime)) {            case 'image/png':            case 'image/x-png':                $core = @imagecreatefrompng($path);                break;            case 'image/jpg':            case 'image/jpeg':            case 'image/pjpeg':                $core = @imagecreatefromjpeg($path);                if (!$core) {                    $core= @imagecreatefromstring(file_get_contents($path));                }                break;            case 'image/gif':                $core = @imagecreatefromgif($path);                break;            case 'image/webp':            case 'image/x-webp':                if ( ! function_exists('imagecreatefromwebp')) {                    throw new NotReadableException(                        ""Unsupported image type. GD/PHP installation does not support WebP format.""                    );                }                $core = @imagecreatefromwebp($path);                break;            default:                throw new NotReadableException(                    ""Unsupported image type. GD driver is only able to decode JPG, PNG, GIF or WebP files.""                );        }        if (empty($core)) {            throw new NotReadableException(                ""Unable to decode image from file ({$path}).""            );        }        $this->gdResourceToTruecolor($core);        // build image        $image = $this->initFromGdResource($core);        $image->mime = $mime;        $image->setFileInfoFromPath($path);        return $image;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
206,Intervention_image_Decoder_574, Initiates new image from GD resource\n\n @param  Resource $resource\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku iz GD resursa.,"    public function initFromGdResource($resource)    {        return new Image(new Driver, $resource);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
207,Intervention_image_Decoder_575, Initiates new image from Imagick object\n\n @param  Imagick $object\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku iz Imagick objekta.,"    public function initFromImagick(\Imagick $object)    {        throw new NotSupportedException(            ""Gd driver is unable to init from Imagick object.""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
208,Intervention_image_Decoder_642, Initiates new image from path in filesystem\\n\\n @param  string $path\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicijalizuj novu sliku sa date putanje u fajl sistemu.,"    public function initFromPath($path)    {        $core = new \Imagick;        try {            $core->setBackgroundColor(new \ImagickPixel('transparent'));            $core->readImage($path);            $core->setImageType(defined('\Imagick::IMGTYPE_TRUECOLORALPHA') ? \Imagick::IMGTYPE_TRUECOLORALPHA : \Imagick::IMGTYPE_TRUECOLORMATTE);        } catch (\ImagickException $e) {            throw new \Intervention\Image\Exception\NotReadableException(                ""Unable to read image from path ({$path})."",                0,                $e            );        }        // build image        $image = $this->initFromImagick($core);        $image->setFileInfoFromPath($path);        return $image;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
209,Intervention_image_Decoder_645, Initiates new image from binary data\n\n @param  string $data\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku iz binarnog podatka.,"    public function initFromBinary($binary)    {        $core = new \Imagick;        try {            $core->setBackgroundColor(new \ImagickPixel('transparent'));            $core->readImageBlob($binary);        } catch (\ImagickException $e) {            throw new NotReadableException(                ""Unable to read image from binary data."",                0,                $e            );        }        // build image        $image = $this->initFromImagick($core);        $image->mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $binary);        return $image;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
210,Intervention_image_Driver_578, Reads given string into color object\\\\n\\\\n @param  string $value\\\\n @return AbstractColor\\\\n,Kreiraj objekat boje iz datog stringa.,    public function parseColor($value)    {        return new Color($value);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
211,Intervention_image_Driver_648, Checks if core module installation is available\\n\\n @return boolean\\n,Proveri da li je dati argument ispravljen sa trenutnim ograničenjem.,    protected function coreAvailable()    {        return (extension_loaded('imagick') && class_exists('Imagick'));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
212,Intervention_image_EllipseCommand_550, Draws ellipse on given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Nacrtaj elipsu na datoj slici.,"    public function execute($image)    {        $width = $this->argument(0)->type('numeric')->required()->value();        $height = $this->argument(1)->type('numeric')->required()->value();        $x = $this->argument(2)->type('numeric')->required()->value();        $y = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $ellipse_classname = sprintf('\Intervention\Image\%s\Shapes\EllipseShape',            $image->getDriver()->getDriverName());        $ellipse = new $ellipse_classname($width, $height);        if ($callback instanceof Closure) {            $callback($ellipse);        }        $ellipse->applyToImage($image, $x, $y);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
213,Intervention_image_Encoder_581, Processes and returns encoded image as JPEG string\n\n @return string\n,Procesuiraj i vrati šifrovanu sliku kao JPEG string.,"    protected function processJpeg()    {        ob_start();        imagejpeg($this->image->getCore(), null, $this->quality);        $this->image->mime = image_type_to_mime_type(IMAGETYPE_JPEG);        $buffer = ob_get_contents();        ob_end_clean();        return $buffer;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
214,Intervention_image_Encoder_582, Processes and returns encoded image as PNG string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao PNG string.,"    protected function processPng()    {        ob_start();        $resource = $this->image->getCore();        imagealphablending($resource, false);        imagesavealpha($resource, true);        imagepng($resource, null, -1);        $this->image->mime = image_type_to_mime_type(IMAGETYPE_PNG);        $buffer = ob_get_contents();        ob_end_clean();        return $buffer;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
215,Intervention_image_Encoder_583, Processes and returns encoded image as GIF string\n\n @return string\n,Procesuiraj i vrati šifrovanu sliku kao GIF string.,    protected function processGif()    {        ob_start();        imagegif($this->image->getCore());        $this->image->mime = image_type_to_mime_type(IMAGETYPE_GIF);        $buffer = ob_get_contents();        ob_end_clean();        return $buffer;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
216,Intervention_image_Encoder_586, Processes and returns encoded image as ICO string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao ICO string.,"    protected function processIco()    {        throw new NotSupportedException(            ""ICO format is not supported by Gd Driver.""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
217,Intervention_image_Encoder_587, Processes and returns encoded image as PSD string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao PSD string.,"    protected function processPsd()    {        throw new NotSupportedException(            ""PSD format is not supported by Gd Driver.""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
218,Intervention_image_Encoder_649, Processes and returns encoded image as JPEG string\n\n @return string\n,Procesuiraj i vrati šifrovanu sliku kao JPEG string.,    protected function processJpeg()    {        $format = 'jpeg';        $compression = \Imagick::COMPRESSION_JPEG;        $imagick = $this->image->getCore();        $imagick->setImageBackgroundColor('white');        $imagick->setBackgroundColor('white');        $imagick = $imagick->mergeImageLayers(\Imagick::LAYERMETHOD_MERGE);        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        $imagick->setCompressionQuality($this->quality);        $imagick->setImageCompressionQuality($this->quality);        return $imagick->getImagesBlob();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
219,Intervention_image_Encoder_651, Processes and returns encoded image as GIF string\n\n @return string\n,Procesuiraj i vrati šifrovanu sliku kao GIF string.,    protected function processGif()    {        $format = 'gif';        $compression = \Imagick::COMPRESSION_LZW;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
220,Intervention_image_Encoder_653, Processes and returns encoded image as BMP string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao BMP string.,    protected function processBmp()    {        $format = 'bmp';        $compression = \Imagick::COMPRESSION_UNDEFINED;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
221,Intervention_image_Encoder_654, Processes and returns encoded image as ICO string\\n\\n @return string\\n,Procesuiraj i vrati šifrovanu sliku kao ICO string.,    protected function processIco()    {        $format = 'ico';        $compression = \Imagick::COMPRESSION_UNDEFINED;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
222,Intervention_image_ExifCommand_551, Read Exif data from the given image\n\n Note: Windows PHP Users - in order to use this method you will need to\n enable the mbstring and exif extensions within the php.ini file.\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Pročitaj Exif podatke iz date slike. Beleška za Windows PHP korisnike: Da bi se koristila ova metoda potrebno je omogućiti mbstring i exif ekstenzije u okviru php.ini fajla.,"    public function execute($image)    {        if (!function_exists('exif_read_data')) {            throw new NotSupportedException(                ""Reading Exif data is not supported by this PHP installation.""            );        }        $key = $this->argument(0)->value();        // try to read exif data from image file        try {            $data = @exif_read_data($image->dirname . '/' . $image->basename);            if (!is_null($key) && is_array($data)) {                $data = array_key_exists($key, $data) ? $data[$key] : false;            }        } catch (\Exception $e) {            throw new NotReadableException(                sprintf(                    ""Cannot read the Exif data from the filename (%s) provided "",                    $image->dirname . '/' . $image->basename                ),                $e->getCode(),                $e            );        }        $this->setOutput($data);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
223,Intervention_image_FillCommand_666, Fills image with color or pattern\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Popuni prostor slike sa bojom ili obrascem.,"    public function execute($image)    {        $filling = $this->argument(0)->value();        $x = $this->argument(1)->type('digit')->value();        $y = $this->argument(2)->type('digit')->value();        $imagick = $image->getCore();        try {            // set image filling            $source = new Decoder;            $filling = $source->init($filling);        } catch (NotReadableException $e) {            // set solid color filling            $filling = new Color($filling);        }        // flood fill if coordinates are set        if (is_int($x) && is_int($y)) {            // flood fill with texture            if ($filling instanceof Image) {                // create tile                $tile = clone $image->getCore();                // mask away color at position                $tile->transparentPaintImage($tile->getImagePixelColor($x, $y), 0, 0, false);                // create canvas                $canvas = clone $image->getCore();                // fill canvas with texture                $canvas = $canvas->textureImage($filling->getCore());                // merge canvas and tile                $canvas->compositeImage($tile, \Imagick::COMPOSITE_DEFAULT, 0, 0);                // replace image core                $image->setCore($canvas);            // flood fill with color            } elseif ($filling instanceof Color) {                // create canvas with filling                $canvas = new \Imagick;                $canvas->newImage($image->getWidth(), $image->getHeight(), $filling->getPixel(), 'png');                // create tile to put on top                $tile = clone $image->getCore();                // mask away color at pos.                $tile->transparentPaintImage($tile->getImagePixelColor($x, $y), 0, 0, false);                // save alpha channel of original image                $alpha = clone $image->getCore();                // merge original with canvas and tile                $image->getCore()->compositeImage($canvas, \Imagick::COMPOSITE_DEFAULT, 0, 0);                $image->getCore()->compositeImage($tile, \Imagick::COMPOSITE_DEFAULT, 0, 0);                // restore alpha channel of original image                $image->getCore()->compositeImage($alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);            }        } else {            if ($filling instanceof Image) {                // fill whole image with texture                $image->setCore($image->getCore()->textureImage($filling->getCore()));            } elseif ($filling instanceof Color) {                // fill whole image with color                $draw = new \ImagickDraw();                $draw->setFillColor($filling->getPixel());                $draw->rectangle(0, 0, $image->getWidth(), $image->getHeight());                $image->getCore()->drawImage($draw);            }        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
224,Intervention_image_FilterInterface_563, Applies filter to given image\n\n @param  \\Intervention\\Image\\Image $image\n @return \\Intervention\\Image\\Image\n,Primeni filtere na datoj slici.,    public function applyFilter(Image $image);,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
225,Intervention_image_FitCommand_601, Crops and resized an image at the same time\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Iseci i promeni veličinu slike u isto vreme.,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->value($width);        $constraints = $this->argument(2)->type('closure')->value();        $position = $this->argument(3)->type('string')->value('center');        // calculate size        $cropped = $image->getSize()->fit(new Size($width, $height), $position);        $resized = clone $cropped;        $resized = $resized->resize($width, $height, $constraints);        // modify image        $this->modify($image, 0, 0, $cropped->pivot->x, $cropped->pivot->y, $resized->getWidth(), $resized->getHeight(), $cropped->getWidth(), $cropped->getHeight());        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
226,Intervention_image_FlipCommand_668, Mirrors an image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Preslikaj sliku,"    public function execute($image)    {        $mode = $this->argument(0)->value('h');        if (in_array(strtolower($mode), [2, 'v', 'vert', 'vertical'])) {            // flip vertical            return $image->getCore()->flipImage();        } else {            // flip horizontal            return $image->getCore()->flopImage();        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
227,Intervention_image_Font_588, Get font size in points\\n\\n @return int\\n,Dohvati veličinu fonta u tačkama.,    protected function getPointSize()    {        return intval(ceil($this->size * 0.75));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
228,Intervention_image_Font_589, Filter function to access internal integer font values\\n\\n @return int\\n,Filter funkcija za dohvatanje interne celobrojne vrednosti fonta.,"    private function getInternalFont()    {        $internalfont = is_null($this->file) ? 1 : $this->file;        $internalfont = is_numeric($internalfont) ? $internalfont : false;        if ( ! in_array($internalfont, [1, 2, 3, 4, 5])) {            throw new NotSupportedException(                sprintf('Internal GD font (%s) not available. Use only 1-5.', $internalfont)            );        }        return intval($internalfont);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
229,Intervention_image_Font_590, Get width of an internal font character\n\n @return int\n,Dohvati širinu unutrašnjeg font karaktera.,    private function getInternalFontWidth()    {        return $this->getInternalFont() + 4;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
230,Intervention_image_Font_656, Calculates bounding box of current font setting\\\\n\\\\n @return array\\\\n,Proračunaj granični opseg trenutne postavke fonta.,"    public function getBoxSize()    {        $box = [];        // build draw object        $draw = new \ImagickDraw();        $draw->setStrokeAntialias(true);        $draw->setTextAntialias(true);        // set font file        if ($this->hasApplicableFontFile()) {            $draw->setFont($this->file);        } else {            throw new RuntimeException(                ""Font file must be provided to apply text to image.""            );        }        $draw->setFontSize($this->size);        $dimensions = (new \Imagick())->queryFontMetrics($draw, $this->text);        if (strlen($this->text) == 0) {            // no text -> no boxsize            $box['width'] = 0;            $box['height'] = 0;        } else {            // get boxsize            $box['width'] = intval(abs($dimensions['textWidth']));            $box['height'] = intval(abs($dimensions['textHeight']));        }        return $box;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
231,Intervention_image_GetSizeCommand_604, Reads size of given image instance in pixels\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Pročitaj veličinu date instance slike u pikselima.,"    public function execute($image)    {        $this->setOutput(new Size(            imagesx($image->getCore()),            imagesy($image->getCore())        ));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
232,Intervention_image_GetSizeCommand_670, Reads size of given image instance in pixels\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Pročitaj veličinu date instance slike u pikselima.,"    public function execute($image)    {        /** @var \Imagick $core */        $core = $image->getCore();        $this->setOutput(new Size(            $core->getImageWidth(),            $core->getImageHeight()        ));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
233,Intervention_image_GreyscaleCommand_671, Turns an image into a greyscale version\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Dohvati verziju slike bez boje.,"    public function execute($image)    {        return $image->getCore()->modulateImage(100, 0, 100);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
234,Intervention_image_ImageManager_503, Initiates an Image instance from different input types\n\n @param  mixed $data\n\n @return \\Intervention\\Image\\Image\n,Inicijalizuj instancu slike iz različitih ulaznih tipova.,    public function make($data)    {        return $this->createDriver()->init($data);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
235,Intervention_image_ImageManager_504, Creates a driver instance according to config settings\\n\\n @return \\\\Intervention\\\\Image\\\\AbstractDriver\\n,Kreiraj instancu upravljača u skladu sa konfiguracionim podešavanjima.,"    private function createDriver()    {        if (is_string($this->config['driver'])) {            $drivername = ucfirst($this->config['driver']);            $driverclass = sprintf('Intervention\\Image\\%s\\Driver', $drivername);            if (class_exists($driverclass)) {                return new $driverclass;            }            throw new NotSupportedException(                ""Driver ({$drivername}) could not be instantiated.""            );        }        if ($this->config['driver'] instanceof AbstractDriver) {            return $this->config['driver'];        }        throw new NotSupportedException(            ""Unknown driver type.""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
236,Intervention_image_ImageManager_505, Check if all requirements are available\\\\n\\\\n @return void\\\\n,Proveri da li su svi uslovi zadovoljeni.,"    private function checkRequirements()    {        if ( ! function_exists('finfo_buffer')) {            throw new MissingDependencyException(                ""PHP Fileinfo extension must be installed/enabled to use Intervention Image.""            );        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
237,Intervention_image_ImageServiceProviderLaravel4_514, Register the service provider.\\n\\n @return void\\n,Registruj servis provajder.,"    public function register()    {        $app = $this->app;        $app['image'] = $app->share(function ($app) {            return new ImageManager($app['config']->get('image::config'));        });        $app->alias('image', 'Intervention\Image\ImageManager');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
238,Intervention_image_ImageServiceProviderLaravelRecent_515, Determines if Intervention Imagecache is installed\n\n @return boolean\n,Proveri da li je Intervantion Imagecache instaliran.,    private function cacheIsInstalled()    {        return class_exists('Intervention\\Image\\ImageCache');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
239,Intervention_image_ImageServiceProvider_509, Bootstrap the application events.\\n\\n @return void\\n,Pokreni aplikacioni sistem za upravljanje dogadjaje.,"    public function boot()    {        if (method_exists($this->provider, 'boot')) {            return $this->provider->boot();        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
240,Intervention_image_ImageServiceProvider_510, Register the service provider.\\n\\n @return void\\n,Registruj servis provajder.,    public function register()    {        return $this->provider->register();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
241,Intervention_image_ImageServiceProvider_511, Return ServiceProvider according to Laravel version\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Provider\\\\\\\\ProviderInterface\\\\n,Dohvati servis provajder u skladu sa Laravel verzijom.,"    private function getProvider()    {        if ($this->app instanceof LumenApplication) {            $provider = '\Intervention\Image\ImageServiceProviderLumen';        } elseif (version_compare(IlluminateApplication::VERSION, '5.0', '<')) {            $provider = '\Intervention\Image\ImageServiceProviderLaravel4';        } else {            $provider = '\Intervention\Image\ImageServiceProviderLaravelRecent';        }        return new $provider($this->app);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
242,Intervention_image_Image_485, Magic method to catch all image calls\\n usually any AbstractCommand\\n\\n @param  string $name\\n @param  Array  $arguments\\n @return mixed\\n,Magična metoda za hvatanje svih poziva sa slikom.,"    public function __call($name, $arguments)    {        $command = $this->driver->executeCommand($this, $name, $arguments);        return $command->hasOutput() ? $command->getOutput() : $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
243,Intervention_image_Image_486, Runs a given filter on current image\n\n @param  FiltersFilterInterface $filter\n @return \\Intervention\\Image\\Image\n,Primeni filtere na datoj slici.,    public function filter(Filters\FilterInterface $filter)    {        return $filter->applyFilter($this);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
244,Intervention_image_Image_492, Checks if named backup exists\\n\\n @param  string $name\\n @return bool\\n,Proveri da li rezervna kopija sa datim imenom postoji.,"    private function backupExists($name)    {        return array_key_exists($name, $this->backups);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
245,Intervention_image_InterlaceCommand_674, Toggles interlaced encoding mode\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Uključi isprepletan mod šifriranja.,    public function execute($image)    {        $mode = $this->argument(0)->type('bool')->value(true);        if ($mode) {            $mode = \Imagick::INTERLACE_LINE;        } else {            $mode = \Imagick::INTERLACE_NO;        }        $image->getCore()->setInterlaceScheme($mode);        return true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
246,Intervention_image_InvertCommand_609, Inverts colors of an image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Invertuj boje na slici.,"    public function execute($image)    {        return imagefilter($image->getCore(), IMG_FILTER_NEGATE);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
247,Intervention_image_IptcCommand_552, Read Iptc data from the given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Pročitaj lpct podatke sa date slike.,"    public function execute($image)    {        if ( ! function_exists('iptcparse')) {            throw new NotSupportedException(                ""Reading Iptc data is not supported by this PHP installation.""            );        }        $key = $this->argument(0)->value();        $info = [];        @getimagesize($image->dirname .'/'. $image->basename, $info);        $data = [];        if (array_key_exists('APP13', $info)) {            $iptc = iptcparse($info['APP13']);            if (is_array($iptc)) {                $data['DocumentTitle'] = isset($iptc[""2#005""][0]) ? $iptc[""2#005""][0] : null;                $data['Urgency'] = isset($iptc[""2#010""][0]) ? $iptc[""2#010""][0] : null;                $data['Category'] = isset($iptc[""2#015""][0]) ? $iptc[""2#015""][0] : null;                $data['Subcategories'] = isset($iptc[""2#020""][0]) ? $iptc[""2#020""][0] : null;                $data['Keywords'] = isset($iptc[""2#025""][0]) ? $iptc[""2#025""] : null;                $data['SpecialInstructions'] = isset($iptc[""2#040""][0]) ? $iptc[""2#040""][0] : null;                $data['CreationDate'] = isset($iptc[""2#055""][0]) ? $iptc[""2#055""][0] : null;                $data['CreationTime'] = isset($iptc[""2#060""][0]) ? $iptc[""2#060""][0] : null;                $data['AuthorByline'] = isset($iptc[""2#080""][0]) ? $iptc[""2#080""][0] : null;                $data['AuthorTitle'] = isset($iptc[""2#085""][0]) ? $iptc[""2#085""][0] : null;                $data['City'] = isset($iptc[""2#090""][0]) ? $iptc[""2#090""][0] : null;                $data['SubLocation'] = isset($iptc[""2#092""][0]) ? $iptc[""2#092""][0] : null;                $data['State'] = isset($iptc[""2#095""][0]) ? $iptc[""2#095""][0] : null;                $data['Country'] = isset($iptc[""2#101""][0]) ? $iptc[""2#101""][0] : null;                $data['OTR'] = isset($iptc[""2#103""][0]) ? $iptc[""2#103""][0] : null;                $data['Headline'] = isset($iptc[""2#105""][0]) ? $iptc[""2#105""][0] : null;                $data['Source'] = isset($iptc[""2#110""][0]) ? $iptc[""2#110""][0] : null;                $data['PhotoSource'] = isset($iptc[""2#115""][0]) ? $iptc[""2#115""][0] : null;                $data['Copyright'] = isset($iptc[""2#116""][0]) ? $iptc[""2#116""][0] : null;                $data['Caption'] = isset($iptc[""2#120""][0]) ? $iptc[""2#120""][0] : null;                $data['CaptionWriter'] = isset($iptc[""2#122""][0]) ? $iptc[""2#122""][0] : null;            }        }        if (! is_null($key) && is_array($data)) {            $data = array_key_exists($key, $data) ? $data[$key] : false;        }        $this->setOutput($data);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
248,Intervention_image_LimitColorsCommand_676, Reduces colors of a given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Smanji intenzitet boja na slici.,"    public function execute($image)    {        $count = $this->argument(0)->value();        $matte = $this->argument(1)->value();        // get current image size        $size = $image->getSize();        // build 2 color alpha mask from original alpha        $alpha = clone $image->getCore();        $alpha->separateImageChannel(\Imagick::CHANNEL_ALPHA);        $alpha->transparentPaintImage('#ffffff', 0, 0, false);        $alpha->separateImageChannel(\Imagick::CHANNEL_ALPHA);        $alpha->negateImage(false);        if ($matte) {            // get matte color            $mattecolor = $image->getDriver()->parseColor($matte)->getPixel();            // create matte image            $canvas = new \Imagick;            $canvas->newImage($size->width, $size->height, $mattecolor, 'png');            // lower colors of original and copy to matte            $image->getCore()->quantizeImage($count, \Imagick::COLORSPACE_RGB, 0, false, false);            $canvas->compositeImage($image->getCore(), \Imagick::COMPOSITE_DEFAULT, 0, 0);            // copy new alpha to canvas            $canvas->compositeImage($alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);            // replace core            $image->setCore($canvas);        } else {            $image->getCore()->quantizeImage($count, \Imagick::COLORSPACE_RGB, 0, false, false);            $image->getCore()->compositeImage($alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
249,Intervention_image_LineCommand_553, Draws line on given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Nacrtaj liniju na datoj slici.,"    public function execute($image)    {        $x1 = $this->argument(0)->type('numeric')->required()->value();        $y1 = $this->argument(1)->type('numeric')->required()->value();        $x2 = $this->argument(2)->type('numeric')->required()->value();        $y2 = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $line_classname = sprintf('\Intervention\Image\%s\Shapes\LineShape',            $image->getDriver()->getDriverName());        $line = new $line_classname($x2, $y2);        if ($callback instanceof Closure) {            $callback($line);        }        $line->applyToImage($image, $x1, $y1);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
250,Intervention_image_MaskCommand_611, Applies an alpha mask to an image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Primeni alfa masku na slici.,"    public function execute($image)    {        $mask_source = $this->argument(0)->value();        $mask_w_alpha = $this->argument(1)->type('bool')->value(false);        $image_size = $image->getSize();        // create empty canvas        $canvas = $image->getDriver()->newImage($image_size->width, $image_size->height, [0,0,0,0]);        // build mask image from source        $mask = $image->getDriver()->init($mask_source);        $mask_size = $mask->getSize();        // resize mask to size of current image (if necessary)        if ($mask_size != $image_size) {            $mask->resize($image_size->width, $image_size->height);        }        imagealphablending($canvas->getCore(), false);        if ( ! $mask_w_alpha) {            // mask from greyscale image            imagefilter($mask->getCore(), IMG_FILTER_GRAYSCALE);        }        // redraw old image pixel by pixel considering alpha map        for ($x=0; $x < $image_size->width; $x++) {            for ($y=0; $y < $image_size->height; $y++) {                $color = $image->pickColor($x, $y, 'array');                $alpha = $mask->pickColor($x, $y, 'array');                if ($mask_w_alpha) {                    $alpha = $alpha[3]; // use alpha channel as mask                } else {                    if ($alpha[3] == 0) { // transparent as black                        $alpha = 0;                    } else {                        // $alpha = floatval(round((($alpha[0] + $alpha[1] + $alpha[3]) / 3) / 255, 2));                        // image is greyscale, so channel doesn't matter (use red channel)                        $alpha = floatval(round($alpha[0] / 255, 2));                    }                }                // preserve alpha of original image...                if ($color[3] < $alpha) {                    $alpha = $color[3];                }                // replace alpha value                $color[3] = $alpha;                // redraw pixel                $canvas->pixel($color, $x, $y);            }        }        // replace current image with masked instance        $image->setCore($canvas->getCore());        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
251,Intervention_image_OpacityCommand_612, Defines opacity of an image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Definiši providnost slike.,"    public function execute($image)    {        $transparency = $this->argument(0)->between(0, 100)->required()->value();        // get size of image        $size = $image->getSize();        // build temp alpha mask        $mask_color = sprintf('rgba(0, 0, 0, %.1F)', $transparency / 100);        $mask = $image->getDriver()->newImage($size->width, $size->height, $mask_color);        // mask image        $image->mask($mask->getCore(), true);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
252,Intervention_image_OrientateCommand_554, Correct image orientation according to Exif data\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Ispravi orijentaciju slike u skladu sa Exif podacima.,    public function execute($image)    {        switch ($image->exif('Orientation')) {            case 2:                $image->flip();                break;            case 3:                $image->rotate(180);                break;            case 4:                $image->rotate(180)->flip();                break;            case 5:                $image->rotate(270)->flip();                break;            case 6:                $image->rotate(270);                break;            case 7:                $image->rotate(90)->flip();                break;            case 8:                $image->rotate(90);                break;        }        return true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
253,Intervention_image_PixelCommand_614, Draws one pixel to a given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Iscrtaj jedan piksel na slici.,"    public function execute($image)    {        $color = $this->argument(0)->required()->value();        $color = new Color($color);        $x = $this->argument(1)->type('digit')->required()->value();        $y = $this->argument(2)->type('digit')->required()->value();        return imagesetpixel($image->getCore(), $x, $y, $color->getInt());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
254,Intervention_image_PixelateCommand_681, Applies a pixelation effect to a given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Primeni efekat pikselizacije na datoj slici.,"    public function execute($image)    {        $size = $this->argument(0)->type('digit')->value(10);        $width = $image->getWidth();        $height = $image->getHeight();        $image->getCore()->scaleImage(max(1, ($width / $size)), max(1, ($height / $size)));        $image->getCore()->scaleImage($width, $height);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
255,Intervention_image_PolygonShape_691, Create new polygon instance\n\n @param array $points\n,Kreiraj novu poligon instancu.,    public function __construct($points)    {        $this->points = $this->formatPoints($points);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
256,Intervention_image_PsrResponseCommand_556," Builds PSR7 compatible response. May replace ""response"" command in\n some future.\n\n Method will generate binary stream and put it inside PSR-7\n ResponseInterface. Following code can be optimized using native php\n streams and more ""clean"" streaming, however drivers has to be updated\n first.\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n",Kreiraj odgovor kompatibilan sa PSR-7 interfejs metodama. Metoda će kreirati binarni tok i postaviti ga u PSR-7 interfejs odgovora. Prateći kod se može optimizovati korišćenjem native php tokovima. Ipak drajveri se moraju nadograditi predhodno.,"    public function execute($image)    {        $format = $this->argument(0)->value();        $quality = $this->argument(1)->between(0, 100)->value();        //Encoded property will be populated at this moment        $stream = $image->stream($format, $quality);        $mimetype = finfo_buffer(            finfo_open(FILEINFO_MIME_TYPE),            $image->getEncoded()        );        $this->setOutput(new Response(            200,            [                'Content-Type'   => $mimetype,                'Content-Length' => strlen($image->getEncoded())            ],            $stream        ));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
257,Intervention_image_ResetCommand_682, Resets given image to its backup state\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Resetuj sliku na njeno predhodno sačuvano stanje.,"    public function execute($image)    {        $backupName = $this->argument(0)->value();        $backup = $image->getBackup($backupName);        if ($backup instanceof \Imagick) {            // destroy current core            $image->getCore()->clear();            // clone backup            $backup = clone $backup;            // reset to new resource            $image->setCore($backup);            return true;        }        throw new RuntimeException(            ""Backup not available. Call backup({$backupName}) before reset().""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
258,Intervention_image_ResizeCanvasCommand_617, Resizes image boundaries\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni veličinu granica u kojima se proteže slika.,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->required()->value();        $anchor = $this->argument(2)->value('center');        $relative = $this->argument(3)->type('boolean')->value(false);        $bgcolor = $this->argument(4)->value();        $original_width = $image->getWidth();        $original_height = $image->getHeight();        // check of only width or height is set        $width = is_null($width) ? $original_width : intval($width);        $height = is_null($height) ? $original_height : intval($height);        // check on relative width/height        if ($relative) {            $width = $original_width + $width;            $height = $original_height + $height;        }        // check for negative width/height        $width = ($width <= 0) ? $width + $original_width : $width;        $height = ($height <= 0) ? $height + $original_height : $height;        // create new canvas        $canvas = $image->getDriver()->newImage($width, $height, $bgcolor);        // set copy position        $canvas_size = $canvas->getSize()->align($anchor);        $image_size = $image->getSize()->align($anchor);        $canvas_pos = $image_size->relativePosition($canvas_size);        $image_pos = $canvas_size->relativePosition($image_size);        if ($width <= $original_width) {            $dst_x = 0;            $src_x = $canvas_pos->x;            $src_w = $canvas_size->width;        } else {            $dst_x = $image_pos->x;            $src_x = 0;            $src_w = $original_width;        }        if ($height <= $original_height) {            $dst_y = 0;            $src_y = $canvas_pos->y;            $src_h = $canvas_size->height;        } else {            $dst_y = $image_pos->y;            $src_y = 0;            $src_h = $original_height;        }        // make image area transparent to keep transparency        // even if background-color is set        $transparent = imagecolorallocatealpha($canvas->getCore(), 255, 255, 255, 127);        imagealphablending($canvas->getCore(), false); // do not blend / just overwrite        imagefilledrectangle($canvas->getCore(), $dst_x, $dst_y, $dst_x + $src_w - 1, $dst_y + $src_h - 1, $transparent);        // copy image into new canvas        imagecopy($canvas->getCore(), $image->getCore(), $dst_x, $dst_y, $src_x, $src_y, $src_w, $src_h);        // set new core to canvas        $image->setCore($canvas->getCore());        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
259,Intervention_image_ResizeCommand_618, Resizes image dimensions\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Promeni dimenzije slike.,"    public function execute($image)    {        $width = $this->argument(0)->value();        $height = $this->argument(1)->value();        $constraints = $this->argument(2)->type('closure')->value();        // resize box        $resized = $image->getSize()->resize($width, $height, $constraints);        // modify image        $this->modify($image, 0, 0, 0, 0, $resized->getWidth(), $resized->getHeight(), $image->getWidth(), $image->getHeight());        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
260,Intervention_image_Response_527, Builds response according to settings\n\n @return mixed\n,Napravi odgovor u skladu sa podešavanjima.,"    public function make()    {        $this->image->encode($this->format, $this->quality);        $data = $this->image->getEncoded();        $mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $data);        $length = strlen($data);        if (function_exists('app') && is_a($app = app(), 'Illuminate\Foundation\Application')) {            $response = IlluminateResponse::make($data);            $response->header('Content-Type', $mime);            $response->header('Content-Length', $length);        } elseif (class_exists('\Symfony\Component\HttpFoundation\Response')) {            $response = SymfonyResponse::create($data);            $response->headers->set('Content-Type', $mime);            $response->headers->set('Content-Length', $length);        } else {            header('Content-Type: ' . $mime);            header('Content-Length: ' . $length);            $response = $data;        }        return $response;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
261,Intervention_image_RotateCommand_620, Rotates image counter clockwise\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Rotiraj sliku u smeru kazaljke na satu.,"    public function execute($image)    {        $angle = $this->argument(0)->type('numeric')->required()->value();        $color = $this->argument(1)->value();        $color = new Color($color);        // restrict rotations beyond 360 degrees, since the end result is the same        $angle %= 360;        // rotate image        $image->setCore(imagerotate($image->getCore(), $angle, $color->getInt()));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
262,Intervention_image_RotateCommand_685, Rotates image counter clockwise\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Rotiraj sliku u smeru kazaljke na satu.,"    public function execute($image)    {        $angle = $this->argument(0)->type('numeric')->required()->value();        $color = $this->argument(1)->value();        $color = new Color($color);        // restrict rotations beyond 360 degrees, since the end result is the same        $angle %= 360;        // rotate image        $image->getCore()->rotateImage($color->getPixel(), ($angle * -1));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
263,Intervention_image_SharpenCommand_621, Sharpen image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Izoštri sliku.,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(10);        // build matrix        $min = $amount >= 10 ? $amount * -0.01 : 0;        $max = $amount * -0.025;        $abs = ((4 * $min + 4 * $max) * -1) + 1;        $div = 1;        $matrix = [            [$min, $max, $min],            [$max, $abs, $max],            [$min, $max, $min]        ];        // apply the matrix        return imageconvolution($image->getCore(), $matrix, $div, 0);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
264,Intervention_image_Size_532, Calculate the current aspect ratio\\\\n\\\\n @return float\\\\n,Dohvati odnos širine i visine.,    public function getRatio()    {        return $this->width / $this->height;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
265,Intervention_image_Size_534, Checks if given size fits into current size\\\\n\\\\n @param  Size   $size\\\\n @return boolean\\\\n,Proveri da li data veličina slike odgovara trenutnoj veličini.,    public function fitsInto(Size $size)    {        return ($this->width <= $size->width) && ($this->height <= $size->height);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
266,Intervention_image_TrimCommand_622, Trims away parts of an image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Odseci delove slike.,"    public function execute($image)    {        $base = $this->argument(0)->type('string')->value();        $away = $this->argument(1)->value();        $tolerance = $this->argument(2)->type('numeric')->value(0);        $feather = $this->argument(3)->type('numeric')->value(0);        $width = $image->getWidth();        $height = $image->getHeight();        // default values        $checkTransparency = false;        // define borders to trim away        if (is_null($away)) {            $away = ['top', 'right', 'bottom', 'left'];        } elseif (is_string($away)) {            $away = [$away];        }        // lower border names        foreach ($away as $key => $value) {            $away[$key] = strtolower($value);        }        // define base color position        switch (strtolower($base)) {            case 'transparent':            case 'trans':                $checkTransparency = true;                $base_x = 0;                $base_y = 0;                break;            case 'bottom-right':            case 'right-bottom':                $base_x = $width - 1;                $base_y = $height - 1;                break;            default:            case 'top-left':            case 'left-top':                $base_x = 0;                $base_y = 0;                break;        }        // pick base color        if ($checkTransparency) {            $color = new Color; // color will only be used to compare alpha channel        } else {            $color = $image->pickColor($base_x, $base_y, 'object');        }        $top_x = 0;        $top_y = 0;        $bottom_x = $width;        $bottom_y = $height;        // search upper part of image for colors to trim away        if (in_array('top', $away)) {            for ($y=0; $y < ceil($height/2); $y++) {                for ($x=0; $x < $width; $x++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $top_y = max(0, $y - $feather);                        break 2;                    }                }            }        }        // search left part of image for colors to trim away        if (in_array('left', $away)) {            for ($x=0; $x < ceil($width/2); $x++) {                for ($y=$top_y; $y < $height; $y++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $top_x = max(0, $x - $feather);                        break 2;                    }                }            }        }        // search lower part of image for colors to trim away        if (in_array('bottom', $away)) {            for ($y=($height-1); $y >= floor($height/2)-1; $y--) {                for ($x=$top_x; $x < $width; $x++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $bottom_y = min($height, $y+1 + $feather);                        break 2;                    }                }            }        }        // search right part of image for colors to trim away        if (in_array('right', $away)) {            for ($x=($width-1); $x >= floor($width/2)-1; $x--) {                for ($y=$top_y; $y < $bottom_y; $y++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $bottom_x = min($width, $x+1 + $feather);                        break 2;                    }                }            }        }        // trim parts of image        return $this->modify($image, 0, 0, $top_x, $top_y, ($bottom_x-$top_x), ($bottom_y-$top_y), ($bottom_x-$top_x), ($bottom_y-$top_y));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
267,Intervention_image_WidenCommand_623, Resize image proportionally to given width\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Promeni veličinu slike proporionalno sa zadatom širinom.,    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $additionalConstraints = $this->argument(1)->type('closure')->value();        $this->arguments[0] = $width;        $this->arguments[1] = null;        $this->arguments[2] = function ($constraint) use ($additionalConstraints) {            $constraint->aspectRatio();            if(is_callable($additionalConstraints))                $additionalConstraints($constraint);        };        return parent::execute($image);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
268,PHPOffice_PHPExcel_Autoloader_126, Register the Autoloader with SPL\\\\\\\\n\\\\\\\\n,Registruj Autoloadersa sa SPL-om.,"    public static function register()    {        if (function_exists('__autoload')) {            // Register any existing autoloader function with SPL, so we don't get any clashes            spl_autoload_register('__autoload');        }        // Register ourselves with SPL        if (version_compare(PHP_VERSION, '5.3.0') >= 0) {            return spl_autoload_register(array('PHPExcel_Autoloader', 'load'), true, true);        } else {            return spl_autoload_register(array('PHPExcel_Autoloader', 'load'));        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
269,PHPOffice_PHPExcel_Autoloader_127, Autoload a class identified by name\\\\\\\\n\\\\\\\\n @param    string    $pClassName        Name of the object to load\\\\\\\\n,Automatski učitaj klasu određenu imenom.,"    public static function load($pClassName)    {        if ((class_exists($pClassName, false)) || (strpos($pClassName, 'PHPExcel') !== 0)) {            // Either already loaded, or not a PHPExcel class request            return false;        }        $pClassFilePath = PHPEXCEL_ROOT .            str_replace('_', DIRECTORY_SEPARATOR, $pClassName) .            '.php';        if ((file_exists($pClassFilePath) === false) || (is_readable($pClassFilePath) === false)) {            // Can't load            return false;        }        require($pClassFilePath);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
270,PHPOffice_PHPExcel_CachedObjectStorageFactory_132, Return the list of all available cache storage methods\\\\\\\\n\\\\\\\\n @return string[]\\\\\\\\n,Dohvati lisu svih dostupnih metoda za keširanje.,"    public static function getCacheStorageMethods()    {        $activeMethods = array();        foreach (self::$storageMethods as $storageMethod) {            $cacheStorageClass = 'PHPExcel_CachedObjectStorage_' . $storageMethod;            if (call_user_func(array($cacheStorageClass, 'cacheMethodIsAvailable'))) {                $activeMethods[] = $storageMethod;            }        }        return $activeMethods;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
271,PHPOffice_PHPExcel_CachedObjectStorageFactory_134, Clear the cache storage\\n\\n,Isprazni keš skladište za podatake.,    public static function finalize()    {        self::$cacheStorageMethod = null;        self::$cacheStorageClass = null;        self::$storageMethodParameters = array();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
272,PHPOffice_PHPExcel_Calculation_139, __clone implementation. Cloning should not be allowed in a Singleton!\\n\\n @access    public\\n @throws    PHPExcel_Calculation_Exception\\n,Kloniranje objekata nije dozvoljeno u Singlton klasama.,    final public function __clone()    {        throw new PHPExcel_Calculation_Exception('Cloning the calculation engine is not allowed!');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
273,PHPOffice_PHPExcel_Calculation_142, Set the Array Return Type (Array or Value of first element in the array)\\\\\\\\n\\\\\\\\n @access    public\\\\\\\\n @param     string    $returnType            Array return type\\\\\\\\n @return     boolean                    Success or failure\\\\\\\\n,Postavi povratni tip za niz.,    public static function setArrayReturnType($returnType)    {        if (($returnType == self::RETURN_ARRAY_AS_VALUE) ||            ($returnType == self::RETURN_ARRAY_AS_ERROR) ||            ($returnType == self::RETURN_ARRAY_AS_ARRAY)) {            self::$returnArrayAsType = $returnType;            return true;        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
274,PHPOffice_PHPExcel_Calculation_151, Wrap string values in quotes\\n\\n @param mixed $value\\n @return mixed\\n,Uokviri string podatak sa znacima navoda.,"    public static function wrapResult($value)    {        if (is_string($value)) {            //    Error values cannot be ""wrapped""            if (preg_match('/^'.self::CALCULATION_REGEXP_ERROR.'$/i', $value, $match)) {                //    Return Excel errors ""as is""                return $value;            }            //    Return strings wrapped in quotes            return '""'.$value.'""';        //    Convert numeric errors to NaN error        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {            return PHPExcel_Calculation_Functions::NaN();        }        return $value;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
275,PHPOffice_PHPExcel_Calculation_152, Remove quotes used as a wrapper to identify string values\n\n @param mixed $value\n @return mixed\n,Uklanjanje navodnika koje uokviruje string vrednost.,"    public static function unwrapResult($value)    {        if (is_string($value)) {            if ((isset($value{0})) && ($value{0} == '""') && (substr($value, -1) == '""')) {                return substr($value, 1, -1);            }        //    Convert numeric errors to NaN error        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {            return PHPExcel_Calculation_Functions::NaN();        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
276,PHPOffice_PHPExcel_Calculation_154," Read the dimensions of a matrix, and re-index it with straight numeric keys starting from row 0, column 0\\\\n\\\\n @param    mixed        &$matrix        matrix operand\\\\n @return    array        An array comprising the number of rows, and number of columns\\\\n",Dohvati dimenzije matrica i reindeksiraj ga vrednostima počevši od nule.,"    private static function getMatrixDimensions(&$matrix)    {        $matrixRows = count($matrix);        $matrixColumns = 0;        foreach ($matrix as $rowKey => $rowValue) {            $matrixColumns = max(count($rowValue), $matrixColumns);            if (!is_array($rowValue)) {                $matrix[$rowKey] = array($rowValue);            } else {                $matrix[$rowKey] = array_values($rowValue);            }        }        $matrix = array_values($matrix);        return array($matrixRows, $matrixColumns);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
277,PHPOffice_PHPExcel_Calculation_155, Ensure that paired matrix operands are both matrices of the same size\\\\\\\\n\\\\\\\\n @param    mixed        &$matrix1        First matrix operand\\\\\\\\n @param    mixed        &$matrix2        Second matrix operand\\\\\\\\n @param    integer        $matrix1Rows    Row size of first matrix operand\\\\\\\\n @param    integer        $matrix1Columns    Column size of first matrix operand\\\\\\\\n @param    integer        $matrix2Rows    Row size of second matrix operand\\\\\\\\n @param    integer        $matrix2Columns    Column size of second matrix operand\\\\\\\\n,Obezbedi da su matrice u operaciji istih dimenzija.,"    private static function resizeMatricesShrink(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Rows < $matrix1Rows) {                for ($i = $matrix2Rows; $i < $matrix1Rows; ++$i) {                    unset($matrix1[$i]);                }            }            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        unset($matrix1[$i][$j]);                    }                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Rows < $matrix2Rows) {                for ($i = $matrix1Rows; $i < $matrix2Rows; ++$i) {                    unset($matrix2[$i]);                }            }            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        unset($matrix2[$i][$j]);                    }                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
278,PHPOffice_PHPExcel_Calculation_156, Ensure that paired matrix operands are both matrices of the same size\n\n @param    mixed        &$matrix1    First matrix operand\n @param    mixed        &$matrix2    Second matrix operand\n @param    integer        $matrix1Rows    Row size of first matrix operand\n @param    integer        $matrix1Columns    Column size of first matrix operand\n @param    integer        $matrix2Rows    Row size of second matrix operand\n @param    integer        $matrix2Columns    Column size of second matrix operand\n,Obezbedi da su matrice u operaciji istih dimenzija.,"    private static function resizeMatricesExtend(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $x = $matrix2[$i][$matrix2Columns-1];                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        $matrix2[$i][$j] = $x;                    }                }            }            if ($matrix2Rows < $matrix1Rows) {                $x = $matrix2[$matrix2Rows-1];                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $matrix2[$i] = $x;                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $x = $matrix1[$i][$matrix1Columns-1];                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        $matrix1[$i][$j] = $x;                    }                }            }            if ($matrix1Rows < $matrix2Rows) {                $x = $matrix1[$matrix1Rows-1];                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $matrix1[$i] = $x;                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
279,PHPOffice_PHPExcel_Calculation_157, Format details of an operand for display in the log (based on operand type)\\\\\\\\n\\\\\\\\n @param    mixed        $value    First matrix operand\\\\\\\\n @return    mixed\\\\\\\\n,Formatiraj detalje operanta za prikazivanje u logu.,"    private function showValue($value)    {        if ($this->_debugLog->getWriteDebugLog()) {            $testArray = PHPExcel_Calculation_Functions::flattenArray($value);            if (count($testArray) == 1) {                $value = array_pop($testArray);            }            if (is_array($value)) {                $returnMatrix = array();                $pad = $rpad = ', ';                foreach ($value as $row) {                    if (is_array($row)) {                        $returnMatrix[] = implode($pad, array_map(array($this, 'showValue'), $row));                        $rpad = '; ';                    } else {                        $returnMatrix[] = $this->showValue($row);                    }                }                return '{ '.implode($rpad, $returnMatrix).' }';            } elseif (is_string($value) && (trim($value, '""') == $value)) {                return '""'.$value.'""';            } elseif (is_bool($value)) {                return ($value) ? self::$localeBoolean['TRUE'] : self::$localeBoolean['FALSE'];            }        }        return PHPExcel_Calculation_Functions::flattenSingleValue($value);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
280,PHPOffice_PHPExcel_Calculation_158, Format type and details of an operand for display in the log (based on operand type)\\\\n\\\\n @param    mixed        $value    First matrix operand\\\\n @return    mixed\\\\n,Formatiraj detalje I tip operanta za prikazivanje.u logu (zavisi od tipa operanta).,    private function showTypeDetails($value)    {        if ($this->_debugLog->getWriteDebugLog()) {            $testArray = PHPExcel_Calculation_Functions::flattenArray($value);            if (count($testArray) == 1) {                $value = array_pop($testArray);            }            if ($value === null) {                return 'a NULL value';            } elseif (is_float($value)) {                $typeString = 'a floating point number';            } elseif (is_int($value)) {                $typeString = 'an integer number';            } elseif (is_bool($value)) {                $typeString = 'a boolean';            } elseif (is_array($value)) {                $typeString = 'a matrix';            } else {                if ($value == '') {                    return 'an empty string';                } elseif ($value{0} == '#') {                    return 'a '.$value.' error';                } else {                    $typeString = 'a string';                }            }            return $typeString.' with a value of '.$this->showValue($value);        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
281,PHPOffice_PHPExcel_Calculation_160," trigger an error, but nicely, if need be\\n",Trigeruj grešku.,"    protected function raiseFormulaError($errorMessage)    {        $this->formulaError = $errorMessage;        $this->cyclicReferenceStack->clear();        if (!$this->suppressFormulaErrors) {            throw new PHPExcel_Calculation_Exception($errorMessage);        }        trigger_error($errorMessage, E_USER_ERROR);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
282,PHPOffice_PHPExcel_Cell_175,    Get Data validation rules\\\\n\\\\n    @return    PHPExcel_Cell_DataValidation\\\\n    @throws    PHPExcel_Exception\\\\n,Dohvati pravila za validaciju podataka,    public function getDataValidation()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot get data validation for cell that is not bound to a worksheet');        }        return $this->getWorksheet()->getDataValidation($this->getCoordinate());    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
283,PHPOffice_PHPExcel_Cell_176,    Does this cell contain a Hyperlink?\\\\\\\\n\\\\\\\\n    @return boolean\\\\\\\\n    @throws    PHPExcel_Exception\\\\\\\\n,Odredi da li ćelija sadrži hyperlink.,    public function hasHyperlink()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot check for hyperlink when cell is not bound to a worksheet');        }        return $this->getWorksheet()->hyperlinkExists($this->getCoordinate());    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
284,PHPOffice_PHPExcel_Cell_177,    Get Hyperlink\\\\\\\\n\\\\\\\\n    @return    PHPExcel_Cell_Hyperlink\\\\\\\\n    @throws    PHPExcel_Exception\\\\\\\\n,Dohvati hyperlink.,    public function getHyperlink()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot get hyperlink for cell that is not bound to a worksheet');        }        return $this->getWorksheet()->getHyperlink($this->getCoordinate());    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
285,PHPOffice_PHPExcel_Cell_178,    Get parent worksheet\\n\\n    @return PHPExcel_CachedObjectStorage_CacheBase\\n,Dohvati roditeljev radni list.,    public function getParent()    {        return $this->parent;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
286,PHPOffice_PHPExcel_Cell_185,    Build range from coordinate strings\\\\n\\\\n    @param    array    $pRange    Array containg one or more arrays containing one or two coordinate strings\\\\n    @return    string    String representation of $pRange\\\\n    @throws    PHPExcel_Exception\\\\n,Kreiraj opseg iz datih stringova sa koordinatama.,"    public static function buildRange($pRange)    {        // Verify range        if (!is_array($pRange) || empty($pRange) || !is_array($pRange[0])) {            throw new PHPExcel_Exception('Range does not contain any information');        }        // Build range        $imploded = array();        $counter = count($pRange);        for ($i = 0; $i < $counter; ++$i) {            $pRange[$i] = implode(':', $pRange[$i]);        }        $imploded = implode(',', $pRange);        return $imploded;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
287,PHPOffice_PHPExcel_Cell_188," Implement PHP __clone to create a deep clone, not just a shallow copy.\\\\n",Implementacija funkcije za duboko kopiranje objekata.,    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if ((is_object($value)) && ($key != 'parent')) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
288,PHPOffice_PHPExcel_Comment_219, Create a new PHPExcel_Comment\n\n @throws PHPExcel_Exception\n,Konstruktor za kreiranje komentar objekata u ekselu.,    public function __construct()    {        // Initialise variables        $this->author    = 'Author';        $this->text      = new PHPExcel_RichText();        $this->fillColor = new PHPExcel_Style_Color('FFFFFFE1');        $this->alignment = PHPExcel_Style_Alignment::HORIZONTAL_GENERAL;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
289,PHPOffice_PHPExcel_Comment_230, Get hash code\\\\n\\\\n @return string    Hash code\\\\n,Dohvati heš kod.,    public function getHashCode()    {        return md5(            $this->author .            $this->text->getHashCode() .            $this->width .            $this->height .            $this->marginLeft .            $this->marginTop .            ($this->visible ? 1 : 0) .            $this->fillColor->getHashCode() .            $this->alignment .            __CLASS__        );    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
290,PHPOffice_PHPExcel_DocumentSecurity_253, Is some sort of document security enabled?\\\\n\\\\n @return boolean\\\\n,Da li je omogućena neka vrsta zaštite dokumenta.,    public function isSecurityEnabled()    {        return  $this->lockRevision ||                $this->lockStructure ||                $this->lockWindows;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
291,PHPOffice_PHPExcel_DocumentSecurity_259," Implement PHP __clone to create a deep clone, not just a shallow copy.\\\\\\\\n",Implementacija funkcije za duboko kopiranje objekata.,    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if (is_object($value)) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
292,PHPOffice_PHPExcel_Exception_261, Error handler callback\n\n @param mixed $code\n @param mixed $string\n @param mixed $file\n @param mixed $line\n @param mixed $context\n,Povratna funkcija za obradu greške.,"    public static function errorHandlerCallback($code, $string, $file, $line, $context)    {        $e = new self($string, $code);        $e->line = $line;        $e->file = $file;        throw $e;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
293,PHPOffice_PHPExcel_PHPExcel_107, Get index for sheet\\n\\n @param  PHPExcel_Worksheet $pSheet\\n @return int Sheet index\\n @throws PHPExcel_Exception\\n,Dohvati indeks stranice iz kolekcije Excel radnih stranica.,"    public function getIndex(PHPExcel_Worksheet $pSheet)    {        foreach ($this->workSheetCollection as $key => $value) {            if ($value->getHashCode() == $pSheet->getHashCode()) {                return $key;            }        }        throw new PHPExcel_Exception(""Sheet does not exist."");    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
294,PHPOffice_PHPExcel_PHPExcel_115, Copy workbook (!= clone!)\\n\\n @return PHPExcel\\n,kopiraj radnu svesku,    public function copy()    {        $copied = clone $this;        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            $this->workSheetCollection[$i] = $this->workSheetCollection[$i]->copy();            $this->workSheetCollection[$i]->rebindParent($this);        }        return $copied;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
295,PHPOffice_PHPExcel_PHPExcel_116," Implement PHP __clone to create a deep clone, not just a shallow copy.\\n",Implementacija funkcije za duboko kopiranje objekata.,    public function __clone()    {        foreach ($this as $key => $val) {            if (is_object($val) || (is_array($val))) {                $this->{$key} = unserialize(serialize($val));            }        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
296,PHPOffice_PHPExcel_PHPExcel_123, Eliminate all unneeded cellXf and afterwards update the xfIndex for all cells\\n and columns in the workbook\\n,Eleminiši sve nepotrebne Xf ćelije i ažuriraj indekse kolona i redova svih preostalih ćelija u radnoj svesci.,"    public function garbageCollect()    {        // how many references are there to each cellXf ?        $countReferencesCellXf = array();        foreach ($this->cellXfCollection as $index => $cellXf) {            $countReferencesCellXf[$index] = 0;        }        foreach ($this->getWorksheetIterator() as $sheet) {            // from cells            foreach ($sheet->getCellCollection(false) as $cellID) {                $cell = $sheet->getCell($cellID);                ++$countReferencesCellXf[$cell->getXfIndex()];            }            // from row dimensions            foreach ($sheet->getRowDimensions() as $rowDimension) {                if ($rowDimension->getXfIndex() !== null) {                    ++$countReferencesCellXf[$rowDimension->getXfIndex()];                }            }            // from column dimensions            foreach ($sheet->getColumnDimensions() as $columnDimension) {                ++$countReferencesCellXf[$columnDimension->getXfIndex()];            }        }        // remove cellXfs without references and create mapping so we can update xfIndex        // for all cells and columns        $countNeededCellXfs = 0;        $map = array();        foreach ($this->cellXfCollection as $index => $cellXf) {            if ($countReferencesCellXf[$index] > 0 || $index == 0) { // we must never remove the first cellXf                ++$countNeededCellXfs;            } else {                unset($this->cellXfCollection[$index]);            }            $map[$index] = $countNeededCellXfs - 1;        }        $this->cellXfCollection = array_values($this->cellXfCollection);        // update the index for all cellXfs        foreach ($this->cellXfCollection as $i => $cellXf) {            $cellXf->setIndex($i);        }        // make sure there is always at least one cellXf (there should be)        if (empty($this->cellXfCollection)) {            $this->cellXfCollection[] = new PHPExcel_Style();        }        // update the xfIndex for all cells, row dimensions, column dimensions        foreach ($this->getWorksheetIterator() as $sheet) {            // for all cells            foreach ($sheet->getCellCollection(false) as $cellID) {                $cell = $sheet->getCell($cellID);                $cell->setXfIndex($map[$cell->getXfIndex()]);            }            // for all row dimensions            foreach ($sheet->getRowDimensions() as $rowDimension) {                if ($rowDimension->getXfIndex() !== null) {                    $rowDimension->setXfIndex($map[$rowDimension->getXfIndex()]);                }            }            // for all column dimensions            foreach ($sheet->getColumnDimensions() as $columnDimension) {                $columnDimension->setXfIndex($map[$columnDimension->getXfIndex()]);            }            // also do garbage collection for all the sheets            $sheet->garbageCollect();        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
297,PHPOffice_PHPExcel_PHPExcel_86," PHPExcel\n\n Copyright (c) 2006 - 2015 PHPExcel\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n @category   PHPExcel\n @package    PHPExcel\n @copyright  Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\n @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\n @version    ##VERSION##, ##DATE##\n",PHP implementacija klase za rad sa Ekselom.,"class PHPExcel{    /**     * Unique ID     *     * @var string     */    private $uniqueID;    /**     * Document properties     *     * @var PHPExcel_DocumentProperties     */    private $properties;    /**     * Document security     *     * @var PHPExcel_DocumentSecurity     */    private $security;    /**     * Collection of Worksheet objects     *     * @var PHPExcel_Worksheet[]     */    private $workSheetCollection = array();    /**     * Calculation Engine     *     * @var PHPExcel_Calculation     */    private $calculationEngine;    /**     * Active sheet index     *     * @var integer     */    private $activeSheetIndex = 0;    /**     * Named ranges     *     * @var PHPExcel_NamedRange[]     */    private $namedRanges = array();    /**     * CellXf supervisor     *     * @var PHPExcel_Style     */    private $cellXfSupervisor;    /**     * CellXf collection     *     * @var PHPExcel_Style[]     */    private $cellXfCollection = array();    /**     * CellStyleXf collection     *     * @var PHPExcel_Style[]     */    private $cellStyleXfCollection = array();    /**    * hasMacros : this workbook have macros ?    *    * @var bool    */    private $hasMacros = false;    /**    * macrosCode : all macros code (the vbaProject.bin file, this include form, code,  etc.), null if no macro    *    * @var binary    */    private $macrosCode;    /**    * macrosCertificate : if macros are signed, contains vbaProjectSignature.bin file, null if not signed    *    * @var binary    */    private $macrosCertificate;    /**    * ribbonXMLData : null if workbook is'nt Excel 2007 or not contain a customized UI    *    * @var null|string    */    private $ribbonXMLData;    /**    * ribbonBinObjects : null if workbook is'nt Excel 2007 or not contain embedded objects (picture(s)) for Ribbon Elements    * ignored if $ribbonXMLData is null    *    * @var null|array    */    private $ribbonBinObjects;    /**    * The workbook has macros ?    *    * @return boolean true if workbook has macros, false if not    */    public function hasMacros()    {        return $this->hasMacros;    }    /**    * Define if a workbook has macros    *    * @param boolean $hasMacros true|false    */    public function setHasMacros($hasMacros = false)    {        $this->hasMacros = (bool) $hasMacros;    }    /**    * Set the macros code    *    * @param string $MacrosCode string|null    */    public function setMacrosCode($MacrosCode = null)    {        $this->macrosCode=$MacrosCode;        $this->setHasMacros(!is_null($MacrosCode));    }    /**    * Return the macros code    *    * @return string|null    */    public function getMacrosCode()    {        return $this->macrosCode;    }    /**    * Set the macros certificate    *    * @param string|null $Certificate    */    public function setMacrosCertificate($Certificate = null)    {        $this->macrosCertificate=$Certificate;    }    /**    * Is the project signed ?    *    * @return boolean true|false    */    public function hasMacrosCertificate()    {        return !is_null($this->macrosCertificate);    }    /**    * Return the macros certificate    *    * @return string|null    */    public function getMacrosCertificate()    {        return $this->macrosCertificate;    }    /**    * Remove all macros, certificate from spreadsheet    *    */    public function discardMacros()    {        $this->hasMacros=false;        $this->macrosCode=null;        $this->macrosCertificate=null;    }    /**    * set ribbon XML data    *    */    public function setRibbonXMLData($Target = null, $XMLData = null)    {        if (!is_null($Target) && !is_null($XMLData)) {            $this->ribbonXMLData = array('target' => $Target, 'data' => $XMLData);        } else {            $this->ribbonXMLData = null;        }    }    /**    * retrieve ribbon XML Data    *    * return string|null|array    */    public function getRibbonXMLData($What = 'all') //we need some constants here...    {        $ReturnData = null;        $What = strtolower($What);        switch ($What){            case 'all':                $ReturnData = $this->ribbonXMLData;                break;            case 'target':            case 'data':                if (is_array($this->ribbonXMLData) && array_key_exists($What, $this->ribbonXMLData)) {                    $ReturnData = $this->ribbonXMLData[$What];                }                break;        }        return $ReturnData;    }    /**    * store binaries ribbon objects (pictures)    *    */    public function setRibbonBinObjects($BinObjectsNames = null, $BinObjectsData = null)    {        if (!is_null($BinObjectsNames) && !is_null($BinObjectsData)) {            $this->ribbonBinObjects = array('names' => $BinObjectsNames, 'data' => $BinObjectsData);        } else {            $this->ribbonBinObjects = null;        }    }    /**    * return the extension of a filename. Internal use for a array_map callback (php<5.3 don't like lambda function)    *    */    private function getExtensionOnly($ThePath)    {        return pathinfo($ThePath, PATHINFO_EXTENSION);    }    /**    * retrieve Binaries Ribbon Objects    *    */    public function getRibbonBinObjects($What = 'all')    {        $ReturnData = null;        $What = strtolower($What);        switch($What) {            case 'all':                return $this->ribbonBinObjects;                break;            case 'names':            case 'data':                if (is_array($this->ribbonBinObjects) && array_key_exists($What, $this->ribbonBinObjects)) {                    $ReturnData=$this->ribbonBinObjects[$What];                }                break;            case 'types':                if (is_array($this->ribbonBinObjects) &&                    array_key_exists('data', $this->ribbonBinObjects) && is_array($this->ribbonBinObjects['data'])) {                    $tmpTypes=array_keys($this->ribbonBinObjects['data']);                    $ReturnData = array_unique(array_map(array($this, 'getExtensionOnly'), $tmpTypes));                } else {                    $ReturnData=array(); // the caller want an array... not null if empty                }                break;        }        return $ReturnData;    }    /**    * This workbook have a custom UI ?    *    * @return boolean true|false    */    public function hasRibbon()    {        return !is_null($this->ribbonXMLData);    }    /**    * This workbook have additionnal object for the ribbon ?    *    * @return boolean true|false    */    public function hasRibbonBinObjects()    {        return !is_null($this->ribbonBinObjects);    }    /**     * Check if a sheet with a specified code name already exists     *     * @param string $pSheetCodeName  Name of the worksheet to check     * @return boolean     */    public function sheetCodeNameExists($pSheetCodeName)    {        return ($this->getSheetByCodeName($pSheetCodeName) !== null);    }    /**     * Get sheet by code name. Warning : sheet don't have always a code name !     *     * @param string $pName Sheet name     * @return PHPExcel_Worksheet     */    public function getSheetByCodeName($pName = '')    {        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            if ($this->workSheetCollection[$i]->getCodeName() == $pName) {                return $this->workSheetCollection[$i];            }        }        return null;    }     /**     * Create a new PHPExcel with one Worksheet     */    public function __construct()    {        $this->uniqueID = uniqid();        $this->calculationEngine = new PHPExcel_Calculation($this);        // Initialise worksheet collection and add one worksheet        $this->workSheetCollection = array();        $this->workSheetCollection[] = new PHPExcel_Worksheet($this);        $this->activeSheetIndex = 0;        // Create document properties        $this->properties = new PHPExcel_DocumentProperties();        // Create document security        $this->security = new PHPExcel_DocumentSecurity();        // Set named ranges        $this->namedRanges = array();        // Create the cellXf supervisor        $this->cellXfSupervisor = new PHPExcel_Style(true);        $this->cellXfSupervisor->bindParent($this);        // Create the default style        $this->addCellXf(new PHPExcel_Style);        $this->addCellStyleXf(new PHPExcel_Style);    }    /**     * Code to execute when this worksheet is unset()     *     */    public function __destruct()    {        $this->calculationEngine = null;        $this->disconnectWorksheets();    }    /**     * Disconnect all worksheets from this PHPExcel workbook object,     *    typically so that the PHPExcel object can be unset     *     */    public function disconnectWorksheets()    {        $worksheet = null;        foreach ($this->workSheetCollection as $k => &$worksheet) {            $worksheet->disconnectCells();            $this->workSheetCollection[$k] = null;        }        unset($worksheet);        $this->workSheetCollection = array();    }    /**     * Return the calculation engine for this worksheet     *     * @return PHPExcel_Calculation     */    public function getCalculationEngine()    {        return $this->calculationEngine;    }    //    function getCellCacheController()    /**     * Get properties     *     * @return PHPExcel_DocumentProperties     */    public function getProperties()    {        return $this->properties;    }    /**     * Set properties     *     * @param PHPExcel_DocumentProperties    $pValue     */    public function setProperties(PHPExcel_DocumentProperties $pValue)    {        $this->properties = $pValue;    }    /**     * Get security     *     * @return PHPExcel_DocumentSecurity     */    public function getSecurity()    {        return $this->security;    }    /**     * Set security     *     * @param PHPExcel_DocumentSecurity    $pValue     */    public function setSecurity(PHPExcel_DocumentSecurity $pValue)    {        $this->security = $pValue;    }    /**     * Get active sheet     *     * @return PHPExcel_Worksheet     *     * @throws PHPExcel_Exception     */    public function getActiveSheet()    {        return $this->getSheet($this->activeSheetIndex);    }    /**     * Create sheet and add it to this workbook     *     * @param  int|null $iSheetIndex Index where sheet should go (0,1,..., or null for last)     * @return PHPExcel_Worksheet     * @throws PHPExcel_Exception     */    public function createSheet($iSheetIndex = null)    {        $newSheet = new PHPExcel_Worksheet($this);        $this->addSheet($newSheet, $iSheetIndex);        return $newSheet;    }    /**     * Check if a sheet with a specified name already exists     *     * @param  string $pSheetName  Name of the worksheet to check     * @return boolean     */    public function sheetNameExists($pSheetName)    {        return ($this->getSheetByName($pSheetName) !== null);    }    /**     * Add sheet     *     * @param  PHPExcel_Worksheet $pSheet     * @param  int|null $iSheetIndex Index where sheet should go (0,1,..., or null for last)     * @return PHPExcel_Worksheet     * @throws PHPExcel_Exception     */    public function addSheet(PHPExcel_Worksheet $pSheet, $iSheetIndex = null)    {        if ($this->sheetNameExists($pSheet->getTitle())) {            throw new PHPExcel_Exception(                ""Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename this worksheet first.""            );        }        if ($iSheetIndex === null) {            if ($this->activeSheetIndex < 0) {                $this->activeSheetIndex = 0;            }            $this->workSheetCollection[] = $pSheet;        } else {            // Insert the sheet at the requested index            array_splice(                $this->workSheetCollection,                $iSheetIndex,                0,                array($pSheet)            );            // Adjust active sheet index if necessary            if ($this->activeSheetIndex >= $iSheetIndex) {                ++$this->activeSheetIndex;            }        }        if ($pSheet->getParent() === null) {            $pSheet->rebindParent($this);        }        return $pSheet;    }    /**     * Remove sheet by index     *     * @param  int $pIndex Active sheet index     * @throws PHPExcel_Exception     */    public function removeSheetByIndex($pIndex = 0)    {        $numSheets = count($this->workSheetCollection);        if ($pIndex > $numSheets - 1) {            throw new PHPExcel_Exception(                ""You tried to remove a sheet by the out of bounds index: {$pIndex}. The actual number of sheets is {$numSheets}.""            );        } else {            array_splice($this->workSheetCollection, $pIndex, 1);        }        // Adjust active sheet index if necessary        if (($this->activeSheetIndex >= $pIndex) &&            ($pIndex > count($this->workSheetCollection) - 1)) {            --$this->activeSheetIndex;        }    }    /**     * Get sheet by index     *     * @param  int $pIndex Sheet index     * @return PHPExcel_Worksheet     * @throws PHPExcel_Exception     */    public function getSheet($pIndex = 0)    {        if (!isset($this->workSheetCollection[$pIndex])) {            $numSheets = $this->getSheetCount();            throw new PHPExcel_Exception(                ""Your requested sheet index: {$pIndex} is out of bounds. The actual number of sheets is {$numSheets}.""            );        }        return $this->workSheetCollection[$pIndex];    }    /**     * Get all sheets     *     * @return PHPExcel_Worksheet[]     */    public function getAllSheets()    {        return $this->workSheetCollection;    }    /**     * Get sheet by name     *     * @param  string $pName Sheet name     * @return PHPExcel_Worksheet     */    public function getSheetByName($pName = '')    {        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            if ($this->workSheetCollection[$i]->getTitle() === $pName) {                return $this->workSheetCollection[$i];            }        }        return null;    }    /**     * Get index for sheet     *     * @param  PHPExcel_Worksheet $pSheet     * @return int Sheet index     * @throws PHPExcel_Exception     */    public function getIndex(PHPExcel_Worksheet $pSheet)    {        foreach ($this->workSheetCollection as $key => $value) {            if ($value->getHashCode() == $pSheet->getHashCode()) {                return $key;            }        }        throw new PHPExcel_Exception(""Sheet does not exist."");    }    /**     * Set index for sheet by sheet name.     *     * @param  string $sheetName Sheet name to modify index for     * @param  int $newIndex New index for the sheet     * @return int New sheet index     * @throws PHPExcel_Exception     */    public function setIndexByName($sheetName, $newIndex)    {        $oldIndex = $this->getIndex($this->getSheetByName($sheetName));        $pSheet = array_splice(            $this->workSheetCollection,            $oldIndex,            1        );        array_splice(            $this->workSheetCollection,            $newIndex,            0,            $pSheet        );        return $newIndex;    }    /**     * Get sheet count     *     * @return int     */    public function getSheetCount()    {        return count($this->workSheetCollection);    }    /**     * Get active sheet index     *     * @return int Active sheet index     */    public function getActiveSheetIndex()    {        return $this->activeSheetIndex;    }    /**     * Set active sheet index     *     * @param  int $pIndex Active sheet index     * @throws PHPExcel_Exception     * @return PHPExcel_Worksheet     */    public function setActiveSheetIndex($pIndex = 0)    {        $numSheets = count($this->workSheetCollection);        if ($pIndex > $numSheets - 1) {            throw new PHPExcel_Exception(                ""You tried to set a sheet active by the out of bounds index: {$pIndex}. The actual number of sheets is {$numSheets}.""            );        } else {            $this->activeSheetIndex = $pIndex;        }        return $this->getActiveSheet();    }    /**     * Set active sheet index by name     *     * @param  string $pValue Sheet title     * @return PHPExcel_Worksheet     * @throws PHPExcel_Exception     */    public function setActiveSheetIndexByName($pValue = '')    {        if (($worksheet = $this->getSheetByName($pValue)) instanceof PHPExcel_Worksheet) {            $this->setActiveSheetIndex($this->getIndex($worksheet));            return $worksheet;        }        throw new PHPExcel_Exception('Workbook does not contain sheet:' . $pValue);    }    /**     * Get sheet names     *     * @return string[]     */    public function getSheetNames()    {        $returnValue = array();        $worksheetCount = $this->getSheetCount();        for ($i = 0; $i < $worksheetCount; ++$i) {            $returnValue[] = $this->getSheet($i)->getTitle();        }        return $returnValue;    }    /**     * Add external sheet     *     * @param  PHPExcel_Worksheet $pSheet External sheet to add     * @param  int|null $iSheetIndex Index where sheet should go (0,1,..., or null for last)     * @throws PHPExcel_Exception     * @return PHPExcel_Worksheet     */    public function addExternalSheet(PHPExcel_Worksheet $pSheet, $iSheetIndex = null)    {        if ($this->sheetNameExists($pSheet->getTitle())) {            throw new PHPExcel_Exception(""Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename the external sheet first."");        }        // count how many cellXfs there are in this workbook currently, we will need this below        $countCellXfs = count($this->cellXfCollection);        // copy all the shared cellXfs from the external workbook and append them to the current        foreach ($pSheet->getParent()->getCellXfCollection() as $cellXf) {            $this->addCellXf(clone $cellXf);        }        // move sheet to this workbook        $pSheet->rebindParent($this);        // update the cellXfs        foreach ($pSheet->getCellCollection(false) as $cellID) {            $cell = $pSheet->getCell($cellID);            $cell->setXfIndex($cell->getXfIndex() + $countCellXfs);        }        return $this->addSheet($pSheet, $iSheetIndex);    }    /**     * Get named ranges     *     * @return PHPExcel_NamedRange[]     */    public function getNamedRanges()    {        return $this->namedRanges;    }    /**     * Add named range     *     * @param  PHPExcel_NamedRange $namedRange     * @return boolean     */    public function addNamedRange(PHPExcel_NamedRange $namedRange)    {        if ($namedRange->getScope() == null) {            // global scope            $this->namedRanges[$namedRange->getName()] = $namedRange;        } else {            // local scope            $this->namedRanges[$namedRange->getScope()->getTitle().'!'.$namedRange->getName()] = $namedRange;        }        return true;    }    /**     * Get named range     *     * @param  string $namedRange     * @param  PHPExcel_Worksheet|null $pSheet Scope. Use null for global scope     * @return PHPExcel_NamedRange|null     */    public function getNamedRange($namedRange, PHPExcel_Worksheet $pSheet = null)    {        $returnValue = null;        if ($namedRange != '' && ($namedRange !== null)) {            // first look for global defined name            if (isset($this->namedRanges[$namedRange])) {                $returnValue = $this->namedRanges[$namedRange];            }            // then look for local defined name (has priority over global defined name if both names exist)            if (($pSheet !== null) && isset($this->namedRanges[$pSheet->getTitle() . '!' . $namedRange])) {                $returnValue = $this->namedRanges[$pSheet->getTitle() . '!' . $namedRange];            }        }        return $returnValue;    }    /**     * Remove named range     *     * @param  string  $namedRange     * @param  PHPExcel_Worksheet|null  $pSheet  Scope: use null for global scope.     * @return PHPExcel     */    public function removeNamedRange($namedRange, PHPExcel_Worksheet $pSheet = null)    {        if ($pSheet === null) {            if (isset($this->namedRanges[$namedRange])) {                unset($this->namedRanges[$namedRange]);            }        } else {            if (isset($this->namedRanges[$pSheet->getTitle() . '!' . $namedRange])) {                unset($this->namedRanges[$pSheet->getTitle() . '!' . $namedRange]);            }        }        return $this;    }    /**     * Get worksheet iterator     *     * @return PHPExcel_WorksheetIterator     */    public function getWorksheetIterator()    {        return new PHPExcel_WorksheetIterator($this);    }    /**     * Copy workbook (!= clone!)     *     * @return PHPExcel     */    public function copy()    {        $copied = clone $this;        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            $this->workSheetCollection[$i] = $this->workSheetCollection[$i]->copy();            $this->workSheetCollection[$i]->rebindParent($this);        }        return $copied;    }    /**     * Implement PHP __clone to create a deep clone, not just a shallow copy.     */    public function __clone()    {        foreach ($this as $key => $val) {            if (is_object($val) || (is_array($val))) {                $this->{$key} = unserialize(serialize($val));            }        }    }    /**     * Get the workbook collection of cellXfs     *     * @return PHPExcel_Style[]     */    public function getCellXfCollection()    {        return $this->cellXfCollection;    }    /**     * Get cellXf by index     *     * @param  int $pIndex     * @return PHPExcel_Style     */    public function getCellXfByIndex($pIndex = 0)    {        return $this->cellXfCollection[$pIndex];    }    /**     * Get cellXf by hash code     *     * @param  string $pValue     * @return PHPExcel_Style|boolean False if no match found     */    public function getCellXfByHashCode($pValue = '')    {        foreach ($this->cellXfCollection as $cellXf) {            if ($cellXf->getHashCode() == $pValue) {                return $cellXf;            }        }        return false;    }    /**     * Check if style exists in style collection     *     * @param  PHPExcel_Style $pCellStyle     * @return boolean     */    public function cellXfExists($pCellStyle = null)    {        return in_array($pCellStyle, $this->cellXfCollection, true);    }    /**     * Get default style     *     * @return PHPExcel_Style     * @throws PHPExcel_Exception     */    public function getDefaultStyle()    {        if (isset($this->cellXfCollection[0])) {            return $this->cellXfCollection[0];        }        throw new PHPExcel_Exception('No default style found for this workbook');    }    /**     * Add a cellXf to the workbook     *     * @param PHPExcel_Style $style     */    public function addCellXf(PHPExcel_Style $style)    {        $this->cellXfCollection[] = $style;        $style->setIndex(count($this->cellXfCollection) - 1);    }    /**     * Remove cellXf by index. It is ensured that all cells get their xf index updated.     *     * @param integer $pIndex Index to cellXf     * @throws PHPExcel_Exception     */    public function removeCellXfByIndex($pIndex = 0)    {        if ($pIndex > count($this->cellXfCollection) - 1) {            throw new PHPExcel_Exception(""CellXf index is out of bounds."");        } else {            // first remove the cellXf            array_splice($this->cellXfCollection, $pIndex, 1);            // then update cellXf indexes for cells            foreach ($this->workSheetCollection as $worksheet) {                foreach ($worksheet->getCellCollection(false) as $cellID) {                    $cell = $worksheet->getCell($cellID);                    $xfIndex = $cell->getXfIndex();                    if ($xfIndex > $pIndex) {                        // decrease xf index by 1                        $cell->setXfIndex($xfIndex - 1);                    } elseif ($xfIndex == $pIndex) {                        // set to default xf index 0                        $cell->setXfIndex(0);                    }                }            }        }    }    /**     * Get the cellXf supervisor     *     * @return PHPExcel_Style     */    public function getCellXfSupervisor()    {        return $this->cellXfSupervisor;    }    /**     * Get the workbook collection of cellStyleXfs     *     * @return PHPExcel_Style[]     */    public function getCellStyleXfCollection()    {        return $this->cellStyleXfCollection;    }    /**     * Get cellStyleXf by index     *     * @param integer $pIndex Index to cellXf     * @return PHPExcel_Style     */    public function getCellStyleXfByIndex($pIndex = 0)    {        return $this->cellStyleXfCollection[$pIndex];    }    /**     * Get cellStyleXf by hash code     *     * @param  string $pValue     * @return PHPExcel_Style|boolean False if no match found     */    public function getCellStyleXfByHashCode($pValue = '')    {        foreach ($this->cellStyleXfCollection as $cellStyleXf) {            if ($cellStyleXf->getHashCode() == $pValue) {                return $cellStyleXf;            }        }        return false;    }    /**     * Add a cellStyleXf to the workbook     *     * @param PHPExcel_Style $pStyle     */    public function addCellStyleXf(PHPExcel_Style $pStyle)    {        $this->cellStyleXfCollection[] = $pStyle;        $pStyle->setIndex(count($this->cellStyleXfCollection) - 1);    }    /**     * Remove cellStyleXf by index     *     * @param integer $pIndex Index to cellXf     * @throws PHPExcel_Exception     */    public function removeCellStyleXfByIndex($pIndex = 0)    {        if ($pIndex > count($this->cellStyleXfCollection) - 1) {            throw new PHPExcel_Exception(""CellStyleXf index is out of bounds."");        } else {            array_splice($this->cellStyleXfCollection, $pIndex, 1);        }    }    /**     * Eliminate all unneeded cellXf and afterwards update the xfIndex for all cells     * and columns in the workbook     */    public function garbageCollect()    {        // how many references are there to each cellXf ?        $countReferencesCellXf = array();        foreach ($this->cellXfCollection as $index => $cellXf) {            $countReferencesCellXf[$index] = 0;        }        foreach ($this->getWorksheetIterator() as $sheet) {            // from cells            foreach ($sheet->getCellCollection(false) as $cellID) {                $cell = $sheet->getCell($cellID);                ++$countReferencesCellXf[$cell->getXfIndex()];            }            // from row dimensions            foreach ($sheet->getRowDimensions() as $rowDimension) {                if ($rowDimension->getXfIndex() !== null) {                    ++$countReferencesCellXf[$rowDimension->getXfIndex()];                }            }            // from column dimensions            foreach ($sheet->getColumnDimensions() as $columnDimension) {                ++$countReferencesCellXf[$columnDimension->getXfIndex()];            }        }        // remove cellXfs without references and create mapping so we can update xfIndex        // for all cells and columns        $countNeededCellXfs = 0;        $map = array();        foreach ($this->cellXfCollection as $index => $cellXf) {            if ($countReferencesCellXf[$index] > 0 || $index == 0) { // we must never remove the first cellXf                ++$countNeededCellXfs;            } else {                unset($this->cellXfCollection[$index]);            }            $map[$index] = $countNeededCellXfs - 1;        }        $this->cellXfCollection = array_values($this->cellXfCollection);        // update the index for all cellXfs        foreach ($this->cellXfCollection as $i => $cellXf) {            $cellXf->setIndex($i);        }        // make sure there is always at least one cellXf (there should be)        if (empty($this->cellXfCollection)) {            $this->cellXfCollection[] = new PHPExcel_Style();        }        // update the xfIndex for all cells, row dimensions, column dimensions        foreach ($this->getWorksheetIterator() as $sheet) {            // for all cells            foreach ($sheet->getCellCollection(false) as $cellID) {                $cell = $sheet->getCell($cellID);                $cell->setXfIndex($map[$cell->getXfIndex()]);            }            // for all row dimensions            foreach ($sheet->getRowDimensions() as $rowDimension) {                if ($rowDimension->getXfIndex() !== null) {                    $rowDimension->setXfIndex($map[$rowDimension->getXfIndex()]);                }            }            // for all column dimensions            foreach ($sheet->getColumnDimensions() as $columnDimension) {                $columnDimension->setXfIndex($map[$columnDimension->getXfIndex()]);            }            // also do garbage collection for all the sheets            $sheet->garbageCollect();        }    }    /**     * Return the unique ID value assigned to this spreadsheet workbook     *     * @return string     */    public function getID()    {        return $this->uniqueID;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
298,PHPOffice_PHPExcel_PHPExcel_96, Create a new PHPExcel with one Worksheet\n,Konstruiši novi PHP eksel objekat sa jednom radnom sveskom.,    public function __construct()    {        $this->uniqueID = uniqid();        $this->calculationEngine = new PHPExcel_Calculation($this);        // Initialise worksheet collection and add one worksheet        $this->workSheetCollection = array();        $this->workSheetCollection[] = new PHPExcel_Worksheet($this);        $this->activeSheetIndex = 0;        // Create document properties        $this->properties = new PHPExcel_DocumentProperties();        // Create document security        $this->security = new PHPExcel_DocumentSecurity();        // Set named ranges        $this->namedRanges = array();        // Create the cellXf supervisor        $this->cellXfSupervisor = new PHPExcel_Style(true);        $this->cellXfSupervisor->bindParent($this);        // Create the default style        $this->addCellXf(new PHPExcel_Style);        $this->addCellStyleXf(new PHPExcel_Style);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
299,PHPOffice_PHPWord_AbstractCollection_973, Add new item\\n\\n @param \\\\PhpOffice\\\\PhpWord\\\\Element\\\\AbstractContainer $item\\n @return int\\n,Dodaj novi podatak u kolekciju.,    public function addItem($item)    {        $index = $this->countItems() + 1;        $this->items[$index] = $item;        return $index;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
300,PHPOffice_PHPWord_Bookmarks_975, Bookmarks collection\\n\\n @since 0.12.0\\n,Klasa kolekcije obeleživača.,class Bookmarks extends AbstractCollection{},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
301,PHPOffice_PHPWord_CollectionTest_1047, Test class for PhpOffice\\\\PhpWord\\\\Collection subnamespace\\n\\n Using concrete class Footnotes instead of AbstractCollection\\n,Klasa za testiranje PhpOffice. Koristi se podprostor imena kolekcije. Koristi se konkretna klasa Footnotes umesto klase abstraktne kolekcije.,"class CollectionTest extends \PHPUnit\Framework\TestCase{    /**     * Test collection     */    public function testCollection()    {        $object = new Footnotes();        $object->addItem(new Footnote()); // addItem #1        $this->assertEquals(2, $object->addItem(new Footnote())); // addItem #2. Should returns new item index        $this->assertCount(2, $object->getItems()); // getItems returns array        $this->assertInstanceOf('PhpOffice\\PhpWord\\Element\\Footnote', $object->getItem(1)); // getItem returns object        $this->assertNull($object->getItem(3)); // getItem returns null when invalid index is referenced        $object->setItem(2, null); // Set item #2 to null        $this->assertNull($object->getItem(2)); // Check if it's null    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
302,PHPOffice_PHPWord_FootnotePropertiesTest_1050, Test setting style with normal value\n,Testiraj postavljanje parametara style sa normalnim vrednostima.,"    public function testSetGetNormal()    {        $footnoteProp = new FootnoteProperties();        $footnoteProp->setPos(FootnoteProperties::POSITION_DOC_END);        $footnoteProp->setNumFmt(NumberFormat::LOWER_ROMAN);        $footnoteProp->setNumStart(2);        $footnoteProp->setNumRestart(FootnoteProperties::RESTART_NUMBER_EACH_PAGE);        $this->assertEquals(FootnoteProperties::POSITION_DOC_END, $footnoteProp->getPos());        $this->assertEquals(NumberFormat::LOWER_ROMAN, $footnoteProp->getNumFmt());        $this->assertEquals(2, $footnoteProp->getNumStart());        $this->assertEquals(FootnoteProperties::RESTART_NUMBER_EACH_PAGE, $footnoteProp->getNumRestart());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
303,PHPOffice_PHPWord_FootnotePropertiesTest_1051, Test throws exception if wrong position given\n\n @expectedException \\InvalidArgumentException\n,Test će izbaciti izuzetak ukoliko su prosleđene vrednosti za poziciju pogrešne.,    public function testWrongPos()    {        $footnoteProp = new FootnoteProperties();        $footnoteProp->setPos(NumberFormat::LOWER_ROMAN);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
304,PHPOffice_PHPWord_FootnotePropertiesTest_1052, Test throws exception if wrong number format given\n\n @expectedException \\InvalidArgumentException\n,Test će izbaciti izuzetak ukoliko je prosleđen broj u lošem formatu.,    public function testWrongNumFmt()    {        $footnoteProp = new FootnoteProperties();        $footnoteProp->setNumFmt(FootnoteProperties::POSITION_DOC_END);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
305,PHPOffice_PHPWord_IOFactoryTest_980, Create existing reader\n,Testiraj postojećeg čitača za Php office.,"    public function testExistingReaderCanBeCreated()    {        $this->assertInstanceOf(            'PhpOffice\\PhpWord\\Reader\\Word2007',            IOFactory::createReader('Word2007')        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
306,PHPOffice_PHPWord_MediaTest_989, Add section link\n,Dodaj odeljak za linkovanje.,"    public function testAddSectionLinkElement()    {        $expected = Media::countElements('section') + 1;        $actual = Media::addElement('section', 'link', 'http://test.com');        $this->assertEquals($expected, $actual);        $this->assertCount(1, Media::getElements('section', 'link'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
307,PHPOffice_PHPWord_MediaTest_991, Add footer media element and reset media\\n,Dodaj element futer medija i resetuj medij. ,"    public function testAddFooterMediaElement()    {        $local = __DIR__ . '/_files/images/mars.jpg';        $remote = self::getRemoteImageUrl();        Media::addElement('footer1', 'image', $local, new Image($local));        Media::addElement('footer1', 'image', $local, new Image($local));        Media::addElement('footer1', 'image', $remote, new Image($remote));        $this->assertCount(2, Media::getElements('footer1'));        Media::resetElements();        $this->assertCount(0, Media::getElements('footer1'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
308,PHPOffice_PHPWord_Media_873, Media collection\n,Klasa kolekcije Medija.,"class Media{    /**     * Media elements     *     * @var array     */    private static $elements = array();    /**     * Add new media element     *     * @since 0.10.0     * @since 0.9.2     *     * @param string $container section|headerx|footerx|footnote|endnote     * @param string $mediaType image|object|link     * @param string $source     * @param \PhpOffice\PhpWord\Element\Image $image     *     * @throws \PhpOffice\PhpWord\Exception\Exception     *     * @return int     */    public static function addElement($container, $mediaType, $source, Image $image = null)    {        // Assign unique media Id and initiate media container if none exists        $mediaId = md5($container . $source);        if (!isset(self::$elements[$container])) {            self::$elements[$container] = array();        }        // Add media if not exists or point to existing media        if (!isset(self::$elements[$container][$mediaId])) {            $mediaCount = self::countElements($container);            $mediaTypeCount = self::countElements($container, $mediaType);            $mediaTypeCount++;            $rId = ++$mediaCount;            $target = null;            $mediaData = array('mediaIndex' => $mediaTypeCount);            switch ($mediaType) {                // Images                case 'image':                    if (is_null($image)) {                        throw new Exception('Image object not assigned.');                    }                    $isMemImage = $image->isMemImage();                    $extension = $image->getImageExtension();                    $mediaData['imageExtension'] = $extension;                    $mediaData['imageType'] = $image->getImageType();                    if ($isMemImage) {                        $mediaData['isMemImage'] = true;                        $mediaData['createFunction'] = $image->getImageCreateFunction();                        $mediaData['imageFunction'] = $image->getImageFunction();                    }                    $target = ""{$container}_image{$mediaTypeCount}.{$extension}"";                    $image->setTarget($target);                    $image->setMediaIndex($mediaTypeCount);                    break;                // Objects                case 'object':                    $target = ""{$container}_oleObject{$mediaTypeCount}.bin"";                    break;                // Links                case 'link':                    $target = $source;                    break;            }            $mediaData['source'] = $source;            $mediaData['target'] = $target;            $mediaData['type'] = $mediaType;            $mediaData['rID'] = $rId;            self::$elements[$container][$mediaId] = $mediaData;            return $rId;        }        $mediaData = self::$elements[$container][$mediaId];        if (!is_null($image)) {            $image->setTarget($mediaData['target']);            $image->setMediaIndex($mediaData['mediaIndex']);        }        return $mediaData['rID'];    }    /**     * Get media elements count     *     * @param string $container section|headerx|footerx|footnote|endnote     * @param string $mediaType image|object|link     * @return int     * @since 0.10.0     */    public static function countElements($container, $mediaType = null)    {        $mediaCount = 0;        if (isset(self::$elements[$container])) {            foreach (self::$elements[$container] as $mediaData) {                if (!is_null($mediaType)) {                    if ($mediaType == $mediaData['type']) {                        $mediaCount++;                    }                } else {                    $mediaCount++;                }            }        }        return $mediaCount;    }    /**     * Get media elements     *     * @param string $container section|headerx|footerx|footnote|endnote     * @param string $type image|object|link     * @return array     * @since 0.10.0     */    public static function getElements($container, $type = null)    {        $elements = array();        // If header/footer, search for headerx and footerx where x is number        if ($container == 'header' || $container == 'footer') {            foreach (self::$elements as $key => $val) {                if (substr($key, 0, 6) == $container) {                    $elements[$key] = $val;                }            }            return $elements;        }        if (!isset(self::$elements[$container])) {            return $elements;        }        return self::getElementsByType($container, $type);    }    /**     * Get elements by media type     *     * @param string $container section|footnote|endnote     * @param string $type image|object|link     * @return array     * @since 0.11.0 Splitted from `getElements` to reduce complexity     */    private static function getElementsByType($container, $type = null)    {        $elements = array();        foreach (self::$elements[$container] as $key => $data) {            if ($type !== null) {                if ($type == $data['type']) {                    $elements[$key] = $data;                }            } else {                $elements[$key] = $data;            }        }        return $elements;    }    /**     * Reset media elements     */    public static function resetElements()    {        self::$elements = array();    }    /**     * Add new Section Media Element     *     * @deprecated 0.10.0     *     * @param  string $src     * @param  string $type     * @param  \PhpOffice\PhpWord\Element\Image $image     *     * @return int     *     * @codeCoverageIgnore     */    public static function addSectionMediaElement($src, $type, Image $image = null)    {        return self::addElement('section', $type, $src, $image);    }    /**     * Add new Section Link Element     *     * @deprecated 0.10.0     *     * @param string $linkSrc     *     * @return int     *     * @codeCoverageIgnore     */    public static function addSectionLinkElement($linkSrc)    {        return self::addElement('section', 'link', $linkSrc);    }    /**     * Get Section Media Elements     *     * @deprecated 0.10.0     *     * @param string $key     *     * @return array     *     * @codeCoverageIgnore     */    public static function getSectionMediaElements($key = null)    {        return self::getElements('section', $key);    }    /**     * Get Section Media Elements Count     *     * @deprecated 0.10.0     *     * @param string $key     *     * @return int     *     * @codeCoverageIgnore     */    public static function countSectionMediaElements($key = null)    {        return self::countElements('section', $key);    }    /**     * Add new Header Media Element     *     * @deprecated 0.10.0     *     * @param  int $headerCount     * @param  string $src     * @param  \PhpOffice\PhpWord\Element\Image $image     *     * @return int     *     * @codeCoverageIgnore     */    public static function addHeaderMediaElement($headerCount, $src, Image $image = null)    {        return self::addElement(""header{$headerCount}"", 'image', $src, $image);    }    /**     * Get Header Media Elements Count     *     * @deprecated 0.10.0     *     * @param string $key     *     * @return int     *     * @codeCoverageIgnore     */    public static function countHeaderMediaElements($key)    {        return self::countElements($key);    }    /**     * Get Header Media Elements     *     * @deprecated 0.10.0     *     * @return array     *     * @codeCoverageIgnore     */    public static function getHeaderMediaElements()    {        return self::getElements('header');    }    /**     * Add new Footer Media Element     *     * @deprecated 0.10.0     *     * @param  int $footerCount     * @param  string $src     * @param  \PhpOffice\PhpWord\Element\Image $image     *     * @return int     *     * @codeCoverageIgnore     */    public static function addFooterMediaElement($footerCount, $src, Image $image = null)    {        return self::addElement(""footer{$footerCount}"", 'image', $src, $image);    }    /**     * Get Footer Media Elements Count     *     * @deprecated 0.10.0     *     * @param string $key     *     * @return int     *     * @codeCoverageIgnore     */    public static function countFooterMediaElements($key)    {        return self::countElements($key);    }    /**     * Get Footer Media Elements     *     * @deprecated 0.10.0     *     * @return array     *     * @codeCoverageIgnore     */    public static function getFooterMediaElements()    {        return self::getElements('footer');    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
309,PHPOffice_PHPWord_Media_875, Add new Section Link Element\n\n @deprecated 0.10.0\n\n @param string $linkSrc\n\n @return int\n\n @codeCoverageIgnore\n,Dodaj novi element za odeljak linkovanja.,"    public static function addSectionLinkElement($linkSrc)    {        return self::addElement('section', 'link', $linkSrc);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
310,PHPOffice_PHPWord_Media_876, Get Header Media Elements Count\\n\\n @deprecated 0.10.0\\n\\n @param string $key\\n\\n @return int\\n\\n @codeCoverageIgnore\\n,Dohvati broj elemenata medija zaglavlja.,    public static function countHeaderMediaElements($key)    {        return self::countElements($key);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
311,PHPOffice_PHPWord_Media_877, Get Header Media Elements\n\n @deprecated 0.10.0\n\n @return array\n\n @codeCoverageIgnore\n,Dohvati elemenate medija zaglavlja.,    public static function getHeaderMediaElements()    {        return self::getElements('header');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
312,PHPOffice_PHPWord_PhpWordTest_1000, Test add title style\\n,Testiraj dodavanje stila za naslov.,"    public function testAddTitleStyle()    {        $phpWord = new PhpWord();        $titleLevel = 1;        $titleName = ""Heading_{$titleLevel}"";        $phpWord->addTitleStyle($titleLevel, array());        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Font', Style::getStyle($titleName));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
313,PHPOffice_PHPWord_PhpWordTest_1001, Test load template\\n\\n @deprecated 0.12.0\\n,Testiraj učitavanje šablona.,"    public function testLoadTemplate()    {        $templateFqfn = __DIR__ . '/_files/templates/blank.docx';        $phpWord = new PhpWord();        $this->assertInstanceOf(            'PhpOffice\\PhpWord\\TemplateProcessor',            $phpWord->loadTemplate($templateFqfn)        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
314,PHPOffice_PHPWord_PhpWordTest_1003, Test save\n,Sačuvaj test.,"    public function testSave()    {        $this->setOutputCallback(function () {        });        $phpWord = new PhpWord();        $section = $phpWord->addSection();        $section->addText('Hello world!');        $this->assertTrue($phpWord->save('test.docx', 'Word2007', true));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
315,PHPOffice_PHPWord_PhpWordTest_1004, Test calling undefined method\n\n @expectedException \\BadMethodCallException\n @expectedExceptionMessage is not defined\n,Testiraj pozivanje nedefinisanih metoda.,    public function testCallUndefinedMethod()    {        $phpWord = new PhpWord();        $phpWord->undefinedMethod();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
316,PHPOffice_PHPWord_PhpWordTest_993, Test class for PhpOffice\\PhpWord\\PhpWord\n\n @runTestsInSeparateProcesses\n,Klasa za testiranje PhpOffice.,"class PhpWordTest extends \PHPUnit\Framework\TestCase{    /**     * Test object creation     */    public function testConstruct()    {        $phpWord = new PhpWord();        $this->assertEquals(new DocInfo(), $phpWord->getDocInfo());        $this->assertEquals(Settings::DEFAULT_FONT_NAME, $phpWord->getDefaultFontName());        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, $phpWord->getDefaultFontSize());    }    /**     * Test create/get section     */    public function testCreateGetSections()    {        $phpWord = new PhpWord();        $phpWord->addSection();        $this->assertCount(1, $phpWord->getSections());    }    /**     * Test set/get default font name     */    public function testSetGetDefaultFontName()    {        $phpWord = new PhpWord();        $fontName = 'Times New Roman';        $this->assertEquals(Settings::DEFAULT_FONT_NAME, $phpWord->getDefaultFontName());        $phpWord->setDefaultFontName($fontName);        $this->assertEquals($fontName, $phpWord->getDefaultFontName());    }    /**     * Test set/get default font size     */    public function testSetGetDefaultFontSize()    {        $phpWord = new PhpWord();        $fontSize = 16;        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, $phpWord->getDefaultFontSize());        $phpWord->setDefaultFontSize($fontSize);        $this->assertEquals($fontSize, $phpWord->getDefaultFontSize());    }    /**     * Test set default paragraph style     */    public function testSetDefaultParagraphStyle()    {        $phpWord = new PhpWord();        $phpWord->setDefaultParagraphStyle(array());        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Paragraph', Style::getStyle('Normal'));    }    /**     * Test add styles     */    public function testAddStyles()    {        $phpWord = new PhpWord();        $styles = array(            'Paragraph' => 'Paragraph',            'Font'      => 'Font',            'Table'     => 'Table',            'Link'      => 'Font',        );        foreach ($styles as $key => $value) {            $method = ""add{$key}Style"";            $styleId = ""{$key} Style"";            $phpWord->$method($styleId, array());            $this->assertInstanceOf(""PhpOffice\\PhpWord\\Style\\{$value}"", Style::getStyle($styleId));        }    }    /**     * Test add title style     */    public function testAddTitleStyle()    {        $phpWord = new PhpWord();        $titleLevel = 1;        $titleName = ""Heading_{$titleLevel}"";        $phpWord->addTitleStyle($titleLevel, array());        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Font', Style::getStyle($titleName));    }    /**     * Test load template     *     * @deprecated 0.12.0     */    public function testLoadTemplate()    {        $templateFqfn = __DIR__ . '/_files/templates/blank.docx';        $phpWord = new PhpWord();        $this->assertInstanceOf(            'PhpOffice\\PhpWord\\TemplateProcessor',            $phpWord->loadTemplate($templateFqfn)        );    }    /**     * Test load template exception     *     * @deprecated 0.12.0     *     * @expectedException \PhpOffice\PhpWord\Exception\Exception     */    public function testLoadTemplateException()    {        $templateFqfn = implode(            DIRECTORY_SEPARATOR,            array(PHPWORD_TESTS_BASE_DIR, 'PhpWord', 'Tests', '_files', 'templates', 'blanks.docx')        );        $phpWord = new PhpWord();        $phpWord->loadTemplate($templateFqfn);    }    /**     * Test save     */    public function testSave()    {        $this->setOutputCallback(function () {        });        $phpWord = new PhpWord();        $section = $phpWord->addSection();        $section->addText('Hello world!');        $this->assertTrue($phpWord->save('test.docx', 'Word2007', true));    }    /**     * Test calling undefined method     *     * @expectedException \BadMethodCallException     * @expectedExceptionMessage is not defined     */    public function testCallUndefinedMethod()    {        $phpWord = new PhpWord();        $phpWord->undefinedMethod();    }    /**     * @covers \PhpOffice\PhpWord\PhpWord::getSection     */    public function testGetNotExistingSection()    {        $phpWord = new PhpWord();        $section = $phpWord->getSection(0);        $this->assertNull($section);    }    /**     * @covers \PhpOffice\PhpWord\PhpWord::getSection     */    public function testGetSection()    {        $phpWord = new PhpWord();        $phpWord->addSection();        $section = $phpWord->getSection(0);        $this->assertNotNull($section);    }    /**     * @covers \PhpOffice\PhpWord\PhpWord::sortSections     */    public function testSortSections()    {        $phpWord = new PhpWord();        $section1 = $phpWord->addSection();        $section1->addText('test1');        $section2 = $phpWord->addSection();        $section2->addText('test2');        $section2->addText('test3');        $this->assertEquals(1, $phpWord->getSection(0)->countElements());        $this->assertEquals(2, $phpWord->getSection(1)->countElements());        $phpWord->sortSections(function ($a, $b) {            $numElementsInA = $a->countElements();            $numElementsInB = $b->countElements();            if ($numElementsInA === $numElementsInB) {                return 0;            } elseif ($numElementsInA > $numElementsInB) {                return -1;            }            return 1;        });        $this->assertEquals(2, $phpWord->getSection(0)->countElements());        $this->assertEquals(1, $phpWord->getSection(1)->countElements());    }    /**     * @covers \PhpOffice\PhpWord\PhpWord::getSettings     */    public function testGetSettings()    {        $phpWord = new PhpWord();        $this->assertInstanceOf('PhpOffice\\PhpWord\\Metadata\\Settings', $phpWord->getSettings());    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
317,PHPOffice_PHPWord_PhpWordTest_994, Test object creation\\n,Kreiranje objekta za testiranje.,"    public function testConstruct()    {        $phpWord = new PhpWord();        $this->assertEquals(new DocInfo(), $phpWord->getDocInfo());        $this->assertEquals(Settings::DEFAULT_FONT_NAME, $phpWord->getDefaultFontName());        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, $phpWord->getDefaultFontSize());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
318,PHPOffice_PHPWord_PhpWordTest_996, Test set/get default font name\\n,Proveri postavljanje i dohvatanje podrazumevanog naziva za font.,"    public function testSetGetDefaultFontName()    {        $phpWord = new PhpWord();        $fontName = 'Times New Roman';        $this->assertEquals(Settings::DEFAULT_FONT_NAME, $phpWord->getDefaultFontName());        $phpWord->setDefaultFontName($fontName);        $this->assertEquals($fontName, $phpWord->getDefaultFontName());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
319,PHPOffice_PHPWord_PhpWordTest_998, Test set default paragraph style\n,Proveri postavljanje podrazumevanog stila za paragraf.,"    public function testSetDefaultParagraphStyle()    {        $phpWord = new PhpWord();        $phpWord->setDefaultParagraphStyle(array());        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Paragraph', Style::getStyle('Normal'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
320,PHPOffice_PHPWord_PhpWord_881, Create new instance\n\n Collections are created dynamically\n,Kreiraj novu instancu medija. Kolekcija se kreira dinamički.,"    public function __construct()    {        // Reset Media and styles        Media::resetElements();        Style::resetStyles();        // Collection        $collections = array('Bookmarks', 'Titles', 'Footnotes', 'Endnotes', 'Charts', 'Comments');        foreach ($collections as $collection) {            $class = 'PhpOffice\\PhpWord\\Collection\\' . $collection;            $this->collections[$collection] = new $class();        }        // Metadata        $metadata = array('DocInfo', 'Settings', 'Compatibility');        foreach ($metadata as $meta) {            $class = 'PhpOffice\\PhpWord\\Metadata\\' . $meta;            $this->metadata[$meta] = new $class();        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
321,PHPOffice_PHPWord_ProofStateTest_1054, Test class for PhpOffice\\\\PhpWord\\\\ComplexType\\\\ProofState\\n\\n @coversDefaultClass \\\\PhpOffice\\\\PhpWord\\\\ComplexType\\\\ProofState\\n,Klasa za testiranje PhpOffice.,"class ProofStateTest extends \PHPUnit\Framework\TestCase{    /**     * Tests the getters and setters     */    public function testGetSet()    {        $pState = new ProofState();        $pState->setGrammar(ProofState::CLEAN);        $pState->setSpelling(ProofState::DIRTY);        $this->assertEquals(ProofState::CLEAN, $pState->getGrammar());        $this->assertEquals(ProofState::DIRTY, $pState->getSpelling());    }    /**     * Test throws exception if wrong grammar proof state value given     *     * @expectedException \InvalidArgumentException     */    public function testWrongGrammar()    {        $pState = new ProofState();        $pState->setGrammar('Wrong');    }    /**     * Test throws exception if wrong spelling proof state value given     *     * @expectedException \InvalidArgumentException     */    public function testWrongSpelling()    {        $pState = new ProofState();        $pState->setSpelling('Wrong');    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
322,PHPOffice_PHPWord_ProofStateTest_1055, Tests the getters and setters\\n,Funkcija za testiranje getera i setera.,"    public function testGetSet()    {        $pState = new ProofState();        $pState->setGrammar(ProofState::CLEAN);        $pState->setSpelling(ProofState::DIRTY);        $this->assertEquals(ProofState::CLEAN, $pState->getGrammar());        $this->assertEquals(ProofState::DIRTY, $pState->getSpelling());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
323,PHPOffice_PHPWord_ProofStateTest_1056, Test throws exception if wrong grammar proof state value given\n\n @expectedException \\InvalidArgumentException\n,Test će izbaciti izuzetak ukoliko je prosleđen pogrešan gramatički dokaz vrednosti stanja.,    public function testWrongGrammar()    {        $pState = new ProofState();        $pState->setGrammar('Wrong');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
324,PHPOffice_PHPWord_SettingsTest_1012, Test set/get zip class\n,Testiraj seter i geter funkcije klase Zip,"    public function testSetGetZipClass()    {        $this->assertEquals(Settings::ZIPARCHIVE, Settings::getZipClass());        $this->assertFalse(Settings::setZipClass('foo'));        $this->assertEquals(Settings::ZIPARCHIVE, Settings::getZipClass());        $this->assertTrue(Settings::setZipClass(Settings::PCLZIP));        $this->assertEquals(Settings::getZipClass(), Settings::PCLZIP);        $this->assertFalse(Settings::setZipClass('foo'));        $this->assertEquals(Settings::getZipClass(), Settings::PCLZIP);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
325,PHPOffice_PHPWord_SettingsTest_1013, Test set/get PDF renderer\\n,Testiraj seter i geter funkcije Pdf čitača.,"    public function testSetGetPdfRenderer()    {        $domPdfPath = realpath(PHPWORD_TESTS_BASE_DIR . '/../vendor/dompdf/dompdf');        $this->assertFalse(Settings::setPdfRenderer('FOO', 'dummy/path'));        $this->assertTrue(Settings::setPdfRenderer(Settings::PDF_RENDERER_DOMPDF, $domPdfPath));        $this->assertEquals(Settings::PDF_RENDERER_DOMPDF, Settings::getPdfRendererName());        $this->assertEquals($domPdfPath, Settings::getPdfRendererPath());        $this->assertFalse(Settings::setPdfRendererPath('dummy/path'));        $this->assertEquals($domPdfPath, Settings::getPdfRendererPath());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
326,PHPOffice_PHPWord_SettingsTest_1018, Test set/get default font size\\n,Testiraj funkcije za postavljanje i dohvatanje podrazmevane veličine fonta.,"    public function testSetGetDefaultFontSize()    {        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, Settings::getDefaultFontSize());        $this->assertFalse(Settings::setDefaultFontSize(null));        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, Settings::getDefaultFontSize());        $this->assertTrue(Settings::setDefaultFontSize(12));        $this->assertEquals(12, Settings::getDefaultFontSize());        $this->assertFalse(Settings::setDefaultFontSize(null));        $this->assertEquals(12, Settings::getDefaultFontSize());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
327,PHPOffice_PHPWord_SettingsTest_1019, Test set/get default paper\\n,Testiraj funkcije za postavljanje i dohvatanje podrazmevanog papira.,"    public function testSetGetDefaultPaper()    {        $dflt = Settings::DEFAULT_PAPER;        $chng = ($dflt === 'A4') ? 'Letter' : 'A4';        $doc = new PhpWord();        $this->assertEquals($dflt, Settings::getDefaultPaper());        $sec1 = $doc->addSection();        $this->assertEquals($dflt, $sec1->getStyle()->getPaperSize());        $this->assertFalse(Settings::setDefaultPaper(''));        $this->assertEquals($dflt, Settings::getDefaultPaper());        $this->assertTrue(Settings::setDefaultPaper($chng));        $this->assertEquals($chng, Settings::getDefaultPaper());        $sec2 = $doc->addSection();        $this->assertEquals($chng, $sec2->getStyle()->getPaperSize());        $sec3 = $doc->addSection(array('paperSize' => 'Legal'));        $this->assertEquals('Legal', $sec3->getStyle()->getPaperSize());        $this->assertFalse(Settings::setDefaultPaper(''));        $this->assertEquals($chng, Settings::getDefaultPaper());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
328,PHPOffice_PHPWord_Settings_906, Identify the external library to use for rendering PDF files\\n\\n @param string $libraryName\\n @return bool\\n,Identifikuj spoljnu biblioteku koja će se koristiti za renderovanje pdf datoteka.,"    public static function setPdfRendererName($libraryName)    {        $pdfRenderers = array(self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_MPDF);        if (!in_array($libraryName, $pdfRenderers)) {            return false;        }        self::$pdfRendererName = $libraryName;        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
329,PHPOffice_PHPWord_Settings_910, Set measurement unit\n\n @param string $value\n @return bool\n,Postavi jedinicu mere.,"    public static function setMeasurementUnit($value)    {        $units = array(self::UNIT_TWIP, self::UNIT_CM, self::UNIT_MM, self::UNIT_INCH,            self::UNIT_POINT, self::UNIT_PICA, );        if (!in_array($value, $units)) {            return false;        }        self::$measurementUnit = $value;        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
330,PHPOffice_PHPWord_StyleTest_1023, Test default paragraph style\\n\\n @covers ::setDefaultParagraphStyle\\n @test\\n,Testiraj podrazumevani stil za paragraf.,"    public function testDefaultParagraphStyle()    {        $paragraph = array('alignment' => Jc::CENTER);        Style::setDefaultParagraphStyle($paragraph);        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Paragraph', Style::getStyle('Normal'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
331,PHPOffice_PHPWord_TemplateProcessorTest_1027, XSL stylesheet can be applied.\n\n @test\n @covers ::applyXslStyleSheet\n @depends testTemplateCanBeSavedInTemporaryLocation\n\n @param string $actualDocumentFqfn\n\n @throws \\Exception\n,Funkcija za testiranje da li se XSL tabela stilova može primeniti.,"    final public function testXslStyleSheetCanBeApplied($actualDocumentFqfn)    {        $expectedDocumentFqfn = __DIR__ . '/_files/documents/without_table_macros.docx';        $actualDocumentZip = new \ZipArchive();        $actualDocumentZip->open($actualDocumentFqfn);        $actualHeaderXml = $actualDocumentZip->getFromName('word/header1.xml');        $actualMainPartXml = $actualDocumentZip->getFromName('word/document.xml');        $actualFooterXml = $actualDocumentZip->getFromName('word/footer1.xml');        if (false === $actualDocumentZip->close()) {            throw new \Exception(""Could not close zip file \""{$actualDocumentFqfn}\""."");        }        $expectedDocumentZip = new \ZipArchive();        $expectedDocumentZip->open($expectedDocumentFqfn);        $expectedHeaderXml = $expectedDocumentZip->getFromName('word/header1.xml');        $expectedMainPartXml = $expectedDocumentZip->getFromName('word/document.xml');        $expectedFooterXml = $expectedDocumentZip->getFromName('word/footer1.xml');        if (false === $expectedDocumentZip->close()) {            throw new \Exception(""Could not close zip file \""{$expectedDocumentFqfn}\""."");        }        $this->assertXmlStringEqualsXmlString($expectedHeaderXml, $actualHeaderXml);        $this->assertXmlStringEqualsXmlString($expectedMainPartXml, $actualMainPartXml);        $this->assertXmlStringEqualsXmlString($expectedFooterXml, $actualFooterXml);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
332,PHPOffice_PHPWord_TemplateProcessorTest_1028, XSL stylesheet cannot be applied on failure in setting parameter value.\n\n @covers                   ::applyXslStyleSheet\n @expectedException        \\PhpOffice\\PhpWord\\Exception\\Exception\n @expectedExceptionMessage Could not set values for the given XSL style sheet parameters.\n @test\n,Testiraj da li će se primeniti XSL tabela stilova u slučaju greške u parametrima podešavanja.,"    final public function testXslStyleSheetCanNotBeAppliedOnFailureOfSettingParameterValue()    {        // Test is not needed for PHP 8.0, because internally validation throws TypeError exception.        if (\PHP_VERSION_ID >= 80000) {            $this->markTestSkipped('not needed for PHP 8.0');        }        $templateProcessor = new TemplateProcessor(__DIR__ . '/_files/templates/blank.docx');        $xslDomDocument = new \DOMDocument();        $xslDomDocument->load(__DIR__ . '/_files/xsl/passthrough.xsl');        /*         * We have to use error control below, because \XSLTProcessor::setParameter omits warning on failure.         * This warning fails the test.         */        @$templateProcessor->applyXslStyleSheet($xslDomDocument, array(1 => 'somevalue'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
333,PHPOffice_PHPWord_TemplateProcessor_943, Returns count of all variables in template.\n\n @return array\n,Vrati broj svih promenljivih u šablonu.,"    public function getVariableCount()    {        $variables = $this->getVariablesForPart($this->tempDocumentMainPart);        foreach ($this->tempDocumentHeaders as $headerXML) {            $variables = array_merge(                $variables,                $this->getVariablesForPart($headerXML)            );        }        foreach ($this->tempDocumentFooters as $footerXML) {            $variables = array_merge(                $variables,                $this->getVariablesForPart($footerXML)            );        }        return array_count_values($variables);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
334,PHPOffice_PHPWord_TemplateProcessor_946, Clones a table row and populates it's values from a two-dimensional array in a template document.\\n\\n @param string $search\\n @param array $values\\n,Dupliraj red tabele i popuni ga vrednostima dvomenzionalnog niza iz šablonskog dokumenta.,"    public function cloneRowAndSetValues($search, $values)    {        $this->cloneRow($search, count($values));        foreach ($values as $rowKey => $rowData) {            $rowNumber = $rowKey + 1;            foreach ($rowData as $macro => $replace) {                $this->setValue($macro . '#' . $rowNumber, $replace);            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
335,PHPOffice_PHPWord_TemplateProcessor_947, Replace a block.\\n\\n @param string $blockname\\n @param string $replacement\\n,Zameni blok.,"    public function replaceBlock($blockname, $replacement)    {        $matches = array();        preg_match(            '/(<\?xml.*)(<w:p.*>\${' . $blockname . '}<\/w:.*?p>)(.*)(<w:p.*\${\/' . $blockname . '}<\/w:.*?p>)/is',            $this->tempDocumentMainPart,            $matches        );        if (isset($matches[3])) {            $this->tempDocumentMainPart = str_replace(                $matches[2] . $matches[3] . $matches[4],                $replacement,                $this->tempDocumentMainPart            );        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
336,PHPOffice_PHPWord_TemplateProcessor_948, Delete a block of text.\\n\\n @param string $blockname\\n,Izbriši tekstualni blok.,"    public function deleteBlock($blockname)    {        $this->replaceBlock($blockname, '');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
337,PHPOffice_PHPWord_TemplateProcessor_951, Saves the result document to the user defined file.\\n\\n @since 0.8.0\\n\\n @param string $fileName\\n,Sačuvaj rezultate dokumenta u korisnički definisanu datoteku.,"    public function saveAs($fileName)    {        $tempFileName = $this->save();        if (file_exists($fileName)) {            unlink($fileName);        }        /*         * Note: we do not use `rename` function here, because it loses file ownership data on Windows platform.         * As a result, user cannot open the file directly getting ""Access denied"" message.         *         * @see https://github.com/PHPOffice/PHPWord/issues/532         */        copy($tempFileName, $fileName);        unlink($tempFileName);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
338,PHPOffice_PHPWord_TemplateProcessor_953, Find and replace macros in the given XML section.\n\n @param mixed $search\n @param mixed $replace\n @param string $documentPartXML\n @param int $limit\n\n @return string\n,Pronađi i zameni makroe u datom xml odeljku sa vrednošću koja mu odgovara.,"    protected function setValueForPart($search, $replace, $documentPartXML, $limit)    {        // Note: we can't use the same function for both cases here, because of performance considerations.        if (self::MAXIMUM_REPLACEMENTS_DEFAULT === $limit) {            return str_replace($search, $replace, $documentPartXML);        }        $regExpEscaper = new RegExp();        return preg_replace($regExpEscaper->escape($search), $replace, $documentPartXML, $limit);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
339,PHPOffice_PHPWord_TemplateProcessor_954, Find all variables in $documentPartXML.\\n\\n @param string $documentPartXML\\n\\n @return string[]\\n,Pronađi sve promenljive u xml delu dokumenta.,"    protected function getVariablesForPart($documentPartXML)    {        $matches = array();        preg_match_all('/\$\{(.*?)}/i', $documentPartXML, $matches);        return $matches[1];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
340,PHPOffice_PHPWord_TemplateProcessor_961, Find the start position of the nearest table row before $offset.\n\n @param int $offset\n\n @throws \\PhpOffice\\PhpWord\\Exception\\Exception\n\n @return int\n,Pronađi najbližu početnu poziciju reda pre zadatog početnog pomeraja.,"    protected function findRowStart($offset)    {        $rowStart = strrpos($this->tempDocumentMainPart, '<w:tr ', ((strlen($this->tempDocumentMainPart) - $offset) * -1));        if (!$rowStart) {            $rowStart = strrpos($this->tempDocumentMainPart, '<w:tr>', ((strlen($this->tempDocumentMainPart) - $offset) * -1));        }        if (!$rowStart) {            throw new Exception('Can not find the start position of the row to clone.');        }        return $rowStart;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
341,PHPOffice_PHPWord_TemplateProcessor_962, Find the end position of the nearest table row after $offset.\\n\\n @param int $offset\\n\\n @return int\\n,Pronađi najbližu krajnju poziciju reda iza zadatog početnog pomeraja.,"    protected function findRowEnd($offset)    {        return strpos($this->tempDocumentMainPart, '</w:tr>', $offset) + 7;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
342,PHPOffice_PHPWord_TemplateProcessor_963, Replaces variable names in cloned\n rows/blocks with indexed names\n\n @param int $count\n @param string $xmlBlock\n\n @return string\n,Zameni naziv promenljive u dupliranom redu ili bloku sa indeksiranim imenom.,"    protected function indexClonedVariables($count, $xmlBlock)    {        $results = array();        for ($i = 1; $i <= $count; $i++) {            $results[] = preg_replace('/\$\{([^:]*?)(:.*?)?\}/', '\${\1#' . $i . '\2}', $xmlBlock);        }        return $results;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
343,PHPOffice_PHPWord_TemplateProcessor_964," Raplaces variables with values from array, array keys are the variable names\n\n @param array $variableReplacements\n @param string $xmlBlock\n\n @return string[]\n","Zameni promenljive sa nizom, gde su ključevi niza imena promenljivih. ","    protected function replaceClonedVariables($variableReplacements, $xmlBlock)    {        $results = array();        foreach ($variableReplacements as $replacementArray) {            $localXmlBlock = $xmlBlock;            foreach ($replacementArray as $search => $replacement) {                $localXmlBlock = $this->setValueForPart(self::ensureMacroCompleted($search), $replacement, $localXmlBlock, self::MAXIMUM_REPLACEMENTS_DEFAULT);            }            $results[] = $localXmlBlock;        }        return $results;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
345,PHPOffice_PHPWord_TemplateProcessor_965, Find the start position of the nearest XML block start before $offset\\n\\n @param int $offset    Search position\\n @param string  $blockType XML Block tag\\n @return int -1 if block start not found\\n,Pronađite početnu poziciju najbližeg xml bloka koji počinje pre zadatog početnog pomeraja.,"    protected function findXmlBlockStart($offset, $blockType)    {        $reverseOffset = (strlen($this->tempDocumentMainPart) - $offset) * -1;        // first try XML tag with attributes        $blockStart = strrpos($this->tempDocumentMainPart, '<' . $blockType . ' ', $reverseOffset);        // if not found, or if found but contains the XML tag without attribute        if (false === $blockStart || strrpos($this->getSlice($blockStart, $offset), '<' . $blockType . '>')) {            // also try XML tag without attributes            $blockStart = strrpos($this->tempDocumentMainPart, '<' . $blockType . '>', $reverseOffset);        }        return ($blockStart === false) ? -1 : $blockStart;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
346,PrestaShop_PrestaShop_Access_769," Add access.\\n\\n @param int $idProfile Profile ID\\n @param int $idRole Role ID\\n\\n @return string Whether access has been successfully granted (""ok"", ""error"")\\n",Dodaj prava pristupa.,"    public function addAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
347,PrestaShop_PrestaShop_Access_770," Remove access.\\n\\n @param int $idProfile Profile ID\\n @param int $idRole Role ID\\n\\n @return string Whether access has been successfully removed (""ok"", ""error"")\\n",Ukloni prava pristupa.,"    public function removeAccess($idProfile, $idRole)    {        $sql = '            DELETE FROM `' . _DB_PREFIX_ . 'access`            WHERE `id_profile` = ""' . (int) $idProfile . '""            AND `id_authorization_role` = ""' . (int) $idRole . '""        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
348,PrestaShop_PrestaShop_Access_771," Add module access.\\\\\\\\n\\\\\\\\n @param int $idProfile Profile ID\\\\\\\\n @param int $idRole Role ID\\\\\\\\n\\\\\\\\n @return string Whether module access has been successfully granted (""ok"", ""error"")\\\\\\\\n",Dodaj prava pristupa za modul.,"    public function addModuleAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'module_access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
349,PrestaShop_PrestaShop_Access_773," Update (legacy) Module access.\\\\\\\\n\\\\\\\\n @param int $idProfile Profile ID\\\\\\\\n @param int $idModule Module ID\\\\\\\\n @param string $lgcAuth Legacy authorization\\\\\\\\n @param int $enabled Whether module access should be granted\\\\\\\\n\\\\\\\\n @return string Whether module access has been succesfully changed (""ok"", ""error"")\\\\\\\\n",Ažuriraj nasleđena prava pristupa modula.,"    public function updateLgcModuleAccess($idProfile, $idModule, $lgcAuth, $enabled)    {        $idProfile = (int) $idProfile;        $idModule = (int) $idModule;        if ($idModule == -1) {            $slug = 'ROLE_MOD_MODULE_%_';        } else {            $slug = self::findSlugByIdModule($idModule);        }        $whereClauses = [];        foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {            $slugLike = Db::getInstance()->escape($slug . $auth);            $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';        }        $roles = Db::getInstance()->executeS('            SELECT `id_authorization_role`            FROM `' . _DB_PREFIX_ . 'authorization_role` t            WHERE ' . implode(' OR ', $whereClauses) . '        ');        $res = [];        foreach ($roles as $role) {            if ($enabled) {                $res[] = $this->addModuleAccess($idProfile, $role['id_authorization_role']);            } else {                $res[] = $this->removeModuleAccess($idProfile, $role['id_authorization_role']);            }        }        return in_array('error', $res) ? 'error' : 'ok';    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
350,PrestaShop_PrestaShop_AddressChecksumCore_789, Class AddressChecksumCore.\n,Glavna klasa za proračun kontrolne sume adrese.,"class AddressChecksumCore implements ChecksumInterface{    const SEPARATOR = '_';    /**     * Generate a checksum.     *     * @param Address $address     *     * @return string SHA1 checksum for the Address     */    public function generateChecksum($address)    {        if (!$address->id) {            return sha1('No address set');        }        $uniqId = '';        $fields = $address->getFields();        foreach ($fields as $name => $value) {            $uniqId .= $value . self::SEPARATOR;        }        $uniqId = rtrim($uniqId, self::SEPARATOR);        return sha1($uniqId);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
351,PrestaShop_PrestaShop_AddressFormat_791, Class AddressFormatCore.\\\\\\\\n,Glavna klasa za formatiranje adresa.,"class AddressFormatCore extends ObjectModel{    const FORMAT_NEW_LINE = ""\n"";    /** @var int Address format */    public $id_address_format;    /** @var int Country ID */    public $id_country;    /** @var string Format */    public $format;    protected $_errorFormatList = [];    /**     * @see ObjectModel::$definition     */    public static $definition = [        'table' => 'address_format',        'primary' => 'id_country',        'fields' => [            'format' => ['type' => self::TYPE_HTML, 'validate' => 'isGenericName', 'required' => true],            'id_country' => ['type' => self::TYPE_INT],        ],    ];    /** @var array Default required form fields list */    public static $requireFormFieldsList = [        'firstname',        'lastname',        'address1',        'city',        'Country:name',    ];    /** @var array Default forbidden property list */    public static $forbiddenPropertyList = [        'deleted',        'date_add',        'alias',        'secure_key',        'note',        'newsletter',        'ip_registration_newsletter',        'newsletter_date_add',        'optin',        'passwd',        'last_passwd_gen',        'active',        'is_guest',        'date_upd',        'country',        'years',        'days',        'months',        'description',        'meta_description',        'short_description',        'link_rewrite',        'meta_title',        'meta_keywords',        'display_tax_label',        'need_zip_code',        'contains_states',        'call_prefixes',        'show_public_prices',        'max_payment',        'max_payment_days',        'geoloc_postcode',        'logged',        'account_number',        'groupBox',        'ape',        'max_payment',        'outstanding_allow_amount',        'call_prefix',        'definition',        'debug_list',    ];    /** @var array Default formbidden class list */    public static $forbiddenClassList = [        'Manufacturer',        'Supplier',    ];    const _CLEANING_REGEX_ = '#([^\w:_]+)#i';    /**     * Check if the the association of the field name and a class name     * is valid.     *     * @param string $className The name class     * @param string $fieldName The property name     * @param bool $isIdField Do we have to allow a property name to be started with 'id_'     *     * @return bool Association of the field and class name is valid     */    protected function _checkValidateClassField($className, $fieldName, $isIdField)    {        $isValid = false;        if (!class_exists($className)) {            $this->_errorFormatList[] = $this->trans('This class name does not exist.', [], 'Admin.Notifications.Error') .            ': ' . $className;        } else {            $obj = new $className();            $reflect = new ReflectionObject($obj);            // Check if the property is accessible            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                $propertyName = $property->getName();                if (($propertyName == $fieldName) && ($isIdField ||                        (!preg_match('/\bid\b|id_\w+|\bid[A-Z]\w+/', $propertyName)))) {                    $isValid = true;                }            }            if (!$isValid) {                $this->_errorFormatList[] = $this->trans('This property does not exist in the class or is forbidden.', [], 'Admin.Notifications.Error') .                ': ' . $className . ': ' . $fieldName;            }            unset(                $obj,                $reflect            );        }        return $isValid;    }    /**     * Verify the existence of a field name and check the availability     * of an association between a field name and a class (ClassName:fieldName)     * if the separator is overview.     *     * @param string $patternName The composition of the class and field name     * @param string $fieldsValidate The list of available field for the Address class     * @todo: Why is $fieldsValidate unused?     */    protected function _checkLiableAssociation($patternName, $fieldsValidate)    {        $patternName = trim($patternName);        if ($associationName = explode(':', $patternName)) {            $totalNameUsed = count($associationName);            if ($totalNameUsed > 2) {                $this->_errorFormatList[] = $this->trans('This association has too many elements.', [], 'Admin.Notifications.Error');            } elseif ($totalNameUsed == 1) {                $associationName[0] = strtolower($associationName[0]);                if (in_array($associationName[0], self::$forbiddenPropertyList) ||                    !$this->_checkValidateClassField('Address', $associationName[0], false)) {                    $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                    $associationName[0];                }            } elseif ($totalNameUsed == 2) {                if (empty($associationName[0]) || empty($associationName[1])) {                    $this->_errorFormatList[] = $this->trans('Syntax error with this pattern.', [], 'Admin.Notifications.Error') . ': ' . $patternName;                } else {                    $associationName[0] = ucfirst($associationName[0]);                    $associationName[1] = strtolower($associationName[1]);                    if (in_array($associationName[0], self::$forbiddenClassList)) {                        $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                        $associationName[0];                    } else {                        // Check if the id field name exist in the Address class                        // Don't check this attribute on Address (no sense)                        if ($associationName[0] != 'Address') {                            $this->_checkValidateClassField('Address', 'id_' . strtolower($associationName[0]), true);                        }                        // Check if the field name exist in the class write by the user                        $this->_checkValidateClassField($associationName[0], $associationName[1], false);                    }                }            }        }    }    /**     * Check if the set fields are valid.     */    public function checkFormatFields()    {        $this->_errorFormatList = [];        $fieldsValidate = Address::getFieldsValidate();        $usedKeyList = [];        $multipleLineFields = explode(self::FORMAT_NEW_LINE, $this->format);        if ($multipleLineFields && is_array($multipleLineFields)) {            foreach ($multipleLineFields as $lineField) {                if (($patternsName = preg_split(self::_CLEANING_REGEX_, $lineField, -1, PREG_SPLIT_NO_EMPTY))) {                    if (is_array($patternsName)) {                        foreach ($patternsName as $patternName) {                            if (!in_array($patternName, $usedKeyList)) {                                $this->_checkLiableAssociation($patternName, $fieldsValidate);                                $usedKeyList[] = $patternName;                            } else {                                $this->_errorFormatList[] = $this->trans('This key has already been used.', [], 'Admin.Notifications.Error') .                                    ': ' . $patternName;                            }                        }                    }                }            }            $this->checkRequiredFields($usedKeyList);        }        return (count($this->_errorFormatList)) ? false : true;    }    /**     * Checks that all required fields exist in a given fields list.     * Fills _errorFormatList array in case of absence of a required field.     *     * @param array $fieldList     */    protected function checkRequiredFields($fieldList)    {        foreach (self::getFieldsRequired() as $requiredField) {            if (!in_array($requiredField, $fieldList)) {                $this->_errorFormatList[] = $this->trans(                    'The %s field (in tab %s) is required.',                    [$requiredField, $this->getFieldTabName($requiredField)],                    'Admin.Notifications.Error');            }        }    }    /**     * Given a field name, get the name of the tab in which the field name can be found.     * For ex: Country:name => the tab is 'Country'.     * There should be only one separator in the string, otherwise throw an exception.     *     * @param string $field     *     * @return bool|string     *     * @throws AddressException     */    private function getFieldTabName($field)    {        if (strpos($field, ':') === false) {            // When there is no ':' separator, the field is in the Address tab            return 'Address';        }        $fieldTab = explode(':', $field);        if (count($fieldTab) === 2) {            // The part preceding the ':' separator is the name of the tab in which there is the required field            return $fieldTab[0];        }        throw new AddressException('Address format field is not valid');    }    /**     * Returns the error list.     */    public function getErrorList()    {        return $this->_errorFormatList;    }    /**     * Set the layout key with the liable value     * example : (firstname) => 'Presta' will result (Presta)     *         : (firstname-lastname) => 'Presta' and 'Shop' result '(Presta-Shop)'.     */    protected static function _setOriginalDisplayFormat(&$formattedValueList, $currentLine, $currentKeyList)    {        if ($currentKeyList && is_array($currentKeyList)) {            if ($originalFormattedPatternList = explode(' ', $currentLine)) {                // Foreach the available pattern                foreach ($originalFormattedPatternList as $patternNum => $pattern) {                    // Var allows to modify the good formatted key value when multiple key exist into the same pattern                    $mainFormattedKey = '';                    // Multiple key can be found in the same pattern                    foreach ($currentKeyList as $key) {                        // Check if we need to use an older modified pattern if a key has already be matched before                        $replacedValue = empty($mainFormattedKey) ? $pattern : $formattedValueList[$mainFormattedKey];                        $chars = $start = $end = str_replace($key, '', $replacedValue);                        if (preg_match(self::_CLEANING_REGEX_, $chars)) {                            if (Tools::substr($replacedValue, 0, Tools::strlen($chars)) == $chars) {                                $end = '';                            } else {                                $start = '';                            }                            if ($chars) {                                $replacedValue = str_replace($chars, '', $replacedValue);                            }                        }                        if ($formattedValue = preg_replace('/^' . $key . '$/', $formattedValueList[$key], $replacedValue, -1, $count)) {                            if ($count) {                                // Allow to check multiple key in the same pattern,                                if (empty($mainFormattedKey)) {                                    $mainFormattedKey = $key;                                }                                // Set the pattern value to an empty string if an older key has already been matched before                                if ($mainFormattedKey != $key) {                                    $formattedValueList[$key] = '';                                }                                // Store the new pattern value                                $formattedValueList[$mainFormattedKey] = $start . $formattedValue . $end;                                unset($originalFormattedPatternList[$patternNum]);                            }                        }                    }                }            }        }    }    /**     * Cleaned the layout set by the user.     */    public static function cleanOrderedAddress(&$orderedAddressField)    {        foreach ($orderedAddressField as &$line) {            $cleanedLine = '';            if (($keyList = preg_split(self::_CLEANING_REGEX_, $line, -1, PREG_SPLIT_NO_EMPTY))) {                foreach ($keyList as $key) {                    $cleanedLine .= $key . ' ';                }                $cleanedLine = trim($cleanedLine);                $line = $cleanedLine;            }        }    }    /**     * Returns the formatted fields with associated values.     *     * @param Address $address Address object     * @param AddressFormat $addressFormat The format     *     * @return array     */    public static function getFormattedAddressFieldsValues($address, $addressFormat, $id_lang = null)    {        if (!$id_lang) {            $id_lang = Context::getContext()->language->id;        }        $tab = [];        $temporyObject = [];        // Check if $address exist and it's an instanciate object of Address        if ($address && ($address instanceof Address)) {            foreach ($addressFormat as $line) {                if (($keyList = preg_split(self::_CLEANING_REGEX_, $line, -1, PREG_SPLIT_NO_EMPTY)) && is_array($keyList)) {                    foreach ($keyList as $pattern) {                        if ($associateName = explode(':', $pattern)) {                            $totalName = count($associateName);                            if ($totalName == 1 && isset($address->{$associateName[0]})) {                                $tab[$associateName[0]] = $address->{$associateName[0]};                            } else {                                $tab[$pattern] = '';                                // Check if the property exist in both classes                                if (($totalName == 2) && class_exists($associateName[0]) &&                                    property_exists($associateName[0], $associateName[1]) &&                                    property_exists($address, 'id_' . strtolower($associateName[0]))) {                                    $idFieldName = 'id_' . strtolower($associateName[0]);                                    if (!isset($temporyObject[$associateName[0]])) {                                        $temporyObject[$associateName[0]] = new $associateName[0]($address->{$idFieldName});                                    }                                    if ($temporyObject[$associateName[0]]) {                                        $tab[$pattern] = (is_array($temporyObject[$associateName[0]]->{$associateName[1]})) ?                                            ((isset($temporyObject[$associateName[0]]->{$associateName[1]}[$id_lang])) ?                                            $temporyObject[$associateName[0]]->{$associateName[1]}[$id_lang] : '') :                                            $temporyObject[$associateName[0]]->{$associateName[1]};                                    }                                }                            }                        }                    }                    AddressFormat::_setOriginalDisplayFormat($tab, $line, $keyList);                }            }        }        AddressFormat::cleanOrderedAddress($addressFormat);        return $tab;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
352,PrestaShop_PrestaShop_AddressFormat_792, Check if the the association of the field name and a class name\\\\n is valid.\\\\n\\\\n @param string $className The name class\\\\n @param string $fieldName The property name\\\\n @param bool $isIdField Do we have to allow a property name to be started with 'id_'\\\\n\\\\n @return bool Association of the field and class name is valid\\\\n,Proveri da li je udrženje imena polja i klase validna,"    protected function _checkValidateClassField($className, $fieldName, $isIdField)    {        $isValid = false;        if (!class_exists($className)) {            $this->_errorFormatList[] = $this->trans('This class name does not exist.', [], 'Admin.Notifications.Error') .            ': ' . $className;        } else {            $obj = new $className();            $reflect = new ReflectionObject($obj);            // Check if the property is accessible            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                $propertyName = $property->getName();                if (($propertyName == $fieldName) && ($isIdField ||                        (!preg_match('/\bid\b|id_\w+|\bid[A-Z]\w+/', $propertyName)))) {                    $isValid = true;                }            }            if (!$isValid) {                $this->_errorFormatList[] = $this->trans('This property does not exist in the class or is forbidden.', [], 'Admin.Notifications.Error') .                ': ' . $className . ': ' . $fieldName;            }            unset(                $obj,                $reflect            );        }        return $isValid;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
353,PrestaShop_PrestaShop_AddressFormat_793, Verify the existence of a field name and check the availability\n of an association between a field name and a class (ClassName:fieldName)\n if the separator is overview.\n\n @param string $patternName The composition of the class and field name\n @param string $fieldsValidate The list of available field for the Address class\n @todo: Why is $fieldsValidate unused?\n,"Verifikuj da naziva polja postoji i proveri njegovu dostupnost za združivanje sa imenom klase, ukoliko je separator pregledan.","    protected function _checkLiableAssociation($patternName, $fieldsValidate)    {        $patternName = trim($patternName);        if ($associationName = explode(':', $patternName)) {            $totalNameUsed = count($associationName);            if ($totalNameUsed > 2) {                $this->_errorFormatList[] = $this->trans('This association has too many elements.', [], 'Admin.Notifications.Error');            } elseif ($totalNameUsed == 1) {                $associationName[0] = strtolower($associationName[0]);                if (in_array($associationName[0], self::$forbiddenPropertyList) ||                    !$this->_checkValidateClassField('Address', $associationName[0], false)) {                    $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                    $associationName[0];                }            } elseif ($totalNameUsed == 2) {                if (empty($associationName[0]) || empty($associationName[1])) {                    $this->_errorFormatList[] = $this->trans('Syntax error with this pattern.', [], 'Admin.Notifications.Error') . ': ' . $patternName;                } else {                    $associationName[0] = ucfirst($associationName[0]);                    $associationName[1] = strtolower($associationName[1]);                    if (in_array($associationName[0], self::$forbiddenClassList)) {                        $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                        $associationName[0];                    } else {                        // Check if the id field name exist in the Address class                        // Don't check this attribute on Address (no sense)                        if ($associationName[0] != 'Address') {                            $this->_checkValidateClassField('Address', 'id_' . strtolower($associationName[0]), true);                        }                        // Check if the field name exist in the class write by the user                        $this->_checkValidateClassField($associationName[0], $associationName[1], false);                    }                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
354,PrestaShop_PrestaShop_AddressFormat_794, Check if the set fields are valid.\\\\\\\\n,Proveri da li su postavljena polja validna.,"    public function checkFormatFields()    {        $this->_errorFormatList = [];        $fieldsValidate = Address::getFieldsValidate();        $usedKeyList = [];        $multipleLineFields = explode(self::FORMAT_NEW_LINE, $this->format);        if ($multipleLineFields && is_array($multipleLineFields)) {            foreach ($multipleLineFields as $lineField) {                if (($patternsName = preg_split(self::_CLEANING_REGEX_, $lineField, -1, PREG_SPLIT_NO_EMPTY))) {                    if (is_array($patternsName)) {                        foreach ($patternsName as $patternName) {                            if (!in_array($patternName, $usedKeyList)) {                                $this->_checkLiableAssociation($patternName, $fieldsValidate);                                $usedKeyList[] = $patternName;                            } else {                                $this->_errorFormatList[] = $this->trans('This key has already been used.', [], 'Admin.Notifications.Error') .                                    ': ' . $patternName;                            }                        }                    }                }            }            $this->checkRequiredFields($usedKeyList);        }        return (count($this->_errorFormatList)) ? false : true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
355,PrestaShop_PrestaShop_AddressFormat_796," Given a field name, get the name of the tab in which the field name can be found.\n For ex: Country:name => the tab is 'Country'.\n There should be only one separator in the string, otherwise throw an exception.\n\n @param string $field\n\n @return bool|string\n\n @throws AddressException\n",Za dato ime polja vrati naziv tab sekcije u kojem se pojavljuje.,"    private function getFieldTabName($field)    {        if (strpos($field, ':') === false) {            // When there is no ':' separator, the field is in the Address tab            return 'Address';        }        $fieldTab = explode(':', $field);        if (count($fieldTab) === 2) {            // The part preceding the ':' separator is the name of the tab in which there is the required field            return $fieldTab[0];        }        throw new AddressException('Address format field is not valid');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
356,googleapis_google-api-php-client_Client_611," Set the access token used for requests.\\n\\n Note that at the time requests are sent, tokens are cached. A token will be\\n cached for each combination of service and authentication scopes. If a\\n cache pool is not provided, creating a new instance of the client will\\n allow modification of access tokens. If a persistent cache pool is\\n provided, in order to change the access token, you must clear the cached\\n token by calling `$client->getCache()->clear()`. (Use caution in this case,\\n as calling `clear()` will remove all cache items, including any items not\\n related to Google API PHP Client.)\\n\\n @param string|array $token\\n @throws InvalidArgumentException\\n",Glavna logika za proveru token id-ja je u AuthTest klasi. Ovo je samo opšta provera kako bismo bili sifurni da verifikujemo važeći id token ukoliko postoji.,"  public function setAccessToken($token)  {    if (is_string($token)) {      if ($json = json_decode($token, true)) {        $token = $json;      } else {        // assume $token is just the token string        $token = array(          'access_token' => $token,        );      }    }    if ($token == null) {      throw new InvalidArgumentException('invalid json token');    }    if (!isset($token['access_token'])) {      throw new InvalidArgumentException(""Invalid token format"");    }    $this->token = $token;  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
358,markrogoyski_math-php_KernelDensityEstimation_3533, Default bandwidth for when one is not provided.\n Uses the normal distribution approximation bandwidth estimator.\n https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\n\n             â…•\n      / 4Ïƒâµ \\\n h = |  ---  |\n      \\ 3n  /\n\n\n @return float\n\n @throws Exception\\OutOfBoundsException\n,Dohvati podrazumevanu širinu opsega kada ona nije navedena. Procenjivač širine opsega koristi normalnu raspodelu kao aproksimaciju.,    private function getDefaultBandwidth(): float    {        $ï¼”Ïƒâµ = 4 * Descriptive::standardDeviation($this->data) ** 5;        $ï¼“n  = 3 * $this->n;        $â…•    = 0.2;        return ($ï¼”Ïƒâµ / $ï¼“n) ** $â…•;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
359,markrogoyski_math-php_Normal_3167, Cumulative distribution function\\n Probability of being below X.\\n Area under the normal distribution from -âˆž to X.\\n             _                  _\\n          1 |         / x - Î¼ \\\\  |\\n cdf(x) = - | 1 + erf|  ----- |  |\\n          2 |_        \\\\  Ïƒâˆš2  / _|\\n\\n @param float $x upper bound\\n\\n @return float cdf(x) below\\n,Kulmutivna funckija raspodele. Verovatnoća biti ispod vrednosti X. Vraća površinu ispod normalne raspodele od minus beskonačno do X.,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        return 1 / 2 * ( 1 + Special::erf(($x - $Î¼) / ($Ïƒ * \sqrt(2))) );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
360,markrogoyski_math-php_Normal_3164, Normal distribution\\n https://en.wikipedia.org/wiki/Normal_distribution\\n,Normalna raspodela,"class Normal extends Continuous{    /**     * Distribution parameter bounds limits     * Î¼ âˆˆ (-âˆž,âˆž)     * Ïƒ âˆˆ (0,âˆž)     * @var array     */    public const PARAMETER_LIMITS = [        'Î¼' => '(-âˆž,âˆž)',        'Ïƒ' => '(0,âˆž)',    ];    /**     * Distribution support bounds limits     * x âˆˆ (-âˆž,âˆž)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '(-âˆž,âˆž)',    ];    /** @var float Mean Parameter */    protected $Î¼;    /** @var float Standard Deviation Parameter */    protected $Ïƒ;    /**     * Normal constructor     *     * @param float $Î¼     * @param float $Ïƒ     */    public function __construct(float $Î¼, float $Ïƒ)    {        parent::__construct($Î¼, $Ïƒ);    }    /**     * Probability density function     *     *              1     * f(x|Î¼,Ïƒ) = ----- â„¯^âˆ’âŸ®x âˆ’ Î¼âŸ¯Â²âˆ•2ÏƒÂ²     *            ÏƒâˆšâŸ®2Ï€âŸ¯     *     * @param float $x random variable     *     * @return float f(x|Î¼,Ïƒ)     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼     = $this->Î¼;        $Ïƒ     = $this->Ïƒ;        $Ï€     = \M_PI;        $ÏƒâˆšâŸ®2Ï€âŸ¯ = $Ïƒ * \sqrt(2 * $Ï€);        $âŸ®xÂ âˆ’Â Î¼âŸ¯Â²âˆ•2ÏƒÂ² = \pow(($x - $Î¼), 2) / (2 * $Ïƒ ** 2);        $â„¯ï¼¾âˆ’âŸ®xÂ âˆ’Â Î¼âŸ¯Â²âˆ•2ÏƒÂ² = \exp(-$âŸ®xÂ âˆ’Â Î¼âŸ¯Â²âˆ•2ÏƒÂ²);        return ( 1 / $ÏƒâˆšâŸ®2Ï€âŸ¯ ) * $â„¯ï¼¾âˆ’âŸ®xÂ âˆ’Â Î¼âŸ¯Â²âˆ•2ÏƒÂ²;    }    /**     * Cumulative distribution function     * Probability of being below X.     * Area under the normal distribution from -âˆž to X.     *             _                  _     *          1 |         / x - Î¼ \  |     * cdf(x) = - | 1 + erf|  ----- |  |     *          2 |_        \  Ïƒâˆš2  / _|     *     * @param float $x upper bound     *     * @return float cdf(x) below     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        return 1 / 2 * ( 1 + Special::erf(($x - $Î¼) / ($Ïƒ * \sqrt(2))) );    }    /**     * Inverse CDF (quantile)     *     * @param float $p     *     * @return float     */    public function inverse(float $p): float    {        if ($p == 0) {            return -\INF;        }        if ($p == 1) {            return \INF;        }        return parent::inverse($p);    }    /**     * Mean of the distribution     *     * Î¼ = Î¼     *     * @return float     */    public function mean(): float    {        return $this->Î¼;    }    /**     * Median of the distribution     *     * median = Î¼     *     * @return float     */    public function median(): float    {        return $this->Î¼;    }    /**     * Mode of the distribution     *     * mode = Î¼     *     * @return float     */    public function mode(): float    {        return $this->Î¼;    }    /**     * Variance of the distribution     *     * var[X] = ÏƒÂ²     *     * @return float     */    public function variance(): float    {        return $this->Ïƒ ** 2;    }    /**     * Random number - Boxâ€“Muller transform     *     * https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform     */    public function rand()    {        $rand1 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        $rand2 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        return \sqrt(-2 * \log($rand1)) * \cos(2 * pi() * $rand2) * $this->Ïƒ + $this->Î¼;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
361,markrogoyski_math-php_StandardNormal_3289," Standard normal tables for Z and related methods\n\n A standard normal table, also called the unit normal table or Z table,\n is a mathematical table for the values of Î¦, which are the values of the\n cumulative distribution function of the normal distribution.\n\n It is used to find the probability that a statistic is observed below,\n above, or between values on the standard normal distribution, and by extension,\n any normal distribution.\n\n Since probability tables cannot be printed for every normal distribution,\n as there are an infinite variety of normal distributions,\n it is common practice to convert a normal to a standard normal\n and then use the standard normal table to find probabilities.\n\n https://en.wikipedia.org/wiki/Standard_normal_table\n\n This table is provided only for completeness. It is common for statistics\n textbooks to include this table, so this library does as well. It is better\n to use the standard normal distribution CDF function when a Z score is required.\n","Budući da se tabele verovatnoće ne mogu ispisati za svaku normalnu raspodelu, jer postoji beskrajna raznolikost normalnih raspodela, uobičajna je praksa da se normala pretvori u standardnu normalu, a zatim koristi standardna normalna tabela za pronalaženje verovatnoća. Ova tabela je data samo radi potpunosti. Uobičajno je da udžbenici statistike uključuju ovu tabelu pa to radi i ova biblioteka. Bolje je koristiti standardnu CDF funkciju normalne raspodele kada je Z rezultat potreban.","class StandardNormal{    /**     * Z scores table - cumulative from mean     * Contains positive and negative Z scores.     * Negative z-score - value is to the left of the mean.     * Positive z-score - value is to the right of the mean.     * @var array     */    public const Z_SCORES = [    '-3.4' => [ 9 => 0.0002, 8 => 0.0003, 7 => 0.0003, 6 => 0.0003, 5 => 0.0003, 4 => 0.0003, 3 => 0.0003, 2 => 0.0003, 1 => 0.0003, 0 => 0.0003 ],    '-3.3' => [ 9 => 0.0003, 8 => 0.0004, 7 => 0.0004, 6 => 0.0004, 5 => 0.0004, 4 => 0.0004, 3 => 0.0004, 2 => 0.0005, 1 => 0.0005, 0 => 0.0005 ],    '-3.2' => [ 9 => 0.0005, 8 => 0.0005, 7 => 0.0005, 6 => 0.0006, 5 => 0.0006, 4 => 0.0006, 3 => 0.0006, 2 => 0.0006, 1 => 0.0007, 0 => 0.0007 ],    '-3.1' => [ 9 => 0.0007, 8 => 0.0007, 7 => 0.0008, 6 => 0.0008, 5 => 0.0008, 4 => 0.0008, 3 => 0.0009, 2 => 0.0009, 1 => 0.0009, 0 => 0.0010 ],    '-3.0' => [ 9 => 0.0010, 8 => 0.0010, 7 => 0.0011, 6 => 0.0011, 5 => 0.0011, 4 => 0.0012, 3 => 0.0012, 2 => 0.0013, 1 => 0.0013, 0 => 0.0013 ],    '-2.9' => [ 9 => 0.0014, 8 => 0.0014, 7 => 0.0015, 6 => 0.0015, 5 => 0.0016, 4 => 0.0016, 3 => 0.0017, 2 => 0.0018, 1 => 0.0018, 0 => 0.0019 ],    '-2.8' => [ 9 => 0.0019, 8 => 0.0020, 7 => 0.0021, 6 => 0.0021, 5 => 0.0022, 4 => 0.0023, 3 => 0.0023, 2 => 0.0024, 1 => 0.0025, 0 => 0.0026 ],    '-2.7' => [ 9 => 0.0026, 8 => 0.0027, 7 => 0.0028, 6 => 0.0029, 5 => 0.0030, 4 => 0.0031, 3 => 0.0032, 2 => 0.0033, 1 => 0.0034, 0 => 0.0035 ],    '-2.6' => [ 9 => 0.0036, 8 => 0.0037, 7 => 0.0038, 6 => 0.0039, 5 => 0.0040, 4 => 0.0041, 3 => 0.0043, 2 => 0.0044, 1 => 0.0045, 0 => 0.0047 ],    '-2.5' => [ 9 => 0.0048, 8 => 0.0049, 7 => 0.0051, 6 => 0.0052, 5 => 0.0054, 4 => 0.0055, 3 => 0.0057, 2 => 0.0059, 1 => 0.0060, 0 => 0.0062 ],    '-2.4' => [ 9 => 0.0064, 8 => 0.0066, 7 => 0.0068, 6 => 0.0069, 5 => 0.0071, 4 => 0.0073, 3 => 0.0075, 2 => 0.0078, 1 => 0.0080, 0 => 0.0082 ],    '-2.3' => [ 9 => 0.0084, 8 => 0.0087, 7 => 0.0089, 6 => 0.0091, 5 => 0.0094, 4 => 0.0096, 3 => 0.0099, 2 => 0.0102, 1 => 0.0104, 0 => 0.0107 ],    '-2.2' => [ 9 => 0.0110, 8 => 0.0113, 7 => 0.0116, 6 => 0.0119, 5 => 0.0122, 4 => 0.0125, 3 => 0.0129, 2 => 0.0132, 1 => 0.0136, 0 => 0.0139 ],    '-2.1' => [ 9 => 0.0143, 8 => 0.0146, 7 => 0.0150, 6 => 0.0154, 5 => 0.0158, 4 => 0.0162, 3 => 0.0166, 2 => 0.0170, 1 => 0.0174, 0 => 0.0179 ],    '-2.0' => [ 9 => 0.0183, 8 => 0.0188, 7 => 0.0192, 6 => 0.0197, 5 => 0.0202, 4 => 0.0207, 3 => 0.0212, 2 => 0.0217, 1 => 0.0222, 0 => 0.0228 ],    '-1.9' => [ 9 => 0.0233, 8 => 0.0239, 7 => 0.0244, 6 => 0.0250, 5 => 0.0256, 4 => 0.0262, 3 => 0.0268, 2 => 0.0274, 1 => 0.0281, 0 => 0.0287 ],    '-1.8' => [ 9 => 0.0294, 8 => 0.0301, 7 => 0.0307, 6 => 0.0314, 5 => 0.0322, 4 => 0.0329, 3 => 0.0336, 2 => 0.0344, 1 => 0.0351, 0 => 0.0359 ],    '-1.7' => [ 9 => 0.0367, 8 => 0.0375, 7 => 0.0384, 6 => 0.0392, 5 => 0.0401, 4 => 0.0409, 3 => 0.0418, 2 => 0.0427, 1 => 0.0436, 0 => 0.0446 ],    '-1.6' => [ 9 => 0.0455, 8 => 0.0465, 7 => 0.0475, 6 => 0.0485, 5 => 0.0495, 4 => 0.0505, 3 => 0.0516, 2 => 0.0526, 1 => 0.0537, 0 => 0.0548 ],    '-1.5' => [ 9 => 0.0559, 8 => 0.0571, 7 => 0.0582, 6 => 0.0594, 5 => 0.0606, 4 => 0.0618, 3 => 0.0630, 2 => 0.0643, 1 => 0.0655, 0 => 0.0668 ],    '-1.4' => [ 9 => 0.0681, 8 => 0.0694, 7 => 0.0708, 6 => 0.0721, 5 => 0.0735, 4 => 0.0749, 3 => 0.0764, 2 => 0.0778, 1 => 0.0793, 0 => 0.0808 ],    '-1.3' => [ 9 => 0.0823, 8 => 0.0838, 7 => 0.0853, 6 => 0.0869, 5 => 0.0885, 4 => 0.0901, 3 => 0.0918, 2 => 0.0934, 1 => 0.0951, 0 => 0.0968 ],    '-1.2' => [ 9 => 0.0985, 8 => 0.1003, 7 => 0.1020, 6 => 0.1038, 5 => 0.1056, 4 => 0.1075, 3 => 0.1093, 2 => 0.1112, 1 => 0.1131, 0 => 0.1151 ],    '-1.1' => [ 9 => 0.1170, 8 => 0.1190, 7 => 0.1210, 6 => 0.1230, 5 => 0.1251, 4 => 0.1271, 3 => 0.1292, 2 => 0.1314, 1 => 0.1335, 0 => 0.1357 ],    '-1.0' => [ 9 => 0.1379, 8 => 0.1401, 7 => 0.1423, 6 => 0.1446, 5 => 0.1469, 4 => 0.1492, 3 => 0.1515, 2 => 0.1539, 1 => 0.1562, 0 => 0.1587 ],    '-0.9' => [ 9 => 0.1611, 8 => 0.1635, 7 => 0.1660, 6 => 0.1685, 5 => 0.1711, 4 => 0.1736, 3 => 0.1762, 2 => 0.1788, 1 => 0.1814, 0 => 0.1841 ],    '-0.8' => [ 9 => 0.1867, 8 => 0.1894, 7 => 0.1922, 6 => 0.1949, 5 => 0.1977, 4 => 0.2005, 3 => 0.2033, 2 => 0.2061, 1 => 0.2090, 0 => 0.2119 ],    '-0.7' => [ 9 => 0.2148, 8 => 0.2177, 7 => 0.2206, 6 => 0.2236, 5 => 0.2266, 4 => 0.2296, 3 => 0.2327, 2 => 0.2358, 1 => 0.2389, 0 => 0.2420 ],    '-0.6' => [ 9 => 0.2451, 8 => 0.2483, 7 => 0.2514, 6 => 0.2546, 5 => 0.2578, 4 => 0.2611, 3 => 0.2643, 2 => 0.2676, 1 => 0.2709, 0 => 0.2743 ],    '-0.5' => [ 9 => 0.2776, 8 => 0.2810, 7 => 0.2843, 6 => 0.2877, 5 => 0.2912, 4 => 0.2946, 3 => 0.2981, 2 => 0.3015, 1 => 0.3050, 0 => 0.3085 ],    '-0.4' => [ 9 => 0.3121, 8 => 0.3156, 7 => 0.3192, 6 => 0.3228, 5 => 0.3264, 4 => 0.3300, 3 => 0.3336, 2 => 0.3372, 1 => 0.3409, 0 => 0.3446 ],    '-0.3' => [ 9 => 0.3483, 8 => 0.3520, 7 => 0.3557, 6 => 0.3594, 5 => 0.3632, 4 => 0.3669, 3 => 0.3707, 2 => 0.3745, 1 => 0.3783, 0 => 0.3821 ],    '-0.2' => [ 9 => 0.3829, 8 => 0.3897, 7 => 0.3936, 6 => 0.3974, 5 => 0.4013, 4 => 0.4052, 3 => 0.4090, 2 => 0.4129, 1 => 0.4168, 0 => 0.4207 ],    '-0.1' => [ 9 => 0.4247, 8 => 0.4286, 7 => 0.4325, 6 => 0.4364, 5 => 0.4404, 4 => 0.4443, 3 => 0.4483, 2 => 0.4522, 1 => 0.4562, 0 => 0.4602 ],    '-0.0' => [ 9 => 0.4641, 8 => 0.4681, 7 => 0.4721, 6 => 0.4761, 5 => 0.4801, 4 => 0.4840, 3 => 0.4880, 2 => 0.4920, 1 => 0.4960, 0 => 0.5000 ],     '0.0' => [ 0 => 0.50000, 1 => 0.50399, 2 => 0.50798, 3 => 0.51197, 4 => 0.51595, 5 => 0.51994, 6 => 0.52392, 7 => 0.52790, 8 => 0.53188, 9 => 0.53586 ],     '0.1' => [ 0 => 0.53980, 1 => 0.54380, 2 => 0.54776, 3 => 0.55172, 4 => 0.55567, 5 => 0.55966, 6 => 0.56360, 7 => 0.56749, 8 => 0.57142, 9 => 0.57535 ],     '0.2' => [ 0 => 0.57930, 1 => 0.58317, 2 => 0.58706, 3 => 0.59095, 4 => 0.59483, 5 => 0.59871, 6 => 0.60257, 7 => 0.60642, 8 => 0.61026, 9 => 0.61409 ],     '0.3' => [ 0 => 0.61791, 1 => 0.62172, 2 => 0.62552, 3 => 0.62930, 4 => 0.63307, 5 => 0.63683, 6 => 0.64058, 7 => 0.64431, 8 => 0.64803, 9 => 0.65173 ],     '0.4' => [ 0 => 0.65542, 1 => 0.65910, 2 => 0.66276, 3 => 0.66640, 4 => 0.67003, 5 => 0.67364, 6 => 0.67724, 7 => 0.68082, 8 => 0.68439, 9 => 0.68793 ],     '0.5' => [ 0 => 0.69146, 1 => 0.69497, 2 => 0.69847, 3 => 0.70194, 4 => 0.70540, 5 => 0.70884, 6 => 0.71226, 7 => 0.71566, 8 => 0.71904, 9 => 0.72240 ],     '0.6' => [ 0 => 0.72575, 1 => 0.72907, 2 => 0.73237, 3 => 0.73565, 4 => 0.73891, 5 => 0.74215, 6 => 0.74537, 7 => 0.74857, 8 => 0.75175, 9 => 0.75490 ],     '0.7' => [ 0 => 0.75804, 1 => 0.76115, 2 => 0.76424, 3 => 0.76730, 4 => 0.77035, 5 => 0.77337, 6 => 0.77637, 7 => 0.77935, 8 => 0.78230, 9 => 0.78524 ],     '0.8' => [ 0 => 0.78814, 1 => 0.79103, 2 => 0.79389, 3 => 0.79673, 4 => 0.79955, 5 => 0.80234, 6 => 0.80511, 7 => 0.80785, 8 => 0.81057, 9 => 0.81327 ],     '0.9' => [ 0 => 0.81594, 1 => 0.81859, 2 => 0.82121, 3 => 0.82381, 4 => 0.82639, 5 => 0.82894, 6 => 0.83147, 7 => 0.83398, 8 => 0.83646, 9 => 0.83891 ],     '1.0' => [ 0 => 0.84134, 1 => 0.84375, 2 => 0.84614, 3 => 0.84849, 4 => 0.85083, 5 => 0.85314, 6 => 0.85543, 7 => 0.85769, 8 => 0.85993, 9 => 0.86214 ],     '1.1' => [ 0 => 0.86433, 1 => 0.86650, 2 => 0.86864, 3 => 0.87076, 4 => 0.87286, 5 => 0.87493, 6 => 0.87698, 7 => 0.87900, 8 => 0.88100, 9 => 0.88298 ],     '1.2' => [ 0 => 0.88493, 1 => 0.88686, 2 => 0.88877, 3 => 0.89065, 4 => 0.89251, 5 => 0.89435, 6 => 0.89617, 7 => 0.89796, 8 => 0.89973, 9 => 0.90147 ],     '1.3' => [ 0 => 0.90320, 1 => 0.90490, 2 => 0.90658, 3 => 0.90824, 4 => 0.90988, 5 => 0.91149, 6 => 0.91308, 7 => 0.91466, 8 => 0.91621, 9 => 0.91774 ],     '1.4' => [ 0 => 0.91924, 1 => 0.92073, 2 => 0.92220, 3 => 0.92364, 4 => 0.92507, 5 => 0.92647, 6 => 0.92785, 7 => 0.92922, 8 => 0.93056, 9 => 0.93189 ],     '1.5' => [ 0 => 0.93319, 1 => 0.93448, 2 => 0.93574, 3 => 0.93699, 4 => 0.93822, 5 => 0.93943, 6 => 0.94062, 7 => 0.94179, 8 => 0.94295, 9 => 0.94408 ],     '1.6' => [ 0 => 0.94520, 1 => 0.94630, 2 => 0.94738, 3 => 0.94845, 4 => 0.94950, 5 => 0.95053, 6 => 0.95154, 7 => 0.95254, 8 => 0.95352, 9 => 0.95449 ],     '1.7' => [ 0 => 0.95543, 1 => 0.95637, 2 => 0.95728, 3 => 0.95818, 4 => 0.95907, 5 => 0.95994, 6 => 0.96080, 7 => 0.96164, 8 => 0.96246, 9 => 0.96327 ],     '1.8' => [ 0 => 0.96407, 1 => 0.96485, 2 => 0.96562, 3 => 0.96638, 4 => 0.96712, 5 => 0.96784, 6 => 0.96856, 7 => 0.96926, 8 => 0.96995, 9 => 0.97062 ],     '1.9' => [ 0 => 0.97128, 1 => 0.97193, 2 => 0.97257, 3 => 0.97320, 4 => 0.97381, 5 => 0.97441, 6 => 0.97500, 7 => 0.97558, 8 => 0.97615, 9 => 0.97670 ],     '2.0' => [ 0 => 0.97725, 1 => 0.97778, 2 => 0.97831, 3 => 0.97882, 4 => 0.97932, 5 => 0.97982, 6 => 0.98030, 7 => 0.98077, 8 => 0.98124, 9 => 0.98169 ],     '2.1' => [ 0 => 0.98214, 1 => 0.98257, 2 => 0.98300, 3 => 0.98341, 4 => 0.98382, 5 => 0.98422, 6 => 0.98461, 7 => 0.98500, 8 => 0.98537, 9 => 0.98574 ],     '2.2' => [ 0 => 0.98610, 1 => 0.98645, 2 => 0.98679, 3 => 0.98713, 4 => 0.98745, 5 => 0.98778, 6 => 0.98809, 7 => 0.98840, 8 => 0.98870, 9 => 0.98899 ],     '2.3' => [ 0 => 0.98928, 1 => 0.98956, 2 => 0.98983, 3 => 0.99010, 4 => 0.99036, 5 => 0.99061, 6 => 0.99086, 7 => 0.99111, 8 => 0.99134, 9 => 0.99158 ],     '2.4' => [ 0 => 0.99180, 1 => 0.99202, 2 => 0.99224, 3 => 0.99245, 4 => 0.99266, 5 => 0.99286, 6 => 0.99305, 7 => 0.99324, 8 => 0.99343, 9 => 0.99361 ],     '2.5' => [ 0 => 0.99379, 1 => 0.99396, 2 => 0.99413, 3 => 0.99430, 4 => 0.99446, 5 => 0.99461, 6 => 0.99477, 7 => 0.99492, 8 => 0.99506, 9 => 0.99520 ],     '2.6' => [ 0 => 0.99534, 1 => 0.99547, 2 => 0.99560, 3 => 0.99573, 4 => 0.99585, 5 => 0.99598, 6 => 0.99609, 7 => 0.99621, 8 => 0.99632, 9 => 0.99643 ],     '2.7' => [ 0 => 0.99653, 1 => 0.99664, 2 => 0.99674, 3 => 0.99683, 4 => 0.99693, 5 => 0.99702, 6 => 0.99711, 7 => 0.99720, 8 => 0.99728, 9 => 0.99736 ],     '2.8' => [ 0 => 0.99744, 1 => 0.99752, 2 => 0.99760, 3 => 0.99767, 4 => 0.99774, 5 => 0.99781, 6 => 0.99788, 7 => 0.99795, 8 => 0.99801, 9 => 0.99807 ],     '2.9' => [ 0 => 0.99813, 1 => 0.99819, 2 => 0.99825, 3 => 0.99831, 4 => 0.99836, 5 => 0.99841, 6 => 0.99846, 7 => 0.99851, 8 => 0.99856, 9 => 0.99861 ],     '3.0' => [ 0 => 0.99865, 1 => 0.99869, 2 => 0.99874, 3 => 0.99878, 4 => 0.99882, 5 => 0.99886, 6 => 0.99889, 7 => 0.99893, 8 => 0.99896, 9 => 0.99900 ],    ];    /**     * Get Z score probability (Î¦)     *     * @param float $Z     *     * @return float probability     *     * @throws Exception\BadDataException     */    public static function getZScoreProbability(float $Z): float    {        if (!preg_match('/^ (\-? \d [.] \d) (\d) $/x', \sprintf('%1.2f', $Z), $matches)) {            throw new Exception\BadParameterException(""Z does not match format X.XX: $Z"");        }        [$z, $ï¼‹0ï¼Ž0x] = [ $matches[1], $matches[2] ];        return self::Z_SCORES[$z][$ï¼‹0ï¼Ž0x];    }    /**     * Z scores for confidence intervals     * Key: confidence level %     * Value: Z score     * @var array     */    private const Z_SCORES_FOR_CONFIDENCE_INTERVALS = [        50     => 0.67449,        70     => 1.04,        75     => 1.15035,        80     => 1.282,        85     => 1.44,        90     => 1.64485,        92     => 1.75,        95     => 1.95996,        96     => 2.05,        97     => 2.17009,        98     => 2.326,        99     => 2.57583,        '99.5' => 2.81,        '99.8' => 3.08,        '99.9' => 3.29053,    ];    /**     * Get Z score for confidence interval     *     * @param  string $cl confidence level     *     * @return float Z score     *     * @throws Exception\BadDataException     */    public static function getZScoreForConfidenceInterval(string $cl): float    {        if (!\array_key_exists($cl, self::Z_SCORES_FOR_CONFIDENCE_INTERVALS)) {            throw new Exception\BadDataException('Not a valid confidence level');        }        return self::Z_SCORES_FOR_CONFIDENCE_INTERVALS[$cl];    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
362,canvas_js_example,PHP Scatter / Point Charts & Graphs. Scatter charts represents data as a series of points with their axis co-ordinates determined by x and y value of data point. Scatter Charts are also referred as Scatter Plot / Point Chart. Given example shows simple Scatter Chart along with source code that you can try running locally.,"Php crtač dijagrama rasejanja i grafikona. Tabele rasejanja sadrže podatke u vidu niza koordinatnih tačaka od kojih svaka ima vrednosti koje odgovaraju x i y osi. Tabele rasejanja, se takođe oslovljava kao tabela tačaka ili dijagram rasejanja. Dat primer prikazuje jednostavnu tabelu rasejanja sa izvornim kodom koji možete lokalno pokrenuti.","<?php   $dataPoints = array( 	array(""x""=> 51, ""y""=> 51), 	array(""x""=> 77, ""y""=> 56), 	array(""x""=> 82, ""y""=> 57), 	array(""x""=> 82.5, ""y""=> 63.5), 	array(""x""=> 83, ""y""=> 59.5), 	array(""x""=> 85, ""y""=> 58), 	array(""x""=> 90, ""y""=> 65), 	array(""x""=> 97.5, ""y""=> 66), 	array(""x""=> 99, ""y""=> 59), 	array(""x""=> 102, ""y""=> 64), 	array(""x""=> 102, ""y""=> 63), 	array(""x""=> 111.5, ""y""=> 68), 	array(""x""=> 112, ""y""=> 70), 	array(""x""=> 113, ""y""=> 61), 	array(""x""=> 128, ""y""=> 65), 	array(""x""=> 132, ""y""=> 66.5), 	array(""x""=> 151, ""y""=> 71) ); 	 ?> <!DOCTYPE HTML> <html> <head>   <script> window.onload = function () {   var chart = new CanvasJS.Chart(""chartContainer"", { 	animationEnabled: true, 	exportEnabled: true, 	theme: ""light1"",  	title:{ 		text: ""Study of Height vs Weight"" 	}, 	axisX:{ 		title: ""Weight"", 		suffix: "" kg"" 	}, 	axisY:{ 		title: ""Height"", 		suffix: "" inch"" 	}, 	data: [{ 		type: ""scatter"", 		markerType: ""square"", 		markerSize: 10, 		toolTipContent: ""Height: {y} inch<br>Weight: {x} kg"", 		dataPoints: <?php echo json_encode($dataPoints, JSON_NUMERIC_CHECK); ?> 	}] }); chart.render();   } </script> </head> <body> <div id=""chartContainer"" style=""height: 370px; width: 100%;""></div> <script src=""https://canvasjs.com/assets/script/canvasjs.min.js""></script> </body> </html>",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
363,php-pm_php-pm_ProcessSlave_1636, Handles incoming requests and transforms a $request into a $response by reference.\n\n @param ServerRequestInterface $request\n\n @return ResponseInterface|Promise\n @throws \\Exception\n,Rukovodi pristiglim zahtevima i transformiše zahtev u odgovor referencom.,"    public function onRequest(ServerRequestInterface $request)    {        if ($this->isPopulateServer()) {            $this->prepareEnvironment($request);        }        $remoteIp = $request->getHeaderLine('X-PHP-PM-Remote-IP');        $remotePort = $request->getHeaderLine('X-PHP-PM-Remote-Port');        $request = $request->withoutHeader('X-PHP-PM-Remote-IP');        $request = $request->withoutHeader('X-PHP-PM-Remote-Port');        $request = $request->withAttribute('remote_address', $remoteIp);        $request = $request->withAttribute('remote_port', $remotePort);        $logTime = \date('d/M/Y:H:i:s O');        $catchLog = function ($e) {            console_log((string) $e);            return new Response(500);        };        try {            $response = $this->handleRequest($request);        } catch (\Throwable $t) {            $response = $catchLog($t);        }        $promise = new Promise(function ($resolve) use ($response) {            return $resolve($response);        });        $promise = $promise->then(function (ResponseInterface $response) use ($request, $logTime, $remoteIp) {            if ($this->isLogging()) {                $this->logResponse($request, $response, $logTime, $remoteIp);            }            return $response;        });        return $promise;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
364,symfony_http-foundation_Request_7904, Request represents an HTTP request.\n\n The methods dealing with URL accept / return a raw path (% encoded):\n                  \n @author Fabien Potencier <fabien@symfony.com>\n,Klasa Request predstavlja http request,"class Request {     public const HEADER_FORWARDED = 0b000001; // When using RFC 7239     public const HEADER_X_FORWARDED_FOR = 0b000010;     public const HEADER_X_FORWARDED_HOST = 0b000100;     public const HEADER_X_FORWARDED_PROTO = 0b001000;     public const HEADER_X_FORWARDED_PORT = 0b010000;     public const HEADER_X_FORWARDED_PREFIX = 0b100000;      /** @deprecated since Symfony 5.2, use either ""HEADER_X_FORWARDED_FOR | HEADER_X_FORWARDED_HOST | HEADER_X_FORWARDED_PORT | HEADER_X_FORWARDED_PROTO"" or ""HEADER_X_FORWARDED_AWS_ELB"" or ""HEADER_X_FORWARDED_TRAEFIK"" constants instead. */     public const HEADER_X_FORWARDED_ALL = 0b1011110; // All ""X-Forwarded-*"" headers sent by ""usual"" reverse proxy     public const HEADER_X_FORWARDED_AWS_ELB = 0b0011010; // AWS ELB doesn't send X-Forwarded-Host     public const HEADER_X_FORWARDED_TRAEFIK = 0b0111110; // All ""X-Forwarded-*"" headers sent by Traefik reverse proxy      public const METHOD_HEAD = 'HEAD';     public const METHOD_GET = 'GET';     public const METHOD_POST = 'POST';     public const METHOD_PUT = 'PUT';     public const METHOD_PATCH = 'PATCH';     public const METHOD_DELETE = 'DELETE';     public const METHOD_PURGE = 'PURGE';     public const METHOD_OPTIONS = 'OPTIONS';     public const METHOD_TRACE = 'TRACE';     public const METHOD_CONNECT = 'CONNECT';      /**      * @var string[]      */     protected static $trustedProxies = [];      /**      * @var string[]      */     protected static $trustedHostPatterns = [];      /**      * @var string[]      */     protected static $trustedHosts = [];      protected static $httpMethodParameterOverride = false;      /**      * Custom parameters.      *      * @var ParameterBag      */     public $attributes;      /**      * Request body parameters ($_POST).      *      * @var InputBag      */     public $request;      /**      * Query string parameters ($_GET).      *      * @var InputBag      */     public $query;      /**      * Server and execution environment parameters ($_SERVER).      *      * @var ServerBag      */     public $server;      /**      * Uploaded files ($_FILES).      *      * @var FileBag      */     public $files;      /**      * Cookies ($_COOKIE).      *      * @var InputBag      */     public $cookies;      /**      * Headers (taken from the $_SERVER).      *      * @var HeaderBag      */     public $headers;      /**      * @var string|resource|false|null      */     protected $content;      /**      * @var array      */     protected $languages;      /**      * @var array      */     protected $charsets;      /**      * @var array      */     protected $encodings;      /**      * @var array      */     protected $acceptableContentTypes;      /**      * @var string      */     protected $pathInfo;      /**      * @var string      */     protected $requestUri;      /**      * @var string      */     protected $baseUrl;      /**      * @var string      */     protected $basePath;      /**      * @var string      */     protected $method;      /**      * @var string      */     protected $format;      /**      * @var SessionInterface|callable      */     protected $session;      /**      * @var string      */     protected $locale;      /**      * @var string      */     protected $defaultLocale = 'en';      /**      * @var array      */     protected static $formats;      protected static $requestFactory;      /**      * @var string|null      */     private $preferredFormat;     private $isHostValid = true;     private $isForwardedValid = true;      /**      * @var bool|null      */     private $isSafeContentPreferred;      private static $trustedHeaderSet = -1;      private const FORWARDED_PARAMS = [         self::HEADER_X_FORWARDED_FOR => 'for',         self::HEADER_X_FORWARDED_HOST => 'host',         self::HEADER_X_FORWARDED_PROTO => 'proto',         self::HEADER_X_FORWARDED_PORT => 'host',     ];      /**      * Names for headers that can be trusted when      * using trusted proxies.      *      * The FORWARDED header is the standard as of rfc7239.      *      * The other headers are non-standard, but widely used      * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).      */     private const TRUSTED_HEADERS = [         self::HEADER_FORWARDED => 'FORWARDED',         self::HEADER_X_FORWARDED_FOR => 'X_FORWARDED_FOR',         self::HEADER_X_FORWARDED_HOST => 'X_FORWARDED_HOST',         self::HEADER_X_FORWARDED_PROTO => 'X_FORWARDED_PROTO',         self::HEADER_X_FORWARDED_PORT => 'X_FORWARDED_PORT',         self::HEADER_X_FORWARDED_PREFIX => 'X_FORWARDED_PREFIX',     ];      /**      * @param array                $query      The GET parameters      * @param array                $request    The POST parameters      * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)      * @param array                $cookies    The COOKIE parameters      * @param array                $files      The FILES parameters      * @param array                $server     The SERVER parameters      * @param string|resource|null $content    The raw body data      */     public function __construct(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)     {         $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);     }      /**      * Sets the parameters for this request.      *      * This method also re-initializes all properties.      *      * @param array                $query      The GET parameters      * @param array                $request    The POST parameters      * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)      * @param array                $cookies    The COOKIE parameters      * @param array                $files      The FILES parameters      * @param array                $server     The SERVER parameters      * @param string|resource|null $content    The raw body data      */     public function initialize(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)     {         $this->request = new InputBag($request);         $this->query = new InputBag($query);         $this->attributes = new ParameterBag($attributes);         $this->cookies = new InputBag($cookies);         $this->files = new FileBag($files);         $this->server = new ServerBag($server);         $this->headers = new HeaderBag($this->server->getHeaders());          $this->content = $content;         $this->languages = null;         $this->charsets = null;         $this->encodings = null;         $this->acceptableContentTypes = null;         $this->pathInfo = null;         $this->requestUri = null;         $this->baseUrl = null;         $this->basePath = null;         $this->method = null;         $this->format = null;     }      /**      * Creates a new request with values from PHP's super globals.      *      * @return static      */     public static function createFromGlobals()     {         $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);          if (0 === strpos($request->headers->get('CONTENT_TYPE', ''), 'application/x-www-form-urlencoded')             && \in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])         ) {             parse_str($request->getContent(), $data);             $request->request = new InputBag($data);         }          return $request;     }      /**      * Creates a Request based on a given URI and configuration.      *      * The information contained in the URI always take precedence      * over the other information (server and parameters).      *      * @param string               $uri        The URI      * @param string               $method     The HTTP method      * @param array                $parameters The query (GET) or request (POST) parameters      * @param array                $cookies    The request cookies ($_COOKIE)      * @param array                $files      The request files ($_FILES)      * @param array                $server     The server parameters ($_SERVER)      * @param string|resource|null $content    The raw body data      *      * @return static      */     public static function create(string $uri, string $method = 'GET', array $parameters = [], array $cookies = [], array $files = [], array $server = [], $content = null)     {         $server = array_replace([             'SERVER_NAME' => 'localhost',             'SERVER_PORT' => 80,             'HTTP_HOST' => 'localhost',             'HTTP_USER_AGENT' => 'Symfony',             'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',             'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',             'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',             'REMOTE_ADDR' => '127.0.0.1',             'SCRIPT_NAME' => '',             'SCRIPT_FILENAME' => '',             'SERVER_PROTOCOL' => 'HTTP/1.1',             'REQUEST_TIME' => time(),             'REQUEST_TIME_FLOAT' => microtime(true),         ], $server);          $server['PATH_INFO'] = '';         $server['REQUEST_METHOD'] = strtoupper($method);          $components = parse_url($uri);         if (isset($components['host'])) {             $server['SERVER_NAME'] = $components['host'];             $server['HTTP_HOST'] = $components['host'];         }          if (isset($components['scheme'])) {             if ('https' === $components['scheme']) {                 $server['HTTPS'] = 'on';                 $server['SERVER_PORT'] = 443;             } else {                 unset($server['HTTPS']);                 $server['SERVER_PORT'] = 80;             }         }          if (isset($components['port'])) {             $server['SERVER_PORT'] = $components['port'];             $server['HTTP_HOST'] .= ':'.$components['port'];         }          if (isset($components['user'])) {             $server['PHP_AUTH_USER'] = $components['user'];         }          if (isset($components['pass'])) {             $server['PHP_AUTH_PW'] = $components['pass'];         }          if (!isset($components['path'])) {             $components['path'] = '/';         }          switch (strtoupper($method)) {             case 'POST':             case 'PUT':             case 'DELETE':                 if (!isset($server['CONTENT_TYPE'])) {                     $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';                 }                 // no break             case 'PATCH':                 $request = $parameters;                 $query = [];                 break;             default:                 $request = [];                 $query = $parameters;                 break;         }          $queryString = '';         if (isset($components['query'])) {             parse_str(html_entity_decode($components['query']), $qs);              if ($query) {                 $query = array_replace($qs, $query);                 $queryString = http_build_query($query, '', '&');             } else {                 $query = $qs;                 $queryString = $components['query'];             }         } elseif ($query) {             $queryString = http_build_query($query, '', '&');         }          $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');         $server['QUERY_STRING'] = $queryString;          return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);     }      /**      * Sets a callable able to create a Request instance.      *      * This is mainly useful when you need to override the Request class      * to keep BC with an existing system. It should not be used for any      * other purpose.      */     public static function setFactory(?callable $callable)     {         self::$requestFactory = $callable;     }      /**      * Clones a request and overrides some of its parameters.      *      * @param array $query      The GET parameters      * @param array $request    The POST parameters      * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)      * @param array $cookies    The COOKIE parameters      * @param array $files      The FILES parameters      * @param array $server     The SERVER parameters      *      * @return static      */     public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)     {         $dup = clone $this;         if (null !== $query) {             $dup->query = new InputBag($query);         }         if (null !== $request) {             $dup->request = new InputBag($request);         }         if (null !== $attributes) {             $dup->attributes = new ParameterBag($attributes);         }         if (null !== $cookies) {             $dup->cookies = new InputBag($cookies);         }         if (null !== $files) {             $dup->files = new FileBag($files);         }         if (null !== $server) {             $dup->server = new ServerBag($server);             $dup->headers = new HeaderBag($dup->server->getHeaders());         }         $dup->languages = null;         $dup->charsets = null;         $dup->encodings = null;         $dup->acceptableContentTypes = null;         $dup->pathInfo = null;         $dup->requestUri = null;         $dup->baseUrl = null;         $dup->basePath = null;         $dup->method = null;         $dup->format = null;          if (!$dup->get('_format') && $this->get('_format')) {             $dup->attributes->set('_format', $this->get('_format'));         }          if (!$dup->getRequestFormat(null)) {             $dup->setRequestFormat($this->getRequestFormat(null));         }          return $dup;     }      /**      * Clones the current request.      *      * Note that the session is not cloned as duplicated requests      * are most of the time sub-requests of the main one.      */     public function __clone()     {         $this->query = clone $this->query;         $this->request = clone $this->request;         $this->attributes = clone $this->attributes;         $this->cookies = clone $this->cookies;         $this->files = clone $this->files;         $this->server = clone $this->server;         $this->headers = clone $this->headers;     }      /**      * Returns the request as a string.      *      * @return string The request      */     public function __toString()     {         $content = $this->getContent();          $cookieHeader = '';         $cookies = [];          foreach ($this->cookies as $k => $v) {             $cookies[] = $k.'='.$v;         }          if (!empty($cookies)) {             $cookieHeader = 'Cookie: '.implode('; ', $cookies).""\r\n"";         }          return             sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).""\r\n"".             $this->headers.             $cookieHeader.""\r\n"".             $content;     }      /**      * Overrides the PHP global variables according to this request instance.      *      * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.      * $_FILES is never overridden, see rfc1867      */     public function overrideGlobals()     {         $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));          $_GET = $this->query->all();         $_POST = $this->request->all();         $_SERVER = $this->server->all();         $_COOKIE = $this->cookies->all();          foreach ($this->headers->all() as $key => $value) {             $key = strtoupper(str_replace('-', '_', $key));             if (\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {                 $_SERVER[$key] = implode(', ', $value);             } else {                 $_SERVER['HTTP_'.$key] = implode(', ', $value);             }         }          $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];          $requestOrder = ini_get('request_order') ?: ini_get('variables_order');         $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';          $_REQUEST = [[]];          foreach (str_split($requestOrder) as $order) {             $_REQUEST[] = $request[$order];         }          $_REQUEST = array_merge(...$_REQUEST);     }      /**      * Sets a list of trusted proxies.      *      * You should only list the reverse proxies that you manage directly.      *      * @param array $proxies          A list of trusted proxies, the string 'REMOTE_ADDR' will be replaced with $_SERVER['REMOTE_ADDR']      * @param int   $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies      */     public static function setTrustedProxies(array $proxies, int $trustedHeaderSet)     {         if (self::HEADER_X_FORWARDED_ALL === $trustedHeaderSet) {             trigger_deprecation('symfony/http-foundation', '5.2', 'The ""HEADER_X_FORWARDED_ALL"" constant is deprecated, use either ""HEADER_X_FORWARDED_FOR | HEADER_X_FORWARDED_HOST | HEADER_X_FORWARDED_PORT | HEADER_X_FORWARDED_PROTO"" or ""HEADER_X_FORWARDED_AWS_ELB"" or ""HEADER_X_FORWARDED_TRAEFIK"" constants instead.');         }         self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {             if ('REMOTE_ADDR' !== $proxy) {                 $proxies[] = $proxy;             } elseif (isset($_SERVER['REMOTE_ADDR'])) {                 $proxies[] = $_SERVER['REMOTE_ADDR'];             }              return $proxies;         }, []);         self::$trustedHeaderSet = $trustedHeaderSet;     }      /**      * Gets the list of trusted proxies.      *      * @return array An array of trusted proxies      */     public static function getTrustedProxies()     {         return self::$trustedProxies;     }      /**      * Gets the set of trusted headers from trusted proxies.      *      * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies      */     public static function getTrustedHeaderSet()     {         return self::$trustedHeaderSet;     }      /**      * Sets a list of trusted host patterns.      *      * You should only list the hosts you manage using regexs.      *      * @param array $hostPatterns A list of trusted host patterns      */     public static function setTrustedHosts(array $hostPatterns)     {         self::$trustedHostPatterns = array_map(function ($hostPattern) {             return sprintf('{%s}i', $hostPattern);         }, $hostPatterns);         // we need to reset trusted hosts on trusted host patterns change         self::$trustedHosts = [];     }      /**      * Gets the list of trusted host patterns.      *      * @return array An array of trusted host patterns      */     public static function getTrustedHosts()     {         return self::$trustedHostPatterns;     }      /**      * Normalizes a query string.      *      * It builds a normalized query string, where keys/value pairs are alphabetized,      * have consistent escaping and unneeded delimiters are removed.      *      * @return string A normalized query string for the Request      */     public static function normalizeQueryString(?string $qs)     {         if ('' === ($qs ?? '')) {             return '';         }          $qs = HeaderUtils::parseQuery($qs);         ksort($qs);          return http_build_query($qs, '', '&', \PHP_QUERY_RFC3986);     }      /**      * Enables support for the _method request parameter to determine the intended HTTP method.      *      * Be warned that enabling this feature might lead to CSRF issues in your code.      * Check that you are using CSRF tokens when required.      * If the HTTP method parameter override is enabled, an html-form with method ""POST"" can be altered      * and used to send a ""PUT"" or ""DELETE"" request via the _method request parameter.      * If these methods are not protected against CSRF, this presents a possible vulnerability.      *      * The HTTP method can only be overridden when the real HTTP method is POST.      */     public static function enableHttpMethodParameterOverride()     {         self::$httpMethodParameterOverride = true;     }      /**      * Checks whether support for the _method request parameter is enabled.      *      * @return bool True when the _method request parameter is enabled, false otherwise      */     public static function getHttpMethodParameterOverride()     {         return self::$httpMethodParameterOverride;     }      /**      * Gets a ""parameter"" value from any bag.      *      * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the      * flexibility in controllers, it is better to explicitly get request parameters from the appropriate      * public property instead (attributes, query, request).      *      * Order of precedence: PATH (routing placeholders or custom attributes), GET, POST      *      * @param mixed $default The default value if the parameter key does not exist      *      * @return mixed      */     public function get(string $key, $default = null)     {         if ($this !== $result = $this->attributes->get($key, $this)) {             return $result;         }          if ($this->query->has($key)) {             return $this->query->all()[$key];         }          if ($this->request->has($key)) {             return $this->request->all()[$key];         }          return $default;     }      /**      * Gets the Session.      *      * @return SessionInterface The session      */     public function getSession()     {         $session = $this->session;         if (!$session instanceof SessionInterface && null !== $session) {             $this->setSession($session = $session());         }          if (null === $session) {             throw new SessionNotFoundException('Session has not been set.');         }          return $session;     }      /**      * Whether the request contains a Session which was started in one of the      * previous requests.      *      * @return bool      */     public function hasPreviousSession()     {         // the check for $this->session avoids malicious users trying to fake a session cookie with proper name         return $this->hasSession() && $this->cookies->has($this->getSession()->getName());     }      /**      * Whether the request contains a Session object.      *      * This method does not give any information about the state of the session object,      * like whether the session is started or not. It is just a way to check if this Request      * is associated with a Session instance.      *      * @return bool true when the Request contains a Session object, false otherwise      */     public function hasSession()     {         return null !== $this->session;     }      public function setSession(SessionInterface $session)     {         $this->session = $session;     }      /**      * @internal      */     public function setSessionFactory(callable $factory)     {         $this->session = $factory;     }      /**      * Returns the client IP addresses.      *      * In the returned array the most trusted IP address is first, and the      * least trusted one last. The ""real"" client IP address is the last one,      * but this is also the least trusted one. Trusted proxies are stripped.      *      * Use this method carefully; you should use getClientIp() instead.      *      * @return array The client IP addresses      *      * @see getClientIp()      */     public function getClientIps()     {         $ip = $this->server->get('REMOTE_ADDR');          if (!$this->isFromTrustedProxy()) {             return [$ip];         }          return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];     }      /**      * Returns the client IP address.      *      * This method can read the client IP address from the ""X-Forwarded-For"" header      * when trusted proxies were set via ""setTrustedProxies()"". The ""X-Forwarded-For""      * header value is a comma+space separated list of IP addresses, the left-most      * being the original client, and each successive proxy that passed the request      * adding the IP address where it received the request from.      *      * If your reverse proxy uses a different header name than ""X-Forwarded-For"",      * (""Client-Ip"" for instance), configure it via the $trustedHeaderSet      * argument of the Request::setTrustedProxies() method instead.      *      * @return string|null The client IP address      *      * @see getClientIps()      * @see https://wikipedia.org/wiki/X-Forwarded-For      */     public function getClientIp()     {         $ipAddresses = $this->getClientIps();          return $ipAddresses[0];     }      /**      * Returns current script name.      *      * @return string      */     public function getScriptName()     {         return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));     }      /**      * Returns the path being requested relative to the executed script.      *      * The path info always starts with a /.      *      * Suppose this request is instantiated from /mysite on localhost:      *      *  * http://localhost/mysite              returns an empty string      *  * http://localhost/mysite/about        returns '/about'      *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'      *  * http://localhost/mysite/about?var=1  returns '/about'      *      * @return string The raw path (i.e. not urldecoded)      */     public function getPathInfo()     {         if (null === $this->pathInfo) {             $this->pathInfo = $this->preparePathInfo();         }          return $this->pathInfo;     }      /**      * Returns the root path from which this request is executed.      *      * Suppose that an index.php file instantiates this request object:      *      *  * http://localhost/index.php         returns an empty string      *  * http://localhost/index.php/page    returns an empty string      *  * http://localhost/web/index.php     returns '/web'      *  * http://localhost/we%20b/index.php  returns '/we%20b'      *      * @return string The raw path (i.e. not urldecoded)      */     public function getBasePath()     {         if (null === $this->basePath) {             $this->basePath = $this->prepareBasePath();         }          return $this->basePath;     }      /**      * Returns the root URL from which this request is executed.      *      * The base URL never ends with a /.      *      * This is similar to getBasePath(), except that it also includes the      * script filename (e.g. index.php) if one exists.      *      * @return string The raw URL (i.e. not urldecoded)      */     public function getBaseUrl()     {         $trustedPrefix = '';          // the proxy prefix must be prepended to any prefix being needed at the webserver level         if ($this->isFromTrustedProxy() && $trustedPrefixValues = $this->getTrustedValues(self::HEADER_X_FORWARDED_PREFIX)) {             $trustedPrefix = rtrim($trustedPrefixValues[0], '/');         }          return $trustedPrefix.$this->getBaseUrlReal();     }      /**      * Returns the real base URL received by the webserver from which this request is executed.      * The URL does not include trusted reverse proxy prefix.      *      * @return string The raw URL (i.e. not urldecoded)      */     private function getBaseUrlReal()     {         if (null === $this->baseUrl) {             $this->baseUrl = $this->prepareBaseUrl();         }          return $this->baseUrl;     }      /**      * Gets the request's scheme.      *      * @return string      */     public function getScheme()     {         return $this->isSecure() ? 'https' : 'http';     }      /**      * Returns the port on which the request is made.      *      * This method can read the client port from the ""X-Forwarded-Port"" header      * when trusted proxies were set via ""setTrustedProxies()"".      *      * The ""X-Forwarded-Port"" header must contain the client port.      *      * @return int|string can be a string if fetched from the server bag      */     public function getPort()     {         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {             $host = $host[0];         } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {             $host = $host[0];         } elseif (!$host = $this->headers->get('HOST')) {             return $this->server->get('SERVER_PORT');         }          if ('[' === $host[0]) {             $pos = strpos($host, ':', strrpos($host, ']'));         } else {             $pos = strrpos($host, ':');         }          if (false !== $pos && $port = substr($host, $pos + 1)) {             return (int) $port;         }          return 'https' === $this->getScheme() ? 443 : 80;     }      /**      * Returns the user.      *      * @return string|null      */     public function getUser()     {         return $this->headers->get('PHP_AUTH_USER');     }      /**      * Returns the password.      *      * @return string|null      */     public function getPassword()     {         return $this->headers->get('PHP_AUTH_PW');     }      /**      * Gets the user info.      *      * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server      */     public function getUserInfo()     {         $userinfo = $this->getUser();          $pass = $this->getPassword();         if ('' != $pass) {             $userinfo .= "":$pass"";         }          return $userinfo;     }      /**      * Returns the HTTP host being requested.      *      * The port name will be appended to the host if it's non-standard.      *      * @return string      */     public function getHttpHost()     {         $scheme = $this->getScheme();         $port = $this->getPort();          if (('http' == $scheme && 80 == $port) || ('https' == $scheme && 443 == $port)) {             return $this->getHost();         }          return $this->getHost().':'.$port;     }      /**      * Returns the requested URI (path and query string).      *      * @return string The raw URI (i.e. not URI decoded)      */     public function getRequestUri()     {         if (null === $this->requestUri) {             $this->requestUri = $this->prepareRequestUri();         }          return $this->requestUri;     }      /**      * Gets the scheme and HTTP host.      *      * If the URL was called with basic authentication, the user      * and the password are not added to the generated string.      *      * @return string The scheme and HTTP host      */     public function getSchemeAndHttpHost()     {         return $this->getScheme().'://'.$this->getHttpHost();     }      /**      * Generates a normalized URI (URL) for the Request.      *      * @return string A normalized URI (URL) for the Request      *      * @see getQueryString()      */     public function getUri()     {         if (null !== $qs = $this->getQueryString()) {             $qs = '?'.$qs;         }          return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;     }      /**      * Generates a normalized URI for the given path.      *      * @param string $path A path to use instead of the current one      *      * @return string The normalized URI for the path      */     public function getUriForPath(string $path)     {         return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;     }      /**      * Returns the path as relative reference from the current Request path.      *      * Only the URIs path component (no schema, host etc.) is relevant and must be given.      * Both paths must be absolute and not contain relative parts.      * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.      * Furthermore, they can be used to reduce the link size in documents.      *      * Example target paths, given a base path of ""/a/b/c/d"":      * - ""/a/b/c/d""     -> """"      * - ""/a/b/c/""      -> ""./""      * - ""/a/b/""        -> ""../""      * - ""/a/b/c/other"" -> ""other""      * - ""/a/x/y""       -> ""../../x/y""      *      * @return string The relative target path      */     public function getRelativeUriForPath(string $path)     {         // be sure that we are dealing with an absolute path         if (!isset($path[0]) || '/' !== $path[0]) {             return $path;         }          if ($path === $basePath = $this->getPathInfo())",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,2.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0
365,symfony_http-foundation_Request_7910," Sets a list of trusted proxies.\n\n You should only list the reverse proxies that you manage directly.\n\n @param array $proxies          A list of trusted proxies, the string 'REMOTE_ADDR' will be replaced with $_SERVER['REMOTE_ADDR']\n @param int   $trustedHeaderSet A bit field of Request::HEADER_",Postavlja listu pouzdanih proksija. Trebalo biste navesti obrnute proksije kojima direktno upravljate.,"    public static function setTrustedProxies(array $proxies, int $trustedHeaderSet)    {        if (self::HEADER_X_FORWARDED_ALL === $trustedHeaderSet) {            trigger_deprecation('symfony/http-foundation', '5.2', 'The ""HEADER_X_FORWARDED_ALL"" constant is deprecated, use either ""HEADER_X_FORWARDED_FOR | HEADER_X_FORWARDED_HOST | HEADER_X_FORWARDED_PORT | HEADER_X_FORWARDED_PROTO"" or ""HEADER_X_FORWARDED_AWS_ELB"" or ""HEADER_X_FORWARDED_TRAEFIK"" constants instead.');        }        self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {            if ('REMOTE_ADDR' !== $proxy) {                $proxies[] = $proxy;            } elseif (isset($_SERVER['REMOTE_ADDR'])) {                $proxies[] = $_SERVER['REMOTE_ADDR'];            }            return $proxies;        }, []);        self::$trustedHeaderSet = $trustedHeaderSet;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
366,symfony_http-foundation_Request_8894," Indicates whether this request originated from a trusted proxy.\n\n This can be useful to determine whether or not to trust the\n contents of a proxy-specific header.\n\n @return bool true if the request came from a trusted proxy, false otherwise\n","Proveri da li je zahtev pristigao od pouzdanog proksi servera. Ovo je korisno prilikom utvrđivanja da li se sadržaju zaglavlja, specifičnog za proksi, može verovati.","    public function isFromTrustedProxy()    {        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR', ''), self::$trustedProxies);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
367,walkor_Workerman_AsyncTcpConnection_8693, AsyncTcpConnection.\n,Asinhrona TCP konekcija.,"class AsyncTcpConnection extends TcpConnection{    /**     * Emitted when socket connection is successfully established.     *     * @var callable|null     */    public $onConnect = null;    /**     * Transport layer protocol.     *     * @var string     */    public $transport = 'tcp';    /**     * Status.     *     * @var int     */    protected $_status = self::STATUS_INITIAL;    /**     * Remote host.     *     * @var string     */    protected $_remoteHost = '';    /**     * Remote port.     *     * @var int     */    protected $_remotePort = 80;    /**     * Connect start time.     *     * @var float     */    protected $_connectStartTime = 0;    /**     * Remote URI.     *     * @var string     */    protected $_remoteURI = '';    /**     * Context option.     *     * @var array     */    protected $_contextOption = null;    /**     * Reconnect timer.     *     * @var int     */    protected $_reconnectTimer = null;    /**     * PHP built-in protocols.     *     * @var array     */    protected static $_builtinTransports = array(        'tcp'   => 'tcp',        'udp'   => 'udp',        'unix'  => 'unix',        'ssl'   => 'ssl',        'sslv2' => 'sslv2',        'sslv3' => 'sslv3',        'tls'   => 'tls'    );    /**     * Construct.     *     * @param string $remote_address     * @param array $context_option     * @throws Exception     */    public function __construct($remote_address, array $context_option = array())    {        $address_info = \parse_url($remote_address);        if (!$address_info) {            list($scheme, $this->_remoteAddress) = \explode(':', $remote_address, 2);            if (!$this->_remoteAddress) {                Worker::safeEcho(new \Exception('bad remote_address'));            }        } else {            if (!isset($address_info['port'])) {                $address_info['port'] = 0;            }            if (!isset($address_info['path'])) {                $address_info['path'] = '/';            }            if (!isset($address_info['query'])) {                $address_info['query'] = '';            } else {                $address_info['query'] = '?' . $address_info['query'];            }            $this->_remoteAddress = ""{$address_info['host']}:{$address_info['port']}"";            $this->_remoteHost    = $address_info['host'];            $this->_remotePort    = $address_info['port'];            $this->_remoteURI     = ""{$address_info['path']}{$address_info['query']}"";            $scheme               = isset($address_info['scheme']) ? $address_info['scheme'] : 'tcp';        }        $this->id = $this->_id = self::$_idRecorder++;        if(\PHP_INT_MAX === self::$_idRecorder){            self::$_idRecorder = 0;        }        // Check application layer protocol class.        if (!isset(self::$_builtinTransports[$scheme])) {            $scheme         = \ucfirst($scheme);            $this->protocol = '\\Protocols\\' . $scheme;            if (!\class_exists($this->protocol)) {                $this->protocol = ""\\Workerman\\Protocols\\$scheme"";                if (!\class_exists($this->protocol)) {                    throw new Exception(""class \\Protocols\\$scheme not exist"");                }            }        } else {            $this->transport = self::$_builtinTransports[$scheme];        }        // For statistics.        ++self::$statistics['connection_count'];        $this->maxSendBufferSize         = self::$defaultMaxSendBufferSize;        $this->maxPackageSize            = self::$defaultMaxPackageSize;        $this->_contextOption            = $context_option;        static::$connections[$this->_id] = $this;    }    /**     * Do connect.     *     * @return void     */    public function connect()    {        if ($this->_status !== self::STATUS_INITIAL && $this->_status !== self::STATUS_CLOSING &&            $this->_status !== self::STATUS_CLOSED) {            return;        }        $this->_status           = self::STATUS_CONNECTING;        $this->_connectStartTime = \microtime(true);        if ($this->transport !== 'unix') {            if (!$this->_remotePort) {                $this->_remotePort = $this->transport === 'ssl' ? 443 : 80;                $this->_remoteAddress = $this->_remoteHost.':'.$this->_remotePort;            }            // Open socket connection asynchronously.            if ($this->_contextOption) {                $context = \stream_context_create($this->_contextOption);                $this->_socket = \stream_socket_client(""tcp://{$this->_remoteHost}:{$this->_remotePort}"",                    $errno, $errstr, 0, \STREAM_CLIENT_ASYNC_CONNECT, $context);            } else {                $this->_socket = \stream_socket_client(""tcp://{$this->_remoteHost}:{$this->_remotePort}"",                    $errno, $errstr, 0, \STREAM_CLIENT_ASYNC_CONNECT);            }        } else {            $this->_socket = \stream_socket_client(""{$this->transport}://{$this->_remoteAddress}"", $errno, $errstr, 0,                \STREAM_CLIENT_ASYNC_CONNECT);        }        // If failed attempt to emit onError callback.        if (!$this->_socket || !\is_resource($this->_socket)) {            $this->emitError(\WORKERMAN_CONNECT_FAIL, $errstr);            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }            return;        }        // Add socket to global event loop waiting connection is successfully established or faild.        Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'checkConnection'));        // For windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_EXCEPT, array($this, 'checkConnection'));        }    }    /**     * Reconnect.     *     * @param int $after     * @return void     */    public function reconnect($after = 0)    {        $this->_status                   = self::STATUS_INITIAL;        static::$connections[$this->_id] = $this;        if ($this->_reconnectTimer) {            Timer::del($this->_reconnectTimer);        }        if ($after > 0) {            $this->_reconnectTimer = Timer::add($after, array($this, 'connect'), null, false);            return;        }        $this->connect();    }    /**     * CancelReconnect.     */    public function cancelReconnect()    {        if ($this->_reconnectTimer) {            Timer::del($this->_reconnectTimer);        }    }    /**     * Get remote address.     *     * @return string     */    public function getRemoteHost()    {        return $this->_remoteHost;    }    /**     * Get remote URI.     *     * @return string     */    public function getRemoteURI()    {        return $this->_remoteURI;    }    /**     * Try to emit onError callback.     *     * @param int    $code     * @param string $msg     * @return void     */    protected function emitError($code, $msg)    {        $this->_status = self::STATUS_CLOSING;        if ($this->onError) {            try {                \call_user_func($this->onError, $this, $code, $msg);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }    /**     * Check connection is successfully established or faild.     *     * @param resource $socket     * @return void     */    public function checkConnection()    {        // Remove EV_EXPECT for windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->del($this->_socket, EventInterface::EV_EXCEPT);        }        // Remove write listener.        Worker::$globalEvent->del($this->_socket, EventInterface::EV_WRITE);        if ($this->_status !== self::STATUS_CONNECTING) {            return;        }        // Check socket state.        if ($address = \stream_socket_get_name($this->_socket, true)) {            // Nonblocking.            \stream_set_blocking($this->_socket, false);            // Compatible with hhvm            if (\function_exists('stream_set_read_buffer')) {                \stream_set_read_buffer($this->_socket, 0);            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && $this->transport === 'tcp') {                $raw_socket = \socket_import_stream($this->_socket);                \socket_set_option($raw_socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($raw_socket, \SOL_TCP, \TCP_NODELAY, 1);            }            // SSL handshake.            if ($this->transport === 'ssl') {                $this->_sslHandshakeCompleted = $this->doSslHandshake($this->_socket);                if ($this->_sslHandshakeCompleted === false) {                    return;                }            } else {                // There are some data waiting to send.                if ($this->_sendBuffer) {                    Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'baseWrite'));                }            }            // Register a listener waiting read event.            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));            $this->_status                = self::STATUS_ESTABLISHED;            $this->_remoteAddress         = $address;            // Try to emit onConnect callback.            if ($this->onConnect) {                try {                    \call_user_func($this->onConnect, $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }            // Try to emit protocol::onConnect            if ($this->protocol && \method_exists($this->protocol, 'onConnect')) {                try {                    \call_user_func(array($this->protocol, 'onConnect'), $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }        } else {            // Connection failed.            $this->emitError(\WORKERMAN_CONNECT_FAIL, 'connect ' . $this->_remoteAddress . ' fail after ' . round(\microtime(true) - $this->_connectStartTime, 4) . ' seconds');            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }        }    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
368,walkor_Workerman_Worker_7760, Write statistics data to disk.\n\n @return void\n,Sačuvaj statističke podatke na disk.,"    protected static function writeConnectionsStatisticsToStatusFile()    {        // For master process.        if (static::$_masterPid === \posix_getpid()) {            \file_put_contents(static::$_statisticsFile, ""--------------------------------------------------------------------- WORKERMAN CONNECTION STATUS --------------------------------------------------------------------------------\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile, ""PID      Worker          CID       Trans   Protocol        ipv4   ipv6   Recv-Q       Send-Q       Bytes-R      Bytes-W       Status         Local Address          Foreign Address\n"", \FILE_APPEND);            \chmod(static::$_statisticsFile, 0722);            foreach (static::getAllWorkerPids() as $worker_pid) {                \posix_kill($worker_pid, \SIGIO);            }            return;        }        // For child processes.        $bytes_format = function($bytes)        {            if($bytes > 1024*1024*1024*1024) {                return round($bytes/(1024*1024*1024*1024), 1).""TB"";            }            if($bytes > 1024*1024*1024) {                return round($bytes/(1024*1024*1024), 1).""GB"";            }            if($bytes > 1024*1024) {                return round($bytes/(1024*1024), 1).""MB"";            }            if($bytes > 1024) {                return round($bytes/(1024), 1).""KB"";            }            return $bytes.""B"";        };        $pid = \posix_getpid();        $str = '';        \reset(static::$_workers);        $current_worker = current(static::$_workers);        $default_worker_name = $current_worker->name;        /** @var \Workerman\Worker $worker */        foreach(TcpConnection::$connections as $connection) {            /** @var \Workerman\Connection\TcpConnection $connection */            $transport      = $connection->transport;            $ipv4           = $connection->isIpV4() ? ' 1' : ' 0';            $ipv6           = $connection->isIpV6() ? ' 1' : ' 0';            $recv_q         = $bytes_format($connection->getRecvBufferQueueSize());            $send_q         = $bytes_format($connection->getSendBufferQueueSize());            $local_address  = \trim($connection->getLocalAddress());            $remote_address = \trim($connection->getRemoteAddress());            $state          = $connection->getStatus(false);            $bytes_read     = $bytes_format($connection->bytesRead);            $bytes_written  = $bytes_format($connection->bytesWritten);            $id             = $connection->id;            $protocol       = $connection->protocol ? $connection->protocol : $connection->transport;            $pos            = \strrpos($protocol, '\\');            if ($pos) {                $protocol = \substr($protocol, $pos+1);            }            if (\strlen($protocol) > 15) {                $protocol = \substr($protocol, 0, 13) . '..';            }            $worker_name = isset($connection->worker) ? $connection->worker->name : $default_worker_name;            if (\strlen($worker_name) > 14) {                $worker_name = \substr($worker_name, 0, 12) . '..';            }            $str .= \str_pad($pid, 9) . \str_pad($worker_name, 16) .  \str_pad($id, 10) . \str_pad($transport, 8)                . \str_pad($protocol, 16) . \str_pad($ipv4, 7) . \str_pad($ipv6, 7) . \str_pad($recv_q, 13)                . \str_pad($send_q, 13) . \str_pad($bytes_read, 13) . \str_pad($bytes_written, 13) . ' '                . \str_pad($state, 14) . ' ' . \str_pad($local_address, 22) . ' ' . \str_pad($remote_address, 22) .""\n"";        }        if ($str) {            \file_put_contents(static::$_statisticsFile, $str, \FILE_APPEND);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0
369,matomo-org_matomo_BaseFactory_116, Should return a message to use in an Exception when an invalid class ID is supplied to\\n {@link factory()}.\\n,Vraća naziv izuzetka za prosleđeni id.,"    protected static function getInvalidClassIdExceptionMessage($id)    {        return ""Invalid class ID '$id' for "" . get_called_class() . ""::factory()."";    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
370,walkor_Workerman_AsyncTcpConnection_8699, Check connection is successfully established or faild.\n\n @param resource $socket\n @return void\n,Proveri da li je konekcija uspostavljena ili ne.,"    public function checkConnection()    {        // Remove EV_EXPECT for windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->del($this->_socket, EventInterface::EV_EXCEPT);        }        // Remove write listener.        Worker::$globalEvent->del($this->_socket, EventInterface::EV_WRITE);        if ($this->_status !== self::STATUS_CONNECTING) {            return;        }        // Check socket state.        if ($address = \stream_socket_get_name($this->_socket, true)) {            // Nonblocking.            \stream_set_blocking($this->_socket, false);            // Compatible with hhvm            if (\function_exists('stream_set_read_buffer')) {                \stream_set_read_buffer($this->_socket, 0);            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && $this->transport === 'tcp') {                $raw_socket = \socket_import_stream($this->_socket);                \socket_set_option($raw_socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($raw_socket, \SOL_TCP, \TCP_NODELAY, 1);            }            // SSL handshake.            if ($this->transport === 'ssl') {                $this->_sslHandshakeCompleted = $this->doSslHandshake($this->_socket);                if ($this->_sslHandshakeCompleted === false) {                    return;                }            } else {                // There are some data waiting to send.                if ($this->_sendBuffer) {                    Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'baseWrite'));                }            }            // Register a listener waiting read event.            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));            $this->_status                = self::STATUS_ESTABLISHED;            $this->_remoteAddress         = $address;            // Try to emit onConnect callback.            if ($this->onConnect) {                try {                    \call_user_func($this->onConnect, $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }            // Try to emit protocol::onConnect            if ($this->protocol && \method_exists($this->protocol, 'onConnect')) {                try {                    \call_user_func(array($this->protocol, 'onConnect'), $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }        } else {            // Connection failed.            $this->emitError(\WORKERMAN_CONNECT_FAIL, 'connect ' . $this->_remoteAddress . ' fail after ' . round(\microtime(true) - $this->_connectStartTime, 4) . ' seconds');            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
371,PrestaShop_PrestaShop_AddressFormat_798, Set the layout key with the liable value\n example : (firstname) => 'Presta' will result (Presta)\n         : (firstname-lastname) => 'Presta' and 'Shop' result '(Presta-Shop)'.\n,Postavi izgled ključa sa pouzdanom vrednošću.,"    protected static function _setOriginalDisplayFormat(&$formattedValueList, $currentLine, $currentKeyList)    {        if ($currentKeyList && is_array($currentKeyList)) {            if ($originalFormattedPatternList = explode(' ', $currentLine)) {                // Foreach the available pattern                foreach ($originalFormattedPatternList as $patternNum => $pattern) {                    // Var allows to modify the good formatted key value when multiple key exist into the same pattern                    $mainFormattedKey = '';                    // Multiple key can be found in the same pattern                    foreach ($currentKeyList as $key) {                        // Check if we need to use an older modified pattern if a key has already be matched before                        $replacedValue = empty($mainFormattedKey) ? $pattern : $formattedValueList[$mainFormattedKey];                        $chars = $start = $end = str_replace($key, '', $replacedValue);                        if (preg_match(self::_CLEANING_REGEX_, $chars)) {                            if (Tools::substr($replacedValue, 0, Tools::strlen($chars)) == $chars) {                                $end = '';                            } else {                                $start = '';                            }                            if ($chars) {                                $replacedValue = str_replace($chars, '', $replacedValue);                            }                        }                        if ($formattedValue = preg_replace('/^' . $key . '$/', $formattedValueList[$key], $replacedValue, -1, $count)) {                            if ($count) {                                // Allow to check multiple key in the same pattern,                                if (empty($mainFormattedKey)) {                                    $mainFormattedKey = $key;                                }                                // Set the pattern value to an empty string if an older key has already been matched before                                if ($mainFormattedKey != $key) {                                    $formattedValueList[$key] = '';                                }                                // Store the new pattern value                                $formattedValueList[$mainFormattedKey] = $start . $formattedValue . $end;                                unset($originalFormattedPatternList[$patternNum]);                            }                        }                    }                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
0,BookStackApp_BookStack_2014_10_12_100000_create_password_resets_table_764, Reverse the migrations.\n\n @return void\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('password_resets');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
1,BookStackApp_BookStack_2015_07_12_114933_create_books_table_765, Run the migrations.\n\n @return void\n, Pokrenuti migraciju.,"    public function up()    {        Schema::create('books', function (Blueprint $table) {            $table->increments('id');            $table->string('name');            $table->string('slug')->indexed();            $table->text('description');            $table->nullableTimestamps();        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
2,BookStackApp_BookStack_2015_08_08_200447_add_users_to_entities_773, Run the migrations.\n\n @return void\n, Pokrenuti migraciju.,"    public function up()    {        Schema::table('pages', function (Blueprint $table) {            $table->integer('created_by');            $table->integer('updated_by');        });        Schema::table('chapters', function (Blueprint $table) {            $table->integer('created_by');            $table->integer('updated_by');        });        Schema::table('images', function (Blueprint $table) {            $table->integer('created_by');            $table->integer('updated_by');        });        Schema::table('books', function (Blueprint $table) {            $table->integer('created_by');            $table->integer('updated_by');        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
3,BookStackApp_BookStack_2015_08_16_142133_create_activities_table_778, Reverse the migrations.\n\n @return void\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('activities');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
4,BookStackApp_BookStack_ActivityService_743, Flashes a notification message to the session if an appropriate message is available.\n, Prikazuje notifikaciju za sesiju ako je odgovaraju?a poruka dostupna. ,"    protected function setNotification(string $type)    {        $notificationTextKey = 'activities.' . $type . '_notification';        if (trans()->has($notificationTextKey)) {            $message = trans($notificationTextKey);            session()->flash('success', $message);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
5,BookStackApp_BookStack_Activity_734, Get the entity for this activity.\n, Vra?a entitet za ovu aktivnost. ,    public function entity(): MorphTo    {        if ($this->entity_type === '') {            $this->entity_type = null;        }        return $this->morphTo('entity');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
6,BookStackApp_BookStack_BrowserKitTest_784, Check if the page contains the given element.\n @param  string  $selector\n, Provjerava da li stranica sadrži dati elemenat.,"    protected function pageHasElement($selector)    {        $elements = $this->crawler->filter($selector);        $this->assertTrue(count($elements) > 0, ""The page does not contain an element matching "" . $selector);        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0
7,BookStackApp_BookStack_CommentRepo_751, Get a comment by ID.\n, Vra?a komentar po ID. ,    public function getById(int $id): Comment    {        return $this->comment->newQuery()->findOrFail($id);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
8,BookStackApp_BookStack_CommentRepo_755, Convert the given comment markdown text to HTML.\n, Konvertuje dati komentar Convert the given comment markdown text to HTML.,"    public function commentToHtml(string $commentText): string    {        $converter = new CommonMarkConverter([            'html_input' => 'strip',            'max_nesting_level' => 10,            'allow_unsafe_links' => false,        ]);        return $converter->convertToHtml($commentText);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
9,BookStackApp_BookStack_CommentRepo_756, Get the next local ID relative to the linked entity.\n, Vra?a slede?i lokalni ID relativan povezanom entitetu. Get the next local ID relative to the linked entity.,"    protected function getNextLocalId(Entity $entity): int    {        $comments = $entity->comments(false)->orderBy('local_id', 'desc')->first();        return ($comments->local_id ?? 0) + 1;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
10,CachetHQ_Cachet_2015_01_05_201324_CreateComponentGroupsTable_1177, Reverse the migrations.\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('component_groups');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
11,CachetHQ_Cachet_2015_01_05_202446_CreateIncidentTemplatesTable_1180, Run the migrations.\n, Pokrenuti migraciju.,"    public function up()    {        Schema::create('incident_templates', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->string('name');            $table->string('slug');            $table->longText('template');            $table->timestamps();            $table->softDeletes();        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
12,CachetHQ_Cachet_2015_01_05_202446_CreateIncidentTemplatesTable_1181, Reverse the migrations.\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('incident_templates');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
13,CachetHQ_Cachet_2015_01_05_203014_CreateSettingsTable_1188, Run the migrations.\n, Pokrenuti migraciju.,"    public function up()    {        Schema::create('settings', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->string('name');            $table->longText('value');            $table->timestamps();        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
14,CachetHQ_Cachet_2015_01_05_203014_CreateSettingsTable_1189, Reverse the migrations.\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('settings');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
15,CachetHQ_Cachet_2015_01_05_203235_CreateSubscribersTable_1191, Reverse the migrations.\n, Preokrenuti migraciju.,    public function down()    {        Schema::drop('subscribers');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
16,CachetHQ_Cachet_2015_01_05_203341_CreateUsersTable_1192, Run the migrations.\n, Pokrenuti migraciju.,"    public function up()    {        Schema::create('users', function (Blueprint $table) {            $table->engine = 'InnoDB';            $table->increments('id');            $table->string('username');            $table->string('password');            $table->rememberToken();            $table->string('email');            $table->string('api_key');            $table->boolean('active')->default(1);            $table->tinyInteger('level')->default(2);            $table->timestamps();            $table->index('remember_token');            $table->index('active');            $table->unique('username');            $table->unique('api_key');            $table->unique('email');        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
17,CachetHQ_Cachet_AbstractApiTestCase_1212, Become a user.\n\n @return $this\n, Postani korisnik.,"    protected function beUser()    {        $this->user = factory(User::class)->create([            'username' => 'cachet-test',        ]);        $this->be($this->user);        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
18,CachetHQ_Cachet_AbstractTestCase_1195, Set up the needed configuration to be able to run the tests.\n\n @return \\CachetHQ\\Tests\\Cachet\\AbstractTestCase\n, Podešavanje potrebne konfiguracije za pokretanje testova. ,"    protected function setupConfig()    {        $env = $this->app->environment();        $repo = $this->app->make(Repository::class);        $cache = $this->app->make(Cache::class);        $loaded = $cache->load($env);        if ($loaded === false) {            $loaded = $repo->all();            $cache->store($env, $loaded);        }        $settings = array_merge($this->app->config->get('setting'), $loaded);        $this->app->config->set('setting', $settings);        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
19,CachetHQ_Cachet_AnalysisTest_1196, This is the analysis test class.\n\n @author Graham Campbell <graham@alt-three.com>\n @author James Brooks <james@alt-three.com>\n, Ovo je klasa za analizu testa. ,"class AnalysisTest extends TestCase{    use AnalysisTrait;    /**     * Get the code paths to analyze.     *     * @return string[]     */    protected function getPaths()    {        return [            realpath(__DIR__.'/../app'),            realpath(__DIR__.'/../bootstrap'),            realpath(__DIR__.'/../config'),            realpath(__DIR__.'/../database'),            realpath(__DIR__),        ];    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
20,CachetHQ_Cachet_ComponentGroupTest_1214, Set up the needed data for the tests.\n\n @return $this\n, Podešavanje potrebnih podataka za testove. ,"    protected function createComponentGroups()    {        $this->createComponentGroup(self::COMPONENT_GROUP_1_NAME, ComponentGroup::VISIBLE_GUEST)            ->createComponentGroup(self::COMPONENT_GROUP_2_NAME, ComponentGroup::VISIBLE_AUTHENTICATED);        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
21,CachetHQ_Cachet_ComponentGroupTest_1215, Create a component group.\n\n Also attaches a creator if any given as a parameter or exists in the test class.\n\n @param string $name\n @param string $visible\n\n @return $this\n, Kreiranje komponentne grupe. Takođe prilaže kreatora ako je naveden kao parametar ili postoji u test klasi.,"    protected function createComponentGroup($name, $visible)    {        factory(ComponentGroup::class)            ->create(['name' => $name, 'visible' => $visible]);        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
22,CachetHQ_Cachet_CreateComponentGroupCommand_1167, This is the create component group command.\n\n @author James Brooks <james@alt-three.com>\n, Ovo je komanda za kreiranje komponente grupe. ,"final class CreateComponentGroupCommand{    /**     * The component group name.     *     * @var string     */    public $name;    /**     * The component group description.     *     * @var int     */    public $order;    /**     * Is the component group collapsed?     *     * @var int     */    public $collapsed;    /**     * Is the component visible to public?     *     * @var int     */    public $visible;    /**     * The validation rules.     *     * @var string[]     */    public $rules = [        'name'      => 'required|string',        'order'     => 'required|int',        'collapsed' => 'required|int|between:0,4',        'visible'   => 'required|bool',    ];    /**     * Create a add component group command instance.     *     * @param string $name     * @param int    $order     * @param int    $collapsed     * @param int    $visible     *     * @return void     */    public function __construct($name, $order, $collapsed, $visible)    {        $this->name = $name;        $this->order = (int) $order;        $this->collapsed = $collapsed;        $this->visible = (int) $visible;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
23,CachetHQ_Cachet_CreateComponentGroupCommand_1168, Create a add component group command instance.\n\n @param string $name\n @param int    $order\n @param int    $collapsed\n @param int    $visible\n\n @return void\n, Kreira instancu komande za dodavanje komponente grupe.,"    public function __construct($name, $order, $collapsed, $visible)    {        $this->name = $name;        $this->order = (int) $order;        $this->collapsed = $collapsed;        $this->visible = (int) $visible;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
24,CachetHQ_Cachet_GeneralTest_1217, This is the general test class.\n\n @author James Brooks <james@alt-three.com>\n @author Graham Campbell <graham@alt-three.com>\n, Ovo je uopštena testna klasa. ,"class GeneralTest extends AbstractApiTestCase{    public function test_can_ping()    {        $response = $this->json('GET', '/api/v1/ping');        $response->assertStatus(200);        $response->assertHeader('Content-Type', 'application/json');        $response->assertJsonFragment(['data' => 'Pong!']);    }    public function test_see_error_page_for_unknown_endpoint()    {        $response = $this->json('GET', '/api/v1/not-found');        $response->assertStatus(404);        $response->assertHeader('Content-Type', 'application/json');    }    public function test_non_acceptable_content_type()    {        $response = $this->json('GET', '/api/v1/ping', [], ['HTTP_Accept' => 'text/html']);        $response->assertStatus(406);    }    public function test_can_get_system_status()    {        $response = $this->json('GET', '/api/v1/status');        $response->assertStatus(200)                 ->assertHeader('Cache-Control')                 ->assertJsonFragment([                     'data' => [                         'status'  => 'success',                         'message' => 'System operational',                     ],                 ]);    }    public function test_can_get_system_status_not_success()    {        factory(Component::class)->create([            'status' => 3,        ]);        $response = $this->json('GET', '/api/v1/status');        $response->assertStatus(200)                 ->assertHeader('Cache-Control')                 ->assertJsonFragment([                     'data' => [                         'status'  => 'info',                         'message' => 'The system is experiencing issues',                     ],                 ]);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
25,CachetHQ_Cachet_RemoveComponentGroupCommand_1169, Create a new remove component group command instance.\n\n @param \\CachetHQ\\Cachet\\Models\\ComponentGroup $group\n\n @return void\n, Kreiranje nove instance komande za uklanjanje komponente grupe.,    public function __construct(ComponentGroup $group)    {        $this->group = $group;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
26,CachetHQ_Cachet_RemoveIncidentCommand_1173, Create a new remove incident command instance.\n\n @param \\CachetHQ\\Cachet\\Models\\Incident $incident\n\n @return void\n, Kreiranje nove instance komande za uklanjanje incidenta.,    public function __construct(Incident $incident)    {        $this->incident = $incident;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
27,CachetHQ_Cachet_TestListener_1200, This is the test listener class.\n\n @author Connor S. Parks <connor@connorvg.tv>\n, Ovo je klasa za testni osluškiva?.,"class TestListener implements PHPUnitTestListener{    /**     * An error occurred.     */    public function addError(Test $test, \Throwable $t, float $time): void    {        //    }    /**     * A warning occurred.     */    public function addWarning(Test $test, Warning $e, float $time): void    {        //    }    /**     * A failure occurred.     */    public function addFailure(Test $test, AssertionFailedError $e, float $time): void    {        //    }    /**     * Incomplete test.     */    public function addIncompleteTest(Test $test, \Throwable $t, float $time): void    {        //    }    /**     * Risky test.     */    public function addRiskyTest(Test $test, \Throwable $t, float $time): void    {        //    }    /**     * Skipped test.     */    public function addSkippedTest(Test $test, \Throwable $t, float $time): void    {        //    }    /**     * A test suite started.     */    public function startTestSuite(TestSuite $suite): void    {        //    }    /**     * A test suite ended.     */    public function endTestSuite(TestSuite $suite): void    {        if ($suite->getName() !== 'Cachet Test Suite') {            return;        }        foreach (glob(__DIR__.'/../bootstrap/cache{,t}/*.php', GLOB_BRACE) as $file) {            unlink($file);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
28,CachetHQ_Cachet_UpdateComponentGroupCommand_1170, This is the update component group command.\n\n @author James Brooks <james@alt-three.com>\n, Ovo je komanda za ažuriranje komponente grupe. ,"final class UpdateComponentGroupCommand{    /**     * The component group.     *     * @var \CachetHQ\Cachet\Models\ComponentGroup     */    public $group;    /**     * The component group name.     *     * @var string     */    public $name;    /**     * The component group description.     *     * @var int     */    public $order;    /**     * Is the component group collapsed?     *     * @var int     */    public $collapsed;    /**     * Is the component visible to public?     *     * @var int     */    public $visible;    /**     * The validation rules.     *     * @var string[]     */    public $rules = [        'name'      => 'nullable|string',        'order'     => 'nullable|int',        'collapsed' => 'nullable|int|between:0,4',        'visible'   => 'nullable|bool',    ];    /**     * Create a add component group command instance.     *     * @param \CachetHQ\Cachet\Models\ComponentGroup $group     * @param string                                 $name     * @param int                                    $order     * @param int                                    $collapsed     * @param int                                    $visible     *     * @return void     */    public function __construct(ComponentGroup $group, $name, $order, $collapsed, $visible)    {        $this->group = $group;        $this->name = $name;        $this->order = (int) $order;        $this->collapsed = $collapsed;        $this->visible = (int) $visible;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
29,DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_6668, Execute and make receiver to enable displaying messages date.\n, Izvršava i pravi prijemnika da se omogu?i prikaz datuma poruka.,"    public function execute()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->enableDate();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
30,DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_7042, Undo the command and make receiver to disable displaying messages date.\n, Poništite komandu i podesite prijemnik da onemoguc?i prikazivanje datuma poruka.,"    public function undo()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->disableDate();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
31,DesignPatternsPHP_DesignPatternsPHP_EBookAdapter_6415," This is the adapter here. Notice it implements Book,\n therefore you don't have to change the code of the client which is using a Book\n","Ovo ovde je adapter. Primetiti da impementira Book, prema tome ti ne trebaš da menjaš kod klijenta koji koristi Book. ","class EBookAdapter implements Book{    public function __construct(protected EBook $eBook)    {    }    /**     * This class makes the proper translation from one interface to another.     */    public function open()    {        $this->eBook->unlock();    }    public function turnPage()    {        $this->eBook->pressNext();    }    /**     * notice the adapted behavior here: EBook::getPage() will return two integers, but Book     * supports only a current page getter, so we adapt the behavior here     */    public function getPage(): int    {        return $this->eBook->getPage()[0];    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
32,DesignPatternsPHP_DesignPatternsPHP_Handler_7422, This approach by using a template method pattern ensures you that\n each subclass will not forget to call the successor\n, Ovaj pristup koriš?enjem šablona metode šablona omogu?ava da svaka potklasa neće zaboraviti da pozove svog prethodnika. ,    final public function handle(RequestInterface $request): ?string    {        $processed = $this->processing($request);        if ($processed === null && $this->successor !== null) {            // the request has not been processed by this handler => see the next            $processed = $this->successor->handle($request);        }        return $processed;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
33,DesignPatternsPHP_DesignPatternsPHP_HelloCommand_6400," execute and output ""Hello World"".\n"," izvršava i ispisuje ""Hello World"".","    public function execute()    {        // sometimes, there is no receiver and this is the command which does all the work        $this->output->write('Hello World');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
34,DesignPatternsPHP_DesignPatternsPHP_HelloCommand_6671," This concrete command calls ""print"" on the Receiver, but an external\n invoker just knows that it can call ""execute""\n"," Ova konkretna komanda poziva ""print"" na prijemniku, ali eksterni invoker zna da može da pozove ""execute""","class HelloCommand implements Command{    /**     * Each concrete command is built with different receivers.     * There can be one, many or completely no receivers, but there can be other commands in the parameters     */    public function __construct(private Receiver $output)    {    }    /**     * execute and output ""Hello World"".     */    public function execute()    {        // sometimes, there is no receiver and this is the command which does all the work        $this->output->write('Hello World');    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
35,DesignPatternsPHP_DesignPatternsPHP_Invoker_6401, Invoker is using the command given to it.\n Example : an Application in SF2.\n, Priziva? koristi komandu koja mu je data. ,"class Invoker{    private Command $command;    /**     * in the invoker we find this kind of method for subscribing the command     * There can be also a stack, a list, a fixed set ...     */    public function setCommand(Command $cmd)    {        $this->command = $cmd;    }    /**     * executes the command; the invoker is the same whatever is the command     */    public function run()    {        $this->command->execute();    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
36,DesignPatternsPHP_DesignPatternsPHP_Invoker_8351, executes the command; the invoker is the same whatever is the command\n, izvršava komandu; priziva? je isti koja god da je komanda u pitanju,    public function run()    {        $this->command->execute();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
37,DesignPatternsPHP_DesignPatternsPHP_Kindle_6691," this is the adapted class. In production code, this could be a class from another package, some vendor code.\n Notice that it uses another naming scheme and the implementation does something similar but in another way\n"," ovo je adaptirana klasa. U produkciji, ovo bi mogla da bude klasa iz drugog  paketa, neki kod proizvo?a?a. Primetiti da se koristi drugačija šema imenovanja i da implementacija radi nešto slično ali na drugačiji način. ","class Kindle implements EBook{    private int $page = 1;    private int $totalPages = 100;    public function pressNext()    {        $this->page++;    }    public function unlock()    {    }    /**     * returns current page and total number of pages, like [10, 100] is page 10 of 100     *     * @return int[]     */    public function getPage(): array    {        return [$this->page, $this->totalPages];    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
38,DesignPatternsPHP_DesignPatternsPHP_PostStatus_6412," Like PostId, this is a value object which holds the value of the current status of a Post. It can be constructed\n either from a string or int and is able to validate itself. An instance can then be converted back to int or string.\n"," Kao i PostId, ovo je vrednosni objekat koji ?uva vrednost trenutnog statusa Post. Može se konstruisati ili od stringa ili int i u mogućnosti je da se samovalidira. Instanca će biti konvertovana nazad u int ili string. ","class PostStatus{    const STATE_DRAFT_ID = 1;    const STATE_PUBLISHED_ID = 2;    const STATE_DRAFT = 'draft';    const STATE_PUBLISHED = 'published';    private static array $validStates = [        self::STATE_DRAFT_ID => self::STATE_DRAFT,        self::STATE_PUBLISHED_ID => self::STATE_PUBLISHED,    ];    public static function fromInt(int $statusId)    {        self::ensureIsValidId($statusId);        return new self($statusId, self::$validStates[$statusId]);    }    public static function fromString(string $status)    {        self::ensureIsValidName($status);        $state = array_search($status, self::$validStates);        if ($state === false) {            throw new InvalidArgumentException('Invalid state given!');        }        return new self($state, $status);    }    private function __construct(private int $id, private string $name)    {    }    public function toInt(): int    {        return $this->id;    }    /**     * there is a reason that I avoid using __toString() as it operates outside of the stack in PHP     * and is therefor not able to operate well with exceptions     */    public function toString(): string    {        return $this->name;    }    private static function ensureIsValidId(int $status)    {        if (!in_array($status, array_keys(self::$validStates), true)) {            throw new InvalidArgumentException('Invalid status id given');        }    }    private static function ensureIsValidName(string $status)    {        if (!in_array($status, self::$validStates, true)) {            throw new InvalidArgumentException('Invalid status name given');        }    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
39,DesignPatternsPHP_DesignPatternsPHP_Receiver_7436, Disable receiver to display message date\n, Onemogu?iti prijemnik da prikazuje poruke o datumu,    public function disableDate()    {        $this->enableDate = false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
40,FriendsOfPHP_PHP-CS-Fixer_AbstractLinesBeforeNamespaceFixer_6880, Make sure # of line breaks prefixing namespace is within given range.\n\n @param int $expectedMin min. # of line breaks\n @param int $expectedMax max. # of line breaks\n, Osigurati da je broj preloma prefiksa imena prostora unutar zadatog opsega. ,"    protected function fixLinesBeforeNamespace(Tokens $tokens, int $index, int $expectedMin, int $expectedMax): void    {        // Let's determine the total numbers of new lines before the namespace        // and the opening token        $openingTokenIndex = null;        $precedingNewlines = 0;        $newlineInOpening = false;        $openingToken = null;        for ($i = 1; $i <= 2; ++$i) {            if (isset($tokens[$index - $i])) {                $token = $tokens[$index - $i];                if ($token->isGivenKind(T_OPEN_TAG)) {                    $openingToken = $token;                    $openingTokenIndex = $index - $i;                    $newlineInOpening = false !== strpos($token->getContent(), ""\n"");                    if ($newlineInOpening) {                        ++$precedingNewlines;                    }                    break;                }                if (false === $token->isGivenKind(T_WHITESPACE)) {                    break;                }                $precedingNewlines += substr_count($token->getContent(), ""\n"");            }        }        if ($precedingNewlines >= $expectedMin && $precedingNewlines <= $expectedMax) {            return;        }        $previousIndex = $index - 1;        $previous = $tokens[$previousIndex];        if (0 === $expectedMax) {            // Remove all the previous new lines            if ($previous->isWhitespace()) {                $tokens->clearAt($previousIndex);            }            // Remove new lines in opening token            if ($newlineInOpening) {                $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, rtrim($openingToken->getContent()).' ']);            }            return;        }        $lineEnding = $this->whitespacesConfig->getLineEnding();        $newlinesForWhitespaceToken = $expectedMax;        if (null !== $openingToken) {            // Use the configured line ending for the PHP opening tag            $content = rtrim($openingToken->getContent());            $newContent = $content.$lineEnding;            $tokens[$openingTokenIndex] = new Token([T_OPEN_TAG, $newContent]);            --$newlinesForWhitespaceToken;        }        if (0 === $newlinesForWhitespaceToken) {            // We have all the needed new lines in the opening tag            if ($previous->isWhitespace()) {                // Let's remove the previous token containing extra new lines                $tokens->clearAt($previousIndex);            }            return;        }        if ($previous->isWhitespace()) {            // Fix the previous whitespace token            $tokens[$previousIndex] = new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken).substr($previous->getContent(), strrpos($previous->getContent(), ""\n"") + 1)]);        } else {            // Add a new whitespace token            $tokens->insertAt($index, new Token([T_WHITESPACE, str_repeat($lineEnding, $newlinesForWhitespaceToken)]));        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
41,FriendsOfPHP_PHP-CS-Fixer_AbstractNoUselessElseFixer_6885," For internal use only, as it is not perfect.\n\n Returns if the token at given index is part of a if/elseif/else statement\n without {}. Assumes not passing the last `;`/close tag of the statement, not\n out of range index, etc.\n\n @param int $index Index of the token to check\n"," Samo za unutrašnju upotrebu, jer nije savršena. Vraća da li je token na datom indeksu dio if/elseif/else naredbe bez {}. Pretpostavlja se da se ne prosleđuje zadnja `;`/tag za zatvaranje naredbe, ni indeks van opsega, itd. ","    private function isInConditionWithoutBraces(Tokens $tokens, int $index, int $lowerLimitIndex): bool    {        do {            if ($tokens[$index]->isComment() || $tokens[$index]->isWhitespace()) {                $index = $tokens->getPrevMeaningfulToken($index);            }            $token = $tokens[$index];            if ($token->isGivenKind([T_IF, T_ELSEIF, T_ELSE])) {                return true;            }            if ($token->equals(';')) {                return false;            }            if ($token->equals('{')) {                $index = $tokens->getPrevMeaningfulToken($index);                // OK if belongs to: for, do, while, foreach                // Not OK if belongs to: if, else, elseif                if ($tokens[$index]->isGivenKind(T_DO)) {                    --$index;                    continue;                }                if (!$tokens[$index]->equals(')')) {                    return false; // like `else {`                }                $index = $tokens->findBlockStart(                    Tokens::BLOCK_TYPE_PARENTHESIS_BRACE,                    $index                );                $index = $tokens->getPrevMeaningfulToken($index);                if ($tokens[$index]->isGivenKind([T_IF, T_ELSEIF])) {                    return false;                }            } elseif ($token->equals(')')) {                $type = Tokens::detectBlockType($token);                $index = $tokens->findBlockStart(                    $type['type'],                    $index                );                $index = $tokens->getPrevMeaningfulToken($index);            } else {                --$index;            }        } while ($index > $lowerLimitIndex);        return false;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
42,FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_6619, This abstract fixer provides a base for fixers to fix types in PHPDoc.\n\n @author Graham Campbell <graham@alt-three.com>\n\n @internal\n, Ovaj apstraktni popravlja? pruža osnovu popravlja?ima za popravljanje tipovi u PHPdoc.,"abstract class AbstractPhpdocTypesFixer extends AbstractFixer{    /**     * The annotation tags search inside.     *     * @var string[]     */    protected $tags;    /**     * {@inheritdoc}     */    public function __construct()    {        parent::__construct();        $this->tags = Annotation::getTagsWithTypes();    }    /**     * {@inheritdoc}     */    public function isCandidate(Tokens $tokens): bool    {        return $tokens->isTokenKindFound(T_DOC_COMMENT);    }    /**     * {@inheritdoc}     */    protected function applyFix(\SplFileInfo $file, Tokens $tokens): void    {        foreach ($tokens as $index => $token) {            if (!$token->isGivenKind(T_DOC_COMMENT)) {                continue;            }            $doc = new DocBlock($token->getContent());            $annotations = $doc->getAnnotationsOfType($this->tags);            if (empty($annotations)) {                continue;            }            foreach ($annotations as $annotation) {                $this->fixTypes($annotation);            }            $tokens[$index] = new Token([T_DOC_COMMENT, $doc->getContent()]);        }    }    /**     * Actually normalize the given type.     */    abstract protected function normalize(string $type): string;    /**     * Fix the types at the given line.     *     * We must be super careful not to modify parts of words.     *     * This will be nicely handled behind the scenes for us by the annotation class.     */    private function fixTypes(Annotation $annotation): void    {        $types = $annotation->getTypes();        $new = $this->normalizeTypes($types);        if ($types !== $new) {            $annotation->setTypes($new);        }    }    /**     * @param string[] $types     *     * @return string[]     */    private function normalizeTypes(array $types): array    {        foreach ($types as $index => $type) {            $types[$index] = $this->normalizeType($type);        }        return $types;    }    /**     * Prepare the type and normalize it.     */    private function normalizeType(string $type): string    {        if ('[]' === substr($type, -2)) {            return $this->normalizeType(substr($type, 0, -2)).'[]';        }        return $this->normalize($type);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
43,FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_8572, Fix the types at the given line.\n\n We must be super careful not to modify parts of words.\n\n This will be nicely handled behind the scenes for us by the annotation class.\n, Popravlja tipove na datoj liniji. Moramo biti ekstra oprezni da ne izmenimo delove reči. Ovim će se fino rukovati u pozadini za nas od strane anotacione klase. ,    private function fixTypes(Annotation $annotation): void    {        $types = $annotation->getTypes();        $new = $this->normalizeTypes($types);        if ($types !== $new) {            $annotation->setTypes($new);        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
44,FriendsOfPHP_PHP-CS-Fixer_AbstractPhpdocTypesFixer_8574, Prepare the type and normalize it.\n, Priprema tip i normlizuje ga.,"    private function normalizeType(string $type): string    {        if ('[]' === substr($type, -2)) {            return $this->normalizeType(substr($type, 0, -2)).'[]';        }        return $this->normalize($type);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
45,Intervention_image_AbstractColor_413, Parses given value as color\n\n @param  mixed $value\n @return \\Intervention\\Image\\AbstractColor\n, Parsira datu vrednost kao boju,"    public function parse($value)    {        switch (true) {            case is_string($value):                $this->initFromString($value);                break;            case is_int($value):                $this->initFromInteger($value);                break;            case is_array($value):                $this->initFromArray($value);                break;            case is_object($value):                $this->initFromObject($value);                break;            case is_null($value):                $this->initFromArray([255, 255, 255, 0]);                break;            default:                throw new NotReadableException(                    ""Color format ({$value}) cannot be read.""                );        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
46,Intervention_image_AbstractColor_414, Formats current color instance into given format\\\\n\\\\n @param  string $type\\\\n @return mixed\\\\n, Formatira datu instancu boje u dati format,"    public function format($type)    {        switch (strtolower($type)) {            case 'rgba':                return $this->getRgba();            case 'hex':                return $this->getHex('#');            case 'int':            case 'integer':                return $this->getInt();            case 'array':                return $this->getArray();            case 'obj':            case 'object':                return $this;            default:                throw new NotSupportedException(                    ""Color format ({$type}) is not supported.""                );        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
47,Intervention_image_AbstractColor_415, Reads RGBA values from string into array\n\n @param  string $value\n @return array\n, ?ita RGBA vrednost iz stringa u niz.,"    protected function rgbaFromString($value)    {        $result = false;        // parse color string in hexidecimal format like #cccccc or cccccc or ccc        $hexPattern = '/^#?([a-f0-9]{1,2})([a-f0-9]{1,2})([a-f0-9]{1,2})$/i';        // parse color string in format rgb(140, 140, 140)        $rgbPattern = '/^rgb ?\(([0-9]{1,3}), ?([0-9]{1,3}), ?([0-9]{1,3})\)$/i';        // parse color string in format rgba(255, 0, 0, 0.5)        $rgbaPattern = '/^rgba ?\(([0-9]{1,3}), ?([0-9]{1,3}), ?([0-9]{1,3}), ?([0-9.]{1,4})\)$/i';        if (preg_match($hexPattern, $value, $matches)) {            $result = [];            $result[0] = strlen($matches[1]) == '1' ? hexdec($matches[1].$matches[1]) : hexdec($matches[1]);            $result[1] = strlen($matches[2]) == '1' ? hexdec($matches[2].$matches[2]) : hexdec($matches[2]);            $result[2] = strlen($matches[3]) == '1' ? hexdec($matches[3].$matches[3]) : hexdec($matches[3]);            $result[3] = 1;        } elseif (preg_match($rgbPattern, $value, $matches)) {            $result = [];            $result[0] = ($matches[1] >= 0 && $matches[1] <= 255) ? intval($matches[1]) : 0;            $result[1] = ($matches[2] >= 0 && $matches[2] <= 255) ? intval($matches[2]) : 0;            $result[2] = ($matches[3] >= 0 && $matches[3] <= 255) ? intval($matches[3]) : 0;            $result[3] = 1;        } elseif (preg_match($rgbaPattern, $value, $matches)) {            $result = [];            $result[0] = ($matches[1] >= 0 && $matches[1] <= 255) ? intval($matches[1]) : 0;            $result[1] = ($matches[2] >= 0 && $matches[2] <= 255) ? intval($matches[2]) : 0;            $result[2] = ($matches[3] >= 0 && $matches[3] <= 255) ? intval($matches[3]) : 0;            $result[3] = ($matches[4] >= 0 && $matches[4] <= 1) ? $matches[4] : 0;        } else {            throw new NotReadableException(                ""Unable to read color ({$value}).""            );        }        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
48,Intervention_image_AbstractCommand_537, Creates new argument instance from given argument key\\n\\n @param  int $key\\n @return \\\\Intervention\\\\Image\\\\Commands\\\\Argument\\n, Kreira novu instancu argumenta od datog klju?a,"    public function argument($key)    {        return new Argument($this, $key);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
49,Intervention_image_AbstractCommand_540, Sets output data of current command\n\n @param mixed $value\n, Postavlja izlazne podatke trenutnne komande,    public function setOutput($value)    {        $this->output = $value;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
50,Intervention_image_AbstractDecoder_422, Determines if current source data is GD resource\\\\n\\\\n @return boolean\\\\n, Odlu?uje da li je trenutni izvor podataka GD izvor,    public function isGdResource()    {        if (is_resource($this->data)) {            return (get_resource_type($this->data) == 'gd');        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
51,Intervention_image_AbstractDecoder_423, Determines if current source data is Imagick object\n\n @return boolean\n, Odlu?uje da li je trenutni izvor podataka Imagick objekat,"    public function isImagick()    {        return is_a($this->data, 'Imagick');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
52,Intervention_image_AbstractDecoder_425, Determines if current data is SplFileInfo object\\n\\n @return boolean\\n, Odlu?uje da li je trenutni izvor podataka SplFileInfo objekat,"    public function isSplFileInfo()    {        return is_a($this->data, 'SplFileInfo');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
53,Intervention_image_AbstractDecoder_426, Determines if current data is Symfony UploadedFile component\n\n @return boolean\n,  Odlu?uje da li je trenutni izvor podataka Symfony UploadedFile komponenta,"    public function isSymfonyUpload()    {        return is_a($this->data, 'Symfony\Component\HttpFoundation\File\UploadedFile');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
54,Intervention_image_AbstractDecoder_427, Determines if current source data is file path\n\n @return boolean\n,  Odlu?uje da li je trenutni izvor podataka putanja do fajla,    public function isFilePath()    {        if (is_string($this->data)) {            try {                return is_file($this->data);            } catch (\Exception $e) {                return false;            }        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
55,Intervention_image_AbstractDecoder_430, Determines if current source data is binary data\n\n @return boolean\n,  Odlu?uje da li je trenutni izvor podataka binarni podatak,"    public function isBinary()    {        if (is_string($this->data)) {            $mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $this->data);            return (substr($mime, 0, 4) != 'text' && $mime != 'application/x-empty');        }        return false;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
56,Intervention_image_AbstractDecoder_431, Determines if current source data is data-url\n\n @return boolean\n,   Odlu?uje da li je trenutni izvor podataka url,    public function isDataUrl()    {        $data = $this->decodeDataUrl($this->data);        return is_null($data) ? false : true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
57,Intervention_image_AbstractDecoder_432, Determines if current source data is base64 encoded\\n\\n @return boolean\\n,   Odlu?uje da li je trenutni izvor podataka base64 enkodiran ,"    public function isBase64()    {        if (!is_string($this->data)) {            return false;        }        return base64_encode(base64_decode($this->data)) === str_replace([""\n"", ""\r""], '', $this->data);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
58,Intervention_image_AbstractDecoder_434, Parses and decodes binary image data from data-url\n\n @param  string $data_url\n @return string\n, Parsira i dekodira binarne podatke za sliku iz url ,"    private function decodeDataUrl($data_url)    {        if (!is_string($data_url)) {            return null;        }        $pattern = ""/^data:(?:image\/[a-zA-Z\-\.]+)(?:charset=\"".+\"")?;base64,(?P<data>.+)$/"";        preg_match($pattern, $data_url, $matches);        if (is_array($matches) && array_key_exists('data', $matches)) {            return base64_decode($matches['data']);        }        return null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
59,Intervention_image_AbstractDecoder_435, Initiates new image from mixed data\\\\n\\\\n @param  mixed $data\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n, Inicira novu sliku iz mešovitih podataka ,"    public function init($data)    {        $this->data = $data;        switch (true) {            case $this->isGdResource():                return $this->initFromGdResource($this->data);            case $this->isImagick():                return $this->initFromImagick($this->data);            case $this->isInterventionImage():                return $this->initFromInterventionImage($this->data);            case $this->isSplFileInfo():                return $this->initFromPath($this->data->getRealPath());            case $this->isBinary():                return $this->initFromBinary($this->data);            case $this->isUrl():                return $this->initFromUrl($this->data);            case $this->isStream():                return $this->initFromStream($this->data);            case $this->isDataUrl():                return $this->initFromBinary($this->decodeDataUrl($this->data));            case $this->isFilePath():                return $this->initFromPath($this->data);            // isBase64 has to be after isFilePath to prevent false positives            case $this->isBase64():                return $this->initFromBinary(base64_decode($this->data));            default:                throw new NotReadableException(""Image source not readable"");        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
60,Intervention_image_AbstractDriver_444, Returns classname of given command name\\\\n\\\\n @param  string $name\\\\n @return string\\\\n, Vra?a ime klase za dato ime komande ,"    private function getCommandClassName($name)    {        $name = mb_convert_case($name[0], MB_CASE_UPPER, 'utf-8') . mb_substr($name, 1, mb_strlen($name));                $drivername = $this->getDriverName();        $classnameLocal = sprintf('\Intervention\Image\%s\Commands\%sCommand', $drivername, ucfirst($name));        $classnameGlobal = sprintf('\Intervention\Image\Commands\%sCommand', ucfirst($name));        if (class_exists($classnameLocal)) {            return $classnameLocal;        } elseif (class_exists($classnameGlobal)) {            return $classnameGlobal;        }        throw new NotSupportedException(            ""Command ({$name}) is not available for driver ({$drivername}).""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
61,Intervention_image_AbstractDriver_445, Returns name of current driver instance\\n\\n @return string\\n, Vra?a naziv trenutne instance drajvera,"    public function getDriverName()    {        $reflect = new \ReflectionClass($this);        $namespace = $reflect->getNamespaceName();        return substr(strrchr($namespace, ""\\""), 1);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
62,Intervention_image_AbstractEncoder_453, Processes and returns encoded image as data-url string\\n\\n @return string\\n,  Procesira i vra?a kodovanu sliku kao url string,"    protected function processDataUrl()    {        $mime = $this->image->mime ? $this->image->mime : 'image/png';        return sprintf('data:%s;base64,%s',            $mime,            base64_encode($this->process($this->image, $mime, $this->quality))        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
63,Intervention_image_AbstractEncoder_455, Determines output quality\n\n @param int $quality\n, Odre?uje kvalitet izlaza,    protected function setQuality($quality)    {        $quality = is_null($quality) ? 90 : $quality;        $quality = $quality === 0 ? 1 : $quality;        if ($quality < 0 || $quality > 100) {            throw new InvalidArgumentException(                'Quality must range from 0 to 100.'            );        }        $this->quality = intval($quality);        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
64,Intervention_image_AbstractShape_474, Determines if current shape has border\\\\n\\\\n @return boolean\\\\n, Odre?uje da li trenutni oblik ima okvir,    public function hasBorder()    {        return ($this->border_width >= 1);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
65,Intervention_image_Argument_541, Returns name of current arguments command\n\n @return string\n, Vra?a naziv trenutne komande argumenta,"    public function getCommandName()    {        preg_match(""/\\\\([\w]+)Command$/"", get_class($this->command), $matches);        return isset($matches[1]) ? lcfirst($matches[1]).'()' : 'Method';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
66,Intervention_image_Argument_542, Defines current argument as required\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Commands\\\\\\\\Argument\\\\n, Definiše trenutni argument kao potreban,"    public function required()    {        if ( ! array_key_exists($this->key, $this->command->arguments)) {            throw new InvalidArgumentException(                sprintf(""Missing argument %d for %s"", $this->key + 1, $this->getCommandName())            );        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
67,Intervention_image_Argument_544, Determines that current argument value must be numeric between given values\\n\\n @return \\\\Intervention\\\\Image\\\\Commands\\\\Argument\\n, Odre?uje da li trenutni vrednost argumenta mora biti numeri?ka izme?u datih vrednosti,"    public function between($x, $y)    {        $value = $this->type('numeric')->value();        if (is_null($value)) {            return $this;        }        $alpha = min($x, $y);        $omega = max($x, $y);        if ($value < $alpha || $value > $omega) {            throw new InvalidArgumentException(                sprintf('Argument %d must be between %s and %s.', $this->key, $x, $y)            );        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
68,Intervention_image_Argument_546, Determines that current argument must be under a maxiumum value\\n\\n @return \\\\Intervention\\\\Image\\\\Commands\\\\Argument\\n, Odre?uje da li trenutna vrednost argumenta mora biti ispod maksimalne vrednosti,"    public function max($value)    {        $v = $this->type('numeric')->value();        if (is_null($v)) {            return $this;        }        if ($v > $value) {            throw new InvalidArgumentException(                sprintf('Argument %d may not be greater than %s.', $this->key, $value)            );        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
69,Intervention_image_BackupCommand_593, Saves a backups of current state of image core\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, ?uva rezervne kopije trenutnog stanja jezgra slike,"    public function execute($image)    {        $backupName = $this->argument(0)->value();        // clone current image resource        $clone = clone $image;        $image->setBackup($clone->getCore(), $backupName);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
70,Intervention_image_BlurCommand_594, Applies blur effect on image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Primenjuje efekat zamu?enja slike,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(1);        for ($i=0; $i < intval($amount); $i++) {            imagefilter($image->getCore(), IMG_FILTER_GAUSSIAN_BLUR);        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
71,Intervention_image_ChecksumCommand_548, Calculates checksum of given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Ra?una kontolnu sumu za datu sliku,"    public function execute($image)    {        $colors = [];        $size = $image->getSize();        for ($x=0; $x <= ($size->width-1); $x++) {            for ($y=0; $y <= ($size->height-1); $y++) {                $colors[] = $image->pickColor($x, $y, 'array');            }        }        $this->setOutput(md5(serialize($colors)));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
72,Intervention_image_CircleCommand_549, Draw a circle centered on given image\n\n @param  \\Intervention\\Image\\image $image\n @return boolean\n, Crta krug koji je centriran na datoj slici,"    public function execute($image)    {        $diameter = $this->argument(0)->type('numeric')->required()->value();        $x = $this->argument(1)->type('numeric')->required()->value();        $y = $this->argument(2)->type('numeric')->required()->value();        $callback = $this->argument(3)->type('closure')->value();        $circle_classname = sprintf('\Intervention\Image\%s\Shapes\CircleShape',            $image->getDriver()->getDriverName());        $circle = new $circle_classname($diameter);        if ($callback instanceof Closure) {            $callback($circle);        }        $circle->applyToImage($image, $x, $y);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
73,Intervention_image_Color_565, Initiates color object from given array\\n\\n @param  array $value\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n, Inicira objekat boje iz datog niza,"    public function initFromArray($array)    {        $array = array_values($array);        if (count($array) == 4) {            // color array with alpha value            list($r, $g, $b, $a) = $array;            $this->a = $this->alpha2gd($a);        } elseif (count($array) == 3) {            // color array without alpha value            list($r, $g, $b) = $array;            $this->a = 0;        }        $this->r = $r;        $this->g = $g;        $this->b = $b;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
74,Intervention_image_Color_569, Calculates integer value of current color instance\n\n @return int\n, Izra?unava celobrojnu vrednost trenutne instance boje,    public function getInt()    {        return ($this->a << 24) + ($this->r << 16) + ($this->g << 8) + $this->b;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
75,Intervention_image_Color_570, Calculates RGB(A) in array format of current color instance\\\\n\\\\n @return array\\\\n, Izra?unava RGB(A) u formatu niza trenutne instance boje,"    public function getArray()    {        return [$this->r, $this->g, $this->b, round(1 - $this->a / 127, 2)];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
76,Intervention_image_Color_571, Calculates RGBA in string format of current color instance\\\\n\\\\n @return string\\\\n, Izra?unava RGB(A) u formatu stringa trenutne instance boje,"    public function getRgba()    {        return sprintf('rgba(%d, %d, %d, %.2F)', $this->r, $this->g, $this->b, round(1 - $this->a / 127, 2));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
77,Intervention_image_Color_572, Convert rgba alpha (0-1) value to gd value (0-127)\\n\\n @param  float $input\\n @return int\\n, Konvertuje rgba alfa (0-1) vrednost u gd vrednost (0-127),    private function alpha2gd($input)    {        $oldMin = 0;        $oldMax = 1;        $newMin = 127;        $newMax = 0;        return ceil(((($input- $oldMin) * ($newMax - $newMin)) / ($oldMax - $oldMin)) + $newMin);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
78,Intervention_image_Color_627, Initiates color object from integer\\\\n\\\\n @param  int $value\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n, Inicira objekat boje na osnovu celog broja ,"    public function initFromInteger($value)    {        $a = ($value >> 24) & 0xFF;        $r = ($value >> 16) & 0xFF;        $g = ($value >> 8) & 0xFF;        $b = $value & 0xFF;        $a = $this->rgb2alpha($a);        $this->setPixel($r, $g, $b, $a);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
79,Intervention_image_Color_630, Initiates color object from given ImagickPixel object\\n\\n @param  ImagickPixel $value\\n\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n, Inicira objekat boje od datog ImagickPixel objekta,"    public function initFromObject($value)    {        if (is_a($value, '\ImagickPixel')) {            $this->pixel = $value;        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
80,Intervention_image_Color_631," Initiates color object from given R, G and B values\\\\n\\\\n @param  int $r\\\\n @param  int $g\\\\n @param  int $b\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n"," Inicira objekat boje od datih R, G i B vrednosti","    public function initFromRgb($r, $g, $b)    {        $this->setPixel($r, $g, $b);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
81,Intervention_image_Color_632," Initiates color object from given R, G, B and A values\\\\n\\\\n @param  int     $r\\\\n @param  int     $g\\\\n @param  int     $b\\\\n @param  float   $a\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractColor\\\\n","Inicira objekat boje od datih R, G, B i A vrednosti","    public function initFromRgba($r, $g, $b, $a)    {        $this->setPixel($r, $g, $b, $a);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
82,Intervention_image_Color_633, Calculates integer value of current color instance\\n\\n @return int\\n, Izra?unava celobrojnu vrednost trenutne instance boje,    public function getInt()    {        $r = $this->getRedValue();        $g = $this->getGreenValue();        $b = $this->getBlueValue();        $a = intval(round($this->getAlphaValue() * 255));        return intval(($a << 24) + ($r << 16) + ($g << 8) + $b);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
83,Intervention_image_Color_636, Returns RGB red value of current color\\\\n\\\\n @return int\\\\n, Vra?a RGB crvenu vrednost trenutne boje,    public function getRedValue()    {        return intval(round($this->pixel->getColorValue(\Imagick::COLOR_RED) * 255));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
84,Intervention_image_Color_639, Returns RGB alpha value of current color\\\\n\\\\n @return float\\\\n, Vra?a RGB alfa vrednost trenutne boje,"    public function getAlphaValue()    {        return round($this->pixel->getColorValue(\Imagick::COLOR_ALPHA), 2);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
85,Intervention_image_Color_641, Calculates RGA integer alpha value into float value\\n\\n @param  int $value\\n @return float\\n,Izra?unava RGA celobrojnu alfa vrednost kao vrednost sa pokretnim zarezom,"    private function rgb2alpha($value)    {        // (255 -> 1.0) / (0 -> 0.0)        return (float) round($value/255, 2);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
86,Intervention_image_ColorizeCommand_596, Changes balance of different RGB color channels\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Menja balans na razli?itim RGB kanalima boja,"    public function execute($image)    {        $red = $this->argument(0)->between(-100, 100)->required()->value();        $green = $this->argument(1)->between(-100, 100)->required()->value();        $blue = $this->argument(2)->between(-100, 100)->required()->value();        // normalize colorize levels        $red = round($red * 2.55);        $green = round($green * 2.55);        $blue = round($blue * 2.55);        // apply filter        return imagefilter($image->getCore(), IMG_FILTER_COLORIZE, $red, $green, $blue);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
87,Intervention_image_ColorizeCommand_660, Changes balance of different RGB color channels\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Menja balans na razli?itim RGB kanalima boja,"    public function execute($image)    {        $red = $this->argument(0)->between(-100, 100)->required()->value();        $green = $this->argument(1)->between(-100, 100)->required()->value();        $blue = $this->argument(2)->between(-100, 100)->required()->value();        // normalize colorize levels        $red = $this->normalizeLevel($red);        $green = $this->normalizeLevel($green);        $blue = $this->normalizeLevel($blue);        $qrange = $image->getCore()->getQuantumRange();        // apply        $image->getCore()->levelImage(0, $red, $qrange['quantumRangeLong'], \Imagick::CHANNEL_RED);        $image->getCore()->levelImage(0, $green, $qrange['quantumRangeLong'], \Imagick::CHANNEL_GREEN);        $image->getCore()->levelImage(0, $blue, $qrange['quantumRangeLong'], \Imagick::CHANNEL_BLUE);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
88,Intervention_image_Constraint_478, Checks if given argument is fixed in current constraint\\n\\n @param  int  $type\\n @return boolean\\n, Proverava da li je dati argument fiksan u trenutnom ograni?enju,    public function isFixed($type)    {        return (bool) ($this->fixed & (1 << $type));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
89,Intervention_image_ContrastCommand_597, Changes contrast of image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Menja kontrast slike,"    public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return imagefilter($image->getCore(), IMG_FILTER_CONTRAST, ($level * -1));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
90,Intervention_image_ContrastCommand_661, Changes contrast of image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Menja kontrast slike,"    public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return $image->getCore()->sigmoidalContrastImage($level > 0, $level / 4, 0);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
91,Intervention_image_CropCommand_598, Crop an image instance\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Se?e instancu slike,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->required()->value();        $x = $this->argument(2)->type('digit')->value();        $y = $this->argument(3)->type('digit')->value();        if (is_null($width) || is_null($height)) {            throw new \Intervention\Image\Exception\InvalidArgumentException(                ""Width and height of cutout needs to be defined.""            );        }        $cropped = new Size($width, $height);        $position = new Point($x, $y);        // align boxes        if (is_null($x) && is_null($y)) {            $position = $image->getSize()->align('center')->relativePosition($cropped->align('center'));        }        // crop image core        return $this->modify($image, 0, 0, $position->x, $position->y, $cropped->width, $cropped->height, $cropped->width, $cropped->height);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
92,Intervention_image_CropCommand_662, Crop an image instance\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Se?e instancu slike,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->required()->value();        $x = $this->argument(2)->type('digit')->value();        $y = $this->argument(3)->type('digit')->value();        if (is_null($width) || is_null($height)) {            throw new InvalidArgumentException(                ""Width and height of cutout needs to be defined.""            );        }        $cropped = new Size($width, $height);        $position = new Point($x, $y);        // align boxes        if (is_null($x) && is_null($y)) {            $position = $image->getSize()->align('center')->relativePosition($cropped->align('center'));        }        // crop image core        $image->getCore()->cropImage($cropped->width, $cropped->height, $position->x, $position->y);        $image->getCore()->setImagePage(0,0,0,0);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
93,Intervention_image_Decoder_574, Initiates new image from GD resource\\\\n\\\\n @param  Resource $resource\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Inicira novu sliku iz GD izvora,"    public function initFromGdResource($resource)    {        return new Image(new Driver, $resource);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
94,Intervention_image_Decoder_576, Initiates new image from binary data\\n\\n @param  string $data\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicira novu sliku iz binarnih podataka,"    public function initFromBinary($binary)    {        $resource = @imagecreatefromstring($binary);        if ($resource === false) {             throw new NotReadableException(                ""Unable to init from given binary data.""            );        }        $image = $this->initFromGdResource($resource);        $image->mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $binary);        return $image;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
95,Intervention_image_Decoder_576, Initiates new image from binary data\\\\n\\\\n @param  string $data\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Inicira novu sliku iz binarnih podataka,"    public function initFromBinary($binary)    {        $resource = @imagecreatefromstring($binary);        if ($resource === false) {             throw new NotReadableException(                ""Unable to init from given binary data.""            );        }        $image = $this->initFromGdResource($resource);        $image->mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $binary);        return $image;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
96,Intervention_image_Decoder_577, Transform GD resource into Truecolor version\\n\\n @param  resource $resource\\n @return bool\\n, Transformiše GD izvor u Truecolor verziju,"    public function gdResourceToTruecolor(&$resource)    {        $width = imagesx($resource);        $height = imagesy($resource);        // new canvas        $canvas = imagecreatetruecolor($width, $height);        // fill with transparent color        imagealphablending($canvas, false);        $transparent = imagecolorallocatealpha($canvas, 255, 255, 255, 127);        imagefilledrectangle($canvas, 0, 0, $width, $height, $transparent);        imagecolortransparent($canvas, $transparent);        imagealphablending($canvas, true);        // copy original        imagecopy($canvas, $resource, 0, 0, 0, 0, $width, $height);        imagedestroy($resource);        $resource = $canvas;        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
97,Intervention_image_Decoder_644, Initiates new image from Imagick object\\\\n\\\\n @param  Imagick $object\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n, Inicira novu sliku iz Imagick objekta,"    public function initFromImagick(\Imagick $object)    {        // currently animations are not supported        // so all images are turned into static        $object = $this->removeAnimation($object);        // reset image orientation        $object->setImageOrientation(\Imagick::ORIENTATION_UNDEFINED);        return new Image(new Driver, $object);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
98,Intervention_image_Decoder_645, Initiates new image from binary data\\n\\n @param  string $data\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Inicira novu sliku iz binarnih podataka,"    public function initFromBinary($binary)    {        $core = new \Imagick;        try {            $core->setBackgroundColor(new \ImagickPixel('transparent'));            $core->readImageBlob($binary);        } catch (\ImagickException $e) {            throw new NotReadableException(                ""Unable to read image from binary data."",                0,                $e            );        }        // build image        $image = $this->initFromImagick($core);        $image->mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $binary);        return $image;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
99,Intervention_image_Decoder_646, Turns object into one frame Imagick object\n by removing all frames except first\n\n @param  Imagick $object\n @return Imagick\n,Pretvara objekat u jedan frame Imagick objekta uklanjanjem svih frejmova osim prvog,    private function removeAnimation(\Imagick $object)    {        $imagick = new \Imagick;        foreach ($object as $frame) {            $imagick->addImage($frame->getImage());            break;        }        $object->destroy();        return $imagick;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
100,Intervention_image_DemoFilter_562, Applies filter effects to given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return \\\\Intervention\\\\Image\\\\Image\\n,Primenjuje efekat filtera na datu sliku,    public function applyFilter(Image $image)    {        $image->pixelate($this->size);        $image->greyscale();        return $image;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
101,Intervention_image_DestroyCommand_599, Destroys current image core and frees up memory\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Uništava jezgro trenutne slike i osloba?a memoriju,    public function execute($image)    {        // destroy image core        imagedestroy($image->getCore());        // destroy backups        foreach ($image->getBackups() as $backup) {            imagedestroy($backup);        }        return true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
102,Intervention_image_DestroyCommand_663, Destroys current image core and frees up memory\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Uništava jezgro trenutne slike i osloba?a memoriju,    public function execute($image)    {        // destroy image core        $image->getCore()->clear();        // destroy backups        foreach ($image->getBackups() as $backup) {            $backup->clear();        }        return true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
103,Intervention_image_Driver_580, Returns clone of given core\\n\\n @return mixed\\n, Vra?a klona datog jezgra,"    public function cloneCore($core)    {        $width = imagesx($core);        $height = imagesy($core);        $clone = imagecreatetruecolor($width, $height);        imagealphablending($clone, false);        imagesavealpha($clone, true);        $transparency = imagecolorallocatealpha($clone, 0, 0, 0, 127);        imagefill($clone, 0, 0, $transparency);                imagecopy($clone, $core, 0, 0, 0, 0, $width, $height);        return $clone;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
104,Intervention_image_Encoder_582, Processes and returns encoded image as PNG string\n\n @return string\n, Obra?uje i vra?a kodovanu sliku kao PNG string,"    protected function processPng()    {        ob_start();        $resource = $this->image->getCore();        imagealphablending($resource, false);        imagesavealpha($resource, true);        imagepng($resource, null, -1);        $this->image->mime = image_type_to_mime_type(IMAGETYPE_PNG);        $buffer = ob_get_contents();        ob_end_clean();        return $buffer;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
105,Intervention_image_Encoder_650, Processes and returns encoded image as PNG string\\n\\n @return string\\n, Obra?uje i vra?a kodovanu sliku kao PNG string,    protected function processPng()    {        $format = 'png';        $compression = \Imagick::COMPRESSION_ZIP;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
106,Intervention_image_Encoder_651, Processes and returns encoded image as GIF string\\\\n\\\\n @return string\\\\n, Procesira i vra?a kodovanu sliku kao GIF string,    protected function processGif()    {        $format = 'gif';        $compression = \Imagick::COMPRESSION_LZW;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
107,Intervention_image_Encoder_652, Processes and returns encoded image as TIFF string\\\\n\\\\n @return string\\\\n, Procesira i vra?a kodovanu sliku kao TIFF string,    protected function processTiff()    {        $format = 'tiff';        $compression = \Imagick::COMPRESSION_UNDEFINED;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        $imagick->setCompressionQuality($this->quality);        $imagick->setImageCompressionQuality($this->quality);        return $imagick->getImagesBlob();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
108,Intervention_image_Encoder_653, Processes and returns encoded image as BMP string\n\n @return string\n, Procesira i vra?a kodovanu sliku kao BMP string,    protected function processBmp()    {        $format = 'bmp';        $compression = \Imagick::COMPRESSION_UNDEFINED;        $imagick = $this->image->getCore();        $imagick->setFormat($format);        $imagick->setImageFormat($format);        $imagick->setCompression($compression);        $imagick->setImageCompression($compression);        return $imagick->getImagesBlob();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
109,Intervention_image_ExifCommand_665, Read Exif data from the given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, ?ita Exif podatke iz date slike,"    public function execute($image)    {        if ($this->preferExtension && function_exists('exif_read_data')) {            return parent::execute($image);        }        $core = $image->getCore();        if ( ! method_exists($core, 'getImageProperties')) {            throw new NotSupportedException(                ""Reading Exif data is not supported by this PHP installation.""            );        }        $requestedKey = $this->argument(0)->value();        if ($requestedKey !== null) {            $this->setOutput($core->getImageProperty('exif:' . $requestedKey));            return true;        }        $exif = [];        $properties = $core->getImageProperties();        foreach ($properties as $key => $value) {            if (substr($key, 0, 5) !== 'exif:') {                continue;            }            $exif[substr($key, 5)] = $value;        }        $this->setOutput($exif);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
110,Intervention_image_File_481, Sets all instance properties from given path\\n\\n @param string $path\\n, Postavlja sva svojstva instance na osnovu date putanja,"    public function setFileInfoFromPath($path)    {        $info = pathinfo($path);        $this->dirname = array_key_exists('dirname', $info) ? $info['dirname'] : null;        $this->basename = array_key_exists('basename', $info) ? $info['basename'] : null;        $this->extension = array_key_exists('extension', $info) ? $info['extension'] : null;        $this->filename = array_key_exists('filename', $info) ? $info['filename'] : null;        if (file_exists($path) && is_file($path)) {            $this->mime = finfo_file(finfo_open(FILEINFO_MIME_TYPE), $path);        }        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
111,Intervention_image_File_482, Get file size\n \n @return mixed\n, Vra?a veli?inu fajla,    public function filesize()    {        $path = $this->basePath();        if (file_exists($path) && is_file($path)) {            return filesize($path);        }                return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
112,Intervention_image_File_483, Get fully qualified path\n\n @return string\n, Vra?a poptpuno kvalifikovanu putanju,    public function basePath()    {        if ($this->dirname && $this->basename) {            return ($this->dirname .'/'. $this->basename);        }        return null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
113,Intervention_image_FillCommand_600, Fills image with color or pattern\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Popunjava sliku sa bojom ili obrascem,"    public function execute($image)    {        $filling = $this->argument(0)->value();        $x = $this->argument(1)->type('digit')->value();        $y = $this->argument(2)->type('digit')->value();        $width = $image->getWidth();        $height = $image->getHeight();        $resource = $image->getCore();        try {            // set image tile filling            $source = new Decoder;            $tile = $source->init($filling);            imagesettile($image->getCore(), $tile->getCore());            $filling = IMG_COLOR_TILED;        } catch (\Intervention\Image\Exception\NotReadableException $e) {            // set solid color filling            $color = new Color($filling);            $filling = $color->getInt();        }        imagealphablending($resource, true);        if (is_int($x) && is_int($y)) {            // resource should be visible through transparency            $base = $image->getDriver()->newImage($width, $height)->getCore();            imagecopy($base, $resource, 0, 0, 0, 0, $width, $height);            // floodfill if exact position is defined            imagefill($resource, $x, $y, $filling);            // copy filled original over base            imagecopy($base, $resource, 0, 0, 0, 0, $width, $height);            // set base as new resource-core            $image->setCore($base);            imagedestroy($resource);        } else {            // fill whole image otherwise            imagefilledrectangle($resource, 0, 0, $width - 1, $height - 1, $filling);        }        isset($tile) ? imagedestroy($tile->getCore()) : null;        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
114,Intervention_image_FillCommand_666, Fills image with color or pattern\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Popunjava sliku sa bojom ili obrascem,"    public function execute($image)    {        $filling = $this->argument(0)->value();        $x = $this->argument(1)->type('digit')->value();        $y = $this->argument(2)->type('digit')->value();        $imagick = $image->getCore();        try {            // set image filling            $source = new Decoder;            $filling = $source->init($filling);        } catch (NotReadableException $e) {            // set solid color filling            $filling = new Color($filling);        }        // flood fill if coordinates are set        if (is_int($x) && is_int($y)) {            // flood fill with texture            if ($filling instanceof Image) {                // create tile                $tile = clone $image->getCore();                // mask away color at position                $tile->transparentPaintImage($tile->getImagePixelColor($x, $y), 0, 0, false);                // create canvas                $canvas = clone $image->getCore();                // fill canvas with texture                $canvas = $canvas->textureImage($filling->getCore());                // merge canvas and tile                $canvas->compositeImage($tile, \Imagick::COMPOSITE_DEFAULT, 0, 0);                // replace image core                $image->setCore($canvas);            // flood fill with color            } elseif ($filling instanceof Color) {                // create canvas with filling                $canvas = new \Imagick;                $canvas->newImage($image->getWidth(), $image->getHeight(), $filling->getPixel(), 'png');                // create tile to put on top                $tile = clone $image->getCore();                // mask away color at pos.                $tile->transparentPaintImage($tile->getImagePixelColor($x, $y), 0, 0, false);                // save alpha channel of original image                $alpha = clone $image->getCore();                // merge original with canvas and tile                $image->getCore()->compositeImage($canvas, \Imagick::COMPOSITE_DEFAULT, 0, 0);                $image->getCore()->compositeImage($tile, \Imagick::COMPOSITE_DEFAULT, 0, 0);                // restore alpha channel of original image                $image->getCore()->compositeImage($alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);            }        } else {            if ($filling instanceof Image) {                // fill whole image with texture                $image->setCore($image->getCore()->textureImage($filling->getCore()));            } elseif ($filling instanceof Color) {                // fill whole image with color                $draw = new \ImagickDraw();                $draw->setFillColor($filling->getPixel());                $draw->rectangle(0, 0, $image->getWidth(), $image->getHeight());                $image->getCore()->drawImage($draw);            }        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
115,Intervention_image_FitCommand_667, Crops and resized an image at the same time\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Ise?e i promeni veli?inu slici u isto vreme,"    public function execute($image)    {        $width = $this->argument(0)->type('digit')->required()->value();        $height = $this->argument(1)->type('digit')->value($width);        $constraints = $this->argument(2)->type('closure')->value();        $position = $this->argument(3)->type('string')->value('center');        // calculate size        $cropped = $image->getSize()->fit(new Size($width, $height), $position);        $resized = clone $cropped;        $resized = $resized->resize($width, $height, $constraints);        // crop image        $image->getCore()->cropImage(            $cropped->width,            $cropped->height,            $cropped->pivot->x,            $cropped->pivot->y        );        // resize image        $image->getCore()->scaleImage($resized->getWidth(), $resized->getHeight());        $image->getCore()->setImagePage(0,0,0,0);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
116,Intervention_image_FlipCommand_602, Mirrors an image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Pravi sliku u ogledalu,"    public function execute($image)    {        $mode = $this->argument(0)->value('h');        $size = $image->getSize();        $dst = clone $size;        switch (strtolower($mode)) {            case 2:            case 'v':            case 'vert':            case 'vertical':                $size->pivot->y = $size->height - 1;                $size->height = $size->height * (-1);                break;            default:                $size->pivot->x = $size->width - 1;                $size->width = $size->width * (-1);                break;        }        return $this->modify($image, 0, 0, $size->pivot->x, $size->pivot->y, $dst->width, $dst->height, $size->width, $size->height);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
117,Intervention_image_FlipCommand_668, Mirrors an image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Pravi sliku u ogledalu,"    public function execute($image)    {        $mode = $this->argument(0)->value('h');        if (in_array(strtolower($mode), [2, 'v', 'vert', 'vertical'])) {            // flip vertical            return $image->getCore()->flipImage();        } else {            // flip horizontal            return $image->getCore()->flopImage();        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
118,Intervention_image_Font_590, Get width of an internal font character\\\\n\\\\n @return int\\\\n, Vra?a širinu unutrašnjeg fonta karaktera,    private function getInternalFontWidth()    {        return $this->getInternalFont() + 4;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
119,Intervention_image_Font_591, Get height of an internal font character\n\n @return int\n,  Vra?a visinu unutrašnjeg fonta karaktera,    private function getInternalFontHeight()    {        switch ($this->getInternalFont()) {            case 1:                return 8;            case 2:                return 14;            case 3:                return 14;            case 4:                return 16;            case 5:                return 16;        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
120,Intervention_image_Font_592, Calculates bounding box of current font setting\\n\\n @return Array\\n, Ra?una okvir za ograni?enje trenutkih podešavanja fonta,"    public function getBoxSize()    {        $box = [];        if ($this->hasApplicableFontFile()) {            // imagettfbbox() converts numeric entities to their respective            // character. Preserve any originally double encoded entities to be            // represented as is.            // eg: &amp;#160; will render &#160; rather than its character.            $this->text = preg_replace('/&(#(?:x[a-fA-F0-9]+|[0-9]+);)/', '&#38;\1', $this->text);            $this->text = mb_encode_numericentity($this->text, array(0x0080, 0xffff, 0, 0xffff), 'UTF-8');            // get bounding box with angle 0            $box = imagettfbbox($this->getPointSize(), 0, $this->file, $this->text);            // rotate points manually            if ($this->angle != 0) {                $angle = pi() * 2 - $this->angle * pi() * 2 / 360;                for ($i=0; $i<4; $i++) {                    $x = $box[$i * 2];                    $y = $box[$i * 2 + 1];                    $box[$i * 2] = cos($angle) * $x - sin($angle) * $y;                    $box[$i * 2 + 1] = sin($angle) * $x + cos($angle) * $y;                }            }            $box['width'] = intval(abs($box[4] - $box[0]));            $box['height'] = intval(abs($box[5] - $box[1]));        } else {            // get current internal font size            $width = $this->getInternalFontWidth();            $height = $this->getInternalFontHeight();            if (strlen($this->text) == 0) {                // no text -> no boxsize                $box['width'] = 0;                $box['height'] = 0;            } else {                // calculate boxsize                $box['width'] = strlen($this->text) * $width;                $box['height'] = $height;            }        }        return $box;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
121,Intervention_image_GreyscaleCommand_605, Turns an image into a greyscale version\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Pretvara sliku u verziju sa sivim tonovima,"    public function execute($image)    {        return imagefilter($image->getCore(), IMG_FILTER_GRAYSCALE);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
122,Intervention_image_ImageManagerStatic_506, Get or create new ImageManager instance\\\\n\\\\n @return ImageManager\\\\n, Vra?a ili kreira novu instancu ImageManager,    public static function getManager()    {        return self::$manager ? self::$manager : new ImageManager;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
123,Intervention_image_ImageManagerStatic_507, Statically initiates an Image instance from different input types\n\n @param  mixed $data\n\n @return \\Intervention\\Image\\Image\n @throws \\Intervention\\Image\\Exception\\NotReadableException\n, Inicira instancu Image stati?no od razli?itih ulaznih tipova,    public static function make($data)    {        return self::getManager()->make($data);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
124,Intervention_image_ImageManager_503, Initiates an Image instance from different input types\\n\\n @param  mixed $data\\n\\n @return \\\\Intervention\\\\Image\\\\Image\\n, Inicira instancu Image od razli?itih ulaznih tipova,    public function make($data)    {        return $this->createDriver()->init($data);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
125,Intervention_image_ImageManager_504, Creates a driver instance according to config settings\\\\n\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\AbstractDriver\\\\n,Kreira instancu drajvera u skladu sa config podešavanjima ,"    private function createDriver()    {        if (is_string($this->config['driver'])) {            $drivername = ucfirst($this->config['driver']);            $driverclass = sprintf('Intervention\\Image\\%s\\Driver', $drivername);            if (class_exists($driverclass)) {                return new $driverclass;            }            throw new NotSupportedException(                ""Driver ({$drivername}) could not be instantiated.""            );        }        if ($this->config['driver'] instanceof AbstractDriver) {            return $this->config['driver'];        }        throw new NotSupportedException(            ""Unknown driver type.""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
126,Intervention_image_ImageManager_505, Check if all requirements are available\\n\\n @return void\\n, Provera da li su svi zahtevi dostupni,"    private function checkRequirements()    {        if ( ! function_exists('finfo_buffer')) {            throw new MissingDependencyException(                ""PHP Fileinfo extension must be installed/enabled to use Intervention Image.""            );        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
127,Intervention_image_ImageServiceProviderLaravel4_514, Register the service provider.\n\n @return void\n, Registruje provajdera usluga,"    public function register()    {        $app = $this->app;        $app['image'] = $app->share(function ($app) {            return new ImageManager($app['config']->get('image::config'));        });        $app->alias('image', 'Intervention\Image\ImageManager');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
128,Intervention_image_ImageServiceProviderLaravelRecent_516, Bootstrap the application events.\\n\\n @return void\\n,Butstrapuje doga?aje aplikacije,    public function boot()    {        $this->publishes([            __DIR__.'/../../config/config.php' => config_path('image.php')        ]);        // setup intervention/imagecache if package is installed        $this->cacheIsInstalled() ? $this->bootstrapImageCache() : null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
129,Intervention_image_ImageServiceProviderLaravelRecent_517, Register the service provider.\\n\\n @return void\\n, Registruje provajdera usluga,"    public function register()    {        $app = $this->app;        // merge default config        $this->mergeConfigFrom(            __DIR__.'/../../config/config.php',            'image'        );        // create image        $app->singleton('image', function ($app) {            return new ImageManager($this->getImageConfig($app));        });        $app->alias('image', 'Intervention\Image\ImageManager');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
130,Intervention_image_ImageServiceProviderLaravelRecent_519, Bootstrap imagecache\n\n @return void\n, Butstrapuje imagecache,"    protected function bootstrapImageCache()    {        $app = $this->app;        $config = __DIR__.'/../../../../imagecache/src/config/config.php';        $this->publishes([            $config => config_path('imagecache.php')        ]);        // merge default config        $this->mergeConfigFrom(            $config,            'imagecache'        );        // imagecache route        if (is_string(config('imagecache.route'))) {            $filename_pattern = '[ \w\\.\\/\\-\\@\(\)]+';            // route to access template applied image file            $app['router']->get(config('imagecache.route').'/{template}/{filename}', [                'uses' => 'Intervention\Image\ImageCacheController@getResponse',                'as' => 'imagecache'            ])->where(['filename' => $filename_pattern]);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
131,Intervention_image_ImageServiceProviderLaravelRecent_520, Return image configuration as array\\n\\n @param  Application $app\\n @return array\\n,Vra?a podešavanja slike u vidu niza,    private function getImageConfig($app)    {        $config = $app['config']->get('image');        if (is_null($config)) {            return [];        }        return $config;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
132,Intervention_image_ImageServiceProviderLeague_521, Register the server provider.\n\n @return void\n, Register the server provider.,"    public function register()    {        $this->getContainer()->share('Intervention\Image\ImageManager', function () {            return new ImageManager($this->config);        });    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
133,Intervention_image_ImageServiceProviderLumen_522, Register the service provider.\n\n @return void\n, Registruje provajdera usluga,"    public function register()    {        $app = $this->app;        // merge default config        $this->mergeConfigFrom(          __DIR__.'/../../config/config.php',          'image'        );        // set configuration        $app->configure('image');        // create image        $app->singleton('image',function ($app) {            return new ImageManager($app['config']->get('image'));        });        $app->alias('image', 'Intervention\Image\ImageManager');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
134,Intervention_image_ImageServiceProvider_510, Register the service provider.\n\n @return void\n, Registruje provajdera usluga,    public function register()    {        return $this->provider->register();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
135,Intervention_image_Image_485, Magic method to catch all image calls\\\\n usually any AbstractCommand\\\\n\\\\n @param  string $name\\\\n @param  Array  $arguments\\\\n @return mixed\\\\n, Magi?na metoda koja hvata sve pozive slika obično bilo koja AbstractCommand,"    public function __call($name, $arguments)    {        $command = $this->driver->executeCommand($this, $name, $arguments);        return $command->hasOutput() ? $command->getOutput() : $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
136,Intervention_image_Image_488, Sets current image driver\\n @param AbstractDriver $driver\\n,Postavlja trenutni drajver slike,    public function setDriver(AbstractDriver $driver)    {        $this->driver = $driver;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
137,Intervention_image_Image_492, Checks if named backup exists\n\n @param  string $name\n @return bool\n, Proverava da li imenovana sigurnosna kopija postoji,"    private function backupExists($name)    {        return array_key_exists($name, $this->backups);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
138,Intervention_image_Image_493, Checks if current image is already encoded\\\\n\\\\n @return boolean\\\\n,Proverava da li je trenuta slika ve? kodovana,    public function isEncoded()    {        return ! empty($this->encoded);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
139,Intervention_image_Image_496, Calculates current image width\\\\n\\\\n @return int\\\\n,Izra?unava širinu trenutne slike ,    public function getWidth()    {        return $this->getSize()->width;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
140,Intervention_image_Image_497, Alias of getWidth()\n\n @return int\n, Pseudonim getWidth() metode,    public function width()    {        return $this->getWidth();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
141,Intervention_image_Image_498, Calculates current image height\n\n @return int\n,Izra?unava visinu trenutne slike ,    public function getHeight()    {        return $this->getSize()->height;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
142,Intervention_image_Image_502, Cloning an image\\\\n,Klonira sliku,    public function __clone()    {        $this->core = $this->driver->cloneCore($this->core);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
143,Intervention_image_InsertCommand_673, Insert another image into given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Insertuje neku drugu sliku u datu sliku,"    public function execute($image)    {        $source = $this->argument(0)->required()->value();        $position = $this->argument(1)->type('string')->value();        $x = $this->argument(2)->type('digit')->value(0);        $y = $this->argument(3)->type('digit')->value(0);        // build watermark        $watermark = $image->getDriver()->init($source);        // define insertion point        $image_size = $image->getSize()->align($position, $x, $y);        $watermark_size = $watermark->getSize()->align($position);        $target = $image_size->relativePosition($watermark_size);        // insert image at position        return $image->getCore()->compositeImage($watermark->getCore(), \Imagick::COMPOSITE_DEFAULT, $target->x, $target->y);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
144,Intervention_image_LineCommand_553, Draws line on given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Crta linije na datoj slici,"    public function execute($image)    {        $x1 = $this->argument(0)->type('numeric')->required()->value();        $y1 = $this->argument(1)->type('numeric')->required()->value();        $x2 = $this->argument(2)->type('numeric')->required()->value();        $y2 = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $line_classname = sprintf('\Intervention\Image\%s\Shapes\LineShape',            $image->getDriver()->getDriverName());        $line = new $line_classname($x2, $y2);        if ($callback instanceof Closure) {            $callback($line);        }        $line->applyToImage($image, $x1, $y1);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
145,Intervention_image_MaskCommand_677, Applies an alpha mask to an image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Primenjuje alfa masku na sliku ,"    public function execute($image)    {        $mask_source = $this->argument(0)->value();        $mask_w_alpha = $this->argument(1)->type('bool')->value(false);        // get imagick        $imagick = $image->getCore();        // build mask image from source        $mask = $image->getDriver()->init($mask_source);        // resize mask to size of current image (if necessary)        $image_size = $image->getSize();        if ($mask->getSize() != $image_size) {            $mask->resize($image_size->width, $image_size->height);        }        $imagick->setImageMatte(true);        if ($mask_w_alpha) {            // just mask with alpha map            $imagick->compositeImage($mask->getCore(), \Imagick::COMPOSITE_DSTIN, 0, 0);        } else {            // get alpha channel of original as greyscale image            $original_alpha = clone $imagick;            $original_alpha->separateImageChannel(\Imagick::CHANNEL_ALPHA);            // use red channel from mask ask alpha            $mask_alpha = clone $mask->getCore();            $mask_alpha->compositeImage($mask->getCore(), \Imagick::COMPOSITE_DEFAULT, 0, 0);            // $mask_alpha->setImageAlphaChannel(\Imagick::ALPHACHANNEL_DEACTIVATE);            $mask_alpha->separateImageChannel(\Imagick::CHANNEL_ALL);            // combine both alphas from original and mask            $original_alpha->compositeImage($mask_alpha, \Imagick::COMPOSITE_COPYOPACITY, 0, 0);            // mask the image with the alpha combination            $imagick->compositeImage($original_alpha, \Imagick::COMPOSITE_DSTIN, 0, 0);        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
146,Intervention_image_PixelCommand_614, Draws one pixel to a given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Crta jedan piksel na datu sliku,"    public function execute($image)    {        $color = $this->argument(0)->required()->value();        $color = new Color($color);        $x = $this->argument(1)->type('digit')->required()->value();        $y = $this->argument(2)->type('digit')->required()->value();        return imagesetpixel($image->getCore(), $x, $y, $color->getInt());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
147,Intervention_image_PixelateCommand_681, Applies a pixelation effect to a given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Primenjuje efekat pikselacije na datu sliku,"    public function execute($image)    {        $size = $this->argument(0)->type('digit')->value(10);        $width = $image->getWidth();        $height = $image->getHeight();        $image->getCore()->scaleImage(max(1, ($width / $size)), max(1, ($height / $size)));        $image->getCore()->scaleImage($width, $height);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
148,Intervention_image_Point_524, Sets X coordinate\n\n @param int $x\n,Postavlja X koordinatu,    public function setX($x)    {        $this->x = intval($x);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
149,Intervention_image_PolygonCommand_555, Draw a polygon on given image\\n\\n @param  \\\\Intervention\\\\Image\\\\image $image\\n @return boolean\\n, Crta poligon na datu sliku,"    public function execute($image)    {        $points = $this->argument(0)->type('array')->required()->value();        $callback = $this->argument(1)->type('closure')->value();        $vertices_count = count($points);        // check if number if coordinates is even        if ($vertices_count % 2 !== 0) {            throw new InvalidArgumentException(                ""The number of given polygon vertices must be even.""            );        }        if ($vertices_count < 6) {            throw new InvalidArgumentException(                ""You must have at least 3 points in your array.""            );        }                $polygon_classname = sprintf('\Intervention\Image\%s\Shapes\PolygonShape',            $image->getDriver()->getDriverName());        $polygon = new $polygon_classname($points);                if ($callback instanceof Closure) {            $callback($polygon);        }        $polygon->applyToImage($image);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
150,Intervention_image_PolygonShape_626, Create new polygon instance\n\n @param array $points\n, Kreira novu instancu poligona,    public function __construct($points)    {        $this->points = $points;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
151,Intervention_image_PolygonShape_691, Create new polygon instance\\n\\n @param array $points\\n, Kreira novu instancu poligona,    public function __construct($points)    {        $this->points = $this->formatPoints($points);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
152,Intervention_image_PsrResponseCommand_556," Builds PSR7 compatible response. May replace ""response"" command in\\\\n some future.\\\\n\\\\n Method will generate binary stream and put it inside PSR-7\\\\n ResponseInterface. Following code can be optimized using native php\\\\n streams and more ""clean"" streaming, however drivers has to be updated\\\\n first.\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n"," Kreira odgovor koji je kompatibilan sa PSR7. Može zameniti komandu odgovora u budućnosti. Metoda će generisati binarni niz i postaviti unutar PSR-7 ResponseInterface. Naredni kod može biti opitimizovan korišćenjem nativnih php nizova i ""čistijeg"" streaming, međutim prvo je potrebno da drajveri budu ažurirani.","    public function execute($image)    {        $format = $this->argument(0)->value();        $quality = $this->argument(1)->between(0, 100)->value();        //Encoded property will be populated at this moment        $stream = $image->stream($format, $quality);        $mimetype = finfo_buffer(            finfo_open(FILEINFO_MIME_TYPE),            $image->getEncoded()        );        $this->setOutput(new Response(            200,            [                'Content-Type'   => $mimetype,                'Content-Length' => strlen($image->getEncoded())            ],            $stream        ));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
153,Intervention_image_RectangleCommand_557, Draws rectangle on given image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Crta pravougaonik na datu sliku,"    public function execute($image)    {        $x1 = $this->argument(0)->type('numeric')->required()->value();        $y1 = $this->argument(1)->type('numeric')->required()->value();        $x2 = $this->argument(2)->type('numeric')->required()->value();        $y2 = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $rectangle_classname = sprintf('\Intervention\Image\%s\Shapes\RectangleShape',            $image->getDriver()->getDriverName());        $rectangle = new $rectangle_classname($x1, $y1, $x2, $y2);        if ($callback instanceof Closure) {            $callback($rectangle);        }        $rectangle->applyToImage($image, $x1, $y1);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
154,Intervention_image_RectangleCommand_557, Draws rectangle on given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Crta pravougaonik na datu sliku,"    public function execute($image)    {        $x1 = $this->argument(0)->type('numeric')->required()->value();        $y1 = $this->argument(1)->type('numeric')->required()->value();        $x2 = $this->argument(2)->type('numeric')->required()->value();        $y2 = $this->argument(3)->type('numeric')->required()->value();        $callback = $this->argument(4)->type('closure')->value();        $rectangle_classname = sprintf('\Intervention\Image\%s\Shapes\RectangleShape',            $image->getDriver()->getDriverName());        $rectangle = new $rectangle_classname($x1, $y1, $x2, $y2);        if ($callback instanceof Closure) {            $callback($rectangle);        }        $rectangle->applyToImage($image, $x1, $y1);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
155,Intervention_image_ResetCommand_616, Resets given image to its backup state\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Resetuje zadatu sliku u stanje rezervne kopije,"    public function execute($image)    {        $backupName = $this->argument(0)->value();        if (is_resource($backup = $image->getBackup($backupName))) {            // destroy current resource            imagedestroy($image->getCore());            // clone backup            $backup = $image->getDriver()->cloneCore($backup);            // reset to new resource            $image->setCore($backup);            return true;        }        throw new RuntimeException(            ""Backup not available. Call backup() before reset().""        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
156,Intervention_image_ResizeCommand_618, Resizes image dimensions\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Menja dimenzije slike,"    public function execute($image)    {        $width = $this->argument(0)->value();        $height = $this->argument(1)->value();        $constraints = $this->argument(2)->type('closure')->value();        // resize box        $resized = $image->getSize()->resize($width, $height, $constraints);        // modify image        $this->modify($image, 0, 0, 0, 0, $resized->getWidth(), $resized->getHeight(), $image->getWidth(), $image->getHeight());        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
157,Intervention_image_ResponseCommand_558, Builds HTTP response from given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n, Pravi HTTP odgovor od date slike,"    public function execute($image)    {        $format = $this->argument(0)->value();        $quality = $this->argument(1)->between(0, 100)->value();        $response = new Response($image, $format, $quality);        $this->setOutput($response->make());        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
158,Intervention_image_Response_527, Builds response according to settings\\n\\n @return mixed\\n, Pravi odgovor u sklau sa podešavanjima,"    public function make()    {        $this->image->encode($this->format, $this->quality);        $data = $this->image->getEncoded();        $mime = finfo_buffer(finfo_open(FILEINFO_MIME_TYPE), $data);        $length = strlen($data);        if (function_exists('app') && is_a($app = app(), 'Illuminate\Foundation\Application')) {            $response = IlluminateResponse::make($data);            $response->header('Content-Type', $mime);            $response->header('Content-Length', $length);        } elseif (class_exists('\Symfony\Component\HttpFoundation\Response')) {            $response = SymfonyResponse::create($data);            $response->headers->set('Content-Type', $mime);            $response->headers->set('Content-Length', $length);        } else {            header('Content-Type: ' . $mime);            header('Content-Length: ' . $length);            $response = $data;        }        return $response;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
159,Intervention_image_RotateCommand_620, Rotates image counter clockwise\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Rotira sliku u smeru suprotnom od kazaljki na satu,"    public function execute($image)    {        $angle = $this->argument(0)->type('numeric')->required()->value();        $color = $this->argument(1)->value();        $color = new Color($color);        // restrict rotations beyond 360 degrees, since the end result is the same        $angle %= 360;        // rotate image        $image->setCore(imagerotate($image->getCore(), $angle, $color->getInt()));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
160,Intervention_image_RotateCommand_685, Rotates image counter clockwise\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Rotira sliku u smeru suprotnom od kazaljki na satu,"    public function execute($image)    {        $angle = $this->argument(0)->type('numeric')->required()->value();        $color = $this->argument(1)->value();        $color = new Color($color);        // restrict rotations beyond 360 degrees, since the end result is the same        $angle %= 360;        // rotate image        $image->getCore()->rotateImage($color->getPixel(), ($angle * -1));        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
161,Intervention_image_SharpenCommand_621, Sharpen image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n,Izoštrava sliku,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(10);        // build matrix        $min = $amount >= 10 ? $amount * -0.01 : 0;        $max = $amount * -0.025;        $abs = ((4 * $min + 4 * $max) * -1) + 1;        $div = 1;        $matrix = [            [$min, $max, $min],            [$max, $abs, $max],            [$min, $max, $min]        ];        // apply the matrix        return imageconvolution($image->getCore(), $matrix, $div, 0);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
162,Intervention_image_SharpenCommand_686, Sharpen image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Izoštrava sliku,"    public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(10);        return $image->getCore()->unsharpMaskImage(1, 1, $amount / 6.25, 0);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
163,Intervention_image_Size_529, Set current pivot point\n\n @param Point $point\n,Podešavanje trenutne ta?ke okretanja,    public function setPivot(Point $point)    {        $this->pivot = $point;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
164,Intervention_image_Size_532, Calculate the current aspect ratio\n\n @return float\n,Izra?unava trenutni odnos širine i visine,    public function getRatio()    {        return $this->width / $this->height;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
165,Intervention_image_Size_533, Calculate the relative position to another Size\\n based on the pivot point settings of both sizes.\\n\\n @param  Size   $size\\n @return \\\\Intervention\\\\Image\\\\Point\\n," Izra?unava relativnu poziciju u odnosu na drugi Size da simulira korišćenje udaljenog deljenog diska, bez da postoji zavisnost u odnosu na lokalni privremeni fajl. ","    public function relativePosition(Size $size)    {        $x = $this->pivot->x - $size->pivot->x;        $y = $this->pivot->y - $size->pivot->y;        return new Point($x, $y);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
166,Intervention_image_Size_534, Checks if given size fits into current size\n\n @param  Size   $size\n @return boolean\n, Proverava da li data veli?ina može da stane u trenutnu veli?inu,    public function fitsInto(Size $size)    {        return ($this->width <= $size->width) && ($this->height <= $size->height);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
167,Intervention_image_TextCommand_560, Write text on given image\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Ispisuje tekst na datu sliku,"    public function execute($image)    {        $text = $this->argument(0)->required()->value();        $x = $this->argument(1)->type('numeric')->value(0);        $y = $this->argument(2)->type('numeric')->value(0);        $callback = $this->argument(3)->type('closure')->value();        $fontclassname = sprintf('\Intervention\Image\%s\Font',            $image->getDriver()->getDriverName());        $font = new $fontclassname($text);        if ($callback instanceof Closure) {            $callback($font);        }        $font->applyToImage($image, $x, $y);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
168,Intervention_image_TrimCommand_622, Trims away parts of an image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n, Se?e delove slike,"    public function execute($image)    {        $base = $this->argument(0)->type('string')->value();        $away = $this->argument(1)->value();        $tolerance = $this->argument(2)->type('numeric')->value(0);        $feather = $this->argument(3)->type('numeric')->value(0);        $width = $image->getWidth();        $height = $image->getHeight();        // default values        $checkTransparency = false;        // define borders to trim away        if (is_null($away)) {            $away = ['top', 'right', 'bottom', 'left'];        } elseif (is_string($away)) {            $away = [$away];        }        // lower border names        foreach ($away as $key => $value) {            $away[$key] = strtolower($value);        }        // define base color position        switch (strtolower($base)) {            case 'transparent':            case 'trans':                $checkTransparency = true;                $base_x = 0;                $base_y = 0;                break;            case 'bottom-right':            case 'right-bottom':                $base_x = $width - 1;                $base_y = $height - 1;                break;            default:            case 'top-left':            case 'left-top':                $base_x = 0;                $base_y = 0;                break;        }        // pick base color        if ($checkTransparency) {            $color = new Color; // color will only be used to compare alpha channel        } else {            $color = $image->pickColor($base_x, $base_y, 'object');        }        $top_x = 0;        $top_y = 0;        $bottom_x = $width;        $bottom_y = $height;        // search upper part of image for colors to trim away        if (in_array('top', $away)) {            for ($y=0; $y < ceil($height/2); $y++) {                for ($x=0; $x < $width; $x++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $top_y = max(0, $y - $feather);                        break 2;                    }                }            }        }        // search left part of image for colors to trim away        if (in_array('left', $away)) {            for ($x=0; $x < ceil($width/2); $x++) {                for ($y=$top_y; $y < $height; $y++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $top_x = max(0, $x - $feather);                        break 2;                    }                }            }        }        // search lower part of image for colors to trim away        if (in_array('bottom', $away)) {            for ($y=($height-1); $y >= floor($height/2)-1; $y--) {                for ($x=$top_x; $x < $width; $x++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $bottom_y = min($height, $y+1 + $feather);                        break 2;                    }                }            }        }        // search right part of image for colors to trim away        if (in_array('right', $away)) {            for ($x=($width-1); $x >= floor($width/2)-1; $x--) {                for ($y=$top_y; $y < $bottom_y; $y++) {                    $checkColor = $image->pickColor($x, $y, 'object');                    if ($checkTransparency) {                        $checkColor->r = $color->r;                        $checkColor->g = $color->g;                        $checkColor->b = $color->b;                    }                    if ($color->differs($checkColor, $tolerance)) {                        $bottom_x = min($width, $x+1 + $feather);                        break 2;                    }                }            }        }        // trim parts of image        return $this->modify($image, 0, 0, $top_x, $top_y, ($bottom_x-$top_x), ($bottom_y-$top_y), ($bottom_x-$top_x), ($bottom_y-$top_y));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
169,Intervention_image_TrimCommand_687, Trims away parts of an image\n\n @param  \\Intervention\\Image\\Image $image\n @return boolean\n, Se?e delove slike,"    public function execute($image)    {        $base = $this->argument(0)->type('string')->value();        $away = $this->argument(1)->value();        $tolerance = $this->argument(2)->type('numeric')->value(0);        $feather = $this->argument(3)->type('numeric')->value(0);        $width = $image->getWidth();        $height = $image->getHeight();        $checkTransparency = false;        // define borders to trim away        if (is_null($away)) {            $away = ['top', 'right', 'bottom', 'left'];        } elseif (is_string($away)) {            $away = [$away];        }        // lower border names        foreach ($away as $key => $value) {            $away[$key] = strtolower($value);        }        // define base color position        switch (strtolower($base)) {            case 'transparent':            case 'trans':                $checkTransparency = true;                $base_x = 0;                $base_y = 0;                break;            case 'bottom-right':            case 'right-bottom':                $base_x = $width - 1;                $base_y = $height - 1;                break;            default:            case 'top-left':            case 'left-top':                $base_x = 0;                $base_y = 0;                break;        }        // pick base color        if ($checkTransparency) {            $base_color = new Color; // color will only be used to compare alpha channel        } else {            $base_color = $image->pickColor($base_x, $base_y, 'object');        }        // trim on clone to get only coordinates        $trimed = clone $image->getCore();        // add border to trim specific color        $trimed->borderImage($base_color->getPixel(), 1, 1);        // trim image        $trimed->trimImage(65850 / 100 * $tolerance);        // get coordinates of trim        $imagePage = $trimed->getImagePage();        list($crop_x, $crop_y) = [$imagePage['x']-1, $imagePage['y']-1];        // $trimed->setImagePage(0, 0, 0, 0);        list($crop_width, $crop_height) = [$trimed->width, $trimed->height];        // adjust settings if right should not be trimed        if ( ! in_array('right', $away)) {            $crop_width = $crop_width + ($width - ($width - $crop_x));        }        // adjust settings if bottom should not be trimed        if ( ! in_array('bottom', $away)) {            $crop_height = $crop_height + ($height - ($height - $crop_y));        }        // adjust settings if left should not be trimed        if ( ! in_array('left', $away)) {            $crop_width = $crop_width + $crop_x;            $crop_x = 0;        }        // adjust settings if top should not be trimed        if ( ! in_array('top', $away)) {            $crop_height = $crop_height + $crop_y;            $crop_y = 0;        }        // add feather        $crop_width = min($width, ($crop_width + $feather * 2));        $crop_height = min($height, ($crop_height + $feather * 2));        $crop_x = max(0, ($crop_x - $feather));        $crop_y = max(0, ($crop_y - $feather));        // finally crop based on page        $image->getCore()->cropImage($crop_width, $crop_height, $crop_x, $crop_y);        $image->getCore()->setImagePage(0,0,0,0);        $trimed->destroy();        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
170,Maatwebsite_Laravel-Excel_DelegatedMacroable_734, Dynamically handle calls to the class.\\\\n\\\\n @param  string $method\\\\n @param  array  $parameters\\\\n\\\\n @return mixed\\\\n, Dinami?ki rukuje pozivima klasi,"    public function __call($method, $parameters)    {        if (method_exists($this->getDelegate(), $method)) {            return call_user_func_array([$this->getDelegate(), $method], $parameters);        }        array_unshift($parameters, $this);        return $this->__callMacro($method, $parameters);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
171,Maatwebsite_Laravel-Excel_HasEventBus_744, Register a global event listener.\\n\\n @param string   $event\\n @param callable $listener\\n, Registruje globalni osluškiva? doga?aja,"    public static function listen(string $event, callable $listener)    {        static::$globalEvents[$event][] = $listener;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
172,Maatwebsite_Laravel-Excel_QueuedImportTest_827, Setup the test environment.\\n,Podešavanje testnog okruženja,    protected function setUp(): void    {        parent::setUp();        $this->loadLaravelMigrations(['--database' => 'testing']);        $this->loadMigrationsFrom(__DIR__ . '/Data/Stubs/Database/Migrations');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
173,Maatwebsite_Laravel-Excel_QueuedImportTest_831," Delete the local temp file before each read chunk job\n to simulate using a shared remote disk, without\n having a dependency on a local temp file.\n",Briše lokalnu privremenu datoteku pre svakog dela ?itanja,"        Queue::before(function (JobProcessing $event) {            if ($event->job->resolveName() === ReadChunk::class) {                /** @var TemporaryFile $tempFile */                $tempFile = $this->inspectJobProperty($event->job, 'temporaryFile');                $this->assertInstanceOf(RemoteTemporaryFile::class, $tempFile);                // Should exist remote                $this->assertTrue(                    $tempFile->exists()                );                $this->assertTrue(                    unlink($tempFile->getLocalPath())                );            }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
174,Maatwebsite_Laravel-Excel_QueuedQueryExportTest_840, Setup the test environment.\\\\n,Podešavanje testnog okruženja,    protected function setUp(): void    {        parent::setUp();        $this->loadLaravelMigrations(['--database' => 'testing']);        $this->withFactories(__DIR__ . '/Data/Stubs/Database/Factories');        factory(User::class)->times(100)->create([]);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
175,PHPOffice_PHPExcel_Autoloader_127, Autoload a class identified by name\\\\n\\\\n @param    string    $pClassName        Name of the object to load\\\\n,Automatsko u?itavanje klase identifikovane imenom,"    public static function load($pClassName)    {        if ((class_exists($pClassName, false)) || (strpos($pClassName, 'PHPExcel') !== 0)) {            // Either already loaded, or not a PHPExcel class request            return false;        }        $pClassFilePath = PHPEXCEL_ROOT .            str_replace('_', DIRECTORY_SEPARATOR, $pClassName) .            '.php';        if ((file_exists($pClassFilePath) === false) || (is_readable($pClassFilePath) === false)) {            // Can't load            return false;        }        require($pClassFilePath);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
176,PHPOffice_PHPExcel_CachedObjectStorageFactory_132, Return the list of all available cache storage methods\n\n @return string[]\n,Vra?a listu svih moguc?ih metoda skladištenja keš memorije,"    public static function getCacheStorageMethods()    {        $activeMethods = array();        foreach (self::$storageMethods as $storageMethod) {            $cacheStorageClass = 'PHPExcel_CachedObjectStorage_' . $storageMethod;            if (call_user_func(array($cacheStorageClass, 'cacheMethodIsAvailable'))) {                $activeMethods[] = $storageMethod;            }        }        return $activeMethods;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
177,PHPOffice_PHPExcel_CachedObjectStorageFactory_133, Initialise the cache storage\\\\n\\\\n @param    PHPExcel_Worksheet     $parent        Enable cell caching for this worksheet\\\\n @return    PHPExcel_CachedObjectStorage_ICache\\\\n, Iniciranje keš memoriju,"    public static function getInstance(PHPExcel_Worksheet $parent)    {        $cacheMethodIsAvailable = true;        if (self::$cacheStorageMethod === null) {            $cacheMethodIsAvailable = self::initialize();        }        if ($cacheMethodIsAvailable) {            $instance = new self::$cacheStorageClass(                $parent,                self::$storageMethodParameters[self::$cacheStorageMethod]            );            if ($instance !== null) {                return $instance;            }        }        return false;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
178,PHPOffice_PHPExcel_CachedObjectStorageFactory_134, Clear the cache storage\\\\n\\\\n,brisanje keš skladišta,    public static function finalize()    {        self::$cacheStorageMethod = null;        self::$cacheStorageClass = null;        self::$storageMethodParameters = array();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
179,PHPOffice_PHPExcel_Calculation_140, Return the locale-specific translation of TRUE\\\\\\\\n\\\\\\\\n @access    public\\\\\\\\n @return     string        locale-specific translation of TRUE\\\\\\\\n, Vra?a lokalni prevod za TRUE,    public static function getTRUE()    {        return self::$localeBoolean['TRUE'];    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
180,PHPOffice_PHPExcel_Calculation_146, Disable calculation cache\\\\n,Onemogu?ava keš ra?unanja,    public function disableCalculationCache()    {        $this->setCalculationCacheEnabled(false);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
181,PHPOffice_PHPExcel_Calculation_147, Clear calculation cache\\\\n,Briše keš ra?unanja,    public function clearCalculationCache()    {        $this->calculationCache = array();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
182,PHPOffice_PHPExcel_Calculation_148, Clear calculation cache for a specified worksheet\\\\\\\\n\\\\\\\\n @param string $worksheetName\\\\\\\\n,Briše keš ra?unanja za navedeni radni list,    public function clearCalculationCacheForWorksheet($worksheetName)    {        if (isset($this->calculationCache[$worksheetName])) {            unset($this->calculationCache[$worksheetName]);        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
183,PHPOffice_PHPExcel_Calculation_149, Rename calculation cache for a specified worksheet\\\\n\\\\n @param string $fromWorksheetName\\\\n @param string $toWorksheetName\\\\n,Menja naziv keša ra?unanja za navedeni radni list,"    public function renameCalculationCacheForWorksheet($fromWorksheetName, $toWorksheetName)    {        if (isset($this->calculationCache[$fromWorksheetName])) {            $this->calculationCache[$toWorksheetName] = &$this->calculationCache[$fromWorksheetName];            unset($this->calculationCache[$fromWorksheetName]);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
184,PHPOffice_PHPExcel_Calculation_150, Get the currently defined locale code\\\\n\\\\n @return string\\\\n,Vra?a  trenutno definisani lokalni kod,    public function getLocale()    {        return self::$localeLanguage;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
185,PHPOffice_PHPExcel_Calculation_152, Remove quotes used as a wrapper to identify string values\\n\\n @param mixed $value\\n @return mixed\\n,Uklanja navodnike koji su koriš?eni za string vrednosti,"    public static function unwrapResult($value)    {        if (is_string($value)) {            if ((isset($value{0})) && ($value{0} == '""') && (substr($value, -1) == '""')) {                return substr($value, 1, -1);            }        //    Convert numeric errors to NaN error        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {            return PHPExcel_Calculation_Functions::NaN();        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
186,PHPOffice_PHPExcel_Calculation_153, Validate and parse a formula string\\\\n\\\\n @param    string        $formula        Formula to parse\\\\n @return    array\\\\n @throws    PHPExcel_Calculation_Exception\\\\n, Validira i parsira niz formule,    public function parseFormula($formula)    {        //    Basic validation that this is indeed a formula        //    We return an empty array if not        $formula = trim($formula);        if ((!isset($formula{0})) || ($formula{0} != '=')) {            return array();        },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
187,PHPOffice_PHPExcel_Calculation_155, Ensure that paired matrix operands are both matrices of the same size\n\n @param    mixed        &$matrix1        First matrix operand\n @param    mixed        &$matrix2        Second matrix operand\n @param    integer        $matrix1Rows    Row size of first matrix operand\n @param    integer        $matrix1Columns    Column size of first matrix operand\n @param    integer        $matrix2Rows    Row size of second matrix operand\n @param    integer        $matrix2Columns    Column size of second matrix operand\n, Osigurava da su upareni operandi matrice matrice istih dimenzija,"    private static function resizeMatricesShrink(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Rows < $matrix1Rows) {                for ($i = $matrix2Rows; $i < $matrix1Rows; ++$i) {                    unset($matrix1[$i]);                }            }            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        unset($matrix1[$i][$j]);                    }                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Rows < $matrix2Rows) {                for ($i = $matrix1Rows; $i < $matrix2Rows; ++$i) {                    unset($matrix2[$i]);                }            }            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        unset($matrix2[$i][$j]);                    }                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
188,PHPOffice_PHPExcel_Calculation_156, Ensure that paired matrix operands are both matrices of the same size\\\\n\\\\n @param    mixed        &$matrix1    First matrix operand\\\\n @param    mixed        &$matrix2    Second matrix operand\\\\n @param    integer        $matrix1Rows    Row size of first matrix operand\\\\n @param    integer        $matrix1Columns    Column size of first matrix operand\\\\n @param    integer        $matrix2Rows    Row size of second matrix operand\\\\n @param    integer        $matrix2Columns    Column size of second matrix operand\\\\n, Osigurava da su upareni operandi matrice matrice istih dimenzija,"    private static function resizeMatricesExtend(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $x = $matrix2[$i][$matrix2Columns-1];                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        $matrix2[$i][$j] = $x;                    }                }            }            if ($matrix2Rows < $matrix1Rows) {                $x = $matrix2[$matrix2Rows-1];                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $matrix2[$i] = $x;                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $x = $matrix1[$i][$matrix1Columns-1];                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        $matrix1[$i][$j] = $x;                    }                }            }            if ($matrix1Rows < $matrix2Rows) {                $x = $matrix1[$matrix1Rows-1];                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $matrix1[$i] = $x;                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
189,PHPOffice_PHPExcel_Calculation_158, Format type and details of an operand for display in the log (based on operand type)\\\\\\\\n\\\\\\\\n @param    mixed        $value    First matrix operand\\\\\\\\n @return    mixed\\\\\\\\n,Dormatira tip i detalje operanda za prikaz u evidenciji (na osnovu tipa operanda),    private function showTypeDetails($value)    {        if ($this->_debugLog->getWriteDebugLog()) {            $testArray = PHPExcel_Calculation_Functions::flattenArray($value);            if (count($testArray) == 1) {                $value = array_pop($testArray);            }            if ($value === null) {                return 'a NULL value';            } elseif (is_float($value)) {                $typeString = 'a floating point number';            } elseif (is_int($value)) {                $typeString = 'an integer number';            } elseif (is_bool($value)) {                $typeString = 'a boolean';            } elseif (is_array($value)) {                $typeString = 'a matrix';            } else {                if ($value == '') {                    return 'an empty string';                } elseif ($value{0} == '#') {                    return 'a '.$value.' error';                } else {                    $typeString = 'a string';                }            }            return $typeString.' with a value of '.$this->showValue($value);        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
190,PHPOffice_PHPExcel_Calculation_159, Compare two strings in the same way as strcmp() except that lowercase come before uppercase letters\\n @param    string    $str1    First string value for the comparison\\n @param    string    $str2    Second string value for the comparison\\n @return   integer\\n,"Poredi dva niza stringova na isti na?in kao i strcmp(), osim što se mala slova stavljaju ispred velikih slova","    private function strcmpLowercaseFirst($str1, $str2)    {        $inversedStr1 = PHPExcel_Shared_String::StrCaseReverse($str1);        $inversedStr2 = PHPExcel_Shared_String::StrCaseReverse($str2);        return strcmp($inversedStr1, $inversedStr2);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
191,PHPOffice_PHPExcel_Calculation_160," trigger an error, but nicely, if need be\n","izbacuje grešku, ali na fin na?in, ukoliko je potrebno","    protected function raiseFormulaError($errorMessage)    {        $this->formulaError = $errorMessage;        $this->cyclicReferenceStack->clear();        if (!$this->suppressFormulaErrors) {            throw new PHPExcel_Calculation_Exception($errorMessage);        }        trigger_error($errorMessage, E_USER_ERROR);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
192,PHPOffice_PHPExcel_Calculation_161, Get a list of all implemented functions as an array of function objects\n\n @return    array of PHPExcel_Calculation_Function\n,Vra?a listu svih implementiranih funkcija kao niz objekata funkcije,"    public function listFunctions()    {        $returnValue = array();        foreach (self::$PHPExcelFunctions as $functionName => $function) {            if ($function['functionCall'] != 'PHPExcel_Calculation_Functions::DUMMY') {                $returnValue[$functionName] = new PHPExcel_Calculation_Function(                    $function['category'],                    $functionName,                    $function['functionCall']                );            }        }        return $returnValue;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
193,PHPOffice_PHPExcel_Calculation_162, Get a list of all Excel function names\\\\\\\\n\\\\\\\\n @return    array\\\\\\\\n,Vra?a listu svih imena Excel funkcija,    public function listAllFunctionNames()    {        return array_keys(self::$PHPExcelFunctions);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
194,PHPOffice_PHPExcel_Calculation_163, Get a list of implemented Excel function names\n\n @return    array\n, Vra?a listu svih imena implementiranih Excel funkcija,    public function listFunctionNames()    {        $returnValue = array();        foreach (self::$PHPExcelFunctions as $functionName => $function) {            if ($function['functionCall'] != 'PHPExcel_Calculation_Functions::DUMMY') {                $returnValue[] = $functionName;            }        }        return $returnValue;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
195,PHPOffice_PHPExcel_Cell_165,    Send notification to the cache controller\\\\n\\\\n    @return void\\\\n,  Šalje obaveštenje kontroloru keš memorije,    public function notifyCacheController()    {        $this->parent->updateCacheData($this);        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
196,PHPOffice_PHPExcel_Cell_173,  Identify if the cell contains a formula\\\\\\\\n\\\\\\\\n  @return boolean\\\\\\\\n,Utvr?uje da li c?elija sadrži formulu,    public function isFormula()    {        return $this->dataType == PHPExcel_Cell_DataType::TYPE_FORMULA;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
197,PHPOffice_PHPExcel_Cell_174,    Does this cell contain Data validation rules?\\n\\n    @return    boolean\\n    @throws    PHPExcel_Exception\\n,Da li ova c?elija sadrži pravila za proveru podataka?,    public function hasDataValidation()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot check for data validation when cell is not bound to a worksheet');        }        return $this->getWorksheet()->dataValidationExists($this->getCoordinate());    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
198,PHPOffice_PHPExcel_Cell_175,    Get Data validation rules\n\n    @return    PHPExcel_Cell_DataValidation\n    @throws    PHPExcel_Exception\n,Vra?a pravila za proveru podataka,    public function getDataValidation()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot get data validation for cell that is not bound to a worksheet');        }        return $this->getWorksheet()->getDataValidation($this->getCoordinate());    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
199,PHPOffice_PHPExcel_Cell_180,    Is this cell in a merge range\\n\\n    @return boolean\\n,Da li je ova c?elija u opsegu spajanja,    public function isInMergeRange()    {        return (boolean) $this->getMergeRange();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
200,PHPOffice_PHPExcel_Cell_181,    Is this cell the master (top left cell) in a merge range (that holds the actual data value)\\\\\\\\n\\\\\\\\n    @return boolean\\\\\\\\n,Da li je ova c?elija glavna (gornja leva c?elija) u opsegu objedinjavanja (koji sadrži stvarnu vrednost podataka),    public function isMergeRangeValueCell()    {        if ($mergeRange = $this->getMergeRange()) {            $mergeRange = PHPExcel_Cell::splitRange($mergeRange);            list($startCell) = $mergeRange[0];            if ($this->getCoordinate() === $startCell) {                return true;            }        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
201,PHPOffice_PHPExcel_Cell_182,"    If this cell is in a merge range, then return the range\n\n    @return string\n","Ako je ova c?elija u opsegu objedinjavanja, vra?a opseg",    public function getMergeRange()    {        foreach ($this->getWorksheet()->getMergeCells() as $mergeRange) {            if ($this->isInRange($mergeRange)) {                return $mergeRange;            }        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
202,PHPOffice_PHPExcel_Cell_183,    Get cell style\n\n    @return    PHPExcel_Style\n,Vra?a stil ?elije,    public function getStyle()    {        return $this->getWorksheet()->getStyle($this->getCoordinate());    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
203,PHPOffice_PHPExcel_Cell_184,    Re-bind parent\\\\\\\\n\\\\\\\\n    @param    PHPExcel_Worksheet $parent\\\\\\\\n    @return    PHPExcel_Cell\\\\\\\\n,Ponovno povezivanje roditelja,    public function rebindParent(PHPExcel_Worksheet $parent)    {        $this->parent = $parent->getCellCacheController();        return $this->notifyCacheController();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
204,PHPOffice_PHPExcel_Cell_186," Compare 2 cells\n\n @param    PHPExcel_Cell    $a    Cell a\n @param    PHPExcel_Cell    $b    Cell b\n @return    int        Result of comparison (always -1 or 1, never zero!)\n",Poredi 2 ?elije,"    public static function compareCells(PHPExcel_Cell $a, PHPExcel_Cell $b)    {        if ($a->getRow() < $b->getRow()) {            return -1;        } elseif ($a->getRow() > $b->getRow()) {            return 1;        } elseif (self::columnIndexFromString($a->getColumn()) < self::columnIndexFromString($b->getColumn())) {            return -1;        } else {            return 1;        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
205,PHPOffice_PHPExcel_Cell_188," Implement PHP __clone to create a deep clone, not just a shallow copy.\n","Implementira PHP __clone da kreira duboka kopija, ne samo plitka kopija. ",    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if ((is_object($value)) && ($key != 'parent')) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
206,PHPOffice_PHPExcel_Comment_218," PHPExcel_Comment\\\\n\\\\n Copyright (c) 2006 - 2015 PHPExcel\\\\n\\\\n This library is free software; you can redistribute it and/or\\\\n modify it under the terms of the GNU Lesser General Public\\\\n License as published by the Free Software Foundation; either\\\\n version 2.1 of the License, or (at your option) any later version.\\\\n\\\\n This library is distributed in the hope that it will be useful,\\\\n but WITHOUT ANY WARRANTY; without even the implied warranty of\\\\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\n Lesser General Public License for more details.\\\\n\\\\n You should have received a copy of the GNU Lesser General Public\\\\n License along with this library; if not, write to the Free Software\\\\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\\\\n\\\\n @category   PHPExcel\\\\n @package    PHPExcel\\\\n @copyright  Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\\\\n @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\\\\n @version    ##VERSION##, ##DATE##\\\\n", PHPExcel_Comment,"class PHPExcel_Comment implements PHPExcel_IComparable{    /**     * Author     *     * @var string     */    private $author;    /**     * Rich text comment     *     * @var PHPExcel_RichText     */    private $text;    /**     * Comment width (CSS style, i.e. XXpx or YYpt)     *     * @var string     */    private $width = '96pt';    /**     * Left margin (CSS style, i.e. XXpx or YYpt)     *     * @var string     */    private $marginLeft = '59.25pt';    /**     * Top margin (CSS style, i.e. XXpx or YYpt)     *     * @var string     */    private $marginTop = '1.5pt';    /**     * Visible     *     * @var boolean     */    private $visible = false;    /**     * Comment height (CSS style, i.e. XXpx or YYpt)     *     * @var string     */    private $height = '55.5pt';    /**     * Comment fill color     *     * @var PHPExcel_Style_Color     */    private $fillColor;    /**     * Alignment     *     * @var string     */    private $alignment;    /**     * Create a new PHPExcel_Comment     *     * @throws PHPExcel_Exception     */    public function __construct()    {        // Initialise variables        $this->author    = 'Author';        $this->text      = new PHPExcel_RichText();        $this->fillColor = new PHPExcel_Style_Color('FFFFFFE1');        $this->alignment = PHPExcel_Style_Alignment::HORIZONTAL_GENERAL;    }    /**     * Get Author     *     * @return string     */    public function getAuthor()    {        return $this->author;    }    /**     * Set Author     *     * @param string $pValue     * @return PHPExcel_Comment     */    public function setAuthor($pValue = '')    {        $this->author = $pValue;        return $this;    }    /**     * Get Rich text comment     *     * @return PHPExcel_RichText     */    public function getText()    {        return $this->text;    }    /**     * Set Rich text comment     *     * @param PHPExcel_RichText $pValue     * @return PHPExcel_Comment     */    public function setText(PHPExcel_RichText $pValue)    {        $this->text = $pValue;        return $this;    }    /**     * Get comment width (CSS style, i.e. XXpx or YYpt)     *     * @return string     */    public function getWidth()    {        return $this->width;    }    /**     * Set comment width (CSS style, i.e. XXpx or YYpt)     *     * @param string $value     * @return PHPExcel_Comment     */    public function setWidth($value = '96pt')    {        $this->width = $value;        return $this;    }    /**     * Get comment height (CSS style, i.e. XXpx or YYpt)     *     * @return string     */    public function getHeight()    {        return $this->height;    }    /**     * Set comment height (CSS style, i.e. XXpx or YYpt)     *     * @param string $value     * @return PHPExcel_Comment     */    public function setHeight($value = '55.5pt')    {        $this->height = $value;        return $this;    }    /**     * Get left margin (CSS style, i.e. XXpx or YYpt)     *     * @return string     */    public function getMarginLeft()    {        return $this->marginLeft;    }    /**     * Set left margin (CSS style, i.e. XXpx or YYpt)     *     * @param string $value     * @return PHPExcel_Comment     */    public function setMarginLeft($value = '59.25pt')    {        $this->marginLeft = $value;        return $this;    }    /**     * Get top margin (CSS style, i.e. XXpx or YYpt)     *     * @return string     */    public function getMarginTop()    {        return $this->marginTop;    }    /**     * Set top margin (CSS style, i.e. XXpx or YYpt)     *     * @param string $value     * @return PHPExcel_Comment     */    public function setMarginTop($value = '1.5pt')    {        $this->marginTop = $value;        return $this;    }    /**     * Is the comment visible by default?     *     * @return boolean     */    public function getVisible()    {        return $this->visible;    }    /**     * Set comment default visibility     *     * @param boolean $value     * @return PHPExcel_Comment     */    public function setVisible($value = false)    {        $this->visible = $value;        return $this;    }    /**     * Get fill color     *     * @return PHPExcel_Style_Color     */    public function getFillColor()    {        return $this->fillColor;    }    /**     * Set Alignment     *     * @param string $pValue     * @return PHPExcel_Comment     */    public function setAlignment($pValue = PHPExcel_Style_Alignment::HORIZONTAL_GENERAL)    {        $this->alignment = $pValue;        return $this;    }    /**     * Get Alignment     *     * @return string     */    public function getAlignment()    {        return $this->alignment;    }    /**     * Get hash code     *     * @return string    Hash code     */    public function getHashCode()    {        return md5(            $this->author .            $this->text->getHashCode() .            $this->width .            $this->height .            $this->marginLeft .            $this->marginTop .            ($this->visible ? 1 : 0) .            $this->fillColor->getHashCode() .            $this->alignment .            __CLASS__        );    }    /**     * Implement PHP __clone to create a deep clone, not just a shallow copy.     */    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if (is_object($value)) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    }    /**     * Convert to string     *     * @return string     */    public function __toString()    {        return $this->text->getPlainText();    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
207,PHPOffice_PHPExcel_Comment_219, Create a new PHPExcel_Comment\\\\n\\\\n @throws PHPExcel_Exception\\\\n,Kreiranje novog PHPExcel_Comment,    public function __construct()    {        // Initialise variables        $this->author    = 'Author';        $this->text      = new PHPExcel_RichText();        $this->fillColor = new PHPExcel_Style_Color('FFFFFFE1');        $this->alignment = PHPExcel_Style_Alignment::HORIZONTAL_GENERAL;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
208,PHPOffice_PHPExcel_Comment_230, Get hash code\n\n @return string    Hash code\n,Vra?a heš kod,    public function getHashCode()    {        return md5(            $this->author .            $this->text->getHashCode() .            $this->width .            $this->height .            $this->marginLeft .            $this->marginTop .            ($this->visible ? 1 : 0) .            $this->fillColor->getHashCode() .            $this->alignment .            __CLASS__        );    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
209,PHPOffice_PHPExcel_Comment_232, Convert to string\n\n @return string\n,Konvertovanje u string,    public function __toString()    {        return $this->text->getPlainText();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
210,PHPOffice_PHPExcel_DocumentProperties_233," PHPExcel_DocumentProperties\\\\\\\\n\\\\\\\\n Copyright (c) 2006 - 2015 PHPExcel\\\\\\\\n\\\\\\\\n This library is free software; you can redistribute it and/or\\\\\\\\n modify it under the terms of the GNU Lesser General Public\\\\\\\\n License as published by the Free Software Foundation; either\\\\\\\\n version 2.1 of the License, or (at your option) any later version.\\\\\\\\n\\\\\\\\n This library is distributed in the hope that it will be useful,\\\\\\\\n but WITHOUT ANY WARRANTY; without even the implied warranty of\\\\\\\\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\\\\\\\n Lesser General Public License for more details.\\\\\\\\n\\\\\\\\n You should have received a copy of the GNU Lesser General Public\\\\\\\\n License along with this library; if not, write to the Free Software\\\\\\\\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\\\\\\\\n\\\\\\\\n @category    PHPExcel\\\\\\\\n @package    PHPExcel\\\\\\\\n @copyright    Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\\\\\\\\n @license    http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt    LGPL\\\\\\\\n @version    ##VERSION##, ##DATE##\\\\\\\\n", PHPExcel_DocumentProperties,"class PHPExcel_DocumentProperties{    /** constants */    const PROPERTY_TYPE_BOOLEAN = 'b';    const PROPERTY_TYPE_INTEGER = 'i';    const PROPERTY_TYPE_FLOAT   = 'f';    const PROPERTY_TYPE_DATE    = 'd';    const PROPERTY_TYPE_STRING  = 's';    const PROPERTY_TYPE_UNKNOWN = 'u';    /**     * Creator     *     * @var string     */    private $creator = 'Unknown Creator';    /**     * LastModifiedBy     *     * @var string     */    private $lastModifiedBy;    /**     * Created     *     * @var datetime     */    private $created;    /**     * Modified     *     * @var datetime     */    private $modified;    /**     * Title     *     * @var string     */    private $title = 'Untitled Spreadsheet';    /**     * Description     *     * @var string     */    private $description = '';    /**     * Subject     *     * @var string     */    private $subject = '';    /**     * Keywords     *     * @var string     */    private $keywords = '';    /**     * Category     *     * @var string     */    private $category = '';    /**     * Manager     *     * @var string     */    private $manager = '';    /**     * Company     *     * @var string     */    private $company = 'Microsoft Corporation';    /**     * Custom Properties     *     * @var string     */    private $customProperties = array();    /**     * Create a new PHPExcel_DocumentProperties     */    public function __construct()    {        // Initialise values        $this->lastModifiedBy = $this->creator;        $this->created  = time();        $this->modified = time();    }    /**     * Get Creator     *     * @return string     */    public function getCreator()    {        return $this->creator;    }    /**     * Set Creator     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setCreator($pValue = '')    {        $this->creator = $pValue;        return $this;    }    /**     * Get Last Modified By     *     * @return string     */    public function getLastModifiedBy()    {        return $this->lastModifiedBy;    }    /**     * Set Last Modified By     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setLastModifiedBy($pValue = '')    {        $this->lastModifiedBy = $pValue;        return $this;    }    /**     * Get Created     *     * @return datetime     */    public function getCreated()    {        return $this->created;    }    /**     * Set Created     *     * @param datetime $pValue     * @return PHPExcel_DocumentProperties     */    public function setCreated($pValue = null)    {        if ($pValue === null) {            $pValue = time();        } elseif (is_string($pValue)) {            if (is_numeric($pValue)) {                $pValue = intval($pValue);            } else {                $pValue = strtotime($pValue);            }        }        $this->created = $pValue;        return $this;    }    /**     * Get Modified     *     * @return datetime     */    public function getModified()    {        return $this->modified;    }    /**     * Set Modified     *     * @param datetime $pValue     * @return PHPExcel_DocumentProperties     */    public function setModified($pValue = null)    {        if ($pValue === null) {            $pValue = time();        } elseif (is_string($pValue)) {            if (is_numeric($pValue)) {                $pValue = intval($pValue);            } else {                $pValue = strtotime($pValue);            }        }        $this->modified = $pValue;        return $this;    }    /**     * Get Title     *     * @return string     */    public function getTitle()    {        return $this->title;    }    /**     * Set Title     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setTitle($pValue = '')    {        $this->title = $pValue;        return $this;    }    /**     * Get Description     *     * @return string     */    public function getDescription()    {        return $this->description;    }    /**     * Set Description     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setDescription($pValue = '')    {        $this->description = $pValue;        return $this;    }    /**     * Get Subject     *     * @return string     */    public function getSubject()    {        return $this->subject;    }    /**     * Set Subject     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setSubject($pValue = '')    {        $this->subject = $pValue;        return $this;    }    /**     * Get Keywords     *     * @return string     */    public function getKeywords()    {        return $this->keywords;    }    /**     * Set Keywords     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setKeywords($pValue = '')    {        $this->keywords = $pValue;        return $this;    }    /**     * Get Category     *     * @return string     */    public function getCategory()    {        return $this->category;    }    /**     * Set Category     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setCategory($pValue = '')    {        $this->category = $pValue;        return $this;    }    /**     * Get Company     *     * @return string     */    public function getCompany()    {        return $this->company;    }    /**     * Set Company     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setCompany($pValue = '')    {        $this->company = $pValue;        return $this;    }    /**     * Get Manager     *     * @return string     */    public function getManager()    {        return $this->manager;    }    /**     * Set Manager     *     * @param string $pValue     * @return PHPExcel_DocumentProperties     */    public function setManager($pValue = '')    {        $this->manager = $pValue;        return $this;    }    /**     * Get a List of Custom Property Names     *     * @return array of string     */    public function getCustomProperties()    {        return array_keys($this->customProperties);    }    /**     * Check if a Custom Property is defined     *     * @param string $propertyName     * @return boolean     */    public function isCustomPropertySet($propertyName)    {        return isset($this->customProperties[$propertyName]);    }    /**     * Get a Custom Property Value     *     * @param string $propertyName     * @return string     */    public function getCustomPropertyValue($propertyName)    {        if (isset($this->customProperties[$propertyName])) {            return $this->customProperties[$propertyName]['value'];        }    }    /**     * Get a Custom Property Type     *     * @param string $propertyName     * @return string     */    public function getCustomPropertyType($propertyName)    {        if (isset($this->customProperties[$propertyName])) {            return $this->customProperties[$propertyName]['type'];        }    }    /**     * Set a Custom Property     *     * @param string $propertyName     * @param mixed $propertyValue     * @param string $propertyType     *      'i'    : Integer     *   'f' : Floating Point     *   's' : String     *   'd' : Date/Time     *   'b' : Boolean     * @return PHPExcel_DocumentProperties     */    public function setCustomProperty($propertyName, $propertyValue = '', $propertyType = null)    {        if (($propertyType === null) || (!in_array($propertyType, array(self::PROPERTY_TYPE_INTEGER,                                                                        self::PROPERTY_TYPE_FLOAT,                                                                        self::PROPERTY_TYPE_STRING,                                                                        self::PROPERTY_TYPE_DATE,                                                                        self::PROPERTY_TYPE_BOOLEAN)))) {            if ($propertyValue === null) {                $propertyType = self::PROPERTY_TYPE_STRING;            } elseif (is_float($propertyValue)) {                $propertyType = self::PROPERTY_TYPE_FLOAT;            } elseif (is_int($propertyValue)) {                $propertyType = self::PROPERTY_TYPE_INTEGER;            } elseif (is_bool($propertyValue)) {                $propertyType = self::PROPERTY_TYPE_BOOLEAN;            } else {                $propertyType = self::PROPERTY_TYPE_STRING;            }        }        $this->customProperties[$propertyName] = array(            'value' => $propertyValue,            'type' => $propertyType        );        return $this;    }    /**     * Implement PHP __clone to create a deep clone, not just a shallow copy.     */    public function __clone()    {        $vars = get_object_vars($this);        foreach ($vars as $key => $value) {            if (is_object($value)) {                $this->$key = clone $value;            } else {                $this->$key = $value;            }        }    }    public static function convertProperty($propertyValue, $propertyType)    {        switch ($propertyType) {            case 'empty':     //    Empty                return '';                break;            case 'null':      //    Null                return null;                break;            case 'i1':        //    1-Byte Signed Integer            case 'i2':        //    2-Byte Signed Integer            case 'i4':        //    4-Byte Signed Integer            case 'i8':        //    8-Byte Signed Integer            case 'int':       //    Integer                return (int) $propertyValue;                break;            case 'ui1':       //    1-Byte Unsigned Integer            case 'ui2':       //    2-Byte Unsigned Integer            case 'ui4':       //    4-Byte Unsigned Integer            case 'ui8':       //    8-Byte Unsigned Integer            case 'uint':      //    Unsigned Integer                return abs((int) $propertyValue);                break;            case 'r4':        //    4-Byte Real Number            case 'r8':        //    8-Byte Real Number            case 'decimal':   //    Decimal                return (float) $propertyValue;                break;            case 'lpstr':     //    LPSTR            case 'lpwstr':    //    LPWSTR            case 'bstr':      //    Basic String                return $propertyValue;                break;            case 'date':      //    Date and Time            case 'filetime':  //    File Time                return strtotime($propertyValue);                break;            case 'bool':     //    Boolean                return ($propertyValue == 'true') ? true : false;                break;            case 'cy':       //    Currency            case 'error':    //    Error Status Code            case 'vector':   //    Vector            case 'array':    //    Array            case 'blob':     //    Binary Blob            case 'oblob':    //    Binary Blob Object            case 'stream':   //    Binary Stream            case 'ostream':  //    Binary Stream Object            case 'storage':  //    Binary Storage            case 'ostorage': //    Binary Storage Object            case 'vstream':  //    Binary Versioned Stream            case 'clsid':    //    Class ID            case 'cf':       //    Clipboard Data                return $propertyValue;                break;        }        return $propertyValue;    }    public static function convertPropertyType($propertyType)    {        switch ($propertyType) {            case 'i1':       //    1-Byte Signed Integer            case 'i2':       //    2-Byte Signed Integer            case 'i4':       //    4-Byte Signed Integer            case 'i8':       //    8-Byte Signed Integer            case 'int':      //    Integer            case 'ui1':      //    1-Byte Unsigned Integer            case 'ui2':      //    2-Byte Unsigned Integer            case 'ui4':      //    4-Byte Unsigned Integer            case 'ui8':      //    8-Byte Unsigned Integer            case 'uint':     //    Unsigned Integer                return self::PROPERTY_TYPE_INTEGER;                break;            case 'r4':       //    4-Byte Real Number            case 'r8':       //    8-Byte Real Number            case 'decimal':  //    Decimal                return self::PROPERTY_TYPE_FLOAT;                break;            case 'empty':    //    Empty            case 'null':     //    Null            case 'lpstr':    //    LPSTR            case 'lpwstr':   //    LPWSTR            case 'bstr':     //    Basic String                return self::PROPERTY_TYPE_STRING;                break;            case 'date':     //    Date and Time            case 'filetime': //    File Time                return self::PROPERTY_TYPE_DATE;                break;            case 'bool':     //    Boolean                return self::PROPERTY_TYPE_BOOLEAN;                break;            case 'cy':       //    Currency            case 'error':    //    Error Status Code            case 'vector':   //    Vector            case 'array':    //    Array            case 'blob':     //    Binary Blob            case 'oblob':    //    Binary Blob Object            case 'stream':   //    Binary Stream            case 'ostream':  //    Binary Stream Object            case 'storage':  //    Binary Storage            case 'ostorage': //    Binary Storage Object            case 'vstream':  //    Binary Versioned Stream            case 'clsid':    //    Class ID            case 'cf':       //    Clipboard Data                return self::PROPERTY_TYPE_UNKNOWN;                break;        }        return self::PROPERTY_TYPE_UNKNOWN;    }}",0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
211,PHPOffice_PHPExcel_DocumentProperties_234, Create a new PHPExcel_DocumentProperties\\\\\\\\n, Kreiranje novog PHPExcel_DocumentProperties,    public function __construct()    {        // Initialise values        $this->lastModifiedBy = $this->creator;        $this->created  = time();        $this->modified = time();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
212,PHPOffice_PHPExcel_Exception_260, PHPExcel_Exception\\\\n\\\\n @category   PHPExcel\\\\n @package    PHPExcel\\\\n @copyright  Copyright (c) 2006 - 2015 PHPExcel (http://www.codeplex.com/PHPExcel)\\\\n, PHPExcel_Exception,"class PHPExcel_Exception extends Exception{    /**     * Error handler callback     *     * @param mixed $code     * @param mixed $string     * @param mixed $file     * @param mixed $line     * @param mixed $context     */    public static function errorHandlerCallback($code, $string, $file, $line, $context)    {        $e = new self($string, $code);        $e->line = $line;        $e->file = $file;        throw $e;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
213,PHPOffice_PHPExcel_Exception_261, Error handler callback\\n\\n @param mixed $code\\n @param mixed $string\\n @param mixed $file\\n @param mixed $line\\n @param mixed $context\\n,Povratni poziv za obradu greške,"    public static function errorHandlerCallback($code, $string, $file, $line, $context)    {        $e = new self($string, $code);        $e->line = $line;        $e->file = $file;        throw $e;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
214,PHPOffice_PHPExcel_PHPExcel_105, Check if a sheet with a specified name already exists\\\\n\\\\n @param  string $pSheetName  Name of the worksheet to check\\\\n @return boolean\\\\n,Proverava da li tabela sa navedenim imenom vec? postoji,    public function sheetNameExists($pSheetName)    {        return ($this->getSheetByName($pSheetName) !== null);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
215,PHPOffice_PHPExcel_PHPExcel_108, Set index for sheet by sheet name.\\n\\n @param  string $sheetName Sheet name to modify index for\\n @param  int $newIndex New index for the sheet\\n @return int New sheet index\\n @throws PHPExcel_Exception\\n,Podešavanje indeks za list na osnovu imenu lista.,"    public function setIndexByName($sheetName, $newIndex)    {        $oldIndex = $this->getIndex($this->getSheetByName($sheetName));        $pSheet = array_splice(            $this->workSheetCollection,            $oldIndex,            1        );        array_splice(            $this->workSheetCollection,            $newIndex,            0,            $pSheet        );        return $newIndex;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
216,PHPOffice_PHPExcel_PHPExcel_109, Get sheet count\n\n @return int\n,Vra?a broj listova,    public function getSheetCount()    {        return count($this->workSheetCollection);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
217,PHPOffice_PHPExcel_PHPExcel_111, Get sheet names\n\n @return string[]\n,Vra?a nazive listova,    public function getSheetNames()    {        $returnValue = array();        $worksheetCount = $this->getSheetCount();        for ($i = 0; $i < $worksheetCount; ++$i) {            $returnValue[] = $this->getSheet($i)->getTitle();        }        return $returnValue;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
218,PHPOffice_PHPExcel_PHPExcel_113, Add named range\\n\\n @param  PHPExcel_NamedRange $namedRange\\n @return boolean\\n,Dodaje imenovani ospeg,    public function addNamedRange(PHPExcel_NamedRange $namedRange)    {        if ($namedRange->getScope() == null) {            // global scope            $this->namedRanges[$namedRange->getName()] = $namedRange;        } else {            // local scope            $this->namedRanges[$namedRange->getScope()->getTitle().'!'.$namedRange->getName()] = $namedRange;        }        return true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
219,PHPOffice_PHPExcel_PHPExcel_114, Get worksheet iterator\\n\\n @return PHPExcel_WorksheetIterator\\n,Vra?a iterator radnog lista,    public function getWorksheetIterator()    {        return new PHPExcel_WorksheetIterator($this);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
220,PHPOffice_PHPExcel_PHPExcel_115, Copy workbook (!= clone!)\\\\n\\\\n @return PHPExcel\\\\n,Kopiranje radne knjige (!= klona),    public function copy()    {        $copied = clone $this;        $worksheetCount = count($this->workSheetCollection);        for ($i = 0; $i < $worksheetCount; ++$i) {            $this->workSheetCollection[$i] = $this->workSheetCollection[$i]->copy();            $this->workSheetCollection[$i]->rebindParent($this);        }        return $copied;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
221,PHPOffice_PHPExcel_PHPExcel_119, Add a cellXf to the workbook\\\\n\\\\n @param PHPExcel_Style $style\\\\n,Dodavanje cellXf u radnu knjigu,    public function addCellXf(PHPExcel_Style $style)    {        $this->cellXfCollection[] = $style;        $style->setIndex(count($this->cellXfCollection) - 1);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
222,PHPOffice_PHPExcel_PHPExcel_120, Get the cellXf supervisor\n\n @return PHPExcel_Style\n, Vra?a supervizora cellXf,    public function getCellXfSupervisor()    {        return $this->cellXfSupervisor;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
223,PHPOffice_PHPExcel_PHPExcel_121, Get the workbook collection of cellStyleXfs\\\\\\\\n\\\\\\\\n @return PHPExcel_Style[]\\\\\\\\n, Vra?a kolekciju ranih knjiga cellStyleXfs,    public function getCellStyleXfCollection()    {        return $this->cellStyleXfCollection;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
224,PHPOffice_PHPExcel_PHPExcel_89, Is the project signed ?\\n\\n @return boolean true|false\\n, Da li je projekat potpisan?,    public function hasMacrosCertificate()    {        return !is_null($this->macrosCertificate);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
225,PHPOffice_PHPExcel_PHPExcel_91," Remove all macros, certificate from spreadsheet\n\n","Uklanja sve markonaredbe, sertifikate iz tabele",    public function discardMacros()    {        $this->hasMacros=false;        $this->macrosCode=null;        $this->macrosCertificate=null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
226,PHPOffice_PHPExcel_PHPExcel_92, return the extension of a filename. Internal use for a array_map callback (php<5.3 don't like lambda function)\\\\\\\\n\\\\\\\\n,vra?a ekstenziju imena fajla. Interna upotreba je za povratni poziv array_map (php<5.3 se ne svi?aju lambda funkcije),"    private function getExtensionOnly($ThePath)    {        return pathinfo($ThePath, PATHINFO_EXTENSION);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
227,PHPOffice_PHPExcel_PHPExcel_93, This workbook have a custom UI ?\\\\\\\\n\\\\\\\\n @return boolean true|false\\\\\\\\n,Ima li ova radna knjiga prilago?eni korisni?ki interfejs? ,    public function hasRibbon()    {        return !is_null($this->ribbonXMLData);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
228,PHPOffice_PHPExcel_PHPExcel_94, This workbook have additionnal object for the ribbon ?\\\\n\\\\n @return boolean true|false\\\\n,Ima li ova radna knjiga dodatni objekat za vrpcu? ,    public function hasRibbonBinObjects()    {        return !is_null($this->ribbonBinObjects);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
229,PHPOffice_PHPExcel_PHPExcel_98," Disconnect all worksheets from this PHPExcel workbook object,\\n    typically so that the PHPExcel object can be unset\\n\\n"," Odspojiti sve radne listove iz ovog PHPExcel objekta, obi?no da bi se mogao PHPExcel objekat poništiti",    public function disconnectWorksheets()    {        $worksheet = null;        foreach ($this->workSheetCollection as $k => &$worksheet) {            $worksheet->disconnectCells();            $this->workSheetCollection[$k] = null;        }        unset($worksheet);        $this->workSheetCollection = array();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
230,PHPOffice_PHPWord_AbstractCollection_971, Get item by index\\n\\n @param int $index\\n @return \\\\PhpOffice\\\\PhpWord\\\\Element\\\\AbstractContainer\\n,Vra?a stavku na osnovu indeksa,"    public function getItem($index)    {        if (array_key_exists($index, $this->items)) {            return $this->items[$index];        }        return null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
231,PHPOffice_PHPWord_AbstractCollection_974, Get item count\\n\\n @return int\\n,Vra?a broj stavki,    public function countItems()    {        return count($this->items);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
232,PHPOffice_PHPWord_CollectionTest_1048, Test collection\n,Testna kolekcija,"    public function testCollection()    {        $object = new Footnotes();        $object->addItem(new Footnote()); // addItem #1        $this->assertEquals(2, $object->addItem(new Footnote())); // addItem #2. Should returns new item index        $this->assertCount(2, $object->getItems()); // getItems returns array        $this->assertInstanceOf('PhpOffice\\PhpWord\\Element\\Footnote', $object->getItem(1)); // getItem returns object        $this->assertNull($object->getItem(3)); // getItem returns null when invalid index is referenced        $object->setItem(2, null); // Set item #2 to null        $this->assertNull($object->getItem(2)); // Check if it's null    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
233,PHPOffice_PHPWord_FootnotePropertiesTest_1053, Test throws exception if wrong number restart given\\n\\n @expectedException \\\\InvalidArgumentException\\n, Test izbacuje izuzetak ako je pogrešan broj restarta dat,    public function testWrongNumRestart()    {        $footnoteProp = new FootnoteProperties();        $footnoteProp->setNumRestart(NumberFormat::LOWER_ROMAN);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
234,PHPOffice_PHPWord_IOFactory_872, Check if it's a concrete class (not abstract nor interface)\\n\\n @param string $class\\n @return bool\\n,Porverava da li je konkretna klasa (da nije apstraktna ni interfejs) ,    private static function isConcreteClass($class)    {        $reflection = new \ReflectionClass($class);        return !$reflection->isAbstract() && !$reflection->isInterface();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
235,PHPOffice_PHPWord_MediaTest_985, Get header media elements\\n,Vra?a elemente zaglavalja medija,"    public function testGetHeaderMediaElementsWithNull()    {        $this->assertEquals(array(), Media::getElements('header'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
236,PHPOffice_PHPWord_MediaTest_986, Get footer media elements\n,Vra?a elemente podnožja medija,"    public function testGetFooterMediaElementsWithNull()    {        $this->assertEquals(array(), Media::getElements('footer'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
237,PHPOffice_PHPWord_MediaTest_987, Count section media elements\n,Broji elemente medija u odeljku,"    public function testCountSectionMediaElementsWithNull()    {        $this->assertEquals(0, Media::countElements('section'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
238,PHPOffice_PHPWord_MediaTest_990, Add header media element\\n, Add header media element,"    public function testAddHeaderMediaElement()    {        $local = __DIR__ . '/_files/images/mars.jpg';        $remote = self::getRemoteImageUrl();        Media::addElement('header1', 'image', $local, new Image($local));        Media::addElement('header1', 'image', $local, new Image($local));        Media::addElement('header1', 'image', $remote, new Image($remote));        $this->assertCount(2, Media::getElements('header1'));        $this->assertEmpty(Media::getElements('header2'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
239,PHPOffice_PHPWord_MediaTest_992, Add image element exception\n\n @expectedException \\Exception\n @expectedExceptionMessage Image object not assigned.\n,Dodaje izuzetak elementa slike,"    public function testAddElementImageException()    {        Media::addElement('section', 'image', __DIR__ . '/_files/images/mars.jpg');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
240,PHPOffice_PHPWord_Media_878, Get Footer Media Elements Count\n\n @deprecated 0.10.0\n\n @param string $key\n\n @return int\n\n @codeCoverageIgnore\n,Vra?a broj podnožja elemenata medija ,    public static function countFooterMediaElements($key)    {        return self::countElements($key);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
241,PHPOffice_PHPWord_PhpWordTest_1001, Test load template\n\n @deprecated 0.12.0\n,Šablon za probno optere?enje,"    public function testLoadTemplate()    {        $templateFqfn = __DIR__ . '/_files/templates/blank.docx';        $phpWord = new PhpWord();        $this->assertInstanceOf(            'PhpOffice\\PhpWord\\TemplateProcessor',            $phpWord->loadTemplate($templateFqfn)        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
242,PHPOffice_PHPWord_PhpWordTest_1003, Test save\\n,Testno ?uvanje,"    public function testSave()    {        $this->setOutputCallback(function () {        });        $phpWord = new PhpWord();        $section = $phpWord->addSection();        $section->addText('Hello world!');        $this->assertTrue($phpWord->save('test.docx', 'Word2007', true));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
243,PHPOffice_PHPWord_PhpWordTest_1004, Test calling undefined method\\n\\n @expectedException \\\\BadMethodCallException\\n @expectedExceptionMessage is not defined\\n,Testno pozvianje nedefinisane metode,    public function testCallUndefinedMethod()    {        $phpWord = new PhpWord();        $phpWord->undefinedMethod();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
244,PHPOffice_PHPWord_PhpWordTest_995, Test create/get section\\n,Test kreiranje/pribavljanje sekcije,"    public function testCreateGetSections()    {        $phpWord = new PhpWord();        $phpWord->addSection();        $this->assertCount(1, $phpWord->getSections());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
245,PHPOffice_PHPWord_PhpWordTest_997, Test set/get default font size\\n,Test postavljanje/vra?anje zadate veli?ine fonta,"    public function testSetGetDefaultFontSize()    {        $phpWord = new PhpWord();        $fontSize = 16;        $this->assertEquals(Settings::DEFAULT_FONT_SIZE, $phpWord->getDefaultFontSize());        $phpWord->setDefaultFontSize($fontSize);        $this->assertEquals($fontSize, $phpWord->getDefaultFontSize());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
246,PHPOffice_PHPWord_PhpWordTest_999, Test add styles\\n, Test dodavanje stila,"    public function testAddStyles()    {        $phpWord = new PhpWord();        $styles = array(            'Paragraph' => 'Paragraph',            'Font'      => 'Font',            'Table'     => 'Table',            'Link'      => 'Font',        );        foreach ($styles as $key => $value) {            $method = ""add{$key}Style"";            $styleId = ""{$key} Style"";            $phpWord->$method($styleId, array());            $this->assertInstanceOf(""PhpOffice\\PhpWord\\Style\\{$value}"", Style::getStyle($styleId));        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
247,PHPOffice_PHPWord_PhpWord_880," PHPWord main class\\n\\n @method Collection\\\\Titles getTitles()\\n @method Collection\\\\Footnotes getFootnotes()\\n @method Collection\\\\Endnotes getEndnotes()\\n @method Collection\\\\Charts getCharts()\\n @method Collection\\\\Comments getComments()\\n @method int addBookmark(Element\\\\Bookmark $bookmark)\\n @method int addTitle(Element\\\\Title $title)\\n @method int addFootnote(Element\\\\Footnote $footnote)\\n @method int addEndnote(Element\\\\Endnote $endnote)\\n @method int addChart(Element\\\\Chart $chart)\\n @method int addComment(Element\\\\Comment $comment)\\n\\n @method Style\\\\Paragraph addParagraphStyle(string $styleName, mixed $styles)\\n @method Style\\\\Font addFontStyle(string $styleName, mixed $fontStyle, mixed $paragraphStyle = null)\\n @method Style\\\\Font addLinkStyle(string $styleName, mixed $styles)\\n @method Style\\\\Font addTitleStyle(mixed $depth, mixed $fontStyle, mixed $paragraphStyle = null)\\n @method Style\\\\Table addTableStyle(string $styleName, mixed $styleTable, mixed $styleFirstRow = null)\\n @method Style\\\\Numbering addNumberingStyle(string $styleName, mixed $styles)\\n", PHPWord main class,"class PhpWord{    /**     * Default font settings     *     * @deprecated 0.11.0 Use Settings constants     *     * @const string|int     */    const DEFAULT_FONT_NAME = Settings::DEFAULT_FONT_NAME;    /**     * @deprecated 0.11.0 Use Settings constants     */    const DEFAULT_FONT_SIZE = Settings::DEFAULT_FONT_SIZE;    /**     * @deprecated 0.11.0 Use Settings constants     */    const DEFAULT_FONT_COLOR = Settings::DEFAULT_FONT_COLOR;    /**     * @deprecated 0.11.0 Use Settings constants     */    const DEFAULT_FONT_CONTENT_TYPE = Settings::DEFAULT_FONT_CONTENT_TYPE;    /**     * Collection of sections     *     * @var \PhpOffice\PhpWord\Element\Section[]     */    private $sections = array();    /**     * Collections     *     * @var array     */    private $collections = array();    /**     * Metadata     *     * @var array     * @since 0.12.0     */    private $metadata = array();    /**     * Create new instance     *     * Collections are created dynamically     */    public function __construct()    {        // Reset Media and styles        Media::resetElements();        Style::resetStyles();        // Collection        $collections = array('Bookmarks', 'Titles', 'Footnotes', 'Endnotes', 'Charts', 'Comments');        foreach ($collections as $collection) {            $class = 'PhpOffice\\PhpWord\\Collection\\' . $collection;            $this->collections[$collection] = new $class();        }        // Metadata        $metadata = array('DocInfo', 'Settings', 'Compatibility');        foreach ($metadata as $meta) {            $class = 'PhpOffice\\PhpWord\\Metadata\\' . $meta;            $this->metadata[$meta] = new $class();        }    }    /**     * Dynamic function call to reduce static dependency     *     * @since 0.12.0     *     * @param mixed $function     * @param mixed $args     *     * @throws \BadMethodCallException     *     * @return mixed     */    public function __call($function, $args)    {        $function = strtolower($function);        $getCollection = array();        $addCollection = array();        $addStyle = array();        $collections = array('Bookmark', 'Title', 'Footnote', 'Endnote', 'Chart', 'Comment');        foreach ($collections as $collection) {            $getCollection[] = strtolower(""get{$collection}s"");            $addCollection[] = strtolower(""add{$collection}"");        }        $styles = array('Paragraph', 'Font', 'Table', 'Numbering', 'Link', 'Title');        foreach ($styles as $style) {            $addStyle[] = strtolower(""add{$style}Style"");        }        // Run get collection method        if (in_array($function, $getCollection)) {            $key = ucfirst(str_replace('get', '', $function));            return $this->collections[$key];        }        // Run add collection item method        if (in_array($function, $addCollection)) {            $key = ucfirst(str_replace('add', '', $function) . 's');            /** @var \PhpOffice\PhpWord\Collection\AbstractCollection $collectionObject */            $collectionObject = $this->collections[$key];            return $collectionObject->addItem(isset($args[0]) ? $args[0] : null);        }        // Run add style method        if (in_array($function, $addStyle)) {            return forward_static_call_array(array('PhpOffice\\PhpWord\\Style', $function), $args);        }        // Exception        throw new \BadMethodCallException(""Method $function is not defined."");    }    /**     * Get document properties object     *     * @return \PhpOffice\PhpWord\Metadata\DocInfo     */    public function getDocInfo()    {        return $this->metadata['DocInfo'];    }    /**     * Get protection     *     * @return \PhpOffice\PhpWord\Metadata\Protection     * @since 0.12.0     * @deprecated Get the Document protection from PhpWord->getSettings()->getDocumentProtection();     * @codeCoverageIgnore     */    public function getProtection()    {        return $this->getSettings()->getDocumentProtection();    }    /**     * Get compatibility     *     * @return \PhpOffice\PhpWord\Metadata\Compatibility     * @since 0.12.0     */    public function getCompatibility()    {        return $this->metadata['Compatibility'];    }    /**     * Get compatibility     *     * @return \PhpOffice\PhpWord\Metadata\Settings     * @since 0.14.0     */    public function getSettings()    {        return $this->metadata['Settings'];    }    /**     * Get all sections     *     * @return \PhpOffice\PhpWord\Element\Section[]     */    public function getSections()    {        return $this->sections;    }    /**     * Returns the section at the requested position     *     * @param int $index     * @return \PhpOffice\PhpWord\Element\Section|null     */    public function getSection($index)    {        if (array_key_exists($index, $this->sections)) {            return $this->sections[$index];        }        return null;    }    /**     * Create new section     *     * @param array $style     * @return \PhpOffice\PhpWord\Element\Section     */    public function addSection($style = null)    {        $section = new Section(count($this->sections) + 1, $style);        $section->setPhpWord($this);        $this->sections[] = $section;        return $section;    }    /**     * Sorts the sections using the callable passed     *     * @see http://php.net/manual/en/function.usort.php for usage     * @param callable $sorter     */    public function sortSections($sorter)    {        usort($this->sections, $sorter);    }    /**     * Get default font name     *     * @return string     */    public function getDefaultFontName()    {        return Settings::getDefaultFontName();    }    /**     * Set default font name.     *     * @param string $fontName     */    public function setDefaultFontName($fontName)    {        Settings::setDefaultFontName($fontName);    }    /**     * Get default font size     *     * @return int     */    public function getDefaultFontSize()    {        return Settings::getDefaultFontSize();    }    /**     * Set default font size.     *     * @param int $fontSize     */    public function setDefaultFontSize($fontSize)    {        Settings::setDefaultFontSize($fontSize);    }    /**     * Set default paragraph style definition to styles.xml     *     * @param array $styles Paragraph style definition     * @return \PhpOffice\PhpWord\Style\Paragraph     */    public function setDefaultParagraphStyle($styles)    {        return Style::setDefaultParagraphStyle($styles);    }    /**     * Load template by filename     *     * @deprecated 0.12.0 Use `new TemplateProcessor($documentTemplate)` instead.     *     * @param  string $filename Fully qualified filename     *     * @throws \PhpOffice\PhpWord\Exception\Exception     *     * @return TemplateProcessor     *     * @codeCoverageIgnore     */    public function loadTemplate($filename)    {        if (file_exists($filename)) {            return new TemplateProcessor($filename);        }        throw new Exception(""Template file {$filename} not found."");    }    /**     * Save to file or download     *     * All exceptions should already been handled by the writers     *     * @param string $filename     * @param string $format     * @param bool $download     * @return bool     */    public function save($filename, $format = 'Word2007', $download = false)    {        $mime = array(            'Word2007'  => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',            'ODText'    => 'application/vnd.oasis.opendocument.text',            'RTF'       => 'application/rtf',            'HTML'      => 'text/html',            'PDF'       => 'application/pdf',        );        $writer = IOFactory::createWriter($this, $format);        if ($download === true) {            header('Content-Description: File Transfer');            header('Content-Disposition: attachment; filename=""' . $filename . '""');            header('Content-Type: ' . $mime[$format]);            header('Content-Transfer-Encoding: binary');            header('Cache-Control: must-revalidate, post-check=0, pre-check=0');            header('Expires: 0');            $filename = 'php://output'; // Change filename to force download        }        $writer->save($filename);        return true;    }    /**     * Create new section     *     * @deprecated 0.10.0     *     * @param array $settings     *     * @return \PhpOffice\PhpWord\Element\Section     *     * @codeCoverageIgnore     */    public function createSection($settings = null)    {        return $this->addSection($settings);    }    /**     * Get document properties object     *     * @deprecated 0.12.0     *     * @return \PhpOffice\PhpWord\Metadata\DocInfo     *     * @codeCoverageIgnore     */    public function getDocumentProperties()    {        return $this->getDocInfo();    }    /**     * Set document properties object     *     * @deprecated 0.12.0     *     * @param \PhpOffice\PhpWord\Metadata\DocInfo $documentProperties     *     * @return self     *     * @codeCoverageIgnore     */    public function setDocumentProperties($documentProperties)    {        $this->metadata['Document'] = $documentProperties;        return $this;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
248,PHPOffice_PHPWord_PhpWord_889, Returns the section at the requested position\n\n @param int $index\n @return \\PhpOffice\\PhpWord\\Element\\Section|null\n,Vra?a odeljak na traženoj poziciji,"    public function getSection($index)    {        if (array_key_exists($index, $this->sections)) {            return $this->sections[$index];        }        return null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
249,PHPOffice_PHPWord_PhpWord_890, Sorts the sections using the callable passed\n\n @see http://php.net/manual/en/function.usort.php for usage\n @param callable $sorter\n,Sortira odeljke koristec?i prosle?eni poziv,"    public function sortSections($sorter)    {        usort($this->sections, $sorter);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
250,PHPOffice_PHPWord_PhpWord_896, Load template by filename\n\n @deprecated 0.12.0 Use `new TemplateProcessor($documentTemplate)` instead.\n\n @param  string $filename Fully qualified filename\n\n @throws \\PhpOffice\\PhpWord\\Exception\\Exception\n\n @return TemplateProcessor\n\n @codeCoverageIgnore\n,U?itava obrazac prema imenu datoteke,"    public function loadTemplate($filename)    {        if (file_exists($filename)) {            return new TemplateProcessor($filename);        }        throw new Exception(""Template file {$filename} not found."");    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
251,PHPOffice_PHPWord_PhpWord_897, Get document properties object\n\n @deprecated 0.12.0\n\n @return \\PhpOffice\\PhpWord\\Metadata\\DocInfo\n\n @codeCoverageIgnore\n,Vra?a objekat svojstava dokumenta,    public function getDocumentProperties()    {        return $this->getDocInfo();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
252,PHPOffice_PHPWord_ProofStateTest_1057, Test throws exception if wrong spelling proof state value given\\n\\n @expectedException \\\\InvalidArgumentException\\n,Test daje izuzetak ako je data pogrešna vrednost dokaza za pravopis,    public function testWrongSpelling()    {        $pState = new ProofState();        $pState->setSpelling('Wrong');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
253,PHPOffice_PHPWord_SettingsTest_1013, Test set/get PDF renderer\n,Test postavljanje/vra?anje PDF renderera,"    public function testSetGetPdfRenderer()    {        $domPdfPath = realpath(PHPWORD_TESTS_BASE_DIR . '/../vendor/dompdf/dompdf');        $this->assertFalse(Settings::setPdfRenderer('FOO', 'dummy/path'));        $this->assertTrue(Settings::setPdfRenderer(Settings::PDF_RENDERER_DOMPDF, $domPdfPath));        $this->assertEquals(Settings::PDF_RENDERER_DOMPDF, Settings::getPdfRendererName());        $this->assertEquals($domPdfPath, Settings::getPdfRendererPath());        $this->assertFalse(Settings::setPdfRendererPath('dummy/path'));        $this->assertEquals($domPdfPath, Settings::getPdfRendererPath());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
254,PHPOffice_PHPWord_SettingsTest_1014, Test set/get measurement unit\n,Test postavljanje/vra?anje mernih jedinica,"    public function testSetGetMeasurementUnit()    {        $this->assertEquals(Settings::UNIT_TWIP, Settings::getMeasurementUnit());        $this->assertFalse(Settings::setMeasurementUnit('foo'));        $this->assertEquals(Settings::UNIT_TWIP, Settings::getMeasurementUnit());        $this->assertTrue(Settings::setMeasurementUnit(Settings::UNIT_INCH));        $this->assertEquals(Settings::UNIT_INCH, Settings::getMeasurementUnit());        $this->assertFalse(Settings::setMeasurementUnit('foo'));        $this->assertEquals(Settings::UNIT_INCH, Settings::getMeasurementUnit());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
255,PHPOffice_PHPWord_SettingsTest_1017, Test set/get default font name\\n,Test postavljanje/vra?anje podrazumevanog imena fonta,"    public function testSetGetDefaultFontName()    {        $this->assertEquals(Settings::DEFAULT_FONT_NAME, Settings::getDefaultFontName());        $this->assertFalse(Settings::setDefaultFontName(' '));        $this->assertEquals(Settings::DEFAULT_FONT_NAME, Settings::getDefaultFontName());        $this->assertTrue(Settings::setDefaultFontName('Times New Roman'));        $this->assertEquals('Times New Roman', Settings::getDefaultFontName());        $this->assertFalse(Settings::setDefaultFontName(' '));        $this->assertEquals('Times New Roman', Settings::getDefaultFontName());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
256,PHPOffice_PHPWord_SettingsTest_1020, Test load config\n, Test u?itavanja konfiguracije,"    public function testLoadConfig()    {        $expected = array(            'compatibility'         => true,            'zipClass'              => 'ZipArchive',            'pdfRendererName'       => 'DomPDF',            'pdfRendererPath'       => '',            'defaultFontName'       => 'Arial',            'defaultFontSize'       => 10,            'outputEscapingEnabled' => false,            'defaultPaper'          => 'A4',        );        // Test default value        $this->assertEquals($expected, Settings::loadConfig());        // Test with valid file        $this->assertEquals($expected, Settings::loadConfig(__DIR__ . '/../../phpword.ini.dist'));        foreach ($expected as $key => $value) {            if ($key === 'compatibility') {                $meth = 'hasCompatibility';            } elseif ($key === 'outputEscapingEnabled') {                $meth = 'isOutputEscapingEnabled';            } else {                $meth = 'get' . ucfirst($key);            }            $this->assertEquals(Settings::$meth(), $value);        }        // Test with invalid file        $this->assertEmpty(Settings::loadConfig(__DIR__ . '/../../phpunit.xml.dist'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
257,PHPOffice_PHPWord_Settings_899, PHPWord settings class\n\n @since 0.8.0\n, PHPWord klasa za podešavanje,"class Settings{    /**     * Zip libraries     *     * @const string     */    const ZIPARCHIVE = 'ZipArchive';    const PCLZIP = 'PclZip';    const OLD_LIB = 'PhpOffice\\PhpWord\\Shared\\ZipArchive'; // @deprecated 0.11    /**     * PDF rendering libraries     *     * @const string     */    const PDF_RENDERER_DOMPDF = 'DomPDF';    const PDF_RENDERER_TCPDF = 'TCPDF';    const PDF_RENDERER_MPDF = 'MPDF';    /**     * Measurement units multiplication factor     *     * Applied to:     * - Section: margins, header/footer height, gutter, column spacing     * - Tab: position     * - Indentation: left, right, firstLine, hanging     * - Spacing: before, after     *     * @const string     */    const UNIT_TWIP = 'twip'; // = 1/20 point    const UNIT_CM = 'cm';    const UNIT_MM = 'mm';    const UNIT_INCH = 'inch';    const UNIT_POINT = 'point'; // = 1/72 inch    const UNIT_PICA = 'pica'; // = 1/6 inch = 12 points    /**     * Default font settings     *     * OOXML defined font size values in halfpoints, i.e. twice of what PhpWord     * use, and the conversion will be conducted during XML writing.     */    const DEFAULT_FONT_NAME = 'Arial';    const DEFAULT_FONT_SIZE = 10;    const DEFAULT_FONT_COLOR = '000000';    const DEFAULT_FONT_CONTENT_TYPE = 'default'; // default|eastAsia|cs    const DEFAULT_PAPER = 'A4';    /**     * Compatibility option for XMLWriter     *     * @var bool     */    private static $xmlWriterCompatibility = true;    /**     * Name of the class used for Zip file management     *     * @var string     */    private static $zipClass = self::ZIPARCHIVE;    /**     * Name of the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererName = null;    /**     * Directory Path to the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererPath = null;    /**     * Measurement unit     *     * @var int|float     */    private static $measurementUnit = self::UNIT_TWIP;    /**     * Default font name     *     * @var string     */    private static $defaultFontName = self::DEFAULT_FONT_NAME;    /**     * Default font size     * @var int     */    private static $defaultFontSize = self::DEFAULT_FONT_SIZE;    /**     * Default paper     * @var string     */    private static $defaultPaper = self::DEFAULT_PAPER;    /**     * The user defined temporary directory.     *     * @var string     */    private static $tempDir = '';    /**     * Enables built-in output escaping mechanism.     * Default value is `false` for backward compatibility with versions below 0.13.0.     *     * @var bool     */    private static $outputEscapingEnabled = false;    /**     * Return the compatibility option used by the XMLWriter     *     * @return bool Compatibility     */    public static function hasCompatibility()    {        return self::$xmlWriterCompatibility;    }    /**     * Set the compatibility option used by the XMLWriter     *     * This sets the setIndent and setIndentString for better compatibility     *     * @param bool $compatibility     * @return bool     */    public static function setCompatibility($compatibility)    {        $compatibility = (bool) $compatibility;        self::$xmlWriterCompatibility = $compatibility;        return true;    }    /**     * Get zip handler class     *     * @return string     */    public static function getZipClass()    {        return self::$zipClass;    }    /**     * Set zip handler class     *     * @param  string $zipClass     * @return bool     */    public static function setZipClass($zipClass)    {        if (in_array($zipClass, array(self::PCLZIP, self::ZIPARCHIVE, self::OLD_LIB))) {            self::$zipClass = $zipClass;            return true;        }        return false;    }    /**     * Set details of the external library for rendering PDF files     *     * @param string $libraryName     * @param string $libraryBaseDir     * @return bool Success or failure     */    public static function setPdfRenderer($libraryName, $libraryBaseDir)    {        if (!self::setPdfRendererName($libraryName)) {            return false;        }        return self::setPdfRendererPath($libraryBaseDir);    }    /**     * Return the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererName()    {        return self::$pdfRendererName;    }    /**     * Identify the external library to use for rendering PDF files     *     * @param string $libraryName     * @return bool     */    public static function setPdfRendererName($libraryName)    {        $pdfRenderers = array(self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_MPDF);        if (!in_array($libraryName, $pdfRenderers)) {            return false;        }        self::$pdfRendererName = $libraryName;        return true;    }    /**     * Return the directory path to the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererPath()    {        return self::$pdfRendererPath;    }    /**     * Location of external library to use for rendering PDF files     *     * @param string $libraryBaseDir Directory path to the library's base folder     * @return bool Success or failure     */    public static function setPdfRendererPath($libraryBaseDir)    {        if (false === file_exists($libraryBaseDir) || false === is_readable($libraryBaseDir)) {            return false;        }        self::$pdfRendererPath = $libraryBaseDir;        return true;    }    /**     * Get measurement unit     *     * @return string     */    public static function getMeasurementUnit()    {        return self::$measurementUnit;    }    /**     * Set measurement unit     *     * @param string $value     * @return bool     */    public static function setMeasurementUnit($value)    {        $units = array(self::UNIT_TWIP, self::UNIT_CM, self::UNIT_MM, self::UNIT_INCH,            self::UNIT_POINT, self::UNIT_PICA, );        if (!in_array($value, $units)) {            return false;        }        self::$measurementUnit = $value;        return true;    }    /**     * Sets the user defined path to temporary directory.     *     * @since 0.12.0     *     * @param string $tempDir The user defined path to temporary directory     */    public static function setTempDir($tempDir)    {        self::$tempDir = $tempDir;    }    /**     * Returns path to temporary directory.     *     * @since 0.12.0     *     * @return string     */    public static function getTempDir()    {        if (!empty(self::$tempDir)) {            $tempDir = self::$tempDir;        } else {            $tempDir = sys_get_temp_dir();        }        return $tempDir;    }    /**     * @since 0.13.0     *     * @return bool     */    public static function isOutputEscapingEnabled()    {        return self::$outputEscapingEnabled;    }    /**     * @since 0.13.0     *     * @param bool $outputEscapingEnabled     */    public static function setOutputEscapingEnabled($outputEscapingEnabled)    {        self::$outputEscapingEnabled = $outputEscapingEnabled;    }    /**     * Get default font name     *     * @return string     */    public static function getDefaultFontName()    {        return self::$defaultFontName;    }    /**     * Set default font name     *     * @param string $value     * @return bool     */    public static function setDefaultFontName($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultFontName = $value;            return true;        }        return false;    }    /**     * Get default font size     *     * @return int     */    public static function getDefaultFontSize()    {        return self::$defaultFontSize;    }    /**     * Set default font size     *     * @param int $value     * @return bool     */    public static function setDefaultFontSize($value)    {        $value = (int) $value;        if ($value > 0) {            self::$defaultFontSize = $value;            return true;        }        return false;    }    /**     * Load setting from phpword.yml or phpword.yml.dist     *     * @param string $filename     * @return array     */    public static function loadConfig($filename = null)    {        // Get config file        $configFile = null;        $configPath = __DIR__ . '/../../';        if ($filename !== null) {            $files = array($filename);        } else {            $files = array(""{$configPath}phpword.ini"", ""{$configPath}phpword.ini.dist"");        }        foreach ($files as $file) {            if (file_exists($file)) {                $configFile = realpath($file);                break;            }        }        // Parse config file        $config = array();        if ($configFile !== null) {            $config = @parse_ini_file($configFile);            if ($config === false) {                return $config;            }        }        // Set config value        foreach ($config as $key => $value) {            $method = ""set{$key}"";            if (method_exists(__CLASS__, $method)) {                self::$method($value);            }        }        return $config;    }    /**     * Get default paper     *     * @return string     */    public static function getDefaultPaper()    {        return self::$defaultPaper;    }    /**     * Set default paper     *     * @param string $value     * @return bool     */    public static function setDefaultPaper($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultPaper = $value;            return true;        }        return false;    }    /**     * Return the compatibility option used by the XMLWriter     *     * @deprecated 0.10.0     *     * @codeCoverageIgnore     */    public static function getCompatibility()    {        return self::hasCompatibility();    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
258,PHPOffice_PHPWord_Settings_900, Return the compatibility option used by the XMLWriter\n\n @return bool Compatibility\n,Vra?a opciju kompatibilnosti koju koristi XMLWriter,    public static function hasCompatibility()    {        return self::$xmlWriterCompatibility;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
259,PHPOffice_PHPWord_Settings_901, Set the compatibility option used by the XMLWriter\\n\\n This sets the setIndent and setIndentString for better compatibility\\n\\n @param bool $compatibility\\n @return bool\\n,Postavlja opciju kompatibilnosti koju koristi XMLWriter Ovo postavlja setIndent i setIndentString za bolju kompatibilnost,    public static function setCompatibility($compatibility)    {        $compatibility = (bool) $compatibility;        self::$xmlWriterCompatibility = $compatibility;        return true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
260,PHPOffice_PHPWord_Settings_903, Set zip handler class\\n\\n @param  string $zipClass\\n @return bool\\n,Postavlja klasu zip rukovaoca,"    public static function setZipClass($zipClass)    {        if (in_array($zipClass, array(self::PCLZIP, self::ZIPARCHIVE, self::OLD_LIB))) {            self::$zipClass = $zipClass;            return true;        }        return false;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
261,PHPOffice_PHPWord_Settings_905, Return the PDF Rendering Library.\n\n @return string\n,Vra?a biblioteku za renderovanje PDF fajlova,    public static function getPdfRendererName()    {        return self::$pdfRendererName;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
262,PHPOffice_PHPWord_Settings_906, Identify the external library to use for rendering PDF files\n\n @param string $libraryName\n @return bool\n,Identifikovanje ekternih biblioteka za renderovanje PDF fajlova,"    public static function setPdfRendererName($libraryName)    {        $pdfRenderers = array(self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_MPDF);        if (!in_array($libraryName, $pdfRenderers)) {            return false;        }        self::$pdfRendererName = $libraryName;        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
263,PHPOffice_PHPWord_Settings_908, Location of external library to use for rendering PDF files\n\n @param string $libraryBaseDir Directory path to the library's base folder\n @return bool Success or failure\n,Lokacija eksternih biblioteka za renderovanje PDF fajlova,    public static function setPdfRendererPath($libraryBaseDir)    {        if (false === file_exists($libraryBaseDir) || false === is_readable($libraryBaseDir)) {            return false;        }        self::$pdfRendererPath = $libraryBaseDir;        return true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
264,PHPOffice_PHPWord_Settings_909, Get measurement unit\n\n @return string\n, Vra?a jedinici mere,    public static function getMeasurementUnit()    {        return self::$measurementUnit;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
265,PHPOffice_PHPWord_Settings_916, Set default font name\n\n @param string $value\n @return bool\n,Postavlja podrazumevani naziv fonta,    public static function setDefaultFontName($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultFontName = $value;            return true;        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
266,PHPOffice_PHPWord_Settings_920, Set default paper\\n\\n @param string $value\\n @return bool\\n,Postavlja podrazumevani papir,    public static function setDefaultPaper($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultPaper = $value;            return true;        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
267,PHPOffice_PHPWord_StyleTest_1021, Test class for PhpOffice\\PhpWord\\Style\n\n @coversDefaultClass \\PhpOffice\\PhpWord\\Style\n @runTestsInSeparateProcesses\n, Testna klasa za PhpOffice,"class StyleTest extends \PHPUnit\Framework\TestCase{    /**     * Add and get paragraph, font, link, title, and table styles     *     * @covers ::addParagraphStyle     * @covers ::addFontStyle     * @covers ::addLinkStyle     * @covers ::addNumberingStyle     * @covers ::addTitleStyle     * @covers ::addTableStyle     * @covers ::setDefaultParagraphStyle     * @covers ::countStyles     * @covers ::getStyle     * @covers ::resetStyles     * @covers ::getStyles     * @test     */    public function testStyles()    {        $paragraph = array('alignment' => Jc::CENTER);        $font = array('italic' => true, '_bold' => true);        $table = array('bgColor' => 'CCCCCC');        $numbering = array(            'type'   => 'multilevel',            'levels' => array(                array(                    'start'     => 1,                    'format'    => 'decimal',                    'restart'   => 1,                    'suffix'    => 'space',                    'text'      => '%1.',                    'alignment' => Jc::START,                ),            ),        );        $styles = array(            'Paragraph' => 'Paragraph',            'Font'      => 'Font',            'Link'      => 'Font',            'Table'     => 'Table',            'Heading_1' => 'Font',            'Normal'    => 'Paragraph',            'Numbering' => 'Numbering',        );        Style::addParagraphStyle('Paragraph', $paragraph);        Style::addFontStyle('Font', $font);        Style::addLinkStyle('Link', $font);        Style::addNumberingStyle('Numbering', $numbering);        Style::addTitleStyle(1, $font);        Style::addTableStyle('Table', $table);        Style::setDefaultParagraphStyle($paragraph);        $this->assertCount(count($styles), Style::getStyles());        foreach ($styles as $name => $style) {            $this->assertInstanceOf(""PhpOffice\\PhpWord\\Style\\{$style}"", Style::getStyle($name));        }        $this->assertNull(Style::getStyle('Unknown'));        Style::resetStyles();        $this->assertCount(0, Style::getStyles());    }    /**     * Test default paragraph style     *     * @covers ::setDefaultParagraphStyle     * @test     */    public function testDefaultParagraphStyle()    {        $paragraph = array('alignment' => Jc::CENTER);        Style::setDefaultParagraphStyle($paragraph);        $this->assertInstanceOf('PhpOffice\\PhpWord\\Style\\Paragraph', Style::getStyle('Normal'));    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
268,PHPOffice_PHPWord_Style_922, Style collection\\n,Kolekcija stilova,"class Style{    /**     * Style register     *     * @var array     */    private static $styles = array();    /**     * Add paragraph style     *     * @param string $styleName     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $styles     * @return \PhpOffice\PhpWord\Style\Paragraph     */    public static function addParagraphStyle($styleName, $styles)    {        return self::setStyleValues($styleName, new Paragraph(), $styles);    }    /**     * Add font style     *     * @param string $styleName     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $fontStyle     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $paragraphStyle     * @return \PhpOffice\PhpWord\Style\Font     */    public static function addFontStyle($styleName, $fontStyle, $paragraphStyle = null)    {        return self::setStyleValues($styleName, new Font('text', $paragraphStyle), $fontStyle);    }    /**     * Add link style     *     * @param string $styleName     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $styles     * @return \PhpOffice\PhpWord\Style\Font     */    public static function addLinkStyle($styleName, $styles)    {        return self::setStyleValues($styleName, new Font('link'), $styles);    }    /**     * Add numbering style     *     * @param string $styleName     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $styleValues     * @return \PhpOffice\PhpWord\Style\Numbering     * @since 0.10.0     */    public static function addNumberingStyle($styleName, $styleValues)    {        return self::setStyleValues($styleName, new Numbering(), $styleValues);    }    /**     * Add title style     *     * @param int|null $depth Provide null to set title font     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $fontStyle     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $paragraphStyle     * @return \PhpOffice\PhpWord\Style\Font     */    public static function addTitleStyle($depth, $fontStyle, $paragraphStyle = null)    {        if (empty($depth)) {            $styleName = 'Title';        } else {            $styleName = ""Heading_{$depth}"";        }        return self::setStyleValues($styleName, new Font('title', $paragraphStyle), $fontStyle);    }    /**     * Add table style     *     * @param string $styleName     * @param array $styleTable     * @param array|null $styleFirstRow     * @return \PhpOffice\PhpWord\Style\Table     */    public static function addTableStyle($styleName, $styleTable, $styleFirstRow = null)    {        return self::setStyleValues($styleName, new Table($styleTable, $styleFirstRow), null);    }    /**     * Count styles     *     * @return int     * @since 0.10.0     */    public static function countStyles()    {        return count(self::$styles);    }    /**     * Reset styles.     *     * @since 0.10.0     */    public static function resetStyles()    {        self::$styles = array();    }    /**     * Set default paragraph style     *     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $styles Paragraph style definition     * @return \PhpOffice\PhpWord\Style\Paragraph     */    public static function setDefaultParagraphStyle($styles)    {        return self::addParagraphStyle('Normal', $styles);    }    /**     * Get all styles     *     * @return \PhpOffice\PhpWord\Style\AbstractStyle[]     */    public static function getStyles()    {        return self::$styles;    }    /**     * Get style by name     *     * @param string $styleName     * @return \PhpOffice\PhpWord\Style\AbstractStyle Paragraph|Font|Table|Numbering     */    public static function getStyle($styleName)    {        if (isset(self::$styles[$styleName])) {            return self::$styles[$styleName];        }        return null;    }    /**     * Set style values and put it to static style collection     *     * The $styleValues could be an array or object     *     * @param string $name     * @param \PhpOffice\PhpWord\Style\AbstractStyle $style     * @param array|\PhpOffice\PhpWord\Style\AbstractStyle $value     * @return \PhpOffice\PhpWord\Style\AbstractStyle     */    private static function setStyleValues($name, $style, $value = null)    {        if (!isset(self::$styles[$name])) {            if ($value !== null) {                if (is_array($value)) {                    $style->setStyleByArray($value);                } elseif ($value instanceof AbstractStyle) {                    if (get_class($style) == get_class($value)) {                        $style = $value;                    }                }            }            $style->setStyleName($name);            $style->setIndex(self::countStyles() + 1); // One based index            self::$styles[$name] = $style;        }        return self::getStyle($name);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
269,PHPOffice_PHPWord_Style_923, Add paragraph style\\n\\n @param string $styleName\\n @param array|\\\\PhpOffice\\\\PhpWord\\\\Style\\\\AbstractStyle $styles\\n @return \\\\PhpOffice\\\\PhpWord\\\\Style\\\\Paragraph\\n,Dodavanjee stil pasusa,"    public static function addParagraphStyle($styleName, $styles)    {        return self::setStyleValues($styleName, new Paragraph(), $styles);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
270,PHPOffice_PHPWord_Style_924, Add link style\\n\\n @param string $styleName\\n @param array|\\\\PhpOffice\\\\PhpWord\\\\Style\\\\AbstractStyle $styles\\n @return \\\\PhpOffice\\\\PhpWord\\\\Style\\\\Font\\n,Dodavanje stil veze,"    public static function addLinkStyle($styleName, $styles)    {        return self::setStyleValues($styleName, new Font('link'), $styles);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
271,PHPOffice_PHPWord_Style_926, Count styles\\n\\n @return int\\n @since 0.10.0\\n,Preboj stilove,    public static function countStyles()    {        return count(self::$styles);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
272,PHPOffice_PHPWord_Style_927, Reset styles.\\n\\n @since 0.10.0\\n,Resetuj stilove.,    public static function resetStyles()    {        self::$styles = array();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
273,PHPOffice_PHPWord_TemplateProcessorTest_1042, Template macros can be fixed.\\n\\n @covers ::fixBrokenMacros\\n @test\\n,Makronaredbe šablona mogu se popraviti.,"    public function testFixBrokenMacros()    {        $templateProcessor = new TestableTemplateProcesor();        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>normal text</w:t></w:r>');        $this->assertEquals('<w:r><w:t>normal text</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>${documentContent}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>${documentContent}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>$</w:t><w:t>{documentContent}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>${documentContent}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>$1500</w:t><w:t>${documentContent}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>$1500</w:t><w:t>${documentContent}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>$1500</w:t><w:t>$</w:t><w:t>{documentContent}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>$1500</w:t><w:t>${documentContent}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:r><w:t>25$ plus some info {hint}</w:t></w:r>');        $this->assertEquals('<w:r><w:t>25$ plus some info {hint}</w:t></w:r>', $fixed);        $fixed = $templateProcessor->fixBrokenMacros('<w:t>$</w:t></w:r><w:bookmarkStart w:id=""0"" w:name=""_GoBack""/><w:bookmarkEnd w:id=""0""/><w:r><w:t xml:space=""preserve"">15,000.00. </w:t></w:r><w:r w:rsidR=""0056499B""><w:t>$</w:t></w:r><w:r w:rsidR=""00573DFD"" w:rsidRPr=""00573DFD""><w:rPr><w:iCs/></w:rPr><w:t>{</w:t></w:r><w:proofErr w:type=""spellStart""/><w:r w:rsidR=""00573DFD"" w:rsidRPr=""00573DFD""><w:rPr><w:iCs/></w:rPr><w:t>variable_name</w:t></w:r><w:proofErr w:type=""spellEnd""/><w:r w:rsidR=""00573DFD"" w:rsidRPr=""00573DFD""><w:rPr><w:iCs/></w:rPr><w:t>}</w:t></w:r>');        $this->assertEquals('<w:t>$</w:t></w:r><w:bookmarkStart w:id=""0"" w:name=""_GoBack""/><w:bookmarkEnd w:id=""0""/><w:r><w:t xml:space=""preserve"">15,000.00. </w:t></w:r><w:r w:rsidR=""0056499B""><w:t>${variable_name}</w:t></w:r>', $fixed);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
274,PHPOffice_PHPWord_TemplateProcessor_945, Clone a table row in a template document.\n\n @param string $search\n @param int $numberOfClones\n\n @throws \\PhpOffice\\PhpWord\\Exception\\Exception\n,Kloniranje reda tabele u dokumentu šablona.,"    public function cloneRow($search, $numberOfClones)    {        $search = static::ensureMacroCompleted($search);        $tagPos = strpos($this->tempDocumentMainPart, $search);        if (!$tagPos) {            throw new Exception('Can not clone row, template variable not found or variable contains markup.');        }        $rowStart = $this->findRowStart($tagPos);        $rowEnd = $this->findRowEnd($tagPos);        $xmlRow = $this->getSlice($rowStart, $rowEnd);        // Check if there's a cell spanning multiple rows.        if (preg_match('#<w:vMerge w:val=""restart""/>#', $xmlRow)) {            // $extraRowStart = $rowEnd;            $extraRowEnd = $rowEnd;            while (true) {                $extraRowStart = $this->findRowStart($extraRowEnd + 1);                $extraRowEnd = $this->findRowEnd($extraRowEnd + 1);                // If extraRowEnd is lower then 7, there was no next row found.                if ($extraRowEnd < 7) {                    break;                }                // If tmpXmlRow doesn't contain continue, this row is no longer part of the spanned row.                $tmpXmlRow = $this->getSlice($extraRowStart, $extraRowEnd);                if (!preg_match('#<w:vMerge/>#', $tmpXmlRow) &&                    !preg_match('#<w:vMerge w:val=""continue""\s*/>#', $tmpXmlRow)                ) {                    break;                }                // This row was a spanned row, update $rowEnd and search for the next row.                $rowEnd = $extraRowEnd;            }            $xmlRow = $this->getSlice($rowStart, $rowEnd);        }        $result = $this->getSlice(0, $rowStart);        $result .= implode($this->indexClonedVariables($numberOfClones, $xmlRow));        $result .= $this->getSlice($rowEnd);        $this->tempDocumentMainPart = $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
275,PHPOffice_PHPWord_TemplateProcessor_951, Saves the result document to the user defined file.\n\n @since 0.8.0\n\n @param string $fileName\n,?uvanje dokument rezultata u korisni?ki definisanu datoteku.,"    public function saveAs($fileName)    {        $tempFileName = $this->save();        if (file_exists($fileName)) {            unlink($fileName);        }        /*         * Note: we do not use `rename` function here, because it loses file ownership data on Windows platform.         * As a result, user cannot open the file directly getting ""Access denied"" message.         *         * @see https://github.com/PHPOffice/PHPWord/issues/532         */        copy($tempFileName, $fileName);        unlink($tempFileName);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
276,PHPOffice_PHPWord_TemplateProcessor_953, Find and replace macros in the given XML section.\\n\\n @param mixed $search\\n @param mixed $replace\\n @param string $documentPartXML\\n @param int $limit\\n\\n @return string\\n,Traženje i zamena makronaredbe u datom XML odeljku.,"    protected function setValueForPart($search, $replace, $documentPartXML, $limit)    {        // Note: we can't use the same function for both cases here, because of performance considerations.        if (self::MAXIMUM_REPLACEMENTS_DEFAULT === $limit) {            return str_replace($search, $replace, $documentPartXML);        }        $regExpEscaper = new RegExp();        return preg_replace($regExpEscaper->escape($search), $replace, $documentPartXML, $limit);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
277,PHPOffice_PHPWord_TemplateProcessor_955, Get the name of the header file for $index.\n\n @param int $index\n\n @return string\n,Vra?a naziv datoteke zaglavalja za $index.,"    protected function getHeaderName($index)    {        return sprintf('word/header%d.xml', $index);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
278,PHPOffice_PHPWord_TemplateProcessor_956," Usually, the name of main part document will be 'document.xml'. However, some .docx files (possibly those from Office 365, experienced also on documents from Word Online created from blank templates) have file 'document22.xml' in their zip archive instead of 'document.xml'. This method searches content types file to correctly determine the file name.\n\n @return string\n"," Obi?no c?e naziv glavnog dela dokumenta biti „document.xml“. Me?utim, neke .docx datoteke (možda one iz Office 365, isto se dešava i na dokumentima iz programa Word Online kreiranim iz praznih šablona) imaju u svojoj zip arhivi datoteku 'document22.xml' umesto 'document.xml'. Ova metoda pretražuje datotelu tipova sadržaja da bi na pravi na?in bilo odre?eno ime datoteke.","    protected function getMainPartName()    {        $contentTypes = $this->zipClass->getFromName('[Content_Types].xml');        $pattern = '~PartName=""\/(word\/document.*?\.xml)"" ContentType=""application\/vnd\.openxmlformats-officedocument\.wordprocessingml\.document\.main\+xml""~';        $matches = array();        preg_match($pattern, $contentTypes, $matches);        return array_key_exists(1, $matches) ? $matches[1] : 'word/document.xml';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
279,PHPOffice_PHPWord_TemplateProcessor_958, Get the name of the footer file for $index.\n\n @param int $index\n\n @return string\n,Vra?a ime datoteke podnožja za $index. ,"    protected function getFooterName($index)    {        return sprintf('word/footer%d.xml', $index);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
280,PHPOffice_PHPWord_TemplateProcessor_959, Get the name of the relations file for document part.\n\n @param string $documentPartName\n\n @return string\n,Vra?a ime datoteke sa kojom je dio dokumenta u odnosu. ,"    protected function getRelationsName($documentPartName)    {        return 'word/_rels/' . pathinfo($documentPartName, PATHINFO_BASENAME) . '.rels';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
281,PHPOffice_PHPWord_TemplateProcessor_962, Find the end position of the nearest table row after $offset.\n\n @param int $offset\n\n @return int\n,Traži krajnji položaj najbližeg reda tabele nakon $offset. ,"    protected function findRowEnd($offset)    {        return strpos($this->tempDocumentMainPart, '</w:tr>', $offset) + 7;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
282,PHPOffice_PHPWord_TemplateProcessor_966, Find the nearest block end position after $offset\\n\\n @param int $offset    Search position\\n @param string  $blockType XML Block tag\\n @return int -1 if block end not found\\n,Prona?ite najbliži krajnji položaj bloka nakon $offset,"    protected function findXmlBlockEnd($offset, $blockType)    {        $blockEndStart = strpos($this->tempDocumentMainPart, '</' . $blockType . '>', $offset);        // return position of end of tag if found, otherwise -1        return ($blockEndStart === false) ? -1 : $blockEndStart + 3 + strlen($blockType);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
283,PrestaShop_PrestaShop_Access_764, Find Tab ID by slug.\\\\n\\\\n @param string $authSlug Slug\\\\n\\\\n @return string Tab ID\\\\n @todo: Find out if we should return an int instead. (breaking change)\\\\n,Traži Tab ID po žetonu.,"    public static function findIdTabByAuthSlug($authSlug)    {        preg_match(            '/ROLE_MOD_[A-Z]+_(?P<classname>[A-Z]+)_(?P<auth>[A-Z]+)/',            $authSlug,            $matches        );        $result = Db::getInstance()->getRow('            SELECT `id_tab`            FROM `' . _DB_PREFIX_ . 'tab`            WHERE UCASE(`class_name`) = ""' . $matches['classname'] . '""        ');        return $result['id_tab'];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
284,PrestaShop_PrestaShop_Access_767, Find slug by Module ID.\\\\n\\\\n @param int $idModule Module ID\\\\n\\\\n @return string Full module slug\\\\n,Traži žeton po Module ID.,"    public static function findSlugByIdModule($idModule)    {        $result = Db::getInstance()->getRow('            SELECT `name`            FROM `' . _DB_PREFIX_ . 'module`            WHERE `id_module` = ""' . (int) $idModule . '""        ');        return self::sluggifyModule($result);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
285,PrestaShop_PrestaShop_Access_769," Add access.\\\\n\\\\n @param int $idProfile Profile ID\\\\n @param int $idRole Role ID\\\\n\\\\n @return string Whether access has been successfully granted (""ok"", ""error"")\\\\n",Dodaj pristup.,"    public function addAccess($idProfile, $idRole)    {        $sql = '            INSERT IGNORE INTO `' . _DB_PREFIX_ . 'access` (`id_profile`, `id_authorization_role`)            VALUES (' . (int) $idProfile . ',' . (int) $idRole . ')        ';        return Db::getInstance()->execute($sql) ? 'ok' : 'error';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
286,PrestaShop_PrestaShop_Access_773," Update (legacy) Module access.\n\n @param int $idProfile Profile ID\n @param int $idModule Module ID\n @param string $lgcAuth Legacy authorization\n @param int $enabled Whether module access should be granted\n\n @return string Whether module access has been succesfully changed (""ok"", ""error"")\n",Ažuriranje (zastarelog) pristup modulu.,"    public function updateLgcModuleAccess($idProfile, $idModule, $lgcAuth, $enabled)    {        $idProfile = (int) $idProfile;        $idModule = (int) $idModule;        if ($idModule == -1) {            $slug = 'ROLE_MOD_MODULE_%_';        } else {            $slug = self::findSlugByIdModule($idModule);        }        $whereClauses = [];        foreach ((array) self::getAuthorizationFromLegacy($lgcAuth) as $auth) {            $slugLike = Db::getInstance()->escape($slug . $auth);            $whereClauses[] = ' `slug` LIKE ""' . $slugLike . '""';        }        $roles = Db::getInstance()->executeS('            SELECT `id_authorization_role`            FROM `' . _DB_PREFIX_ . 'authorization_role` t            WHERE ' . implode(' OR ', $whereClauses) . '        ');        $res = [];        foreach ($roles as $role) {            if ($enabled) {                $res[] = $this->addModuleAccess($idProfile, $role['id_authorization_role']);            } else {                $res[] = $this->removeModuleAccess($idProfile, $role['id_authorization_role']);            }        }        return in_array('error', $res) ? 'error' : 'ok';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
287,PrestaShop_PrestaShop_AddressFormat_793, Verify the existence of a field name and check the availability\\n of an association between a field name and a class (ClassName:fieldName)\\n if the separator is overview.\\n\\n @param string $patternName The composition of the class and field name\\n @param string $fieldsValidate The list of available field for the Address class\\n @todo: Why is $fieldsValidate unused?\\n,Proverava da li postoji ime polja i proverava dostupnost asocijacije između nazva polja i kalse (ClassName:fieldName) ako je separator pregledan.,"    protected function _checkLiableAssociation($patternName, $fieldsValidate)    {        $patternName = trim($patternName);        if ($associationName = explode(':', $patternName)) {            $totalNameUsed = count($associationName);            if ($totalNameUsed > 2) {                $this->_errorFormatList[] = $this->trans('This association has too many elements.', [], 'Admin.Notifications.Error');            } elseif ($totalNameUsed == 1) {                $associationName[0] = strtolower($associationName[0]);                if (in_array($associationName[0], self::$forbiddenPropertyList) ||                    !$this->_checkValidateClassField('Address', $associationName[0], false)) {                    $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                    $associationName[0];                }            } elseif ($totalNameUsed == 2) {                if (empty($associationName[0]) || empty($associationName[1])) {                    $this->_errorFormatList[] = $this->trans('Syntax error with this pattern.', [], 'Admin.Notifications.Error') . ': ' . $patternName;                } else {                    $associationName[0] = ucfirst($associationName[0]);                    $associationName[1] = strtolower($associationName[1]);                    if (in_array($associationName[0], self::$forbiddenClassList)) {                        $this->_errorFormatList[] = $this->trans('This name is not allowed.', [], 'Admin.Notifications.Error') . ': ' .                        $associationName[0];                    } else {                        // Check if the id field name exist in the Address class                        // Don't check this attribute on Address (no sense)                        if ($associationName[0] != 'Address') {                            $this->_checkValidateClassField('Address', 'id_' . strtolower($associationName[0]), true);                        }                        // Check if the field name exist in the class write by the user                        $this->_checkValidateClassField($associationName[0], $associationName[1], false);                    }                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
288,PrestaShop_PrestaShop_AddressFormat_795, Checks that all required fields exist in a given fields list.\\\\n Fills _errorFormatList array in case of absence of a required field.\\\\n\\\\n @param array $fieldList\\\\n,Proverava da li sva obavezna polja postoje na datoj listi polja.,"    protected function checkRequiredFields($fieldList)    {        foreach (self::getFieldsRequired() as $requiredField) {            if (!in_array($requiredField, $fieldList)) {                $this->_errorFormatList[] = $this->trans(                    'The %s field (in tab %s) is required.',                    [$requiredField, $this->getFieldTabName($requiredField)],                    'Admin.Notifications.Error');            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
289,PrestaShop_PrestaShop_AddressFormat_798, Set the layout key with the liable value\\\\n example : (firstname) => 'Presta' will result (Presta)\\\\n         : (firstname-lastname) => 'Presta' and 'Shop' result '(Presta-Shop)'.\\\\n,Postavlja klju? izgleda sa odgovornom vrednoš?u,"    protected static function _setOriginalDisplayFormat(&$formattedValueList, $currentLine, $currentKeyList)    {        if ($currentKeyList && is_array($currentKeyList)) {            if ($originalFormattedPatternList = explode(' ', $currentLine)) {                // Foreach the available pattern                foreach ($originalFormattedPatternList as $patternNum => $pattern) {                    // Var allows to modify the good formatted key value when multiple key exist into the same pattern                    $mainFormattedKey = '';                    // Multiple key can be found in the same pattern                    foreach ($currentKeyList as $key) {                        // Check if we need to use an older modified pattern if a key has already be matched before                        $replacedValue = empty($mainFormattedKey) ? $pattern : $formattedValueList[$mainFormattedKey];                        $chars = $start = $end = str_replace($key, '', $replacedValue);                        if (preg_match(self::_CLEANING_REGEX_, $chars)) {                            if (Tools::substr($replacedValue, 0, Tools::strlen($chars)) == $chars) {                                $end = '';                            } else {                                $start = '';                            }                            if ($chars) {                                $replacedValue = str_replace($chars, '', $replacedValue);                            }                        }                        if ($formattedValue = preg_replace('/^' . $key . '$/', $formattedValueList[$key], $replacedValue, -1, $count)) {                            if ($count) {                                // Allow to check multiple key in the same pattern,                                if (empty($mainFormattedKey)) {                                    $mainFormattedKey = $key;                                }                                // Set the pattern value to an empty string if an older key has already been matched before                                if ($mainFormattedKey != $key) {                                    $formattedValueList[$key] = '';                                }                                // Store the new pattern value                                $formattedValueList[$mainFormattedKey] = $start . $formattedValue . $end;                                unset($originalFormattedPatternList[$patternNum]);                            }                        }                    }                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
290,PrestaShop_PrestaShop_AddressFormat_799, Cleaned the layout set by the user.\\\\\\\\n,?isti izgled postavljen od strane korisnika. ,"    public static function cleanOrderedAddress(&$orderedAddressField)    {        foreach ($orderedAddressField as &$line) {            $cleanedLine = '';            if (($keyList = preg_split(self::_CLEANING_REGEX_, $line, -1, PREG_SPLIT_NO_EMPTY))) {                foreach ($keyList as $key) {                    $cleanedLine .= $key . ' ';                }                $cleanedLine = trim($cleanedLine);                $line = $cleanedLine;            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
291,PrestaShop_PrestaShop_AddressFormat_801, Returns selected fields required for an address in an array according to a selection hash.\\n\\n @return array String values\\n,Vrac?a izabrana polja potrebna za adresu u nizu u skladu sa hešom izbora.,"    public static function getValidateFields($className)    {        $propertyList = [];        if (class_exists($className)) {            $object = new $className();            $reflect = new ReflectionObject($object);            // Check if the property is accessible            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                $propertyName = $property->getName();                if ((!in_array($propertyName, AddressFormat::$forbiddenPropertyList)) &&                        (!preg_match('#id|id_\w#', $propertyName))) {                    $propertyList[] = $propertyName;                }            }            unset(                $object,                $reflect            );        }        return $propertyList;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
292,PrestaShop_PrestaShop_AddressFormat_802, Return a list of liable class of the className.\\n\\n @param string $className\\n\\n @return array\\n,Vra?a listu odgovornih klasa className. ,"    public static function getLiableClass($className)    {        $objectList = [];        if (class_exists($className)) {            $object = new $className();            $reflect = new ReflectionObject($object);            // Get all the name object liable to the Address class            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                $propertyName = $property->getName();                if (preg_match('#id_\w#', $propertyName) && strlen($propertyName) > 3) {                    $nameObject = ucfirst(substr($propertyName, 3));                    if (!in_array($nameObject, self::$forbiddenClassList) &&                            class_exists($nameObject)) {                        $objectList[$nameObject] = new $nameObject();                    }                }            }            unset(                $object,                $reflect            );        }        return $objectList;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
293,PrestaShop_PrestaShop_AddressFormat_803," Return a data array containing ordered, formatedValue and object fields.\\\\\\\\n","Vra?a niz podataka koji sadrži ure?ena, formatedValue i polja objekta.","    public static function getFormattedLayoutData($address)    {        $layoutData = [];        if ($address && $address instanceof Address) {            $layoutData['ordered'] = AddressFormat::getOrderedAddressFields((int) $address->id_country);            $layoutData['formated'] = AddressFormat::getFormattedAddressFieldsValues($address, $layoutData['ordered']);            $layoutData['object'] = [];            $reflect = new ReflectionObject($address);            $publicProperties = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);            foreach ($publicProperties as $property) {                if (isset($address->{$property->getName()})) {                    $layoutData['object'][$property->getName()] = $address->{$property->getName()};                }            }        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
294,PrestaShop_PrestaShop_AddressFormat_806, Get Address format from DB.\\\\n\\\\n @param int $idCountry Country ID\\\\n\\\\n @return false|string|null Address format\\\\n\\\\n @since 1.7.0\\\\n,Vra?a format adrese iz DB.,"    protected function getFormatDB($idCountry)    {        if (!Cache::isStored('AddressFormat::getFormatDB' . $idCountry)) {            $format = Db::getInstance()->getValue('SELECT formatFROM `' . _DB_PREFIX_ . $this->def['table'] . '`WHERE `id_country` = ' . (int) $idCountry);            $format = trim($format);            Cache::store('AddressFormat::getFormatDB' . $idCountry, $format);            return $format;        }        return Cache::retrieve('AddressFormat::getFormatDB' . $idCountry);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
295,PrestaShop_PrestaShop_Address_775, reset static cache (eg unit testing purpose).\\n, resetovanje stati?ke keš memorije (npr. u svrhu testiranja jedinice).,    public static function resetStaticCache()    {        static::$_idZones = [];        static::$_idCountries = [];    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
296,PrestaShop_PrestaShop_Address_778, Returns fields required for an address in an array hash.\\\\n\\\\n @return array Hash values\\\\n,Vra?a pptrebna polja za adresu u heširanom nizu.,    public static function getFieldsValidate()    {        $tmp_addr = new Address();        $out = $tmp_addr->fieldsValidate;        unset($tmp_addr);        return $out;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
297,PrestaShop_PrestaShop_Address_780, Check if the Country is active for a given address.\\\\\\\\n\\\\\\\\n @param int $id_address Address ID for which we want to get the Country status\\\\\\\\n\\\\\\\\n @return int Country status\\\\\\\\n,Proverava da li je država aktivna za datu adresu.,"    public static function isCountryActiveById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        $cache_id = 'Address::isCountryActiveById_' . (int) $id_address;        if (!Cache::isStored($cache_id)) {            $result = (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT c.`active`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`WHERE a.`id_address` = ' . (int) $id_address);            Cache::store($cache_id, $result);            return $result;        }        return Cache::retrieve($cache_id);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
298,PrestaShop_PrestaShop_Address_781, Request to check if DNI field is required\\n depending on the current selected country.\\n\\n @param int $idCountry\\n\\n @return bool\\n,Zahtev da e proveri da li je DNI polje obavezno u zavisnoti od izabrane države. ,    public static function dniRequired($idCountry)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT c.`need_identification_number` ' .            'FROM `' . _DB_PREFIX_ . 'country` c ' .            'WHERE c.`id_country` = ' . (int) $idCountry        );    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
299,PrestaShop_PrestaShop_Address_782, Check if Address is used (at least one order placed).\\\\\\\\n\\\\\\\\n @return int Order count for this Address\\\\\\\\n,Proverava da li je adresa koriš?ena (barem jedna narudžba postoji).,    public function isUsed()    {        if ((int) $this->id <= 0) {            return false;        }        $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT COUNT(`id_order`) AS usedFROM `' . _DB_PREFIX_ . 'orders`WHERE `id_address_delivery` = ' . (int) $this->id . 'OR `id_address_invoice` = ' . (int) $this->id);        return $result > 0 ? (int) $result : false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
300,PrestaShop_PrestaShop_Address_783, Get Country and State of this Address.\\n\\n @param int $id_address Address ID\\n\\n @return array\\n,Vra?a državu ove adrese.,"    public static function getCountryAndState($id_address)    {        if (isset(self::$_idCountries[$id_address])) {            return self::$_idCountries[$id_address];        }        if ($id_address) {            $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT `id_country`, `id_state`, `vat_number`, `postcode` FROM `' . _DB_PREFIX_ . 'address`WHERE `id_address` = ' . (int) $id_address);        } else {            $result = false;        }        self::$_idCountries[$id_address] = $result;        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
301,PrestaShop_PrestaShop_Address_784, Specify if an address is already in base.\\\\n\\\\n @param int $id_address Address id\\\\n\\\\n @return bool The address exists\\\\n,Navodi da li adresa ve? postoji u bazi.,"    public static function addressExists($id_address)    {        return (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue(            'SELECT `id_address`             FROM ' . _DB_PREFIX_ . 'address a             WHERE a.`id_address` = ' . (int) $id_address,            false        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
302,PrestaShop_PrestaShop_Address_785, Check if the address is valid.\n\n @param int $id_address Address id\n\n @return bool The address is valid\n,Proverava da li je adresa validna.,    public static function isValid($id_address)    {        $id_address = (int) $id_address;        $isValid = Db::getInstance()->getValue('            SELECT `id_address` FROM ' . _DB_PREFIX_ . 'address a            WHERE a.`id_address` = ' . $id_address . ' AND a.`deleted` = 0 AND a.`active` = 1        ');        return (bool) $isValid;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
303,PrestaShop_PrestaShop_Address_786, Returns Address ID for a given Supplier ID.\n\n @since 1.5.0\n\n @param int $id_supplier Supplier ID\n\n @return int $id_address Address ID\n, Vra?a Address ID za dati Supplier ID.,    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    },2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
304,PrestaShop_PrestaShop_Address_787, Check if the alias already exists.\n\n @param string $alias Alias of an address\n @param int $id_address Address id\n @param int $id_customer Customer id\n\n @return false|string|null Amount of aliases found\n @todo: Find out if we shouldn't be returning an int instead? (breaking change)\n,Provera da li pseudonim ve? postoji.,"    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
305,PrestaShop_PrestaShop_AdminAccessController_863, return human readable Tabs hierarchy for display.\\n,vra?a hijerarhiju kartica ?itljivih za prikaz.,    protected function displayTabs(array $tabs)    {        $tabsTree = $this->getChildrenTab($tabs);        return $tabsTree;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
306,PrestaShop_PrestaShop_AdminAttributesGroupsController_872, Call the right method for creating or updating object.\\\\\\\\n\\\\\\\\n @return mixed\\\\\\\\n,Pozovanje odgovaraju?e metode za stvaranje ili ažuriranje objekta.,    public function processSave()    {        if ($this->display == 'add' || $this->display == 'edit') {            $this->identifier = 'id_attribute_group';        }        if (!$this->id_object) {            return $this->processAdd();        } else {            return $this->processUpdate();        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
307,PrestaShop_PrestaShop_Alias_810, Get all found aliases from DB with search query.\\\\\\\\n\\\\\\\\n @return string Comma separated aliases\\\\\\\\n,Vra?a sve prona?ene pseudonime iz DB pomo?u upita za pretragu.,"    public function getAliases()    {        if (!Alias::isFeatureActive()) {            return '';        }        $aliases = Db::getInstance()->executeS('SELECT a.aliasFROM `' . _DB_PREFIX_ . 'alias` aWHERE `search` = \'' . pSQL($this->search) . '\'');        $aliases = array_map('implode', $aliases);        return implode(', ', $aliases);    }",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
308,PrestaShop_PrestaShop_Alias_812, This method is allow to know if a alias exist for AdminImportController.\\\\n\\\\n @param int $idAlias Alias ID\\\\n\\\\n @return bool\\\\n\\\\n @since 1.5.6.0\\\\n,Ova metoda dozvoljava da se zna postoji li pseudonim za AdminImportController.,"    public static function aliasExists($idAlias)    {        $sql = new DbQuery();        $sql->select('a.`id_alias`');        $sql->from('alias', 'a');        $sql->where('a.`id_alias` = ' . (int) $idAlias);        $row = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow($sql, false);        return isset($row['id_alias']);    }",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
309,PrestaShop_PrestaShop_AppKernel_759, Enable auto loading of module Composer autoloader if needed.\\n Need to be done as earlier as possible in application lifecycle.\\n\\n Note: this feature is also manage in PrestaShop\\\\PrestaShop\\\\Adapter\\\\ContainerBuilder\\n for non Symfony environments.\\n\\n @param array $modules the list of modules\\n,Omogu?avanje automatskog u?itavanje modula Composer autoloader ako je potrebno. Potrebno je da bude urađeno što je pre moguće u životnom ciklusu aplikacije. Napomena: ovim svojstvom se takođe upravlja u PrestaShop\\\\PrestaShop\\\\Adapter\\\\ContainerBuilder\\n za okruženja koja nisu Symfony.,"    private function enableComposerAutoloaderOnModules($modules)    {        $moduleDirectoryPath = rtrim(_PS_MODULE_DIR_, '/') . '/';        foreach ($modules as $module) {            $autoloader = $moduleDirectoryPath . $module . '/vendor/autoload.php';            if (file_exists($autoloader)) {                include_once $autoloader;            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
310,PrestaShop_PrestaShop_AppKernel_760, Gets the application root dir.\n Override Kernel due to the fact that we remove the composer.json in\n downloaded package. More we are not a framework and the root directory\n should always be the parent of this file.\n\n @return string The project root dir\n,Vra?a root direktorijum aplikacije. Premoštava Kernel zbog činjenice da smo uklonili composer.json u paketu za preuzimanje. Štaviše mi nismo okvir i root direktorijum bi trebao uvek da bude roditelj ovog fajla. ,    public function getProjectDir()    {        return realpath(__DIR__ . '/..');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
311,PrestaShop_PrestaShop_Attachment_815, Delete selection of attachments.\\\\\\\\n\\\\\\\\n @param array $attachments Attachments\\\\\\\\n\\\\\\\\n @return bool|int Whether the selection has been successfully deleted\\\\\\\\n @todo: Find out if $return can be initialized with true. (breaking change)\\\\\\\\n,Brisanje izbora priloga.,    public function deleteSelection($attachments)    {        $return = 1;        foreach ($attachments as $idAttachment) {            $attachment = new Attachment((int) $idAttachment);            $return &= $attachment->delete();        }        return $return;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
312,PrestaShop_PrestaShop_Attachment_816, Delete Product attachments for the given Product ID.\n\n @param int $idProduct Product ID\n\n @return bool\n,Brisanje Product priloga za dati Product ID.,    public static function deleteProductAttachments($idProduct)    {        $res = Db::getInstance()->execute('DELETE FROM ' . _DB_PREFIX_ . 'product_attachmentWHERE id_product = ' . (int) $idProduct);        Product::updateCacheAttachment((int) $idProduct);        return $res;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
313,PrestaShop_PrestaShop_Attachment_817, Associate $id_product to the current object.\\\\\\\\n\\\\\\\\n @param int $idProduct id of the product to associate\\\\\\\\n\\\\\\\\n @return bool true if success\\\\\\\\n, Pridružuje $id_product datom objektu.,"    public function attachProduct($idProduct)    {        return static::associateProductAttachment((int) $idProduct, (int) $this->id);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
314,PrestaShop_PrestaShop_Attachment_819, Associate an array of id_attachment $array to the product $id_product\\\\n and remove eventual previous association.\\\\n\\\\n @param int $idProduct Product ID\\\\n @param array $array Attachment IDs\\\\n\\\\n @return bool Whether the attachments have been successfully associated with the Product\\\\n, Pridružuje niz id_attachment $array proizvodu $id_product i uklanja eventualne prethodne asocijacije. ,"    public static function attachToProduct($idProduct, $array)    {        $result1 = Attachment::deleteProductAttachments($idProduct);        if (is_array($array)) {            $ids = [];            foreach ($array as $idAttachment) {                if ((int) $idAttachment > 0) {                    $ids[] = ['id_product' => (int) $idProduct, 'id_attachment' => (int) $idAttachment];                }            }            if (!empty($ids)) {                $result2 = Db::getInstance()->insert('product_attachment', $ids);            }        }        Product::updateCacheAttachment((int) $idProduct);        if (is_array($array)) {            return $result1 && (!isset($result2) || $result2);        }        return $result1;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
315,PrestaShop_PrestaShop_Attachment_820, Get Attachment IDs for the given Product within the given range of attachment IDs.\\\\n\\\\n @param int $idLang Language ID\\\\n @param array $list List of attachment IDs in which to search\\\\n\\\\n @return array|bool List of attachment IDs found. False if nothing found.\\\\n,Vra?a Attachment ID-ijeve za dati Product u okviru opsega Id-ijeva priloga.,"    public static function getProductAttached($idLang, $list)    {        if (!is_array($list)) {            return false;        }        $idsAttachments = array_column($list, 'id_attachment');        $sql = 'SELECT * FROM `' . _DB_PREFIX_ . 'product_attachment` pa ' .             'LEFT JOIN `' . _DB_PREFIX_ . 'product_lang` pl ON (pa.`id_product` = pl.`id_product`' . Shop::addSqlRestrictionOnLang('pl') . ') ' .             'WHERE `id_attachment` IN (' . implode(',', array_map('intval', $idsAttachments)) . ') ' .             'AND pl.`id_lang` = ' . (int) $idLang;        $tmp = Db::getInstance()->executeS($sql);        $productAttachments = [];        foreach ($tmp as $t) {            $productAttachments[$t['id_attachment']][] = $t['name'];        }        return $productAttachments;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
316,PrestaShop_PrestaShop_Attachment_822," Set products ids of current attachment for association.\\n\\n @param array<int, array{id: int|string }> $products Products ids\\n\\n @return bool\\n",Postavljanje ID-jeva proizvoda trenutnog priloga za povezivanje.,"    public function setWsProducts(array $products): bool    {        $this->deleteAttachments(true);        foreach ($products as $product) {            Db::getInstance()->execute('INSERT INTO `' . _DB_PREFIX_ . 'product_attachment` (`id_product`, `id_attachment`) VALUES (' . (int) $product['id'] . ', ' . (int) $this->id . ')');            Product::updateCacheAttachment((int) $product['id']);        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
317,PrestaShop_PrestaShop_AttributeGroup_831, Clean dead combinations\\n A combination is considered dead when its Attribute ID cannot be found.\\n\\n @return bool Whether the dead combinations have been successfully deleted\\n,?iš?enje mrtvih kombinacija Komvbinacija se smatra mrtvom ako njen Attribute ID ne može biti nađen.,"    public static function cleanDeadCombinations()    {        $attributeCombinations = Db::getInstance()->executeS('SELECT pac.`id_attribute`, pa.`id_product_attribute`FROM `' . _DB_PREFIX_ . 'product_attribute` paLEFT JOIN `' . _DB_PREFIX_ . 'product_attribute_combination` pacON (pa.`id_product_attribute` = pac.`id_product_attribute`)');        $toRemove = [];        foreach ($attributeCombinations as $attributeCombination) {            if ((int) $attributeCombination['id_attribute'] == 0) {                $toRemove[] = (int) $attributeCombination['id_product_attribute'];            }        }        $return = true;        if (!empty($toRemove)) {            foreach ($toRemove as $remove) {                $combination = new Combination($remove);                $return &= $combination->delete();            }        }        return $return;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
318,PrestaShop_PrestaShop_AttributeGroup_832, Deletes current AttributeGroup from database.\\\\\\\\n\\\\\\\\n @return bool True if delete was successful\\\\\\\\n\\\\\\\\n @throws PrestaShopException\\\\\\\\n,Briše trenutnu AttributeGroup iz baze podataka.,"    public function delete()    {        if (!$this->hasMultishopEntries() || Shop::getContext() == Shop::CONTEXT_ALL) {            /* Select children in order to find linked combinations */            $attributeIds = Db::getInstance()->executeS(                'SELECT `id_attribute`FROM `' . _DB_PREFIX_ . 'attribute`WHERE `id_attribute_group` = ' . (int) $this->id            );            if ($attributeIds === false) {                return false;            }            /* Removing attributes to the found combinations */            $toRemove = [];            foreach ($attributeIds as $attribute) {                $toRemove[] = (int) $attribute['id_attribute'];            }            if (!empty($toRemove) && Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'product_attribute_combination`WHERE `id_attribute`IN (' . implode(', ', $toRemove) . ')') === false) {                return false;            }            /* Remove combinations if they do not possess attributes anymore */            if (!AttributeGroup::cleanDeadCombinations()) {                return false;            }            /* Also delete related attributes */            if (count($toRemove)) {                if (!Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_lang`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_shop`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute` WHERE `id_attribute_group` = ' . (int) $this->id)) {                    return false;                }            }            $this->cleanPositions();        }        $return = parent::delete();        if ($return) {            Hook::exec('actionAttributeGroupDelete', ['id_attribute_group' => $this->id]);        }        return $return;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
319,PrestaShop_PrestaShop_AttributeGroup_833, Get all attributes for a given language / group.\\\\n\\\\n @param int $idLang Language ID\\\\n @param int $idAttributeGroup AttributeGroup ID\\\\n\\\\n @return array Attributes\\\\n,Vra?a sve atribute za dati jezik/grupu.,"    public static function getAttributes($idLang, $idAttributeGroup)    {        if (!Combination::isFeatureActive()) {            return [];        }        return Db::getInstance()->executeS('SELECT *FROM `' . _DB_PREFIX_ . 'attribute` a' . Shop::addSqlAssociation('attribute', 'a') . 'LEFT JOIN `' . _DB_PREFIX_ . 'attribute_lang` alON (a.`id_attribute` = al.`id_attribute` AND al.`id_lang` = ' . (int) $idLang . ')WHERE a.`id_attribute_group` = ' . (int) $idAttributeGroup . 'ORDER BY `position` ASC');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
320,PrestaShop_PrestaShop_AttributeGroup_834, Get all attributes groups for a given language.\\\\n\\\\n @param int $idLang Language id\\\\n\\\\n @return array Attributes groups\\\\n,Vra?a sve atribute grupe za dati jezik.,"    public static function getAttributesGroups($idLang)    {        if (!Combination::isFeatureActive()) {            return [];        }        return Db::getInstance()->executeS('SELECT DISTINCT agl.`name`, ag.*, agl.*FROM `' . _DB_PREFIX_ . 'attribute_group` ag' . Shop::addSqlAssociation('attribute_group', 'ag') . 'LEFT JOIN `' . _DB_PREFIX_ . 'attribute_group_lang` aglON (ag.`id_attribute_group` = agl.`id_attribute_group` AND `id_lang` = ' . (int) $idLang . ')ORDER BY `name` ASC');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
321,PrestaShop_PrestaShop_AttributeGroup_836, Set the values of the current AttributeGroup for the webservice.\\n\\n @param array $values\\n\\n @return bool Whether the update was successful\\n,Postavlja vrednosti trenutnog AttributeGroup za web servis.,"    public function setWsProductOptionValues($values)    {        $ids = [];        foreach ($values as $value) {            $ids[] = (int) ($value['id']);        }        if (!empty($ids)) {            Db::getInstance()->execute(                '                DELETE FROM `' . _DB_PREFIX_ . 'attribute`                WHERE `id_attribute_group` = ' . (int) $this->id . '                AND `id_attribute` NOT IN (' . implode(',', $ids) . ')'            );        }        $ok = true;        foreach ($values as $value) {            $result = Db::getInstance()->execute(                'UPDATE `' . _DB_PREFIX_ . 'attribute`SET `id_attribute_group` = ' . (int) $this->id . 'WHERE `id_attribute` = ' . (int) $value['id']            );            if ($result === false) {                $ok = false;            }        }        return $ok;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
322,PrestaShop_PrestaShop_AttributeGroup_837, Get values of current AttributeGroup instance for the webservice.\n\n @return array|false|mysqli_result|PDOStatement|resource|null\n,Vra?a vrednosti trenutnog AttributeGroup za web servis.,"    public function getWsProductOptionValues()    {        $result = Db::getInstance()->executeS(            'SELECT a.id_attribute AS idFROM `' . _DB_PREFIX_ . 'attribute` a' . Shop::addSqlAssociation('attribute', 'a') . 'WHERE a.id_attribute_group = ' . (int) $this->id        );        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
323,PrestaShop_PrestaShop_AttributeGroup_838, Move a group attribute.\n\n @param bool $direction Up (1) or Down (0)\n @param int $position\n\n @return bool Update result\n,Premeštanje atributa grupe.,"    public function updatePosition($direction, $position)    {        if (!$res = Db::getInstance()->executeS(            'SELECT ag.`position`, ag.`id_attribute_group`FROM `' . _DB_PREFIX_ . 'attribute_group` agWHERE ag.`id_attribute_group` = ' . (int) Tools::getValue('id_attribute_group', 1) . 'ORDER BY ag.`position` ASC'        )) {            return false;        }        foreach ($res as $groupAttribute) {            if ((int) $groupAttribute['id_attribute_group'] == (int) $this->id) {                $movedGroupAttribute = $groupAttribute;            }        }        if (!isset($movedGroupAttribute) || !isset($position)) {            return false;        }        // < and > statements rather than BETWEEN operator        // since BETWEEN is treated differently according to databases        return Db::getInstance()->execute(            'UPDATE `' . _DB_PREFIX_ . 'attribute_group`SET `position`= `position` ' . ($direction ? '- 1' : '+ 1') . 'WHERE `position`' . ($direction                ? '> ' . (int) $movedGroupAttribute['position'] . ' AND `position` <= ' . (int) $position                : '< ' . (int) $movedGroupAttribute['position'] . ' AND `position` >= ' . (int) $position)        ) && Db::getInstance()->execute('UPDATE `' . _DB_PREFIX_ . 'attribute_group`SET `position` = ' . (int) $position . 'WHERE `id_attribute_group`=' . (int) $movedGroupAttribute['id_attribute_group']);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
324,PrestaShop_PrestaShop_Attribute_827, Get minimal quantity for product with attributes quantity.\n\n @param int $idProductAttribute Product Attribute ID\n\n @return mixed Minimal quantity or false if no result\n, Vra?a minimalnu koli?inu proizvoda sa koli?inom atributa. ,    public static function getAttributeMinimalQty($idProductAttribute)    {        $minimalQuantity = Db::getInstance()->getValue(            'SELECT `minimal_quantity`FROM `' . _DB_PREFIX_ . 'product_attribute_shop` pasWHERE `id_shop` = ' . (int) Context::getContext()->shop->id . 'AND `id_product_attribute` = ' . (int) $idProductAttribute        );        if ($minimalQuantity > 1) {            return (int) $minimalQuantity;        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
325,PrestaShop_PrestaShop_CMSCategory_849, Recursively add specified CMSCategory childs to $toDelete array.\\\\\\\\n\\\\\\\\n @param array &$toDelete Array reference where categories ID will be saved\\\\\\\\n @param array|int $id_cms_category Parent CMSCategory ID\\\\\\\\n,Rekurzivno dodaje specifi?nu CMSCategory decu u $toDelete niz. ,"    protected function recursiveDelete(&$to_delete, $id_cms_category)    {        if (!is_array($to_delete) || !$id_cms_category) {            die(Tools::displayError());        }        $result = Db::getInstance()->executeS('SELECT `id_cms_category`FROM `' . _DB_PREFIX_ . 'cms_category`WHERE `id_parent` = ' . (int) $id_cms_category);        foreach ($result as $row) {            $to_delete[] = (int) $row['id_cms_category'];            $this->recursiveDelete($to_delete, (int) $row['id_cms_category']);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
326,PrestaShop_PrestaShop_CMSCategory_850," Directly call the parent of delete, in order to avoid recursion.\\\\n\\\\n @return bool Deletion result\\\\n",Direktno pozovanje roditelja za brisanje kako bi se izbeglo ponavljanje.,    private function deleteLite()    {        return parent::delete();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
327,PrestaShop_PrestaShop_CMSCategory_851, Delete pages which are in CMSCategories to delete.\\\\\\\\n\\\\\\\\n @return bool Deletion result\\\\\\\\n,Brisanje stranica u CMSCategory koje su za brisanje. ,"    private function deleteCMS()    {        $result = true;        $cms = new PrestaShopCollection('CMS');        $cms->where('id_cms_category', '=', $this->id);        foreach ($cms as $c) {            $result &= $c->delete();        }        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
328,PrestaShop_PrestaShop_CMSCategory_854, Hide CMSCategory prefix used for position.\\\\n\\\\n @param string $name CMSCategory name\\\\n\\\\n @return string Name without position\\\\n,Skriva CMSCategory prefiks koji se koristi za poziciju. ,"    public static function hideCMSCategoryPosition($name)    {        return preg_replace('/^[0-9]+\./', '', $name);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
329,PrestaShop_PrestaShop_CMSCategory_855, Return an array of all children of the current CMSCategory.\\n\\n @return PrestaShopCollection Collection of CMSCategory\\n, Vra?a niz sve dece trenutne CMSCategory. ,"    private function getAllChildren()    {        // Get children        $toDelete = [(int) $this->id];        $this->recursiveDelete($toDelete, (int) $this->id);        $toDelete = array_unique($toDelete);        // remove id of current CMSCategory because we want only ids of children        unset($toDelete[0]);        if (count($toDelete)) {            $children = new PrestaShopCollection('CMSCategory');            $children->where('id_cms_category', 'in', $toDelete);            return $children;        }        return $toDelete;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
330,PrestaShop_PrestaShop_CMSCategory_856, Check if CMSCategory can be moved in another one.\\n\\n @param int $id_parent Parent candidate\\n\\n @return bool Parent validity\\n, Povera da li se CMSCategory može pomeriti u drugu. ,"    public static function checkBeforeMove($id_cms_category, $id_parent)    {        if ($id_cms_category == $id_parent) {            return false;        }        if ($id_parent == 1) {            return true;        }        $i = (int) $id_parent;        while (42) {            $result = Db::getInstance()->getRow('SELECT `id_parent` FROM `' . _DB_PREFIX_ . 'cms_category` WHERE `id_cms_category` = ' . (int) $i);            if (!isset($result['id_parent'])) {                return false;            }            if ($result['id_parent'] == $id_cms_category) {                return false;            }            if ($result['id_parent'] == 1) {                return true;            }            $i = $result['id_parent'];        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
331,Respect_Validation_CustomRule_1795, Example of a custom rule that does not have an exception.\\\\n\\\\n @author Casey McLaughlin <caseyamcl@gmail.com>\\\\n,Primer prilago?enog pravila koje nema izuzetak.,final class CustomRule extends AbstractRule{    /**     * {@inheritDoc}     */    public function validate($input): bool    {        return false;    }},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
332,Respect_Validation_Factory_1756, Returns the default instance of the Factory.\\n, Vra?a podrazumevanu vrednost instance Factory.,    public static function getDefaultInstance(): self    {        if (self::$defaultInstance === null) {            self::$defaultInstance = new self();        }        return self::$defaultInstance;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
333,Respect_Validation_Factory_1757, Define the default instance of the Factory.\\\\n, Definiše podrazumevanu instancu Factory.,    public static function setDefaultInstance(self $defaultInstance): void    {        self::$defaultInstance = $defaultInstance;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
334,Respect_Validation_Stub_1799, Initializes the rule.\n\n @param bool[] ...$validations\n,Inicijalizuje pravilo.,    public function __construct(bool ...$validations)    {        $this->validations = $validations;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
335,Respect_Validation_UndefinedProvider_1792," Returns values that are not considered as ""undefined""\\\\n\\\\n @return mixed[][]\\\\n",Vrac?a vrednosti koje se ne smatraju „nedefinisanima“,"    public function providerForNotUndefined(): array    {        return [            [0],            [0.0],            ['0'],            [false],            [true],            [' '],            [[]],        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
336,Respect_Validation_Validator_1777, Create a new rule by the name of the method and adds the rule to the chain.\\\\n\\\\n @param mixed[] $arguments\\\\n\\\\n @throws ComponentException\\\\n,Kreira novo pravilo po imenu metode i dodaje pravilo lancu.,"    public function __call(string $ruleName, array $arguments): self    {        $this->addRule(Factory::getDefaultInstance()->rule($ruleName, $arguments));        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
337,Sylius_Sylius_LaminasPriorityQueueStub_1186," Re-usable, serializable priority queue implementation\n\n SplPriorityQueue acts as a heap; on iteration, each item is removed from the\n queue. If you wish to re-use such a queue, you need to clone it first. This\n makes for some interesting issues if you wish to delete items from the queue,\n or, as already stated, iterate over it multiple times.\n\n This class aggregates items for the queue itself, but also composes an\n ""inner"" iterator in the form of an SplPriorityQueue object for performing\n the actual iteration.\n\n @psalm-template T\n @implements IteratorAggregate<int, T>\n"," Ponovno iskoristiva, serijalizovna implementacija prioritetnog reda SplPriorityQueue se ponaša kao heap; u svakoj iteraciji, svaki elemenat se uklanja iz reda. Ako želite da ponovo koristite takav red, mora se prvo klonirati. Ovo pravi neke zanimljive probleme ako želite da izbrišete elemenat uz reda, ili, kako je sam već navedeo, da ga koristite više puta. Ova klasa agrerira elemente za sami red, ali takođe sastavlja ""unutrašnji"" iterator u formi SplPriorityQueue objekta za obavljanje stvarne iteracije. ","class PriorityQueue implements Countable, IteratorAggregate, Serializable{    const EXTR_DATA     = 0x00000001;    const EXTR_PRIORITY = 0x00000002;    const EXTR_BOTH     = 0x00000003;    /**     * Inner queue class to use for iteration     * @var string     */    protected $queueClass = SplPriorityQueue::class;    /**     * Actual items aggregated in the priority queue. Each item is an array     * with keys ""data"" and ""priority"".     * @var array     */    protected $items      = [];    /**     * Inner queue object     * @var SplPriorityQueue     */    protected $queue;    /**     * Insert an item into the queue     *     * Priority defaults to 1 (low priority) if none provided.     *     * @param  mixed $data     * @param  int $priority     * @return PriorityQueue     *     * @psalm-param T $data     * @psalm-return PriorityQueue<T>     */    public function insert($data, $priority = 1)    {        $priority = (int) $priority;        $this->items[] = [            'data'     => $data,            'priority' => $priority,        ];        $this->getQueue()->insert($data, $priority);        return $this;    }    /**     * Remove an item from the queue     *     * This is different than {@link extract()}; its purpose is to dequeue an     * item.     *     * This operation is potentially expensive, as it requires     * re-initialization and re-population of the inner queue.     *     * Note: this removes the first item matching the provided item found. If     * the same item has been added multiple times, it will not remove other     * instances.     *     * @param  mixed $datum     * @return bool False if the item was not found, true otherwise.     *     * @psalm-param T $datum     */    public function remove($datum)    {        $found = false;        foreach ($this->items as $key => $item) {            if ($item['data'] === $datum) {                $found = true;                break;            }        }        if ($found) {            unset($this->items[$key]);            $this->queue = null;            if (! $this->isEmpty()) {                $queue = $this->getQueue();                foreach ($this->items as $item) {                    $queue->insert($item['data'], $item['priority']);                }            }            return true;        }        return false;    }    /**     * Is the queue empty?     *     * @return bool     */    public function isEmpty()    {        return (0 === $this->count());    }    /**     * How many items are in the queue?     *     * @return int     */    public function count()    {        return count($this->items);    }    /**     * Peek at the top node in the queue, based on priority.     *     * @return mixed     */    public function top()    {        return $this->getIterator()->top();    }    /**     * Extract a node from the inner queue and sift up     *     * @return mixed     */    public function extract()    {        $value = $this->getQueue()->extract();        $keyToRemove = null;        $highestPriority = null;        foreach ($this->items as $key => $item) {            if ($item['data'] !== $value) {                continue;            }            if (null === $highestPriority) {                $highestPriority = $item['priority'];                $keyToRemove = $key;                continue;            }            if ($highestPriority >= $item['priority']) {                continue;            }            $highestPriority = $item['priority'];            $keyToRemove = $key;        }        if ($keyToRemove !== null) {            unset($this->items[$keyToRemove]);        }        return $value;    }    /**     * Retrieve the inner iterator     *     * SplPriorityQueue acts as a heap, which typically implies that as items     * are iterated, they are also removed. This does not work for situations     * where the queue may be iterated multiple times. As such, this class     * aggregates the values, and also injects an SplPriorityQueue. This method     * retrieves the inner queue object, and clones it for purposes of     * iteration.     *     * @return SplPriorityQueue     *     * @psalm-return SplPriorityQueue<T>     */    public function getIterator()    {        $queue = $this->getQueue();        return clone $queue;    }    /**     * Serialize the data structure     *     * @return string     */    public function serialize()    {        return serialize($this->items);    }    /**     * Unserialize a string into a PriorityQueue object     *     * Serialization format is compatible with {@link Laminas\Stdlib\SplPriorityQueue}     *     * @param  string $data     * @return void     */    public function unserialize($data)    {        foreach (unserialize($data) as $item) {            $this->insert($item['data'], $item['priority']);        }    }    /**     * Serialize to an array     *     * By default, returns only the item data, and in the order registered (not     * sorted). You may provide one of the EXTR_* flags as an argument, allowing     * the ability to return priorities or both data and priority.     *     * @param  int $flag     * @return array     */    public function toArray($flag = self::EXTR_DATA)    {        switch ($flag) {            case self::EXTR_BOTH:                return $this->items;            case self::EXTR_PRIORITY:                return array_map(function ($item) {                    return $item['priority'];                }, $this->items);            case self::EXTR_DATA:            default:                return array_map(function ($item) {                    return $item['data'];                }, $this->items);        }    }    /**     * Specify the internal queue class     *     * Please see {@link getIterator()} for details on the necessity of an     * internal queue class. The class provided should extend SplPriorityQueue.     *     * @param  string $class     * @return PriorityQueue     *     * @psalm-return PriorityQueue<T>     */    public function setInternalQueueClass($class)    {        $this->queueClass = (string) $class;        return $this;    }    /**     * Does the queue contain the given datum?     *     * @param  mixed $datum     * @return bool     *     * @psalm-param T $datum     */    public function contains($datum)    {        foreach ($this->items as $item) {            if ($item['data'] === $datum) {                return true;            }        }        return false;    }    /**     * Does the queue have an item with the given priority?     *     * @param  int $priority     * @return bool     */    public function hasPriority($priority)    {        foreach ($this->items as $item) {            if ($item['priority'] === $priority) {                return true;            }        }        return false;    }    /**     * Get the inner priority queue instance     *     * @throws Exception\DomainException     * @return SplPriorityQueue     */    protected function getQueue()    {        if (null === $this->queue) {            $this->queue = new $this->queueClass();            if (! $this->queue instanceof \SplPriorityQueue) {                throw new Exception\DomainException(sprintf(                    'PriorityQueue expects an internal queue of type SplPriorityQueue; received ""%s""',                    get_class($this->queue)                ));            }        }        return $this->queue;    }    /**     * Add support for deep cloning     *     * @return void     */    public function __clone()    {        if (null !== $this->queue) {            $this->queue = clone $this->queue;        }    }}",0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
338,Sylius_Sylius_LaminasPriorityQueueStub_1191, Extract a node from the inner queue and sift up\n\n @return mixed\n,Izvla?enje unutrašnjeg ?vor iz unutrašnjeg reda i prosejavanje,    public function extract()    {        $value = $this->getQueue()->extract();        $keyToRemove = null;        $highestPriority = null;        foreach ($this->items as $key => $item) {            if ($item['data'] !== $value) {                continue;            }            if (null === $highestPriority) {                $highestPriority = $item['priority'];                $keyToRemove = $key;                continue;            }            if ($highestPriority >= $item['priority']) {                continue;            }            $highestPriority = $item['priority'];            $keyToRemove = $key;        }        if ($keyToRemove !== null) {            unset($this->items[$keyToRemove]);        }        return $value;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
339,Sylius_Sylius_LaminasPriorityQueueStub_1194, Unserialize a string into a PriorityQueue object\n\n Serialization format is compatible with {@link Laminas\\Stdlib\\SplPriorityQueue}\n\n @param  string $data\n @return void\n,Deserializacija stringa u objekat PriorityQueue Format serijalizacije je kompatibilan sa {@link Laminas\\Stdlib\\SplPriorityQueue},"    public function unserialize($data)    {        foreach (unserialize($data) as $item) {            $this->insert($item['data'], $item['priority']);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
340,Sylius_Sylius_LaminasPriorityQueueStub_1195, Specify the internal queue class\n\n Please see {@link getIterator()} for details on the necessity of an\n internal queue class. The class provided should extend SplPriorityQueue.\n\n @param  string $class\n @return PriorityQueue\n\n @psalm-return PriorityQueue<T>\n,Specificira internu klasu reda Molim Vas da pogledate {@link getIterator()} za detalje o neophodnosti interne klase reda. Klasa koja je data bi trebalo da nasledi SplPriorityQueue.,    public function setInternalQueueClass($class)    {        $this->queueClass = (string) $class;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
341,Sylius_Sylius_LaminasPriorityQueueStub_1196, Does the queue contain the given datum?\n\n @param  mixed $datum\n @return bool\n\n @psalm-param T $datum\n,Da li red sadrži zadati datum?,    public function contains($datum)    {        foreach ($this->items as $item) {            if ($item['data'] === $datum) {                return true;            }        }        return false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
342,Sylius_Sylius_LaminasPriorityQueueStub_455," Peek at the top node in the queue, based on priority.\\n\\n @return mixed\\n",Zaviritit u gornji ?vor u redu na osnovu prioriteta.,    public function top()    {        return $this->getIterator()->top();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
343,Sylius_Sylius_LaminasPriorityQueueStub_458, Serialize the data structure\\n\\n @return string\\n, Serijalizacija strukture podataka,    public function serialize()    {        return serialize($this->items);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
344,Sylius_Sylius_LaminasPriorityQueueStub_463, Get the inner priority queue instance\\n\\n @throws Exception\\\\DomainException\\n @return SplPriorityQueue\\n,Vra?a instancu unutrašnjeg prioritetnog reda,"    protected function getQueue()    {        if (null === $this->queue) {            $this->queue = new $this->queueClass();            if (! $this->queue instanceof \SplPriorityQueue) {                throw new Exception\DomainException(sprintf(                    'PriorityQueue expects an internal queue of type SplPriorityQueue; received ""%s""',                    get_class($this->queue)                ));            }        }        return $this->queue;    }",0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
345,TheAlgorithms_PHP_EditDistance_2066," Edit distance (Levenshtein distance).\n Compute the difference between two sequences, ie, the minimum number of changes\n to get to $str2 from $str1\n @param string $str1\n @param string $str2\n @return int the minimum number of changes to transform one string into another\n","Ure?ivanje udaljenosti (Levenshtein udaljenost). Izračunava razlku između dva niza, tj. minmalan broj promena da se od $str2 dobije $str1","function editDistance($str1, $str2){    $lenStr1 = strlen($str1);    $lenStr2 = strlen($str2);    if ($lenStr1 == 0) {        return $lenStr2;    }    if ($lenStr2 == 0) {        return $lenStr1;    }    $distanceVectorInit = [];    $distanceVectorFinal = [];    for ($i = 0; $i < $lenStr1 + 1; $i++) {        $distanceVectorInit[] = 0;        $distanceVectorFinal[] = 0;    }    for ($i = 0; $i < $lenStr1 + 1; $i++) {        $distanceVectorInit[$i] = $i;    }    for ($i = 0; $i < $lenStr2; $i++) {        $distanceVectorFinal[0] = $i + 1;        // use formula to fill in the rest of the row        for ($j = 0; $j < $lenStr1; $j++) {            $substitutionCost = 0;            if ($str1[$j] == $str2[$i]) {                $substitutionCost = $distanceVectorInit[$j];            } else {                $substitutionCost = $distanceVectorInit[$j] + 1;            }            $distanceVectorFinal[$j+1] = min($distanceVectorInit[$j+1] + 1, min($distanceVectorFinal[$j] + 1, $substitutionCost));        }        $distanceVectorInit = $distanceVectorFinal;    }    return $distanceVectorFinal[$lenStr1];}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
346,TheAlgorithms_PHP_caesarCipher_2069, Encrypt given text using caesar cipher.\n @param string text text to be encrypted\n @param int shift number of shifts to be applied\n @return string new encrypted text\n,Enkriptovanje datog teksta koriš?enjem Cezarovog šifrovanja.,"function encrypt(string $text, int $shift): string{    $encryptedText = ''; // Empty string to store encrypted text    foreach (str_split($text) as $c) { // Going through each character        if (ctype_alpha($c)) {            $placeValue = ord($c) - ord(ctype_upper($c) ? 'A' : 'a'); // Getting value of character (i.e. 0-25)            $placeValue = ($placeValue + $shift) % 26; // Applying encryption formula            $placeValue += ord(ctype_upper($c) ? 'A' : 'a');            $newChar = chr($placeValue); // Getting new character from new value (i.e. A-Z)            $encryptedText .= $newChar; // Appending encrypted character        } else {            $encryptedText .= $c; // Appending the original character        }    }    return $encryptedText; // Returning encrypted text}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
347,TheAlgorithms_PHP_linear_search_2071," Linear search in PHP\n \n Reference: https://www.geeksforgeeks.org/linear-search/\n \n @param Array $list a array of integers to search\n @param integer $target an integer number to search for in the list\n @return integer the index where the target is found (or -1 if not found)\n \n Examples:\n \n  data =  5, 7, 8, 11, 12, 15, 17, 18, 20\n  \n  x = 15\n  Element found at position 6\n  \n  x = 1\n  Element not found\n \n",Linearna pretraga u PHP,"function linear_search($list, $target) #Linear Search  { $n = sizeof($list);     for($i = 0; $i < $n; $i++)     {         if($list[$i] == $target)             return $i+1;     }     return -1;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
348,YOURLS_YOURLS_functions-geo_708, Return flag URL from 2 letter country code\n @param string $code\n @return string\n,Vra?a zastavu URL na osnovu 2 slova državnog koda,function yourls_geo_get_flag( $code ) {    if ( !file_exists( YOURLS_INC.'/geo/flags/flag_'.strtolower( $code ).'.gif' ) ) {        $code = '';    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
349,barryvdh_laravel-debugbar_LaravelDebugbar_101," Enable the Debugbar and boot, if not already booted.\n","Omogu?iti Debugbar i pokrenuti, ako ve? nije pokrenut.",    public function enable()    {        $this->enabled = true;        if (!$this->booted) {            $this->boot();        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
350,barryvdh_laravel-debugbar_LaravelDebugbar_102," Boot the debugbar (add collectors, renderer and listener)\n","Pokrenuti debugbar (i kolektore, renderere, i osluškiva?e)","    public function boot()    {        if ($this->booted) {            return;        }        /** @var \Barryvdh\Debugbar\LaravelDebugbar $debugbar */        $debugbar = $this;        /** @var Application $app */        $app = $this->app;        // Set custom error handler        if ($app['config']->get('debugbar.error_handler', false)) {            set_error_handler([$this, 'handleError']);        }        $this->selectStorage($debugbar);        if ($this->shouldCollect('phpinfo', true)) {            $this->addCollector(new PhpInfoCollector());        }        if ($this->shouldCollect('messages', true)) {            $this->addCollector(new MessagesCollector());        }        if ($this->shouldCollect('time', true)) {            $startTime = $app['request']->server('REQUEST_TIME_FLOAT');            $this->addCollector(new TimeDataCollector($startTime));            if (! $this->isLumen() && $startTime) {                $this->app->booted(                    function () use ($debugbar, $startTime) {                        $debugbar['time']->addMeasure('Booting', $startTime, microtime(true));                    }                );            }            $debugbar->startMeasure('application', 'Application');        }        if ($this->shouldCollect('memory', true)) {            $this->addCollector(new MemoryCollector());        }        if ($this->shouldCollect('exceptions', true)) {            try {                $exceptionCollector = new ExceptionsCollector();                $exceptionCollector->setChainExceptions(                    $this->app['config']->get('debugbar.options.exceptions.chain', true)                );                $this->addCollector($exceptionCollector);            } catch (\Exception $e) {            }        }        if ($this->shouldCollect('laravel', false)) {            $this->addCollector(new LaravelCollector($this->app));        }        if ($this->shouldCollect('default_request', false)) {            $this->addCollector(new RequestDataCollector());        }        if ($this->shouldCollect('events', false) && isset($this->app['events'])) {            try {                $startTime = $this->app['request']->server('REQUEST_TIME_FLOAT');                $eventCollector = new EventCollector($startTime);                $this->addCollector($eventCollector);                $this->app['events']->subscribe($eventCollector);            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add EventCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('views', true) && isset($this->app['events'])) {            try {                $collectData = $this->app['config']->get('debugbar.options.views.data', true);                $this->addCollector(new ViewCollector($collectData));                $this->app['events']->listen(                    'composing:*',                    function ($view, $data = []) use ($debugbar) {                        if ($data) {                            $view = $data[0]; // For Laravel >= 5.4                        }                        $debugbar['views']->addView($view);                    }                );            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add ViewCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if (!$this->isLumen() && $this->shouldCollect('route')) {            try {                $this->addCollector($this->app->make('Barryvdh\Debugbar\DataCollector\RouteCollector'));            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add RouteCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if (!$this->isLumen() && $this->shouldCollect('log', true)) {            try {                if ($this->hasCollector('messages')) {                    $logger = new MessagesCollector('log');                    $this['messages']->aggregate($logger);                    $this->app['log']->listen(                        function ($level, $message = null, $context = null) use ($logger) {                            // Laravel 5.4 changed how the global log listeners are called. We must account for                            // the first argument being an ""event object"", where arguments are passed                            // via object properties, instead of individual arguments.                            if ($level instanceof \Illuminate\Log\Events\MessageLogged) {                                $message = $level->message;                                $context = $level->context;                                $level = $level->level;                            }                            try {                                $logMessage = (string) $message;                                if (mb_check_encoding($logMessage, 'UTF-8')) {                                    $logMessage .= (!empty($context) ? ' ' . json_encode($context) : '');                                } else {                                    $logMessage = ""[INVALID UTF-8 DATA]"";                                }                            } catch (\Exception $e) {                                $logMessage = ""[Exception: "" . $e->getMessage() . ""]"";                            }                            $logger->addMessage(                                '[' . date('H:i:s') . '] ' . ""LOG.$level: "" . $logMessage,                                $level,                                false                            );                        }                    );                } else {                    $this->addCollector(new MonologCollector($this->getMonologLogger()));                }            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add LogsCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('db', true) && isset($this->app['db'])) {            $db = $this->app['db'];            if (                $debugbar->hasCollector('time') && $this->app['config']->get(                    'debugbar.options.db.timeline',                    false                )            ) {                $timeCollector = $debugbar->getCollector('time');            } else {                $timeCollector = null;            }            $queryCollector = new QueryCollector($timeCollector);            $queryCollector->setDataFormatter(new QueryFormatter());            if ($this->app['config']->get('debugbar.options.db.with_params')) {                $queryCollector->setRenderSqlWithParams(true);            }            if ($this->app['config']->get('debugbar.options.db.backtrace')) {                $middleware = ! $this->is_lumen ? $this->app['router']->getMiddleware() : [];                $queryCollector->setFindSource(true, $middleware);            }            if ($this->app['config']->get('debugbar.options.db.backtrace_exclude_paths')) {                $excludePaths = $this->app['config']->get('debugbar.options.db.backtrace_exclude_paths');                $queryCollector->mergeBacktraceExcludePaths($excludePaths);            }            $queryCollector->setDurationBackground($this->app['config']->get('debugbar.options.db.duration_background'));            if ($this->app['config']->get('debugbar.options.db.explain.enabled')) {                $types = $this->app['config']->get('debugbar.options.db.explain.types');                $queryCollector->setExplainSource(true, $types);            }            if ($this->app['config']->get('debugbar.options.db.hints', true)) {                $queryCollector->setShowHints(true);            }            if ($this->app['config']->get('debugbar.options.db.show_copy', false)) {                $queryCollector->setShowCopyButton(true);            }            $this->addCollector($queryCollector);            try {                $db->listen(                    function (                        $query,                        $bindings = null,                        $time = null,                        $connectionName = null                    ) use (                        $db,                        $queryCollector                    ) {                        if (!app(static::class)->shouldCollect('db', true)) {                            return; // Issue 776 : We've turned off collecting after the listener was attached                        }                        // Laravel 5.2 changed the way some core events worked. We must account for                        // the first argument being an ""event object"", where arguments are passed                        // via object properties, instead of individual arguments.                        if ($query instanceof \Illuminate\Database\Events\QueryExecuted) {                            $bindings = $query->bindings;                            $time = $query->time;                            $connection = $query->connection;                            $query = $query->sql;                        } else {                            $connection = $db->connection($connectionName);                        }                        //allow collecting only queries slower than a specified amount of milliseconds                        $threshold = app('config')->get('debugbar.options.db.slow_threshold', false);                        if (!$threshold || $time > $threshold) {                            $queryCollector->addQuery((string)$query, $bindings, $time, $connection);                        }                    }                );            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add listen to Queries for Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }            try {                $db->getEventDispatcher()->listen(                    \Illuminate\Database\Events\TransactionBeginning::class,                    function ($transaction) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Begin Transaction', $transaction->connection);                    }                );                $db->getEventDispatcher()->listen(                    \Illuminate\Database\Events\TransactionCommitted::class,                    function ($transaction) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Commit Transaction', $transaction->connection);                    }                );                $db->getEventDispatcher()->listen(                    \Illuminate\Database\Events\TransactionRolledBack::class,                    function ($transaction) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Rollback Transaction', $transaction->connection);                    }                );                $db->getEventDispatcher()->listen(                    'connection.*.beganTransaction',                    function ($event, $params) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Begin Transaction', $params[0]);                    }                );                $db->getEventDispatcher()->listen(                    'connection.*.committed',                    function ($event, $params) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Commit Transaction', $params[0]);                    }                );                $db->getEventDispatcher()->listen(                    'connection.*.rollingBack',                    function ($event, $params) use ($queryCollector) {                        $queryCollector->collectTransactionEvent('Rollback Transaction', $params[0]);                    }                );            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add listen transactions to Queries for Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('models', true)) {            try {                $modelsCollector = $this->app->make('Barryvdh\Debugbar\DataCollector\ModelsCollector');                $this->addCollector($modelsCollector);            } catch (\Exception $e) {                // No Models collector            }        }        if ($this->shouldCollect('livewire', true) && $this->app->bound('livewire')) {            try {                $livewireCollector = $this->app->make('Barryvdh\Debugbar\DataCollector\LivewireCollector');                $this->addCollector($livewireCollector);            } catch (\Exception $e) {                $this->addThrowable(                    new Exception('Cannot add Livewire Collector: ' . $e->getMessage(), $e->getCode(), $e)                );            }        }        if ($this->shouldCollect('mail', true) && class_exists('Illuminate\Mail\MailServiceProvider')) {            try {                $mailer = $this->app['mailer']->getSwiftMailer();                $this->addCollector(new SwiftMailCollector($mailer));                if (                    $this->app['config']->get('debugbar.options.mail.full_log') && $this->hasCollector(                        'messages'                    )                ) {                    $this['messages']->aggregate(new SwiftLogCollector($mailer));                }            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add MailCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('logs', false)) {            try {                $file = $this->app['config']->get('debugbar.options.logs.file');                $this->addCollector(new LogsCollector($file));            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add LogsCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('files', false)) {            $this->addCollector(new FilesCollector($app));        }        if ($this->shouldCollect('auth', false)) {            try {                $guards = $this->app['config']->get('auth.guards', []);                $authCollector = new MultiAuthCollector($app['auth'], $guards);                $authCollector->setShowName(                    $this->app['config']->get('debugbar.options.auth.show_name')                );                $this->addCollector($authCollector);            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add AuthCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        if ($this->shouldCollect('gate', false)) {            try {                $gateCollector = $this->app->make('Barryvdh\Debugbar\DataCollector\GateCollector');                $this->addCollector($gateCollector);            } catch (\Exception $e) {                // No Gate collector            }        }        if ($this->shouldCollect('cache', false) && isset($this->app['events'])) {            try {                $collectValues = $this->app['config']->get('debugbar.options.cache.values', true);                $startTime = $this->app['request']->server('REQUEST_TIME_FLOAT');                $cacheCollector = new CacheCollector($startTime, $collectValues);                $this->addCollector($cacheCollector);                $this->app['events']->subscribe($cacheCollector);            } catch (\Exception $e) {                $this->addThrowable(                    new Exception(                        'Cannot add CacheCollector to Laravel Debugbar: ' . $e->getMessage(),                        $e->getCode(),                        $e                    )                );            }        }        $renderer = $this->getJavascriptRenderer();        $renderer->setIncludeVendors($this->app['config']->get('debugbar.include_vendors', true));        $renderer->setBindAjaxHandlerToFetch($app['config']->get('debugbar.capture_ajax', true));        $renderer->setBindAjaxHandlerToXHR($app['config']->get('debugbar.capture_ajax', true));        $this->booted = true;    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
351,barryvdh_laravel-debugbar_LaravelDebugbar_106, Adds an exception to be profiled in the debug bar\n\n @param Exception $e\n,Dodaje izuzetak za profilisanje u debug bar-u za otklanjanje grešaka,    public function addThrowable($e)    {        if ($this->hasCollector('exceptions')) {            /** @var \DebugBar\DataCollector\ExceptionsCollector $collector */            $collector = $this->getCollector('exceptions');            $collector->addThrowable($e);        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
352,barryvdh_laravel-debugbar_LaravelDebugbar_117, Magic calls for adding messages\n\n @param string $method\n @param array $args\n @return mixed|void\n, Magi?ni poziv za dodavanje poruka,"    public function __call($method, $args)    {        $messageLevels = ['emergency', 'alert', 'critical', 'error', 'warning', 'notice', 'info', 'debug', 'log'];        if (in_array($method, $messageLevels)) {            foreach ($args as $arg) {                $this->addMessage($arg, $method);            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
353,barryvdh_laravel-debugbar_LaravelDebugbar_119, Add Server-Timing headers for the TimeData collector\n\n @see https://www.w3.org/TR/server-timing/\n @param Response $response\n,Dodajte zaglavlja Server-Timing za sakuplja? TimeData,"    protected function addServerTimingHeaders(Response $response)    {        if ($this->hasCollector('time')) {            $collector = $this->getCollector('time');            $headers = [];            foreach ($collector->collect()['measures'] as $k => $m) {                $headers[] = sprintf('app;desc=""%s"";dur=%F', str_replace('""', ""'"", $m['label']), $m['duration'] * 1000);            }            $response->headers->set('Server-Timing', $headers, false);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
354,barryvdh_laravel-debugbar_LumenServiceProvider_122, Get the config path\n\n @return string\n,Vra?a putanju konfiguracije,    protected function getConfigPath()    {        return base_path('config/debugbar.php');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
355,barryvdh_laravel-debugbar_LumenServiceProvider_123, Register the Debugbar Middleware\n\n @param  string $middleware\n,Registruje Debugbar Middleware,    protected function registerMiddleware($middleware)    {        $this->app->middleware([$middleware]);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
356,barryvdh_laravel-debugbar_ServiceProvider_129, Publish the config file\n\n @param  string $configPath\n, Objavi konfiguracioni fajl,"    protected function publishConfig($configPath)    {        $this->publishes([$configPath => config_path('debugbar.php')], 'config');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
357,barryvdh_laravel-debugbar_TestCase_151, Get package aliases.\n\n @param  \\Illuminate\\Foundation\\Application  $app\n\n @return array\n,Vra?a pseudonime paketa.,    protected function getPackageAliases($app)    {        return ['Debugbar' => Facade::class];    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
358,bcit-ci_CodeIgniter_Common_334, Determines if the current version of PHP is equal to or greater than the supplied value\n\n @param\tstring\n @return\tbool\tTRUE if the current version is $version or higher\n,Utvr?uje da li je trenutna verzija PHP-a jednaka ili vec?a od isporu?ene vrednosti,"function is_php($version){static $_is_php;$version = (string) $version;if ( ! isset($_is_php[$version])){$_is_php[$version] = version_compare(PHP_VERSION, $version, '>=');}return $_is_php[$version];}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
359,bcit-ci_CodeIgniter_Common_335," Tests for file writability\\n\\n is_writable() returns TRUE on Windows servers when you really can't write to\\n the file, based on the read-only attribute.\\n\\n @link\\thttps://bugs.php.net/bug.php?id=54709\\n @param\\tstring\\n @return\\tbool\\n","Testovi za upisivanje u datoteke is_writable() vraća TAČNO na Windows serverima kada zapravo ne može da se upiše u fajl, na osnovu read-only atributa.","function is_really_writable($file){// If we're on a UNIX-like server, just is_writable()if (DIRECTORY_SEPARATOR === '/'){return is_writable($file);}/* For Windows servers and safe_mode ""on"" installations we'll actually * write a file then read it. Bah... */if (is_dir($file)){$file = rtrim($file, '/').'/'.md5(mt_rand());if (($fp = @fopen($file, 'ab')) === FALSE){return FALSE;}fclose($fp);@chmod($file, 0777);@unlink($file);return TRUE;}elseif ( ! is_file($file) OR ($fp = @fopen($file, 'ab')) === FALSE){return FALSE;}fclose($fp);return TRUE;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
360,bcit-ci_CodeIgniter_Common_337, Returns the MIME types array from config/mimes.php\n\n @return\tarray\n,Vrac?a niz MIME tipova iz config / mimes.php,"function &get_mimes(){static $_mimes;if (empty($_mimes)){$_mimes = file_exists(APPPATH.'config/mimes.php')? include(APPPATH.'config/mimes.php'): array();if (file_exists(APPPATH.'config/'.ENVIRONMENT.'/mimes.php')){$_mimes = array_merge($_mimes, include(APPPATH.'config/'.ENVIRONMENT.'/mimes.php'));}}return $_mimes;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
361,bcit-ci_CodeIgniter_Common_338, Is HTTPS?\\n\\n Determines if the application is accessed via an encrypted\\n (HTTPS) connection.\\n\\n @return\\tbool\\n,Da li je HTTPS? Određuje da li se aplikaciji može pristupiti sa enkriptovanom (HTPPS) konekcijom. ,function is_https(){if ( ! empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off'){return TRUE;}elseif (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) === 'https'){return TRUE;}elseif ( ! empty($_SERVER['HTTP_FRONT_END_HTTPS']) && strtolower($_SERVER['HTTP_FRONT_END_HTTPS']) !== 'off'){return TRUE;}return FALSE;},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
362,bcit-ci_CodeIgniter_Config_348, Build URI string\n\n @used-by\tCI_Config::site_url()\n @used-by\tCI_Config::base_url()\n\n @param\tstring|string[]\t$uri\tURI string or an array of segments\n @return\tstring\n, Pravljenje URI stringa ,"protected function _uri_string($uri){if ($this->item('enable_query_strings') === FALSE){is_array($uri) && $uri = implode('/', $uri);return ltrim($uri, '/');}elseif (is_array($uri)){return http_build_query($uri);}return $uri;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
363,bcit-ci_CodeIgniter_Config_349, Set a config file item\n\n @param\tstring\t$item\tConfig item key\n @param\tstring\t$value\tConfig item value\n @return\tvoid\n,Postavljanje stavke konfiguracinog fajla,"public function set_item($item, $value){$this->config[$item] = $value;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
364,bcit-ci_CodeIgniter_Exceptions_357, Native PHP error handler\\n\\n @param\\tint\\t$severity\\tError level\\n @param\\tstring\\t$message\\tError message\\n @param\\tstring\\t$filepath\\tFile path\\n @param\\tint\\t$line\\t\\tLine number\\n @return\\tvoid\\n, Izvorni PHP rukovalac greškama,"public function show_php_error($severity, $message, $filepath, $line){$templates_path = config_item('error_views_path');if (empty($templates_path)){$templates_path = VIEWPATH.'errors'.DIRECTORY_SEPARATOR;}else{$templates_path = rtrim($templates_path, '/\\').DIRECTORY_SEPARATOR;}$severity = isset($this->levels[$severity]) ? $this->levels[$severity] : $severity;// For safety reasons we don't show the full file path in non-CLI requestsif ( ! is_cli()){$filepath = str_replace('\\', '/', $filepath);if (FALSE !== strpos($filepath, '/')){$x = explode('/', $filepath);$filepath = $x[count($x)-2].'/'.end($x);}$template = 'html'.DIRECTORY_SEPARATOR.'error_php';}else{$template = 'cli'.DIRECTORY_SEPARATOR.'error_php';}if (ob_get_level() > $this->ob_level + 1){ob_end_flush();}ob_start();include($templates_path.$template.'.php');$buffer = ob_get_contents();ob_end_clean();echo $buffer;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
365,bcit-ci_CodeIgniter_Input_365, Magic __get()\n\n Allows read access to protected properties\n\n @param\tstring\t$name\n @return\tmixed\n, Magi?ni __get() Omogućava čitanje zaštićenih svojstava,public function __get($name){if ($name === 'raw_input_stream'){isset($this->_raw_input_stream) OR $this->_raw_input_stream = file_get_contents('php://input');return $this->_raw_input_stream;}elseif ($name === 'ip_address'){return $this->ip_address;}},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
366,bcit-ci_CodeIgniter_Loader_371, Is Loaded\n\n A utility method to test if a class is in the self::$_ci_classes array.\n\n @used-by\tMainly used by Form Helper function _get_validation_object().\n\n @param \tstring\t\t$class\tClass name to check for\n @return \tstring|bool\tClass object name if loaded or FALSE\n,Da li je u?itano Uslužna metoda koja testira da li je klasa u nizu Uglavnom se koristi od strane Form Helper funkcije _get_validation_object().,"public function is_loaded($class){return array_search(ucfirst($class), $this->_ci_classes, TRUE);}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
367,bcit-ci_CodeIgniter_Loader_373, Get Variable\\n\\n Check if a variable is set and retrieve it.\\n\\n @param\\tstring\\t$key\\tVariable name\\n @return\\tmixed\\tThe variable or NULL if not found\\n,Vrati varijablu Proverava da li je varijabla postavljena i vraća je. ,public function get_var($key){return isset($this->_ci_cached_vars[$key]) ? $this->_ci_cached_vars[$key] : NULL;},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
368,bcit-ci_CodeIgniter_Loader_377, CI Autoloader\\n\\n Loads component listed in the config/autoload.php file.\\n\\n @used-by\\tCI_Loader::initialize()\\n @return\\tvoid\\n, CI Autoloader Učitava komponente koje su navedene u config/autoload.php file.,"protected function _ci_autoloader(){if (file_exists(APPPATH.'config/autoload.php')){include(APPPATH.'config/autoload.php');}if (file_exists(APPPATH.'config/'.ENVIRONMENT.'/autoload.php')){include(APPPATH.'config/'.ENVIRONMENT.'/autoload.php');}if ( ! isset($autoload)){return;}// Autoload packagesif (isset($autoload['packages'])){foreach ($autoload['packages'] as $package_path){$this->add_package_path($package_path);}}// Load any custom config fileif (count($autoload['config']) > 0){foreach ($autoload['config'] as $val){$this->config($val);}}// Autoload helpers and languagesforeach (array('helper', 'language') as $type){if (isset($autoload[$type]) && count($autoload[$type]) > 0){$this->$type($autoload[$type]);}}// Autoload driversif (isset($autoload['drivers'])){$this->driver($autoload['drivers']);}// Load librariesif (isset($autoload['libraries']) && count($autoload['libraries']) > 0){// Load the database driver.if (in_array('database', $autoload['libraries'])){$this->database();$autoload['libraries'] = array_diff($autoload['libraries'], array('database'));}// Load all other libraries$this->library($autoload['libraries']);}// Autoload modelsif (isset($autoload['model'])){$this->model($autoload['model']);}}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
369,bcit-ci_CodeIgniter_Loader_378," Prepare variables for _ci_vars, to be later extract()-ed inside views\n\n Converts objects to associative arrays and filters-out internal\n variable names (i.e. keys prefixed with '_ci_').\n\n @param\tmixed\t$vars\n @return\tarray\n"," Pripremanje varijabli za _ci_vars,  da kasnije budu extract()-ovane unutar pogleda Konvertuje objekte da se povežu nizovi i  filtrira unutrašnja imena varijabli (t.j. ključeve sa prefiksom '_ci_'). ","protected function _ci_prepare_view_vars($vars){if ( ! is_array($vars)){$vars = is_object($vars)? get_object_vars($vars): array();}foreach (array_keys($vars) as $key){if (strncmp($key, '_ci_', 4) === 0){unset($vars[$key]);}}return $vars;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
370,blueimp_jQuery-File-Upload_UploadHandler_2," Fix for overflowing signed 32 bit integers,\n works for sizes up to 2^32-1 bytes (4 GiB - 1):\n","Ispravka za prekora?njenje 32-bitnih celih brojeva, radi sa veli?inama do 2^32-1 bitova (4 GB - 1)",    protected function fix_integer_overflow($size) {        if ($size < 0) {            $size += 2.0 * (PHP_INT_MAX + 1);        },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
371,bobthecow_psysh_CodeCleaner_1453, Get default CodeCleaner passes.\n\n @return array\n,Vra?a podrazumevane propusnice CodeCleaner.,"    private function getDefaultPasses()    {        if ($this->yolo) {            return $this->getYoloPasses();        }        $useStatementPass = new UseStatementPass();        $namespacePass = new NamespacePass($this);        // Try to add implicit `use` statements and an implicit namespace,        // based on the file in which the `debug` call was made.        $this->addImplicitDebugContext([$useStatementPass, $namespacePass]);        return [            // Validation passes            new AbstractClassPass(),            new AssignThisVariablePass(),            new CalledClassPass(),            new CallTimePassByReferencePass(),            new FinalClassPass(),            new FunctionContextPass(),            new FunctionReturnInWriteContextPass(),            new InstanceOfPass(),            new IssetPass(),            new LabelContextPass(),            new LeavePsyshAlonePass(),            new ListPass(),            new LoopContextPass(),            new PassableByReferencePass(),            new ReturnTypePass(),            new EmptyArrayDimFetchPass(),            new ValidConstructorPass(),            // Rewriting shenanigans            $useStatementPass,        // must run before the namespace pass            new ExitPass(),            new ImplicitReturnPass(),            new MagicConstantsPass(),            $namespacePass,           // must run after the implicit return pass            new RequirePass(),            new StrictTypesPass(),            // Namespace-aware validation (which depends on aforementioned shenanigans)            new ValidClassNamePass(),            new ValidConstantPass(),            new ValidFunctionNamePass(),        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
372,bobthecow_psysh_CodeCleaner_1456, Search the stack trace for a file in which the user called Psy\\debug.\n\n @return string|null\n,Pretraživanje traga steka za datoteku u kojoj je korisnik nazvao Psi,"    private static function getDebugFile()    {        $trace = \debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS);        foreach (\array_reverse($trace) as $stackFrame) {            if (!self::isDebugCall($stackFrame)) {                continue;            }            if (\preg_match('/eval\(/', $stackFrame['file'])) {                \preg_match_all('/([^\(]+)\((\d+)/', $stackFrame['file'], $matches);                return $matches[1][0];            }            return $stackFrame['file'];        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
373,bobthecow_psysh_ConfigPaths_1468, Find real config files in config directories.\n\n @param string[] $names Config file names\n\n @return string[]\n,Pronalaženje prave konfiguracione datoteke u direktorijumima konfiguracije.,"    public function configFiles(array $names)    {        return $this->allRealFiles($this->configDirs(), $names);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
374,bobthecow_psysh_ConfigPaths_1477," Ensure that $file exists and is writable, make the parent directory if necessary.\n\n Generates E_USER_NOTICE error if either $file or its directory is not writable.\n\n @param string $file\n\n @return string|false Full path to $file, or false if file is not writable\n","Osigurava da $file postoji i da se može u njega upisati, ako je potrebno pravi roditeljski direktorijum. Generiše E_USER_NOTICE grešku ako ili u $file ili u neki od njegovih direktorijuma nije moguće upisati.","    public static function touchFileWithMkdir($file)    {        if (\file_exists($file)) {            if (\is_writable($file)) {                return $file;            }            \trigger_error(\sprintf('Writing to %s is not allowed.', $file), \E_USER_NOTICE);            return false;        }        if (!self::ensureDir(\dirname($file))) {            return false;        }        \touch($file);        return $file;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
375,bobthecow_psysh_Configuration_1480," Get the desired config file from the given input.\n\n @return string|null config file path, or null if none is specified\n",Vra?a željenu konfiguracionu datoteku sa datog ulaza.,"    private static function getConfigFileFromInput(InputInterface $input)    {        // Best case, input is properly bound and validated.        if ($input->hasOption('config')) {            return $input->getOption('config');        }        return $input->getParameterOption('--config', null, true) ?: $input->getParameterOption('-c', null, true);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
376,bobthecow_psysh_Configuration_1491, Set the shell's data directory location.\n\n @param string $dir\n,Postavlja lokaciju direktorijuma podataka ljuske.,"    public function setDataDir($dir)    {        $this->dataDir = (string) $dir;        $this->configPaths->overrideDirs([            'configDir'  => $this->configDir,            'dataDir'    => $this->dataDir,            'runtimeDir' => $this->runtimeDir,        ]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
377,bobthecow_psysh_Configuration_1493, Set the shell's temporary directory location.\n\n @param string $dir\n,Postavlja trenutnu lokaciju direktorijuma podataka ljuske.,"    public function setRuntimeDir($dir)    {        $this->runtimeDir = (string) $dir;        $this->configPaths->overrideDirs([            'configDir'  => $this->configDir,            'dataDir'    => $this->dataDir,            'runtimeDir' => $this->runtimeDir,        ]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
378,bobthecow_psysh_Configuration_1498, Get the readline max history size.\n\n @return int\n,Vra?a maksimalnu veli?inu istorije za ?itanje.,    public function getHistorySize()    {        return $this->historySize;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
379,bobthecow_psysh_Configuration_1499, Sets whether readline erases old duplicate history entries.\n\n @param bool $value\n,Postavlja da li linija za ?itanje briše stare duplikate unosa istorije.,    public function setEraseDuplicates($value)    {        $this->eraseDuplicates = (bool) $value;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
380,bobthecow_psysh_Configuration_1502, Get a filename suitable for a FIFO pipe of $type for process $pid.\n\n The pipe will be created inside the current temporary directory.\n\n @param string $type\n @param int    $pid\n\n @return string Pipe name\n,Vra?a naziv datoteke pogodan za FIFO cev $type za proces $pid. Cev će biti kreirana unutar trenutnog privremenog direktorijuma.,"    public function getPipe($type, $pid)    {        return \sprintf('%s/%s_%s', $this->getRuntimeDir(), $type, $pid);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
381,bobthecow_psysh_Configuration_1513," Check whether to use Pcntl.\n\n If `setUsePcntl` has been set to true, but Pcntl is not actually\n available, this will return false.\n\n @return bool True if the current Shell should use Pcntl\n","Proverava da li da koristi Pcntl. Ako `setUsePcntl` nije postavljeno na talno, ali Pcntl zapravo nije dostupan, ovo će uvek vratiti tačno.",    public function usePcntl()    {        return isset($this->usePcntl) ? ($this->hasPcntl && $this->usePcntl) : $this->hasPcntl;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
382,bobthecow_psysh_Configuration_1518," Enable or disable Unicode in PsySH specific output.\n\n Note that this does not disable Unicode output in general, it just makes\n it so PsySH won't output any itself.\n\n @param bool $useUnicode\n","Omoguc?ite ili onemoguc?ite Unicode u izlazu specifi?nom za PsiSH.  Imajte na umu da ovo uopšte ne onemogućava Unicode izlaz, već samo to čini tako da PsiSH neće sam davati bilo koji.",    public function setUseUnicode($useUnicode)    {        $this->useUnicode = (bool) $useUnicode;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
383,bobthecow_psysh_Configuration_1519," Check whether to use Unicode in PsySH specific output.\n\n Note that this does not disable Unicode output in general, it just makes\n it so PsySH won't output any itself.\n\n @return bool\n","Proverava da li treba koristiti Unicode u izlazu specifi?nom za PsiSH. Imajte na umu da ovo uopšte ne onemogućava Unicode izlaz, već samo to čini tako da PsiSH neće sam davati bilo koji.",    public function useUnicode()    {        if (isset($this->useUnicode)) {            return $this->useUnicode;        }        // @todo detect `chsh` != 65001 on Windows and return false        return true;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
384,bobthecow_psysh_Configuration_1526, Enable or disable tab completion.\n\n @param bool $useTabCompletion\n,Omoguc?ite ili onemoguc?ite dovršavanje.,    public function setUseTabCompletion($useTabCompletion)    {        $this->useTabCompletion = (bool) $useTabCompletion;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
385,bobthecow_psysh_Configuration_1528," Check whether to use tab completion.\n\n If `setUseTabCompletion` has been set to true, but readline is not\n actually available, this will return false.\n\n @return bool True if the current Shell should use tab completion\n","Proveravnje da li treba koristiti završetak kartice. Ako `setUseTabCompletion` je postavljena na tačno, ali čitanje linije nije zapravo dostupno, ovo uvek vraća tačno.",    public function useTabCompletion()    {        return isset($this->useTabCompletion) ? ($this->hasReadline && $this->useTabCompletion) : $this->hasReadline;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
386,bobthecow_psysh_Configuration_1533, Get the interactive setting for shell input.\n\n @return bool\n,Vra?a interaktivno podešavanje za unos ljuske.,    public function getInputInteractive()    {        switch ($this->interactiveMode()) {            case self::INTERACTIVE_MODE_AUTO:                return !$this->inputIsPiped();            case self::INTERACTIVE_MODE_FORCED:                return true;            case self::INTERACTIVE_MODE_DISABLED:                return false;        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
387,bobthecow_psysh_Configuration_1534," Set the OutputPager service.\n\n If a string is supplied, a ProcOutputPager will be used which shells out\n to the specified command.\n\n @throws \\InvalidArgumentException if $pager is not a string or OutputPager instance\n\n @param string|OutputPager $pager\n","Postavljanje usluge OutputPager. Ako je string dostupan, koristiće se ProcOutputPager koji se ljušti prema navedenoj naredbi.",    public function setPager($pager)    {        if ($pager && !\is_string($pager) && !$pager instanceof OutputPager) {            throw new \InvalidArgumentException('Unexpected pager instance');        }        $this->pager = $pager;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
388,bobthecow_psysh_Configuration_1536, Set the Shell AutoCompleter service.\n\n @param AutoCompleter $autoCompleter\n,Postavljanje usluge Shell AutoCompleter.,    public function setAutoCompleter(AutoCompleter $autoCompleter)    {        $this->autoCompleter = $autoCompleter;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
389,bobthecow_psysh_Configuration_1548, Add an array of casters definitions.\n\n @param array $casters\n,Dodavanje niza definicija kota?ic?a.,    public function addCasters(array $casters)    {        $this->getPresenter()->addCasters($casters);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
390,bobthecow_psysh_Configuration_1566, Set the force array indexes.\n\n @param bool $forceArrayIndexes\n,Postavljanje indeksa niza sila.,    public function setForceArrayIndexes($forceArrayIndexes)    {        $this->forceArrayIndexes = $forceArrayIndexes;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
391,bobthecow_psysh_Configuration_1568," Internal method for applying output formatter style customization.\n\n This is called on initialization of the shell output, and again if the\n formatter styles config is updated.\n","Interna metoda za primenu prilago?avanja stila izlaznog formatera. Ovo se poziva pri inicijalizaciji izlaza ljuske, i opet ako su podešavanja formatera stila ažuriran.","    private function applyFormatterStyles()    {        $formatter = $this->output->getFormatter();        foreach ($this->formatterStyles as $name => $style) {            $formatter->setStyle($name, $style);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
392,bobthecow_psysh_Configuration_1570, Set the shell output verbosity.\n\n Accepts OutputInterface verbosity constants.\n\n @param string $verbosity\n, Podesite opširnost izlaza ljuske. Prihvata razne OutputInterface konstante.,"    public function setVerbosity($verbosity)    {        $validVerbosityLevels = [            self::VERBOSITY_QUIET,            self::VERBOSITY_NORMAL,            self::VERBOSITY_VERBOSE,            self::VERBOSITY_VERY_VERBOSE,            self::VERBOSITY_DEBUG,        ];        if (!\in_array($verbosity, $validVerbosityLevels)) {            throw new \InvalidArgumentException('Invalid verbosity level: '.$verbosity);        }        $this->verbosity = $verbosity;        if (isset($this->output)) {            $this->output->setVerbosity($this->getOutputVerbosity());        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
393,bobthecow_psysh_Context_1578," The Shell execution context.\n\n This class encapsulates the current variables, most recent return value and\n exception, and the current namespace.\n","Kontekst izvršenja Shell. Ova klasa enkapsulira trenutne varijable, najnovije povratne vrednosti, i izuzetke, i trenutni namespace. ","class Context{    private static $specialNames = ['_', '_e', '__out', '__psysh__', 'this'];    // Whitelist a very limited number of command-scope magic variable names.    // This might be a bad idea, but future me can sort it out.    private static $commandScopeNames = [        '__function', '__method', '__class', '__namespace', '__file', '__line', '__dir',    ];    private $scopeVariables = [];    private $commandScopeVariables = [];    private $returnValue;    private $lastException;    private $lastStdout;    private $boundObject;    private $boundClass;    /**     * Get a context variable.     *     * @throws \InvalidArgumentException If the variable is not found in the current context     *     * @param string $name     *     * @return mixed     */    public function get($name)    {        switch ($name) {            case '_':                return $this->returnValue;            case '_e':                if (isset($this->lastException)) {                    return $this->lastException;                }                break;            case '__out':                if (isset($this->lastStdout)) {                    return $this->lastStdout;                }                break;            case 'this':                if (isset($this->boundObject)) {                    return $this->boundObject;                }                break;            case '__function':            case '__method':            case '__class':            case '__namespace':            case '__file':            case '__line':            case '__dir':                if (\array_key_exists($name, $this->commandScopeVariables)) {                    return $this->commandScopeVariables[$name];                }                break;            default:                if (\array_key_exists($name, $this->scopeVariables)) {                    return $this->scopeVariables[$name];                }                break;        }        throw new \InvalidArgumentException('Unknown variable: $'.$name);    }    /**     * Get all defined variables.     *     * @return array     */    public function getAll()    {        return \array_merge($this->scopeVariables, $this->getSpecialVariables());    }    /**     * Get all defined magic variables: $_, $_e, $__out, $__class, $__file, etc.     *     * @return array     */    public function getSpecialVariables()    {        $vars = [            '_' => $this->returnValue,        ];        if (isset($this->lastException)) {            $vars['_e'] = $this->lastException;        }        if (isset($this->lastStdout)) {            $vars['__out'] = $this->lastStdout;        }        if (isset($this->boundObject)) {            $vars['this'] = $this->boundObject;        }        return \array_merge($vars, $this->commandScopeVariables);    }    /**     * Set all scope variables.     *     * This method does *not* set any of the magic variables: $_, $_e, $__out,     * $__class, $__file, etc.     *     * @param array $vars     */    public function setAll(array $vars)    {        foreach (self::$specialNames as $key) {            unset($vars[$key]);        }        foreach (self::$commandScopeNames as $key) {            unset($vars[$key]);        }        $this->scopeVariables = $vars;    }    /**     * Set the most recent return value.     *     * @param mixed $value     */    public function setReturnValue($value)    {        $this->returnValue = $value;    }    /**     * Get the most recent return value.     *     * @return mixed     */    public function getReturnValue()    {        return $this->returnValue;    }    /**     * Set the most recent Exception.     *     * @param \Exception $e     */    public function setLastException(\Exception $e)    {        $this->lastException = $e;    }    /**     * Get the most recent Exception.     *     * @throws \InvalidArgumentException If no Exception has been caught     *     * @return \Exception|null     */    public function getLastException()    {        if (!isset($this->lastException)) {            throw new \InvalidArgumentException('No most-recent exception');        }        return $this->lastException;    }    /**     * Set the most recent output from evaluated code.     *     * @param string $lastStdout     */    public function setLastStdout($lastStdout)    {        $this->lastStdout = $lastStdout;    }    /**     * Get the most recent output from evaluated code.     *     * @throws \InvalidArgumentException If no output has happened yet     *     * @return string|null     */    public function getLastStdout()    {        if (!isset($this->lastStdout)) {            throw new \InvalidArgumentException('No most-recent output');        }        return $this->lastStdout;    }    /**     * Set the bound object ($this variable) for the interactive shell.     *     * Note that this unsets the bound class, if any exists.     *     * @param object|null $boundObject     */    public function setBoundObject($boundObject)    {        $this->boundObject = \is_object($boundObject) ? $boundObject : null;        $this->boundClass = null;    }    /**     * Get the bound object ($this variable) for the interactive shell.     *     * @return object|null     */    public function getBoundObject()    {        return $this->boundObject;    }    /**     * Set the bound class (self) for the interactive shell.     *     * Note that this unsets the bound object, if any exists.     *     * @param string|null $boundClass     */    public function setBoundClass($boundClass)    {        $this->boundClass = (\is_string($boundClass) && $boundClass !== '') ? $boundClass : null;        $this->boundObject = null;    }    /**     * Get the bound class (self) for the interactive shell.     *     * @return string|null     */    public function getBoundClass()    {        return $this->boundClass;    }    /**     * Set command-scope magic variables: $__class, $__file, etc.     *     * @param array $commandScopeVariables     */    public function setCommandScopeVariables(array $commandScopeVariables)    {        $vars = [];        foreach ($commandScopeVariables as $key => $value) {            // kind of type check            if (\is_scalar($value) && \in_array($key, self::$commandScopeNames)) {                $vars[$key] = $value;            }        }        $this->commandScopeVariables = $vars;    }    /**     * Get command-scope magic variables: $__class, $__file, etc.     *     * @return array     */    public function getCommandScopeVariables()    {        return $this->commandScopeVariables;    }    /**     * Get unused command-scope magic variables names: __class, __file, etc.     *     * This is used by the shell to unset old command-scope variables after a     * new batch is set.     *     * @return array Array of unused variable names     */    public function getUnusedCommandScopeVariableNames()    {        return \array_diff(self::$commandScopeNames, \array_keys($this->commandScopeVariables));    }    /**     * Check whether a variable name is a magic variable.     *     * @param string $name     *     * @return bool     */    public static function isSpecialVariableName($name)    {        return \in_array($name, self::$specialNames) || \in_array($name, self::$commandScopeNames);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
394,bobthecow_psysh_Context_1580, Get all defined variables.\n\n @return array\n,Vra?a sve definisane promenljive.,"    public function getAll()    {        return \array_merge($this->scopeVariables, $this->getSpecialVariables());    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
395,bobthecow_psysh_Context_1585, Set the most recent Exception.\n\n @param \\Exception $e\n,Postavite najnoviji izuzetak.,    public function setLastException(\Exception $e)    {        $this->lastException = $e;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
396,bobthecow_psysh_Context_1596, Check whether a variable name is a magic variable.\n\n @param string $name\n\n @return bool\n,Proverava da li je ime promenljive magi?na promenljiva.,"    public static function isSpecialVariableName($name)    {        return \in_array($name, self::$specialNames) || \in_array($name, self::$commandScopeNames);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
397,botman_botman_ArrayCache_1302, Determine if an item exists in the cache.\n\n @param  string $key\n @return bool\n,Odre?uje da li stavka postoji u keš memoriji.,    public function has($key)    {        return isset($this->cache[$key]);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
398,botman_botman_BotManDriverEventTest_1353, Return the event payload.\n\n @return mixed\n,Vrati korisni teret doga?aja.,"    public function getPayload()    {        return [            'event' => 'test_event',            'data' => 'foo',        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
399,botman_botman_BotMan_1271, Get the parameter names for the route.\n\n @param $value\n @return array\n,Vra?a ime parametara za rutu.,"    protected function compileParameterNames($value)    {        preg_match_all(Matcher::PARAM_NAME_REGEX, $value, $matches);        return array_map(function ($m) {            return trim($m, '?');        }, $matches[1]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
400,botman_botman_BotMan_1274, Listening for image files.\n\n @param $callback\n @return Command\n,Osluškiva? za slike.,"    public function receivesVideos($callback)    {        return $this->hears(Video::PATTERN, $callback);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
401,botman_botman_BotMan_1275, Listening for audio files.\n\n @param $callback\n @return Command\n,Osluškiva? za zvu?ne fajlove.,"    public function receivesAudio($callback)    {        return $this->hears(Audio::PATTERN, $callback);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
402,botman_botman_BotMan_1278, Listening for files attachment.\n\n @param $callback\n @return Command\n,Osluškiva? za priloge.,"    public function receivesFiles($callback)    {        return $this->hears(File::PATTERN, $callback);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
403,botman_botman_BotMan_1281, Try to match messages with the ones we should\n listen to.\n, Pokušaj da se upare poruke sa onima kojima bi trebali osluškuju.,"    public function listen()    {        try {            $isVerificationRequest = $this->verifyServices();            if (! $isVerificationRequest) {                $this->fireDriverEvents();                if ($this->firedDriverEvents === false) {                    $this->loadActiveConversation();                    if ($this->loadedConversation === false) {                        $this->callMatchingMessages();                    }                    /*                     * If the driver has a  ""messagesHandled"" method, call it.                     * This method can be used to trigger driver methods                     * once the messages are handles.                     */                    if (method_exists($this->getDriver(), 'messagesHandled')) {                        $this->getDriver()->messagesHandled();                    }                }                $this->firedDriverEvents = false;                $this->message = new IncomingMessage('', '', '', null, $this->config['bot_id']);            }        } catch (\Throwable $e) {            $this->exceptionHandler->handleException($e, $this);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
404,botman_botman_BotMan_527, Set a fallback message to use if no listener matches.\\n\\n @param callable $callback\\n,Podesite rezervnu poruku koja će se koristiti ako se nijedan osluškiva? ne podudara,    public function fallback($callback)    {        $this->fallbackMessage = $callback;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
405,botman_botman_BotMan_538, Listening for image files.\\n\\n @param $callback\\n @return Command\\n,Osluškiva? za slike.,"    public function receivesImages($callback)    {        return $this->hears(Image::PATTERN, $callback);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
406,botman_botman_BotMan_541, Listening for location attachment.\\n\\n @param $callback\\n @return Command\\n,Oslukiva? za priloge lokacije. ,"    public function receivesLocation($callback)    {        return $this->hears(Location::PATTERN, $callback);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
407,botman_botman_BotMan_544, Create a command group with shared attributes.\\n\\n @param  array $attributes\\n @param  \\\\Closure $callback\\n,Kreiranje grupe naredbi sa deljenim atributima.,"    public function group(array $attributes, Closure $callback)    {        $previousGroupAttributes = $this->groupAttributes;        $this->groupAttributes = array_merge_recursive($previousGroupAttributes, $attributes);        \call_user_func($callback, $this);        $this->groupAttributes = $previousGroupAttributes;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
408,botman_botman_BotMan_547, Call matching message callbacks.\\n,Povratni pozivi za podudaranje poziva.,"    protected function callMatchingMessages()    {        $matchingMessages = $this->conversationManager->getMatchingMessages($this->getMessages(), $this->middleware,            $this->getConversationAnswer(), $this->getDriver());        foreach ($matchingMessages as $matchingMessage) {            $this->command = $matchingMessage->getCommand();            $callback = $this->command->getCallback();            $callback = $this->getCallable($callback);            // Set the message first, so it's available for middlewares            $this->message = $matchingMessage->getMessage();            $commandMiddleware = Collection::make($this->command->getMiddleware())->filter(function ($middleware) {                return $middleware instanceof Heard;            })->toArray();            $this->message = $this->middleware->applyMiddleware('heard', $matchingMessage->getMessage(),                $commandMiddleware);            $parameterNames = $this->compileParameterNames($this->command->getPattern());            $parameters = $matchingMessage->getMatches();            if (\count($parameterNames) !== \count($parameters)) {                $parameters = array_merge(                //First, all named parameters (eg. function ($a, $b, $c))                    array_filter(                        $parameters,                        '\is_string',                        ARRAY_FILTER_USE_KEY                    ),                    //Then, all other unsorted parameters (regex non named results)                    array_filter(                        $parameters,                        '\is_integer',                        ARRAY_FILTER_USE_KEY                    )                );            }            $this->matches = $parameters;            array_unshift($parameters, $this);            $parameters = $this->conversationManager->addDataParameters($this->message, $parameters);            if (call_user_func_array($callback, array_values($parameters))) {                return;            }        }        if (empty($matchingMessages) && empty($this->getBotMessages()) && ! \is_null($this->fallbackMessage)) {            $this->callFallbackMessage();        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
409,botman_botman_BotMan_560, Load driver on wakeup.\\n,U?itajte drajvera pri bu?enju.,"    public function __wakeup()    {        $this->driver = DriverManager::loadFromName($this->driverName, $this->config);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
410,botman_botman_CodeIgniterCache_1305, Determine if an item exists in the cache.\n\n @param  string $key\n @return bool\n,Odre?uje da li stavka postoji u keš memoriji.,    public function has($key)    {        return $this->cache->get($key) !== false;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
411,botman_botman_LaravelCache_1312, Store an item in the cache.\n\n @param  string $key\n @param  mixed $value\n @param  \\DateTime|int $minutes\n @return void\n, Spremanje stavku u keš memoriju.,"    public function put($key, $value, $minutes)    {        if (! $minutes instanceof \DateTime) {            $minutes = $minutes * 60;        }        Cache::put($key, $value, $minutes);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
412,briannesbitt_Carbon_AbstractTestCase_385, Standardize given set of dates (or period) before assertion.\n\n @param array|\\DatePeriod $dates\n\n @return array\n,Standardizujte dati datum (ili period) pre tvrdnje.,    public function standardizeDates($dates)    {        $result = [];        foreach ($dates as $date) {            if ($date instanceof DateTime) {                $date = Carbon::instance($date);            } elseif (is_string($date)) {                $date = Carbon::parse($date);            }            $result[] = $date->format('Y-m-d H:i:s P');        }        return $result;    },0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
413,briannesbitt_Carbon_AddTest_402, Test non plural methods with non default args.\\n,Testiramke metode bez množine sa nepodrazumevanim argumentima.,"    public function testAddYearPassingArg()    {        // addYear should ideally be used without argument        /** @var mixed $date */        $date = Carbon::createFromDate(1975);        $this->assertSame(1977, $date->addYear(2)->year);        $this->assertSame(1977, Carbon::createFromDate(1975)->add(2, 'year')->year);        $this->assertSame(1977, Carbon::createFromDate(1975)->add(2, 'years')->year);        $this->assertSame(1977, Carbon::createFromDate(1975)->add(CarbonInterval::years(2))->year);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
414,briannesbitt_Carbon_CarbonImmutable_4, Create a very old date representing start of time.\\\\n\\\\n @return static\\\\n,Kreira  vrlo stari datum koji predstavlja po?etak vremena.,    public static function startOfTime(): self    {        $date = static::parse('0001-01-01')->years(self::getStartOfTimeYear());        $date->startOfTime = true;        return $date;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
415,briannesbitt_Carbon_CarbonInterval_209," A simple API extension for DateInterval.\\\\n The implementation provides helpers to handle weeks but only days are saved.\\\\n Weeks are calculated based on the total days of the current instance.\\\\n\\\\n @property int $years Total years of the current interval.\\\\n @property int $months Total months of the current interval.\\\\n @property int $weeks Total weeks of the current interval calculated from the days.\\\\n @property int $dayz Total days of the current interval (weeks  @property int $hours Total hours of the current interval.\\\\n @property int $minutes Total minutes of the current interval.\\\\n @property int $seconds Total seconds of the current interval.\\\\n @property int $microseconds Total microseconds of the current interval.\\\\n @property int $milliseconds Total microseconds of the current interval.\\\\n @property int $microExcludeMilli Remaining microseconds without the milliseconds.\\\\n @property int $dayzExcludeWeeks Total days remaining in the final week of the current instance (days % 7).\\\\n @property int $daysExcludeWeeks alias of dayzExcludeWeeks\\\\n @property-read float $totalYears Number of years equivalent to the interval.\\\\n @property-read float $totalMonths Number of months equivalent to the interval.\\\\n @property-read float $totalWeeks Number of weeks equivalent to the interval.\\\\n @property-read float $totalDays Number of days equivalent to the interval.\\\\n @property-read float $totalDayz Alias for totalDays.\\\\n @property-read float $totalHours Number of hours equivalent to the interval.\\\\n @property-read float $totalMinutes Number of minutes equivalent to the interval.\\\\n @property-read float $totalSeconds Number of seconds equivalent to the interval.\\\\n @property-read float $totalMilliseconds Number of milliseconds equivalent to the interval.\\\\n @property-read float $totalMicroseconds Number of microseconds equivalent to the interval.\\\\n @property-read string $locale locale of the current instance\\\\n\\\\n @method static CarbonInterval years($years = 1) Create instance specifying a number of years or modify the number of years if called on an instance.\\\\n @method static CarbonInterval year($years = 1) Alias for years()\\\\n @method static CarbonInterval months($months = 1) Create instance specifying a number of months or modify the number of months if called on an instance.\\\\n @method static CarbonInterval month($months = 1) Alias for months()\\\\n @method static CarbonInterval weeks($weeks = 1) Create instance specifying a number of weeks or modify the number of weeks if called on an instance.\\\\n @method static CarbonInterval week($weeks = 1) Alias for weeks()\\\\n @method static CarbonInterval days($days = 1) Create instance specifying a number of days or modify the number of days if called on an instance.\\\\n @method static CarbonInterval dayz($days = 1) Alias for days()\\\\n @method static CarbonInterval daysExcludeWeeks($days = 1) Create instance specifying a number of days or modify the number of days (keeping the current number of weeks) if called on an instance.\\\\n @method static CarbonInterval dayzExcludeWeeks($days = 1) Alias for daysExcludeWeeks()\\\\n @method static CarbonInterval day($days = 1) Alias for days()\\\\n @method static CarbonInterval hours($hours = 1) Create instance specifying a number of hours or modify the number of hours if called on an instance.\\\\n @method static CarbonInterval hour($hours = 1) Alias for hours()\\\\n @method static CarbonInterval minutes($minutes = 1) Create instance specifying a number of minutes or modify the number of minutes if called on an instance.\\\\n @method static CarbonInterval minute($minutes = 1) Alias for minutes()\\\\n @method static CarbonInterval seconds($seconds = 1) Create instance specifying a number of seconds or modify the number of seconds if called on an instance.\\\\n @method static CarbonInterval second($seconds = 1) Alias for seconds()\\\\n @method static CarbonInterval milliseconds($milliseconds = 1) Create instance specifying a number of milliseconds or modify the number of milliseconds if called on an instance.\\\\n @method static CarbonInterval millisecond($milliseconds = 1) Alias for milliseconds()\\\\n @method static CarbonInterval microseconds($microseconds = 1) Create instance specifying a number of microseconds or modify the number of microseconds if called on an instance.\\\\n @method static CarbonInterval microsecond($microseconds = 1) Alias for microseconds()\\\\n @method $this addYears(int $years) Add given number of years to the current interval\\\\n @method $this subYears(int $years) Subtract given number of years to the current interval\\\\n @method $this addMonths(int $months) Add given number of months to the current interval\\\\n @method $this subMonths(int $months) Subtract given number of months to the current interval\\\\n @method $this addWeeks(int|float $weeks) Add given number of weeks to the current interval\\\\n @method $this subWeeks(int|float $weeks) Subtract given number of weeks to the current interval\\\\n @method $this addDays(int|float $days) Add given number of days to the current interval\\\\n @method $this subDays(int|float $days) Subtract given number of days to the current interval\\\\n @method $this addHours(int|float $hours) Add given number of hours to the current interval\\\\n @method $this subHours(int|float $hours) Subtract given number of hours to the current interval\\\\n @method $this addMinutes(int|float $minutes) Add given number of minutes to the current interval\\\\n @method $this subMinutes(int|float $minutes) Subtract given number of minutes to the current interval\\\\n @method $this addSeconds(int|float $seconds) Add given number of seconds to the current interval\\\\n @method $this subSeconds(int|float $seconds) Subtract given number of seconds to the current interval\\\\n @method $this addMilliseconds(int|float $milliseconds) Add given number of milliseconds to the current interval\\\\n @method $this subMilliseconds(int|float $milliseconds) Subtract given number of milliseconds to the current interval\\\\n @method $this addMicroseconds(int|float $microseconds) Add given number of microseconds to the current interval\\\\n @method $this subMicroseconds(int|float $microseconds) Subtract given number of microseconds to the current interval\\\\n @method $this roundYear(int|float $precision = 1, string $function = ""round"") Round the current instance year with given precision using the given function.\\\\n @method $this roundYears(int|float $precision = 1, string $function = ""round"") Round the current instance year with given precision using the given function.\\\\n @method $this floorYear(int|float $precision = 1) Truncate the current instance year with given precision.\\\\n @method $this floorYears(int|float $precision = 1) Truncate the current instance year with given precision.\\\\n @method $this ceilYear(int|float $precision = 1) Ceil the current instance year with given precision.\\\\n @method $this ceilYears(int|float $precision = 1) Ceil the current instance year with given precision.\\\\n @method $this roundMonth(int|float $precision = 1, string $function = ""round"") Round the current instance month with given precision using the given function.\\\\n @method $this roundMonths(int|float $precision = 1, string $function = ""round"") Round the current instance month with given precision using the given function.\\\\n @method $this floorMonth(int|float $precision = 1) Truncate the current instance month with given precision.\\\\n @method $this floorMonths(int|float $precision = 1) Truncate the current instance month with given precision.\\\\n @method $this ceilMonth(int|float $precision = 1) Ceil the current instance month with given precision.\\\\n @method $this ceilMonths(int|float $precision = 1) Ceil the current instance month with given precision.\\\\n @method $this roundWeek(int|float $precision = 1, string $function = ""round"") Round the current instance day with given precision using the given function.\\\\n @method $this roundWeeks(int|float $precision = 1, string $function = ""round"") Round the current instance day with given precision using the given function.\\\\n @method $this floorWeek(int|float $precision = 1) Truncate the current instance day with given precision.\\\\n @method $this floorWeeks(int|float $precision = 1) Truncate the current instance day with given precision.\\\\n @method $this ceilWeek(int|float $precision = 1) Ceil the current instance day with given precision.\\\\n @method $this ceilWeeks(int|float $precision = 1) Ceil the current instance day with given precision.\\\\n @method $this roundDay(int|float $precision = 1, string $function = ""round"") Round the current instance day with given precision using the given function.\\\\n @method $this roundDays(int|float $precision = 1, string $function = ""round"") Round the current instance day with given precision using the given function.\\\\n @method $this floorDay(int|float $precision = 1) Truncate the current instance day with given precision.\\\\n @method $this floorDays(int|float $precision = 1) Truncate the current instance day with given precision.\\\\n @method $this ceilDay(int|float $precision = 1) Ceil the current instance day with given precision.\\\\n @method $this ceilDays(int|float $precision = 1) Ceil the current instance day with given precision.\\\\n @method $this roundHour(int|float $precision = 1, string $function = ""round"") Round the current instance hour with given precision using the given function.\\\\n @method $this roundHours(int|float $precision = 1, string $function = ""round"") Round the current instance hour with given precision using the given function.\\\\n @method $this floorHour(int|float $precision = 1) Truncate the current instance hour with given precision.\\\\n @method $this floorHours(int|float $precision = 1) Truncate the current instance hour with given precision.\\\\n @method $this ceilHour(int|float $precision = 1) Ceil the current instance hour with given precision.\\\\n @method $this ceilHours(int|float $precision = 1) Ceil the current instance hour with given precision.\\\\n @method $this roundMinute(int|float $precision = 1, string $function = ""round"") Round the current instance minute with given precision using the given function.\\\\n @method $this roundMinutes(int|float $precision = 1, string $function = ""round"") Round the current instance minute with given precision using the given function.\\\\n @method $this floorMinute(int|float $precision = 1) Truncate the current instance minute with given precision.\\\\n @method $this floorMinutes(int|float $precision = 1) Truncate the current instance minute with given precision.\\\\n @method $this ceilMinute(int|float $precision = 1) Ceil the current instance minute with given precision.\\\\n @method $this ceilMinutes(int|float $precision = 1) Ceil the current instance minute with given precision.\\\\n @method $this roundSecond(int|float $precision = 1, string $function = ""round"") Round the current instance second with given precision using the given function.\\\\n @method $this roundSeconds(int|float $precision = 1, string $function = ""round"") Round the current instance second with given precision using the given function.\\\\n @method $this floorSecond(int|float $precision = 1) Truncate the current instance second with given precision.\\\\n @method $this floorSeconds(int|float $precision = 1) Truncate the current instance second with given precision.\\\\n @method $this ceilSecond(int|float $precision = 1) Ceil the current instance second with given precision.\\\\n @method $this ceilSeconds(int|float $precision = 1) Ceil the current instance second with given precision.\\\\n @method $this roundMillennium(int|float $precision = 1, string $function = ""round"") Round the current instance millennium with given precision using the given function.\\\\n @method $this roundMillennia(int|float $precision = 1, string $function = ""round"") Round the current instance millennium with given precision using the given function.\\\\n @method $this floorMillennium(int|float $precision = 1) Truncate the current instance millennium with given precision.\\\\n @method $this floorMillennia(int|float $precision = 1) Truncate the current instance millennium with given precision.\\\\n @method $this ceilMillennium(int|float $precision = 1) Ceil the current instance millennium with given precision.\\\\n @method $this ceilMillennia(int|float $precision = 1) Ceil the current instance millennium with given precision.\\\\n @method $this roundCentury(int|float $precision = 1, string $function = ""round"") Round the current instance century with given precision using the given function.\\\\n @method $this roundCenturies(int|float $precision = 1, string $function = ""round"") Round the current instance century with given precision using the given function.\\\\n @method $this floorCentury(int|float $precision = 1) Truncate the current instance century with given precision.\\\\n @method $this floorCenturies(int|float $precision = 1) Truncate the current instance century with given precision.\\\\n @method $this ceilCentury(int|float $precision = 1) Ceil the current instance century with given precision.\\\\n @method $this ceilCenturies(int|float $precision = 1) Ceil the current instance century with given precision.\\\\n @method $this roundDecade(int|float $precision = 1, string $function = ""round"") Round the current instance decade with given precision using the given function.\\\\n @method $this roundDecades(int|float $precision = 1, string $function = ""round"") Round the current instance decade with given precision using the given function.\\\\n @method $this floorDecade(int|float $precision = 1) Truncate the current instance decade with given precision.\\\\n @method $this floorDecades(int|float $precision = 1) Truncate the current instance decade with given precision.\\\\n @method $this ceilDecade(int|float $precision = 1) Ceil the current instance decade with given precision.\\\\n @method $this ceilDecades(int|float $precision = 1) Ceil the current instance decade with given precision.\\\\n @method $this roundQuarter(int|float $precision = 1, string $function = ""round"") Round the current instance quarter with given precision using the given function.\\\\n @method $this roundQuarters(int|float $precision = 1, string $function = ""round"") Round the current instance quarter with given precision using the given function.\\\\n @method $this floorQuarter(int|float $precision = 1) Truncate the current instance quarter with given precision.\\\\n @method $this floorQuarters(int|float $precision = 1) Truncate the current instance quarter with given precision.\\\\n @method $this ceilQuarter(int|float $precision = 1) Ceil the current instance quarter with given precision.\\\\n @method $this ceilQuarters(int|float $precision = 1) Ceil the current instance quarter with given precision.\\\\n @method $this roundMillisecond(int|float $precision = 1, string $function = ""round"") Round the current instance millisecond with given precision using the given function.\\\\n @method $this roundMilliseconds(int|float $precision = 1, string $function = ""round"") Round the current instance millisecond with given precision using the given function.\\\\n @method $this floorMillisecond(int|float $precision = 1) Truncate the current instance millisecond with given precision.\\\\n @method $this floorMilliseconds(int|float $precision = 1) Truncate the current instance millisecond with given precision.\\\\n @method $this ceilMillisecond(int|float $precision = 1) Ceil the current instance millisecond with given precision.\\\\n @method $this ceilMilliseconds(int|float $precision = 1) Ceil the current instance millisecond with given precision.\\\\n @method $this roundMicrosecond(int|float $precision = 1, string $function = ""round"") Round the current instance microsecond with given precision using the given function.\\\\n @method $this roundMicroseconds(int|float $precision = 1, string $function = ""round"") Round the current instance microsecond with given precision using the given function.\\\\n @method $this floorMicrosecond(int|float $precision = 1) Truncate the current instance microsecond with given precision.\\\\n @method $this floorMicroseconds(int|float $precision = 1) Truncate the current instance microsecond with given precision.\\\\n @method $this ceilMicrosecond(int|float $precision = 1) Ceil the current instance microsecond with given precision.\\\\n @method $this ceilMicroseconds(int|float $precision = 1) Ceil the current instance microsecond with given precision.\\\\n",Jednostavno API proširenje za DateInterval. Implementacija omogućava helper-ima da rade sa sedmicama ali će samo dati biti sačuvani. Sedmice se računaju na osnovu ukupnog broja dana trenutne instance.,"class CarbonInterval extends DateInterval implements CarbonConverterInterface{    use IntervalRounding;    use IntervalStep;    use Mixin {        Mixin::mixin as baseMixin;    }    use Options;    /**     * Interval spec period designators     */    const PERIOD_PREFIX = 'P';    const PERIOD_YEARS = 'Y';    const PERIOD_MONTHS = 'M';    const PERIOD_DAYS = 'D';    const PERIOD_TIME_PREFIX = 'T';    const PERIOD_HOURS = 'H';    const PERIOD_MINUTES = 'M';    const PERIOD_SECONDS = 'S';    /**     * A translator to ... er ... translate stuff     *     * @var \Symfony\Component\Translation\TranslatorInterface     */    protected static $translator;    /**     * @var array|null     */    protected static $cascadeFactors;    /**     * @var array     */    protected static $formats = [        'y' => 'y',        'Y' => 'y',        'o' => 'y',        'm' => 'm',        'n' => 'm',        'W' => 'weeks',        'd' => 'd',        'j' => 'd',        'z' => 'd',        'h' => 'h',        'g' => 'h',        'H' => 'h',        'G' => 'h',        'i' => 'i',        's' => 's',        'u' => 'micro',        'v' => 'milli',    ];    /**     * @var array|null     */    private static $flipCascadeFactors;    /**     * The registered macros.     *     * @var array     */    protected static $macros = [];    /**     * Timezone handler for settings() method.     *     * @var mixed     */    protected $tzName;    /**     * Set the instance's timezone from a string or object and add/subtract the offset difference.     *     * @param \DateTimeZone|string $tzName     *     * @return static     */    public function shiftTimezone($tzName)    {        $this->tzName = $tzName;        return $this;    }    /**     * Mapping of units and factors for cascading.     *     * Should only be modified by changing the factors or referenced constants.     *     * @return array     */    public static function getCascadeFactors()    {        return static::$cascadeFactors ?: [            'milliseconds' => [Carbon::MICROSECONDS_PER_MILLISECOND, 'microseconds'],            'seconds' => [Carbon::MILLISECONDS_PER_SECOND, 'milliseconds'],            'minutes' => [Carbon::SECONDS_PER_MINUTE, 'seconds'],            'hours' => [Carbon::MINUTES_PER_HOUR, 'minutes'],            'dayz' => [Carbon::HOURS_PER_DAY, 'hours'],            'weeks' => [Carbon::DAYS_PER_WEEK, 'dayz'],            'months' => [Carbon::WEEKS_PER_MONTH, 'weeks'],            'years' => [Carbon::MONTHS_PER_YEAR, 'months'],        ];    }    private static function standardizeUnit($unit)    {        $unit = rtrim($unit, 'sz').'s';        return $unit === 'days' ? 'dayz' : $unit;    }    private static function getFlipCascadeFactors()    {        if (!self::$flipCascadeFactors) {            self::$flipCascadeFactors = [];            foreach (static::getCascadeFactors() as $to => [$factor, $from]) {                self::$flipCascadeFactors[self::standardizeUnit($from)] = [self::standardizeUnit($to), $factor];            }        }        return self::$flipCascadeFactors;    }    /**     * Set default cascading factors for ->cascade() method.     *     * @param array $cascadeFactors     */    public static function setCascadeFactors(array $cascadeFactors)    {        self::$flipCascadeFactors = null;        static::$cascadeFactors = $cascadeFactors;    }    ///////////////////////////////////////////////////////////////////    //////////////////////////// CONSTRUCTORS /////////////////////////    ///////////////////////////////////////////////////////////////////    /**     * Create a new CarbonInterval instance.     *     * @param int|null $years     * @param int|null $months     * @param int|null $weeks     * @param int|null $days     * @param int|null $hours     * @param int|null $minutes     * @param int|null $seconds     * @param int|null $microseconds     *     * @throws Exception when the interval_spec (passed as $years) cannot be parsed as an interval.     */    public function __construct($years = 1, $months = null, $weeks = null, $days = null, $hours = null, $minutes = null, $seconds = null, $microseconds = null)    {        if ($years instanceof Closure) {            $this->step = $years;            $years = null;        }        if ($years instanceof DateInterval) {            parent::__construct(static::getDateIntervalSpec($years));            $this->f = $years->f;            static::copyNegativeUnits($years, $this);            return;        }        $spec = $years;        if (!\is_string($spec) || \floatval($years) || preg_match('/^[0-9.]/', $years)) {            $spec = static::PERIOD_PREFIX;            $spec .= $years > 0 ? $years.static::PERIOD_YEARS : '';            $spec .= $months > 0 ? $months.static::PERIOD_MONTHS : '';            $specDays = 0;            $specDays += $weeks > 0 ? $weeks * static::getDaysPerWeek() : 0;            $specDays += $days > 0 ? $days : 0;            $spec .= $specDays > 0 ? $specDays.static::PERIOD_DAYS : '';            if ($hours > 0 || $minutes > 0 || $seconds > 0) {                $spec .= static::PERIOD_TIME_PREFIX;                $spec .= $hours > 0 ? $hours.static::PERIOD_HOURS : '';                $spec .= $minutes > 0 ? $minutes.static::PERIOD_MINUTES : '';                $spec .= $seconds > 0 ? $seconds.static::PERIOD_SECONDS : '';            }            if ($spec === static::PERIOD_PREFIX) {                // Allow the zero interval.                $spec .= '0'.static::PERIOD_YEARS;            }        }        parent::__construct($spec);        if (!\is_null($microseconds)) {            $this->f = $microseconds / Carbon::MICROSECONDS_PER_SECOND;        }    }    /**     * Returns the factor for a given source-to-target couple.     *     * @param string $source     * @param string $target     *     * @return int|null     */    public static function getFactor($source, $target)    {        $source = self::standardizeUnit($source);        $target = self::standardizeUnit($target);        $factors = static::getFlipCascadeFactors();        if (isset($factors[$source])) {            [$to, $factor] = $factors[$source];            if ($to === $target) {                return $factor;            }            return $factor * static::getFactor($to, $target);        }        return null;    }    /**     * Returns current config for days per week.     *     * @return int     */    public static function getDaysPerWeek()    {        return static::getFactor('dayz', 'weeks') ?: Carbon::DAYS_PER_WEEK;    }    /**     * Returns current config for hours per day.     *     * @return int     */    public static function getHoursPerDay()    {        return static::getFactor('hours', 'dayz') ?: Carbon::HOURS_PER_DAY;    }    /**     * Returns current config for minutes per hour.     *     * @return int     */    public static function getMinutesPerHour()    {        return static::getFactor('minutes', 'hours') ?: Carbon::MINUTES_PER_HOUR;    }    /**     * Returns current config for seconds per minute.     *     * @return int     */    public static function getSecondsPerMinute()    {        return static::getFactor('seconds', 'minutes') ?: Carbon::SECONDS_PER_MINUTE;    }    /**     * Returns current config for microseconds per second.     *     * @return int     */    public static function getMillisecondsPerSecond()    {        return static::getFactor('milliseconds', 'seconds') ?: Carbon::MILLISECONDS_PER_SECOND;    }    /**     * Returns current config for microseconds per second.     *     * @return int     */    public static function getMicrosecondsPerMillisecond()    {        return static::getFactor('microseconds', 'milliseconds') ?: Carbon::MICROSECONDS_PER_MILLISECOND;    }    /**     * Create a new CarbonInterval instance from specific values.     * This is an alias for the constructor that allows better fluent     * syntax as it allows you to do CarbonInterval::create(1)->fn() rather than     * (new CarbonInterval(1))->fn().     *     * @param int $years     * @param int $months     * @param int $weeks     * @param int $days     * @param int $hours     * @param int $minutes     * @param int $seconds     * @param int $microseconds     *     * @throws Exception when the interval_spec (passed as $years) cannot be parsed as an interval.     *     * @return static     */    public static function create($years = 1, $months = null, $weeks = null, $days = null, $hours = null, $minutes = null, $seconds = null, $microseconds = null)    {        return new static($years, $months, $weeks, $days, $hours, $minutes, $seconds, $microseconds);    }    /**     * Parse a string into a new CarbonInterval object according to the specified format.     *     * @example     * ```     * echo Carboninterval::createFromFormat('H:i', '1:30');     * ```     *     * @param string $format   Format of the $interval input string     * @param string $interval Input string to convert into an interval     *     * @throws Exception when the $interval cannot be parsed as an interval.     *     * @return static     */    public static function createFromFormat(string $format, ?string $interval)    {        $instance = new static(0);        $length = mb_strlen($format);        if (preg_match('/s([,.])([uv])$/', $format, $match)) {            $interval = explode($match[1], $interval);            $index = \count($interval) - 1;            $interval[$index] = str_pad($interval[$index], $match[2] === 'v' ? 3 : 6, '0');            $interval = implode($match[1], $interval);        }        $interval = $interval ?? '';        for ($index = 0; $index < $length; $index++) {            $expected = mb_substr($format, $index, 1);            $nextCharacter = mb_substr($interval, 0, 1);            $unit = static::$formats[$expected] ?? null;            if ($unit) {                if (!preg_match('/^-?\d+/', $interval, $match)) {                    throw new ParseErrorException('number', $nextCharacter);                }                $interval = mb_substr($interval, mb_strlen($match[0]));                $instance->$unit += \intval($match[0]);                continue;            }            if ($nextCharacter !== $expected) {                throw new ParseErrorException(                    ""'$expected'"",                    $nextCharacter,                    'Allowed substitutes for interval formats are '.implode(', ', array_keys(static::$formats)).""\n"".                    'See https://php.net/manual/en/function.date.php for their meaning'                );            }            $interval = mb_substr($interval, 1);        }        if ($interval !== '') {            throw new ParseErrorException(                'end of string',                $interval            );        }        return $instance;    }    /**     * Get a copy of the instance.     *     * @return static     */    public function copy()    {        $date = new static(0);        $date->copyProperties($this);        $date->step = $this->step;        return $date;    }    /**     * Get a copy of the instance.     *     * @return static     */    public function clone()    {        return $this->copy();    }    /**     * Provide static helpers to create instances.  Allows CarbonInterval::years(3).     *     * Note: This is done using the magic method to allow static and instance methods to     *       have the same names.     *     * @param string $method     magic method name called     * @param array  $parameters parameters list     *     * @return static|null     */    public static function __callStatic($method, $parameters)    {        try {            $interval = new static(0);            $localStrictModeEnabled = $interval->localStrictModeEnabled;            $interval->localStrictModeEnabled = true;            $result = static::hasMacro($method)                ? static::bindMacroContext(null, function () use (&$method, &$parameters, &$interval) {                    return $interval->callMacro($method, $parameters);                })                : $interval->$method(...$parameters);            $interval->localStrictModeEnabled = $localStrictModeEnabled;            return $result;        } catch (BadFluentSetterException $exception) {            if (Carbon::isStrictModeEnabled()) {                throw new BadFluentConstructorException($method, 0, $exception);            }            return null;        }    }    /**     * Return the current context from inside a macro callee or a new one if static.     *     * @return static     */    protected static function this()    {        return end(static::$macroContextStack) ?: new static(0);    }    /**     * Creates a CarbonInterval from string.     *     * Format:     *     * Suffix | Unit    | Example | DateInterval expression     * -------|---------|---------|------------------------     * y      | years   |   1y    | P1Y     * mo     | months  |   3mo   | P3M     * w      | weeks   |   2w    | P2W     * d      | days    |  28d    | P28D     * h      | hours   |   4h    | PT4H     * m      | minutes |  12m    | PT12M     * s      | seconds |  59s    | PT59S     *     * e. g. `1w 3d 4h 32m 23s` is converted to 10 days 4 hours 32 minutes and 23 seconds.     *     * Special cases:     *  - An empty string will return a zero interval     *  - Fractions are allowed for weeks, days, hours and minutes and will be converted     *    and rounded to the next smaller value (caution: 0.5w = 4d)     *     * @param string $intervalDefinition     *     * @return static     */    public static function fromString($intervalDefinition)    {        if (empty($intervalDefinition)) {            return new static(0);        }        $years = 0;        $months = 0;        $weeks = 0;        $days = 0;        $hours = 0;        $minutes = 0;        $seconds = 0;        $milliseconds = 0;        $microseconds = 0;        $pattern = '/(\d+(?:\.\d+)?)\h*([^\d\h]*)/i';        preg_match_all($pattern, $intervalDefinition, $parts, PREG_SET_ORDER);        while ([$part, $value, $unit] = array_shift($parts)) {            $intValue = \intval($value);            $fraction = \floatval($value) - $intValue;            // Fix calculation precision            switch (round($fraction, 6)) {                case 1:                    $fraction = 0;                    $intValue++;                    break;                case 0:                    $fraction = 0;                    break;            }            switch ($unit === 'Âµs' ? 'Âµs' : strtolower($unit)) {                case 'millennia':                case 'millennium':                    $years += $intValue * CarbonInterface::YEARS_PER_MILLENNIUM;                    break;                case 'century':                case 'centuries':                    $years += $intValue * CarbonInterface::YEARS_PER_CENTURY;                    break;                case 'decade':                case 'decades':                    $years += $intValue * CarbonInterface::YEARS_PER_DECADE;                    break;                case 'year':                case 'years':                case 'y':                    $years += $intValue;                    break;                case 'quarter':                case 'quarters':                    $months += $intValue * CarbonInterface::MONTHS_PER_QUARTER;                    break;                case 'month':                case 'months':                case 'mo':                    $months += $intValue;                    break;                case 'week':                case 'weeks':                case 'w':                    $weeks += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getDaysPerWeek(), 'd'];                    }                    break;                case 'day':                case 'days':                case 'd':                    $days += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getHoursPerDay(), 'h'];                    }                    break;                case 'hour':                case 'hours':                case 'h':                    $hours += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getMinutesPerHour(), 'm'];                    }                    break;                case 'minute':                case 'minutes':                case 'm':                    $minutes += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getSecondsPerMinute(), 's'];                    }                    break;                case 'second':                case 'seconds':                case 's':                    $seconds += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getMillisecondsPerSecond(), 'ms'];                    }                    break;                case 'millisecond':                case 'milliseconds':                case 'milli':                case 'ms':                    $milliseconds += $intValue;                    if ($fraction) {                        $microseconds += round($fraction * static::getMicrosecondsPerMillisecond());                    }                    break;                case 'microsecond':                case 'microseconds':                case 'micro':                case 'Âµs':                    $microseconds += $intValue;                    break;                default:                    throw new InvalidIntervalException(                        sprintf('Invalid part %s in definition %s', $part, $intervalDefinition)                    );            }        }        return new static($years, $months, $weeks, $days, $hours, $minutes, $seconds, $milliseconds * Carbon::MICROSECONDS_PER_MILLISECOND + $microseconds);    }    /**     * Creates a CarbonInterval from string using a different locale.     *     * @param string      $interval interval string in the given language (may also contain English).     * @param string|null $locale   if locale is null or not specified, current global locale will be used instead.     *     * @return static     */    public static function parseFromLocale($interval, $locale = null)    {        return static::fromString(Carbon::translateTimeString($interval, $locale ?: static::getLocale(), 'en'));    }    private static function castIntervalToClass(DateInterval $interval, string $className)    {        $mainClass = DateInterval::class;        if (!is_a($className, $mainClass, true)) {            throw new InvalidCastException(""$className is not a sub-class of $mainClass."");        }        $microseconds = $interval->f;        $instance = new $className(static::getDateIntervalSpec($interval));        if ($microseconds) {            $instance->f = $microseconds;        }        if ($interval instanceof self && is_a($className, self::class, true)) {            static::copyStep($interval, $instance);        }        static::copyNegativeUnits($interval, $instance);        return $instance;    }    private static function copyNegativeUnits(DateInterval $from, DateInterval $to): void    {        $to->invert = $from->invert;        foreach (['y', 'm', 'd', 'h', 'i', 's'] as $unit) {            if ($from->$unit < 0) {                $to->$unit *= -1;            }        }    }    private static function copyStep(self $from, self $to): void    {        $to->setStep($from->getStep());    }    /**     * Cast the current instance into the given class.     *     * @param string $className The $className::instance() method will be called to cast the current object.     *     * @return DateInterval     */    public function cast(string $className)    {        return self::castIntervalToClass($this, $className);    }    /**     * Create a CarbonInterval instance from a DateInterval one.  Can not instance     * DateInterval objects created from DateTime::diff() as you can't externally     * set the $days field.     *     * @param DateInterval $interval     *     * @return static     */    public static function instance(DateInterval $interval)    {        return self::castIntervalToClass($interval, static::class);    }    /**     * Make a CarbonInterval instance from given variable if possible.     *     * Always return a new instance. Parse only strings and only these likely to be intervals (skip dates     * and recurrences). Throw an exception for invalid format, but otherwise return null.     *     * @param mixed|int|DateInterval|string|Closure|null $interval interval or number of the given $unit     * @param string|null                                $unit     if specified, $interval must be an integer     *     * @return static|null     */    public static function make($interval, $unit = null)    {        if ($unit) {            $interval = ""$interval "".Carbon::pluralUnit($unit);        }        if ($interval instanceof DateInterval) {            return static::instance($interval);        }        if ($interval instanceof Closure) {            return new static($interval);        }        if (!\is_string($interval)) {            return null;        }        return static::makeFromString($interval);    }    protected static function makeFromString(string $interval)    {        $interval = preg_replace('/\s+/', ' ', trim($interval));        if (preg_match('/^P[T0-9]/', $interval)) {            return new static($interval);        }        if (preg_match('/^(?:\h*\d+(?:\.\d+)?\h*[a-z]+)+$/i', $interval)) {            return static::fromString($interval);        }        /** @var static $interval */        $interval = static::createFromDateString($interval);        return !$interval || $interval->isEmpty() ? null : $interval;    }    protected function resolveInterval($interval)    {        if (!($interval instanceof self)) {            return self::make($interval);        }        return $interval;    }    /**     * Sets up a DateInterval from the relative parts of the string.     *     * @param string $time     *     * @return static     *     * @link https://php.net/manual/en/dateinterval.createfromdatestring.php     */    #[ReturnTypeWillChange]    public static function createFromDateString($time)    {        $interval = @parent::createFromDateString(strtr($time, [            ',' => ' ',            ' and ' => ' ',        ]));        if ($interval instanceof DateInterval) {            $interval = static::instance($interval);        }        return $interval;    }    ///////////////////////////////////////////////////////////////////    ///////////////////////// GETTERS AND SETTERS /////////////////////    ///////////////////////////////////////////////////////////////////    /**     * Get a part of the CarbonInterval object.     *     * @param string $name     *     * @throws UnknownGetterException     *     * @return int|float|string     */    public function get($name)    {        if (substr($name, 0, 5) === 'total') {            return $this->total(substr($name, 5));        }        switch ($name) {            case 'years':                return $this->y;            case 'months':                return $this->m;            case 'dayz':                return $this->d;            case 'hours':                return $this->h;            case 'minutes':                return $this->i;            case 'seconds':                return $this->s;            case 'milli':            case 'milliseconds':                return (int) (round($this->f * Carbon::MICROSECONDS_PER_SECOND) / Carbon::MICROSECONDS_PER_MILLISECOND);            case 'micro':            case 'microseconds':                return (int) round($this->f * Carbon::MICROSECONDS_PER_SECOND);            case 'microExcludeMilli':                return (int) round($this->f * Carbon::MICROSECONDS_PER_SECOND) % Carbon::MICROSECONDS_PER_MILLISECOND;            case 'weeks':                return (int) ($this->d / static::getDaysPerWeek());            case 'daysExcludeWeeks':            case 'dayzExcludeWeeks':                return $this->d % static::getDaysPerWeek();            case 'locale':                return $this->getTranslatorLocale();            default:                throw new UnknownGetterException($name);        }    }    /**     * Get a part of the CarbonInterval object.     *     * @param string $name     *     * @throws UnknownGetterException     *     * @return int|float|string     */    public function __get($name)    {        return $this->get($name);    }    /**     * Set a part of the CarbonInterval object.     *     * @param string|array $name     * @param int          $value     *     * @throws UnknownSetterException     *     * @return $this     */    public function set($name, $value = null)    {        $properties = \is_array($name) ? $name : [$name => $value];        foreach ($properties as $key => $value) {            switch (Carbon::singularUnit(rtrim($key, 'z'))) {                case 'year':                    $this->y = $value;                    break;                case 'month':                    $this->m = $value;                    break;                case 'week':                    $this->d = $value * static::getDaysPerWeek();                    break;                case 'day':                    $this->d = $value;                    break;                case 'daysexcludeweek':                case 'dayzexcludeweek':                    $this->d = $this->weeks * static::getDaysPerWeek() + $value;                    break;                case 'hour':                    $this->h = $value;                    break;                case 'minute':                    $this->i = $value;                    break;                case 'second':                    $this->s = $value;                    break;                case 'milli':                case 'millisecond':                    $this->microseconds = $value * Carbon::MICROSECONDS_PER_MILLISECOND + $this->microseconds % Carbon::MICROSECONDS_PER_MILLISECOND;                    break;                case 'micro':                case 'microsecond':                    $this->f = $value / Carbon::MICROSECONDS_PER_SECOND;                    break;                default:                    if ($this->localStrictModeEnabled ?? Carbon::isStrictModeEnabled()) {                        throw new UnknownSetterException($key);                    }                    $this->$key = $value;            }        }        return $this;    }    /**     * Set a part of the CarbonInterval object.     *     * @param string $name     * @param int    $value     *     * @throws UnknownSetterException     */    public function __set($name, $value)    {        $this->set($name, $value);    }    /**     * Allow setting of weeks and days to be cumulative.     *     * @param int $weeks Number of weeks to set     * @param int $days  Number of days to set     *     * @return static     */    public function weeksAndDays($weeks, $days)    {        $this->dayz = ($weeks * static::getDaysPerWeek()) + $days;        return $this;    }    /**     * Returns true if the interval is empty for each unit.     *     * @return bool     */    public function isEmpty()    {        return $this->years === 0 &&            $this->months === 0 &&            $this->dayz === 0 &&            !$this->days &&            $this->hours === 0 &&            $this->minutes === 0 &&            $this->seconds === 0 &&            $this->microseconds === 0;    }    /**     * Register a custom macro.     *     * @example     * ```     * CarbonInterval::macro('twice', function () {     *   return $this->times(2);     * });     * echo CarbonInterval::hours(2)->twice();     * ```     *     * @param string          $name     * @param object|callable $macro     *     * @return void     */    public static function macro($name, $macro)    {        static::$macros[$name] = $macro;    }    /**     * Register macros from a mixin object.     *     * @example     * ```     * CarbonInterval::mixin(new class {     *   public function daysToHours() {     *     return function () {     *       $this->hours += $this->days;     *       $this->days = 0;     *     *       return $this;     *     };     *   }     *   public function hoursToDays() {     *     return function () {     *       $this->days += $this->hours;     *       $this->hours = 0;     *     *       return $this;     *     };     *   }     * });     * echo CarbonInterval::hours(5)->hoursToDays() . ""\n"";     * echo CarbonInterval::days(5)->daysToHours() . ""\n"";     * ```     *     * @param object|string $mixin     *     * @throws ReflectionException     *     * @return void     */    public static function mixin($mixin)    {        static::baseMixin($mixin);    }    /**     * Check if macro is registered.     *     * @param string $name     *     * @return bool     */    public static function hasMacro($name)    {        return isset(static::$macros[$name]);    }    /**     * Call given macro.     *     * @param string $name     * @param array  $parameters     *     * @return mixed     */    protected function callMacro($name, $parameters)    {        $macro = static::$macros[$name];        if ($macro instanceof Closure) {            $boundMacro = @$macro->bindTo($this, static::class) ?: @$macro->bindTo(null, static::class);            return ($boundMacro ?: $macro)(...$parameters);        }        return $macro(...$parameters);    }    /**     * Allow fluent calls on the setters... CarbonInterval::years(3)->months(5)->day().     *     * Note: This is done using the magic method to allow static and instance methods to     *       have the same names.     *     * @param string $method     magic method name called     * @param array  $parameters parameters list     *     * @throws BadFluentSetterException|Throwable     *     * @return static     */    public function __call($method, $parameters)    {        if (static::hasMacro($method)) {            return static::bindMacroContext($this, function () use (&$method, &$parameters) {                return $this->callMacro($method, $parameters);            });        }        $roundedValue = $this->callRoundMethod($method, $parameters);        if ($roundedValue !== null) {            return $roundedValue;        }        if (preg_match('/^(?<method>add|sub)(?<unit>[A-Z].*)$/', $method, $match)) {            return $this->{$match['method']}($parameters[0], $match['unit']);        }        try {            $this->set($method, \count($parameters) === 0 ? 1 : $parameters[0]);        } catch (UnknownSetterException $exception) {            if ($this->localStrictModeEnabled ?? Carbon::isStrictModeEnabled()) {                throw new BadFluentSetterException($method, 0, $exception);            }        }        return $this;    }    protected function getForHumansInitialVariables($syntax, $short)    {        if (\is_array($syntax)) {            return $syntax;        }        if (\is_int($short)) {            return [                'parts' => $short,                'short' => false,            ];        }        if (\is_bool($syntax)) {            return [                'short' => $syntax,                'syntax' => CarbonInterface::DIFF_ABSOLUTE,            ];        }        return [];    }    /**     * @param mixed $syntax     * @param mixed $short     * @param mixed $parts     * @param mixed $options     *     * @return array     */    protected function getForHumansParameters($syntax = null, $short = false, $parts = -1, $options = null)    {        $optionalSpace = ' ';        $default = $this->getTranslationMessage('list.0') ?? $this->getTranslationMessage('list') ?? ' ';        $join = $default === '' ? '' : ' ';        $altNumbers = false;        $aUnit = false;        $minimumUnit = 's';        extract($this->getForHumansInitialVariables($syntax, $short));        if (\is_null($syntax)) {            $syntax = CarbonInterface::DIFF_ABSOLUTE;        }        if ($parts === -1) {            $parts = INF;        }        if (\is_null($options)) {            $options = static::getHumanDiffOptions();        }        if ($join === false) {            $join = ' ';        } elseif ($join === true) {            $join = [                $default,                $this->getTranslationMessage('list.1') ?? $default,            ];        }        if ($altNumbers) {            if ($altNumbers !== true) {                $language = new Language($this->locale);                $altNumbers = \in_array($language->getCode(), (array) $altNumbers);            }        }        if (\is_array($join)) {            [$default, $last] = $join;            if ($default !== ' ') {                $optionalSpace = '';            }            $join = function ($list) use ($default, $last) {                if (\co",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
416,briannesbitt_Carbon_CarbonInterval_211, Mapping of units and factors for cascading.\\n\\n Should only be modified by changing the factors or referenced constants.\\n\\n @return array\\n,Mapiranje jedinica i faktora za kaskadno. Treba se promeniti samo tako što će se promeniti faktori ili konstantne na koje se referencira. ,"    public static function getCascadeFactors()    {        return static::$cascadeFactors ?: [            'milliseconds' => [Carbon::MICROSECONDS_PER_MILLISECOND, 'microseconds'],            'seconds' => [Carbon::MILLISECONDS_PER_SECOND, 'milliseconds'],            'minutes' => [Carbon::SECONDS_PER_MINUTE, 'seconds'],            'hours' => [Carbon::MINUTES_PER_HOUR, 'minutes'],            'dayz' => [Carbon::HOURS_PER_DAY, 'hours'],            'weeks' => [Carbon::DAYS_PER_WEEK, 'dayz'],            'months' => [Carbon::WEEKS_PER_MONTH, 'weeks'],            'years' => [Carbon::MONTHS_PER_YEAR, 'months'],        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
417,briannesbitt_Carbon_CarbonInterval_212, Set default cascading factors for ->cascade() method.\\\\n\\\\n @param array $cascadeFactors\\\\n, Postavlja podrazumevane kaskadne faktore za metodu ->cascade().,    public static function setCascadeFactors(array $cascadeFactors)    {        self::$flipCascadeFactors = null;        static::$cascadeFactors = $cascadeFactors;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
418,briannesbitt_Carbon_CarbonInterval_213, Returns the factor for a given source-to-target couple.\\\\n\\\\n @param string $source\\\\n @param string $target\\\\n\\\\n @return int|null\\\\n,Vrac?a faktor za zadati par izvor-cilj.,"    public static function getFactor($source, $target)    {        $source = self::standardizeUnit($source);        $target = self::standardizeUnit($target);        $factors = static::getFlipCascadeFactors();        if (isset($factors[$source])) {            [$to, $factor] = $factors[$source];            if ($to === $target) {                return $factor;            }            return $factor * static::getFactor($to, $target);        }        return null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
419,briannesbitt_Carbon_CarbonInterval_215, Returns current config for hours per day.\n\n @return int\n,Prikazuje trenutnu konfiguraciju za sate po danu.,"    public static function getHoursPerDay()    {        return static::getFactor('hours', 'dayz') ?: Carbon::HOURS_PER_DAY;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
420,briannesbitt_Carbon_CarbonInterval_216, Returns current config for minutes per hour.\\\\n\\\\n @return int\\\\n,Prikazuje trenutnu konfiguraciju za minute na sat.,"    public static function getMinutesPerHour()    {        return static::getFactor('minutes', 'hours') ?: Carbon::MINUTES_PER_HOUR;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
421,briannesbitt_Carbon_CarbonInterval_217, Returns current config for seconds per minute.\\\\n\\\\n @return int\\\\n,Prikazuje trenutnu konfiguraciju za sekunde u minuti.,"    public static function getSecondsPerMinute()    {        return static::getFactor('seconds', 'minutes') ?: Carbon::SECONDS_PER_MINUTE;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
422,briannesbitt_Carbon_CarbonInterval_218, Returns current config for microseconds per second.\\n\\n @return int\\n,Prikazuje trenutnu konfiguraciju za mikrosekunde u sekundi.,"    public static function getMillisecondsPerSecond()    {        return static::getFactor('milliseconds', 'seconds') ?: Carbon::MILLISECONDS_PER_SECOND;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
423,briannesbitt_Carbon_CarbonInterval_219, Returns current config for microseconds per second.\\\\n\\\\n @return int\\\\n,Prikazuje trenutnu konfiguraciju za mikrosekunde u sekundi.,"    public static function getMicrosecondsPerMillisecond()    {        return static::getFactor('microseconds', 'milliseconds') ?: Carbon::MICROSECONDS_PER_MILLISECOND;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
424,briannesbitt_Carbon_CarbonInterval_220," Parse a string into a new CarbonInterval object according to the specified format.\\\\n\\\\n @example\\\\n ```\\\\n echo Carboninterval::createFromFormat('H:i', '1:30');\\\\n ```\\\\n\\\\n @param string $format   Format of the $interval input string\\\\n @param string $interval Input string to convert into an interval\\\\n\\\\n @throws Exception when the $interval cannot be parsed as an interval.\\\\n\\\\n @return static\\\\n", Parsira string u novi CarbonInterval objekat u slakdu sa navedenim formatom. ,"    public static function createFromFormat(string $format, ?string $interval)    {        $instance = new static(0);        $length = mb_strlen($format);        if (preg_match('/s([,.])([uv])$/', $format, $match)) {            $interval = explode($match[1], $interval);            $index = \count($interval) - 1;            $interval[$index] = str_pad($interval[$index], $match[2] === 'v' ? 3 : 6, '0');            $interval = implode($match[1], $interval);        }        $interval = $interval ?? '';        for ($index = 0; $index < $length; $index++) {            $expected = mb_substr($format, $index, 1);            $nextCharacter = mb_substr($interval, 0, 1);            $unit = static::$formats[$expected] ?? null;            if ($unit) {                if (!preg_match('/^-?\d+/', $interval, $match)) {                    throw new ParseErrorException('number', $nextCharacter);                }                $interval = mb_substr($interval, mb_strlen($match[0]));                $instance->$unit += \intval($match[0]);                continue;            }            if ($nextCharacter !== $expected) {                throw new ParseErrorException(                    ""'$expected'"",                    $nextCharacter,                    'Allowed substitutes for interval formats are '.implode(', ', array_keys(static::$formats)).""\n"".                    'See https://php.net/manual/en/function.date.php for their meaning'                );            }            $interval = mb_substr($interval, 1);        }        if ($interval !== '') {            throw new ParseErrorException(                'end of string',                $interval            );        }        return $instance;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
425,briannesbitt_Carbon_CarbonInterval_221, Get a copy of the instance.\n\n @return static\n, Vra?a kopiju instance. ,    public function copy()    {        $date = new static(0);        $date->copyProperties($this);        $date->step = $this->step;        return $date;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
426,briannesbitt_Carbon_CarbonInterval_225," Creates a CarbonInterval from string.\n\n Format:\n\n Suffix | Unit    | Example | DateInterval expression\n -------|---------|---------|------------------------\n y      | years   |   1y    | P1Y\n mo     | months  |   3mo   | P3M\n w      | weeks   |   2w    | P2W\n d      | days    |  28d    | P28D\n h      | hours   |   4h    | PT4H\n m      | minutes |  12m    | PT12M\n s      | seconds |  59s    | PT59S\n\n e. g. `1w 3d 4h 32m 23s` is converted to 10 days 4 hours 32 minutes and 23 seconds.\n\n Special cases:\n  - An empty string will return a zero interval\n  - Fractions are allowed for weeks, days, hours and minutes and will be converted\n    and rounded to the next smaller value (caution: 0.5w = 4d)\n\n @param string $intervalDefinition\n\n @return static\n"," Kriera CarbonInterval iz string-a. \n\n Format:\n\n Sufiks | Jedinica    | Primer | DateInterval izraz\n -------|---------|---------|------------------------\n y      | godine   |   1y    | P1Y\n mo     | meseci  |   3mo   | P3M\n w      | sedmice   |   2w    | P2W\n d      | dani    |  28d    | P28D\n h      | sati   |   4h    | PT4H\n m      | minute |  12m    | PT12M\n s      | sekunde |  59s    | PT59S\n\n npr. `1w 3d 4h 32m 23s`  se konvertuje u 10 days 4 hours 32 minutes and 23 seconds.\n\n Specijalni slučajevi:\n  - Prazan string će uvek da vrati nulti interval\n  - Razlomci su dozvoljeni za sedmic, dane, sate i minute i biće konvertovani\n i zaokruženi na sledeću manju vrednost (oprez: 0.5w = 4d)","    public static function fromString($intervalDefinition)    {        if (empty($intervalDefinition)) {            return new static(0);        }        $years = 0;        $months = 0;        $weeks = 0;        $days = 0;        $hours = 0;        $minutes = 0;        $seconds = 0;        $milliseconds = 0;        $microseconds = 0;        $pattern = '/(\d+(?:\.\d+)?)\h*([^\d\h]*)/i';        preg_match_all($pattern, $intervalDefinition, $parts, PREG_SET_ORDER);        while ([$part, $value, $unit] = array_shift($parts)) {            $intValue = \intval($value);            $fraction = \floatval($value) - $intValue;            // Fix calculation precision            switch (round($fraction, 6)) {                case 1:                    $fraction = 0;                    $intValue++;                    break;                case 0:                    $fraction = 0;                    break;            }            switch ($unit === 'Âµs' ? 'Âµs' : strtolower($unit)) {                case 'millennia':                case 'millennium':                    $years += $intValue * CarbonInterface::YEARS_PER_MILLENNIUM;                    break;                case 'century':                case 'centuries':                    $years += $intValue * CarbonInterface::YEARS_PER_CENTURY;                    break;                case 'decade':                case 'decades':                    $years += $intValue * CarbonInterface::YEARS_PER_DECADE;                    break;                case 'year':                case 'years':                case 'y':                    $years += $intValue;                    break;                case 'quarter':                case 'quarters':                    $months += $intValue * CarbonInterface::MONTHS_PER_QUARTER;                    break;                case 'month':                case 'months':                case 'mo':                    $months += $intValue;                    break;                case 'week':                case 'weeks':                case 'w':                    $weeks += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getDaysPerWeek(), 'd'];                    }                    break;                case 'day':                case 'days':                case 'd':                    $days += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getHoursPerDay(), 'h'];                    }                    break;                case 'hour':                case 'hours':                case 'h':                    $hours += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getMinutesPerHour(), 'm'];                    }                    break;                case 'minute':                case 'minutes':                case 'm':                    $minutes += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getSecondsPerMinute(), 's'];                    }                    break;                case 'second':                case 'seconds':                case 's':                    $seconds += $intValue;                    if ($fraction) {                        $parts[] = [null, $fraction * static::getMillisecondsPerSecond(), 'ms'];                    }                    break;                case 'millisecond':                case 'milliseconds':                case 'milli':                case 'ms':                    $milliseconds += $intValue;                    if ($fraction) {                        $microseconds += round($fraction * static::getMicrosecondsPerMillisecond());                    }                    break;                case 'microsecond':                case 'microseconds':                case 'micro':                case 'Âµs':                    $microseconds += $intValue;                    break;                default:                    throw new InvalidIntervalException(                        sprintf('Invalid part %s in definition %s', $part, $intervalDefinition)                    );            }        }        return new static($years, $months, $weeks, $days, $hours, $minutes, $seconds, $milliseconds * Carbon::MICROSECONDS_PER_MILLISECOND + $microseconds);    }",0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
427,briannesbitt_Carbon_CarbonInterval_226, Cast the current instance into the given class.\n\n @param string $className The $className::instance() method will be called to cast the current object.\n\n @return DateInterval\n, Kastovanje trenutne instance u datu klasu.,"    public function cast(string $className)    {        return self::castIntervalToClass($this, $className);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
428,briannesbitt_Carbon_CarbonInterval_229, Get a part of the CarbonInterval object.\\\\n\\\\n @param string $name\\\\n\\\\n @throws UnknownGetterException\\\\n\\\\n @return int|float|string\\\\n, Vraća dio CarbonInterval objekta.,"    public function get($name)    {        if (substr($name, 0, 5) === 'total') {            return $this->total(substr($name, 5));        }        switch ($name) {            case 'years':                return $this->y;            case 'months':                return $this->m;            case 'dayz':                return $this->d;            case 'hours':                return $this->h;            case 'minutes':                return $this->i;            case 'seconds':                return $this->s;            case 'milli':            case 'milliseconds':                return (int) (round($this->f * Carbon::MICROSECONDS_PER_SECOND) / Carbon::MICROSECONDS_PER_MILLISECOND);            case 'micro':            case 'microseconds':                return (int) round($this->f * Carbon::MICROSECONDS_PER_SECOND);            case 'microExcludeMilli':                return (int) round($this->f * Carbon::MICROSECONDS_PER_SECOND) % Carbon::MICROSECONDS_PER_MILLISECOND;            case 'weeks':                return (int) ($this->d / static::getDaysPerWeek());            case 'daysExcludeWeeks':            case 'dayzExcludeWeeks':                return $this->d % static::getDaysPerWeek();            case 'locale':                return $this->getTranslatorLocale();            default:                throw new UnknownGetterException($name);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
429,briannesbitt_Carbon_CarbonInterval_232, Allow setting of weeks and days to be cumulative.\\n\\n @param int $weeks Number of weeks to set\\n @param int $days  Number of days to set\\n\\n @return static\\n, Omogući da se podesi da sedmice i dani budu kumulativni. ,"    public function weeksAndDays($weeks, $days)    {        $this->dayz = ($weeks * static::getDaysPerWeek()) + $days;        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
430,briannesbitt_Carbon_CarbonInterval_233, Returns true if the interval is empty for each unit.\\n\\n @return bool\\n,Vraća tačno ako je interval prazan za svaku jedinicu mere.,    public function isEmpty()    {        return $this->years === 0 &&            $this->months === 0 &&            $this->dayz === 0 &&            !$this->days &&            $this->hours === 0 &&            $this->minutes === 0 &&            $this->seconds === 0 &&            $this->microseconds === 0;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
431,briannesbitt_Carbon_CarbonInterval_236, Check if macro is registered.\\n\\n @param string $name\\n\\n @return bool\\n,Proverava da li je makro registrovan. ,    public static function hasMacro($name)    {        return isset(static::$macros[$name]);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
432,briannesbitt_Carbon_CarbonInterval_240, Returns interval non-zero values as an array where key are the unit names and values the counts.\\n\\n @return int[]\\n, Vraća interval nenultih vrednosti kao niz u kojem je ključ imena jedinica mere i vrednosti koje se broje.,"    public function getNonZeroValues()    {        return array_filter($this->toArray(), 'intval');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
433,briannesbitt_Carbon_CarbonInterval_242, Format the instance as a string using the forHumans() function.\n\n @throws Exception\n\n @return string\n, Formatira instancu kao string koristeći forHumans() funkciju.,    public function __toString()    {        $format = $this->localToStringFormat;        if ($format) {            if ($format instanceof Closure) {                return $format($this);            }            return $this->format($format);        }        return $this->forHumans();    },0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
434,briannesbitt_Carbon_CarbonInterval_247," Multiply current instance given number of times. times() is naive, it multiplies each unit\\\\n (so day can be greater than 31, hour can be greater than 23, etc.) and the result is rounded\\\\n separately for each unit.\\\\n\\\\n Use times() when you want a fast and approximated calculation that does not cascade units.\\\\n\\\\n For a precise and cascaded calculation,\\\\n\\\\n @see multiply()\\\\n\\\\n @param float|int $factor\\\\n\\\\n @return $this\\\\n"," Množi trenutnu instancu dati broj puta. times() je nativni, množi svaku od jedinica mere (tako da dan može biti veći od 31, sati mogu biti veći od 23, itd.) i rezultat se z<okružuje zasebno za svaku jedinicu mere. Koristiti times() ako želite brz i približan izračun koji ne pravi kaskade od jedinica mere.Za precizan izračun sa kaskadama vidjeti multiply()",    public function times($factor)    {        if ($factor < 0) {            $this->invert = $this->invert ? 0 : 1;            $factor = -$factor;        }        $this->years = (int) round($this->years * $factor);        $this->months = (int) round($this->months * $factor);        $this->dayz = (int) round($this->dayz * $factor);        $this->hours = (int) round($this->hours * $factor);        $this->minutes = (int) round($this->minutes * $factor);        $this->seconds = (int) round($this->seconds * $factor);        $this->microseconds = (int) round($this->microseconds * $factor);        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
435,briannesbitt_Carbon_CarbonInterval_247," Multiply current instance given number of times. times() is naive, it multiplies each unit\\\\n (so day can be greater than 31, hour can be greater than 23, etc.) and the result is rounded\\\\n separately for each unit.\\\\n\\\\n Use times() when you want a fast and approximated calculation that does not cascade units.\\\\n\\\\n For a precise and cascaded calculation,\\\\n\\\\n @see multiply()\\\\n\\\\n @param float|int $factor\\\\n\\\\n @return $this\\\\n"," Množi trenutnu instancu dati broj puta. times() je nativni, množi svaku od jedinica mere (tako da dan može biti veći od 31, sati mogu biti veći od 23, itd.) i rezultat se z<okružuje zasebno za svaku jedinicu mere. Koristiti times() ako želite brz i približan izračun koji ne pravi kaskade od jedinica mere.Za precizan izračun sa kaskadama vidjeti multiply()",    public function times($factor)    {        if ($factor < 0) {            $this->invert = $this->invert ? 0 : 1;            $factor = -$factor;        }        $this->years = (int) round($this->years * $factor);        $this->months = (int) round($this->months * $factor);        $this->dayz = (int) round($this->dayz * $factor);        $this->hours = (int) round($this->hours * $factor);        $this->minutes = (int) round($this->minutes * $factor);        $this->seconds = (int) round($this->seconds * $factor);        $this->microseconds = (int) round($this->microseconds * $factor);        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
436,briannesbitt_Carbon_CarbonInterval_251, Get the interval_spec string of a date interval.\\n\\n @param DateInterval $interval\\n\\n @return string\\n, Vraća interval_spec string datog intervala datuma.,"    public static function getDateIntervalSpec(DateInterval $interval)    {        $date = array_filter([            static::PERIOD_YEARS => abs($interval->y),            static::PERIOD_MONTHS => abs($interval->m),            static::PERIOD_DAYS => abs($interval->d),        ]);        $time = array_filter([            static::PERIOD_HOURS => abs($interval->h),            static::PERIOD_MINUTES => abs($interval->i),            static::PERIOD_SECONDS => abs($interval->s),        ]);        $specString = static::PERIOD_PREFIX;        foreach ($date as $key => $value) {            $specString .= $value.$key;        }        if (\count($time) > 0) {            $specString .= static::PERIOD_TIME_PREFIX;            foreach ($time as $key => $value) {                $specString .= $value.$key;            }        }        return $specString === static::PERIOD_PREFIX ? 'PT0S' : $specString;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
437,briannesbitt_Carbon_CarbonInterval_253, Comparing 2 date intervals.\\n\\n @param DateInterval $first\\n @param DateInterval $second\\n\\n @return int\\n,Poredi 2 intervala datuma.,"    public static function compareDateIntervals(DateInterval $first, DateInterval $second)    {        $current = Carbon::now();        $passed = $current->avoidMutation()->add($second);        $current->add($first);        if ($current < $passed) {            return -1;        }        if ($current > $passed) {            return 1;        }        return 0;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
438,briannesbitt_Carbon_CarbonInterval_259, Determines if the instance is not equal to another\\n\\n @param CarbonInterval|DateInterval|mixed $interval\\n\\n @see notEqualTo()\\n\\n @return bool\\n,Određuje da li je instanca nejednaka nekoj drugoj,    public function ne($interval): bool    {        return $this->notEqualTo($interval);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
439,briannesbitt_Carbon_CarbonInterval_261, Determines if the instance is greater (longer) than another\\\\n\\\\n @param CarbonInterval|DateInterval|mixed $interval\\\\n\\\\n @see greaterThan()\\\\n\\\\n @return bool\\\\n, Određuje da li je instanca veća (duža) od druge,    public function gt($interval): bool    {        return $this->greaterThan($interval);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
440,briannesbitt_Carbon_CarbonInterval_263, Determines if the instance is greater (longer) than or equal to another\\\\n\\\\n @param CarbonInterval|DateInterval|mixed $interval\\\\n\\\\n @see greaterThanOrEqualTo()\\\\n\\\\n @return bool\\\\n, Određuje da li je instanca veća (duža) ili jednaka drugoj,    public function gte($interval): bool    {        return $this->greaterThanOrEqualTo($interval);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
441,briannesbitt_Carbon_CarbonInterval_264, Determines if the instance is greater (longer) than or equal to another\n\n @param CarbonInterval|DateInterval|mixed $interval\n\n @return bool\n, Određuje da li je instanca veća (duža) ili jednaka drugoj,    public function greaterThanOrEqualTo($interval): bool    {        return $this->greaterThan($interval) || $this->equalTo($interval);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
442,briannesbitt_Carbon_CarbonInterval_265, Determines if the instance is less (shorter) than another\\\\n\\\\n @param CarbonInterval|DateInterval|mixed $interval\\\\n\\\\n @see lessThan()\\\\n\\\\n @return bool\\\\n, Određuje da li je instanca manja (kraća) od druge,    public function lt($interval): bool    {        return $this->lessThan($interval);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
443,briannesbitt_Carbon_CarbonInterval_269," Determines if the instance is between two others, bounds excluded.\\n\\n @example\\n ```\\n CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::days(3)); // true\\n CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::hours(36)); // false\\n CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::days(2)); // true\\n ```\\n\\n @param CarbonInterval|DateInterval|mixed $interval1\\n @param CarbonInterval|DateInterval|mixed $interval2\\n\\n @return bool\\n","Odlučuje da li je instnaca između dvije instnace, ne uključujući granice","    public function betweenIncluded($interval1, $interval2): bool    {        return $this->between($interval1, $interval2, true);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
444,briannesbitt_Carbon_CarbonInterval_270," Determines if the instance is between two others, bounds excluded.\\\\n\\\\n @example\\\\n ```\\\\n CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::days(3)); // true\\\\n CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::hours(36)); // false\\\\n CarbonInterval::hours(48)->betweenExcluded(CarbonInterval::day(), CarbonInterval::days(2)); // false\\\\n ```\\\\n\\\\n @param CarbonInterval|DateInterval|mixed $interval1\\\\n @param CarbonInterval|DateInterval|mixed $interval2\\\\n\\\\n @return bool\\\\n","Odlučuje da li je instnaca između dvije instnace, ne uključujući granice","    public function betweenExcluded($interval1, $interval2): bool    {        return $this->between($interval1, $interval2, false);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
445,briannesbitt_Carbon_CarbonPeriod_273, Create a new instance from a DatePeriod or CarbonPeriod object.\\n\\n @param CarbonPeriod|DatePeriod $period\\n\\n @return static\\n, Kreira novu instnacu iz DatePeriod ili CarbonPeriod objekta.,"    public static function instance($period)    {        if ($period instanceof static) {            return $period->copy();        }        if ($period instanceof self) {            return new static(                $period->getStartDate(),                $period->getEndDate() ?: $period->getRecurrences(),                $period->getDateInterval(),                $period->getOptions()            );        }        if ($period instanceof DatePeriod) {            return new static(                $period->start,                $period->end ?: ($period->recurrences - 1),                $period->interval,                $period->include_start_date ? 0 : static::EXCLUDE_START_DATE            );        }        $class = \get_called_class();        $type = \gettype($period);        throw new NotAPeriodException(            'Argument 1 passed to '.$class.'::'.__METHOD__.'() '.            'must be an instance of DatePeriod or '.$class.', '.            ($type === 'object' ? 'instance of '.\get_class($period) : $type).' given.'        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
446,briannesbitt_Carbon_CarbonPeriod_276, Return whether given interval contains non zero value of any time unit.\\n\\n @param \\\\DateInterval $interval\\n\\n @return bool\\n,Vraća da li dati interval sadrži nenulte vrednosti bilo koje jedinice mere.,    protected static function intervalHasTime(DateInterval $interval)    {        return $interval->h || $interval->i || $interval->s || $interval->f;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
447,briannesbitt_Carbon_CarbonPeriod_277," Return whether given variable is an ISO 8601 specification.\\n\\n Note: Check is very basic, as actual validation will be done later when parsing.\\n We just want to ensure that variable is not any other type of a valid parameter.\\n\\n @param mixed $var\\n\\n @return bool\\n","Vraća da li je trenutna varijabla ISO 8601 specifikacija. Napomena: Provera je vrlo bazična, jer prava validacija će biti urađena kasnije tokom parsiranja. Samo želimo da se osiguramo da varijabla nije nijednog grugog tipa osim validnog parametra. ","    protected static function isIso8601($var)    {        if (!\is_string($var)) {            return false;        }        // Match slash but not within a timezone name.        $part = '[a-z]+(?:[_-][a-z]+)*';        preg_match(""#\b$part/$part\b|(/)#i"", $var, $match);        return isset($match[1]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
448,briannesbitt_Carbon_CarbonPeriod_279, Add missing parts of the target date from the soure date.\\n\\n @param string $source\\n @param string $target\\n\\n @return string\\n, Dodaje nedostajuće delove ciljnog datuma iz izvornog datuma.,"    protected static function addMissingParts($source, $target)    {        $pattern = '/'.preg_replace('/[0-9]+/', '[0-9]+', preg_quote($target, '/')).'$/';        $result = preg_replace($pattern, $target, $source, 1, $count);        return $count ? $result : $target;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
449,briannesbitt_Carbon_CarbonPeriod_280," Register a custom macro.\\n\\n @example\\n ```\\n CarbonPeriod::macro('middle', function () {\\n   return $this->getStartDate()->average($this->getEndDate());\\n });\\n echo CarbonPeriod::since('2011-05-12')->until('2011-06-03')->middle();\\n ```\\n\\n @param string          $name\\n @param object|callable $macro\\n\\n @return void\\n",Registruje prilagođeni makro.,"    public static function macro($name, $macro)    {        static::$macros[$name] = $macro;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
450,briannesbitt_Carbon_CarbonInterval_224, Return the current context from inside a macro callee or a new one if static.\n\n @return static\n,Vra?a trenutni kontekst iz poziva makronaredbe ili novi ako je stati?an. ,    protected static function this()    {        return end(static::$macroContextStack) ?: new static(0);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
451,briannesbitt_Carbon_CarbonPeriod_289, Check if an attribute exists on the object\\\\n\\\\n @param string $name\\\\n\\\\n @return bool\\\\n, Proveri da li atribut postoji u objektu.,    public function __isset(string $name): bool    {        return $this->getGetter($name) !== null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
452,briannesbitt_Carbon_CarbonPeriod_317, Format the date period as ISO 8601.\\\\n\\\\n @return string\\\\n,Formatira datum kao u skladu sa ISO 8601. ,"    public function toIso8601String()    {        $parts = [];        if ($this->recurrences !== null) {            $parts[] = 'R'.$this->recurrences;        }        $parts[] = $this->startDate->toIso8601String();        $parts[] = $this->dateInterval->spec();        if ($this->endDate !== null) {            $parts[] = $this->endDate->toIso8601String();        }        return implode('/', $parts);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
453,briannesbitt_Carbon_CarbonPeriod_319, Format the date period as ISO 8601.\\n\\n @return string\\n,Formatira datum kao u skladu sa ISO 8601. ,    public function spec()    {        return $this->toIso8601String();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
454,briannesbitt_Carbon_CarbonPeriod_335," Determines if the instance is not equal to another.\\\\n Warning: if options differ, instances wil never be equal.\\\\n\\\\n @param mixed $period\\\\n\\\\n @see notEqualTo()\\\\n\\\\n @return bool\\\\n","Određuje da li je instanca jednaka ili ne drugoj. Upozorenje: ako se opcije razlikuju, instance nikada neće biti iste.",    public function ne($period): bool    {        return $this->notEqualTo($period);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
455,briannesbitt_Carbon_CarbonPeriod_323, Count dates in the date period.\n\n @return int\n,Broji datume u datumskom periodu.,    public function count()    {        return \count($this->toArray());    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
456,briannesbitt_Carbon_CarbonPeriod_324, Return the first date in the date period.\n\n @return CarbonInterface|null\n,Vraća prvi datum u datumskom periodu.,    public function first()    {        return ($this->toArray() ?: [])[0] ?? null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
457,briannesbitt_Carbon_CarbonPeriod_325, Return the last date in the date period.\\\\n\\\\n @return CarbonInterface|null\\\\n,Vraća zadnji datum u datumskom periodu.,    public function last()    {        $array = $this->toArray();        return $array ? $array[\count($array) - 1] : null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
458,briannesbitt_Carbon_CarbonPeriod_326, Convert the date period into a string.\n\n @return string\n,Konvertuje datumski period u string. ,    public function __toString()    {        return $this->toString();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
459,briannesbitt_Carbon_CarbonPeriod_350, Handle change of the parameters.\\n,Rukovanje promenom parametara. ,    protected function handleChangedParameters()    {        if (($this->getOptions() & static::IMMUTABLE) && $this->dateClass === Carbon::class) {            $this->setDateClass(CarbonImmutable::class);        } elseif (!($this->getOptions() & static::IMMUTABLE) && $this->dateClass === CarbonImmutable::class) {            $this->setDateClass(Carbon::class);        }        $this->validationResult = null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
460,briannesbitt_Carbon_Language_364, Get the list of the known languages.\\\\n\\\\n @return array\\\\n, Vraća listu svih poznatih jezika.,    public static function all()    {        if (!static::$languagesNames) {            static::$languagesNames = require __DIR__.'/List/languages.php';        }        return static::$languagesNames;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
461,briannesbitt_Carbon_Language_365, Get the list of the known regions.\\n\\n @return array\\n,Vraća listu svih poznatih regiona.,    public static function regions()    {        if (!static::$regionsNames) {            static::$regionsNames = require __DIR__.'/List/regions.php';        }        return static::$regionsNames;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
462,briannesbitt_Carbon_CarbonPeriod_318, Convert the date period into a string.\\\\n\\\\n @return string\\\\n,Konvertuje datum u string. ,"    public function toString()    {        $translator = ([$this->dateClass, 'getTranslator'])();        $parts = [];        $format = !$this->startDate->isStartOfDay() || $this->endDate && !$this->endDate->isStartOfDay()            ? 'Y-m-d H:i:s'            : 'Y-m-d';        if ($this->recurrences !== null) {            $parts[] = $this->translate('period_recurrences', [], $this->recurrences, $translator);        }        $parts[] = $this->translate('period_interval', [':interval' => $this->dateInterval->forHumans([            'join' => true,        ])], null, $translator);        $parts[] = $this->translate('period_start_date', [':date' => $this->startDate->rawFormat($format)], null, $translator);        if ($this->endDate !== null) {            $parts[] = $this->translate('period_end_date', [':date' => $this->endDate->rawFormat($format)], null, $translator);        }        $result = implode(' ', $parts);        return mb_strtoupper(mb_substr($result, 0, 1)).mb_substr($result, 1);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
463,cakephp_cakephp_BasicAuthenticate_1190, Generate the login headers\\n\\n @param \\\\Cake\\\\Http\\\\ServerRequest $request Request object.\\n @return string[] Headers for logging in.\\n,Generiše zagavlja za logovanje,"    public function loginHeaders(ServerRequest $request): array    {        $realm = $this->getConfig('realm') ?: $request->getEnv('SERVER_NAME');        return [            'WWW-Authenticate' => sprintf('Basic realm=""%s""', $realm),        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
464,cakephp_cakephp_ControllerAuthorize_1192, Checks user authorization using a controller callback.\n\n @param array|\\ArrayAccess $user Active user data\n @param \\Cake\\Http\\ServerRequest $request Request instance.\n @throws \\Cake\\Core\\Exception\\CakeException If controller does not have method `isAuthorized()`.\n @return bool\n, Proverava korisničku autorizaciju koristećni povratni poziv kontrolera.,"    public function authorize($user, ServerRequest $request): bool    {        if (!method_exists($this->_Controller, 'isAuthorized')) {            throw new CakeException(sprintf(                '%s does not implement an isAuthorized() method.',                get_class($this->_Controller)            ));        }        return (bool)$this->_Controller->isAuthorized($user);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
465,cakephp_cakephp_DefaultPasswordHasher_1194, Generates password hash.\\n\\n @param string $password Plain text password to hash.\\n @return string|false Password hash or false on failure\\n @psalm-suppress InvalidNullableReturnType\\n @link https://book.cakephp.org/4/en/controllers/components/authentication.html#hashing-passwords\\n,Generiše heš lozinke.,"    public function hash(string $password)    {        /** @psalm-suppress NullableReturnStatement */        return password_hash(            $password,            $this->_config['hashType'],            $this->_config['hashOptions']        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
466,cakephp_cakephp_DefaultPasswordHasher_1195, Check hash. Generate hash for user provided password and check against existing hash.\\\\n\\\\n @param string $password Plain text password to hash.\\\\n @param string $hashedPassword Existing hashed password.\\\\n @return bool True if hashes match else false.\\\\n,Provera heša. Generiše hešš za lozinku koju je dao korisnik i poredi sa postojećim hešom.,"    public function check(string $password, string $hashedPassword): bool    {        return password_verify($password, $hashedPassword);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
467,cakephp_cakephp_DefaultPasswordHasher_1196," Returns true if the password need to be rehashed, due to the password being\\\\n created with anything else than the passwords generated by this class.\\\\n\\\\n @param string $password The password to verify\\\\n @return bool\\\\n","Vraća tačno ako lozinka ponovo mora biti heširana, ukoliko je lozinka kreirana sa bilo čim osim lozinke koju je generisala ova klasa.","    public function needsRehash(string $password): bool    {        return password_needs_rehash($password, $this->_config['hashType'], $this->_config['hashOptions']);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
468,briannesbitt_Carbon_Language_373, Returns the long ISO language name.\\\\n\\\\n @return string\\\\n,Vraća dugo ISO ime jezika.,    public function getFullIsoName(): string    {        if (!$this->isoName) {            $this->isoName = $this->getNames()['isoName'];        }        return $this->isoName;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
469,briannesbitt_Carbon_Language_376, Set the name of the language in this language.\n\n @param string $nativeName\n,Podesi ime jezika u ovom jeziku.,    public function setNativeName(string $nativeName): self    {        $this->nativeName = $nativeName;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
470,briannesbitt_Carbon_Language_377, Returns the short ISO language name.\\n\\n @return string\\n,Vraća kratko ISO ime jezika.,"    public function getIsoName(): string    {        $name = $this->getFullIsoName();        return trim(strstr($name, ',', true) ?: $name);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
471,cakephp_cakephp_BaseAuthenticate_1177, Get query object for fetching user from database.\n\n @param string $username The username/identifier.\n @return \\Cake\\ORM\\Query\n,Vraća objekt upita za preuzimanje korisnika iz baze podataka.,"    protected function _query(string $username): Query    {        $config = $this->_config;        $table = $this->getTableLocator()->get($config['userModel']);        $options = [            'conditions' => [$table->aliasField($config['fields']['username']) => $username],        ];        $finder = $config['finder'];        if (is_array($finder)) {            $options += current($finder);            $finder = key($finder);        }        if (!isset($options['username'])) {            $options['username'] = $username;        }        return $table->find($finder, $options);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
472,cakephp_cakephp_BasicAuthenticate_1189, Handles an unauthenticated access attempt by sending appropriate login headers\\\\n\\\\n @param \\\\\\\\Cake\\\\\\\\Http\\\\\\\\ServerRequest $request A request object.\\\\n @param \\\\\\\\Cake\\\\\\\\Http\\\\\\\\Response $response A response object.\\\\n @return \\\\\\\\Cake\\\\\\\\Http\\\\\\\\Response|null|void\\\\n @throws \\\\\\\\Cake\\\\\\\\Http\\\\\\\\Exception\\\\\\\\UnauthorizedException\\\\n,Rukuje neautorizovanom pokušaju pristupa šaljući odgovarajuće zaglavlje za logovanje,"    public function unauthenticated(ServerRequest $request, Response $response)    {        $unauthorizedException = new UnauthorizedException();        $unauthorizedException->setHeaders($this->loginHeaders($request));        throw $unauthorizedException;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
473,briannesbitt_Carbon_CarbonPeriod_314, Return the current date.\n\n @return CarbonInterface|null\n,Vraća trenutni datum. ,    public function current()    {        return $this->valid()            ? $this->prepareForReturn($this->current)            : null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
474,briannesbitt_Carbon_CarbonPeriod_322, Convert the date period into an array without changing current iteration state.\\n\\n @return CarbonInterface[]\\n,Konvertuje datumski period u niz bez da menja trenutno stanje iteracije.,"    public function toArray()    {        $state = [            $this->key,            $this->current ? $this->current->avoidMutation() : null,            $this->validationResult,        ];        $result = iterator_to_array($this);        [$this->key, $this->current, $this->validationResult] = $state;        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
475,briannesbitt_Carbon_CarbonPeriod_331," Execute a given function on each date of the period.\n\n @example\n ```\n Carbon::create(\'2020-11-29\')->daysUntil(\'2020-12-24\')->forEach(function (Carbon $date) {\n   echo $date->diffInDays(\'2020-12-25\')."" days before Christmas!\\n"";\n });\n ```\n\n @param callable $callback\n",Izvršava funkciju na svakom datumu perioda.,    public function forEach(callable $callback)    {        foreach ($this as $date) {            $callback($date);        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
476,briannesbitt_Carbon_CarbonPeriod_338, Return true if end date is now or later.\n (Rather start/end are included by options is ignored.)\n\n @return bool\n,Vraća tačno ako je krajnji datum sada ili kasnije. (Umesto da se početak / kraj uključuju opcije se ignorišu.),    public function isEnded(): bool    {        return $this->endsBeforeOrAt();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
477,briannesbitt_Carbon_CarbonPeriod_351," Validate current date and stop iteration when necessary.\n\n Returns true when current date is valid, false if it is not, or static::END_ITERATION\n when iteration should be stopped.\n\n @return bool|string\n","Validira trenutni datum i zaustavlja iteraciju kada je potrebno. Vraća tačno kada je trenutni datum validan, netačno ako nije, ili static::END_ITERATION kada je iteraciju treba zaustaviti.",    protected function validateCurrentDate()    {        if ($this->current === null) {            $this->rewind();        }        // Check after the first rewind to avoid repeating the initial validation.        if ($this->validationResult !== null) {            return $this->validationResult;        }        return $this->validationResult = $this->checkFilters();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
478,briannesbitt_Carbon_CarbonPeriod_352, Check whether current value and key pass all the filters.\\n\\n @return bool|string\\n,Proverava da li trenutna vrednost prolazi kroz sve filtere.,"    protected function checkFilters()    {        $current = $this->prepareForReturn($this->current);        foreach ($this->filters as $tuple) {            $result = \call_user_func(                $tuple[0],                $current->avoidMutation(),                $this->key,                $this            );            if ($result === static::END_ITERATION) {                return static::END_ITERATION;            }            if (!$result) {                return false;            }        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
479,briannesbitt_Carbon_CarbonPeriod_354, Keep incrementing the current date until a valid date is found or the iteration is ended.\n\n @throws RuntimeException\n\n @return void\n,Nastavlja sa inkrementacijom trenutnog datuma dok ne dođe do validnog datuma ili se iteracija završi.,    protected function incrementCurrentDateUntilValid()    {        $attempts = 0;        do {            $this->current = $this->current->add($this->dateInterval);            $this->validationResult = null;            if (++$attempts > static::NEXT_MAX_ATTEMPTS) {                throw new UnreachableException('Could not find next valid date.');            }        } while ($this->validateCurrentDate() === false);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
480,cakephp_cakephp_DigestAuthenticate_1199, Gets the digest headers from the request/environment.\\n\\n @param \\\\Cake\\\\Http\\\\ServerRequest $request Request object.\\n @return array|null Array of digest information.\\n,Vraća sažetak zaglavlja iz zehteva/okoline.,"    protected function _getDigest(ServerRequest $request): ?array    {        $digest = $request->getEnv('PHP_AUTH_DIGEST');        if (empty($digest) && function_exists('apache_request_headers')) {            $headers = apache_request_headers();            if (!empty($headers['Authorization']) && substr($headers['Authorization'], 0, 7) === 'Digest ') {                $digest = substr($headers['Authorization'], 7);            }        }        if (empty($digest)) {            return null;        }        return $this->parseAuthData($digest);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
481,cakephp_cakephp_DigestAuthenticate_1200, Parse the digest authentication headers and split them up.\\\\n\\\\n @param string $digest The raw digest authentication headers.\\\\n @return array|null An array of digest authentication headers\\\\n,Parsira sažetak autentikacije zaglavlja i razdvaja ih.,"    public function parseAuthData(string $digest): ?array    {        if (substr($digest, 0, 7) === 'Digest ') {            $digest = substr($digest, 7);        }        $keys = $match = [];        $req = ['nonce' => 1, 'nc' => 1, 'cnonce' => 1, 'qop' => 1, 'username' => 1, 'uri' => 1, 'response' => 1];        preg_match_all('/(\w+)=([\'""]?)([a-zA-Z0-9\:\#\%\?\&@=\.\/_-]+)\2/', $digest, $match, PREG_SET_ORDER);        foreach ($match as $i) {            $keys[$i[1]] = $i[3];            unset($req[$i[1]]);        }        if (empty($req)) {            return $keys;        }        return null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
482,cakephp_cakephp_DigestAuthenticate_1201, Generate the response hash for a given digest array.\\n\\n @param array $digest Digest information containing data from DigestAuthenticate::parseAuthData().\\n @param string $password The digest hash password generated with DigestAuthenticate::password()\\n @param string $method Request method\\n @return string Response hash\\n,Generiše heš odgovora za dati niz sažetaka. ,"    public function generateResponseHash(array $digest, string $password, string $method): string    {        return md5(            $password .            ':' . $digest['nonce'] . ':' . $digest['nc'] . ':' . $digest['cnonce'] . ':' . $digest['qop'] . ':' .            md5($method . ':' . $digest['uri'])        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
483,woocommerce_woocommerce_Container_1874, Add a service provider.\n\n @param ServiceProviderInterface|string $provider\n\n @return self\n,Dodavanje dobavljača usluga.,    public function addServiceProvider($provider) : self    {        $this->providers->add($provider);        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
484,woocommerce_woocommerce_FunctionsMockerHack_1987, Initializes the class.\n\n @param array $mockable_functions An array containing the names of the functions that will become mockable.\n\n @throws \\Exception $mockable_functions is not an array or is empty.\n,Inicijalizuje klasu.,public static function initialize( $mockable_functions ) {if ( ! is_array( $mockable_functions ) || empty( $mockable_functions ) ) {throw new \Exception( 'FunctionsMockeHack::initialize: $mockable_functions must be a non-empty array of function names.' );},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
485,woocommerce_woocommerce_class-wc-ajax_1746, Bulk action - Set Stock.\n\n @param array $variations List of variations.\n @param array $data Data to set.\n\n @used-by bulk_edit_variations\n,Grupna akcija - postavljanje iznosa zaliha.,"private static function variation_bulk_action_variable_stock( $variations, $data ) {if ( ! isset( $data['value'] ) ) {return;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
486,woocommerce_woocommerce_class-wc-ajax_1747, Bulk action - Set Low Stock Amount.\n\n @param array $variations List of variations.\n @param array $data Data to set.\n\n @used-by bulk_edit_variations\n,Grupna akcija - postavljanje niskog iznosa zaliha.,"private static function variation_bulk_action_variable_low_stock_amount( $variations, $data ) {if ( ! isset( $data['value'] ) ) {return;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
487,woocommerce_woocommerce_class-wc-ajax_1754, Bulk action - Delete all.\n\n @param array $variations List of variations.\n @param array $data Data to set.\n\n @used-by bulk_edit_variations\n,Grupna radnja - brisanje svega.,"private static function variation_bulk_action_delete_all( $variations, $data ) {if ( isset( $data['allowed'] ) && 'true' === $data['allowed'] ) {foreach ( $variations as $variation_id ) {$variation = wc_get_product( $variation_id );$variation->delete( true );}}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
488,woocommerce_woocommerce_ContainerAwareTrait_1883, Set a container.\n\n @param Container $container\n\n @return self\n,Postavlja kontejner.,    public function setLeagueContainer(Container $container) : ContainerAwareInterface    {        $this->container = $container;        $this->leagueContainer = $container;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
489,yiisoft_yii2_TestCase_1062, Clean up after test.\\n By default the application created with [[mockApplication]] will be destroyed.\\n,Ćišćenje posle testa. Podrazumevano je da će aplikacija kreirana sa [[mockApplication]] biti uništena.,    protected function tearDown()    {        parent::tearDown();        $this->destroyApplication();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
490,yiisoft_yii2_TranslationController_982, Getting DIFF from git.\\n\\n @param string $translatedFilePath path pointing to translated file\\n @param string $sourceFilePath path pointing to original file\\n @return string DIFF\\n,Vraća DIFF sa git. ,"    protected function getDiff($translatedFilePath, $sourceFilePath)    {        $lastTranslationHash = shell_exec('git log -1 --format=format:""%H"" -- ' . $translatedFilePath);        return shell_exec('git diff ' . $lastTranslationHash . '..HEAD -- ' . $sourceFilePath);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
491,yiisoft_yii2_TranslationController_983, Adds all necessary HTML tags and classes to diff output.\\n\\n @param string $diff DIFF\\n @return string highlighted DIFF\\n,Dodavanje svih potrebnih HTML oznaka i klasa da bi se razlikovali izlazi. ,"    public function highlightDiff($diff)    {        $lines = explode(""\n"", $diff);        foreach ($lines as $key => $val) {            if (strpos($val, '@') === 0) {                $lines[$key] = '<span class=""info"">' . Html::encode($val) . '</span>';            } elseif (strpos($val, '+') === 0) {                $lines[$key] = '<ins>' . Html::encode($val) . '</ins>';            } elseif (strpos($val, '-') === 0) {                $lines[$key] = '<del>' . Html::encode($val) . '</del>';            } else {                $lines[$key] = Html::encode($val);            }        }        return implode(""\n"", $lines);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
492,yiisoft_yii2_Utf8Controller_984, Check files for broken UTF8 and non-printable characters.\\n\\n @author Carsten Brandt <mail@cebe.cc>\\n, Provera da li datoteke imaju nevalidne UTF8 i znakove koji se ne mogu štampati.,"class Utf8Controller extends Controller{    public $defaultAction = 'check-guide';    /**     * Check guide for non-printable characters that may break docs generation.     *     * @param string $directory the directory to check. If not specified, the default     * guide directory will be checked.     */    public function actionCheckGuide($directory = null)    {        if ($directory === null) {            $directory = \dirname(\dirname(__DIR__)) . '/docs';        }        if (is_file($directory)) {            $files = [$directory];        } else {            $files = FileHelper::findFiles($directory, [                'only' => ['*.md'],            ]);        }        foreach ($files as $file) {            $content = file_get_contents($file);            $chars = preg_split('//u', $content, null, PREG_SPLIT_NO_EMPTY);            $line = 1;            $pos = 0;            foreach ($chars as $c) {                $ord = $this->unicodeOrd($c);                $pos++;                if ($ord == 0x000A) {                    $line++;                    $pos = 0;                }                if ($ord === false) {                    $this->found('BROKEN UTF8', $c, $line, $pos, $file);                    continue;                }                // http://unicode-table.com/en/blocks/general-punctuation/                if (0x2000 <= $ord && $ord <= 0x200F                 || 0x2028 <= $ord && $ord <= 0x202E                 || 0x205f <= $ord && $ord <= 0x206F                    ) {                    $this->found('UNSUPPORTED SPACE CHARACTER', $c, $line, $pos, $file);                    continue;                }                if ($ord < 0x0020 && $ord != 0x000A && $ord != 0x0009 ||                    0x0080 <= $ord && $ord < 0x009F) {                    $this->found('CONTROL CHARARCTER', $c, $line, $pos, $file);                    continue;                }//                if ($ord > 0x009F) {//                    $this->found(""NON ASCII CHARARCTER"", $c, $line, $pos, $file);//                    continue;//                }            }        }    }    private $_foundFiles = [];    private function found($what, $char, $line, $pos, $file)    {        if (!isset($this->_foundFiles[$file])) {            $this->stdout(""$file: \n"", Console::BOLD);            $this->_foundFiles[$file] = $file;        }        $hexcode = dechex($this->unicodeOrd($char));        $hexcode = str_repeat('0', max(4 - \strlen($hexcode), 0)) . $hexcode;        $this->stdout(""  at $line:$pos FOUND $what: 0x$hexcode '$char' http://unicode-table.com/en/$hexcode/\n"");    }    /**     * Equivalent for ord() just for unicode.     *     * http://stackoverflow.com/a/10333324/1106908     *     * @param $c     * @return bool|int     */    private function unicodeOrd($c)    {        $h = \ord($c[0]);        if ($h <= 0x7F) {            return $h;        } elseif ($h < 0xC2) {            return false;        } elseif ($h <= 0xDF) {            return ($h & 0x1F) << 6 | (\ord($c[1]) & 0x3F);        } elseif ($h <= 0xEF) {            return ($h & 0x0F) << 12 | (\ord($c[1]) & 0x3F) << 6                                     | (\ord($c[2]) & 0x3F);        } elseif ($h <= 0xF4) {            return ($h & 0x0F) << 18 | (\ord($c[1]) & 0x3F) << 12                                     | (\ord($c[2]) & 0x3F) << 6                                     | (\ord($c[3]) & 0x3F);        }        return false;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
493,walkor_Workerman_Worker_7347, Format status data.\n\n @param $statistics_file\n @return string\n,Formatiranje statusnih podataka.,"    protected static function formatStatusData($statistics_file)    {        static $total_request_cache = array();        if (!\is_readable($statistics_file)) {            return '';        }        $info = \file($statistics_file, \FILE_IGNORE_NEW_LINES);        if (!$info) {            return '';        }        $status_str = '';        $current_total_request = array();        $worker_info = \unserialize($info[0]);        \ksort($worker_info, SORT_NUMERIC);        unset($info[0]);        $data_waiting_sort = array();        $read_process_status = false;        $total_requests = 0;        $total_qps = 0;        $total_connections = 0;        $total_fails = 0;        $total_memory = 0;        $total_timers = 0;        $maxLen1 = static::$_maxSocketNameLength;        $maxLen2 = static::$_maxWorkerNameLength;        foreach($info as $key => $value) {            if (!$read_process_status) {                $status_str .= $value . ""\n"";                if (\preg_match('/^pid.*?memory.*?listening/', $value)) {                    $read_process_status = true;                }                continue;            }            if(\preg_match('/^[0-9]+/', $value, $pid_math)) {                $pid = $pid_math[0];                $data_waiting_sort[$pid] = $value;                if(\preg_match('/^\S+?\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?/', $value, $match)) {                    $total_memory += \intval(\str_ireplace('M','',$match[1]));                    $maxLen1 = \max($maxLen1,\strlen($match[2]));                    $maxLen2 = \max($maxLen2,\strlen($match[3]));                    $total_connections += \intval($match[4]);                    $total_fails += \intval($match[5]);                    $total_timers += \intval($match[6]);                    $current_total_request[$pid] = $match[7];                    $total_requests += \intval($match[7]);                }            }        }        foreach($worker_info as $pid => $info) {            if (!isset($data_waiting_sort[$pid])) {                $status_str .= ""$pid\t"" . \str_pad('N/A', 7) . "" ""                    . \str_pad($info['listen'], static::$_maxSocketNameLength) . "" ""                    . \str_pad($info['name'], static::$_maxWorkerNameLength) . "" ""                    . \str_pad('N/A', 11) . "" "" . \str_pad('N/A', 9) . "" ""                    . \str_pad('N/A', 7) . "" "" . \str_pad('N/A', 13) . "" N/A    [busy] \n"";                continue;            }            //$qps = isset($total_request_cache[$pid]) ? $current_total_request[$pid]            if (!isset($total_request_cache[$pid]) || !isset($current_total_request[$pid])) {                $qps = 0;            } else {                $qps = $current_total_request[$pid] - $total_request_cache[$pid];                $total_qps += $qps;            }            $status_str .= $data_waiting_sort[$pid]. "" "" . \str_pad($qps, 6) ."" [idle]\n"";        }        $total_request_cache = $current_total_request;        $status_str .= ""----------------------------------------------PROCESS STATUS---------------------------------------------------\n"";        $status_str .= ""Summary\t"" . \str_pad($total_memory.'M', 7) . "" ""            . \str_pad('-', $maxLen1) . "" ""            . \str_pad('-', $maxLen2) . "" ""            . \str_pad($total_connections, 11) . "" "" . \str_pad($total_fails, 9) . "" ""            . \str_pad($total_timers, 7) . "" "" . \str_pad($total_requests, 13) . "" ""            . \str_pad($total_qps,6)."" [Summary] \n"";        return $status_str;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
494,walkor_Workerman_Worker_7349, Reinstall signal handler.\n\n @return void\n,Ponovo instalirajte upravljač signalima.,"    protected static function reinstallSignal()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        $signalHandler = '\Workerman\Worker::signalHandler';        // uninstall stop signal handler        \pcntl_signal(\SIGINT, \SIG_IGN, false);        // uninstall stop signal handler        \pcntl_signal(\SIGTERM, \SIG_IGN, false);        // uninstall graceful stop signal handler        \pcntl_signal(\SIGHUP, \SIG_IGN, false);        // uninstall reload signal handler        \pcntl_signal(\SIGUSR1, \SIG_IGN, false);        // uninstall graceful reload signal handler        \pcntl_signal(\SIGQUIT, \SIG_IGN, false);        // uninstall status signal handler        \pcntl_signal(\SIGUSR2, \SIG_IGN, false);        // uninstall connections status signal handler        \pcntl_signal(\SIGIO, \SIG_IGN, false);        // reinstall stop signal handler        static::$globalEvent->add(\SIGINT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful stop signal handler        static::$globalEvent->add(\SIGHUP, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall reload signal handler        static::$globalEvent->add(\SIGUSR1, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful reload signal handler        static::$globalEvent->add(\SIGQUIT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall status signal handler        static::$globalEvent->add(\SIGUSR2, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall connection status signal handler        static::$globalEvent->add(\SIGIO, EventInterface::EV_SIGNAL, $signalHandler);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
495,walkor_Workerman_Worker_7353, Save pid.\n\n @throws Exception\n,Čuvanje pid.,"    protected static function saveMasterPid()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        static::$_masterPid = \posix_getpid();        if (false === \file_put_contents(static::$pidFile, static::$_masterPid)) {            throw new Exception('can not save pid to ' . static::$pidFile);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
496,walkor_Workerman_Worker_7368, Monitor all child processes.\n\n @return void\n,Nadziranje svih procesa dece. ,"    protected static function monitorWorkersForWindows()    {        Timer::add(1, ""\\Workerman\\Worker::checkWorkerStatusForWindows"");        static::$globalEvent->loop();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
497,walkor_Workerman_Worker_7371, Stop.\n\n @return void\n,Stopiranje.,"    public static function stopAll()    {        static::$_status = static::STATUS_SHUTDOWN;        // For master process.        if (static::$_masterPid === \posix_getpid()) {            static::log(""Workerman["" . \basename(static::$_startFile) . ""] stopping ..."");            $worker_pid_array = static::getAllWorkerPids();            // Send stop signal to all child processes.            if (static::$_gracefulStop) {                $sig = \SIGHUP;            } else {                $sig = \SIGINT;            }            foreach ($worker_pid_array as $worker_pid) {                \posix_kill($worker_pid, $sig);                if(!static::$_gracefulStop){                    Timer::add(static::KILL_WORKER_TIMER_TIME, '\posix_kill', array($worker_pid, \SIGKILL), false);                }            }            Timer::add(1, ""\\Workerman\\Worker::checkIfChildRunning"");            // Remove statistics file.            if (\is_file(static::$_statisticsFile)) {                @\unlink(static::$_statisticsFile);            }        } // For child processes.        else {            // Execute exit.            foreach (static::$_workers as $worker) {                if(!$worker->stopping){                    $worker->stop();                    $worker->stopping = true;                }            }            if (!static::$_gracefulStop || ConnectionInterface::$statistics['connection_count'] <= 0) {                static::$_workers = array();                if (static::$globalEvent) {                    static::$globalEvent->destroy();                }                try {                    exit(0);                } catch (Exception $e) {                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
498,walkor_Workerman_Worker_7379, Log.\n\n @param string $msg\n @return void\n,Logovanje.,"    public static function log($msg)    {        $msg = $msg . ""\n"";        if (!static::$daemonize) {            static::safeEcho($msg);        }        \file_put_contents((string)static::$logFile, \date('Y-m-d H:i:s') . ' ' . 'pid:'            . (static::$_OS === \OS_TYPE_LINUX ? \posix_getpid() : 1) . ' ' . $msg, \FILE_APPEND | \LOCK_EX);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
499,walkor_Workerman_Worker_7383, Pause accept new connections.\n\n @return void\n,Pauziranje prihvatanja novih konekcija.,"    public function pauseAccept()    {        if (static::$globalEvent && false === $this->_pauseAccept && $this->_mainSocket) {            static::$globalEvent->del($this->_mainSocket, EventInterface::EV_READ);            $this->_pauseAccept = true;        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
500,walkor_Workerman_Worker_7387, Stop current worker instance.\n\n @return void\n,Zaustavljanje trenutne instance worker-a. ,"    public function stop()    {        // Try to emit onWorkerStop callback.        if ($this->onWorkerStop) {            try {                \call_user_func($this->onWorkerStop, $this);            } catch (\Exception $e) {                static::log($e);                exit(250);            } catch (\Error $e) {                static::log($e);                exit(250);            }        }        // Remove listener for server socket.        $this->unlisten();        // Close all connections for the worker.        if (!static::$_gracefulStop) {            foreach ($this->connections as $connection) {                $connection->close();            }        }        // Clear callback.        $this->onMessage = $this->onClose = $this->onError = $this->onBufferDrain = $this->onBufferFull = null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
501,walkor_Workerman_Worker_7759, Write statistics data to disk.\n\n @return void\n,Upis statističkih podataka na disk.,"    protected static function writeStatisticsToStatusFile()    {        // For master process.        if (static::$_masterPid === \posix_getpid()) {            $all_worker_info = array();            foreach(static::$_pidMap as $worker_id => $pid_array) {                /** @var /Workerman/Worker $worker */                $worker = static::$_workers[$worker_id];                foreach($pid_array as $pid) {                    $all_worker_info[$pid] = array('name' => $worker->name, 'listen' => $worker->getSocketName());                }            }            \file_put_contents(static::$_statisticsFile, \serialize($all_worker_info).""\n"", \FILE_APPEND);            $loadavg = \function_exists('sys_getloadavg') ? \array_map('round', \sys_getloadavg(), array(2)) : array('-', '-', '-');            \file_put_contents(static::$_statisticsFile,                ""----------------------------------------------GLOBAL STATUS----------------------------------------------------\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile,                'Workerman version:' . static::VERSION . ""          PHP version:"" . \PHP_VERSION . ""\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile, 'start time:' . \date('Y-m-d H:i:s',                    static::$_globalStatistics['start_timestamp']) . '   run ' . \floor((\time() - static::$_globalStatistics['start_timestamp']) / (24 * 60 * 60)) . ' days ' . \floor(((\time() - static::$_globalStatistics['start_timestamp']) % (24 * 60 * 60)) / (60 * 60)) . "" hours   \n"",                FILE_APPEND);            $load_str = 'load average: ' . \implode("", "", $loadavg);            \file_put_contents(static::$_statisticsFile,                \str_pad($load_str, 33) . 'event-loop:' . static::getEventLoopName() . ""\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile,                \count(static::$_pidMap) . ' workers       ' . \count(static::getAllWorkerPids()) . "" processes\n"",                \FILE_APPEND);            \file_put_contents(static::$_statisticsFile,                \str_pad('worker_name', static::$_maxWorkerNameLength) . "" exit_status      exit_count\n"", \FILE_APPEND);            foreach (static::$_pidMap as $worker_id => $worker_pid_array) {                $worker = static::$_workers[$worker_id];                if (isset(static::$_globalStatistics['worker_exit_info'][$worker_id])) {                    foreach (static::$_globalStatistics['worker_exit_info'][$worker_id] as $worker_exit_status => $worker_exit_count) {                        \file_put_contents(static::$_statisticsFile,                            \str_pad($worker->name, static::$_maxWorkerNameLength) . "" "" . \str_pad($worker_exit_status,                                16) . "" $worker_exit_count\n"", \FILE_APPEND);                    }                } else {                    \file_put_contents(static::$_statisticsFile,                        \str_pad($worker->name, static::$_maxWorkerNameLength) . "" "" . \str_pad(0, 16) . "" 0\n"",                        \FILE_APPEND);                }            }            \file_put_contents(static::$_statisticsFile,                ""----------------------------------------------PROCESS STATUS---------------------------------------------------\n"",                \FILE_APPEND);            \file_put_contents(static::$_statisticsFile,                ""pid\tmemory  "" . \str_pad('listening', static::$_maxSocketNameLength) . "" "" . \str_pad('worker_name',                    static::$_maxWorkerNameLength) . "" connections "" . \str_pad('send_fail', 9) . "" ""                . \str_pad('timers', 8) . \str_pad('total_request', 13) ."" qps    status\n"", \FILE_APPEND);            \chmod(static::$_statisticsFile, 0722);            foreach (static::getAllWorkerPids() as $worker_pid) {                \posix_kill($worker_pid, \SIGUSR2);            }            return;        }        // For child processes.        \reset(static::$_workers);        /** @var \Workerman\Worker $worker */        $worker            = current(static::$_workers);        $worker_status_str = \posix_getpid() . ""\t"" . \str_pad(round(memory_get_usage(true) / (1024 * 1024), 2) . ""M"", 7)            . "" "" . \str_pad($worker->getSocketName(), static::$_maxSocketNameLength) . "" ""            . \str_pad(($worker->name === $worker->getSocketName() ? 'none' : $worker->name), static::$_maxWorkerNameLength)            . "" "";        $worker_status_str .= \str_pad(ConnectionInterface::$statistics['connection_count'], 11)            . "" "" .  \str_pad(ConnectionInterface::$statistics['send_fail'], 9)            . "" "" . \str_pad(static::$globalEvent->getTimerCount(), 7)            . "" "" . \str_pad(ConnectionInterface::$statistics['total_request'], 13) . ""\n"";        \file_put_contents(static::$_statisticsFile, $worker_status_str, \FILE_APPEND);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
502,walkor_Workerman_Worker_7764, Listen.\n\n @throws Exception\n,Slušanje. ,"    public function listen()    {        if (!$this->_socketName) {            return;        }        // Autoload.        Autoloader::setRootPath($this->_autoloadRootPath);        if (!$this->_mainSocket) {            $local_socket = $this->parseSocketAddress();            // Flag.            $flags = $this->transport === 'udp' ? \STREAM_SERVER_BIND : \STREAM_SERVER_BIND | \STREAM_SERVER_LISTEN;            $errno = 0;            $errmsg = '';            // SO_REUSEPORT.            if ($this->reusePort) {                \stream_context_set_option($this->_context, 'socket', 'so_reuseport', 1);            }            // Create an Internet or Unix domain server socket.            $this->_mainSocket = \stream_socket_server($local_socket, $errno, $errmsg, $flags, $this->_context);            if (!$this->_mainSocket) {                throw new Exception($errmsg);            }            if ($this->transport === 'ssl') {                \stream_socket_enable_crypto($this->_mainSocket, false);            } elseif ($this->transport === 'unix') {                $socket_file = \substr($local_socket, 7);                if ($this->user) {                    \chown($socket_file, $this->user);                }                if ($this->group) {                    \chgrp($socket_file, $this->group);                }            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && static::$_builtinTransports[$this->transport] === 'tcp') {                \set_error_handler(function(){});                $socket = \socket_import_stream($this->_mainSocket);                \socket_set_option($socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($socket, \SOL_TCP, \TCP_NODELAY, 1);                \restore_error_handler();            }            // Non blocking.            \stream_set_blocking($this->_mainSocket, false);        }        $this->resumeAccept();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
503,woocommerce_woocommerce_class-wc-breadcrumb_1837, Add a breadcrumb for pagination.\n,Dodavanje breadcrumb za straničenje.,"protected function paged_trail() {if ( get_query_var( 'paged' ) && 'subcategories' !== woocommerce_get_loop_display_mode() ) {/* translators: %d: page number */$this->add_crumb( sprintf( __( 'Page %d', 'woocommerce' ), get_query_var( 'paged' ) ) );}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
504,woocommerce_woocommerce_Container_1873, Get a definition to extend.\n\n @param string $id [description]\n\n @return DefinitionInterface\n,Vraća definiciju koju treba proširiti. ,"    public function extend(string $id) : DefinitionInterface    {        if ($this->providers->provides($id)) {            $this->providers->register($id);        }        if ($this->definitions->has($id)) {            return $this->definitions->getDefinition($id);        }        throw new NotFoundException(            sprintf('Unable to extend alias (%s) as it is not being managed as a definition', $id)        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
505,googleapis_google-api-php-client_ClientTest_677, Test that the ID token is properly refreshed.\\n,Testiranje da je ID token na pravi način osvežen.,"  public function testRefreshTokenSetsValues()  {    $token = json_encode([        'access_token' => 'xyz',        'id_token' => 'ID_TOKEN',    ]);    $postBody = $this->prophesize('GuzzleHttp\Psr7\Stream');    $postBody->__toString()        ->shouldBeCalledTimes(1)        ->willReturn($token);    if ($this->isGuzzle5()) {      $response = $this->getGuzzle5ResponseMock();      $response->getStatusCode()          ->shouldBeCalledTimes(1)          ->willReturn(200);    } else {      $response = $this->prophesize('Psr\Http\Message\ResponseInterface');    }    $response->getBody()        ->shouldBeCalledTimes(1)        ->willReturn($postBody->reveal());    $response->hasHeader('Content-Type')->willReturn(false);    $http = $this->prophesize('GuzzleHttp\ClientInterface');    if ($this->isGuzzle5()) {      $guzzle5Request = new GuzzleHttp\Message\Request('POST', '/', ['body' => $token]);      $http->createRequest(Argument::any(), Argument::any(), Argument::any())          ->shouldBeCalledTimes(1)          ->willReturn($guzzle5Request);      $http->send(Argument::type('GuzzleHttp\Message\Request'))          ->shouldBeCalledTimes(1)          ->willReturn($response->reveal());    } else {      $http->send(Argument::type('Psr\Http\Message\RequestInterface'), [])          ->shouldBeCalledTimes(1)          ->willReturn($response->reveal());    }    $client = $this->getClient();    $client->setHttpClient($http->reveal());    $client->fetchAccessTokenWithRefreshToken(""REFRESH_TOKEN"");    $token = $client->getAccessToken();    $this->assertEquals(""ID_TOKEN"", $token['id_token']);  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
506,googleapis_google-api-php-client_ClientTest_678, Test that the Refresh Token is set when refreshed.\\n,Testiranje da li je Refresh Token postavljen kada je osvežen.,"  public function testRefreshTokenIsSetOnRefresh()  {    $refreshToken = 'REFRESH_TOKEN';    $token = json_encode(array(        'access_token' => 'xyz',        'id_token' => 'ID_TOKEN',    ));    $postBody = $this->prophesize('Psr\Http\Message\StreamInterface');    $postBody->__toString()        ->shouldBeCalledTimes(1)        ->willReturn($token);    if ($this->isGuzzle5()) {      $response = $this->getGuzzle5ResponseMock();      $response->getStatusCode()          ->shouldBeCalledTimes(1)          ->willReturn(200);    } else {      $response = $this->prophesize('Psr\Http\Message\ResponseInterface');    }    $response->getBody()        ->shouldBeCalledTimes(1)        ->willReturn($postBody->reveal());    $response->hasHeader('Content-Type')->willReturn(false);    $http = $this->prophesize('GuzzleHttp\ClientInterface');    if ($this->isGuzzle5()) {      $guzzle5Request = new GuzzleHttp\Message\Request('POST', '/', ['body' => $token]);      $http->createRequest(Argument::any(), Argument::any(), Argument::any())          ->willReturn($guzzle5Request);      $http->send(Argument::type('GuzzleHttp\Message\Request'))          ->shouldBeCalledTimes(1)          ->willReturn($response->reveal());    } else {      $http->send(Argument::type('Psr\Http\Message\RequestInterface'), [])          ->shouldBeCalledTimes(1)          ->willReturn($response->reveal());    }    $client = $this->getClient();    $client->setHttpClient($http->reveal());    $client->fetchAccessTokenWithRefreshToken($refreshToken);    $token = $client->getAccessToken();    $this->assertEquals($refreshToken, $token['refresh_token']);  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
507,googleapis_google-api-php-client_ClientTest_679, Test that the Refresh Token is not set when a new refresh token is returned.\n,Testiranje da Refresh Token nije postavljen kada je novi osveženi token vraćen.,"  public function testRefreshTokenIsNotSetWhenNewRefreshTokenIsReturned()  {    $refreshToken = 'REFRESH_TOKEN';    $token = json_encode(array(        'access_token' => 'xyz',        'id_token' => 'ID_TOKEN',        'refresh_token' => 'NEW_REFRESH_TOKEN'    ));    $postBody = $this->prophesize('GuzzleHttp\Psr7\Stream');    $postBody->__toString()        ->wilLReturn($token);    if ($this->isGuzzle5()) {      $response = $this->getGuzzle5ResponseMock();      $response->getStatusCode()          ->willReturn(200);    } else {      $response = $this->prophesize('Psr\Http\Message\ResponseInterface');    }    $response->getBody()        ->willReturn($postBody->reveal());    $response->hasHeader('Content-Type')->willReturn(false);    $http = $this->prophesize('GuzzleHttp\ClientInterface');    if ($this->isGuzzle5()) {      $guzzle5Request = new GuzzleHttp\Message\Request('POST', '/', ['body' => $token]);      $http->createRequest(Argument::any(), Argument::any(), Argument::any())          ->willReturn($guzzle5Request);      $http->send(Argument::type('GuzzleHttp\Message\Request'))          ->willReturn($response->reveal());    } else {      $http->send(Argument::type('Psr\Http\Message\RequestInterface'), [])          ->shouldBeCalledTimes(1)          ->willReturn($response->reveal());    }    $client = $this->getClient();    $client->setHttpClient($http->reveal());    $client->fetchAccessTokenWithRefreshToken($refreshToken);    $token = $client->getAccessToken();    $this->assertEquals('NEW_REFRESH_TOKEN', $token['refresh_token']);  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
508,yiisoft_yii2_ReleaseController_975, Shows information about current framework and extension versions.\\\\n,Prikazuje informacije o trenutnom frejmvorku i proširenim verzijama.,"    public function actionInfo()    {        $items = [            'framework',            'app-basic',            'app-advanced',        ];        $extensionPath = ""{$this->basePath}/extensions"";        foreach (scandir($extensionPath) as $extension) {            if (ctype_alpha($extension) && is_dir($extensionPath . '/' . $extension)) {                $items[] = $extension;            }        }        if ($this->update) {            foreach ($items as $item) {                $this->stdout(""fetching tags for $item..."");                if ($item === 'framework') {                    $this->gitFetchTags((string)$this->basePath);                } elseif (strncmp('app-', $item, 4) === 0) {                    $this->gitFetchTags(""{$this->basePath}/apps/"" . substr($item, 4));                } else {                    $this->gitFetchTags(""{$this->basePath}/extensions/$item"");                }                $this->stdout(""done.\n"", Console::FG_GREEN, Console::BOLD);            }        } else {            $this->stdout(""\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n"");        }        $versions = $this->getCurrentVersions($items);        $nextVersions = $this->getNextVersions($versions, self::PATCH);        // print version table        $w = $this->minWidth(array_keys($versions));        $this->stdout(str_repeat(' ', $w + 2) . ""Current Version  Next Version\n"", Console::BOLD);        foreach ($versions as $ext => $version) {            $this->stdout($ext . str_repeat(' ', $w + 3 - mb_strlen($ext)) . $version . '');            $this->stdout(str_repeat(' ', 17 - mb_strlen($version)) . $nextVersions[$ext] . ""\n"");        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
0,cakephp_cakephp_BaseAuthenticate_1177, Get query object for fetching user from database.\\\\n\\\\n @param string $username The username/identifier.\\\\n @return \\\\\\\\Cake\\\\\\\\ORM\\\\\\\\Query\\\\n,Dohvatanje objekta iz upita radi preuzimanja podataka o korisniku iz baze podataka,"    protected function _query(string $username): Query    {        $config = $this->_config;        $table = $this->getTableLocator()->get($config['userModel']);        $options = [            'conditions' => [$table->aliasField($config['fields']['username']) => $username],        ];        $finder = $config['finder'];        if (is_array($finder)) {            $options += current($finder);            $finder = key($finder);        }        if (!isset($options['username'])) {            $options['username'] = $username;        }        return $table->find($finder, $options);    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
1,PrestaShop_PrestaShop_Alias_810, Get all found aliases from DB with search query.\\n\\n @return string Comma separated aliases\\n,Dohvatanje svih pronađenih pseudonima iz baze podataka pomoću upita za pretragu,"    public function getAliases()    {        if (!Alias::isFeatureActive()) {            return '';        }        $aliases = Db::getInstance()->executeS('SELECT a.aliasFROM `' . _DB_PREFIX_ . 'alias` aWHERE `search` = \'' . pSQL($this->search) . '\'');        $aliases = array_map('implode', $aliases);        return implode(', ', $aliases);    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
2,wallabag_wallabag_AnnotationRepository_2416, Retrieves all annotations for a user.\n\n @param int $userId\n\n @return QueryBuilder\n,Dohvata sve napomene za korisnika,"    public function findAnnotationsByPageId($entryId, $userId)    {        return $this->createQueryBuilder('a')            ->where('a.entry = :entryId')->setParameter('entryId', $entryId)            ->andwhere('a.user = :userId')->setParameter('userId', $userId)            ->getQuery()            ->getResult()        ;    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
3,symfony_http-foundation_Request_7937, Generates a normalized URI (URL) for the Request.\n\n @return string A normalized URI (URL) for the Request\n\n @see getQueryString()\n,Generiše normalizovani URI (URL) za zahtev,    public function getUri()    {        if (null !== $qs = $this->getQueryString()) {            $qs = '?'.$qs;        }        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;    },2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
4,PrestaShop_PrestaShop_Address_786, Returns Address ID for a given Supplier ID.\\n\\n @since 1.5.0\\n\\n @param int $id_supplier Supplier ID\\n\\n @return int $id_address Address ID\\n,Vraća ID adrese za dati ID dobavljača,    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    },3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
5,PrestaShop_PrestaShop_Address_787, Check if the alias already exists.\\\\n\\\\n @param string $alias Alias of an address\\\\n @param int $id_address Address id\\\\n @param int $id_customer Customer id\\\\n\\\\n @return false|string|null Amount of aliases found\\\\n @todo: Find out if we shouldn't be returning an int instead? (breaking change)\\\\n,Proverava da li pseudonim već postoji,"    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
6,PrestaShop_PrestaShop_Alias_812, This method is allow to know if a alias exist for AdminImportController.\\\\\\\\n\\\\\\\\n @param int $idAlias Alias ID\\\\\\\\n\\\\\\\\n @return bool\\\\\\\\n\\\\\\\\n @since 1.5.6.0\\\\\\\\n,Ovaj metod dozvoljava da se zna postoji li pseudonim za AdminImportController,"    public static function aliasExists($idAlias)    {        $sql = new DbQuery();        $sql->select('a.`id_alias`');        $sql->from('alias', 'a');        $sql->where('a.`id_alias` = ' . (int) $idAlias);        $row = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow($sql, false);        return isset($row['id_alias']);    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
7,getgrav_grav_Grav_1205," This attempts to find media, other files, and download them\n\n @param string $path\n @return PageInterface|false\n","Pokušava da pronađe medije, druge datoteke i preuzme ih","    public function fallbackUrl($path)    {        $this->fireEvent('onPageFallBackUrl');        /** @var Uri $uri */        $uri = $this['uri'];        /** @var Config $config */        $config = $this['config'];        $uri_extension = strtolower($uri->extension());        $fallback_types = $config->get('system.media.allowed_fallback_types', null);        $supported_types = $config->get('media.types');        // Check whitelist first, then ensure extension is a valid media type        if (!empty($fallback_types) && !in_array($uri_extension, $fallback_types, true)) {            return false;        }        if (!array_key_exists($uri_extension, $supported_types)) {            return false;        }        $path_parts = pathinfo($path);        /** @var Pages $pages */        $pages = $this['pages'];        $page = $pages->find($path_parts['dirname'], true);        if ($page) {            $media = $page->media()->all();            $parsed_url = parse_url(rawurldecode($uri->basename()));            $media_file = $parsed_url['path'];            // if this is a media object, try actions first            if (isset($media[$media_file])) {                /** @var Medium $medium */                $medium = $media[$media_file];                foreach ($uri->query(null, true) as $action => $params) {                    if (in_array($action, ImageMedium::$magic_actions, true)) {                        call_user_func_array([&$medium, $action], explode(',', $params));                    }                }                Utils::download($medium->path(), false);            }            // unsupported media type, try to download it...            if ($uri_extension) {                $extension = $uri_extension;            } else {                if (isset($path_parts['extension'])) {                    $extension = $path_parts['extension'];                } else {                    $extension = null;                }            }            if ($extension) {                $download = true;                if (in_array(ltrim($extension, '.'), $config->get('system.media.unsupported_inline_types', []), true)) {                    $download = false;                }                Utils::download($page->path() . DIRECTORY_SEPARATOR . $uri->basename(), $download);            }            // Nothing found            return false;        }        return $page;    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
8,guzzle_guzzle_Client_9, Applies the array of request options to a request.\\n,Primenjuje niz opcionih zahteva na zahtev,"    private function applyOptions(RequestInterface $request, array &$options): RequestInterface    {        $modify = [            'set_headers' => [],        ];        if (isset($options['headers'])) {            $modify['set_headers'] = $options['headers'];            unset($options['headers']);        }        if (isset($options['form_params'])) {            if (isset($options['multipart'])) {                throw new InvalidArgumentException('You cannot use '                    . 'form_params and multipart at the same time. Use the '                    . 'form_params option if you want to send application/'                    . 'x-www-form-urlencoded requests, and the multipart '                    . 'option to send multipart/form-data requests.');            }            $options['body'] = \http_build_query($options['form_params'], '', '&');            unset($options['form_params']);            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'application/x-www-form-urlencoded';        }        if (isset($options['multipart'])) {            $options['body'] = new Psr7\MultipartStream($options['multipart']);            unset($options['multipart']);        }        if (isset($options['json'])) {            $options['body'] = Utils::jsonEncode($options['json']);            unset($options['json']);            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'application/json';        }        if (!empty($options['decode_content'])            && $options['decode_content'] !== true        ) {            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Accept-Encoding'], $options['_conditional']);            $modify['set_headers']['Accept-Encoding'] = $options['decode_content'];        }        if (isset($options['body'])) {            if (\is_array($options['body'])) {                throw $this->invalidBody();            }            $modify['body'] = Psr7\Utils::streamFor($options['body']);            unset($options['body']);        }        if (!empty($options['auth']) && \is_array($options['auth'])) {            $value = $options['auth'];            $type = isset($value[2]) ? \strtolower($value[2]) : 'basic';            switch ($type) {                case 'basic':                    // Ensure that we don't have the header in different case and set the new value.                    $modify['set_headers'] = Psr7\Utils::caselessRemove(['Authorization'], $modify['set_headers']);                    $modify['set_headers']['Authorization'] = 'Basic '                        . \base64_encode(""$value[0]:$value[1]"");                    break;                case 'digest':                    // @todo: Do not rely on curl                    $options['curl'][\CURLOPT_HTTPAUTH] = \CURLAUTH_DIGEST;                    $options['curl'][\CURLOPT_USERPWD] = ""$value[0]:$value[1]"";                    break;                case 'ntlm':                    $options['curl'][\CURLOPT_HTTPAUTH] = \CURLAUTH_NTLM;                    $options['curl'][\CURLOPT_USERPWD] = ""$value[0]:$value[1]"";                    break;            }        }        if (isset($options['query'])) {            $value = $options['query'];            if (\is_array($value)) {                $value = \http_build_query($value, '', '&', \PHP_QUERY_RFC3986);            }            if (!\is_string($value)) {                throw new InvalidArgumentException('query must be a string or array');            }            $modify['query'] = $value;            unset($options['query']);        }        // Ensure that sink is not an invalid value.        if (isset($options['sink'])) {            // TODO: Add more sink validation?            if (\is_bool($options['sink'])) {                throw new InvalidArgumentException('sink must not be a boolean');            }        }        $request = Psr7\Utils::modifyRequest($request, $modify);        if ($request->getBody() instanceof Psr7\MultipartStream) {            // Use a multipart/form-data POST if a Content-Type is not set.            // Ensure that we don't have the header in different case and set the new value.            $options['_conditional'] = Psr7\Utils::caselessRemove(['Content-Type'], $options['_conditional']);            $options['_conditional']['Content-Type'] = 'multipart/form-data; boundary='                . $request->getBody()->getBoundary();        }        // Merge in conditional headers if they are not present.        if (isset($options['_conditional'])) {            // Build up the changes so it's in a single clone of the message.            $modify = [];            foreach ($options['_conditional'] as $k => $v) {                if (!$request->hasHeader($k)) {                    $modify['set_headers'][$k] = $v;                }            }            $request = Psr7\Utils::modifyRequest($request, $modify);            // Don't pass this internal value along to middleware/handlers.            unset($options['_conditional']);        }        return $request;    }",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
9,matomo-org_matomo_InvalidVisits_265, Adds one site and sends several invalid tracking requests. The result should be\\n one website with no visits.\\n,Dodaje jedan vebsajt i šalje nekoliko nevažećih zahteva za praćenje. Rezultat bi trebalo da bude jedan vebsajt bez poseta,"class InvalidVisits extends Fixture{    public $idSite = 1;    public $dateTime = '2009-01-04 00:11:42';    public $trackInvalidRequests = true;    public function setUp(): void    {        $this->setUpWebsitesAndGoals();        $this->trackVisits();    }    public function tearDown(): void    {        // empty    }    private function setUpWebsitesAndGoals()    {        if (!self::siteCreated($idSite = 1)) {            self::createWebsite($this->dateTime);        }    }    private function trackVisits()    {        if (!$this->trackInvalidRequests) {            return;        }        $dateTime = $this->dateTime;        $idSite = $this->idSite;        API::getInstance()->setGlobalExcludedUserAgents('globalexcludeduseragent');        Cache::regenerateCacheWebsiteAttributes([1]);        // Trigger empty request        $trackerUrl = self::getTrackerUrl();        $response = Http::fetchRemoteFile($trackerUrl);        self::assertTrue(strpos($response, 'Keep full control of your data with the leading free') !== false, 'Piwik empty request response not correct: ' . $response);        $t = self::getTracker($idSite, $dateTime, $defaultInit = true);        // test GoogleBot UA visitor        $t->setUserAgent('Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)');        self::checkResponse($t->doTrackPageView('bot visit, please do not record'));        // Test IP Exclusion works with or without IP exclusion        foreach (array(false, true) as $enable) {            $excludedIp = '154.1.12.34';            API::getInstance()->updateSite($idSite, 'new site name', $url = array('http://site.com'), $ecommerce = 0, $ss = 1, $ss_kwd = '', $ss_cat = '', $excludedIp . ',1.2.3.4', $excludedQueryParameters = null, $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = 'excludeduseragentstring');            Cache::regenerateCacheWebsiteAttributes([1]);            // Enable IP Anonymization            $t->DEBUG_APPEND_URL = '&forceIpAnonymization=' . (int)$enable;            // test with excluded User Agent            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729) (excludeduseragentstring)');            $t->setIp('211.1.2.3');            self::checkResponse($t->doTrackPageView('visit from excluded User Agent'));            $t->setUserAgent('Mozilla/5.0 (Windows NT 6.1; rv:6.0) Gecko/20110814 Firefox/6.0 Google (+https://developers.google.com/+/web/snippet/)');            self::checkResponse($t->doTrackPageView('visit from excluded User Agent'));            // test w/ global excluded User Agent            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729) (globalexcludeduseragent)');            $t->setIp('211.1.2.3');            self::checkResponse($t->doTrackPageView('visit from global excluded User Agent'));            // test with excluded IP            $t->setUserAgent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6 (.NET CLR 3.5.30729)'); // restore normal user agent            $t->setIp($excludedIp);            self::checkResponse($t->doTrackPageView('visit from IP excluded'));            // test with global list of excluded IPs            $excludedIpBis = '145.5.3.4';            API::getInstance()->setGlobalExcludedIps($excludedIpBis);            Cache::regenerateCacheWebsiteAttributes([1]);            $t->setIp($excludedIpBis);            self::checkResponse($t->doTrackPageView('visit from IP globally excluded'));        }        // test unknown url exclusion works        $urls = array(""http://piwik.net"", ""http://my.stuff.com/"");        API::getInstance()->updateSite($idSite, $siteName = null, $urls, $ecommerce = null, $siteSearch = null,            $searchKeywordParameters = null, $searchCategoryParameters = null, $excludedIps = null, $excludedQueryParams = null,            $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = null,            $keepUrlFragments = null, $type = null, $settings = null, $excludeUnknownUrls = 1);        Cache::regenerateCacheWebsiteAttributes([1]);        $t->setIp(""125.4.5.6"");        $t->setUrl(""http://piwik.com/to/the/moon"");        $t->doTrackPageView(""ignored, not from piwik.net"");        $t->setUrl(""http://their.stuff.com/back/to/the/future"");        $t->doTrackPageView(""ignored, not from my.stuff.com"");        // undo exclude unknown urls change (important when multiple fixtures are setup together, as is done in OmniFixture)        API::getInstance()->updateSite($idSite, $siteName = null, $urls, $ecommerce = null, $siteSearch = null,            $searchKeywordParameters = null, $searchCategoryParameters = null, $excludedIps = null, $excludedQueryParams = null,            $timezone = null, $currency = null, $group = null, $startDate = null, $excludedUserAgents = null,            $keepUrlFragments = null, $type = null, $settings = null, $excludeUnknownUrls = 0);        Cache::regenerateCacheWebsiteAttributes([1]);        try {            @$t->setAttributionInfo(array());            self::fail();        } catch (Exception $e) {        }        try {            $t->setAttributionInfo(json_encode('test'));            self::fail();        } catch (Exception $e) {        }        $t->setAttributionInfo(json_encode(array()));    }}",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
10,matomo-org_matomo_RowEvolution_242," This class generates a Row evolution dataset, from input request\\n\\n",Ova klasa generiše niz podataka o evoluciji redova na osnovu unetog zahteva,"class RowEvolution{    private static $actionsUrlReports = array(        'getPageUrls',        'getPageUrlsFollowingSiteSearch',        'getEntryPageUrls',        'getExitPageUrls',        'getPageUrl'    );    public function getRowEvolution($idSite, $period, $date, $apiModule, $apiAction, $label = false, $segment = false, $column = false, $language = false, $apiParameters = array(), $legendAppendMetric = true, $labelUseAbsoluteUrl = true, $labelSeries = '')    {        // validation of requested $period & $date        if ($period == 'range') {            // load days in the range            $period = 'day';        }        if (!Period::isMultiplePeriod($date, $period)) {            throw new Exception(""Row evolutions can not be processed with this combination of \'date\' and \'period\' parameters."");        }        $label = DataTablePostProcessor::unsanitizeLabelParameter($label);        $labels = Piwik::getArrayFromApiParameter($label, $onlyUnique = empty($labelSeries));        $metadata = $this->getRowEvolutionMetaData($idSite, $period, $date, $apiModule, $apiAction, $language, $apiParameters);        $dataTable = $this->loadRowEvolutionDataFromAPI($metadata, $idSite, $period, $date, $apiModule, $apiAction, $labels, $segment, $apiParameters);        if (empty($dataTable->getDataTables())) {            return array();        }        if (empty($labels)) {            $labels = $this->getLabelsFromDataTable($dataTable, $labels);            $dataTable = $this->enrichRowAddMetadataLabelIndex($labels, $dataTable);        }        if (count($labels) != 1) {            $data = $this->getMultiRowEvolution(                $dataTable,                $metadata,                $apiModule,                $apiAction,                $labels,                $column,                $legendAppendMetric,                $labelUseAbsoluteUrl,                $labelSeries            );        } else {            $data = $this->getSingleRowEvolution(                $idSite,                $dataTable,                $metadata,                $apiModule,                $apiAction,                $labels[0],                $labelUseAbsoluteUrl            );        }        return $data;    }    /**     * @param array $labels     * @param DataTable\Map $dataTable     * @return mixed     */    protected function enrichRowAddMetadataLabelIndex($labels, $dataTable)    {        // set label index metadata        $labelsToIndex = array_flip($labels);        foreach ($dataTable->getDataTables() as $table) {            foreach ($table->getRows() as $row) {                $label = $row->getColumn('label');                if (isset($labelsToIndex[$label])) {                    $row->setMetadata(LabelFilter::FLAG_IS_ROW_EVOLUTION, $labelsToIndex[$label]);                }            }        }        return $dataTable;    }    /**     * @param DataTable\Map $dataTable     * @param array $labels     * @return array     */    protected function getLabelsFromDataTable($dataTable, $labels)    {        // if no labels specified, use all possible labels as list        foreach ($dataTable->getDataTables() as $table) {            $labels = array_merge($labels, $table->getColumn('label'));        }        $labels = array_values(array_unique($labels));        // if the filter_limit query param is set, treat it as a request to limit        // the number of labels used        $limit = Common::getRequestVar('filter_limit', false);        if ($limit != false            && $limit >= 0        ) {            $labels = array_slice($labels, 0, $limit);        }        return $labels;    }    /**     * Get row evolution for a single label     * @param DataTable\Map $dataTable     * @param array $metadata     * @param string $apiModule     * @param string $apiAction     * @param string $label     * @param bool $labelUseAbsoluteUrl     * @return array containing  report data, metadata, label, logo     */    private function getSingleRowEvolution($idSite, $dataTable, $metadata, $apiModule, $apiAction, $label, $labelUseAbsoluteUrl = true)    {        $metricNames = array_keys($metadata['metrics']);        $logo = $actualLabel = false;        $urlFound = false;        foreach ($dataTable->getDataTables() as $subTable) {            /** @var $subTable DataTable */            $subTable->applyQueuedFilters();            if ($subTable->getRowsCount() > 0) {                /** @var $row Row */                $row = $subTable->getFirstRow();                if (!$actualLabel) {                    $logo = $row->getMetadata('logo');                    $actualLabel = $this->getRowUrlForEvolutionLabel($row, $apiModule, $apiAction, $labelUseAbsoluteUrl);                    $urlFound = $actualLabel !== false;                    if (empty($actualLabel)) {                        $actualLabel = $row->getColumn('label');                    }                }                // remove all columns that are not in the available metrics.                // this removes the label as well (which is desired for two reasons: (1) it was passed                // in the request, (2) it would cause the evolution graph to show the label in the legend).                foreach ($row->getColumns() as $column => $value) {                    if (!in_array($column, $metricNames) && $column != 'label_html') {                        $row->deleteColumn($column);                    }                }                $row->deleteMetadata();            }        }        $this->enhanceRowEvolutionMetaData($metadata, $dataTable);        // if we have a recursive label and no url, use the path        if (!$urlFound) {            $actualLabel = $this->formatQueryLabelForDisplay($idSite, $apiModule, $apiAction, $label);        }        $return = array(            'label'      => SafeDecodeLabel::decodeLabelSafe($actualLabel),            'reportData' => $dataTable,            'metadata'   => $metadata        );        if (!empty($logo)) {            $return['logo'] = $logo;        }        return $return;    }    private function formatQueryLabelForDisplay($idSite, $apiModule, $apiAction, $label)    {        // rows with subtables do not contain URL metadata. this hack makes sure the label titles in row        // evolution popovers look like URLs.        if ($apiModule == 'Actions'            && in_array($apiAction, self::$actionsUrlReports)        ) {            $mainUrl = Site::getMainUrlFor($idSite);            $mainUrlHost = @parse_url($mainUrl, PHP_URL_HOST);            $replaceRegex = ""/\\s*"" . preg_quote(LabelFilter::SEPARATOR_RECURSIVE_LABEL) . ""\\s*/"";            $cleanLabel = preg_replace($replaceRegex, '/', $label);            $result = $mainUrlHost . '/' . $cleanLabel . '/';        } else {            $result = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        }        // remove @ terminal operator occurrences        return str_replace(LabelFilter::TERMINAL_OPERATOR, '', $result);    }    /**     * @param Row $row     * @param string $apiModule     * @param string $apiAction     * @param bool $labelUseAbsoluteUrl     * @return bool|string     */    private function getRowUrlForEvolutionLabel($row, $apiModule, $apiAction, $labelUseAbsoluteUrl)    {        $url = $row->getMetadata('url');        if ($url            && ($apiModule == 'Actions'                || ($apiModule == 'Referrers'                    && $apiAction == 'getWebsites'))            && $labelUseAbsoluteUrl        ) {            $actualLabel = preg_replace(';^http(s)?://(www.)?;i', '', $url);            return $actualLabel;        }        return false;    }    /**     * @param array $metadata see getRowEvolutionMetaData()     * @param int $idSite     * @param string $period     * @param string $date     * @param string $apiModule     * @param string $apiAction     * @param string|bool $label     * @param string|bool $segment     * @param array $apiParameters     * @throws Exception     * @return DataTable\Map|DataTable     */    private function loadRowEvolutionDataFromAPI($metadata, $idSite, $period, $date, $apiModule, $apiAction, $label, $segment, $apiParameters)    {        if (!is_array($label)) {            $label = array($label);        }        $label = array_map('rawurlencode', $label);        $parameters = array(            'method'                   => $apiModule . '.' . $apiAction,            'label'                    => $label,            'idSite'                   => $idSite,            'period'                   => $period,            'date'                     => $date,            'format'                   => 'original',            'serialize'                => '0',            'segment'                  => $segment,            // data for row evolution should NOT be limited            'filter_limit'             => -1,            // if more than one label is used, we add metadata to ensure we know which            // row corresponds with which label (since the labels can change, and rows            // can be sorted in a different order)            'labelFilterAddLabelIndex' => count($label) > 1 ? 1 : 0,        );        if (!empty($apiParameters) && is_array($apiParameters)) {            foreach ($apiParameters as $param => $value) {                $parameters[$param] = $value;            }        }        // add ""processed metrics"" like actions per visit or bounce rate        // note: some reports should not be filtered with AddColumnProcessedMetrics        // specifically, reports without the Metrics::INDEX_NB_VISITS metric such as Goals.getVisitsUntilConversion & Goal.getDaysToConversion        // this is because the AddColumnProcessedMetrics filter removes all datable rows lacking this metric        if (isset($metadata['metrics']['nb_visits'])) {            $parameters['filter_add_columns_when_show_all_columns'] = '0';        }        $url = Url::getQueryStringFromParameters($parameters);        $request = new Request($url);        try {            $dataTable = $request->process();        } catch (Exception $e) {            throw new Exception(""API returned an error: "" . $e->getMessage() . ""\n"");        }        return $dataTable;    }    /**     * For a given API report, returns a simpler version     * of the metadata (will return only the metrics and the dimension name)     * @param $idSite     * @param $period     * @param $date     * @param $apiModule     * @param $apiAction     * @param $language     * @param $apiParameters     * @throws Exception     * @return array     */    private function getRowEvolutionMetaData($idSite, $period, $date, $apiModule, $apiAction, $language, $apiParameters)    {        $reportMetadata = API::getInstance()->getMetadata($idSite, $apiModule, $apiAction, $apiParameters, $language,            $period, $date, $hideMetricsDoc = false, $showSubtableReports = true);        if (empty($reportMetadata)) {            throw new Exception(""Requested report $apiModule.$apiAction for Website id=$idSite ""                . ""not found in the list of available reports. \n"");        }        $reportMetadata = reset($reportMetadata);        $metrics = $reportMetadata['metrics'];        if (isset($reportMetadata['processedMetrics']) && is_array($reportMetadata['processedMetrics'])) {            $metrics = $metrics + $reportMetadata['processedMetrics'];        }        if (empty($reportMetadata['dimension'])) {            throw new Exception(sprintf('Reports like %s.%s which do not have a dimension are not supported by row evolution', $apiModule, $apiAction));        }        $dimension = $reportMetadata['dimension'];        return compact('metrics', 'dimension');    }    /**     * Given the Row evolution dataTable, and the associated metadata,     * enriches the metadata with min/max values, and % change between the first period and the last one     * @param array $metadata     * @param DataTable\Map $dataTable     */    private function enhanceRowEvolutionMetaData(&$metadata, $dataTable)    {        // prepare result array for metrics        $metricsResult = array();        foreach ($metadata['metrics'] as $metric => $name) {            $metricsResult[$metric] = array('name' => $name);            if (!empty($metadata['logos'][$metric])) {                $metricsResult[$metric]['logo'] = $metadata['logos'][$metric];            }        }        unset($metadata['logos']);        $subDataTables = $dataTable->getDataTables();        if (empty($subDataTables)) {            throw new \Exception(""Unexpected state: row evolution API call returned empty DataTable\\Map."");        }        $firstDataTable = reset($subDataTables);        $this->checkDataTableInstance($firstDataTable);        $firstDataTableRow = $firstDataTable->getFirstRow();        $lastDataTable = end($subDataTables);        $this->checkDataTableInstance($lastDataTable);        $lastDataTableRow = $lastDataTable->getFirstRow();        // Process min/max values        $firstNonZeroFound = array();        foreach ($subDataTables as $subDataTable) {            // $subDataTable is the report for one period, it has only one row            $firstRow = $subDataTable->getFirstRow();            foreach ($metadata['metrics'] as $metric => $label) {                $value = $firstRow ? floatval($firstRow->getColumn($metric)) : 0;                if ($value > 0) {                    $firstNonZeroFound[$metric] = true;                } else if (!isset($firstNonZeroFound[$metric])) {                    continue;                }                if (!isset($metricsResult[$metric]['min'])                    || $metricsResult[$metric]['min'] > $value                ) {                    $metricsResult[$metric]['min'] = $value;                }                if (!isset($metricsResult[$metric]['max'])                    || $metricsResult[$metric]['max'] < $value                ) {                    $metricsResult[$metric]['max'] = $value;                }            }        }        // Process % change between first/last values        foreach ($metadata['metrics'] as $metric => $label) {            $first = $firstDataTableRow ? floatval($firstDataTableRow->getColumn($metric)) : 0;            $last = $lastDataTableRow ? floatval($lastDataTableRow->getColumn($metric)) : 0;            // do not calculate evolution if the first value is 0 (to avoid divide-by-zero)            if ($first == 0) {                continue;            }            $change = CalculateEvolutionFilter::calculate($last, $first, $quotientPrecision = 0, true, true);            $metricsResult[$metric]['change'] = $change;        }        $metadata['metrics'] = $metricsResult;    }    /** Get row evolution for a multiple labels */    private function getMultiRowEvolution(DataTable\Map $dataTable, $metadata, $apiModule, $apiAction, $labels, $column,                                          $legendAppendMetric = true,                                          $labelUseAbsoluteUrl = true,                                          $labelSeries = '')    {        $labelSeries = explode(',', $labelSeries);        $labelSeries = array_filter($labelSeries, 'strlen');        $labelSeries = array_map('intval', $labelSeries);        if (!isset($metadata['metrics'][$column])) {            // invalid column => use the first one that's available            $metrics = array_keys($metadata['metrics']);            $column = reset($metrics);        }        // get the processed label and logo (if any) for every requested label        $actualLabels = $logos = array();        foreach ($labels as $labelIdx => $label) {            foreach ($dataTable->getDataTables() as $table) {                $labelRow = $this->getRowEvolutionRowFromLabelIdx($table, $labelIdx);                if ($labelRow) {                    $actualLabels[$labelIdx] = $this->getRowUrlForEvolutionLabel(                        $labelRow, $apiModule, $apiAction, $labelUseAbsoluteUrl);                    $prettyLabel = $labelRow->getColumn('label_html');                    if ($prettyLabel !== false) {                        $actualLabels[$labelIdx] = $prettyLabel;                    }                    $logos[$labelIdx] = $labelRow->getMetadata('logo');                    if (!empty($actualLabels[$labelIdx])) {                        break;                    }                }            }            if (empty($actualLabels[$labelIdx])) {                $cleanLabel = $this->cleanOriginalLabel($label);                $actualLabels[$labelIdx] = $cleanLabel;            }            if (isset($labelSeries[$labelIdx])) {                $labelSeriesIndex = $labelSeries[$labelIdx];                $actualLabels[$labelIdx] .= ' ' . DataComparisonFilter::getPrettyComparisonLabelFromSeriesIndex($labelSeriesIndex);            }        }        // convert rows to be array($column.'_'.$labelIdx => $value) as opposed to        // array('label' => $label, 'column' => $value).        $dataTableMulti = $dataTable->getEmptyClone();        foreach ($dataTable->getDataTables() as $tableLabel => $table) {            $newRow = new Row();            foreach ($labels as $labelIdx => $label) {                $row = $this->getRowEvolutionRowFromLabelIdx($table, $labelIdx);                $value = 0;                if ($row) {                    $value = $row->getColumn($column);                    $value = floatVal(str_replace(',', '.', $value));                }                if ($value == '') {                    $value = 0;                }                $newLabel = $column . '_' . (int)$labelIdx;                $newRow->addColumn($newLabel, $value);            }            $newTable = $table->getEmptyClone();            if (!empty($labels)) { // only add a row if the row has data (no labels === no data)                $newTable->addRow($newRow);            }            $dataTableMulti->addTable($newTable, $tableLabel);        }        // the available metrics for the report are returned as metadata / columns        $metadata['columns'] = $metadata['metrics'];        // metadata / metrics should document the rows that are compared        // this way, UI code can be reused        $metadata['metrics'] = array();        foreach ($actualLabels as $labelIndex => $label) {            if ($legendAppendMetric) {                $label .= ' (' . $metadata['columns'][$column] . ')';            }            $metricName = $column . '_' . $labelIndex;            $metadata['metrics'][$metricName] = $label;            if (!empty($logos[$labelIndex])) {                $metadata['logos'][$metricName] = $logos[$labelIndex];            }        }        $this->enhanceRowEvolutionMetaData($metadata, $dataTableMulti);        return array(            'column'     => $column,            'reportData' => $dataTableMulti,            'metadata'   => $metadata        );    }    /**     * Returns the row in a datatable by its LabelFilter::FLAG_IS_ROW_EVOLUTION metadata.     *     * @param DataTable $table     * @param int $labelIdx     * @return Row|false     */    private function getRowEvolutionRowFromLabelIdx($table, $labelIdx)    {        $labelIdx = (int)$labelIdx;        foreach ($table->getRows() as $row) {            if ($row->getMetadata(LabelFilter::FLAG_IS_ROW_EVOLUTION) === $labelIdx) {                return $row;            }        }        return false;    }    /**     * Returns a prettier, more comprehensible version of a row evolution label for display.     */    private function cleanOriginalLabel($label)    {        $label = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        $label = SafeDecodeLabel::decodeLabelSafe($label);        return $label;    }    private function checkDataTableInstance($lastDataTable)    {        if (!($lastDataTable instanceof DataTable)) {            throw new \Exception(""Unexpected state: row evolution returned DataTable\\Map w/ incorrect child table type: "" . get_class($lastDataTable));        }    }}",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
11,owncloud_core_AppConfig_1354," Sets a value. If the key did not exist before it will be created.\\\\n\\\\n @param string $app app\\\\n @param string $key key\\\\n @param string|float|int $value value\\\\n @return bool True if the value was inserted or updated, false if the value was the same\\\\n",Postavlja vrednost. Ako ključ nije postojao pre nego što će biti kreiran,"public function setValue($app, $key, $value) {return $this->emittingCall(function (&$afterArray) use (&$app, &$key, &$value) {if (!$this->hasKey($app, $key)) {$inserted = (bool) $this->conn->insertIfNotExist('*PREFIX*appconfig', ['appid' => $app,'configkey' => $key,'configvalue' => $value,], ['appid','configkey',]);if ($inserted) {if (!isset($this->cache[$app])) {$this->cache[$app] = [];}$this->cache[$app][$key] = $value;return true;}}$sql = $this->conn->getQueryBuilder();$sql->update('appconfig')->set('configvalue', $sql->createParameter('configvalue'))->where($sql->expr()->eq('appid', $sql->createParameter('app')))->andWhere($sql->expr()->eq('configkey', $sql->createParameter('configkey')))->setParameter('configvalue', $value)->setParameter('app', $app)->setParameter('configkey', $key);/* * Only limit to the existing value for non-Oracle DBs: * http://docs.oracle.com/cd/E11882_01/server.112/e26088/conditions002.htm#i1033286 * > Large objects (LOBs) are not supported in comparison conditions. */if (!($this->conn instanceof \OC\DB\OracleConnection)) {// Only update the value when it is not the same$sql->andWhere($sql->expr()->neq('configvalue', $sql->createParameter('configvalue')))->setParameter('configvalue', $value);}if (isset($this->cache[$app], $this->cache[$app][$key])) {$afterArray['update'] = true;$afterArray['oldvalue'] = $this->cache[$app][$key];}$changedRow = (bool) $sql->execute();$this->cache[$app][$key] = $value;return $changedRow;}, [",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
12,owncloud_core_AppConfig_1355, Deletes a key\\\\n\\\\n @param string $app app\\\\n @param string $key key\\\\n @return boolean|null\\\\n,Briše ključ,"public function deleteKey($app, $key) {$this->emittingCall(function () use (&$app, &$key) {$this->loadConfigValues();$sql = $this->conn->getQueryBuilder();$sql->delete('appconfig')->where($sql->expr()->eq('appid', $sql->createParameter('app')))->andWhere($sql->expr()->eq('configkey', $sql->createParameter('configkey')))->setParameter('app', $app)->setParameter('configkey', $key);$sql->execute();unset($this->cache[$app][$key]);return true;}, [",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
13,owncloud_core_AppConfig_1356, Remove app from appconfig\n\n @param string $app app\n @return boolean|null\n\n Removes all keys in appconfig belonging to the app.\n,Uklanja aplikaciju iz appconfig,"public function deleteApp($app) {$this->emittingCall(function () use (&$app) {$this->loadConfigValues();$sql = $this->conn->getQueryBuilder();$sql->delete('appconfig')->where($sql->expr()->eq('appid', $sql->createParameter('app')))->setParameter('app', $app);$sql->execute();unset($this->cache[$app]);return true;}, [",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
14,swoft-cloud_swoft_DbSelector_3501, Class DbSelector\n\n @since 2.0\n\n @Bean()\n,Klasa DbSelector,"class DbSelector implements DbSelectorInterface{    /**     * @param Connection $connection     */    public function select(Connection $connection): void    {        $selectIndex  = (int)context()->getRequest()->query('id', 0);        $createDbName = $connection->getDb();        if ($selectIndex == 0) {            $selectIndex = '';        }        if ($createDbName == 'test2') {            $createDbName = 'test';        }        $dbName = sprintf('%s%s', $createDbName, (string)$selectIndex);        $connection->db($dbName);    }}",1.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
15,symfony_http-foundation_UploadedFile_9948, Returns the maximum size of an uploaded file as configured in php.ini.\n\n @return int|float The maximum size of an uploaded file in bytes (returns float if size > PHP_INT_MAX)\n,Vraća maksimalnu veličinu učitane datoteke kako je konfigurisana u php.ini fajlu,"final class UrlHelper{    private $requestStack;    private $requestContext;    public function __construct(RequestStack $requestStack, RequestContext $requestContext = null)    {        $this->requestStack = $requestStack;        $this->requestContext = $requestContext;    }    public function getAbsoluteUrl(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $this->getAbsoluteUrlFromContext($path);        }        if ('#' === $path[0]) {            $path = $request->getRequestUri().$path;        } elseif ('?' === $path[0]) {            $path = $request->getPathInfo().$path;        }        if (!$path || '/' !== $path[0]) {            $prefix = $request->getPathInfo();            $last = \strlen($prefix) - 1;            if ($last !== $pos = strrpos($prefix, '/')) {                $prefix = substr($prefix, 0, $pos).'/';            }            return $request->getUriForPath($prefix.$path);        }        return $request->getSchemeAndHttpHost().$path;    }    public function getRelativePath(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $path;        }        return $request->getRelativeUriForPath($path);    }    private function getAbsoluteUrlFromContext(string $path): string    {        if (null === $this->requestContext || '' === $host = $this->requestContext->getHost()) {            return $path;        }        $scheme = $this->requestContext->getScheme();        $port = '';        if ('http' === $scheme && 80 !== $this->requestContext->getHttpPort()) {            $port = ':'.$this->requestContext->getHttpPort();        } elseif ('https' === $scheme && 443 !== $this->requestContext->getHttpsPort()) {            $port = ':'.$this->requestContext->getHttpsPort();        }        if ('#' === $path[0]) {            $queryString = $this->requestContext->getQueryString();            $path = $this->requestContext->getPathInfo().($queryString ? '?'.$queryString : '').$path;        } elseif ('?' === $path[0]) {            $path = $this->requestContext->getPathInfo().$path;        }        if ('/' !== $path[0]) {            $path = rtrim($this->requestContext->getBaseUrl(), '/').'/'.$path;        }        return $scheme.'://'.$host.$port.$path;    }}",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
16,symfony_http-kernel_UriSigner_3083, Signs URIs.\n\n @author Fabien Potencier <fabien@symfony.com>\n,Potpisuje URI linkove,"    public function check(string $uri)    {        $url = parse_url($uri);        if (isset($url['query'])) {            parse_str($url['query'], $params);        } else {            $params = [];        }        if (empty($params[$this->parameter])) {            return false;        }        $hash = $params[$this->parameter];        unset($params[$this->parameter]);        return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
17,w7corp_easywechat_Client_2087, Get current url.\n\n @return string\n,Preuzmi trenutni url,"class Client extends BaseClient{    /**     * @var string     */    protected $baseUri = 'https://api.weixin.qq.com/cgi-bin/';    /**     * Allow media type.     *     * @var array     */    protected $allowTypes = ['image', 'voice', 'video', 'thumb'];    /**     * Upload image.     *     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadImage($path)    {        return $this->upload('image', $path);    }    /**     * Upload video.     *     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadVideo($path)    {        return $this->upload('video', $path);    }    /**     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadVoice($path)    {        return $this->upload('voice', $path);    }    /**     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadThumb($path)    {        return $this->upload('thumb', $path);    }    /**     * Upload temporary material.     *     * @param string $type     * @param string $path     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function upload(string $type, string $path)    {        if (!file_exists($path) || !is_readable($path)) {            throw new InvalidArgumentException(sprintf(""File does not exist, or the file is unreadable: '%s'"", $path));        }        if (!in_array($type, $this->allowTypes, true)) {            throw new InvalidArgumentException(sprintf(""Unsupported media type: '%s'"", $type));        }        return $this->httpUpload('media/upload', ['media' => $path], ['type' => $type]);    }    /**     * @param string $path     * @param string $title     * @param string $description     *     * @return array|\EasyWeChat\Kernel\Support\Collection|object|\Psr\Http\Message\ResponseInterface|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidArgumentException     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function uploadVideoForBroadcasting(string $path, string $title, string $description)    {        $response = $this->uploadVideo($path);        /** @var array $arrayResponse */        $arrayResponse = $this->detectAndCastResponseToType($response, 'array');        if (!empty($arrayResponse['media_id'])) {            return $this->createVideoForBroadcasting($arrayResponse['media_id'], $title, $description);        }        return $response;    }    /**     * @param string $mediaId     * @param string $title     * @param string $description     *     * @return \Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function createVideoForBroadcasting(string $mediaId, string $title, string $description)    {        return $this->httpPostJson('media/uploadvideo', [            'media_id' => $mediaId,            'title' => $title,            'description' => $description,        ]);    }    /**     * Fetch item from WeChat server.     *     * @param string $mediaId     *     * @return \EasyWeChat\Kernel\Http\StreamResponse|\Psr\Http\Message\ResponseInterface|\EasyWeChat\Kernel\Support\Collection|array|object|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function get(string $mediaId)    {        $response = $this->requestRaw('media/get', 'GET', [            'query' => [                'media_id' => $mediaId,            ],        ]);        if (false !== stripos($response->getHeaderLine('Content-disposition'), 'attachment')) {            return StreamResponse::buildFromPsrResponse($response);        }        return $this->castResponseToType($response, $this->app['config']->get('response_type'));    }    /**     * @param string $mediaId     *     * @return array|\EasyWeChat\Kernel\Http\Response|\EasyWeChat\Kernel\Support\Collection|object|\Psr\Http\Message\ResponseInterface|string     *     * @throws \EasyWeChat\Kernel\Exceptions\InvalidConfigException     * @throws \GuzzleHttp\Exception\GuzzleException     */    public function getJssdkMedia(string $mediaId)    {        $response = $this->requestRaw('media/get/jssdk', 'GET', [            'query' => [                'media_id' => $mediaId,            ],        ]);        if (false !== stripos($response->getHeaderLine('Content-disposition'), 'attachment')) {            return StreamResponse::buildFromPsrResponse($response);        }        return $this->castResponseToType($response, $this->app['config']->get('response_type'));    }}",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
18,wallabag_wallabag_AnnotationRepository_2418, Find annotations for entry id.\\n\\n @param int $entryId\\n @param int $userId\\n\\n @return array\\n,Pronađite napomene za ID unos,"    public function findLastAnnotationByPageId($entryId, $userId)    {        return $this->createQueryBuilder('a')            ->where('a.entry = :entryId')->setParameter('entryId', $entryId)            ->andwhere('a.user = :userId')->setParameter('userId', $userId)            ->orderBy('a.id', 'DESC')            ->setMaxResults(1)            ->getQuery()            ->getOneOrNullResult();    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
19,wallabag_wallabag_AnnotationRepository_2419, Remove all annotations for a user id.\\n Used when a user want to reset all informations.\\n\\n @param int $userId\\n,Uklonite sve napomene za korisnički ID. Koristi se kada korisnik žželi da resetuje sve informacije,"    public function removeAllByUserId($userId)    {        $this->getEntityManager()            ->createQuery('DELETE FROM Wallabag\AnnotationBundle\Entity\Annotation a WHERE a.user = :userId')            ->setParameter('userId', $userId)            ->execute();    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
20,wallabag_wallabag_AnnotationRepository_2421,Return a query builder to used by other getBuilderFor\\n @param int $userId\\n\\n @return QueryBuilder\\n,Vratite graditelj upita onom koji koristi drugi getBuilderFor,"    private function getSortedQueryBuilderByUser($userId)    {        return $this->createQueryBuilder('a')            ->leftJoin('a.user', 'u')            ->andWhere('u.id = :userId')->setParameter('userId', $userId)            ->orderBy('a.id', 'desc')        ;    }",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
21,woocommerce_woocommerce_class-wc-breadcrumb_1834, Add crumbs for a term.\n\n @param int    $term_id  Term ID.\n @param string $taxonomy Taxonomy.\n,Dodajte mrvice (crumbs) za pojam,"protected function search_trail() {if ( is_search() ) {/* translators: %s: search term */$this->add_crumb( sprintf( __( 'Search results for &ldquo;%s&rdquo;', 'woocommerce' ), get_search_query() ), remove_query_arg( 'paged' ) );}",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
22,Intervention_image_AbstractDriver_444, Returns classname of given command name\n\n @param  string $name\n @return string\n,Vraća ime klase za ime date komande,"    private function getCommandClassName($name)    {        $name = mb_convert_case($name[0], MB_CASE_UPPER, 'utf-8') . mb_substr($name, 1, mb_strlen($name));                $drivername = $this->getDriverName();        $classnameLocal = sprintf('\Intervention\Image\%s\Commands\%sCommand', $drivername, ucfirst($name));        $classnameGlobal = sprintf('\Intervention\Image\Commands\%sCommand', ucfirst($name));        if (class_exists($classnameLocal)) {            return $classnameLocal;        } elseif (class_exists($classnameGlobal)) {            return $classnameGlobal;        }        throw new NotSupportedException(            ""Command ({$name}) is not available for driver ({$drivername}).""        );    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
23,bcit-ci_CodeIgniter_Input_363, Fetch the IP Address\n\n Determines and validates the visitor's IP address.\n\n @return\tstring\tIP address\n,Preuzimanje IP adrese. Određuje i potvrđuje IP adresu posetioca,"public function ip_address(){if ($this->ip_address !== FALSE){return $this->ip_address;}$proxy_ips = config_item('proxy_ips');if ( ! empty($proxy_ips) && ! is_array($proxy_ips)){$proxy_ips = explode(',', str_replace(' ', '', $proxy_ips));}$this->ip_address = $this->server('REMOTE_ADDR');if ($proxy_ips){foreach (array('HTTP_X_FORWARDED_FOR', 'HTTP_CLIENT_IP', 'HTTP_X_CLIENT_IP', 'HTTP_X_CLUSTER_CLIENT_IP') as $header){if (($spoof = $this->server($header)) !== NULL){// Some proxies typically list the whole chain of IP// addresses through which the client has reached us.// e.g. client_ip, proxy_ip1, proxy_ip2, etc.sscanf($spoof, '%[^,]', $spoof);if ( ! $this->valid_ip($spoof)){$spoof = NULL;}else{break;}}}if ($spoof){for ($i = 0, $c = count($proxy_ips); $i < $c; $i++){// Check if we have an IP address or a subnetif (strpos($proxy_ips[$i], '/') === FALSE){// An IP address (and not a subnet) is specified.// We can compare right away.if ($proxy_ips[$i] === $this->ip_address){$this->ip_address = $spoof;break;}continue;}// We have a subnet ... now the heavy lifting beginsisset($separator) OR $separator = $this->valid_ip($this->ip_address, 'ipv6') ? ':' : '.';// If the proxy entry doesn't match the IP protocol - skip itif (strpos($proxy_ips[$i], $separator) === FALSE){continue;}// Convert the REMOTE_ADDR IP address to binary, if neededif ( ! isset($ip, $sprintf)){if ($separator === ':'){// Make sure we're have the ""full"" IPv6 format$ip = explode(':',str_replace('::',str_repeat(':', 9 - substr_count($this->ip_address, ':')),$this->ip_address));for ($j = 0; $j < 8; $j++){$ip[$j] = intval($ip[$j], 16);}$sprintf = '%016b%016b%016b%016b%016b%016b%016b%016b';}else{$ip = explode('.', $this->ip_address);$sprintf = '%08b%08b%08b%08b';}$ip = vsprintf($sprintf, $ip);}// Split the netmask length off the network addresssscanf($proxy_ips[$i], '%[^/]/%d', $netaddr, $masklen);// Again, an IPv6 address is most likely in a compressed formif ($separator === ':'){$netaddr = explode(':', str_replace('::', str_repeat(':', 9 - substr_count($netaddr, ':')), $netaddr));for ($j = 0; $j < 8; $j++){$netaddr[$j] = intval($netaddr[$j], 16);}}else{$netaddr = explode('.', $netaddr);}// Convert to binary and finally compareif (strncmp($ip, vsprintf($sprintf, $netaddr), $masklen) === 0){$this->ip_address = $spoof;break;}}}}if ( ! $this->valid_ip($this->ip_address)){return $this->ip_address = '0.0.0.0';}return $this->ip_address;}",0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
24,getgrav_grav_Cache_1130, The GravCache object is used throughout Grav to store and retrieve cached data.\\n It uses DoctrineCache library and supports a variety of caching mechanisms. Those include:\\n\\n APCu\\n RedisCache\\n MemCache\\n MemCacheD\\n FileSystem\\n,"Objekt GravCache koristi se u celom Grav-u za skladištenje i preuzimanje keširanih podataka. Koristi biblioteku DoctrineCache i podržava razne mehanizme keširanja. To uključuje: APCu, RedisCache, MemCache, MemCacheD, FileSistem","class Cache extends Getters{    /** @var string Cache key. */    protected $key;    /** @var int */    protected $lifetime;    /** @var int */    protected $now;    /** @var Config $config */    protected $config;    /** @var DoctrineCache\CacheProvider */    protected $driver;    /** @var CacheInterface */    protected $simpleCache;    /** @var string */    protected $driver_name;    /** @var string */    protected $driver_setting;    /** @var bool */    protected $enabled;    /** @var string */    protected $cache_dir;    protected static $standard_remove = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'cache://images',        'asset://',    ];    protected static $standard_remove_no_images = [        'cache://twig/',        'cache://doctrine/',        'cache://compiled/',        'cache://clockwork/',        'cache://validated-',        'asset://',    ];    protected static $all_remove = [        'cache://',        'cache://images',        'asset://',        'tmp://'    ];    protected static $assets_remove = [        'asset://'    ];    protected static $images_remove = [        'cache://images'    ];    protected static $cache_remove = [        'cache://'    ];    protected static $tmp_remove = [        'tmp://'    ];    /**     * Constructor     *     * @param Grav $grav     */    public function __construct(Grav $grav)    {        $this->init($grav);    }    /**     * Initialization that sets a base key and the driver based on configuration settings     *     * @param  Grav $grav     * @return void     */    public function init(Grav $grav)    {        $this->config = $grav['config'];        $this->now = time();        if (null === $this->enabled) {            $this->enabled = (bool)$this->config->get('system.cache.enabled');        }        /** @var Uri $uri */        $uri = $grav['uri'];        $prefix = $this->config->get('system.cache.prefix');        $uniqueness = substr(md5($uri->rootUrl(true) . $this->config->key() . GRAV_VERSION), 2, 8);        // Cache key allows us to invalidate all cache on configuration changes.        $this->key = ($prefix ? $prefix : 'g') . '-' . $uniqueness;        $this->cache_dir = $grav['locator']->findResource('cache://doctrine/' . $uniqueness, true, true);        $this->driver_setting = $this->config->get('system.cache.driver');        $this->driver = $this->getCacheDriver();        $this->driver->setNamespace($this->key);        /** @var EventDispatcher $dispatcher */        $dispatcher = Grav::instance()['events'];        $dispatcher->addListener('onSchedulerInitialized', [$this, 'onSchedulerInitialized']);    }    /**     * @return CacheInterface     */    public function getSimpleCache()    {        if (null === $this->simpleCache) {            $cache = new \Grav\Framework\Cache\Adapter\DoctrineCache($this->driver, '', $this->getLifetime());            // Disable cache key validation.            $cache->setValidation(false);            $this->simpleCache = $cache;        }        return $this->simpleCache;    }    /**     * Deletes the old out of date file-based caches     *     * @return int     */    public function purgeOldCache()    {        $cache_dir = dirname($this->cache_dir);        $current = basename($this->cache_dir);        $count = 0;        foreach (new DirectoryIterator($cache_dir) as $file) {            $dir = $file->getBasename();            if ($dir === $current || $file->isDot() || $file->isFile()) {                continue;            }            Folder::delete($file->getPathname());            $count++;        }        return $count;    }    /**     * Public accessor to set the enabled state of the cache     *     * @param bool|int $enabled     * @return void     */    public function setEnabled($enabled)    {        $this->enabled = (bool)$enabled;    }    /**     * Returns the current enabled state     *     * @return bool     */    public function getEnabled()    {        return $this->enabled;    }    /**     * Get cache state     *     * @return string     */    public function getCacheStatus()    {        return 'Cache: [' . ($this->enabled ? 'true' : 'false') . '] Setting: [' . $this->driver_setting . '] Driver: [' . $this->driver_name . ']';    }    /**     * Automatically picks the cache mechanism to use.  If you pick one manually it will use that     * If there is no config option for $driver in the config, or it's set to 'auto', it will     * pick the best option based on which cache extensions are installed.     *     * @return DoctrineCache\CacheProvider  The cache driver to use     */    public function getCacheDriver()    {        $setting = $this->driver_setting;        $driver_name = 'file';        // CLI compatibility requires a non-volatile cache driver        if ($this->config->get('system.cache.cli_compatibility') && (            $setting === 'auto' || $this->isVolatileDriver($setting))) {            $setting = $driver_name;        }        if (!$setting || $setting === 'auto') {            if (extension_loaded('apcu')) {                $driver_name = 'apcu';            } elseif (extension_loaded('wincache')) {                $driver_name = 'wincache';            }        } else {            $driver_name = $setting;        }        $this->driver_name = $driver_name;        switch ($driver_name) {            case 'apc':            case 'apcu':                $driver = new DoctrineCache\ApcuCache();                break;            case 'wincache':                $driver = new DoctrineCache\WinCacheCache();                break;            case 'memcache':                if (extension_loaded('memcache')) {                    $memcache = new \Memcache();                    $memcache->connect(                        $this->config->get('system.cache.memcache.server', 'localhost'),                        $this->config->get('system.cache.memcache.port', 11211)                    );                    $driver = new DoctrineCache\MemcacheCache();                    $driver->setMemcache($memcache);                } else {                    throw new LogicException('Memcache PHP extension has not been installed');                }                break;            case 'memcached':                if (extension_loaded('memcached')) {                    $memcached = new \Memcached();                    $memcached->addServer(                        $this->config->get('system.cache.memcached.server', 'localhost'),                        $this->config->get('system.cache.memcached.port', 11211)                    );                    $driver = new DoctrineCache\MemcachedCache();                    $driver->setMemcached($memcached);                } else {                    throw new LogicException('Memcached PHP extension has not been installed');                }                break;            case 'redis':                if (extension_loaded('redis')) {                    $redis = new \Redis();                    $socket = $this->config->get('system.cache.redis.socket', false);                    $password = $this->config->get('system.cache.redis.password', false);                    $databaseId = $this->config->get('system.cache.redis.database', 0);                    if ($socket) {                        $redis->connect($socket);                    } else {                        $redis->connect(                            $this->config->get('system.cache.redis.server', 'localhost'),                            $this->config->get('system.cache.redis.port', 6379)                        );                    }                    // Authenticate with password if set                    if ($password && !$redis->auth($password)) {                        throw new \RedisException('Redis authentication failed');                    }                    // Select alternate ( !=0 ) database ID if set                    if ($databaseId && !$redis->select($databaseId)) {                        throw new \RedisException('Could not select alternate Redis database ID');                    }                    $driver = new DoctrineCache\RedisCache();                    $driver->setRedis($redis);                } else {                    throw new LogicException('Redis PHP extension has not been installed');                }                break;            default:                $driver = new DoctrineCache\FilesystemCache($this->cache_dir);                break;        }        return $driver;    }    /**     * Gets a cached entry if it exists based on an id. If it does not exist, it returns false     *     * @param  string $id the id of the cached entry     * @return mixed|bool     returns the cached entry, can be any type, or false if doesn't exist     */    public function fetch($id)    {        if ($this->enabled) {            return $this->driver->fetch($id);        }        return false;    }    /**     * Stores a new cached entry.     *     * @param  string       $id       the id of the cached entry     * @param  array|object|int $data     the data for the cached entry to store     * @param  int|null     $lifetime the lifetime to store the entry in seconds     */    public function save($id, $data, $lifetime = null)    {        if ($this->enabled) {            if ($lifetime === null) {                $lifetime = $this->getLifetime();            }            $this->driver->save($id, $data, $lifetime);        }    }    /**     * Deletes an item in the cache based on the id     *     * @param string $id    the id of the cached data entry     * @return bool         true if the item was deleted successfully     */    public function delete($id)    {        if ($this->enabled) {            return $this->driver->delete($id);        }        return false;    }    /**     * Deletes all cache     *     * @return bool     */    public function deleteAll()    {        if ($this->enabled) {            return $this->driver->deleteAll();        }        return false;    }    /**     * Returns a boolean state of whether or not the item exists in the cache based on id key     *     * @param string $id    the id of the cached data entry     * @return bool         true if the cached items exists     */    public function contains($id)    {        if ($this->enabled) {            return $this->driver->contains(($id));        }        return false;    }    /**     * Getter method to get the cache key     *     * @return string     */    public function getKey()    {        return $this->key;    }    /**     * Setter method to set key (Advanced)     *     * @param string $key     * @return void     */    public function setKey($key)    {        $this->key = $key;        $this->driver->setNamespace($this->key);    }    /**     * Helper method to clear all Grav caches     *     * @param string $remove standard|all|assets-only|images-only|cache-only     * @return array     */    public static function clearCache($remove = 'standard')    {        $locator = Grav::instance()['locator'];        $output = [];        $user_config = USER_DIR . 'config/system.yaml';        switch ($remove) {            case 'all':                $remove_paths = self::$all_remove;                break;            case 'assets-only':                $remove_paths = self::$assets_remove;                break;            case 'images-only':                $remove_paths = self::$images_remove;                break;            case 'cache-only':                $remove_paths = self::$cache_remove;                break;            case 'tmp-only':                $remove_paths = self::$tmp_remove;                break;            case 'invalidate':                $remove_paths = [];                break;            default:                if (Grav::instance()['config']->get('system.cache.clear_images_by_default')) {                    $remove_paths = self::$standard_remove;                } else {                    $remove_paths = self::$standard_remove_no_images;                }        }        // Delete entries in the doctrine cache if required        if (in_array($remove, ['all', 'standard'])) {            $cache = Grav::instance()['cache'];            $cache->driver->deleteAll();        }        // Clearing cache event to add paths to clear        Grav::instance()->fireEvent('onBeforeCacheClear', new Event(['remove' => $remove, 'paths' => &$remove_paths]));        foreach ($remove_paths as $stream) {            // Convert stream to a real path            try {                $path = $locator->findResource($stream, true, true);                if ($path === false) {                    continue;                }                $anything = false;                $files = glob($path . '/*');                if (is_array($files)) {                    foreach ($files as $file) {                        if (is_link($file)) {                            $output[] = '<yellow>Skipping symlink:  </yellow>' . $file;                        } elseif (is_file($file)) {                            if (@unlink($file)) {                                $anything = true;                            }                        } elseif (is_dir($file)) {                            if (Folder::delete($file, false)) {                                $anything = true;                            }                        }                    }                }                if ($anything) {                    $output[] = '<red>Cleared:  </red>' . $path . '/*';                }            } catch (Exception $e) {                // stream not found or another error while deleting files.                $output[] = '<red>ERROR: </red>' . $e->getMessage();            }        }        $output[] = '';        if (($remove === 'all' || $remove === 'standard') && file_exists($user_config)) {            touch($user_config);            $output[] = '<red>Touched: </red>' . $user_config;            $output[] = '';        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }        Grav::instance()->fireEvent('onAfterCacheClear', new Event(['remove' => $remove, 'output' => &$output]));        return $output;    }    /**     * @return void     */    public static function invalidateCache()    {        $user_config = USER_DIR . 'config/system.yaml';        if (file_exists($user_config)) {            touch($user_config);        }        // Clear stat cache        @clearstatcache();        // Clear opcache        if (function_exists('opcache_reset')) {            @opcache_reset();        }    }    /**     * Set the cache lifetime programmatically     *     * @param int $future timestamp     * @return void     */    public function setLifetime($future)    {        if (!$future) {            return;        }        $interval = (int)($future - $this->now);        if ($interval > 0 && $interval < $this->getLifetime()) {            $this->lifetime = $interval;        }    }    /**     * Retrieve the cache lifetime (in seconds)     *     * @return int     */    public function getLifetime()    {        if ($this->lifetime === null) {            $this->lifetime = (int)($this->config->get('system.cache.lifetime') ?: 604800); // 1 week default        }        return $this->lifetime;    }    /**     * Returns the current driver name     *     * @return string     */    public function getDriverName()    {        return $this->driver_name;    }    /**     * Returns the current driver setting     *     * @return string     */    public function getDriverSetting()    {        return $this->driver_setting;    }    /**     * is this driver a volatile driver in that it resides in PHP process memory     *     * @param string $setting     * @return bool     */    public function isVolatileDriver($setting)    {        if (in_array($setting, ['apc', 'apcu', 'xcache', 'wincache'])) {            return true;        }        return false;    }    /**     * Static function to call as a scheduled Job to purge old Doctrine files     *     * @param bool $echo     *     * @return string|void     */    public static function purgeJob($echo = false)    {        /** @var Cache $cache */        $cache = Grav::instance()['cache'];        $deleted_folders = $cache->purgeOldCache();        $msg = 'Purged ' . $deleted_folders . ' old cache folders...';        if ($echo) {            echo $msg;        } else {            return $msg;        }    }    /**     * Static function to call as a scheduled Job to clear Grav cache     *     * @param string $type     * @return void     */    public static function clearJob($type)    {        $result = static::clearCache($type);        static::invalidateCache();        echo strip_tags(implode(""\n"", $result));    }    /**     * @param Event $event     * @return void     */    public function onSchedulerInitialized(Event $event)    {        /** @var Scheduler $scheduler */        $scheduler = $event['scheduler'];        $config = Grav::instance()['config'];        // File Cache Purge        $at = $config->get('system.cache.purge_at');        $name = 'cache-purge';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::purgeJob', [true], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');        // Cache Clear        $at = $config->get('system.cache.clear_at');        $clear_type = $config->get('system.cache.clear_job_type');        $name = 'cache-clear';        $logs = 'logs/' . $name . '.out';        $job = $scheduler->addFunction('Grav\Common\Cache::clearJob', [$clear_type], $name);        $job->at($at);        $job->output($logs);        $job->backlink('/config/system#caching');    }}",0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
25,googleapis_google-api-php-client_Model_654," This class defines attributes, valid values, and usage which is generated\\\\n from a given json schema.\\\\n http://tools.ietf.org/html/draft-zyp-json-schema-03#section-5\\\\n\\\\n","Ova klasa definiše atribute, važeće vrednosti i upotrebu koja se generiše iz date json šeme","class Model implements \ArrayAccess{  /**   * If you need to specify a NULL JSON value, use Google\Model::NULL_VALUE   * instead - it will be replaced when converting to JSON with a real null.   */  const NULL_VALUE = ""{}gapi-php-null"";  protected $internal_gapi_mappings = array();  protected $modelData = array();  protected $processed = array();  /**   * Polymorphic - accepts a variable number of arguments dependent   * on the type of the model subclass.   */  final public function __construct()  {    if (func_num_args() == 1 && is_array(func_get_arg(0))) {      // Initialize the model with the array's contents.      $array = func_get_arg(0);      $this->mapTypes($array);    }    $this->gapiInit();  }  /**   * Getter that handles passthrough access to the data array, and lazy object creation.   * @param string $key Property name.   * @return mixed The value if any, or null.   */  public function __get($key)  {    $keyType = $this->keyType($key);    $keyDataType = $this->dataType($key);    if ($keyType && !isset($this->processed[$key])) {      if (isset($this->modelData[$key])) {        $val = $this->modelData[$key];      } elseif ($keyDataType == 'array' || $keyDataType == 'map') {        $val = array();      } else {        $val = null;      }      if ($this->isAssociativeArray($val)) {        if ($keyDataType && 'map' == $keyDataType) {          foreach ($val as $arrayKey => $arrayItem) {              $this->modelData[$key][$arrayKey] =                new $keyType($arrayItem);          }        } else {          $this->modelData[$key] = new $keyType($val);        }      } else if (is_array($val)) {        $arrayObject = array();        foreach ($val as $arrayIndex => $arrayItem) {          $arrayObject[$arrayIndex] = new $keyType($arrayItem);        }        $this->modelData[$key] = $arrayObject;      }      $this->processed[$key] = true;    }    return isset($this->modelData[$key]) ? $this->modelData[$key] : null;  }  /**   * Initialize this object's properties from an array.   *   * @param array $array Used to seed this object's properties.   * @return void   */  protected function mapTypes($array)  {    // Hard initialise simple types, lazy load more complex ones.    foreach ($array as $key => $val) {      if ($keyType = $this->keyType($key)) {        $dataType = $this->dataType($key);        if ($dataType == 'array' || $dataType == 'map') {          $this->$key = array();          foreach ($val as $itemKey => $itemVal) {            if ($itemVal instanceof $keyType) {              $this->{$key}[$itemKey] = $itemVal;            } else {              $this->{$key}[$itemKey] = new $keyType($itemVal);            }          }        } elseif ($val instanceof $keyType) {          $this->$key = $val;        } else {          $this->$key = new $keyType($val);        }        unset($array[$key]);      } elseif (property_exists($this, $key)) {          $this->$key = $val;          unset($array[$key]);      } elseif (property_exists($this, $camelKey = $this->camelCase($key))) {          // This checks if property exists as camelCase, leaving it in array as snake_case          // in case of backwards compatibility issues.          $this->$camelKey = $val;      }    }    $this->modelData = $array;  }  /**   * Blank initialiser to be used in subclasses to do  post-construction initialisation - this   * avoids the need for subclasses to have to implement the variadics handling in their   * constructors.   */  protected function gapiInit()  {    return;  }  /**   * Create a simplified object suitable for straightforward   * conversion to JSON. This is relatively expensive   * due to the usage of reflection, but shouldn't be called   * a whole lot, and is the most straightforward way to filter.   */  public function toSimpleObject()  {    $object = new stdClass();    // Process all other data.    foreach ($this->modelData as $key => $val) {      $result = $this->getSimpleValue($val);      if ($result !== null) {        $object->$key = $this->nullPlaceholderCheck($result);      }    }    // Process all public properties.    $reflect = new ReflectionObject($this);    $props = $reflect->getProperties(ReflectionProperty::IS_PUBLIC);    foreach ($props as $member) {      $name = $member->getName();      $result = $this->getSimpleValue($this->$name);      if ($result !== null) {        $name = $this->getMappedName($name);        $object->$name = $this->nullPlaceholderCheck($result);      }    }    return $object;  }  /**   * Handle different types of values, primarily   * other objects and map and array data types.   */  private function getSimpleValue($value)  {    if ($value instanceof Model) {      return $value->toSimpleObject();    } else if (is_array($value)) {      $return = array();      foreach ($value as $key => $a_value) {        $a_value = $this->getSimpleValue($a_value);        if ($a_value !== null) {          $key = $this->getMappedName($key);          $return[$key] = $this->nullPlaceholderCheck($a_value);        }      }      return $return;    }    return $value;  }  /**   * Check whether the value is the null placeholder and return true null.   */  private function nullPlaceholderCheck($value)  {    if ($value === self::NULL_VALUE) {      return null;    }    return $value;  }  /**   * If there is an internal name mapping, use that.   */  private function getMappedName($key)  {    if (isset($this->internal_gapi_mappings, $this->internal_gapi_mappings[$key])) {      $key = $this->internal_gapi_mappings[$key];    }    return $key;  }  /**   * Returns true only if the array is associative.   * @param array $array   * @return bool True if the array is associative.   */  protected function isAssociativeArray($array)  {    if (!is_array($array)) {      return false;    }    $keys = array_keys($array);    foreach ($keys as $key) {      if (is_string($key)) {        return true;      }    }    return false;  }  /**   * Verify if $obj is an array.   * @throws \Google\Exception Thrown if $obj isn't an array.   * @param array $obj Items that should be validated.   * @param string $method Method expecting an array as an argument.   */  public function assertIsArray($obj, $method)  {    if ($obj && !is_array($obj)) {      throw new GoogleException(          ""Incorrect parameter type passed to $method(). Expected an array.""      );    }  }  public function offsetExists($offset)  {    return isset($this->$offset) || isset($this->modelData[$offset]);  }  public function offsetGet($offset)  {    return isset($this->$offset) ?        $this->$offset :        $this->__get($offset);  }  public function offsetSet($offset, $value)  {    if (property_exists($this, $offset)) {      $this->$offset = $value;    } else {      $this->modelData[$offset] = $value;      $this->processed[$offset] = true;    }  }  public function offsetUnset($offset)  {    unset($this->modelData[$offset]);  }  protected function keyType($key)  {    $keyType = $key . ""Type"";    // ensure keyType is a valid class    if (property_exists($this, $keyType) && class_exists($this->$keyType)) {      return $this->$keyType;    }  }  protected function dataType($key)  {    $dataType = $key . ""DataType"";    if (property_exists($this, $dataType)) {      return $this->$dataType;    }  }  public function __isset($key)  {    return isset($this->modelData[$key]);  }  public function __unset($key)  {    unset($this->modelData[$key]);  }  /**   * Convert a string to camelCase   * @param  string $value   * @return string   */  private function camelCase($value)  {    $value = ucwords(str_replace(array('-', '_'), ' ', $value));    $value = str_replace(' ', '', $value);    $value[0] = strtolower($value[0]);    return $value;  }}",0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
26,php-pm_php-pm_ProcessSlave_1637, Handle a redirected request from master.\n\n @param ServerRequestInterface $request\n @return ResponseInterface\n,Obrađuje preusmereni zahtev od mastera,"    protected function handleRequest(ServerRequestInterface $request)    {        if ($this->getStaticDirectory()) {            $staticResponse = $this->serveStatic($request);            if ($staticResponse instanceof ResponseInterface) {                return $staticResponse;            }        }        if ($bridge = $this->getBridge()) {            try {                $response = $bridge->handle($request);            } catch (\Throwable $t) {                \error_log(                    'An exception was thrown by the bridge. Forcing restart of the worker. The exception was: ' .                    (string)$t                );                $response = new Response(500, [], 'Unexpected error');                @\ob_end_clean();                $this->shutdown();            }            $this->sendCurrentFiles();        } else {            $response = new Response(404, [], 'No Bridge defined');        }        if (\headers_sent()) {            //when a script sent headers the cgi process needs to die because the second request            //trying to send headers again will fail (headers already sent fatal). Its best to not even            //try to send headers because this break the whole approach of php-pm using php-cgi.            \error_log(                'Headers have been sent, but not redirected to client. Forcing restart of the worker. ' .                'Make sure your application does not send headers on its own.'            );            $this->shutdown();        }        $this->sendMessage($this->controller, 'stats', ['memory_usage' => \round(\memory_get_peak_usage(true)/1048576, 2)]); // Convert memory usage to MB        return $response;    }",0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
27,symfony_debug_ClassNotFoundFatalErrorHandler_1769," ErrorHandler for classes that do not exist.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\FatalErrorHandler\\\\ClassNotFoundFatalErrorHandler instead.\\n",ErrorHandler za klase koje ne postoje,"class ClassNotFoundFatalErrorHandler implements FatalErrorHandlerInterface{    /**     * {@inheritdoc}     */    public function handleError(array $error, FatalErrorException $exception)    {        if (!preg_match('/^(Class|Interface|Trait) [\'""]([^\'""]+)[\'""] not found$/', $error['message'], $matches)) {            return null;        }        $typeName = strtolower($matches[1]);        $fullyQualifiedClassName = $matches[2];        if (false !== $namespaceSeparatorIndex = strrpos($fullyQualifiedClassName, '\\')) {            $className = substr($fullyQualifiedClassName, $namespaceSeparatorIndex + 1);            $namespacePrefix = substr($fullyQualifiedClassName, 0, $namespaceSeparatorIndex);            $message = sprintf('Attempted to load %s ""%s"" from namespace ""%s"".', $typeName, $className, $namespacePrefix);            $tail = ' for another namespace?';        } else {            $className = $fullyQualifiedClassName;            $message = sprintf('Attempted to load %s ""%s"" from the global namespace.', $typeName, $className);            $tail = '?';        }        if ($candidates = $this->getClassCandidates($className)) {            $tail = array_pop($candidates).'""?';            if ($candidates) {                $tail = ' for e.g. ""'.implode('"", ""', $candidates).'"" or ""'.$tail;            } else {                $tail = ' for ""'.$tail;            }        }        $message .= ""\nDid you forget a \""use\"" statement"".$tail;        return new ClassNotFoundException($message, $exception);    }    /**     * Tries to guess the full namespace for a given class name.     *     * By default, it looks for PSR-0 and PSR-4 classes registered via a Symfony or a Composer     * autoloader (that should cover all common cases).     *     * @param string $class A class name (without its namespace)     *     * @return array An array of possible fully qualified class names     */    private function getClassCandidates(string $class): array    {        if (!\is_array($functions = spl_autoload_functions())) {            return [];        }        // find Symfony and Composer autoloaders        $classes = [];        foreach ($functions as $function) {            if (!\is_array($function)) {                continue;            }            // get class loaders wrapped by DebugClassLoader            if ($function[0] instanceof DebugClassLoader) {                $function = $function[0]->getClassLoader();                if (!\is_array($function)) {                    continue;                }            }            if ($function[0] instanceof ComposerClassLoader || $function[0] instanceof SymfonyClassLoader) {                foreach ($function[0]->getPrefixes() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }            if ($function[0] instanceof ComposerClassLoader) {                foreach ($function[0]->getPrefixesPsr4() as $prefix => $paths) {                    foreach ($paths as $path) {                        $classes = array_merge($classes, $this->findClassInPath($path, $class, $prefix));                    }                }            }        }        return array_unique($classes);    }    private function findClassInPath(string $path, string $class, string $prefix): array    {        if (!$path = realpath($path.'/'.strtr($prefix, '\\_', '//')) ?: realpath($path.'/'.\dirname(strtr($prefix, '\\_', '//'))) ?: realpath($path)) {            return [];        }        $classes = [];        $filename = $class.'.php';        foreach (new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS), \RecursiveIteratorIterator::LEAVES_ONLY) as $file) {            if ($filename == $file->getFileName() && $class = $this->convertFileToClass($path, $file->getPathName(), $prefix)) {                $classes[] = $class;            }        }        return $classes;    }    private function convertFileToClass(string $path, string $file, string $prefix): ?string    {        $candidates = [            // namespaced class            $namespacedClass = str_replace([$path.\DIRECTORY_SEPARATOR, '.php', '/'], ['', '', '\\'], $file),            // namespaced class (with target dir)            $prefix.$namespacedClass,            // namespaced class (with target dir and separator)            $prefix.'\\'.$namespacedClass,            // PEAR class            str_replace('\\', '_', $namespacedClass),            // PEAR class (with target dir)            str_replace('\\', '_', $prefix.$namespacedClass),            // PEAR class (with target dir and separator)            str_replace('\\', '_', $prefix.'\\'.$namespacedClass),        ];        if ($prefix) {            $candidates = array_filter($candidates, function ($candidate) use ($prefix) { return 0 === strpos($candidate, $prefix); });        }        // We cannot use the autoloader here as most of them use require; but if the class        // is not found, the new autoloader call will require the file again leading to a        // ""cannot redeclare class"" error.        foreach ($candidates as $candidate) {            if ($this->classExists($candidate)) {                return $candidate;            }        }        try {            require_once $file;        } catch (\Throwable $e) {            return null;        }        foreach ($candidates as $candidate) {            if ($this->classExists($candidate)) {                return $candidate;            }        }        return null;    }    private function classExists(string $class): bool    {        return class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);    }}",0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
28,symfony_http-foundation_FileBag_9727, Converts uploaded files to UploadedFile instances.\n\n @param array|UploadedFile $file A (multi-dimensional) array of uploaded file information\n\n @return UploadedFile[]|UploadedFile|null A (multi-dimensional) array of UploadedFile instances\n,Pretvara otpremljene datoteke u UploadedFile instance ,"    protected function convertFileInformation($file)    {        if ($file instanceof UploadedFile) {            return $file;        }        if (\is_array($file)) {            $file = $this->fixPhpFilesArray($file);            $keys = array_keys($file);            sort($keys);            if (self::FILE_KEYS == $keys) {                if (\UPLOAD_ERR_NO_FILE == $file['error']) {                    $file = null;                } else {                    $file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['error'], false);                }            } else {                $file = array_map([$this, 'convertFileInformation'], $file);                if (array_keys($keys) === $keys) {                    $file = array_filter($file);                }            }        }        return $file;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
29,symfony_http-foundation_ParameterBag_8812, ParameterBag is a container for key/value pairs.\n\n @author Fabien Potencier <fabien@symfony.com>\n,ParameterBag je kontejner za parove ključ/vrijednost,"class ParameterBag implements \IteratorAggregate, \Countable{    /**     * Parameter storage.     */    protected $parameters;    public function __construct(array $parameters = [])    {        $this->parameters = $parameters;    }    /**     * Returns the parameters.     *     * @param string|null $key The name of the parameter to return or null to get them all     *     * @return array An array of parameters     */    public function all(/*string $key = null*/)    {        $key = \func_num_args() > 0 ? func_get_arg(0) : null;        if (null === $key) {            return $this->parameters;        }        if (!\is_array($value = $this->parameters[$key] ?? [])) {            throw new BadRequestException(sprintf('Unexpected value for parameter ""%s"": expecting ""array"", got ""%s"".', $key, get_debug_type($value)));        }        return $value;    }    /**     * Returns the parameter keys.     *     * @return array An array of parameter keys     */    public function keys()    {        return array_keys($this->parameters);    }    /**     * Replaces the current parameters by a new set.     */    public function replace(array $parameters = [])    {        $this->parameters = $parameters;    }    /**     * Adds parameters.     */    public function add(array $parameters = [])    {        $this->parameters = array_replace($this->parameters, $parameters);    }    /**     * Returns a parameter by name.     *     * @param mixed $default The default value if the parameter key does not exist     *     * @return mixed     */    public function get(string $key, $default = null)    {        return \array_key_exists($key, $this->parameters) ? $this->parameters[$key] : $default;    }    /**     * Sets a parameter by name.     *     * @param mixed $value The value     */    public function set(string $key, $value)    {        $this->parameters[$key] = $value;    }    /**     * Returns true if the parameter is defined.     *     * @return bool true if the parameter exists, false otherwise     */    public function has(string $key)    {        return \array_key_exists($key, $this->parameters);    }    /**     * Removes a parameter.     */    public function remove(string $key)    {        unset($this->parameters[$key]);    }    /**     * Returns the alphabetic characters of the parameter value.     *     * @return string The filtered value     */    public function getAlpha(string $key, string $default = '')    {        return preg_replace('/[^[:alpha:]]/', '', $this->get($key, $default));    }    /**     * Returns the alphabetic characters and digits of the parameter value.     *     * @return string The filtered value     */    public function getAlnum(string $key, string $default = '')    {        return preg_replace('/[^[:alnum:]]/', '', $this->get($key, $default));    }    /**     * Returns the digits of the parameter value.     *     * @return string The filtered value     */    public function getDigits(string $key, string $default = '')    {        // we need to remove - and + because they're allowed in the filter        return str_replace(['-', '+'], '', $this->filter($key, $default, \FILTER_SANITIZE_NUMBER_INT));    }    /**     * Returns the parameter value converted to integer.     *     * @return int The filtered value     */    public function getInt(string $key, int $default = 0)    {        return (int) $this->get($key, $default);    }    /**     * Returns the parameter value converted to boolean.     *     * @return bool The filtered value     */    public function getBoolean(string $key, bool $default = false)    {        return $this->filter($key, $default, \FILTER_VALIDATE_BOOLEAN);    }    /**     * Filter key.     *     * @param mixed $default Default = null     * @param int   $filter  FILTER_* constant     * @param mixed $options Filter options     *     * @see https://php.net/filter-var     *     * @return mixed     */    public function filter(string $key, $default = null, int $filter = \FILTER_DEFAULT, $options = [])    {        $value = $this->get($key, $default);        // Always turn $options into an array - this allows filter_var option shortcuts.        if (!\is_array($options) && $options) {            $options = ['flags' => $options];        }        // Add a convenience check for arrays.        if (\is_array($value) && !isset($options['flags'])) {            $options['flags'] = \FILTER_REQUIRE_ARRAY;        }        if ((\FILTER_CALLBACK & $filter) && !(($options['options'] ?? null) instanceof \Closure)) {            trigger_deprecation('symfony/http-foundation', '5.2', 'Not passing a Closure together with FILTER_CALLBACK to ""%s()"" is deprecated. Wrap your filter in a closure instead.', __METHOD__);            // throw new \InvalidArgumentException(sprintf('A Closure must be passed to ""%s()"" when FILTER_CALLBACK is used, ""%s"" given.', __METHOD__, get_debug_type($options['options'] ?? null)));        }        return filter_var($value, $filter, $options);    }    /**     * Returns an iterator for parameters.     *     * @return \ArrayIterator An \ArrayIterator instance     */    public function getIterator()    {        return new \ArrayIterator($this->parameters);    }    /**     * Returns the number of parameters.     *     * @return int The number of parameters     */    public function count()    {        return \count($this->parameters);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
30,twigphp_Twig_Compiler_9130, Adds a quoted string to the compiled code.\n\n @return $this\n,Dodaje citirani niz kompajliranom kodu,"class Environment{    public const VERSION = '3.3.3-DEV';    public const VERSION_ID = 30303;    public const MAJOR_VERSION = 3;    public const MINOR_VERSION = 3;    public const RELEASE_VERSION = 3;    public const EXTRA_VERSION = 'DEV';    private $charset;    private $loader;    private $debug;    private $autoReload;    private $cache;    private $lexer;    private $parser;    private $compiler;    private $globals = [];    private $resolvedGlobals;    private $loadedTemplates;    private $strictVariables;    private $templateClassPrefix = '__TwigTemplate_';    private $originalCache;    private $extensionSet;    private $runtimeLoaders = [];    private $runtimes = [];    private $optionsHash;    /**     * Constructor.     *     * Available options:     *     *  * debug: When set to true, it automatically set ""auto_reload"" to true as     *           well (default to false).     *     *  * charset: The charset used by the templates (default to UTF-8).     *     *  * cache: An absolute path where to store the compiled templates,     *           a \Twig\Cache\CacheInterface implementation,     *           or false to disable compilation cache (default).     *     *  * auto_reload: Whether to reload the template if the original source changed.     *                 If you don't provide the auto_reload option, it will be     *                 determined automatically based on the debug value.     *     *  * strict_variables: Whether to ignore invalid variables in templates     *                      (default to false).     *     *  * autoescape: Whether to enable auto-escaping (default to html):     *                  * false: disable auto-escaping     *                  * html, js: set the autoescaping to one of the supported strategies     *                  * name: set the autoescaping strategy based on the template name extension     *                  * PHP callback: a PHP callback that returns an escaping strategy based on the template ""name""     *     *  * optimizations: A flag that indicates which optimizations to apply     *                   (default to -1 which means that all optimizations are enabled;     *                   set it to 0 to disable).     */    public function __construct(LoaderInterface $loader, $options = [])    {        $this->setLoader($loader);        $options = array_merge([            'debug' => false,            'charset' => 'UTF-8',            'strict_variables' => false,            'autoescape' => 'html',            'cache' => false,            'auto_reload' => null,            'optimizations' => -1,        ], $options);        $this->debug = (bool) $options['debug'];        $this->setCharset($options['charset'] ?? 'UTF-8');        $this->autoReload = null === $options['auto_reload'] ? $this->debug : (bool) $options['auto_reload'];        $this->strictVariables = (bool) $options['strict_variables'];        $this->setCache($options['cache']);        $this->extensionSet = new ExtensionSet();        $this->addExtension(new CoreExtension());        $this->addExtension(new EscaperExtension($options['autoescape']));        $this->addExtension(new OptimizerExtension($options['optimizations']));    }    /**     * Enables debugging mode.     */    public function enableDebug()    {        $this->debug = true;        $this->updateOptionsHash();    }    /**     * Disables debugging mode.     */    public function disableDebug()    {        $this->debug = false;        $this->updateOptionsHash();    }    /**     * Checks if debug mode is enabled.     *     * @return bool true if debug mode is enabled, false otherwise     */    public function isDebug()    {        return $this->debug;    }    /**     * Enables the auto_reload option.     */    public function enableAutoReload()    {        $this->autoReload = true;    }    /**     * Disables the auto_reload option.     */    public function disableAutoReload()    {        $this->autoReload = false;    }    /**     * Checks if the auto_reload option is enabled.     *     * @return bool true if auto_reload is enabled, false otherwise     */    public function isAutoReload()    {        return $this->autoReload;    }    /**     * Enables the strict_variables option.     */    public function enableStrictVariables()    {        $this->strictVariables = true;        $this->updateOptionsHash();    }    /**     * Disables the strict_variables option.     */    public function disableStrictVariables()    {        $this->strictVariables = false;        $this->updateOptionsHash();    }    /**     * Checks if the strict_variables option is enabled.     *     * @return bool true if strict_variables is enabled, false otherwise     */    public function isStrictVariables()    {        return $this->strictVariables;    }    /**     * Gets the current cache implementation.     *     * @param bool $original Whether to return the original cache option or the real cache instance     *     * @return CacheInterface|string|false A Twig\Cache\CacheInterface implementation,     *                                     an absolute path to the compiled templates,     *                                     or false to disable cache     */    public function getCache($original = true)    {        return $original ? $this->originalCache : $this->cache;    }    /**     * Sets the current cache implementation.     *     * @param CacheInterface|string|false $cache A Twig\Cache\CacheInterface implementation,     *                                           an absolute path to the compiled templates,     *                                           or false to disable cache     */    public function setCache($cache)    {        if (\is_string($cache)) {            $this->originalCache = $cache;            $this->cache = new FilesystemCache($cache);        } elseif (false === $cache) {            $this->originalCache = $cache;            $this->cache = new NullCache();        } elseif ($cache instanceof CacheInterface) {            $this->originalCache = $this->cache = $cache;        } else {            throw new \LogicException('Cache can only be a string, false, or a \Twig\Cache\CacheInterface implementation.');        }    }    /**     * Gets the template class associated with the given string.     *     * The generated template class is based on the following parameters:     *     *  * The cache key for the given template;     *  * The currently enabled extensions;     *  * Whether the Twig C extension is available or not;     *  * PHP version;     *  * Twig version;     *  * Options with what environment was created.     *     * @param string   $name  The name for which to calculate the template class name     * @param int|null $index The index if it is an embedded template     *     * @internal     */    public function getTemplateClass(string $name, int $index = null): string    {        $key = $this->getLoader()->getCacheKey($name).$this->optionsHash;        return $this->templateClassPrefix.hash('sha256', $key).(null === $index ? '' : '___'.$index);    }    /**     * Renders a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws SyntaxError  When an error occurred during compilation     * @throws RuntimeError When an error occurred during rendering     */    public function render($name, array $context = []): string    {        return $this->load($name)->render($context);    }    /**     * Displays a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws SyntaxError  When an error occurred during compilation     * @throws RuntimeError When an error occurred during rendering     */    public function display($name, array $context = []): void    {        $this->load($name)->display($context);    }    /**     * Loads a template.     *     * @param string|TemplateWrapper $name The template name     *     * @throws LoaderError  When the template cannot be found     * @throws RuntimeError When a previously generated cache is corrupted     * @throws SyntaxError  When an error occurred during compilation     */    public function load($name): TemplateWrapper    {        if ($name instanceof TemplateWrapper) {            return $name;        }        return new TemplateWrapper($this, $this->loadTemplate($this->getTemplateClass($name), $name));    }    /**     * Loads a template internal representation.     *     * This method is for internal use only and should never be called     * directly.     *     * @param string $name  The template name     * @param int    $index The index if it is an embedded template     *     * @throws LoaderError  When the template cannot be found     * @throws RuntimeError When a previously generated cache is corrupted     * @throws SyntaxError  When an error occurred during compilation     *     * @internal     */    public function loadTemplate(string $cls, string $name, int $index = null): Template    {        $mainCls = $cls;        if (null !== $index) {            $cls .= '___'.$index;        }        if (isset($this->loadedTemplates[$cls])) {            return $this->loadedTemplates[$cls];        }        if (!class_exists($cls, false)) {            $key = $this->cache->generateKey($name, $mainCls);            if (!$this->isAutoReload() || $this->isTemplateFresh($name, $this->cache->getTimestamp($key))) {                $this->cache->load($key);            }            $source = null;            if (!class_exists($cls, false)) {                $source = $this->getLoader()->getSourceContext($name);                $content = $this->compileSource($source);                $this->cache->write($key, $content);                $this->cache->load($key);                if (!class_exists($mainCls, false)) {                    /* Last line of defense if either $this->bcWriteCacheFile was used,                     * $this->cache is implemented as a no-op or we have a race condition                     * where the cache was cleared between the above calls to write to and load from                     * the cache.                     */                    eval('?>'.$content);                }                if (!class_exists($cls, false)) {                    throw new RuntimeError(sprintf('Failed to load Twig template ""%s"", index ""%s"": cache might be corrupted.', $name, $index), -1, $source);                }            }        }        $this->extensionSet->initRuntime();        return $this->loadedTemplates[$cls] = new $cls($this);    }    /**     * Creates a template from source.     *     * This method should not be used as a generic way to load templates.     *     * @param string $template The template source     * @param string $name     An optional name of the template to be used in error messages     *     * @throws LoaderError When the template cannot be found     * @throws SyntaxError When an error occurred during compilation     */    public function createTemplate(string $template, string $name = null): TemplateWrapper    {        $hash = hash('sha256', $template, false);        if (null !== $name) {            $name = sprintf('%s (string template %s)', $name, $hash);        } else {            $name = sprintf('__string_template__%s', $hash);        }        $loader = new ChainLoader([            new ArrayLoader([$name => $template]),            $current = $this->getLoader(),        ]);        $this->setLoader($loader);        try {            return new TemplateWrapper($this, $this->loadTemplate($this->getTemplateClass($name), $name));        } finally {            $this->setLoader($current);        }    }    /**     * Returns true if the template is still fresh.     *     * Besides checking the loader for freshness information,     * this method also checks if the enabled extensions have     * not changed.     *     * @param int $time The last modification time of the cached template     */    public function isTemplateFresh(string $name, int $time): bool    {        return $this->extensionSet->getLastModified() <= $time && $this->getLoader()->isFresh($name, $time);    }    /**     * Tries to load a template consecutively from an array.     *     * Similar to load() but it also accepts instances of \Twig\Template and     * \Twig\TemplateWrapper, and an array of templates where each is tried to be loaded.     *     * @param string|TemplateWrapper|array $names A template or an array of templates to try consecutively     *     * @throws LoaderError When none of the templates can be found     * @throws SyntaxError When an error occurred during compilation     */    public function resolveTemplate($names): TemplateWrapper    {        if (!\is_array($names)) {            return $this->load($names);        }        foreach ($names as $name) {            try {                return $this->load($name);            } catch (LoaderError $e) {            }        }        throw new LoaderError(sprintf('Unable to find one of the following templates: ""%s"".', implode('"", ""', $names)));    }    public function setLexer(Lexer $lexer)    {        $this->lexer = $lexer;    }    /**     * @throws SyntaxError When the code is syntactically wrong     */    public function tokenize(Source $source): TokenStream    {        if (null === $this->lexer) {            $this->lexer = new Lexer($this);        }        return $this->lexer->tokenize($source);    }    public function setParser(Parser $parser)    {        $this->parser = $parser;    }    /**     * Converts a token stream to a node tree.     *     * @throws SyntaxError When the token stream is syntactically or semantically wrong     */    public function parse(TokenStream $stream): ModuleNode    {        if (null === $this->parser) {            $this->parser = new Parser($this);        }        return $this->parser->parse($stream);    }    public function setCompiler(Compiler $compiler)    {        $this->compiler = $compiler;    }    /**     * Compiles a node and returns the PHP code.     */    public function compile(Node $node): string    {        if (null === $this->compiler) {            $this->compiler = new Compiler($this);        }        return $this->compiler->compile($node)->getSource();    }    /**     * Compiles a template source code.     *     * @throws SyntaxError When there was an error during tokenizing, parsing or compiling     */    public function compileSource(Source $source): string    {        try {            return $this->compile($this->parse($this->tokenize($source)));        } catch (Error $e) {            $e->setSourceContext($source);            throw $e;        } catch (\Exception $e) {            throw new SyntaxError(sprintf('An exception has been thrown during the compilation of a template (""%s"").', $e->getMessage()), -1, $source, $e);        }    }    public function setLoader(LoaderInterface $loader)    {        $this->loader = $loader;    }    public function getLoader(): LoaderInterface    {        return $this->loader;    }    public function setCharset(string $charset)    {        if ('UTF8' === $charset = null === $charset ? null : strtoupper($charset)) {            // iconv on Windows requires ""UTF-8"" instead of ""UTF8""            $charset = 'UTF-8';        }        $this->charset = $charset;    }    public function getCharset(): string    {        return $this->charset;    }    public function hasExtension(string $class): bool    {        return $this->extensionSet->hasExtension($class);    }    public function addRuntimeLoader(RuntimeLoaderInterface $loader)    {        $this->runtimeLoaders[] = $loader;    }    public function getExtension(string $class): ExtensionInterface    {        return $this->extensionSet->getExtension($class);    }    /**     * Returns the runtime implementation of a Twig element (filter/function/tag/test).     *     * @param string $class A runtime class name     *     * @return object The runtime implementation     *     * @throws RuntimeError When the template cannot be found     */    public function getRuntime(string $class)    {        if (isset($this->runtimes[$class])) {            return $this->runtimes[$class];        }        foreach ($this->runtimeLoaders as $loader) {            if (null !== $runtime = $loader->load($class)) {                return $this->runtimes[$class] = $runtime;            }        }        throw new RuntimeError(sprintf('Unable to load the ""%s"" runtime.', $class));    }    public function addExtension(ExtensionInterface $extension)    {        $this->extensionSet->addExtension($extension);        $this->updateOptionsHash();    }    /**     * @param ExtensionInterface[] $extensions An array of extensions     */    public function setExtensions(array $extensions)    {        $this->extensionSet->setExtensions($extensions);        $this->updateOptionsHash();    }    /**     * @return ExtensionInterface[] An array of extensions (keys are for internal usage only and should not be relied on)     */    public function getExtensions(): array    {        return $this->extensionSet->getExtensions();    }    public function addTokenParser(TokenParserInterface $parser)    {        $this->extensionSet->addTokenParser($parser);    }    /**     * @return TokenParserInterface[]     *     * @internal     */    public function getTokenParsers(): array    {        return $this->extensionSet->getTokenParsers();    }    /**     * @internal     */    public function getTokenParser(string $name): ?TokenParserInterface    {        return $this->extensionSet->getTokenParser($name);    }    public function registerUndefinedTokenParserCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedTokenParserCallback($callable);    }    public function addNodeVisitor(NodeVisitorInterface $visitor)    {        $this->extensionSet->addNodeVisitor($visitor);    }    /**     * @return NodeVisitorInterface[]     *     * @internal     */    public function getNodeVisitors(): array    {        return $this->extensionSet->getNodeVisitors();    }    public function addFilter(TwigFilter $filter)    {        $this->extensionSet->addFilter($filter);    }    /**     * @internal     */    public function getFilter(string $name): ?TwigFilter    {        return $this->extensionSet->getFilter($name);    }    public function registerUndefinedFilterCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedFilterCallback($callable);    }    /**     * Gets the registered Filters.     *     * Be warned that this method cannot return filters defined with registerUndefinedFilterCallback.     *     * @return TwigFilter[]     *     * @see registerUndefinedFilterCallback     *     * @internal     */    public function getFilters(): array    {        return $this->extensionSet->getFilters();    }    public function addTest(TwigTest $test)    {        $this->extensionSet->addTest($test);    }    /**     * @return TwigTest[]     *     * @internal     */    public function getTests(): array    {        return $this->extensionSet->getTests();    }    /**     * @internal     */    public function getTest(string $name): ?TwigTest    {        return $this->extensionSet->getTest($name);    }    public function addFunction(TwigFunction $function)    {        $this->extensionSet->addFunction($function);    }    /**     * @internal     */    public function getFunction(string $name): ?TwigFunction    {        return $this->extensionSet->getFunction($name);    }    public function registerUndefinedFunctionCallback(callable $callable): void    {        $this->extensionSet->registerUndefinedFunctionCallback($callable);    }    /**     * Gets registered functions.     *     * Be warned that this method cannot return functions defined with registerUndefinedFunctionCallback.     *     * @return TwigFunction[]     *     * @see registerUndefinedFunctionCallback     *     * @internal     */    public function getFunctions(): array    {        return $this->extensionSet->getFunctions();    }    /**     * Registers a Global.     *     * New globals can be added before compiling or rendering a template;     * but after, you can only update existing globals.     *     * @param mixed $value The global value     */    public function addGlobal(string $name, $value)    {        if ($this->extensionSet->isInitialized() && !\array_key_exists($name, $this->getGlobals())) {            throw new \LogicException(sprintf('Unable to add global ""%s"" as the runtime or the extensions have already been initialized.', $name));        }        if (null !== $this->resolvedGlobals) {            $this->resolvedGlobals[$name] = $value;        } else {            $this->globals[$name] = $value;        }    }    /**     * @internal     */    public function getGlobals(): array    {        if ($this->extensionSet->isInitialized()) {            if (null === $this->resolvedGlobals) {                $this->resolvedGlobals = array_merge($this->extensionSet->getGlobals(), $this->globals);            }            return $this->resolvedGlobals;        }        return array_merge($this->extensionSet->getGlobals(), $this->globals);    }    public function mergeGlobals(array $context): array    {        // we don't use array_merge as the context being generally        // bigger than globals, this code is faster.        foreach ($this->getGlobals() as $key => $value) {            if (!\array_key_exists($key, $context)) {                $context[$key] = $value;            }        }        return $context;    }    /**     * @internal     */    public function getUnaryOperators(): array    {        return $this->extensionSet->getUnaryOperators();    }    /**     * @internal     */    public function getBinaryOperators(): array    {        return $this->extensionSet->getBinaryOperators();    }    private function updateOptionsHash(): void    {        $this->optionsHash = implode(':', [            $this->extensionSet->getSignature(),            \PHP_MAJOR_VERSION,            \PHP_MINOR_VERSION,            self::VERSION,            (int) $this->debug,            (int) $this->strictVariables,        ]);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
31,Sylius_Sylius_LaminasPriorityQueueStub_1197, Does the queue have an item with the given priority?\n\n @param  int $priority\n @return bool\n,Da li red ima stavku sa datim prioritetom?,    public function hasPriority($priority)    {        foreach ($this->items as $item) {            if ($item['priority'] === $priority) {                return true;            }        }        return false;    },0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
32,guzzle_promises_FulfilledPromise_710, A promise that has been fulfilled.\\\\\\\\n\\\\\\\\n Thenning off of this promise will invoke the onFulfilled callback\\\\\\\\n immediately and ignore other callbacks.\\\\\\\\n,Obećanje koje je ispunjeno. Isključivanje ovog obećanja odmah će pozvati onFulfished povratni poziv i zanemariti druge povratne pozive,"class FulfilledPromise implements PromiseInterface{    private $value;    public function __construct($value)    {        if (is_object($value) && method_exists($value, 'then')) {            throw new \InvalidArgumentException(                'You cannot create a FulfilledPromise with a promise.'            );        }        $this->value = $value;    }    public function then(        callable $onFulfilled = null,        callable $onRejected = null    ) {        // Return itself if there is no onFulfilled function.        if (!$onFulfilled) {            return $this;        }        $queue = Utils::queue();        $p = new Promise([$queue, 'run']);        $value = $this->value;        $queue->add(static function () use ($p, $value, $onFulfilled) {            if (Is::pending($p)) {                try {                    $p->resolve($onFulfilled($value));                } catch (\Throwable $e) {                    $p->reject($e);                } catch (\Exception $e) {                    $p->reject($e);                }            }        });        return $p;    }    public function otherwise(callable $onRejected)    {        return $this->then(null, $onRejected);    }    public function wait($unwrap = true, $defaultDelivery = null)    {        return $unwrap ? $this->value : null;    }    public function getState()    {        return self::FULFILLED;    }    public function resolve($value)    {        if ($value !== $this->value) {            throw new \LogicException(""Cannot resolve a fulfilled promise"");        }    }    public function reject($reason)    {        throw new \LogicException(""Cannot reject a fulfilled promise"");    }    public function cancel()    {        // pass    }}",0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
33,laravel_laravel_2019_08_19_000000_create_failed_jobs_table_13, Run the migrations.\\n\\n @return void\\n,Pokretanje migracija,"    public function up()    {        Schema::create('failed_jobs', function (Blueprint $table) {            $table->id();            $table->string('uuid')->unique();            $table->text('connection');            $table->text('queue');            $table->longText('payload');            $table->longText('exception');            $table->timestamp('failed_at')->useCurrent();        });    }",0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
34,symfony_var-dumper_AbstractDumper_9251, Abstract mechanism for dumping a Data object.\n\n @author Nicolas Grekas <p@tchwork.com>\n,Apstraktni mehanizam za odbacivanje objekta podataka,"class AmqpCaster{    private const FLAGS = [        \AMQP_DURABLE => 'AMQP_DURABLE',        \AMQP_PASSIVE => 'AMQP_PASSIVE',        \AMQP_EXCLUSIVE => 'AMQP_EXCLUSIVE',        \AMQP_AUTODELETE => 'AMQP_AUTODELETE',        \AMQP_INTERNAL => 'AMQP_INTERNAL',        \AMQP_NOLOCAL => 'AMQP_NOLOCAL',        \AMQP_AUTOACK => 'AMQP_AUTOACK',        \AMQP_IFEMPTY => 'AMQP_IFEMPTY',        \AMQP_IFUNUSED => 'AMQP_IFUNUSED',        \AMQP_MANDATORY => 'AMQP_MANDATORY',        \AMQP_IMMEDIATE => 'AMQP_IMMEDIATE',        \AMQP_MULTIPLE => 'AMQP_MULTIPLE',        \AMQP_NOWAIT => 'AMQP_NOWAIT',        \AMQP_REQUEUE => 'AMQP_REQUEUE',    ];    private const EXCHANGE_TYPES = [        \AMQP_EX_TYPE_DIRECT => 'AMQP_EX_TYPE_DIRECT',        \AMQP_EX_TYPE_FANOUT => 'AMQP_EX_TYPE_FANOUT',        \AMQP_EX_TYPE_TOPIC => 'AMQP_EX_TYPE_TOPIC',        \AMQP_EX_TYPE_HEADERS => 'AMQP_EX_TYPE_HEADERS',    ];    public static function castConnection(\AMQPConnection $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'is_connected' => $c->isConnected(),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPConnection\x00login""])) {            return $a;        }        // BC layer in the amqp lib        if (method_exists($c, 'getReadTimeout')) {            $timeout = $c->getReadTimeout();        } else {            $timeout = $c->getTimeout();        }        $a += [            $prefix.'is_connected' => $c->isConnected(),            $prefix.'login' => $c->getLogin(),            $prefix.'password' => $c->getPassword(),            $prefix.'host' => $c->getHost(),            $prefix.'vhost' => $c->getVhost(),            $prefix.'port' => $c->getPort(),            $prefix.'read_timeout' => $timeout,        ];        return $a;    }    public static function castChannel(\AMQPChannel $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'is_connected' => $c->isConnected(),            $prefix.'channel_id' => $c->getChannelId(),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPChannel\x00connection""])) {            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'prefetch_size' => $c->getPrefetchSize(),            $prefix.'prefetch_count' => $c->getPrefetchCount(),        ];        return $a;    }    public static function castQueue(\AMQPQueue $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'flags' => self::extractFlags($c->getFlags()),        ];        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPQueue\x00name""])) {            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'channel' => $c->getChannel(),            $prefix.'name' => $c->getName(),            $prefix.'arguments' => $c->getArguments(),        ];        return $a;    }    public static function castExchange(\AMQPExchange $c, array $a, Stub $stub, bool $isNested)    {        $prefix = Caster::PREFIX_VIRTUAL;        $a += [            $prefix.'flags' => self::extractFlags($c->getFlags()),        ];        $type = isset(self::EXCHANGE_TYPES[$c->getType()]) ? new ConstStub(self::EXCHANGE_TYPES[$c->getType()], $c->getType()) : $c->getType();        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPExchange\x00name""])) {            $a[""\x00AMQPExchange\x00type""] = $type;            return $a;        }        $a += [            $prefix.'connection' => $c->getConnection(),            $prefix.'channel' => $c->getChannel(),            $prefix.'name' => $c->getName(),            $prefix.'type' => $type,            $prefix.'arguments' => $c->getArguments(),        ];        return $a;    }    public static function castEnvelope(\AMQPEnvelope $c, array $a, Stub $stub, bool $isNested, int $filter = 0)    {        $prefix = Caster::PREFIX_VIRTUAL;        $deliveryMode = new ConstStub($c->getDeliveryMode().(2 === $c->getDeliveryMode() ? ' (persistent)' : ' (non-persistent)'), $c->getDeliveryMode());        // Recent version of the extension already expose private properties        if (isset($a[""\x00AMQPEnvelope\x00body""])) {            $a[""\0AMQPEnvelope\0delivery_mode""] = $deliveryMode;            return $a;        }        if (!($filter & Caster::EXCLUDE_VERBOSE)) {            $a += [$prefix.'body' => $c->getBody()];        }        $a += [            $prefix.'delivery_tag' => $c->getDeliveryTag(),            $prefix.'is_redelivery' => $c->isRedelivery(),            $prefix.'exchange_name' => $c->getExchangeName(),            $prefix.'routing_key' => $c->getRoutingKey(),            $prefix.'content_type' => $c->getContentType(),            $prefix.'content_encoding' => $c->getContentEncoding(),            $prefix.'headers' => $c->getHeaders(),            $prefix.'delivery_mode' => $deliveryMode,            $prefix.'priority' => $c->getPriority(),            $prefix.'correlation_id' => $c->getCorrelationId(),            $prefix.'reply_to' => $c->getReplyTo(),            $prefix.'expiration' => $c->getExpiration(),            $prefix.'message_id' => $c->getMessageId(),            $prefix.'timestamp' => $c->getTimeStamp(),            $prefix.'type' => $c->getType(),            $prefix.'user_id' => $c->getUserId(),            $prefix.'app_id' => $c->getAppId(),        ];        return $a;    }    private static function extractFlags(int $flags): ConstStub    {        $flagsArray = [];        foreach (self::FLAGS as $value => $name) {            if ($flags & $value) {                $flagsArray[] = $name;            }        }        if (!$flagsArray) {            $flagsArray = ['AMQP_NOPARAM'];        }        return new ConstStub(implode('|', $flagsArray), $flags);    }}",0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
35,walkor_Workerman_Worker_7002, Write statistics data to disk.\n\n @return void\n,Zapisuje statističke podatke na disk,"    protected static function writeConnectionsStatisticsToStatusFile()    {        // For master process.        if (static::$_masterPid === \posix_getpid()) {            \file_put_contents(static::$_statisticsFile, ""--------------------------------------------------------------------- WORKERMAN CONNECTION STATUS --------------------------------------------------------------------------------\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile, ""PID      Worker          CID       Trans   Protocol        ipv4   ipv6   Recv-Q       Send-Q       Bytes-R      Bytes-W       Status         Local Address          Foreign Address\n"", \FILE_APPEND);            \chmod(static::$_statisticsFile, 0722);            foreach (static::getAllWorkerPids() as $worker_pid) {                \posix_kill($worker_pid, \SIGIO);            }            return;        }        // For child processes.        $bytes_format = function($bytes)        {            if($bytes > 1024*1024*1024*1024) {                return round($bytes/(1024*1024*1024*1024), 1).""TB"";            }            if($bytes > 1024*1024*1024) {                return round($bytes/(1024*1024*1024), 1).""GB"";            }            if($bytes > 1024*1024) {                return round($bytes/(1024*1024), 1).""MB"";            }            if($bytes > 1024) {                return round($bytes/(1024), 1).""KB"";            }            return $bytes.""B"";        };        $pid = \posix_getpid();        $str = '';        \reset(static::$_workers);        $current_worker = current(static::$_workers);        $default_worker_name = $current_worker->name;        /** @var \Workerman\Worker $worker */        foreach(TcpConnection::$connections as $connection) {            /** @var \Workerman\Connection\TcpConnection $connection */            $transport      = $connection->transport;            $ipv4           = $connection->isIpV4() ? ' 1' : ' 0';            $ipv6           = $connection->isIpV6() ? ' 1' : ' 0';            $recv_q         = $bytes_format($connection->getRecvBufferQueueSize());            $send_q         = $bytes_format($connection->getSendBufferQueueSize());            $local_address  = \trim($connection->getLocalAddress());            $remote_address = \trim($connection->getRemoteAddress());            $state          = $connection->getStatus(false);            $bytes_read     = $bytes_format($connection->bytesRead);            $bytes_written  = $bytes_format($connection->bytesWritten);            $id             = $connection->id;            $protocol       = $connection->protocol ? $connection->protocol : $connection->transport;            $pos            = \strrpos($protocol, '\\');            if ($pos) {                $protocol = \substr($protocol, $pos+1);            }            if (\strlen($protocol) > 15) {                $protocol = \substr($protocol, 0, 13) . '..';            }            $worker_name = isset($connection->worker) ? $connection->worker->name : $default_worker_name;            if (\strlen($worker_name) > 14) {                $worker_name = \substr($worker_name, 0, 12) . '..';            }            $str .= \str_pad($pid, 9) . \str_pad($worker_name, 16) .  \str_pad($id, 10) . \str_pad($transport, 8)                . \str_pad($protocol, 16) . \str_pad($ipv4, 7) . \str_pad($ipv6, 7) . \str_pad($recv_q, 13)                . \str_pad($send_q, 13) . \str_pad($bytes_read, 13) . \str_pad($bytes_written, 13) . ' '                . \str_pad($state, 14) . ' ' . \str_pad($local_address, 22) . ' ' . \str_pad($remote_address, 22) .""\n"";        }        if ($str) {            \file_put_contents(static::$_statisticsFile, $str, \FILE_APPEND);        }    }",0.0,0.0,2.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
36,walkor_Workerman_Worker_7372, check if child processes is really running\n,Proverite da li se podređeni procesi zaista izvode,"    protected static function writeConnectionsStatisticsToStatusFile()    {        // For master process.        if (static::$_masterPid === \posix_getpid()) {            \file_put_contents(static::$_statisticsFile, ""--------------------------------------------------------------------- WORKERMAN CONNECTION STATUS --------------------------------------------------------------------------------\n"", \FILE_APPEND);            \file_put_contents(static::$_statisticsFile, ""PID      Worker          CID       Trans   Protocol        ipv4   ipv6   Recv-Q       Send-Q       Bytes-R      Bytes-W       Status         Local Address          Foreign Address\n"", \FILE_APPEND);            \chmod(static::$_statisticsFile, 0722);            foreach (static::getAllWorkerPids() as $worker_pid) {                \posix_kill($worker_pid, \SIGIO);            }            return;        }        // For child processes.        $bytes_format = function($bytes)        {            if($bytes > 1024*1024*1024*1024) {                return round($bytes/(1024*1024*1024*1024), 1).""TB"";            }            if($bytes > 1024*1024*1024) {                return round($bytes/(1024*1024*1024), 1).""GB"";            }            if($bytes > 1024*1024) {                return round($bytes/(1024*1024), 1).""MB"";            }            if($bytes > 1024) {                return round($bytes/(1024), 1).""KB"";            }            return $bytes.""B"";        };        $pid = \posix_getpid();        $str = '';        \reset(static::$_workers);        $current_worker = current(static::$_workers);        $default_worker_name = $current_worker->name;        /** @var \Workerman\Worker $worker */        foreach(TcpConnection::$connections as $connection) {            /** @var \Workerman\Connection\TcpConnection $connection */            $transport      = $connection->transport;            $ipv4           = $connection->isIpV4() ? ' 1' : ' 0';            $ipv6           = $connection->isIpV6() ? ' 1' : ' 0';            $recv_q         = $bytes_format($connection->getRecvBufferQueueSize());            $send_q         = $bytes_format($connection->getSendBufferQueueSize());            $local_address  = \trim($connection->getLocalAddress());            $remote_address = \trim($connection->getRemoteAddress());            $state          = $connection->getStatus(false);            $bytes_read     = $bytes_format($connection->bytesRead);            $bytes_written  = $bytes_format($connection->bytesWritten);            $id             = $connection->id;            $protocol       = $connection->protocol ? $connection->protocol : $connection->transport;            $pos            = \strrpos($protocol, '\\');            if ($pos) {                $protocol = \substr($protocol, $pos+1);            }            if (\strlen($protocol) > 15) {                $protocol = \substr($protocol, 0, 13) . '..';            }            $worker_name = isset($connection->worker) ? $connection->worker->name : $default_worker_name;            if (\strlen($worker_name) > 14) {                $worker_name = \substr($worker_name, 0, 12) . '..';            }            $str .= \str_pad($pid, 9) . \str_pad($worker_name, 16) .  \str_pad($id, 10) . \str_pad($transport, 8)                . \str_pad($protocol, 16) . \str_pad($ipv4, 7) . \str_pad($ipv6, 7) . \str_pad($recv_q, 13)                . \str_pad($send_q, 13) . \str_pad($bytes_read, 13) . \str_pad($bytes_written, 13) . ' '                . \str_pad($state, 14) . ' ' . \str_pad($local_address, 22) . ' ' . \str_pad($remote_address, 22) .""\n"";        }        if ($str) {            \file_put_contents(static::$_statisticsFile, $str, \FILE_APPEND);        }    }",0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
37,walkor_Workerman_Worker_7771, Stop current worker instance.\n\n @return void\n,Zaustavite trenutnu radnu instancu,"class Worker{    /**     * Version.     *     * @var string     */    const VERSION = '4.0.19';    /**     * Status starting.     *     * @var int     */    const STATUS_STARTING = 1;    /**     * Status running.     *     * @var int     */    const STATUS_RUNNING = 2;    /**     * Status shutdown.     *     * @var int     */    const STATUS_SHUTDOWN = 4;    /**     * Status reloading.     *     * @var int     */    const STATUS_RELOADING = 8;    /**     * After sending the restart command to the child process KILL_WORKER_TIMER_TIME seconds,     * if the process is still living then forced to kill.     *     * @var int     */    const KILL_WORKER_TIMER_TIME = 2;    /**     * Default backlog. Backlog is the maximum length of the queue of pending connections.     *     * @var int     */    const DEFAULT_BACKLOG = 102400;    /**     * Max udp package size.     *     * @var int     */    const MAX_UDP_PACKAGE_SIZE = 65535;    /**     * The safe distance for columns adjacent     *     * @var int     */    const UI_SAFE_LENGTH = 4;    /**     * Worker id.     *     * @var int     */    public $id = 0;    /**     * Name of the worker processes.     *     * @var string     */    public $name = 'none';    /**     * Number of worker processes.     *     * @var int     */    public $count = 1;    /**     * Unix user of processes, needs appropriate privileges (usually root).     *     * @var string     */    public $user = '';    /**     * Unix group of processes, needs appropriate privileges (usually root).     *     * @var string     */    public $group = '';    /**     * reloadable.     *     * @var bool     */    public $reloadable = true;    /**     * reuse port.     *     * @var bool     */    public $reusePort = false;    /**     * Emitted when worker processes start.     *     * @var callable     */    public $onWorkerStart = null;    /**     * Emitted when a socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when data is received.     *     * @var callable     */    public $onMessage = null;    /**     * Emitted when the other end of the socket sends a FIN packet.     *     * @var callable     */    public $onClose = null;    /**     * Emitted when an error occurs with connection.     *     * @var callable     */    public $onError = null;    /**     * Emitted when the send buffer becomes full.     *     * @var callable     */    public $onBufferFull = null;    /**     * Emitted when the send buffer becomes empty.     *     * @var callable     */    public $onBufferDrain = null;    /**     * Emitted when worker processes stoped.     *     * @var callable     */    public $onWorkerStop = null;    /**     * Emitted when worker processes get reload signal.     *     * @var callable     */    public $onWorkerReload = null;    /**     * Transport layer protocol.     *     * @var string     */    public $transport = 'tcp';    /**     * Store all connections of clients.     *     * @var array     */    public $connections = array();    /**     * Application layer protocol.     *     * @var string     */    public $protocol = null;    /**     * Root path for autoload.     *     * @var string     */    protected $_autoloadRootPath = '';    /**     * Pause accept new connections or not.     *     * @var bool     */    protected $_pauseAccept = true;    /**     * Is worker stopping ?     * @var bool     */    public $stopping = false;    /**     * Daemonize.     *     * @var bool     */    public static $daemonize = false;    /**     * Stdout file.     *     * @var string     */    public static $stdoutFile = '/dev/null';    /**     * The file to store master process PID.     *     * @var string     */    public static $pidFile = '';    /**     * Log file.     *     * @var mixed     */    public static $logFile = '';    /**     * Global event loop.     *     * @var EventInterface     */    public static $globalEvent = null;    /**     * Emitted when the master process get reload signal.     *     * @var callable     */    public static $onMasterReload = null;    /**     * Emitted when the master process terminated.     *     * @var callable     */    public static $onMasterStop = null;    /**     * EventLoopClass     *     * @var string     */    public static $eventLoopClass = '';    /**     * Process title     *     * @var string     */    public static $processTitle = 'WorkerMan';    /**     * The PID of master process.     *     * @var int     */    protected static $_masterPid = 0;    /**     * Listening socket.     *     * @var resource     */    protected $_mainSocket = null;    /**     * Socket name. The format is like this http://0.0.0.0:80 .     *     * @var string     */    protected $_socketName = '';    /** parse from _socketName avoid parse again in master or worker     * LocalSocket The format is like tcp://0.0.0.0:8080     * @var string     */    protected $_localSocket=null;    /**     * Context of socket.     *     * @var resource     */    protected $_context = null;    /**     * All worker instances.     *     * @var Worker[]     */    protected static $_workers = array();    /**     * All worker processes pid.     * The format is like this [worker_id=>[pid=>pid, pid=>pid, ..], ..]     *     * @var array     */    protected static $_pidMap = array();    /**     * All worker processes waiting for restart.     * The format is like this [pid=>pid, pid=>pid].     *     * @var array     */    protected static $_pidsToRestart = array();    /**     * Mapping from PID to worker process ID.     * The format is like this [worker_id=>[0=>$pid, 1=>$pid, ..], ..].     *     * @var array     */    protected static $_idMap = array();    /**     * Current status.     *     * @var int     */    protected static $_status = self::STATUS_STARTING;    /**     * Maximum length of the worker names.     *     * @var int     */    protected static $_maxWorkerNameLength = 12;    /**     * Maximum length of the socket names.     *     * @var int     */    protected static $_maxSocketNameLength = 12;    /**     * Maximum length of the process user names.     *     * @var int     */    protected static $_maxUserNameLength = 12;    /**     * Maximum length of the Proto names.     *     * @var int     */    protected static $_maxProtoNameLength = 4;    /**     * Maximum length of the Processes names.     *     * @var int     */    protected static $_maxProcessesNameLength = 9;    /**     * Maximum length of the Status names.     *     * @var int     */    protected static $_maxStatusNameLength = 1;    /**     * The file to store status info of current worker process.     *     * @var string     */    protected static $_statisticsFile = '';    /**     * Start file.     *     * @var string     */    protected static $_startFile = '';    /**     * OS.     *     * @var string     */    protected static $_OS = \OS_TYPE_LINUX;    /**     * Processes for windows.     *     * @var array     */    protected static $_processForWindows = array();    /**     * Status info of current worker process.     *     * @var array     */    protected static $_globalStatistics = array(        'start_timestamp'  => 0,        'worker_exit_info' => array()    );    /**     * Available event loops.     *     * @var array     */    protected static $_availableEventLoops = array(        'event'    => '\Workerman\Events\Event',        'libevent' => '\Workerman\Events\Libevent'    );    /**     * PHP built-in protocols.     *     * @var array     */    protected static $_builtinTransports = array(        'tcp'   => 'tcp',        'udp'   => 'udp',        'unix'  => 'unix',        'ssl'   => 'tcp'    );    /**     * PHP built-in error types.     *     * @var array     */    protected static $_errorType = array(        \E_ERROR             => 'E_ERROR',             // 1        \E_WARNING           => 'E_WARNING',           // 2        \E_PARSE             => 'E_PARSE',             // 4        \E_NOTICE            => 'E_NOTICE',            // 8        \E_CORE_ERROR        => 'E_CORE_ERROR',        // 16        \E_CORE_WARNING      => 'E_CORE_WARNING',      // 32        \E_COMPILE_ERROR     => 'E_COMPILE_ERROR',     // 64        \E_COMPILE_WARNING   => 'E_COMPILE_WARNING',   // 128        \E_USER_ERROR        => 'E_USER_ERROR',        // 256        \E_USER_WARNING      => 'E_USER_WARNING',      // 512        \E_USER_NOTICE       => 'E_USER_NOTICE',       // 1024        \E_STRICT            => 'E_STRICT',            // 2048        \E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR', // 4096        \E_DEPRECATED        => 'E_DEPRECATED',        // 8192        \E_USER_DEPRECATED   => 'E_USER_DEPRECATED'   // 16384    );    /**     * Graceful stop or not.     *     * @var bool     */    protected static $_gracefulStop = false;    /**     * Standard output stream     * @var resource     */    protected static $_outputStream = null;    /**     * If $outputStream support decorated     * @var bool     */    protected static $_outputDecorated = null;    /**     * Run all worker instances.     *     * @return void     */    public static function runAll()    {        static::checkSapiEnv();        static::init();        static::parseCommand();        static::daemonize();        static::initWorkers();        static::installSignal();        static::saveMasterPid();        static::displayUI();        static::forkWorkers();        static::resetStd();        static::monitorWorkers();    }    /**     * Check sapi.     *     * @return void     */    protected static function checkSapiEnv()    {        // Only for cli.        if (\PHP_SAPI !== 'cli') {            exit(""Only run in command line mode \n"");        }        if (\DIRECTORY_SEPARATOR === '\\') {            self::$_OS = \OS_TYPE_WINDOWS;        }    }    /**     * Init.     *     * @return void     */    protected static function init()    {        \set_error_handler(function($code, $msg, $file, $line){            Worker::safeEcho(""$msg in file $file on line $line\n"");        });        // Start file.        $backtrace        = \debug_backtrace();        static::$_startFile = $backtrace[\count($backtrace) - 1]['file'];        $unique_prefix = \str_replace('/', '_', static::$_startFile);        // Pid file.        if (empty(static::$pidFile)) {            static::$pidFile = __DIR__ . ""/../$unique_prefix.pid"";        }        // Log file.        if (empty(static::$logFile)) {            static::$logFile = __DIR__ . '/../workerman.log';        }        $log_file = (string)static::$logFile;        if (!\is_file($log_file)) {            \touch($log_file);            \chmod($log_file, 0622);        }        // State.        static::$_status = static::STATUS_STARTING;        // For statistics.        static::$_globalStatistics['start_timestamp'] = \time();        // Process title.        static::setProcessTitle(static::$processTitle . ': master process  start_file=' . static::$_startFile);        // Init data for worker id.        static::initId();        // Timer init.        Timer::init();    }    /**     * Lock.     *     * @return void     */    protected static function lock()    {        $fd = \fopen(static::$_startFile, 'r');        if ($fd && !flock($fd, LOCK_EX)) {            static::log('Workerman['.static::$_startFile.'] already running.');            exit;        }    }    /**     * Unlock.     *     * @return void     */    protected static function unlock()    {        $fd = \fopen(static::$_startFile, 'r');        $fd && flock($fd, \LOCK_UN);    }    /**     * Init All worker instances.     *     * @return void     */    protected static function initWorkers()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        static::$_statisticsFile = __DIR__ . '/../workerman-' .posix_getpid().'.status';        foreach (static::$_workers as $worker) {            // Worker name.            if (empty($worker->name)) {                $worker->name = 'none';            }            // Get unix user of the worker process.            if (empty($worker->user)) {                $worker->user = static::getCurrentUser();            } else {                if (\posix_getuid() !== 0 && $worker->user !== static::getCurrentUser()) {                    static::log('Warning: You must have the root privileges to change uid and gid.');                }            }            // Socket name.            $worker->socket = $worker->getSocketName();            // Status name.            $worker->status = '<g> [OK] </g>';            // Get column mapping for UI            foreach(static::getUiColumns() as $column_name => $prop){                !isset($worker->{$prop}) && $worker->{$prop} = 'NNNN';                $prop_length = \strlen($worker->{$prop});                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                static::$$key = \max(static::$$key, $prop_length);            }            // Listen.            if (!$worker->reusePort) {                $worker->listen();            }        }    }    /**     * Reload all worker instances.     *     * @return void     */    public static function reloadAllWorkers()    {        static::init();        static::initWorkers();        static::displayUI();        static::$_status = static::STATUS_RELOADING;    }    /**     * Get all worker instances.     *     * @return array     */    public static function getAllWorkers()    {        return static::$_workers;    }    /**     * Get global event-loop instance.     *     * @return EventInterface     */    public static function getEventLoop()    {        return static::$globalEvent;    }    /**     * Get main socket resource     * @return resource     */    public function getMainSocket(){        return $this->_mainSocket;    }    /**     * Init idMap.     * return void     */    protected static function initId()    {        foreach (static::$_workers as $worker_id => $worker) {            $new_id_map = array();            $worker->count = $worker->count < 1 ? 1 : $worker->count;            for($key = 0; $key < $worker->count; $key++) {                $new_id_map[$key] = isset(static::$_idMap[$worker_id][$key]) ? static::$_idMap[$worker_id][$key] : 0;            }            static::$_idMap[$worker_id] = $new_id_map;        }    }    /**     * Get unix user of current porcess.     *     * @return string     */    protected static function getCurrentUser()    {        $user_info = \posix_getpwuid(\posix_getuid());        return $user_info['name'];    }    /**     * Display staring UI.     *     * @return void     */    protected static function displayUI()    {        global $argv;        if (\in_array('-q', $argv)) {            return;        }        if (static::$_OS !== \OS_TYPE_LINUX) {            static::safeEcho(""----------------------- WORKERMAN -----------------------------\r\n"");            static::safeEcho('Workerman version:'. static::VERSION. '          PHP version:'. \PHP_VERSION. ""\r\n"");            static::safeEcho(""------------------------ WORKERS -------------------------------\r\n"");            static::safeEcho(""worker               listen                              processes status\r\n"");            return;        }        //show version        $line_version = 'Workerman version:' . static::VERSION . \str_pad('PHP version:', 22, ' ', \STR_PAD_LEFT) . \PHP_VERSION . \PHP_EOL;        !\defined('LINE_VERSIOIN_LENGTH') && \define('LINE_VERSIOIN_LENGTH', \strlen($line_version));        $total_length = static::getSingleLineTotalLength();        $line_one = '<n>' . \str_pad('<w> WORKERMAN </w>', $total_length + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . '</n>'. \PHP_EOL;        $line_two = \str_pad('<w> WORKERS </w>' , $total_length  + \strlen('<w></w>'), '-', \STR_PAD_BOTH) . \PHP_EOL;        static::safeEcho($line_one . $line_version . $line_two);        //Show title        $title = '';        foreach(static::getUiColumns() as $column_name => $prop){            $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';            //just keep compatible with listen name            $column_name === 'socket' && $column_name = 'listen';            $title.= ""<w>{$column_name}</w>""  .  \str_pad('', static::$$key + static::UI_SAFE_LENGTH - \strlen($column_name));        }        $title && static::safeEcho($title . \PHP_EOL);        //Show content        foreach (static::$_workers as $worker) {            $content = '';            foreach(static::getUiColumns() as $column_name => $prop){                $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';                \preg_match_all(""/(<n>|<\/n>|<w>|<\/w>|<g>|<\/g>)/is"", $worker->{$prop}, $matches);                $place_holder_length = !empty($matches) ? \strlen(\implode('', $matches[0])) : 0;                $content .= \str_pad($worker->{$prop}, static::$$key + static::UI_SAFE_LENGTH + $place_holder_length);            }            $content && static::safeEcho($content . \PHP_EOL);        }        //Show last line        $line_last = \str_pad('', static::getSingleLineTotalLength(), '-') . \PHP_EOL;        !empty($content) && static::safeEcho($line_last);        if (static::$daemonize) {            foreach ($argv as $index => $value) {                if ($value == '-d') {                    unset($argv[$index]);                } elseif ($value == 'start' || $value == 'restart') {                    $argv[$index] = 'stop';                }            }            static::safeEcho(""Input \""php "".implode(' ', $argv).""\"" to stop. Start success.\n\n"");        } else {            static::safeEcho(""Press Ctrl+C to stop. Start success.\n"");        }    }    /**     * Get UI columns to be shown in terminal     *     * 1. $column_map: array('ui_column_name' => 'clas_property_name')     * 2. Consider move into configuration in future     *     * @return array     */    public static function getUiColumns()    {        return array(            'proto'     =>  'transport',            'user'      =>  'user',            'worker'    =>  'name',            'socket'    =>  'socket',            'processes' =>  'count',            'status'    =>  'status',        );    }    /**     * Get single line total length for ui     *     * @return int     */    public static function getSingleLineTotalLength()    {        $total_length = 0;        foreach(static::getUiColumns() as $column_name => $prop){            $key = '_max' . \ucfirst(\strtolower($column_name)) . 'NameLength';            $total_length += static::$$key + static::UI_SAFE_LENGTH;        }        //keep beauty when show less colums        !\defined('LINE_VERSIOIN_LENGTH') && \define('LINE_VERSIOIN_LENGTH', 0);        $total_length <= LINE_VERSIOIN_LENGTH && $total_length = LINE_VERSIOIN_LENGTH;        return $total_length;    }    /**     * Parse command.     *     * @return void     */    protected static function parseCommand()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        global $argv;        // Check argv;        $start_file = $argv[0];        $usage = ""Usage: php yourfile <command> [mode]\nCommands: \nstart\t\tStart worker in DEBUG mode.\n\t\tUse mode -d to start in DAEMON mode.\nstop\t\tStop worker.\n\t\tUse mode -g to stop gracefully.\nrestart\t\tRestart workers.\n\t\tUse mode -d to start in DAEMON mode.\n\t\tUse mode -g to stop gracefully.\nreload\t\tReload codes.\n\t\tUse mode -g to reload gracefully.\nstatus\t\tGet worker status.\n\t\tUse mode -d to show live status.\nconnections\tGet worker connections.\n"";        $available_commands = array(            'start',            'stop',            'restart',            'reload',            'status',            'connections',        );        $available_mode = array(            '-d',            '-g'        );        $command = $mode = '';        foreach ($argv as $value) {            if (\in_array($value, $available_commands)) {                $command = $value;            } elseif (\in_array($value, $available_mode)) {                $mode = $value;            }        }        if (!$command) {            exit($usage);        }        // Start command.        $mode_str = '';        if ($command === 'start') {            if ($mode === '-d' || static::$daemonize) {                $mode_str = 'in DAEMON mode';            } else {                $mode_str = 'in DEBUG mode';            }        }        static::log(""Workerman[$start_file] $command $mode_str"");        // Get master process PID.        $master_pid      = \is_file(static::$pidFile) ? (int)\file_get_contents(static::$pidFile) : 0;        // Master is still alive?        if (static::checkMasterIsAlive($master_pid)) {            if ($command === 'start') {                static::log(""Workerman[$start_file] already running"");                exit;            }        } elseif ($command !== 'start' && $command !== 'restart') {            static::log(""Workerman[$start_file] not run"");            exit;        }        $statistics_file =  __DIR__ . ""/../workerman-$master_pid.status"";        // execute command.        switch ($command) {            case 'start':                if ($mode === '-d') {                    static::$daemonize = true;                }                break;            case 'status':                while (1) {                    if (\is_file($statistics_file)) {                        @\unlink($statistics_file);                    }                    // Master process will send SIGUSR2 signal to all child processes.                    \posix_kill($master_pid, SIGUSR2);                    // Sleep 1 second.                    \sleep(1);                    // Clear terminal.                    if ($mode === '-d') {                        static::safeEcho(""\33[H\33[2J\33(B\33[m"", true);                    }                    // Echo status data.                    static::safeEcho(static::formatStatusData($statistics_file));                    if ($mode !== '-d') {                        exit(0);                    }                    static::safeEcho(""\nPress Ctrl+C to quit.\n\n"");                }                exit(0);            case 'connections':                if (\is_file($statistics_file) && \is_writable($statistics_file)) {                    \unlink($statistics_file);                }                // Master process will send SIGIO signal to all child processes.                \posix_kill($master_pid, SIGIO);                // Waiting amoment.                \usleep(500000);                // Display statisitcs data from a disk file.                if(\is_readable($statistics_file)) {                    \readfile($statistics_file);                }                exit(0);            case 'restart':            case 'stop':                if ($mode === '-g') {                    static::$_gracefulStop = true;                    $sig = \SIGHUP;                    static::log(""Workerman[$start_file] is gracefully stopping ..."");                } else {                    static::$_gracefulStop = false;                    $sig = \SIGINT;                    static::log(""Workerman[$start_file] is stopping ..."");                }                // Send stop signal to master process.                $master_pid && \posix_kill($master_pid, $sig);                // Timeout.                $timeout    = 5;                $start_time = \time();                // Check master process is still alive?                while (1) {                    $master_is_alive = $master_pid && \posix_kill((int) $master_pid, 0);                    if ($master_is_alive) {                        // Timeout?                        if (!static::$_gracefulStop && \time() - $start_time >= $timeout) {                            static::log(""Workerman[$start_file] stop fail"");                            exit;                        }                        // Waiting amoment.                        \usleep(10000);                        continue;                    }                    // Stop success.                    static::log(""Workerman[$start_file] stop success"");                    if ($command === 'stop') {                        exit(0);                    }                    if ($mode === '-d') {                        static::$daemonize = true;                    }                    break;                }                break;            case 'reload':                if($mode === '-g'){                    $sig = \SIGQUIT;                }else{                    $sig = \SIGUSR1;                }                \posix_kill($master_pid, $sig);                exit;            default :                if (isset($command)) {                    static::safeEcho('Unknown command: ' . $command . ""\n"");                }                exit($usage);        }    }    /**     * Format status data.     *     * @param $statistics_file     * @return string     */    protected static function formatStatusData($statistics_file)    {        static $total_request_cache = array();        if (!\is_readable($statistics_file)) {            return '';        }        $info = \file($statistics_file, \FILE_IGNORE_NEW_LINES);        if (!$info) {            return '';        }        $status_str = '';        $current_total_request = array();        $worker_info = \unserialize($info[0]);        \ksort($worker_info, SORT_NUMERIC);        unset($info[0]);        $data_waiting_sort = array();        $read_process_status = false;        $total_requests = 0;        $total_qps = 0;        $total_connections = 0;        $total_fails = 0;        $total_memory = 0;        $total_timers = 0;        $maxLen1 = static::$_maxSocketNameLength;        $maxLen2 = static::$_maxWorkerNameLength;        foreach($info as $key => $value) {            if (!$read_process_status) {                $status_str .= $value . ""\n"";                if (\preg_match('/^pid.*?memory.*?listening/', $value)) {                    $read_process_status = true;                }                continue;            }            if(\preg_match('/^[0-9]+/', $value, $pid_math)) {                $pid = $pid_math[0];                $data_waiting_sort[$pid] = $value;                if(\preg_match('/^\S+?\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?/', $value, $match)) {                    $total_memory += \intval(\str_ireplace('M','',$match[1]));                    $maxLen1 = \max($maxLen1,\strlen($match[2]));                    $maxLen2 = \max($maxLen2,\strlen($match[3]));                    $total_connections += \intval($match[4]);                    $total_fails += \intval($match[5]);                    $total_timers += \intval($match[6]);                    $current_total_request[$pid] = $match[7];                    $total_requests += \intval($match[7]);                }            }        }        foreach($worker_info as $pid => $info) {            if (!isset($data_waiting_sort[$pid])) {                $status_str .= ""$pid\t"" . \str_pad('N/A', 7) . "" ""                    . \str_pad($info['listen'], static::$_maxSocketNameLength) . "" ""                    . \str_pad($info['name'], static::$_maxWorkerNameLength) . "" ""                    . \str_pad('N/A', 11) . "" "" . \str_pad('N/A', 9) . "" ""                    . \str_pad('N/A', 7) . "" "" . \str_pad('N/A', 13) . "" N/A    [busy] \n"";                continue;            }            //$qps = isset($total_request_cache[$pid]) ? $current_total_request[$pid]            if (!isset($total_request_cache[$pid]) || !isset($current_total_request[$pid])) {                $qps = 0;            } else {                $qps = $current_total_request[$pid] - $total_request_cache[$pid];                $total_qps += $qps;            }            $status_str .= $data_waiting_sort[$pid]. "" "" . \str_pad($qps, 6) ."" [idle]\n"";        }        $total_request_cache = $current_total_request;        $status_str .= ""----------------------------------------------PROCESS STATUS---------------------------------------------------\n"";        $status_str .= ""Summary\t"" . \str_pad($total_memory.'M', 7) . "" ""            . \str_pad('-', $maxLen1) . "" ""            . \str_pad('-', $maxLen2) . "" ""            . \str_pad($total_connections, 11) . "" "" . \str_pad($total_fails, 9) . "" ""            . \str_pad($total_timers, 7) . "" "" . \str_pad($total_requests, 13) . "" ""            . \str_pad($total_qps,6)."" [Summary] \n"";        return $status_str;    }    /**     * Install signal handler.     *     * @return void     */    protected static function installSignal()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        $signalHandler = '\Workerman\Worker::signalHandler';        // stop        \pcntl_signal(\SIGINT, $signalHandler, false);        // stop        \pcntl_signal(\SIGTERM, $signalHandler, false);        // graceful stop        \pcntl_signal(\SIGHUP, $signalHandler, false);        // reload        \pcntl_signal(\SIGUSR1, $signalHandler, false);        // graceful reload        \pcntl_signal(\SIGQUIT, $signalHandler, false);        // status        \pcntl_signal(\SIGUSR2, $signalHandler, false);        // connection status        \pcntl_signal(\SIGIO, $signalHandler, false);        // ignore        \pcntl_signal(\SIGPIPE, \SIG_IGN, false);    }    /**     * Reinstall signal handler.     *     * @return void     */    protected static function reinstallSignal()    {        if (static::$_OS !== \OS_TYPE_LINUX) {            return;        }        $signalHandler = '\Workerman\Worker::signalHandler';        // uninstall stop signal handler        \pcntl_signal(\SIGINT, \SIG_IGN, false);        // uninstall stop signal handler        \pcntl_signal(\SIGTERM, \SIG_IGN, false);        // uninstall graceful stop signal handler        \pcntl_signal(\SIGHUP, \SIG_IGN, false);        // uninstall reload signal handler        \pcntl_signal(\SIGUSR1, \SIG_IGN, false);        // uninstall graceful reload signal handler        \pcntl_signal(\SIGQUIT, \SIG_IGN, false);        // uninstall status signal handler        \pcntl_signal(\SIGUSR2, \SIG_IGN, false);        // uninstall connections status signal handler        \pcntl_signal(\SIGIO, \SIG_IGN, false);        // reinstall stop signal handler        static::$globalEvent->add(\SIGINT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful stop signal handler        static::$globalEvent->add(\SIGHUP, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall reload signal handler        static::$globalEvent->add(\SIGUSR1, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall graceful reload signal handler        static::$globalEvent->add(\SIGQUIT, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall status signal handler        static::$globalEvent->add(\SIGUSR2, EventInterface::EV_SIGNAL, $signalHandler);        // reinstall connection status signal handler        static::$globalEvent->add(\SIGIO, EventInterface::EV_SIGNAL, $signalHandler);    }    /**     * Signal handler.     *     * @param int $signal     */    public static function signalHandler($signal)    {        switch ($signal) {            // Stop.            case \SIGINT:            case \SIGTERM:                static::$_gracefulStop = false;                static::stopAll();                break;            // Graceful stop.            case \SIGHUP:                static::$_gracefulStop = true;                static::stopAll();                break;            // Reload.            case \SIGQUIT:            case \SIGUSR1:                static::$_gracefulStop = $signal === \SIGQUIT;                static::$_pidsToRestart = static::getAllWorkerPids();                static::reload();                break;            // Show status.            case \SIGUSR2:                static::writeStatisticsToStatusFile();                break;            // Show connection status.            case \SIGIO:                static::writeConnectionsStatisticsToStatusFile();                break;        }    }    /**     * Run as deamon mode.     *     * @throws Exception     */    protected static function daemonize()    {        if (!static::$daemonize || static::$_OS !== \OS_TYPE_LINUX) {            return;        }        \umask(0);        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception('Fork fail');        } elseif ($pid > 0) {            exit(0);        }        if (-1 === \posix_setsid()) {            throw new Exception(""Setsid fail"");        }        // Fork again avoid SVR4 system regain the control of terminal.        $pid = \pcntl_fork();        if (-1 === $pid) {            throw new Exception(""Fork fail"");        } elseif (0 !== $pid) {            exit(0);        }    }    /**     * Redirect sta",0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
38,symfony_finder_Finder_1080, Finder allows to build rules to find files and directories.\n\n It is a thin wrapper around several specialized iterator classes.\n\n All rules may be invoked several times.\n\n All methods return the current Finder object to allow chaining:\n\n     $finder = Finder::create()->files()->name('\n @author Fabien Potencier <fabien@symfony.com>\n,Finder omogućava izgradnju pravila za pronalaženje datoteka i direktorija. To je tanki omotač oko nekoliko specijalizovanih klasa iteratora. Sva pravila se mogu pozivati nekoliko puta. Sve metode vraćaju trenutni objekt Finder-a u dozvoliti ulančavanje,"class Finder implements \IteratorAggregate, \Countable{    public const IGNORE_VCS_FILES = 1;    public const IGNORE_DOT_FILES = 2;    public const IGNORE_VCS_IGNORED_FILES = 4;    private $mode = 0;    private $names = [];    private $notNames = [];    private $exclude = [];    private $filters = [];    private $depths = [];    private $sizes = [];    private $followLinks = false;    private $reverseSorting = false;    private $sort = false;    private $ignore = 0;    private $dirs = [];    private $dates = [];    private $iterators = [];    private $contains = [];    private $notContains = [];    private $paths = [];    private $notPaths = [];    private $ignoreUnreadableDirs = false;    private static $vcsPatterns = ['.svn', '_svn', 'CVS', '_darcs', '.arch-params', '.monotone', '.bzr', '.git', '.hg'];    public function __construct()    {        $this->ignore = static::IGNORE_VCS_FILES | static::IGNORE_DOT_FILES;    }    /**     * Creates a new Finder.     *     * @return static     */    public static function create()    {        return new static();    }    /**     * Restricts the matching to directories only.     *     * @return $this     */    public function directories()    {        $this->mode = Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES;        return $this;    }    /**     * Restricts the matching to files only.     *     * @return $this     */    public function files()    {        $this->mode = Iterator\FileTypeFilterIterator::ONLY_FILES;        return $this;    }    /**     * Adds tests for the directory depth.     *     * Usage:     *     *     $finder->depth('> 1') // the Finder will start matching at level 1.     *     $finder->depth('< 3') // the Finder will descend at most 3 levels of directories below the starting point.     *     $finder->depth(['>= 1', '< 3'])     *     * @param string|int|string[]|int[] $levels The depth level expression or an array of depth levels     *     * @return $this     *     * @see DepthRangeFilterIterator     * @see NumberComparator     */    public function depth($levels)    {        foreach ((array) $levels as $level) {            $this->depths[] = new Comparator\NumberComparator($level);        }        return $this;    }    /**     * Adds tests for file dates (last modified).     *     * The date must be something that strtotime() is able to parse:     *     *     $finder->date('since yesterday');     *     $finder->date('until 2 days ago');     *     $finder->date('> now - 2 hours');     *     $finder->date('>= 2005-10-15');     *     $finder->date(['>= 2005-10-15', '<= 2006-05-27']);     *     * @param string|string[] $dates A date range string or an array of date ranges     *     * @return $this     *     * @see strtotime     * @see DateRangeFilterIterator     * @see DateComparator     */    public function date($dates)    {        foreach ((array) $dates as $date) {            $this->dates[] = new Comparator\DateComparator($date);        }        return $this;    }    /**     * Adds rules that files must match.     *     * You can use patterns (delimited with / sign), globs or simple strings.     *     *     $finder->name('*.php')     *     $finder->name('/\.php$/') // same as above     *     $finder->name('test.php')     *     $finder->name(['test.py', 'test.php'])     *     * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function name($patterns)    {        $this->names = array_merge($this->names, (array) $patterns);        return $this;    }    /**     * Adds rules that files must not match.     *     * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function notName($patterns)    {        $this->notNames = array_merge($this->notNames, (array) $patterns);        return $this;    }    /**     * Adds tests that file contents must match.     *     * Strings or PCRE patterns can be used:     *     *     $finder->contains('Lorem ipsum')     *     $finder->contains('/Lorem ipsum/i')     *     $finder->contains(['dolor', '/ipsum/i'])     *     * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns     *     * @return $this     *     * @see FilecontentFilterIterator     */    public function contains($patterns)    {        $this->contains = array_merge($this->contains, (array) $patterns);        return $this;    }    /**     * Adds tests that file contents must not match.     *     * Strings or PCRE patterns can be used:     *     *     $finder->notContains('Lorem ipsum')     *     $finder->notContains('/Lorem ipsum/i')     *     $finder->notContains(['lorem', '/dolor/i'])     *     * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns     *     * @return $this     *     * @see FilecontentFilterIterator     */    public function notContains($patterns)    {        $this->notContains = array_merge($this->notContains, (array) $patterns);        return $this;    }    /**     * Adds rules that filenames must match.     *     * You can use patterns (delimited with / sign) or simple strings.     *     *     $finder->path('some/special/dir')     *     $finder->path('/some\/special\/dir/') // same as above     *     $finder->path(['some dir', 'another/dir'])     *     * Use only / as dirname separator.     *     * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function path($patterns)    {        $this->paths = array_merge($this->paths, (array) $patterns);        return $this;    }    /**     * Adds rules that filenames must not match.     *     * You can use patterns (delimited with / sign) or simple strings.     *     *     $finder->notPath('some/special/dir')     *     $finder->notPath('/some\/special\/dir/') // same as above     *     $finder->notPath(['some/file.txt', 'another/file.log'])     *     * Use only / as dirname separator.     *     * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns     *     * @return $this     *     * @see FilenameFilterIterator     */    public function notPath($patterns)    {        $this->notPaths = array_merge($this->notPaths, (array) $patterns);        return $this;    }    /**     * Adds tests for file sizes.     *     *     $finder->size('> 10K');     *     $finder->size('<= 1Ki');     *     $finder->size(4);     *     $finder->size(['> 10K', '< 20K'])     *     * @param string|int|string[]|int[] $sizes A size range string or an integer or an array of size ranges     *     * @return $this     *     * @see SizeRangeFilterIterator     * @see NumberComparator     */    public function size($sizes)    {        foreach ((array) $sizes as $size) {            $this->sizes[] = new Comparator\NumberComparator($size);        }        return $this;    }    /**     * Excludes directories.     *     * Directories passed as argument must be relative to the ones defined with the `in()` method. For example:     *     *     $finder->in(__DIR__)->exclude('ruby');     *     * @param string|array $dirs A directory path or an array of directories     *     * @return $this     *     * @see ExcludeDirectoryFilterIterator     */    public function exclude($dirs)    {        $this->exclude = array_merge($this->exclude, (array) $dirs);        return $this;    }    /**     * Excludes ""hidden"" directories and files (starting with a dot).     *     * This option is enabled by default.     *     * @return $this     *     * @see ExcludeDirectoryFilterIterator     */    public function ignoreDotFiles(bool $ignoreDotFiles)    {        if ($ignoreDotFiles) {            $this->ignore |= static::IGNORE_DOT_FILES;        } else {            $this->ignore &= ~static::IGNORE_DOT_FILES;        }        return $this;    }    /**     * Forces the finder to ignore version control directories.     *     * This option is enabled by default.     *     * @return $this     *     * @see ExcludeDirectoryFilterIterator     */    public function ignoreVCS(bool $ignoreVCS)    {        if ($ignoreVCS) {            $this->ignore |= static::IGNORE_VCS_FILES;        } else {            $this->ignore &= ~static::IGNORE_VCS_FILES;        }        return $this;    }    /**     * Forces Finder to obey .gitignore and ignore files based on rules listed there.     *     * This option is disabled by default.     *     * @return $this     */    public function ignoreVCSIgnored(bool $ignoreVCSIgnored)    {        if ($ignoreVCSIgnored) {            $this->ignore |= static::IGNORE_VCS_IGNORED_FILES;        } else {            $this->ignore &= ~static::IGNORE_VCS_IGNORED_FILES;        }        return $this;    }    /**     * Adds VCS patterns.     *     * @see ignoreVCS()     *     * @param string|string[] $pattern VCS patterns to ignore     */    public static function addVCSPattern($pattern)    {        foreach ((array) $pattern as $p) {            self::$vcsPatterns[] = $p;        }        self::$vcsPatterns = array_unique(self::$vcsPatterns);    }    /**     * Sorts files and directories by an anonymous function.     *     * The anonymous function receives two \SplFileInfo instances to compare.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sort(\Closure $closure)    {        $this->sort = $closure;        return $this;    }    /**     * Sorts files and directories by name.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByName(bool $useNaturalSort = false)    {        $this->sort = $useNaturalSort ? Iterator\SortableIterator::SORT_BY_NAME_NATURAL : Iterator\SortableIterator::SORT_BY_NAME;        return $this;    }    /**     * Sorts files and directories by type (directories before files), then by name.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByType()    {        $this->sort = Iterator\SortableIterator::SORT_BY_TYPE;        return $this;    }    /**     * Sorts files and directories by the last accessed time.     *     * This is the time that the file was last accessed, read or written to.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByAccessedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_ACCESSED_TIME;        return $this;    }    /**     * Reverses the sorting.     *     * @return $this     */    public function reverseSorting()    {        $this->reverseSorting = true;        return $this;    }    /**     * Sorts files and directories by the last inode changed time.     *     * This is the time that the inode information was last modified (permissions, owner, group or other metadata).     *     * On Windows, since inode is not available, changed time is actually the file creation time.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByChangedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_CHANGED_TIME;        return $this;    }    /**     * Sorts files and directories by the last modified time.     *     * This is the last time the actual contents of the file were last modified.     *     * This can be slow as all the matching files and directories must be retrieved for comparison.     *     * @return $this     *     * @see SortableIterator     */    public function sortByModifiedTime()    {        $this->sort = Iterator\SortableIterator::SORT_BY_MODIFIED_TIME;        return $this;    }    /**     * Filters the iterator with an anonymous function.     *     * The anonymous function receives a \SplFileInfo and must return false     * to remove files.     *     * @return $this     *     * @see CustomFilterIterator     */    public function filter(\Closure $closure)    {        $this->filters[] = $closure;        return $this;    }    /**     * Forces the following of symlinks.     *     * @return $this     */    public function followLinks()    {        $this->followLinks = true;        return $this;    }    /**     * Tells finder to ignore unreadable directories.     *     * By default, scanning unreadable directories content throws an AccessDeniedException.     *     * @return $this     */    public function ignoreUnreadableDirs(bool $ignore = true)    {        $this->ignoreUnreadableDirs = $ignore;        return $this;    }    /**     * Searches files and directories which match defined rules.     *     * @param string|string[] $dirs A directory path or an array of directories     *     * @return $this     *     * @throws DirectoryNotFoundException if one of the directories does not exist     */    public function in($dirs)    {        $resolvedDirs = [];        foreach ((array) $dirs as $dir) {            if (is_dir($dir)) {                $resolvedDirs[] = $this->normalizeDir($dir);            } elseif ($glob = glob($dir, (\defined('GLOB_BRACE') ? \GLOB_BRACE : 0) | \GLOB_ONLYDIR | \GLOB_NOSORT)) {                sort($glob);                $resolvedDirs = array_merge($resolvedDirs, array_map([$this, 'normalizeDir'], $glob));            } else {                throw new DirectoryNotFoundException(sprintf('The ""%s"" directory does not exist.', $dir));            }        }        $this->dirs = array_merge($this->dirs, $resolvedDirs);        return $this;    }    /**     * Returns an Iterator for the current Finder configuration.     *     * This method implements the IteratorAggregate interface.     *     * @return \Iterator|SplFileInfo[] An iterator     *     * @throws \LogicException if the in() method has not been called     */    public function getIterator()    {        if (0 === \count($this->dirs) && 0 === \count($this->iterators)) {            throw new \LogicException('You must call one of in() or append() methods before iterating over a Finder.');        }        if (1 === \count($this->dirs) && 0 === \count($this->iterators)) {            $iterator = $this->searchInDirectory($this->dirs[0]);            if ($this->sort || $this->reverseSorting) {                $iterator = (new Iterator\SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();            }            return $iterator;        }        $iterator = new \AppendIterator();        foreach ($this->dirs as $dir) {            $iterator->append(new \IteratorIterator(new LazyIterator(function () use ($dir) {                return $this->searchInDirectory($dir);            })));        }        foreach ($this->iterators as $it) {            $iterator->append($it);        }        if ($this->sort || $this->reverseSorting) {            $iterator = (new Iterator\SortableIterator($iterator, $this->sort, $this->reverseSorting))->getIterator();        }        return $iterator;    }    /**     * Appends an existing set of files/directories to the finder.     *     * The set can be another Finder, an Iterator, an IteratorAggregate, or even a plain array.     *     * @return $this     *     * @throws \InvalidArgumentException when the given argument is not iterable     */    public function append(iterable $iterator)    {        if ($iterator instanceof \IteratorAggregate) {            $this->iterators[] = $iterator->getIterator();        } elseif ($iterator instanceof \Iterator) {            $this->iterators[] = $iterator;        } elseif ($iterator instanceof \Traversable || \is_array($iterator)) {            $it = new \ArrayIterator();            foreach ($iterator as $file) {                $file = $file instanceof \SplFileInfo ? $file : new \SplFileInfo($file);                $it[$file->getPathname()] = $file;            }            $this->iterators[] = $it;        } else {            throw new \InvalidArgumentException('Finder::append() method wrong argument type.');        }        return $this;    }    /**     * Check if any results were found.     *     * @return bool     */    public function hasResults()    {        foreach ($this->getIterator() as $_) {            return true;        }        return false;    }    /**     * Counts all the results collected by the iterators.     *     * @return int     */    public function count()    {        return iterator_count($this->getIterator());    }    private function searchInDirectory(string $dir): \Iterator    {        $exclude = $this->exclude;        $notPaths = $this->notPaths;        if (static::IGNORE_VCS_FILES === (static::IGNORE_VCS_FILES & $this->ignore)) {            $exclude = array_merge($exclude, self::$vcsPatterns);        }        if (static::IGNORE_DOT_FILES === (static::IGNORE_DOT_FILES & $this->ignore)) {            $notPaths[] = '#(^|/)\..+(/|$)#';        }        if (static::IGNORE_VCS_IGNORED_FILES === (static::IGNORE_VCS_IGNORED_FILES & $this->ignore)) {            $gitignoreFilePath = sprintf('%s/.gitignore', $dir);            if (!is_readable($gitignoreFilePath)) {                throw new \RuntimeException(sprintf('The ""ignoreVCSIgnored"" option cannot be used by the Finder as the ""%s"" file is not readable.', $gitignoreFilePath));            }            $notPaths = array_merge($notPaths, [Gitignore::toRegex(file_get_contents($gitignoreFilePath))]);        }        $minDepth = 0;        $maxDepth = \PHP_INT_MAX;        foreach ($this->depths as $comparator) {            switch ($comparator->getOperator()) {                case '>':                    $minDepth = $comparator->getTarget() + 1;                    break;                case '>=':                    $minDepth = $comparator->getTarget();                    break;                case '<':                    $maxDepth = $comparator->getTarget() - 1;                    break;                case '<=':                    $maxDepth = $comparator->getTarget();                    break;                default:                    $minDepth = $maxDepth = $comparator->getTarget();            }        }        $flags = \RecursiveDirectoryIterator::SKIP_DOTS;        if ($this->followLinks) {            $flags |= \RecursiveDirectoryIterator::FOLLOW_SYMLINKS;        }        $iterator = new Iterator\RecursiveDirectoryIterator($dir, $flags, $this->ignoreUnreadableDirs);        if ($exclude) {            $iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $exclude);        }        $iterator = new \RecursiveIteratorIterator($iterator, \RecursiveIteratorIterator::SELF_FIRST);        if ($minDepth > 0 || $maxDepth < \PHP_INT_MAX) {            $iterator = new Iterator\DepthRangeFilterIterator($iterator, $minDepth, $maxDepth);        }        if ($this->mode) {            $iterator = new Iterator\FileTypeFilterIterator($iterator, $this->mode);        }        if ($this->names || $this->notNames) {            $iterator = new Iterator\FilenameFilterIterator($iterator, $this->names, $this->notNames);        }        if ($this->contains || $this->notContains) {            $iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);        }        if ($this->sizes) {            $iterator = new Iterator\SizeRangeFilterIterator($iterator, $this->sizes);        }        if ($this->dates) {            $iterator = new Iterator\DateRangeFilterIterator($iterator, $this->dates);        }        if ($this->filters) {            $iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);        }        if ($this->paths || $notPaths) {            $iterator = new Iterator\PathFilterIterator($iterator, $this->paths, $notPaths);        }        return $iterator;    }    /**     * Normalizes given directory names by removing trailing slashes.     *     * Excluding: (s)ftp:// or ssh2.(s)ftp:// wrapper     */    private function normalizeDir(string $dir): string    {        if ('/' === $dir) {            return $dir;        }        $dir = rtrim($dir, '/'.\DIRECTORY_SEPARATOR);        if (preg_match('#^(ssh2\.)?s?ftp://#', $dir)) {            $dir .= '/';        }        return $dir;    }}",0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
39,markrogoyski_math-php_Descriptive_3492," Compute the P-th percentile of a list of numbers\\n\\n Linear interpolation between closest ranks method - Second variant, C = 1\\n P-th percentile (0 <= P <= 100) of a list of N ordered values (sorted from least to greatest)\\n Similar method used in NumPy and Excel\\n https://en.wikipedia.org/wiki/Percentile#Second_variant.2C_.7F.27.22.60UNIQ--postMath-00000043-QINU.60.22.27.7F\\n\\n      P\\n x - --- (N - 1) + 1\\n     100\\n\\n P = percentile\\n N = number of elements in list\\n\\n Î½(x) = Î½â‚“ + xï¼…1(Î½â‚“â‚Šâ‚ - Î½â‚“)\\n\\n âŒŠxâŒ‹  = integer part of x\\n xï¼…1 = fraction part of x\\n Î½â‚“   = number in position x in sorted list of numbers\\n Î½â‚“â‚Šâ‚ = number in position x + 1 in sorted list of number\\n\\n @param float[] $numbers\\n @param float   $P percentile to calculate\\n\\n @return float in list corresponding to P percentile\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if $P percentile is not between 0 and 100\\n","Izračunajte P-ti percentil iz liste brojeva . Metoda linearne interpolacije između najbližih rangova - Druga varijanta, C = 1. P-ti percentil (0 <= P <= 100) liste N uređenih vrednosti (poređanih od najmanje do najveće). Slična metoda korišćena u NumPi i Excel-u","    public static function percentile(array $numbers, float $P): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the P-th percentile of an empty list of numbers');        }        if ($P < 0 || $P > 100) {            throw new Exception\OutOfBoundsException('Percentile P must be between 0 and 100.');        }        $N = \count($numbers);        if ($N === 1) {            return \array_shift($numbers);        }        \sort($numbers);        if ($P == 100) {            return  $numbers[$N - 1];        }        $x    = ($P / 100) * ($N - 1) + 1;        $âŒŠxâŒ‹  = \intval($x);        $xï¼…1 = $x - $âŒŠxâŒ‹;        $Î½â‚“   = $numbers[$âŒŠxâŒ‹ - 1];        $Î½â‚“â‚Šâ‚ = $numbers[$âŒŠxâŒ‹];        return $Î½â‚“ + $xï¼…1 * ($Î½â‚“â‚Šâ‚ - $Î½â‚“);    }",0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
40,markrogoyski_math-php_NumericalIntegration_3024, Sorts our coordinates (arrays) by their x-component (first number) such\n that consecutive coordinates have an increasing x-component.\n\n @param  array[] $points\n\n @return array[]\n,Sortira naše koordinate (nizove) prema njihovim k-komponentama (prvi broj) tako da uzastopne koordinate imaju rastuću k-komponentu,"    protected static function sort(array $points): array    {        \usort($points, function ($a, $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }",0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
41,symfony_http-foundation_AcceptHeader_9684, Sorts items by descending quality.\n,Sortira stavke prema opadajućem kvalitetu,"    private function sort(): void    {        if (!$this->sorted) {            uasort($this->items, function (AcceptHeaderItem $a, AcceptHeaderItem $b) {                $qA = $a->getQuality();                $qB = $b->getQuality();                if ($qA === $qB) {                    return $a->getIndex() > $b->getIndex() ? 1 : -1;                }                return $qA > $qB ? -1 : 1;            });            $this->sorted = true;        }    }",0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
42,TheAlgorithms_PHP_MaxCharacter_2067, This function returns\n the character which is\n repeated maximum no. of\n times in the given string.\n\n @param string $string\n @return string\n,Ova funkcija vraća znak koji je ponovljen maksimum br. puta u datom nizu,function maxCharacter(string $string){    if (empty($string)) {        throw new \Exception('Please pass a non-empty string value');    }    $characterCountTable = []; // A variable to maintain the character counts    $string              = strtolower($string); // For case-insensitive checking    $characters          = str_split($string); // Splitting the string to a Character Array.    foreach ($characters as $character) {        $currentCharacterCount = 1;        if (isset($characterCountTable[$character])) {            $currentCharacterCount = $characterCountTable[$character] + 1;        }        $characterCountTable[$character] = $currentCharacterCount;    }    arsort($characterCountTable);    return array_keys($characterCountTable)[0];},0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
43,symfony_http-foundation_AcceptHeader_9683, Returns first item.\n\n @return AcceptHeaderItem|null\n,Vraća prvu stavku,    public function first()    {        $this->sort();        return !empty($this->items) ? reset($this->items) : null;    },0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
44,markrogoyski_math-php_Descriptive_3491," Quartiles - Inclusive method (R method)\n Three points that divide the data set into four equal groups, each group comprising a quarter of the data.\n https://en.wikipedia.org/wiki/Quartile\n\n 0% is smallest number\n Q1 (25%) is first quartile (lower quartile, 25th percentile)\n Q2 (50%) is second quartile (median, 50th percentile)\n Q3 (75%) is third quartile (upper quartile, 75th percentile)\n 100% is largest number\n interquartile_range is the difference between the upper and lower quartiles. (IQR = Qâ‚ƒ - Qâ‚)\n\n Method used\n  - Use the median to divide the ordered data set into two halves.\n   - If there are an odd number of data points in the original ordered data set,\n     include the median (the central value in the ordered list) in both halves.\n   - If there are an even number of data points in the original ordered data set,\n     split this data set exactly in half.\n  - The lower quartile value is the median of the lower half of the data.\n    The upper quartile value is the median of the upper half of the data.\n\n The values found by this method are also known as ""Tukey\'s hinges"".\n This is the method that the programming language R uses by default.\n\n @param float[] $numbers\n\n @return array (0%, Q1, Q2, Q3, 100%, IQR)\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n","Kvartili - Inkluzivna metoda (R metoda).Tri tačke koje skup podataka dele na četiri jednake grupe, a svaka grupa čini četvrtinu podataka https://en.vikipedia.org/viki/Kuartile\n\n 0% je najmanji broj K1 (25%) je prvi kvartil (donji kvartil, 25. percentil), K2 (50%) je drugi kvartil (medijana, 50. percentil), K3 (75%) je treći kvartil (gornji) kvartil, 75. percentil) , 100% je najveći broj. Interquartile_range je razlika između gornjeg i donjeg kvartila. (IKR = Ka‚ƒ - Ka ‚). Korišćena metoda - Koristiti medijanu da podeli poređani skup podataka na dve polovine. Ako u originalnim uređenim podacima postoji neparan broj tačaka podataka skupa, uključite medijanu (centralnu vrednost na uređenoj listi) u obe polovine. Ako u originalnom uređenom skupu podataka postoji paran broj tačaka podataka, podelite ovaj skup podataka tačno na pola. Vrednost donjeg kvartila je medijana donje polovine podataka.Vrednost gornjeg kvartila je srednja vrednost gornje polovine podataka. Vrednosti pronađene ovom metodom poznate su i kao „Tukey\'s hinges"". Ovo je metoda koju programski jezik R podrazumevano koristi","    public static function quartilesInclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);            // Add median to both halves            $median = Average::median($numbers);            \array_push($lower_half, $median);            \array_unshift($upper_half, $median);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }",0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
45,jorgecasas_php-ml_EigenTransformerBase_898, Calculates eigenValues and eigenVectors of the given matrix. Returns\n top eigenVectors along with the largest eigenValues. The total explained variance\n of these eigenVectors will be no less than desired $totalVariance value\n,Izračunava eigenValues i eigenVectors date matrice. Vraća top eigenVectors zajedno sa najvećim eigenValues. Ukupna objašnjena varijansa ovih eigenVectors neće biti manja od željene $totalVariance vrednosti,    protected function eigenDecomposition(array $matrix): void    {        $eig = new EigenvalueDecomposition($matrix);        $eigVals = $eig->getRealEigenvalues();        $eigVects = $eig->getEigenvectors();        $totalEigVal = array_sum($eigVals);        // Sort eigenvalues in descending order        arsort($eigVals);        $explainedVar = 0.0;        $vectors = [];        $values = [];        foreach ($eigVals as $i => $eigVal) {            $explainedVar += $eigVal / $totalEigVal;            $vectors[] = $eigVects[$i];            $values[] = $eigVal;            if ($this->numFeatures !== null) {                if (count($vectors) == $this->numFeatures) {                    break;                }            } else {                if ($explainedVar >= $this->totalVariance) {                    break;                }            }        }        $this->eigValues = $values;        $this->eigVectors = $vectors;    },0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
46,markrogoyski_math-php_SimpsonsRule_3028," Use Simpson's Rule to approximate the definite integral of a\n function f(x). Our input can support either a set of arrays, or a callback\n function with arguments (to produce a set of arrays). Each array in our\n input contains two numbers which correspond to coordinates (x, y) or\n equivalently, (x, f(x)), of the function f(x) whose definite integral we\n are approximating.\n\n Note: Simpson's method requires that we have an even number of\n subintervals (we must supply an odd number of points) and also that the\n size of each subinterval is equal (spacing between each point is equal).\n\n The bounds of the definite integral to which we are approximating is\n determined by the our inputs.\n\n Example: approximate([0, 10], [5, 5], [10, 7]) will approximate the definite\n integral of the function that produces these coordinates with a lower\n bound of 0, and an upper bound of 10.\n\n Example: approximate(function($x) {return $x a set of arrays by evaluating the callback at 5 evenly spaced points\n between 0 and 4. Then, this array will be used in our approximation.\n\n Simpson's Rule:\n\n xn        â¿â»Â¹ xáµ¢â‚Šâ‚\n âˆ« f(x)dx = âˆ‘   âˆ« f(x)dx\n xâ‚        â±â¼Â¹  xáµ¢\n\n         â½â¿â»Â¹â¾/Â² h\n          = âˆ‘    - [fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯ + 4fâŸ®xâ‚‚áµ¢âŸ¯ + fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯] + O(hâµfâ—(x))\n           â±â¼Â¹   3\n where h = (xn - xâ‚) / (n - 1)\n\n @param callable|array $source  The source of our approximation. Should be either\n                                a callback function or a set of arrays. Each array\n                                (point) contains precisely two numbers, an x and y.\n                                Example array: [[1,2], [2,3], [3,4]].\n                                Example callback: function($x) {return $x @param number         ...$args The arguments of our callback function: start,\n                                end, and n. Example: approximate($source, 0, 8, 5).\n                                If $source is a set of points, do not input any\n                                $args. Example: approximate($source).\n\n @return float                  The approximation to the integral of f(x)\n\n @throws Exception\\BadDataException\n @throws Exception\\IncorrectTypeException\n","Koristite Simpsonovo pravilo za približavanje konačnog integrala funkcije f(x). Naš ulaz može podržati ili skup nizova, ili funkciju povratnog poziva sa argumentima (da bi se dobio niz nizova). Svaki niz u našem ulazu sadrži dva broja koji odgovaraju koordinatama (x, i) ili ekvivalentno, (x, f (x)), funkcije f(x) čiji konačni integral aproksimiramo. Napomena: Simpsonova metoda zahteva da imamo paran broj podintervala (moramo dostaviti neparan broj tačaka) i da je veličina svakog podintervala jednaka (razmak između svake tačke je jednak). Granice definitivnog integrala kojem se približavamo određuju naši unosi. Primer: approximate([0, 10], [5, 5], [10, 7]) će približite konačni integral funkcije koja daje ove koordinate sa donjom granicom 0, a gornjom granicom 10. Primer: approximate(funkcija ($x) {vrati $x skup nizova procenjujući povratni poziv u 5 ravnomerno raspoređenih tačaka između 0 i 4. Zatim će se ovaj niz koristiti u našoj aproksimaciji","    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 3);        Validation::isSubintervalsMultiple($points, $m = 2);        $sorted = self::sort($points);        Validation::isSpacingConstant($sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $subintervals  = $n - 1;        $a             = $sorted[0][$x];        $b             = $sorted[$n - 1][$x];        $h             = ($b - $a) / $subintervals;        $approximation = 0;        /*         * Summation         * â½â¿â»Â¹â¾/Â² h         *    âˆ‘    - [fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯ + 4fâŸ®xâ‚‚áµ¢âŸ¯ + fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯] + O(hâµfâ—(x))         *   â±â¼Â¹   3         *  where h = (xn - xâ‚) / (n - 1)         */        for ($i = 1; $i < ($subintervals / 2) + 1; $i++) {            $xâ‚‚áµ¢â‚‹â‚          = $sorted[(2 * $i) - 2][$x];            $xâ‚‚áµ¢            = $sorted[(2 * $i) - 1][$x];            $xâ‚‚áµ¢â‚Šâ‚          = $sorted[(2 * $i)][$x];            $fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯        = $sorted[(2 * $i) - 2][$y];  // yâ‚‚áµ¢â‚‹â‚            $fâŸ®xâ‚‚áµ¢âŸ¯          = $sorted[(2 * $i) - 1][$y];  // yâ‚‚áµ¢            $fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯        = $sorted[(2 * $i)][$y];    // yâ‚‚áµ¢â‚Šâ‚            $lagrange       = LagrangePolynomial::interpolate([[$xâ‚‚áµ¢â‚‹â‚, $fâŸ®xâ‚‚áµ¢â‚‹â‚âŸ¯], [$xâ‚‚áµ¢, $fâŸ®xâ‚‚áµ¢âŸ¯], [$xâ‚‚áµ¢â‚Šâ‚, $fâŸ®xâ‚‚áµ¢â‚Šâ‚âŸ¯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xâ‚‚áµ¢â‚Šâ‚) - $integral($xâ‚‚áµ¢â‚‹â‚); // definite integral of lagrange polynomial        }        return $approximation;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
47,markrogoyski_math-php_TrapezoidalRule_3032," Use the Trapezoidal Rule to approximate the definite integral of a\\n function f(x). Our input can support either a set of arrays, or a callback\\n function with arguments (to produce a set of arrays). Each array in our\\n input contains two numbers which correspond to coordinates (x, y) or\\n equivalently, (x, f(x)), of the function f(x) whose definite integral we\\n are approximating.\\n\\n The bounds of the definite integral to which we are approximating is\\n determined by the our inputs.\\n\\n Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite\\n integral of the function that produces these coordinates with a lower\\n bound of 0, and an upper bound of 10.\\n\\n Example: approximate(function($x) {return $x a set of arrays by evaluating the callback at 5 evenly spaced points\\n between 0 and 4. Then, this array will be used in our approximation.\\n\\n Trapezoidal Rule:\\n\\n xn        â¿â»Â¹ xáµ¢â‚Šâ‚\\n âˆ« f(x)dx = âˆ‘   âˆ« f(x)dx\\n xâ‚        â±â¼Â¹  xáµ¢\\n\\n           â¿â»Â¹  h\\n          = âˆ‘   - [f(xáµ¢â‚Šâ‚) + f(xáµ¢)] + O(hÂ³fâ€³(x))\\n           â±â¼Â¹  2\\n\\n  where h = xáµ¢â‚Šâ‚ - xáµ¢\\n  note: this implementation does not compute the error term.\\n @param callable|array $source The source of our approximation. Should be either\\n                               a callback function or a set of arrays. Each array\\n                               (point) contains precisely two numbers, an x and y.\\n                               Example array: [[1,2], [2,3], [3,4]].\\n                               Example callback: function($x) {return $x @param number        ...$args The arguments of our callback function: start,\\n                               end, and n. Example: approximate($source, 0, 8, 5).\\n                               If $source is a set of points, do not input any\\n                               $args. Example: approximate($source).\\n\\n @return float                The approximation to the integral of f(x)\\n\\n @throws Exception\\\\BadDataException\\n @throws \\\\MathPHP\\\\Exception\\\\IncorrectTypeException\\n","Koristite trapezoidno pravilo za približavanje konačnog integrala funkcije f(x). Naš ulaz može podržati ili skup nizova, ili funkciju povratnog poziva sa argumentima (za stvaranje niza nizova). Svaki niz u našem ulazu sadrži dva broja koji odgovaraju koordinatama (x, i) ili ekvivalentno, (x, f(x)), funkcije f(x) čiji konačni integral aproksimiramo. Granice konačnog integrala kojem se približavamo određene su našim ulazima. Primer: approximate([0, 10], [3, 5] , [10, 7]) približiće konačni integral funkcije koja proizvodi ove koordinate sa donjom granicom 0, a gornjom granicom 10. Primer: approximate(funkcija ($x) {vrati $x skup nizova procenom povratnog poziva u 5 ravnomerno raspoređenih tačaka između 0 i 4. Tada će se ovaj niz koristiti u našoj aproksimaciji","    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         * â¿â»Â¹  h         *  âˆ‘   - [f(xáµ¢â‚Šâ‚) + f(xáµ¢)]         * â±â¼Â¹  2         *  where h = xáµ¢â‚Šâ‚ - xáµ¢         */        for ($i = 0; $i < $steps; $i++) {            $xáµ¢             = $sorted[$i][$x];            $xáµ¢â‚Šâ‚           = $sorted[$i + 1][$x];            $fâŸ®xáµ¢âŸ¯           = $sorted[$i][$y];    // yáµ¢            $fâŸ®xáµ¢â‚Šâ‚âŸ¯         = $sorted[$i + 1][$y];  // yáµ¢â‚Šâ‚            $lagrange       = LagrangePolynomial::interpolate([[$xáµ¢, $fâŸ®xáµ¢âŸ¯], [$xáµ¢â‚Šâ‚, $fâŸ®xáµ¢â‚Šâ‚âŸ¯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xáµ¢â‚Šâ‚) - $integral($xáµ¢); // definite integral of lagrange polynomial        }        return $approximation;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
48,yiisoft_yii2_ReleaseController_980, Ensure sorting of the changelog lines.\\n @param string[] $changelog\\n @return string[]\\n,Obezbedite sortiranje redova dnevnika promena,"abstract class TestCase extends \PHPUnit\Framework\TestCase{    public static $params;    /**     * Clean up after test case.     */    public static function tearDownAfterClass()    {        parent::tearDownAfterClass();        $logger = Yii::getLogger();        $logger->flush();    }    /**     * Returns a test configuration param from /data/config.php.     * @param string $name params name     * @param mixed $default default value to use when param is not set.     * @return mixed  the value of the configuration param     */    public static function getParam($name, $default = null)    {        if (static::$params === null) {            static::$params = require __DIR__ . '/data/config.php';        }        return isset(static::$params[$name]) ? static::$params[$name] : $default;    }    /**     * Clean up after test.     * By default the application created with [[mockApplication]] will be destroyed.     */    protected function tearDown()    {        parent::tearDown();        $this->destroyApplication();    }    /**     * Populates Yii::$app with a new application     * The application will be destroyed on tearDown() automatically.     * @param array $config The application configuration, if needed     * @param string $appClass name of the application class to create     */    protected function mockApplication($config = [], $appClass = '\yii\console\Application')    {        new $appClass(ArrayHelper::merge([            'id' => 'testapp',            'basePath' => __DIR__,            'vendorPath' => $this->getVendorPath(),        ], $config));    }    protected function mockWebApplication($config = [], $appClass = '\yii\web\Application')    {        new $appClass(ArrayHelper::merge([            'id' => 'testapp',            'basePath' => __DIR__,            'vendorPath' => $this->getVendorPath(),            'aliases' => [                '@bower' => '@vendor/bower-asset',                '@npm' => '@vendor/npm-asset',            ],            'components' => [                'request' => [                    'cookieValidationKey' => 'wefJDF8sfdsfSDefwqdxj9oq',                    'scriptFile' => __DIR__ . '/index.php',                    'scriptUrl' => '/index.php',                ],            ],        ], $config));    }    protected function getVendorPath()    {        $vendor = dirname(dirname(__DIR__)) . '/vendor';        if (!is_dir($vendor)) {            $vendor = dirname(dirname(dirname(dirname(__DIR__))));        }        return $vendor;    }    /**     * Destroys application in Yii::$app by setting it to null.     */    protected function destroyApplication()    {        if (\Yii::$app && \Yii::$app->has('session', true)) {            \Yii::$app->session->close();        }        \Yii::$app = null;    }    /**     * Asserting two strings equality ignoring line endings.     * @param string $expected     * @param string $actual     * @param string $message     */    protected function assertEqualsWithoutLE($expected, $actual, $message = '')    {        $expected = str_replace(""\r\n"", ""\n"", $expected);        $actual = str_replace(""\r\n"", ""\n"", $actual);        $this->assertEquals($expected, $actual, $message);    }    /**     * Asserts that a haystack contains a needle ignoring line endings.     *     * @param mixed $needle     * @param mixed $haystack     * @param string $message     */    protected function assertContainsWithoutLE($needle, $haystack, $message = '')    {        $needle = str_replace(""\r\n"", ""\n"", $needle);        $haystack = str_replace(""\r\n"", ""\n"", $haystack);        $this->assertContains($needle, $haystack, $message);    }    /**     * Invokes a inaccessible method.     * @param $object     * @param $method     * @param array $args     * @param bool $revoke whether to make method inaccessible after execution     * @return mixed     * @since 2.0.11     */    protected function invokeMethod($object, $method, $args = [], $revoke = true)    {        $reflection = new \ReflectionObject($object);        $method = $reflection->getMethod($method);        $method->setAccessible(true);        $result = $method->invokeArgs($object, $args);        if ($revoke) {            $method->setAccessible(false);        }        return $result;    }    /**     * Sets an inaccessible object property to a designated value.     * @param $object     * @param $propertyName     * @param $value     * @param bool $revoke whether to make property inaccessible after setting     * @since 2.0.11     */    protected function setInaccessibleProperty($object, $propertyName, $value, $revoke = true)    {        $class = new \ReflectionClass($object);        while (!$class->hasProperty($propertyName)) {            $class = $class->getParentClass();        }        $property = $class->getProperty($propertyName);        $property->setAccessible(true);        $property->setValue($object, $value);        if ($revoke) {            $property->setAccessible(false);        }    }    /**     * Gets an inaccessible object property.     * @param $object     * @param $propertyName     * @param bool $revoke whether to make property inaccessible after getting     * @return mixed     */    protected function getInaccessibleProperty($object, $propertyName, $revoke = true)    {        $class = new \ReflectionClass($object);        while (!$class->hasProperty($propertyName)) {            $class = $class->getParentClass();        }        $property = $class->getProperty($propertyName);        $property->setAccessible(true);        $result = $property->getValue($object);        if ($revoke) {            $property->setAccessible(false);        }        return $result;    }    /**     * Asserts that value is one of expected values.     *     * @param mixed $actual     * @param array $expected     * @param string $message     */    public function assertIsOneOf($actual, array $expected, $message = '')    {        self::assertThat($actual, new IsOneOfAssert($expected), $message);    }    /**     * Changes db component config     * @param $db     */    protected function switchDbConnection($db)    {        $databases = $this->getParam('databases');        if (isset($databases[$db])) {            $database = $databases[$db];            Yii::$app->db->close();            Yii::$app->db->dsn = isset($database['dsn']) ? $database['dsn'] : null;            Yii::$app->db->username = isset($database['username']) ? $database['username'] : null;            Yii::$app->db->password = isset($database['password']) ? $database['password'] : null;        }    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
49,markrogoyski_math-php_Average_3436, Statistical averages\n,Statistički proseci,"class Average{    /**************************************************************************     * Averages of a list of numbers     **************************************************************************/    /**     * Calculate the mean average of a list of numbers     *     *     âˆ‘âŸ®xáµ¢âŸ¯     * xÌ„ = -----     *       n     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function mean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the average of an empty list of numbers');        }        return \array_sum($numbers) / \count($numbers);    }    /**     * Calculate the weighted mean average of a list of numbers     * https://en.wikipedia.org/wiki/Weighted_arithmetic_mean     *     *     âˆ‘âŸ®xáµ¢wáµ¢âŸ¯     * xÌ„ = -----     *      âˆ‘âŸ®wáµ¢âŸ¯     *     * @param float[] $numbers     * @param float[] $weights     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\BadDataException if the number of numbers and weights are not equal     */    public static function weightedMean(array $numbers, array $weights): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the weightedMean of an empty list of numbers');        }        if (empty($weights)) {            return Average::mean($numbers);        }        if (\count($numbers) !== \count($weights)) {            throw new Exception\BadDataException('Numbers and weights must have the same number of elements.');        }        $âˆ‘âŸ®xáµ¢wáµ¢âŸ¯ = \array_sum(\array_map(            function ($xáµ¢, $wáµ¢) {                return $xáµ¢ * $wáµ¢;            },            $numbers,            $weights        ));        $âˆ‘âŸ®wáµ¢âŸ¯ = \array_sum($weights);        return $âˆ‘âŸ®xáµ¢wáµ¢âŸ¯ / $âˆ‘âŸ®wáµ¢âŸ¯;    }    /**     * Calculate the median average of a list of numbers     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if kth-smallest k is out of bounds     */    public static function median(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median of an empty list of numbers');        }        if (\count($numbers) === 1) {            return \array_pop($numbers);        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // For odd number of numbers, take the middle indexed number        if (\count($numbers) % 2 == 1) {            $middle_index = \intdiv(\count($numbers), 2);            return self::kthSmallest($numbers, $middle_index);        }        // For even number of items, take the mean of the middle two indexed numbers        $left_middle_index  = \intdiv(\count($numbers), 2) - 1;        $left_median        = self::kthSmallest($numbers, $left_middle_index);        $right_middle_index = $left_middle_index + 1;        $right_median       = self::kthSmallest($numbers, $right_middle_index);        return self::mean([ $left_median, $right_median ]);    }    /**     * Return the kth smallest value in an array     * Uses a linear-time algorithm: O(n) time in worst case.     *     * if $a = [1,2,3,4,6,7]     *     * kthSmallest($a, 4) = 6     *     * Algorithm:     *  1) If n is small, just sort and return     *  2) Otherwise, group into 5-element subsets and mind the median     *  3) Find the median of the medians     *  4) Find L and U sets     *     - L is numbers lower than the median of medians     *     - U is numbers higher than the median of medians     *  5) Recursive step     *     - if k is the median of medians, return that     *     - Otherwise, recursively search in smaller group.     *     * @param float[] $numbers     * @param int    $k zero indexed - must be less than n (count of $numbers)     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if k â‰¥ n     */    public static function kthSmallest(array $numbers, int $k): float    {        $n = \count($numbers);        if ($n === 0) {            throw new Exception\BadDataException('Cannot find the k-th smallest of an empty list of numbers');        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException('k cannot be greater than or equal to the count of numbers');        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // If the array is 5 elements or smaller, use quicksort and return the element of interest.        if ($n <= 5) {            \sort($numbers);            return $numbers[$k];        }        // Otherwise, we are going to slice $numbers into 5-element slices and find the median of each.        $num_slices = \ceil($n / 5);        $median_array = [];        for ($i = 0; $i < $num_slices; $i++) {            $median_array[] = self::median(\array_slice($numbers, 5 * $i, 5));        }        // Then we find the median of the medians.        $median_of_medians = self::median($median_array);        // Next we walk the array and separate it into values that are greater than or less than this ""median of medians"".        $lower_upper   = self::splitAtValue($numbers, $median_of_medians);        $lower_number = \count($lower_upper['lower']);        $equal_number = $lower_upper['equal'];        // Lastly, we find which group of values our value of interest is in, and find it in the smaller array.        if ($k < $lower_number) {            return self::kthSmallest($lower_upper['lower'], $k);        } elseif ($k < ($lower_number + $equal_number)) {            return $median_of_medians;        } else {            return self::kthSmallest($lower_upper['upper'], $k - $lower_number - $equal_number);        }    }    /**     * Given an array and a value, separate the array into two groups,     * those values which are greater than the value, and those that are less     * than the value. Also, tell how many times the value appears in the array.     *     * @param float[] $numbers     * @param float   $value     *     * @return array     */    private static function splitAtValue(array $numbers, float $value): array    {        $lower        = [];        $upper        = [];        $number_equal = 0;        foreach ($numbers as $number) {            if ($number < $value) {                $lower[] = $number;            } elseif ($number > $value) {                $upper[] = $number;            } else {                $number_equal++;            }        }        return [            'lower' => $lower,            'upper' => $upper,            'equal' => $number_equal,        ];    }    /**     * Calculate the mode average of a list of numbers     * If multiple modes (bimodal, trimodal, etc.), all modes will be returned.     * Always returns an array, even if only one mode.     *     * @param float[] $numbers     *     * @return float[] of mode(s)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function mode(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the mode of an empty list of numbers');        }        // Count how many times each number occurs.        // Determine the max any number occurs.        // Find all numbers that occur max times.        $number_strings = \array_map('\strval', $numbers);        $number_counts  = \array_count_values($number_strings);        $max            = \max($number_counts);        $modes          = array();        foreach ($number_counts as $number => $count) {            if ($count === $max) {                $modes[] = $number;            }        }        // Cast back to numbers        return \array_map('\floatval', $modes);    }    /**     * Geometric mean     * A type of mean which indicates the central tendency or typical value of a set of numbers     * by using the product of their values (as opposed to the arithmetic mean which uses their sum).     * https://en.wikipedia.org/wiki/Geometric_mean     *                    __________     * Geometric mean = â¿âˆšaâ‚€aâ‚aâ‚‚ â‹¯     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function geometricMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the geometric mean of an empty list of numbers');        }        $n       = \count($numbers);        $aâ‚€aâ‚aâ‚‚â‹¯ = \array_reduce(            $numbers,            function ($carry, $a) {                return $carry * $a;            },            1        );        $â¿âˆšaâ‚€aâ‚aâ‚‚â‹¯ = \pow($aâ‚€aâ‚aâ‚‚â‹¯, 1 / $n);        return $â¿âˆšaâ‚€aâ‚aâ‚‚â‹¯;    }    /**     * Harmonic mean (subcontrary mean)     * The harmonic mean can be expressed as the reciprocal of the arithmetic mean of the reciprocals.     * Appropriate for situations when the average of rates is desired.     * https://en.wikipedia.org/wiki/Harmonic_mean     *     *     *        n     * H = ------     *      n  1     *      âˆ‘  -     *     â±â¼Â¹ xáµ¢     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\BadDataException if there are negative numbers     */    public static function harmonicMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the harmonic mean of an empty list of numbers');        }        $negativeValues = \array_filter(            $numbers,            function ($x) {                return $x < 0;            }        );        if (!empty($negativeValues)) {            throw new Exception\BadDataException('Harmonic mean cannot be computed for negative values.');        }        $n      = \count($numbers);        $âˆ‘1ï¼xáµ¢ = \array_sum(Map\Single::reciprocal($numbers));        return $n / $âˆ‘1ï¼xáµ¢;    }    /**     * Contraharmonic mean     * A function complementary to the harmonic mean.     * A special case of the Lehmer mean, Lâ‚‚(x), where p = 2.     * https://en.wikipedia.org/wiki/Contraharmonic_mean     *     * @param  float[] $numbers     *     * @return float     */    public static function contraharmonicMean(array $numbers): float    {        $p = 2;        return self::lehmerMean($numbers, $p);    }    /**     * Root mean square (quadratic mean)     * The square root of the arithmetic mean of the squares of a set of numbers.     * https://en.wikipedia.org/wiki/Root_mean_square     *           ___________     *          /xâ‚+Â²xâ‚‚Â²+ â‹¯     * x rms = / -----------     *        âˆš       n     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function rootMeanSquare(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the root mean square of an empty list of numbers');        }        $n = \count($numbers);        $xâ‚Â²ï¼‹xâ‚‚Â²ï¼‹â‹¯ = \array_sum(\array_map(            function ($x) {                return $x ** 2;            },            $numbers        ));        return \sqrt($xâ‚Â²ï¼‹xâ‚‚Â²ï¼‹â‹¯ / $n);    }    /**     * Quadradic mean (root mean square)     * Convenience function for rootMeanSquare     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quadraticMean(array $numbers): float    {        return self::rootMeanSquare($numbers);    }    /**     * Trimean (TM, or Tukey's trimean)     * A measure of a probability distribution's location defined as     * a weighted average of the distribution's median and its two quartiles.     * https://en.wikipedia.org/wiki/Trimean     *     *      Qâ‚ + 2Qâ‚‚ + Qâ‚ƒ     * TM = -------------     *            4     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function trimean(array $numbers): float    {        $quartiles = Descriptive::quartiles($numbers);        $Qâ‚        = $quartiles['Q1'];        $Qâ‚‚        = $quartiles['Q2'];        $Qâ‚ƒ        = $quartiles['Q3'];        return ($Qâ‚ + 2 * $Qâ‚‚ + $Qâ‚ƒ) / 4;    }    /**     * Interquartile mean (IQM)     * A measure of central tendency based on the truncated mean of the interquartile range.     * Only the data in the second and third quartiles is used (as in the interquartile range),     * and the lowest 25% and the highest 25% of the scores are discarded.     * https://en.wikipedia.org/wiki/Interquartile_mean     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\OutOfBoundsException     */    public static function interquartileMean(array $numbers): float    {        return self::truncatedMean($numbers, 25);    }    /**     * IQM (Interquartile mean)     * Convenience function for interquartileMean     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\OutOfBoundsException     */    public static function iqm(array $numbers): float    {        return self::truncatedMean($numbers, 25);    }    /**     * Cubic mean     * https://en.wikipedia.org/wiki/Cubic_mean     *              _________     *             / 1  n     * x cubic = Â³/  -  âˆ‘ xáµ¢Â³     *           âˆš   n â±â¼Â¹     *     * @param array $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function cubicMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the cubic mean of an empty list of numbers');        }        $n    = \count($numbers);        $âˆ‘xáµ¢Â³ = \array_sum(Map\Single::cube($numbers));        return \pow($âˆ‘xáµ¢Â³ / $n, 1 / 3);    }    /**     * Truncated mean (trimmed mean)     * The mean after discarding given parts of a probability distribution or sample     * at the high and low end, and typically discarding an equal amount of both.     * This number of points to be discarded is given as a percentage of the total number of points.     * https://en.wikipedia.org/wiki/Truncated_mean     *     * Trim count = floor( (trim percent / 100) * sample size )     *     * For example: [8, 3, 7, 1, 3, 9] with a trim of 20%     * First sort the list: [1, 3, 3, 7, 8, 9]     * Sample size = 6     * Then determine trim count: floot(20/100 * 6 ) = 1     * Trim the list by removing 1 from each end: [3, 3, 7, 8]     * Finally, find the mean: 5.2     *     * @param float[] $numbers     * @param int     $trim_percent Percent between 0-99     *     * @return float     *     * @throws Exception\OutOfBoundsException if trim percent is not between 0 and 99     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function truncatedMean(array $numbers, int $trim_percent): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the truncated mean of an empty list of numbers');        }        if ($trim_percent < 0 || $trim_percent > 99) {            throw new Exception\OutOfBoundsException('Trim percent must be between 0 and 99.');        }        $n          = \count($numbers);        $trim_count = \floor($n * ($trim_percent / 100));        \sort($numbers);        for ($i = 1; $i <= $trim_count; $i++) {            \array_shift($numbers);            \array_pop($numbers);        }        return self::mean($numbers);    }    /**     * Lehmer mean     * https://en.wikipedia.org/wiki/Lehmer_mean     *     *          âˆ‘xáµ¢áµ–     * Lp(x) = ------     *         âˆ‘xáµ¢áµ–â»Â¹     *     * Special cases:     *  L-âˆž(x) is the min(x)     *  Lâ‚€(x) is the harmonic mean     *  LÂ½(xâ‚€, xâ‚) is the geometric mean if computed against two numbers     *  Lâ‚(x) is the arithmetic mean     *  Lâ‚‚(x) is the contraharmonic mean     *  Lâˆž(x) is the max(x)     *     * @param  float[] $numbers     * @param  float   $p     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function lehmerMean(array $numbers, $p): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the lehmer mean of an empty list of numbers');        }        // Special cases for infinite p        if ($p == -\INF) {            return \min($numbers);        }        if ($p == \INF) {            return \max($numbers);        }        // Standard case for non-infinite p        $âˆ‘xáµ¢áµ–   = \array_sum(Map\Single::pow($numbers, $p));        $âˆ‘xáµ¢áµ–â»Â¹ = \array_sum(Map\Single::pow($numbers, $p - 1));        return $âˆ‘xáµ¢áµ– / $âˆ‘xáµ¢áµ–â»Â¹;    }    /**     * Generalized mean (power mean, HÃ¶lder mean)     * https://en.wikipedia.org/wiki/Generalized_mean     *     *          / 1  n    \ 1/p     * Mp(x) = |  -  âˆ‘ xáµ¢áµ–|     *          \ n â±â¼Â¹   /     *     * Special cases:     *  M-âˆž(x) is \min(x)     *  Mâ‚‹â‚(x) is the harmonic mean     *  Mâ‚€(x) is the geometric mean     *  Mâ‚(x) is the arithmetic mean     *  Mâ‚‚(x) is the quadratic mean     *  Mâ‚ƒ(x) is the cubic mean     *  Mâˆž(x) is max(X)     *     * @param  float[] $numbers     * @param  float   $p     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function generalizedMean(array $numbers, float $p): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the generalized mean of an empty list of numbers');        }        // Special cases for infinite p        if ($p == -\INF) {            return \min($numbers);        }        if ($p == \INF) {            return \max($numbers);        }        // Special case for p = 0 (geometric mean)        if ($p == 0) {            return self::geometricMean($numbers);        }        // Standard case for non-infinite p        $n    = \count($numbers);        $âˆ‘xáµ¢áµ– = \array_sum(Map\Single::pow($numbers, $p));        return \pow($âˆ‘xáµ¢áµ– / $n, 1 / $p);    }    /**     * Power mean (generalized mean)     * Convenience method for generalizedMean     *     * @param  float[] $numbers     * @param  float $p     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function powerMean(array $numbers, float $p): float    {        return self::generalizedMean($numbers, $p);    }    /**************************************************************************     * Moving averages (list of numbers)     **************************************************************************/    /**     * Simple n-point moving average SMA     * The unweighted mean of the previous n data.     *     * First calculate initial average:     *  â¿â»Â¹     *   âˆ‘ xáµ¢     *  áµ¢â‚Œâ‚€     *     * To calculating successive values, a new value comes into the sum and an old value drops out:     *  SMAtoday = SMAyesterday + NewNumber/N - DropNumber/N     *     * @param  float[] $numbers     * @param  int     $n       n-point moving average     *     * @return float[] of averages for each n-point time period     */    public static function simpleMovingAverage(array $numbers, int $n): array    {        $m   = \count($numbers);        $SMA = [];        // Counters        $new       = $n; // New value comes into the sum        $drop      = 0;  // Old value drops out        $yesterday = 0;  // Yesterday's SMA        // Base case: initial average        $SMA[] = \array_sum(\array_slice($numbers, 0, $n)) / $n;        // Calculating successive values: New value comes in; old value drops out        while ($new < $m) {            $SMA[] = $SMA[$yesterday] + ($numbers[$new] / $n) - ($numbers[$drop] / $n);            $drop++;            $yesterday++;            $new++;        }        return $SMA;    }    /**     * Cumulative moving average (CMA)     *     * Base case for initial average:     *         xâ‚€     *  CMAâ‚€ = --     *         1     *     * Standard case:     *         xáµ¢ + (i * CMAáµ¢â‚‹â‚)     *  CMAáµ¢ = -----------------     *              i + 1     *     * @param  float[] $numbers     *     * @return float[] of cumulative averages     */    public static function cumulativeMovingAverage(array $numbers): array    {        $m   = \count($numbers);        $CMA = [];        // Base case: first average is just itself        $CMA[] = $numbers[0];        for ($i = 1; $i < $m; $i++) {            $CMA[] = (($numbers[$i]) + ($CMA[$i - 1] * $i)) / ($i + 1);        }        return $CMA;    }    /**     * Weighted n-point moving average (WMA)     *     * Similar to simple n-point moving average,     * however, each n-point has a weight associated with it,     * and instead of dividing by n, we divide by the sum of the weights.     *     * Each weighted average = âˆ‘(weighted values) / âˆ‘(weights)     *     * @param  array  $numbers     * @param  int    $n       n-point moving average     * @param  array  $weights Weights for each n points     *     * @return array of averages     *     * @throws Exception\BadDataException if number of weights is not equal to number of n-points     */    public static function weightedMovingAverage(array $numbers, int $n, array $weights): array    {        if (\count($weights) !== $n) {            throw new Exception\BadDataException('Number of weights must equal number of n-points');        }        $m   = \count($numbers);        $âˆ‘w  = \array_sum($weights);        $WMA = [];        for ($i = 0; $i <= $m - $n; $i++) {            $âˆ‘wp   = \array_sum(Map\Multi::multiply(\array_slice($numbers, $i, $n), $weights));            $WMA[] = $âˆ‘wp / $âˆ‘w;        }        return $WMA;    }    /**     * Exponential moving average (EMA)     *     * The start of the EPA is seeded with the first data point.     * Then each day after that:     *  EMAtoday = Î±â‹…xtoday + (1-Î±)EMAyesterday     *     *   where     *    Î±: coefficient that represents the degree of weighting decrease, a constant smoothing factor between 0 and 1.     *     * @param array  $numbers     * @param int    $n       Length of the EPA     *     * @return array of exponential moving averages     */    public static function exponentialMovingAverage(array $numbers, int $n): array    {        $m   = \count($numbers);        $Î±   = 2 / ($n + 1);        $EMA = [];        // Start off by seeding with the first data point        $EMA[] = $numbers[0];        // Each day after: EMAtoday = Î±â‹…xtoday + (1-Î±)EMAyesterday        for ($i = 1; $i < $m; $i++) {            $EMA[] = ($Î± * $numbers[$i]) + ((1 - $Î±) * $EMA[$i - 1]);        }        return $EMA;    }    /**************************************************************************     * Averages of two numbers     **************************************************************************/    /**     * Arithmetic-Geometric mean     *     * First, compute the arithmetic and geometric means of x and y, calling them aâ‚ and gâ‚ respectively.     * Then, use iteration, with aâ‚ taking the place of x and gâ‚ taking the place of y.     * Both a and g will converge to the same mean.     * https://en.wikipedia.org/wiki/Arithmetic%E2%80%93geometric_mean     *     * x and y â‰¥ 0     * If x or y = 0, then agm = 0     * If x or y < 0, then NaN     *     * @param  float $x     * @param  float $y     *     * @return float     */    public static function arithmeticGeometricMean(float $x, float $y): float    {        // x or y < 0 = NaN        if ($x < 0 || $y < 0) {            return \NAN;        }        // x or y zero = 0        if ($x == 0 || $y == 0) {            return 0;        }        // Standard case x and y > 0        [$a, $g] = [$x, $y];        for ($i = 0; $i <= 10; $i++) {            [$a, $g] = [self::mean([$a, $g]), self::geometricMean([$a, $g])];        }        return $a;    }    /**     * Convenience method for arithmeticGeometricMean     *     * @param  float $x     * @param  float $y     *     * @return float     */    public static function agm(float $x, float $y): float    {        return self::arithmeticGeometricMean($x, $y);    }    /**     * Logarithmic mean     * A function of two non-negative numbers which is equal to their     * difference divided by the logarithm of their quotient.     *     * https://en.wikipedia.org/wiki/Logarithmic_mean     *     *  Mlm(x, y) = 0 if x = 0 or y = 0     *              x if x = y     *  otherwise:     *                y - x     *             -----------     *             ln y - ln x     *     * @param  float $x     * @param  float $y     *     * @return float     */    public static function logarithmicMean(float $x, float $y): float    {        if ($x == 0 || $y == 0) {            return 0;        }        if ($x == $y) {            return $x;        }        return ($y - $x) / (\log($y) - \log($x));    }    /**     * Heronian mean     * https://en.wikipedia.org/wiki/Heronian_mean     *            __     * H = â…“(A + âˆšAB + B)     *     * @param  float $A     * @param  float $B     *     * @return float     */    public static function heronianMean(float $A, float $B): float    {        return 1 / 3 * ($A + \sqrt($A * $B) + $B);    }    /**     * Identric mean     * https://en.wikipedia.org/wiki/Identric_mean     *                 ____     *          1     / xË£     * I(x,y) = - Ë£â»Ê¸/  --     *          â„¯   âˆš   yÊ¸     *     * @param  float $x     * @param  float $y     *     * @return float     *     * @throws Exception\OutOfBoundsException if x or y is â‰¤ 0     */    public static function identricMean(float $x, float $y): float    {        // x and y must be positive        if ($x <= 0 || $y <= 0) {            throw new Exception\OutOfBoundsException('x and y must be positive real numbers.');        }        // Special case: x if x = y        if ($x == $y) {            return $x;        }        // Standard case        $â„¯  = \M_E;        $xË£ = $x ** $x;        $yÊ¸ = $y ** $y;        return 1 / $â„¯ * \pow($xË£ / $yÊ¸, 1 / ($x - $y));    }    /**     * Get a report of all the averages over a list of numbers     * Includes mean, median mode, geometric mean, harmonic mean, quardratic mean     *     * @param array $numbers     *     * @return array [ mean, median, mode, geometric_mean, harmonic_mean,     *                 contraharmonic_mean, quadratic_mean, trimean, iqm, cubic_mean ]     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function describe(array $numbers): array    {        return [            'mean'                => self::mean($numbers),            'median'              => self::median($numbers),            'mode'                => self::mode($numbers),            'geometric_mean'      => self::geometricMean($numbers),            'harmonic_mean'       => self::harmonicMean($numbers),            'contraharmonic_mean' => self::contraharmonicMean($numbers),            'quadratic_mean'      => self::quadraticMean($numbers),            'trimean'             => self::trimean($numbers),            'iqm'                 => self::iqm($numbers),            'cubic_mean'          => self::cubicMean($numbers),        ];    }}",0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
50,markrogoyski_math-php_RegularGridInterpolator_3003," Find the indicies and norm distances for search point\\n\\n @param float[] $xi 1-dimensional array ( search point = [x,y,z ....] )\\n\\n @return array[] (indices in grid for search point, normDistances for search point)\\n",Pronađite indekse i normativne udaljenosti za tačku pretraživanja,"    private function findIndices($xi): array    {        $indices       = [];  // Find relevant edges between which xi are situated        $normDistances = [];  // Compute distance to lower edge in unity units        // Iterate through dimensions x-y-z-...>        // $grid - 1nd array, example all x values (or all y..)        // $x float, search point: x or y or z...        foreach (Iter::zip($xi, $this->grid) as [$x, $grid]) {            $gridSize = \count($grid);                       // Column count            $i        = Search::sorted($grid, $x) - 1;  // Min match index            if ($i < 0) {                $i = 0;            }            if ($i > $gridSize - 2) {                $i = $gridSize - 2;            }            $indices[]       = $i;            $lessValue       = $grid[$i];            $greaterValue    = $grid[$i + 1];            $normDistances[] = ($x - $lessValue) / ($greaterValue - $lessValue);        }        return [$indices, $normDistances];    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
51,yiisoft_yii2_BaseYii_998, Configures an object with the initial property values.\\n @param object $object the object to be configured\\n @param array $properties the property initial values given in terms of name-value pairs.\\n @return object the object itself\\n,Konfiguriše objekat sa početnim vrednostima svojstava,"class ClassmapController extends Controller{    public $defaultAction = 'create';    /**     * Creates a class map for the core Yii classes.     * @param string $root    the root path of Yii framework. Defaults to YII2_PATH.     * @param string $mapFile the file to contain the class map. Defaults to YII2_PATH . '/classes.php'.     */    public function actionCreate($root = null, $mapFile = null)    {        if ($root === null) {            $root = YII2_PATH;        }        $root = FileHelper::normalizePath($root);        if ($mapFile === null) {            $mapFile = YII2_PATH . '/classes.php';        }        $options = [            'filter' => function ($path) {                if (is_file($path)) {                    $file = basename($path);                    if ($file[0] < 'A' || $file[0] > 'Z') {                        return false;                    }                }                return null;            },            'only' => ['*.php'],            'except' => [                '/Yii.php',                '/BaseYii.php',                '/console/',                '/requirements/',            ],        ];        $files = FileHelper::findFiles($root, $options);        $map = [];        foreach ($files as $file) {            if (strpos($file, $root) !== 0) {                throw new Exception(""Something wrong: $file\n"");            }            $path = str_replace('\\', '/', substr($file, \strlen($root)));            $map[$path] = ""  'yii"" . substr(str_replace('/', '\\', $path), 0, -4) . ""' => YII2_PATH . '$path',"";        }        ksort($map);        $map = implode(""\n"", $map);        $output = <<<EOD<?php/** * Yii core class map. * * This file is automatically generated by the ""build classmap"" command under the ""build"" folder. * Do not modify it directly. * * @link http://www.yiiframework.com/ * @copyright Copyright (c) 2008 Yii Software LLC * @license http://www.yiiframework.com/license/ */return [$map];EOD;        if (is_file($mapFile) && file_get_contents($mapFile) === $output) {            echo ""Nothing changed.\n"";        } else {            file_put_contents($mapFile, $output);            echo ""Class map saved in $mapFile\n"";        }    }}",0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
52,yiisoft_yii2_ReleaseController_979, Extract changelog content for a specific version.\\n @param string $file\\n @param string $version\\n @return array\\n,Izdvoja sadržaj changelog-a  za određenu verziju,"    protected function resortChangelog($changelog)    {        // cleanup whitespace        foreach ($changelog as $i => $line) {            $changelog[$i] = rtrim($line);        }        $changelog = array_filter($changelog);        $i = 0;        ArrayHelper::multisort($changelog, function ($line) use (&$i) {            if (preg_match('/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/', $line, $m)) {                $o = ['Bug' => 'C', 'Enh' => 'D', 'Chg' => 'E', 'New' => 'F'];                return $o[$m[1]] . ' ' . (!empty($m[2]) ? $m[2] : 'AAAA' . $i++);            }            return 'B' . $i++;        }, SORT_ASC, SORT_NATURAL);        // re-add leading and trailing lines        array_unshift($changelog, '');        $changelog[] = '';        $changelog[] = '';        return $changelog;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
53,getgrav_grav_Debugger_1486, Initialize the debugger\\n\\n @return $this\\n @throws DebugBarException\\n,Inicijalizacija debagera,"    public function init()    {        if ($this->initialized) {            return $this;        }        $this->grav = Grav::instance();        $this->config = $this->grav['config'];        // Enable/disable debugger based on configuration.        $this->enabled = (bool)$this->config->get('system.debugger.enabled');        $this->censored = (bool)$this->config->get('system.debugger.censored', false);        if ($this->enabled) {            $this->initialized = true;            $clockwork = $debugbar = null;            switch ($this->config->get('system.debugger.provider', 'debugbar')) {                case 'clockwork':                    $this->clockwork = $clockwork = new Clockwork();                    break;                default:                    $this->debugbar = $debugbar = new DebugBar();            }            $plugins_config = (array)$this->config->get('plugins');            ksort($plugins_config);            if ($clockwork) {                $log = $this->grav['log'];                $clockwork->setStorage(new FileStorage('cache://clockwork'));                if (extension_loaded('xdebug')) {                    $clockwork->addDataSource(new XdebugDataSource());                }                if ($log instanceof Logger) {                    $clockwork->addDataSource(new MonologDataSource($log));                }                $timeline = $clockwork->timeline();                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Server');                    $event->finalize($this->requestTime, GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $event = $timeline->event('Loading');                    $event->finalize(GRAV_REQUEST_TIME, $this->currentTime);                }                $event = $timeline->event('Site Setup');                $event->finalize($this->currentTime, microtime(true));            }            if ($this->censored) {                $censored = ['CENSORED' => true];            }            if ($debugbar) {                $debugbar->addCollector(new PhpInfoCollector());                $debugbar->addCollector(new MessagesCollector());                if (!$this->censored) {                    $debugbar->addCollector(new RequestDataCollector());                }                $debugbar->addCollector(new TimeDataCollector($this->requestTime));                $debugbar->addCollector(new MemoryCollector());                $debugbar->addCollector(new ExceptionsCollector());                $debugbar->addCollector(new ConfigCollector($censored ?? (array)$this->config->get('system'), 'Config'));                $debugbar->addCollector(new ConfigCollector($censored ?? $plugins_config, 'Plugins'));                $debugbar->addCollector(new ConfigCollector($this->config->get('streams.schemes'), 'Streams'));                if ($this->requestTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Server', $debugbar['time']->getRequestStartTime(), GRAV_REQUEST_TIME);                }                if ($this->currentTime !== GRAV_REQUEST_TIME) {                    $debugbar['time']->addMeasure('Loading', GRAV_REQUEST_TIME, $this->currentTime);                }                $debugbar['time']->addMeasure('Site Setup', $this->currentTime, microtime(true));            }            $this->addMessage('Grav v' . GRAV_VERSION . ' - PHP ' . PHP_VERSION);            $this->config->debug();            if ($clockwork) {                $clockwork->info('System Configuration', $censored ?? $this->config->get('system'));                $clockwork->info('Plugins Configuration', $censored ?? $plugins_config);                $clockwork->info('Streams', $this->config->get('streams.schemes'));            }        }        return $this;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
54,markrogoyski_math-php_Correlation_3480, Ï„ - Kendall rank correlation coefficient (Kendall's tau)\\n\\n A statistic used to measure the ordinal association between two\\n measured quantities. It is a measure of rank correlation:\\n the similarity of the orderings of the data when ranked by each\\n of the quantities.\\n https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient\\n https://onlinecourses.science.psu.edu/stat509/node/158\\n\\n tau-a (no rank ties):\\n\\n        nc - nd\\n   Ï„ = ----------\\n       n(n - 1)/2\\n\\n   Where\\n     nc: number of concordant pairs\\n     nd: number of discordant pairs\\n\\n tau-b (rank ties exist):\\n\\n                 nc - nd\\n   Ï„ = -----------------------------\\n       âˆš(nc + nd + Xâ‚€)(nc + nd + Yâ‚€)\\n\\n   Where\\n     Xâ‚€: number of pairs tied only on the X variable\\n     Yâ‚€: number of pairs tied only on the Y variable\\n\\n @param array $X values for random variable X\\n @param array $Y values for random variable Y\\n\\n @todo Implement with algorithm faster than O(nÂ²)\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if both random variables do not have the same number of elements\\n,Kendallov koeficijent korelacije ranga (Kendallov tau) Statistika koja se koristi za merenje redne povezanosti između dve izmerene veličine. To je mera korelacije ranga: sličnost redosleda podataka kada ih rangira svaka količina,"    public static function kendallsTau(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('Both random variables must have the same number of elements');        }        $n = \count($X);        // Match X and Y pairs and sort by X rank        $xy = \array_map(            function ($x, $y) {                return [$x, $y];            },            $X,            $Y        );        \usort($xy, function ($a, $b) {            return $a[0] <=> $b[0];        });        // Initialize counters        $nc      = 0;  // concordant pairs        $nd      = 0;  // discordant pairs        $ties_x  = 0;  // ties xáµ¢ = xâ±¼        $ties_y  = 0;  // ties yáµ¢ = yâ±¼        $ties_xy = 0;  // ties xáµ¢ = xâ±¼ and yáµ¢ = yâ±¼        // Tally concordant, discordant, and tied pairs        for ($i = 0; $i < $n; $i++) {            for ($j = $i + 1; $j < $n; $j++) {                // xáµ¢ = xâ±¼ and yáµ¢ = yâ±¼ -- neither concordant or discordant                if ($xy[$i][self::X] == $xy[$j][self::X] && $xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_xy++;                // xáµ¢ = xâ±¼ -- neither concordant or discordant                } elseif ($xy[$i][self::X] == $xy[$j][self::X]) {                    $ties_x++;                // yáµ¢ = yâ±¼ -- neither concordant or discordant                } elseif ($xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_y++;                // xáµ¢ < xâ±¼ and yáµ¢ < yâ±¼ -- concordant                } elseif ($xy[$i][self::X] < $xy[$j][self::X] && $xy[$i][self::Y] < $xy[$j][self::Y]) {                    $nc++;                // xáµ¢ > xâ±¼ and yáµ¢ < yâ±¼ or  xáµ¢ < xâ±¼ and yáµ¢ > yâ±¼ -- discordant                } else {                    $nd++;                }            }        }        // Numerator: (number of concordant pairs) - (number of discordant pairs)        $âŸ®ncÂ âˆ’Â ndâŸ¯ = $nc - $nd;        /* tau-a (no rank ties):         *         *        nc - nd         *   Ï„ = ----------         *       n(n - 1)/2         */        if ($ties_x == 0 && $ties_y == 0) {            return $âŸ®ncÂ âˆ’Â ndâŸ¯ / (($n * ($n - 1)) / 2);        }        /* tau-b (rank ties exist):         *         *                 nc - nd         *   Ï„ = -----------------------------         *       âˆš(nc + nd + Xâ‚€)(nc + nd + Yâ‚€)         */        return $âŸ®ncÂ âˆ’Â ndâŸ¯ / \sqrt(($nc + $nd + $ties_x) * ($nc + $nd + $ties_y));    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
55,owncloud_core_CorsController_1436, WhiteLists a domain for CORS\n\n @NoAdminRequired\n @NoSubadminRequired\n\n @param string $domain The domain to whitelist\n @return JSONResponse\n, WhiteLists domen za CORS,"public function addDomain($domain) {if ($this->isValidUrl($domain)) {$userId = $this->userId;$domains = \json_decode($this->config->getUserValue($userId, 'core', 'domains', '[]'), true);$domains = \array_filter($domains);\array_push($domains, $domain);// In case same domain is added$domains = \array_unique($domains);// Store as comma separated string$domainsString = \json_encode($domains);$this->config->setUserValue($userId, 'core', 'domains', $domainsString);$this->logger->debug(""The domain {$domain} has been white-listed."", ['app' => $this->appName]);return new JSONResponse([ 'domains' => $domains]);} else {$errorMsg = $this->l10n->t(""Invalid url '%s'. Urls should be set up like 'http://www.example.com' or 'https://www.example.com'"", \strip_tags($domain));return new JSONResponse([ 'message' => $errorMsg ]);}",0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
56,composer_composer_InstalledVersions_2524," Returns a list of all package names which are present, either by being installed, replaced or provided\n\n @return string[]\n @psalm-return list<string>\n","Prikazuje listu svih prisutnih imena paketa, bilo instaliranjem, zamenom ili pružanjem","    public static function getInstalledPackages()    {        $packages = array();        foreach (self::getInstalled() as $installed) {            $packages[] = array_keys($installed['versions']);        }        if (1 === \count($packages)) {            return $packages[0];        }        return array_keys(array_flip(\call_user_func_array('array_merge', $packages)));    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
57,filp_whoops_FrameCollection_8407, Exposes a fluent interface for dealing with an ordered list\n of stack-trace frames.\n,Izlaže tečan interfejs koji se bavi uređenom listom stack-trace frejmova,"class FrameCollection implements ArrayAccess, IteratorAggregate, Serializable, Countable{    /**     * @var array[]     */    private $frames;    /**     * @param array $frames     */    public function __construct(array $frames)    {        $this->frames = array_map(function ($frame) {            return new Frame($frame);        }, $frames);    }    /**     * Filters frames using a callable, returns the same FrameCollection     *     * @param  callable        $callable     * @return FrameCollection     */    public function filter($callable)    {        $this->frames = array_values(array_filter($this->frames, $callable));        return $this;    }    /**     * Map the collection of frames     *     * @param  callable        $callable     * @return FrameCollection     */    public function map($callable)    {        // Contain the map within a higher-order callable        // that enforces type-correctness for the $callable        $this->frames = array_map(function ($frame) use ($callable) {            $frame = call_user_func($callable, $frame);            if (!$frame instanceof Frame) {                throw new UnexpectedValueException(                    ""Callable to "" . __CLASS__ . ""::map must return a Frame object""                );            }            return $frame;        }, $this->frames);        return $this;    }    /**     * Returns an array with all frames, does not affect     * the internal array.     *     * @todo   If this gets any more complex than this,     *         have getIterator use this method.     * @see    FrameCollection::getIterator     * @return array     */    public function getArray()    {        return $this->frames;    }    /**     * @see IteratorAggregate::getIterator     * @return ArrayIterator     */    public function getIterator()    {        return new ArrayIterator($this->frames);    }    /**     * @see ArrayAccess::offsetExists     * @param int $offset     */    public function offsetExists($offset)    {        return isset($this->frames[$offset]);    }    /**     * @see ArrayAccess::offsetGet     * @param int $offset     */    public function offsetGet($offset)    {        return $this->frames[$offset];    }    /**     * @see ArrayAccess::offsetSet     * @param int $offset     */    public function offsetSet($offset, $value)    {        throw new \Exception(__CLASS__ . ' is read only');    }    /**     * @see ArrayAccess::offsetUnset     * @param int $offset     */    public function offsetUnset($offset)    {        throw new \Exception(__CLASS__ . ' is read only');    }    /**     * @see Countable::count     * @return int     */    public function count()    {        return count($this->frames);    }    /**     * Count the frames that belongs to the application.     *     * @return int     */    public function countIsApplication()    {        return count(array_filter($this->frames, function (Frame $f) {            return $f->isApplication();        }));    }    /**     * @see Serializable::serialize     * @return string     */    public function serialize()    {        return serialize($this->frames);    }    /**     * @see Serializable::unserialize     * @param string $serializedFrames     */    public function unserialize($serializedFrames)    {        $this->frames = unserialize($serializedFrames);    }    /**     * @param Frame[] $frames Array of Frame instances, usually from $e->getPrevious()     */    public function prependFrames(array $frames)    {        $this->frames = array_merge($frames, $this->frames);    }    /**     * Gets the innermost part of stack trace that is not the same as that of outer exception     *     * @param  FrameCollection $parentFrames Outer exception frames to compare tail against     * @return Frame[]     */    public function topDiff(FrameCollection $parentFrames)    {        $diff = $this->frames;        $parentFrames = $parentFrames->getArray();        $p = count($parentFrames)-1;        for ($i = count($diff)-1; $i >= 0 && $p >= 0; $i--) {            /** @var Frame $tailFrame */            $tailFrame = $diff[$i];            if ($tailFrame->equals($parentFrames[$p])) {                unset($diff[$i]);            }            $p--;        }        return $diff;    }}",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
58,matomo-org_matomo_API_961," Given a segment, will return a list of the most used values for this particular segment.\n @param $segmentName\n @param $idSite\n @throws \\Exception\n @return array\n",Dati segment vratiće listu najčešće korišćenih vrednosti za ovaj određeni segment,"    public function getSuggestedValuesForSegment($segmentName, $idSite)    {        if (empty(Config::getInstance()->General['enable_segment_suggested_values'])) {            return array();        }        Piwik::checkUserHasViewAccess($idSite);        $maxSuggestionsToReturn = 30;        $segment = $this->findSegment($segmentName, $idSite);        // if segment has suggested values callback then return result from it instead        $suggestedValuesCallbackRequiresTable = false;        if (!empty($segment['suggestedValuesApi']) && is_string($segment['suggestedValuesApi']) && !Rules::isBrowserTriggerEnabled()) {            $now = Date::now()->setTimezone(Site::getTimezoneFor($idSite));            if (self::$_autoSuggestLookBack != 60) {                // in Auto suggest tests we need to assume now is in 2018...                // we do - 20 to make sure the year is still correct otherwise could end up being 2017-12-31 and the recorded visits are over several days in the tests we make sure to select the last day a visit was recorded                $now = $now->subDay(self::$_autoSuggestLookBack - 20);            }            // we want to avoid launching the archiver should browser archiving be enabled as this can be very slow... we then rather            // use the live api.            $period = 'year';            $date = $now->toString();            if ($now->toString('m') == '01') {                if (Rules::isArchivingDisabledFor(array($idSite), new Segment('', array($idSite)), 'range')) {                    $date = $now->subYear(1)->toString(); // use previous year data to avoid using range                } else {                    $period = 'range';                    $date = $now->subMonth(1)->toString() . ',' . $now->addDay(1)->toString();                }            }            $apiParts = explode('.', $segment['suggestedValuesApi']);            $meta = $this->getMetadata($idSite, $apiParts[0], $apiParts[1]);            $flat = !empty($meta[0]['actionToLoadSubTables']) && $meta[0]['actionToLoadSubTables'] == $apiParts[1];            $table = Request::processRequest($segment['suggestedValuesApi'], array(                'idSite' => $idSite,                'period' => $period,                'date' => $date,                'segment' => '',                'filter_offset' => 0,                'flat' => (int) $flat,                'filter_limit' => $maxSuggestionsToReturn            ));            if ($table && $table instanceof DataTable && $table->getRowsCount()) {                $values = [];                foreach ($table->getRowsWithoutSummaryRow() as $row) {                    $segment = $row->getMetadata('segment');                    $remove = array(                        $segmentName . Segment\SegmentExpression::MATCH_EQUAL,                        $segmentName . Segment\SegmentExpression::MATCH_STARTS_WITH                    );                    // we don't look at row columns since this could include rows that won't work eg Other summary rows. etc                    // and it is generally not reliable.                    if (!empty($segment) && preg_match('/^' . implode('|',$remove) . '/', $segment)) {                        $values[] = urldecode(urldecode(str_replace($remove, '', $segment)));                    }                }                $values = array_slice($values, 0, $maxSuggestionsToReturn);                $values = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $values);                return $values;            }        }        if (isset($segment['suggestedValuesCallback'])) {            $suggestedValuesCallbackRequiresTable = $this->doesSuggestedValuesCallbackNeedData(                $segment['suggestedValuesCallback']);            if (!$suggestedValuesCallbackRequiresTable) {                return call_user_func($segment['suggestedValuesCallback'], $idSite, $maxSuggestionsToReturn);            }        }        // if period=range is disabled, do not proceed        if (!Period\Factory::isPeriodEnabledForAPI('range')) {            return array();        }        if (!empty($segment['unionOfSegments'])) {            $values = array();            foreach ($segment['unionOfSegments'] as $unionSegmentName) {                $unionSegment = $this->findSegment($unionSegmentName, $idSite, $_showAllSegments = true);                try {                    $result = $this->getSuggestedValuesForSegmentName($idSite, $unionSegment, $maxSuggestionsToReturn);                    if (!empty($result)) {                        $values = array_merge($result, $values);                    }                } catch (\Exception $e) {                    // we ignore if there was no data found for $unionSegmentName                }            }            if (empty($values)) {                throw new \Exception(""There was no data to suggest for $segmentName"");            }        } else {            $values = $this->getSuggestedValuesForSegmentName($idSite, $segment, $maxSuggestionsToReturn);        }        $values = $this->getMostFrequentValues($values);        $values = array_slice($values, 0, $maxSuggestionsToReturn);        $values = array_map(array('Piwik\Common', 'unsanitizeInputValue'), $values);        return $values;    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
59,matomo-org_matomo_Archive_786, Returns the list of plugins that archive the given reports.\n\n @param array $archiveNames\n @return array\n,Prikazuje listu dodataka koji arhiviraju date izveštaje,    private function getRequestedPlugins($archiveNames)    {        $result = array();        foreach ($archiveNames as $name) {            $result[] = self::getPluginForReport($name);        }        return array_unique($result);    },0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
60,squizlabs_PHP_CodeSniffer_FileList_955, Retrieve the filtered file list as an array.\n\n @return array\n,Dohvatite filtriranu listu datoteka kao niz,"    public function getList()    {        $fileList = [];        foreach ($this->fileIterator as $file) {            $fileList[] = str_replace($this->rootPath, '', $file);        }        return $fileList;    }//end getList()",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
62,symfony_var-dumper_ArgsStub_9204, Represents a list of function arguments.\n\n @author Nicolas Grekas <p@tchwork.com>\n,Predstavlja listu argumenata funkcije,"final class CliContextProvider implements ContextProviderInterface{    public function getContext(): ?array    {        if ('cli' !== \PHP_SAPI) {            return null;        }        return [            'command_line' => $commandLine = implode(' ', $_SERVER['argv'] ?? []),            'identifier' => hash('crc32b', $commandLine.$_SERVER['REQUEST_TIME_FLOAT']),        ];    }}",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
63,yiisoft_yii2_DevController_956, Get a list of subdirectories for directory specified.\n @param string $dir directory to read\n\n @return array list of subdirectories\n,Dobija listu jezika prihvatljivih za klijentski pregledač,"    protected function listSubDirs($dir)    {        $list = [];        $handle = opendir($dir);        if ($handle === false) {            throw new InvalidParamException(""Unable to open directory: $dir"");        }        while (($file = readdir($handle)) !== false) {            if ($file === '.' || $file === '..') {                continue;            }            // ignore hidden directories            if (strpos($file, '.') === 0) {                continue;            }            if (is_dir(""$dir/$file"")) {                $list[] = ""$dir/$file"";            }        }        closedir($handle);        return $list;    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
64,PHPOffice_PHPExcel_CachedObjectStorageFactory_132, Return the list of all available cache storage methods\\n\\n @return string[]\\n,Vratite listu svih dostupnih metoda keš memorije,"    public static function getCacheStorageMethods()    {        $activeMethods = array();        foreach (self::$storageMethods as $storageMethod) {            $cacheStorageClass = 'PHPExcel_CachedObjectStorage_' . $storageMethod;            if (call_user_func(array($cacheStorageClass, 'cacheMethodIsAvailable'))) {                $activeMethods[] = $storageMethod;            }        }        return $activeMethods;    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
65,phalcon_cphalcon_functions_198, Get postgresql db options\n,Dohvatite postgresql db opcije,"    function getOptionsPostgresql(): array    {        return [            'host'     => env('DATA_POSTGRES_HOST'),            'username' => env('DATA_POSTGRES_USER'),            'password' => env('DATA_POSTGRES_PASS'),            'port'     => env('DATA_POSTGRES_PORT'),            'dbname'   => env('DATA_POSTGRES_NAME'),            'schema'   => env('DATA_POSTGRES_SCHEMA'),        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
66,phalcon_cphalcon_functions_200, Get sqlite db options\n,Dohvatite sqlite db opcije,"    function getOptionsSqlite(): array    {        return [            'dbname' => codecept_root_dir(env('DATA_SQLITE_NAME')),        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
67,phalcon_cphalcon_functions_2095, Get mysql db options\n,Dohvatite mysql db opcije,"    function getOptionsMysql(): array    {        return [            'host'     => env('DATA_MYSQL_HOST'),            'username' => env('DATA_MYSQL_USER'),            'password' => env('DATA_MYSQL_PASS'),            'dbname'   => env('DATA_MYSQL_NAME'),            'port'     => env('DATA_MYSQL_PORT'),            'charset'  => env('DATA_MYSQL_CHARSET'),        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
68,markrogoyski_math-php_MatrixFactory_2688, Matrix factory to create matrices of all types.\n Use factory instead of instantiating individual Matrix classes.\n,Fabrika matrica za stvaranje matrica svih tipova. Koristitite fabriku umesto instanciranja pojedinačnih klasa matrica,"class MatrixFactory{    /**     * Factory method     *     * @param  number[][] $A 2-dimensional array of Matrix data     * @param float|null $Îµ Optional error tolerance     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public static function create(array $A, ?float $Îµ = null): Matrix    {        self::checkParams($A);        $matrix_type = self::determineMatrixType($A);        switch ($matrix_type) {            case 'numeric':            case 'numeric_square':                return self::createNumeric($A, $Îµ);            case 'complex':                return new ComplexMatrix($A);            case 'object':                return new ObjectMatrix($A);            case 'object_square':                return new ObjectSquareMatrix($A);        }        throw new Exception\IncorrectTypeException('Unknown matrix type: ' . print_r($A, true));    }    /**     * @param number[][] $A     * @param float|null $Îµ Optional error tolerance     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     */    public static function createNumeric(array $A, ?float $Îµ = null): NumericMatrix    {        $m = \count($A);        $n = \count($A[0]);        if ($m === $n) {            $A = new NumericSquareMatrix($A);            $A->setError($Îµ);            return $A;        }        $A = new NumericMatrix($A);        $A->setError($Îµ);        return $A;    }    /**     * Factory method to create a matrix from an array of Vectors     *     * Example:     *        [1]       [4]        [7]       [8]     *   Xâ‚ = [2]  Xâ‚‚ = [2]   Xâ‚ƒ = [8]  Xâ‚„ = [4]     *        [1]       [13]       [1]       [5]     *     *       [1  4 7 8]     *   R = [2  2 8 4]     *       [1 13 1 5]     *     * @param  Vector[] $A array of Vectors     * @param float|null $Îµ Optional error tolerance     *     * @return Matrix     *     * @throws Exception\MatrixException if the Vectors are not all the same length     * @throws Exception\IncorrectTypeException     * @throws Exception\BadDataException     */    public static function createFromVectors(array $A, ?float $Îµ = null): NumericMatrix    {        // Check that all vectors are the same length        $m = $A[0]->getN();        $n = \count($A);        for ($j = 1; $j < $n; $j++) {            if ($A[$j]->getN() !== $m) {                throw new Exception\MatrixException('Vectors being combined into matrix have different lengths');            }        }        // Concatenate all the vectors        $R = [];        foreach ($A as $V) {            $R[] = $V->getVector();        }        // Transpose to create matrix from the vector columns        return (self::createNumeric($R, $Îµ))->transpose();    }    /**     * Column vector (column matrix)     * m Ã— 1 matrix consisting of a single column of m elements.     *     *     [xâ‚]     * x = [xâ‚‚]     *     [â‹® ]     *     [xm]     *     * @param array $A m Ã— 1 vector representing the matrix     *     * @return Matrix     */    public static function createFromColumnVector(array $A): Matrix    {        foreach ($A as $item) {            if (\is_array($item)) {                throw new Exception\BadDataException('Column vector data must be a one-dimensional array');            }        }        $R = [];        foreach ($A as $value) {            $R[] = [$value];        }        return self::create($R);    }    /**     * Row vector (row matrix)     * 1 Ã— n matrix consisting of a single row of n elements.     *     * x = [xâ‚ xâ‚‚ â‹¯ xn]     *     * @param array $A 1 Ã— n vector representing the matrix     *     * @return Matrix     */    public static function createFromRowVector(array $A): Matrix    {        foreach ($A as $item) {            if (\is_array($item)) {                throw new Exception\BadDataException('Row vector data must be a one-dimensional array');            }        }        $R = [$A];        return self::create($R);    }    /**     * Factory method     *     * @param  array[] $A 2-dimensional array of Matrix data     *     * @return FunctionMatrix     */    public static function createFunctionMatrix(array $A): FunctionMatrix    {        self::checkParams($A);        if (!is_callable($A[0][0])) {            throw new Exception\BadDataException('FunctionMatrix must be made of functions - got ' . gettype($A[0][0]));        }        return new FunctionMatrix($A);    }    /**************************************************************************     * SPECIAL MATRICES - Not created from an array of arrays     *  - identity     *  - exchange     *  - downshiftPermutation     *  - upshiftPermutation     *  - zero     *  - one     *  - eye     *  - diagonal     *  - hilbert     *  - vandermonde     *  - givens     **************************************************************************/    /**     * Identity matrix - n x n matrix with ones in the diagonal     *     * Example:     *  n = 3;     *     *      [1 0 0]     *  A = [0 1 0]     *      [0 0 1]     *     * @param int   $n size of matrix     *     * @return NumericSquareMatrix     *     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function identity(int $n): NumericSquareMatrix    {        if ($n < 0) {            throw new Exception\OutOfBoundsException(""n must be â‰¥ 0. n = $n"");        }        $R = [];        for ($i = 0; $i < $n; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $i == $j ? 1 : 0;            }        }        return new NumericSquareMatrix($R);    }    /**     * Exchange matrix - n x n matrix with ones in the reverse diagonal     * Row-reversed, or column-reversed version of the identity matrix.     * https://en.wikipedia.org/wiki/Exchange_matrix     *     * Example:     *  n = 3;     *     *      [0 0 1]     *  A = [0 1 0]     *      [1 0 0]     *     * @param int $n size of matrix     *     * @return NumericSquareMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function exchange(int $n): NumericSquareMatrix    {        if ($n < 0) {            throw new Exception\OutOfBoundsException(""n must be â‰¥ 0. n = $n"");        }        $R = [];        $one = $n - 1;        for ($i = 0; $i < $n; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $j == $one ? 1 : 0;            }            $one--;        }        return new NumericSquareMatrix($R);    }    /**     * Downshift permutation matrix     * Pushes the components of a vector down one notch with wraparound     *     *       [0, 0, 0, 1] [xâ‚]   [xâ‚„]     *       [1, 0, 0, 0] [xâ‚‚]   [xâ‚]     * Dâ‚„x = [0, 1, 0, 0] [xâ‚ƒ] = [xâ‚‚]     *       [0, 0, 1, 0] [xâ‚„]   [xâ‚ƒ]     *     * @param  int $n     *     * @return NumericSquareMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException if n < 0     */    public static function downshiftPermutation(int $n): NumericSquareMatrix    {        $I = self::identity($n)->getMatrix();        $bottom_row = \array_pop($I);        \array_unshift($I, $bottom_row);        return new NumericSquareMatrix($I);    }    /**     * Upshift permutation matrix - Dáµ€     * Pushes the components of a vector up one notch with wraparound     *     * @param  int $n     *     * @return Matrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     */    public static function upshiftPermutation(int $n): Matrix    {        return self::downshiftPermutation($n)->transpose();    }    /**     * Zero matrix - m x n matrix with all elements being zeros     *     * Example:     *  m = 3; n = 3     *     *      [0 0 0]     *  A = [0 0 0]     *      [0 0 0]     *     * @param int $m rows     * @param int $n columns     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m < 1 or n < 1     */    public static function zero(int $m, int $n): NumericMatrix    {        if ($m < 1 || $n < 1) {            throw new Exception\OutOfBoundsException(""m and n must be > 0. m = $m, n = $n"");        }        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 0;            }        }        return self::createNumeric($R);    }    /**     * Ones matrix - m x n matrix with all elements being ones     *     * Example:     *  m = 3; n = 3     *     *      [1 1 1]     *  A = [1 1 1]     *      [1 1 1]     *     * @param int $m rows     * @param int $n columns     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m or n < 1     */    public static function one(int $m, int $n): NumericMatrix    {        if ($m < 1 || $n < 1) {            throw new Exception\OutOfBoundsException(""m and n must be > 0. m = $m, n = $n"");        }        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 1;            }        }        return self::createNumeric($R);    }    /**     * Eye matrix - ones on the k diagonal and zeros everywhere else.     * Diagonal can start at any column.     * Option to set the diagonal to any number.     *     * Example:     *  m = 3; n = 3; k = 1; x = 1 (3x3 matrix with 1s on the kth (1) diagonal)     *     *      [0 1 0]     *  A = [0 0 1]     *      [0 0 0]     *     * @param int        $m number of rows     * @param int        $n number of columns     * @param int        $k Diagonal to fill with xs     * @param float|null $x (optional; default 1)     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException if m, n, or k are < 0; if k >= n     */    public static function eye(int $m, int $n, int $k, float $x = null): NumericMatrix    {        if ($n < 0 || $m < 0 || $k < 0) {            throw new Exception\OutOfBoundsException(""m, n and k must be â‰¥ 0. m = $m, n = $n, k = $k"");        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException(""k must be < n. k = $k, n = $n"");        }        $x = $x ?? 1;        $R = (self::zero($m, $n))->getMatrix();        for ($i = 0; $i < $m; $i++) {            if (($k + $i) < $n) {                $R[$i][$k + $i] = $x;            }        }        return self::createNumeric($R);    }    /**     * A Diagonal Matrix is constructed from a single-row array.     * The elements of this array are placed on the diagonal of a square matrix.     *     * Example:     *  D = [1, 2, 3]     *     *     [1 0 0]     * A = [0 2 0]     *     [0 0 3]     *     * @param array $D elements of the diagonal     *     * @return NumericDiagonalMatrix     *     * @throws Exception\MatrixException     */    public static function diagonal(array $D): NumericDiagonalMatrix    {        $m = \count($D);        $A = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $m; $j++) {                if ($i == $j) {                    $A[$i][$j] = $D[$i];                } else {                    $A[$i][$j] = 0;                }            }        }        return new NumericDiagonalMatrix($A);    }    /**     * Hilbert matrix - a square matrix with entries being the unit fractions     * https://en.wikipedia.org/wiki/Hilbert_matrix     *     *           1     * Hij = ---------     *       i + j - 1     *     * Example: n = 5     *     *     [1 Â½ â…“ Â¼ â…•]     *     [Â½ â…“ Â¼ â…• â…™]     * H = [â…“ Â¼ â…• â…™ â…]     *     [Â¼ â…• â…™ â… â…›]     *     [â…• â…™ â… â…› â…‘]     *     * @param int $n     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     * @throws Exception\OutOfBoundsException     */    public static function hilbert(int $n): NumericMatrix    {        if ($n < 1) {            throw new Exception\OutOfBoundsException(""n must be > 0. m = $n"");        }        $H = [];        for ($i = 1; $i <= $n; $i++) {            for ($j = 1; $j <= $n; $j++) {                $H[$i - 1][$j - 1] = 1 / ($i + $j - 1);            }        }        return new NumericSquareMatrix($H);    }    /**     * Create the Vandermonde Matrix from a simple array.     *     * @param array $M (Î±â‚, Î±â‚‚, Î±â‚ƒ â‹¯ Î±m)     * @param int   $n     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     */    public static function vandermonde(array $M, int $n): NumericMatrix    {        $A = [];        foreach ($M as $row => $Î±) {            for ($i = 0; $i < $n; $i++) {                $A[$row][$i] = $Î± ** $i;            }        }        return self::createNumeric($A);    }   /**    * Construct a Givens rotation matrix    *    *               [  1 â‹¯ 0 â‹¯ 0 â‹¯ 0  ]    *               [  â‹® â‹± â‹®   â‹®   â‹®   ]    *               [  0 â‹¯ c â‹¯-s â‹¯ 0  ]    * G (ð’¾,ð’¿,Î¸) =   [  â‹®   â‹®  â‹± â‹®  â‹®  ]    *               [  0 â‹¯ s â‹¯ c â‹¯ 0  ]    *               [  â‹®    â‹®   â‹® â‹± â‹® ]    *               [  0 â‹¯ 0 â‹¯ 0 â‹¯ 1 ]    *    * https://en.wikipedia.org/wiki/Givens_rotation    *    * @param int   $m The row in G in which the top of the rotation lies    * @param int   $n The column in G in which the left of the rotation lies    * @param float $angle The angle to use in the trigonometric functions    * @param int   $size The total number of rows in G    *    * @return NumericMatrix    *    * @throws Exception\BadDataException    * @throws Exception\MathException    * @throws Exception\OutOfBoundsException    */    public static function givens(int $m, int $n, float $angle, int $size): NumericMatrix    {        if ($m >= $size || $n >= $size || $m < 0 || $n < 0) {            throw new Exception\OutOfBoundsException(""m and n must be within the matrix"");        }        $G         = MatrixFactory::identity($size)->getMatrix();        $G[$m][$m] = \cos($angle);        $G[$n][$n] = \cos($angle);        $G[$m][$n] = -1 * \sin($angle);        $G[$n][$m] = \sin($angle);        return self::createNumeric($G);    }    /**     * Create a Matrix of random numbers     *     * @param int $m   number of rows     * @param int $n   number of columns     * @param int $min lower bound for the random number (optional - default: 0)     * @param int $max upper bound for the random number (optional - default: 20)     *     * @return NumericMatrix     *     * @throws Exception\BadDataException     * @throws Exception\MathException     */    public static function random(int $m, int $n, int $min = 0, int $max = 20): NumericMatrix    {        $A = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $A[$i][$j] = \rand($min, $max);            }        }        return self::createNumeric($A);    }    /* ************************************************************************     * PRIVATE HELPER METHODS     * ***********************************************************************/    /**     * Check input parameters     *     * @param  array    $A     *     * @throws Exception\BadDataException if array data not provided for matrix creation     * @throws Exception\MatrixException if any row has a different column count     */    private static function checkParams(array $A): void    {        if (empty($A)) {            throw new Exception\BadDataException('Array data not provided for Matrix creation');        }        if (isset($A[0]) && \is_array($A[0])) {            $column_count = \count($A[0]);            foreach ($A as $i => $row) {                if (\count($row) !== $column_count) {                    throw new Exception\MatrixException(""Row $i has a different column count: "" . \count($row) . ""; was expecting $column_count."");                }            }        }    }    /**     * Determine what type of matrix to create     *     * @param  array[] $A 2-dimensional array of Matrix data     *     * @return string indicating what matrix type to create     */    private static function determineMatrixType(array $A): string    {        $m = \count($A);        $n = \count($A[0]);        // Object (closure) matrices        if (\is_object($A[0][0])) {            if ($A[0][0] instanceof Complex) {                return 'complex';            }            return $m === $n                ? 'object_square'                : 'object';        }        // Numeric matrix        if (\is_numeric($A[0][0])) {            return $m === $n                ? 'numeric_square'                : 'numeric';        }        // Unknown or bad data        return 'unknown';    }}",0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
69,markrogoyski_math-php_Eigenvector_2617, Find the zero columns\n\n @param  NumericMatrix $M\n\n @return array\n,Pronađite nulte kolone,"    private static function findZeroColumns(NumericMatrix $M): array    {        $m = $M->getM();        $zero_columns = [];        for ($i = 0; $i < $M->getN(); $i++) {            if ($M->getColumn($i) == \array_fill(0, $m, 0)) {                $zero_columns[] = $i;            }        }        return $zero_columns;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
70,markrogoyski_math-php_Matrix_2631," Returns the elements on the diagonal of a square matrix as an array\n     [1 2 3]\n A = [4 5 6]\n     [7 8 9]\n\n getDiagonalElements($A) = [1, 5, 9]\n\n @return array\n",Vraća elemente na dijagonali kvadratne matrice kao niz,"    public function getDiagonalElements(): array    {        $diagonal = [];        for ($i = 0; $i < \min($this->m, $this->n); $i++) {            $diagonal[] = $this->A[$i][$i];        }        return $diagonal;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
71,markrogoyski_math-php_Matrix_2633," Returns the elements on the subdiagonal of a square matrix as an array\n     [1 2 3]\n A = [4 5 6]\n     [7 8 9]\n\n getSubdiagonalElements($A) = [4, 8]\n\n http://mathworld.wolfram.com/Subdiagonal.html\n\n @return array\n",Vraća elemente na poddijagonali kvadratne matrice kao niz,    public function getSubdiagonalElements(): array    {        $subdiagonal = [];        if ($this->isSquare()) {            for ($i = 1; $i < $this->m; $i++) {                $subdiagonal[] = $this->A[$i][$i - 1];            }        }        return $subdiagonal;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
72,symfony_process_Process_1490, Returns PTY state.\\n\\n @return bool\\n,Vraća PTY stanje,"    public function getWorkingDirectory()    {        if (null === $this->cwd) {            // getcwd() will return false if any one of the parent directories does not have            // the readable or search mode set, even if the current directory does            return getcwd() ?: null;        }        return $this->cwd;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
73,bobthecow_psysh_Configuration_1485, Get the local PsySH config file.\n\n Searches for a project specific config file `.psysh.php` in the current\n working directory.\n\n @return string\n,Dohvatanje lokalne datoteke za konfiguraciju PsySH. Pretražuje konfiguracionu datoteku specifičnu za projekat `.psish.php` u trenutnom radnom direktorijumu,    public function getLocalConfigFile()    {        $localConfig = \getcwd().'/.psysh.php';        if (@\is_file($localConfig)) {            return $localConfig;        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
74,symfony_process_ProcessFailedExceptionTest_1552, Tests ProcessFailedException throws exception if the process was successful.\\\\n,Testovi ProcessFailedException bacaju izuzetak ako je proces bio uspešan,"    public function testDisabledOutputInFailedExceptionDoesNotPopulateOutput()    {        $cmd = 'php';        $exitCode = 1;        $exitText = 'General error';        $workingDirectory = getcwd();        $process = $this->getMockBuilder(Process::class)->setMethods(['isSuccessful', 'isOutputDisabled', 'getExitCode', 'getExitCodeText', 'getOutput', 'getErrorOutput', 'getWorkingDirectory'])->setConstructorArgs([[$cmd]])->getMock();        $process->expects($this->once())            ->method('isSuccessful')            ->willReturn(false);        $process->expects($this->never())            ->method('getOutput');        $process->expects($this->never())            ->method('getErrorOutput');        $process->expects($this->once())            ->method('getExitCode')            ->willReturn($exitCode);        $process->expects($this->once())            ->method('getExitCodeText')            ->willReturn($exitText);        $process->expects($this->once())            ->method('isOutputDisabled')            ->willReturn(true);        $process->expects($this->once())            ->method('getWorkingDirectory')            ->willReturn($workingDirectory);        $exception = new ProcessFailedException($process);        $this->assertEquals(            ""The command \""$cmd\"" failed.\n\nExit Code: $exitCode($exitText)\n\nWorking directory: {$workingDirectory}"",            str_replace(""'php'"", 'php', $exception->getMessage())        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
75,squizlabs_PHP_CodeSniffer_Config_871, Processes a long (--example) command line argument.\\n\\n @param string $arg The command line argument.\\n @param int    $pos The position of the argument on the command line.\\n\\n @return void\\n @throws \\\\PHP_CodeSniffer\\\\Exceptions\\\\DeepExitException\\n,Obrađuje dugi (--primer) argument gomandne linije,"    public function processLongArgument($arg, $pos)    {        switch ($arg) {        case 'help':            ob_start();            $this->printUsage();            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'version':            $output  = 'PHP_CodeSniffer version '.self::VERSION.' ('.self::STABILITY.') ';            $output .= 'by Squiz (http://www.squiz.net)'.PHP_EOL;            throw new DeepExitException($output, 0);        case 'colors':            if (isset(self::$overriddenDefaults['colors']) === true) {                break;            }            $this->colors = true;            self::$overriddenDefaults['colors'] = true;            break;        case 'no-colors':            if (isset(self::$overriddenDefaults['colors']) === true) {                break;            }            $this->colors = false;            self::$overriddenDefaults['colors'] = true;            break;        case 'cache':            if (isset(self::$overriddenDefaults['cache']) === true) {                break;            }            if (defined('PHP_CODESNIFFER_IN_TESTS') === false) {                $this->cache = true;                self::$overriddenDefaults['cache'] = true;            }            break;        case 'no-cache':            if (isset(self::$overriddenDefaults['cache']) === true) {                break;            }            $this->cache = false;            self::$overriddenDefaults['cache'] = true;            break;        case 'ignore-annotations':            if (isset(self::$overriddenDefaults['annotations']) === true) {                break;            }            $this->annotations = false;            self::$overriddenDefaults['annotations'] = true;            break;        case 'config-set':            if (isset($this->cliArgs[($pos + 1)]) === false                || isset($this->cliArgs[($pos + 2)]) === false            ) {                $error  = 'ERROR: Setting a config option requires a name and value'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $key     = $this->cliArgs[($pos + 1)];            $value   = $this->cliArgs[($pos + 2)];            $current = self::getConfigData($key);            try {                $this->setConfigData($key, $value);            } catch (\Exception $e) {                throw new DeepExitException($e->getMessage().PHP_EOL, 3);            }            $output = 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            if ($current === null) {                $output .= ""Config value \""$key\"" added successfully"".PHP_EOL;            } else {                $output .= ""Config value \""$key\"" updated successfully; old value was \""$current\"""".PHP_EOL;            }            throw new DeepExitException($output, 0);        case 'config-delete':            if (isset($this->cliArgs[($pos + 1)]) === false) {                $error  = 'ERROR: Deleting a config option requires the name of the option'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $output = 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            $key     = $this->cliArgs[($pos + 1)];            $current = self::getConfigData($key);            if ($current === null) {                $output .= ""Config value \""$key\"" has not been set"".PHP_EOL;            } else {                try {                    $this->setConfigData($key, null);                } catch (\Exception $e) {                    throw new DeepExitException($e->getMessage().PHP_EOL, 3);                }                $output .= ""Config value \""$key\"" removed successfully; old value was \""$current\"""".PHP_EOL;            }            throw new DeepExitException($output, 0);        case 'config-show':            ob_start();            $data = self::getAllConfigData();            echo 'Using config file: '.self::$configDataFile.PHP_EOL.PHP_EOL;            $this->printConfigData($data);            $output = ob_get_contents();            ob_end_clean();            throw new DeepExitException($output, 0);        case 'runtime-set':            if (isset($this->cliArgs[($pos + 1)]) === false                || isset($this->cliArgs[($pos + 2)]) === false            ) {                $error  = 'ERROR: Setting a runtime config option requires a name and value'.PHP_EOL.PHP_EOL;                $error .= $this->printShortUsage(true);                throw new DeepExitException($error, 3);            }            $key   = $this->cliArgs[($pos + 1)];            $value = $this->cliArgs[($pos + 2)];            $this->cliArgs[($pos + 1)] = '';            $this->cliArgs[($pos + 2)] = '';            self::setConfigData($key, $value, true);            if (isset(self::$overriddenDefaults['runtime-set']) === false) {                self::$overriddenDefaults['runtime-set'] = [];            }            self::$overriddenDefaults['runtime-set'][$key] = true;            break;        default:            if (substr($arg, 0, 7) === 'sniffs=') {                if (isset(self::$overriddenDefaults['sniffs']) === true) {                    break;                }                $sniffs = explode(',', substr($arg, 7));                foreach ($sniffs as $sniff) {                    if (substr_count($sniff, '.') !== 2) {                        $error  = 'ERROR: The specified sniff code ""'.$sniff.'"" is invalid'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                }                $this->sniffs = $sniffs;                self::$overriddenDefaults['sniffs'] = true;            } else if (substr($arg, 0, 8) === 'exclude=') {                if (isset(self::$overriddenDefaults['exclude']) === true) {                    break;                }                $sniffs = explode(',', substr($arg, 8));                foreach ($sniffs as $sniff) {                    if (substr_count($sniff, '.') !== 2) {                        $error  = 'ERROR: The specified sniff code ""'.$sniff.'"" is invalid'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                }                $this->exclude = $sniffs;                self::$overriddenDefaults['exclude'] = true;            } else if (defined('PHP_CODESNIFFER_IN_TESTS') === false                && substr($arg, 0, 6) === 'cache='            ) {                if ((isset(self::$overriddenDefaults['cache']) === true                    && $this->cache === false)                    || isset(self::$overriddenDefaults['cacheFile']) === true                ) {                    break;                }                // Turn caching on.                $this->cache = true;                self::$overriddenDefaults['cache'] = true;                $this->cacheFile = Util\Common::realpath(substr($arg, 6));                // It may not exist and return false instead.                if ($this->cacheFile === false) {                    $this->cacheFile = substr($arg, 6);                    $dir = dirname($this->cacheFile);                    if (is_dir($dir) === false) {                        $error  = 'ERROR: The specified cache file path ""'.$this->cacheFile.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    if ($dir === '.') {                        // Passed cache file is a file in the current directory.                        $this->cacheFile = getcwd().'/'.basename($this->cacheFile);                    } else {                        if ($dir[0] === '/') {                            // An absolute path.                            $dir = Util\Common::realpath($dir);                        } else {                            $dir = Util\Common::realpath(getcwd().'/'.$dir);                        }                        if ($dir !== false) {                            // Cache file path is relative.                            $this->cacheFile = $dir.'/'.basename($this->cacheFile);                        }                    }                }//end if                self::$overriddenDefaults['cacheFile'] = true;                if (is_dir($this->cacheFile) === true) {                    $error  = 'ERROR: The specified cache file path ""'.$this->cacheFile.'"" is a directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if (substr($arg, 0, 10) === 'bootstrap=') {                $files     = explode(',', substr($arg, 10));                $bootstrap = [];                foreach ($files as $file) {                    $path = Util\Common::realpath($file);                    if ($path === false) {                        $error  = 'ERROR: The specified bootstrap file ""'.$file.'"" does not exist'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    $bootstrap[] = $path;                }                $this->bootstrap = array_merge($this->bootstrap, $bootstrap);                self::$overriddenDefaults['bootstrap'] = true;            } else if (substr($arg, 0, 10) === 'file-list=') {                $fileList = substr($arg, 10);                $path     = Util\Common::realpath($fileList);                if ($path === false) {                    $error  = 'ERROR: The specified file list ""'.$fileList.'"" does not exist'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }                $files = file($path);                foreach ($files as $inputFile) {                    $inputFile = trim($inputFile);                    // Skip empty lines.                    if ($inputFile === '') {                        continue;                    }                    $this->processFilePath($inputFile);                }            } else if (substr($arg, 0, 11) === 'stdin-path=') {                if (isset(self::$overriddenDefaults['stdinPath']) === true) {                    break;                }                $this->stdinPath = Util\Common::realpath(substr($arg, 11));                // It may not exist and return false instead, so use whatever they gave us.                if ($this->stdinPath === false) {                    $this->stdinPath = trim(substr($arg, 11));                }                self::$overriddenDefaults['stdinPath'] = true;            } else if (PHP_CODESNIFFER_CBF === false && substr($arg, 0, 12) === 'report-file=') {                if (isset(self::$overriddenDefaults['reportFile']) === true) {                    break;                }                $this->reportFile = Util\Common::realpath(substr($arg, 12));                // It may not exist and return false instead.                if ($this->reportFile === false) {                    $this->reportFile = substr($arg, 12);                    $dir = Util\Common::realpath(dirname($this->reportFile));                    if (is_dir($dir) === false) {                        $error  = 'ERROR: The specified report file path ""'.$this->reportFile.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                        $error .= $this->printShortUsage(true);                        throw new DeepExitException($error, 3);                    }                    $this->reportFile = $dir.'/'.basename($this->reportFile);                }//end if                self::$overriddenDefaults['reportFile'] = true;                if (is_dir($this->reportFile) === true) {                    $error  = 'ERROR: The specified report file path ""'.$this->reportFile.'"" is a directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if (substr($arg, 0, 13) === 'report-width=') {                if (isset(self::$overriddenDefaults['reportWidth']) === true) {                    break;                }                $this->reportWidth = substr($arg, 13);                self::$overriddenDefaults['reportWidth'] = true;            } else if (substr($arg, 0, 9) === 'basepath=') {                if (isset(self::$overriddenDefaults['basepath']) === true) {                    break;                }                self::$overriddenDefaults['basepath'] = true;                if (substr($arg, 9) === '') {                    $this->basepath = null;                    break;                }                $this->basepath = Util\Common::realpath(substr($arg, 9));                // It may not exist and return false instead.                if ($this->basepath === false) {                    $this->basepath = substr($arg, 9);                }                if (is_dir($this->basepath) === false) {                    $error  = 'ERROR: The specified basepath ""'.$this->basepath.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                    $error .= $this->printShortUsage(true);                    throw new DeepExitException($error, 3);                }            } else if ((substr($arg, 0, 7) === 'report=' || substr($arg, 0, 7) === 'report-')) {                $reports = [];                if ($arg[6] === '-') {                    // This is a report with file output.                    $split = strpos($arg, '=');                    if ($split === false) {                        $report = substr($arg, 7);                        $output = null;                    } else {                        $report = substr($arg, 7, ($split - 7));                        $output = substr($arg, ($split + 1));                        if ($output === false) {                            $output = null;                        } else {                            $dir = Util\Common::realpath(dirname($output));                            if (is_dir($dir) === false) {                                $error  = 'ERROR: The specified '.$report.' report file path ""'.$output.'"" points to a non-existent directory'.PHP_EOL.PHP_EOL;                                $error .= $this->printShortUsage(true);                                throw new DeepExitException($error, 3);                            }                            $output = $dir.'/'.basename($output);                            if (is_dir($output) === true) {                                $error  = 'ERROR: The specified '.$report.' report file path ""'.$output.'"" is a directory'.PHP_EOL.PHP_EOL;                                $error .= $this->printShortUsage(true);                                throw new DeepExitException($error, 3);                            }                        }//end if                    }//end if                    $reports[$report] = $output;                } else {                    // This is a single report.                    if (isset(self::$overriddenDefaults['reports']) === true) {                        break;                    }                    $reportNames = explode(',', substr($arg, 7));                    foreach ($reportNames as $report) {                        $reports[$report] = null;                    }                }//end if                // Remove the default value so the CLI value overrides it.                if (isset(self::$overriddenDefaults['reports']) === false) {                    $this->reports = $reports;                } else {                    $this->reports = array_merge($this->reports, $reports);                }                self::$overriddenDefaults['reports'] = true;            } else if (substr($arg, 0, 7) === 'filter=') {                if (isset(self::$overriddenDefaults['filter']) === true) {                    break;                }                $this->filter = substr($arg, 7);                self::$overriddenDefaults['filter'] = true;            } else if (substr($arg, 0, 9) === 'standard=') {                $standards = trim(substr($arg, 9));                if ($standards !== '') {                    $this->standards = explode(',', $standards);                }                self::$overriddenDefaults['standards'] = true;            } else if (substr($arg, 0, 11) === 'extensions=') {                if (isset(self::$overriddenDefaults['extensions']) === true) {                    break;                }                $extensions    = explode(',', substr($arg, 11));                $newExtensions = [];                foreach ($extensions as $ext) {                    $slash = strpos($ext, '/');                    if ($slash !== false) {                        // They specified the tokenizer too.                        list($ext, $tokenizer) = explode('/', $ext);                        $newExtensions[$ext]   = strtoupper($tokenizer);                        continue;                    }                    if (isset($this->extensions[$ext]) === true) {                        $newExtensions[$ext] = $this->extensions[$ext];                    } else {                        $newExtensions[$ext] = 'PHP';                    }                }                $this->extensions = $newExtensions;                self::$overriddenDefaults['extensions'] = true;            } else if (substr($arg, 0, 7) === 'suffix=') {                if (isset(self::$overriddenDefaults['suffix']) === true) {                    break;                }                $this->suffix = substr($arg, 7);                self::$overriddenDefaults['suffix'] = true;            } else if (substr($arg, 0, 9) === 'parallel=') {                if (isset(self::$overriddenDefaults['parallel']) === true) {                    break;                }                $this->parallel = max((int) substr($arg, 9), 1);                self::$overriddenDefaults['parallel'] = true;            } else if (substr($arg, 0, 9) === 'severity=') {                $this->errorSeverity   = (int) substr($arg, 9);                $this->warningSeverity = $this->errorSeverity;                if (isset(self::$overriddenDefaults['errorSeverity']) === false) {                    self::$overriddenDefaults['errorSeverity'] = true;                }                if (isset(self::$overriddenDefaults['warningSeverity']) === false) {                    self::$overriddenDefaults['warningSeverity'] = true;                }            } else if (substr($arg, 0, 15) === 'error-severity=') {                if (isset(self::$overriddenDefaults['errorSeverity']) === true) {                    break;                }                $this->errorSeverity = (int) substr($arg, 15);                self::$overriddenDefaults['errorSeverity'] = true;            } else if (substr($arg, 0, 17) === 'warning-severity=') {                if (isset(self::$overriddenDefaults['warningSeverity']) === true) {                    break;                }                $this->warningSeverity = (int) substr($arg, 17);                self::$overriddenDefaults['warningSeverity'] = true;            } else if (substr($arg, 0, 7) === 'ignore=') {                if (isset(self::$overriddenDefaults['ignored']) === true) {                    break;                }                // Split the ignore string on commas, unless the comma is escaped                // using 1 or 3 slashes (\, or \\\,).                $patterns = preg_split(                    '/(?<=(?<!\\\\)\\\\\\\\),|(?<!\\\\),/',                    substr($arg, 7)                );                $ignored = [];                foreach ($patterns as $pattern) {                    $pattern = trim($pattern);                    if ($pattern === '') {                        continue;                    }                    $ignored[$pattern] = 'absolute';                }                $this->ignored = $ignored;                self::$overriddenDefaults['ignored'] = true;            } else if (substr($arg, 0, 10) === 'generator='                && PHP_CODESNIFFER_CBF === false            ) {                if (isset(self::$overriddenDefaults['generator']) === true) {                    break;                }                $this->generator = substr($arg, 10);                self::$overriddenDefaults['generator'] = true;            } else if (substr($arg, 0, 9) === 'encoding=') {                if (isset(self::$overriddenDefaults['encoding']) === true) {                    break;                }                $this->encoding = strtolower(substr($arg, 9));                self::$overriddenDefaults['encoding'] = true;            } else if (substr($arg, 0, 10) === 'tab-width=') {                if (isset(self::$overriddenDefaults['tabWidth']) === true) {                    break;                }                $this->tabWidth = (int) substr($arg, 10);                self::$overriddenDefaults['tabWidth'] = true;            } else {                if ($this->dieOnUnknownArg === false) {                    $eqPos = strpos($arg, '=');                    try {                        if ($eqPos === false) {                            $this->values[$arg] = $arg;                        } else {                            $value = substr($arg, ($eqPos + 1));                            $arg   = substr($arg, 0, $eqPos);                            $this->values[$arg] = $value;                        }                    } catch (RuntimeException $e) {                        // Value is not valid, so just ignore it.                    }                } else {                    $this->processUnknownArgument('--'.$arg, $pos);                }            }//end if            break;        }//end switch    }//end processLongArgument()",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
76,PrestaShop_PrestaShop_AttributeGroup_837, Get values of current AttributeGroup instance for the webservice.\\\\\\\\n\\\\\\\\n @return array|false|mysqli_result|PDOStatement|resource|null\\\\\\\\n,Dohvatanje vrednosti trenutne instance AttributeGroup za veb servis,"    public function getWsProductOptionValues()    {        $result = Db::getInstance()->executeS(            'SELECT a.id_attribute AS idFROM `' . _DB_PREFIX_ . 'attribute` a' . Shop::addSqlAssociation('attribute', 'a') . 'WHERE a.id_attribute_group = ' . (int) $this->id        );        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
77,PrestaShop_PrestaShop_AttributeGroup_840, Get the highest AttributeGroup position.\\\\n\\\\n @return int $position Position\\\\n,Dohvatanje najviše pozicije AttributeGroup-e,    public static function getHigherPosition()    {        $sql = 'SELECT MAX(`position`)FROM `' . _DB_PREFIX_ . 'attribute_group`';        $position = Db::getInstance()->getValue($sql);        return (is_numeric($position)) ? $position : -1;    },1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
78,PrestaShop_PrestaShop_Attribute_826, Return true if the Attribute is a color.\n\n @return bool Color is the attribute type\n,Vrati tačno ako je atribut boja,    public function isColorAttribute()    {        if (!Db::getInstance()->getRow('SELECT `group_type`FROM `' . _DB_PREFIX_ . 'attribute_group`WHERE `id_attribute_group` = (SELECT `id_attribute_group`FROM `' . _DB_PREFIX_ . 'attribute`WHERE `id_attribute` = ' . (int) $this->id . ')AND group_type = \'color\'')) {            return false;        }        return Db::getInstance()->numRows();    },1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
79,PrestaShop_PrestaShop_Attribute_825, Check if the given name is an Attribute within the given AttributeGroup.\\n\\n @param int $idAttributeGroup AttributeGroup\\n @param string $name Attribute name\\n @param int $idLang Language ID\\n\\n @return array|bool\\n,Proverite da li je dato ime atribut unutar date AttributeGroup,"    public static function isAttribute($idAttributeGroup, $name, $idLang)    {        if (!Combination::isFeatureActive()) {            return [];        }        $result = Db::getInstance()->getValue('SELECT COUNT(*)FROM `' . _DB_PREFIX_ . 'attribute_group` agLEFT JOIN `' . _DB_PREFIX_ . 'attribute_group_lang` aglON (ag.`id_attribute_group` = agl.`id_attribute_group` AND agl.`id_lang` = ' . (int) $idLang . ')LEFT JOIN `' . _DB_PREFIX_ . 'attribute` aON a.`id_attribute_group` = ag.`id_attribute_group`LEFT JOIN `' . _DB_PREFIX_ . 'attribute_lang` alON (a.`id_attribute` = al.`id_attribute` AND al.`id_lang` = ' . (int) $idLang . ')' . Shop::addSqlAssociation('attribute_group', 'ag') . '' . Shop::addSqlAssociation('attribute', 'a') . 'WHERE al.`name` = \'' . pSQL($name) . '\' AND ag.`id_attribute_group` = ' . (int) $idAttributeGroup . 'ORDER BY agl.`name` ASC, a.`position` ASC');        return (int) $result > 0;    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
80,PrestaShop_PrestaShop_Attribute_828, Move an attribute inside its group.\n\n @param bool $direction Up (1) or Down (0)\n @param int $position Current position of the attribute\n\n @return bool Update result\n,Premestite atribut unutar njegove grupe,"    public function updatePosition($direction, $position)    {        if (!$idAttributeGroup = (int) Tools::getValue('id_attribute_group')) {            $idAttributeGroup = (int) $this->id_attribute_group;        }        $sql = 'SELECT a.`id_attribute`, a.`position`, a.`id_attribute_group`FROM `' . _DB_PREFIX_ . 'attribute` aWHERE a.`id_attribute_group` = ' . (int) $idAttributeGroup . 'ORDER BY a.`position` ASC';        if (!$res = Db::getInstance()->executeS($sql)) {            return false;        }        foreach ($res as $attribute) {            if ((int) $attribute['id_attribute'] == (int) $this->id) {                $movedAttribute = $attribute;            }        }        if (!isset($movedAttribute) || !isset($position)) {            return false;        }        // < and > statements rather than BETWEEN operator        // since BETWEEN is treated differently according to databases        $res1 = Db::getInstance()->execute(            'UPDATE `' . _DB_PREFIX_ . 'attribute`SET `position`= `position` ' . ($direction ? '- 1' : '+ 1') . 'WHERE `position`' . ($direction                ? '> ' . (int) $movedAttribute['position'] . ' AND `position` <= ' . (int) $position                : '< ' . (int) $movedAttribute['position'] . ' AND `position` >= ' . (int) $position) . 'AND `id_attribute_group`=' . (int) $movedAttribute['id_attribute_group']        );        $res2 = Db::getInstance()->execute(            'UPDATE `' . _DB_PREFIX_ . 'attribute`SET `position` = ' . (int) $position . 'WHERE `id_attribute` = ' . (int) $movedAttribute['id_attribute'] . 'AND `id_attribute_group`=' . (int) $movedAttribute['id_attribute_group']        );        return $res1 && $res2;    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
81,PrestaShop_PrestaShop_AttributeGroup_832, Deletes current AttributeGroup from database.\n\n @return bool True if delete was successful\n\n @throws PrestaShopException\n,Briše trenutnu AttributeGroup-u iz baze podataka,"    public function delete()    {        if (!$this->hasMultishopEntries() || Shop::getContext() == Shop::CONTEXT_ALL) {            /* Select children in order to find linked combinations */            $attributeIds = Db::getInstance()->executeS(                'SELECT `id_attribute`FROM `' . _DB_PREFIX_ . 'attribute`WHERE `id_attribute_group` = ' . (int) $this->id            );            if ($attributeIds === false) {                return false;            }            /* Removing attributes to the found combinations */            $toRemove = [];            foreach ($attributeIds as $attribute) {                $toRemove[] = (int) $attribute['id_attribute'];            }            if (!empty($toRemove) && Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'product_attribute_combination`WHERE `id_attribute`IN (' . implode(', ', $toRemove) . ')') === false) {                return false;            }            /* Remove combinations if they do not possess attributes anymore */            if (!AttributeGroup::cleanDeadCombinations()) {                return false;            }            /* Also delete related attributes */            if (count($toRemove)) {                if (!Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_lang`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute_shop`WHERE `id_attribute`IN (' . implode(',', $toRemove) . ')') ||                !Db::getInstance()->execute('DELETE FROM `' . _DB_PREFIX_ . 'attribute` WHERE `id_attribute_group` = ' . (int) $this->id)) {                    return false;                }            }            $this->cleanPositions();        }        $return = parent::delete();        if ($return) {            Hook::exec('actionAttributeGroupDelete', ['id_attribute_group' => $this->id]);        }        return $return;    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
82,PrestaShop_PrestaShop_Attribute_829, get highest position.\n\n Get the highest attribute position from a group attribute\n\n @param int $idAttributeGroup AttributeGroup ID\n\n @return int $position Position\n @todo: Shouldn't this be called getHighestPosition instead?\n,Dobiti najvišu poziciju.  Dobiti najvišu poziciju atributa iz grupe atributa,    public static function getHigherPosition($idAttributeGroup)    {        $sql = 'SELECT MAX(`position`)FROM `' . _DB_PREFIX_ . 'attribute`WHERE id_attribute_group = ' . (int) $idAttributeGroup;        $position = Db::getInstance()->getValue($sql);        return (is_numeric($position)) ? $position : -1;    },1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
83,PrestaShop_PrestaShop_Address_782, Check if Address is used (at least one order placed).\\\\n\\\\n @return int Order count for this Address\\\\n,Proverite da li se koristi adresa (bar jedna narudžbina postavljena).,    public function isUsed()    {        if ((int) $this->id <= 0) {            return false;        }        $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT COUNT(`id_order`) AS usedFROM `' . _DB_PREFIX_ . 'orders`WHERE `id_address_delivery` = ' . (int) $this->id . 'OR `id_address_invoice` = ' . (int) $this->id);        return $result > 0 ? (int) $result : false;    },1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
84,PrestaShop_PrestaShop_Address_783, Get Country and State of this Address.\\\\n\\\\n @param int $id_address Address ID\\\\n\\\\n @return array\\\\n,Dohvata državu i adresu udržavi,"    public static function getCountryAndState($id_address)    {        if (isset(self::$_idCountries[$id_address])) {            return self::$_idCountries[$id_address];        }        if ($id_address) {            $result = Db::getInstance(_PS_USE_SQL_SLAVE_)->getRow('SELECT `id_country`, `id_state`, `vat_number`, `postcode` FROM `' . _DB_PREFIX_ . 'address`WHERE `id_address` = ' . (int) $id_address);        } else {            $result = false;        }        self::$_idCountries[$id_address] = $result;        return $result;    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
85,PrestaShop_PrestaShop_Address_780, Check if the Country is active for a given address.\n\n @param int $id_address Address ID for which we want to get the Country status\n\n @return int Country status\n,Proverite da li je država aktivna za datu adresu,"    public static function isCountryActiveById($id_address)    {        if (!isset($id_address) || empty($id_address)) {            return false;        }        $cache_id = 'Address::isCountryActiveById_' . (int) $id_address;        if (!Cache::isStored($cache_id)) {            $result = (bool) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT c.`active`FROM `' . _DB_PREFIX_ . 'address` aLEFT JOIN `' . _DB_PREFIX_ . 'country` c ON c.`id_country` = a.`id_country`WHERE a.`id_address` = ' . (int) $id_address);            Cache::store($cache_id, $result);            return $result;        }        return Cache::retrieve($cache_id);    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
86,markrogoyski_math-php_Combinatorics_3052, Central Binomial Coefficient\\n\\n (2n)   (2n)!\\n (  ) = ----- for n â‰¥ 0\\n (n )   (n!)Â²\\n\\n https://en.wikipedia.org/wiki/Central_binomial_coefficient\\n\\n @param  int $n\\n\\n @return float number\\n\\n @throws Exception\\\\OutOfBoundsException if n < 0\\n,Centralni binomni koeficijent,    public static function centralBinomialCoefficient(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute negative central binomial coefficient.');        }        $âŸ®2nâŸ¯ï¼ = self::factorial(2 * $n);        $âŸ®nï¼âŸ¯Â² = (self::factorial($n)) ** 2;        return $âŸ®2nâŸ¯ï¼ / $âŸ®nï¼âŸ¯Â²;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
87,markrogoyski_math-php_Binomial_3220," PMF multiplication method\n\n Evaluate binomial probabilities using a method that avoids unnecessary overflow and underflow\n Catherine Loader: http://octave.1599824.n4.nabble.com/attachment/3829107/0/loader2000Fast.pdf\n\n               x             x   n-x\n              __  n - x + i __   __\n p(x; n, p) = ||  --------- || p ||  (1 - p)\n              â±â¼Â¹     i     â±â¼Â¹  â±â¼Â¹\n\n @param int   $r number of successful events\n @param int   $n number of events\n @param float $p probability of success\n\n @return float\n",PMF metoda množenja. Procenite binomne verovatnoće pomoću metode koja izbegava nepotrebno prelivanje i podlivanje,"    private function multiplicationMethod(int $r, int $n, float $p): float    {        if (2 * $r > $n) {            return $this->multiplicationMethod($n - $r, $n, 1 - $p);        }        [$jâ‚€, $jâ‚, $jâ‚‚] = [0, 0, 0];        $f = 1;        while (($jâ‚€ < $r) | ($jâ‚ < $r) | ($jâ‚‚ < $n - $r)) {            if (($jâ‚€ < $r) && ($f < 1)) {                $jâ‚€++;                $f *= ($n - $r + $jâ‚€) / $jâ‚€;            } elseif ($jâ‚ < $r) {                $jâ‚++;                $f *= $p;            } else {                $jâ‚‚++;                $f *= 1 - $p;            }        }        return $f;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
88,markrogoyski_math-php_Hypergeometric_3240," Cumulative distribution function\n\n           (  n  )(  N - n  )      _                           _\n           (k + 1)(K - k - 1)     | 1, k + 1 - K, k + 1 - n      |\n cdf = 1 - ------------------ â‚ƒFâ‚‚ |                          ; 1 |\n                  (N)             | k + 2, N + k + 2 - K - n     |\n                  (K)             |_                            _|\n\n N is the population size,\n K is the number of success states in the population,\n n is the number of draws,\n k is the number of observed successes,\n (a)\n (b) is a binomial coefficient.\n â‚ƒFâ‚‚ is the generalized hypergeometric function\n\n N âˆˆ {0, 1, 2, ...}\n K âˆˆ {0, 1, 2, ..., N}\n n âˆˆ {0, 1, 2, ..., N}\n k âˆˆ {max(0, n + K - N), ..., min(n, K)}\n\n @param  int $k number of observed successes\n\n @return float\n",Funkcija kumulativne raspodele,"    public function cdf(int $k): float    {        Support::checkLimits($this->support_limit, ['k' => $k]);        $N = $this->N;        $K = $this->K;        $n = $this->n;        $nCâŸ®kÂ ï¼‹Â 1âŸ¯         = Combinatorics::combinations($n, $k + 1);        $âŸ®NÂ âˆ’Â nâŸ¯CâŸ®KÂ âˆ’Â kÂ âˆ’Â 1âŸ¯ = Combinatorics::combinations(($N - $n), ($K - $k - 1));        $NCK              = Combinatorics::combinations($N, $K);        $â‚ƒFâ‚‚ = Special::generalizedHypergeometric(3, 2, 1, $k + 1 - $K, $k + 1 - $n, $k + 2, $N + $k + 2 - $K - $n, 1);        return (($nCâŸ®kÂ ï¼‹Â 1âŸ¯ * $âŸ®NÂ âˆ’Â nâŸ¯CâŸ®KÂ âˆ’Â kÂ âˆ’Â 1âŸ¯) / $NCK) * $â‚ƒFâ‚‚;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
89,markrogoyski_math-php_Continuous_3086, Produce a random number with a particular distribution\n\n @return number\n\n @throws \\Exception\n,"Napravite slučajni broj sa određenom raspodelom
","    public function rand()    {        return $this->inverse(\random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
90,bcit-ci_CodeIgniter_Common_338, Is HTTPS?\n\n Determines if the application is accessed via an encrypted\n (HTTPS) connection.\n\n @return\tbool\n,Da li je HTTPS?  Određuje da li se aplikaciji pristupa preko šifrovane (HTTPS) veze,function is_https(){if ( ! empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off'){return TRUE;}elseif (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) === 'https'){return TRUE;}elseif ( ! empty($_SERVER['HTTP_FRONT_END_HTTPS']) && strtolower($_SERVER['HTTP_FRONT_END_HTTPS']) !== 'off'){return TRUE;}return FALSE;},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
91,markrogoyski_math-php_Linear_3576," Simple linear regression - least squares method\n\n A model with a single explanatory variable.\n Fits a straight line through the set of n points in such a way that makes\n the sum of squared residuals of the model (that is, vertical distances\n between the points of the data set and the fitted line) as small as possible.\n https://en.wikipedia.org/wiki/Simple_linear_regression\n\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\n Find the equation y = mx + b\n\n      _ _   __\n      x y - xy\n m = _________\n      _     __\n     (x)Â² - xÂ²\n\n     _    _\n b = y - mx\n","Jednostavna linearna regresija - metoda najmanjih kvadrata. Model sa jednom objašnjenom promenljivom. Uklapa pravu liniju kroz skup od n tačaka na takav načinkoji pravi da zabir kvadratnih reziduala modela (tj. , vertikalne udaljenosti između tačaka skupa podataka i prave koja fituje podatke) bude što je moguće manji","class Linear extends ParametricRegression{    use Methods\LeastSquares;    use Models\LinearModel;    /**     * Average of x     * @var number     */    private $xbar;    /**     * Average of y     * @var number     */    private $ybar;    /**     * Sum of squared deviations of x     * @var number     */    private $SSx;    /**     * Sum of squares residuals     * @var number     */    private $SSres;    /**     * Calculates the regression parameters.     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     * @throws Exception\MathException     */    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs)->getColumn(0);    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
92,markrogoyski_math-php_WeightedLinear_3603," Weighted linear regression - least squares method\n\n A model with a single explanatory variable.\n Fits a straight line through the set of n points in such a way that makes\n the sum of squared residuals of the model (that is, vertical distances\n between the points of the data set and the fitted line) as small as possible.\n https://en.wikipedia.org/wiki/Simple_linear_regression\n\n Having data points {(xáµ¢, yáµ¢), i = 1 ..., n }\n Find the equation y = mx + b\n\n","Ponderisana linearna regresija - metoda najmanjih kvadrata. Model sa jednom promenljivom objašnjenja. Uklapa se prava linija kroz skup od n tačaka na takav način da zbir kvadratnih reziduala modela (tj. , vertikalne udaljenosti između tačaka skupa podataka i ugrađene prave) bude što je moguće manji","class WeightedLinear extends ParametricRegression{    use Models\LinearModel;    use Methods\WeightedLeastSquares;    /**     * Array of weights     * @var array     */    private $ws;    /**     * @param array $points     * @param array $ws     Weights     */    public function __construct(array $points, array $ws)    {        $this->ws = $ws;        parent::__construct($points);    }    /**     * Calculates the regression parameters.     *     * @throws Exception\MatrixException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     */    public function calculate(): void    {        $this->parameters = $this->leastSquares($this->ys, $this->xs, $this->ws)->getColumn(0);    }    /**     * Evaluate the regression equation at x     * Uses the instance model's evaluateModel method.     *     * @param  float $x     *     * @return float     */    public function evaluate(float $x): float    {        return $this->evaluateModel($x, $this->parameters);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
93,markrogoyski_math-php_PowerLaw_3590, Calculate the regression parameters by least squares on linearized data\\n ln(y) = ln(A) + B\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\IncorrectTypeException\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\MathException\\n,Izračunava parametre regresije po metodi najmanjih kvadrata na linearizovanim podacima  ln(i) = ln(A) + B,"    public function calculate(): void    {        // Linearize the relationship by taking the log of both sides.        $xâ€™ = \array_map('\log', $this->xs);        $yâ€™ = \array_map('\log', $this->ys);        // Perform Least Squares Fit        $linearized_parameters = $this->leastSquares($yâ€™, $xâ€™)->getColumn(0);        // Translate the linearized parameters back.        $this->a = \exp($linearized_parameters[0]);        $this->b = $linearized_parameters[1];        $this->parameters = [$this->a, $this->b];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
94,markrogoyski_math-php_LinearModel_3634, Get regression equation (y = mx + b)\n\n @param array $params\n\n @return string\n,Dobijanje regresione jednačine (y = mx + b),"    public function getModelEquation(array $params): string    {        return \sprintf('y = %fx + %f', $params[self::$M], $params[self::$B]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
95,markrogoyski_math-php_LinearModel_3633," Get regression parameters (coefficients)\\n m = slope\\n b = y intercept\\n\\n @param array $params\\n\\n @return array [ m => number, b => number ]\\n",Dobijanje regresionih parametara (koeficijenata) m = nagib  b = y presek,"    public function getModelParameters(array $params): array    {        return [            'm' => $params[self::$M],            'b' => $params[self::$B],        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
96,markrogoyski_math-php_PowerModel_3640, Get regression equation (y = axáµ‡) in format y = ax^b\\n\\n @param array $params\\n\\n @return string\\n,Dobijanje regresione jednačine (y = axáµ‡) u formatu y = ax^b,"    public function getModelEquation(array $params): string    {        return \sprintf('y = %fx^%f', $params[self::$A], $params[self::$B]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
97,markrogoyski_math-php_Regression_3593," Constructor - Prepares the data arrays for regression analysis\\n\\n @param array $points [ [x, y], [x, y], ... ]\\n",Konstruktor - Priprema nizove podataka za regresionu analizu,"    public function __construct(array $points)    {        $this->points = $points;        $this->n      = \count($points);        // Get list of x points and y points.        // This will be fine for linear or polynomial regression, where there is only one x,        // but if expanding to multiple linear, the format will have to change.        $this->xs = \array_map(function ($point) {            return $point[0];        }, $points);        $this->ys = \array_map(function ($point) {            return $point[1];        }, $points);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
98,walkor_Workerman_AsyncTcpConnection_9648, Try to emit onError callback.\n\n @param int    $code\n @param string $msg\n @return void\n,Pokušava da emitujete onError povratni poziv,"    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
99,walkor_Workerman_AsyncUdpConnection_7027, Connect.\n\n @return void\n,Konekcija,"class AsyncUdpConnection extends UdpConnection{    /**     * Emitted when socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when socket connection closed.     *     * @var callable     */    public $onClose = null;    /**     * Connected or not.     *     * @var bool     */    protected $connected = false;    /**     * Context option.     *     * @var array     */    protected $_contextOption = null;    /**     * Construct.     *     * @param string $remote_address     * @throws Exception     */    public function __construct($remote_address, $context_option = null)    {        // Get the application layer communication protocol and listening address.        list($scheme, $address) = \explode(':', $remote_address, 2);        // Check application layer protocol class.        if ($scheme !== 'udp') {            $scheme         = \ucfirst($scheme);            $this->protocol = '\\Protocols\\' . $scheme;            if (!\class_exists($this->protocol)) {                $this->protocol = ""\\Workerman\\Protocols\\$scheme"";                if (!\class_exists($this->protocol)) {                    throw new Exception(""class \\Protocols\\$scheme not exist"");                }            }        }                $this->_remoteAddress = \substr($address, 2);        $this->_contextOption = $context_option;    }        /**     * For udp package.     *     * @param resource $socket     * @return bool     */    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }    /**     * Sends data on the connection.     *     * @param string $send_buffer     * @param bool   $raw     * @return void|boolean     */    public function send($send_buffer, $raw = false)    {        if (false === $raw && $this->protocol) {            $parser      = $this->protocol;            $send_buffer = $parser::encode($send_buffer, $this);            if ($send_buffer === '') {                return;            }        }        if ($this->connected === false) {            $this->connect();        }        return \strlen($send_buffer) === \stream_socket_sendto($this->_socket, $send_buffer, 0);    }            /**     * Close connection.     *     * @param mixed $data     * @param bool $raw     *     * @return bool     */    public function close($data = null, $raw = false)    {        if ($data !== null) {            $this->send($data, $raw);        }        Worker::$globalEvent->del($this->_socket, EventInterface::EV_READ);        \fclose($this->_socket);        $this->connected = false;        // Try to emit onClose callback.        if ($this->onClose) {            try {                \call_user_func($this->onClose, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        $this->onConnect = $this->onMessage = $this->onClose = null;        return true;    }    /**     * Connect.     *     * @return void     */    public function connect()    {        if ($this->connected === true) {            return;        }        if ($this->_contextOption) {            $context = \stream_context_create($this->_contextOption);            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg,                30, \STREAM_CLIENT_CONNECT, $context);        } else {            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg);        }        if (!$this->_socket) {            Worker::safeEcho(new \Exception($errmsg));            return;        }                \stream_set_blocking($this->_socket, false);                if ($this->onMessage) {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));        }        $this->connected = true;        // Try to emit onConnect callback.        if ($this->onConnect) {            try {                \call_user_func($this->onConnect, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
100,walkor_Workerman_AsyncUdpConnection_7782, AsyncTcpConnection.\n,Asinhrona Tcp konekcija,"class AsyncUdpConnection extends UdpConnection{    /**     * Emitted when socket connection is successfully established.     *     * @var callable     */    public $onConnect = null;    /**     * Emitted when socket connection closed.     *     * @var callable     */    public $onClose = null;    /**     * Connected or not.     *     * @var bool     */    protected $connected = false;    /**     * Context option.     *     * @var array     */    protected $_contextOption = null;    /**     * Construct.     *     * @param string $remote_address     * @throws Exception     */    public function __construct($remote_address, $context_option = null)    {        // Get the application layer communication protocol and listening address.        list($scheme, $address) = \explode(':', $remote_address, 2);        // Check application layer protocol class.        if ($scheme !== 'udp') {            $scheme         = \ucfirst($scheme);            $this->protocol = '\\Protocols\\' . $scheme;            if (!\class_exists($this->protocol)) {                $this->protocol = ""\\Workerman\\Protocols\\$scheme"";                if (!\class_exists($this->protocol)) {                    throw new Exception(""class \\Protocols\\$scheme not exist"");                }            }        }                $this->_remoteAddress = \substr($address, 2);        $this->_contextOption = $context_option;    }        /**     * For udp package.     *     * @param resource $socket     * @return bool     */    public function baseRead($socket)    {        $recv_buffer = \stream_socket_recvfrom($socket, Worker::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        if (false === $recv_buffer || empty($remote_address)) {            return false;        }                if ($this->onMessage) {            if ($this->protocol) {                $parser      = $this->protocol;                $recv_buffer = $parser::decode($recv_buffer, $this);            }            ++ConnectionInterface::$statistics['total_request'];            try {                \call_user_func($this->onMessage, $this, $recv_buffer);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        return true;    }    /**     * Sends data on the connection.     *     * @param string $send_buffer     * @param bool   $raw     * @return void|boolean     */    public function send($send_buffer, $raw = false)    {        if (false === $raw && $this->protocol) {            $parser      = $this->protocol;            $send_buffer = $parser::encode($send_buffer, $this);            if ($send_buffer === '') {                return;            }        }        if ($this->connected === false) {            $this->connect();        }        return \strlen($send_buffer) === \stream_socket_sendto($this->_socket, $send_buffer, 0);    }            /**     * Close connection.     *     * @param mixed $data     * @param bool $raw     *     * @return bool     */    public function close($data = null, $raw = false)    {        if ($data !== null) {            $this->send($data, $raw);        }        Worker::$globalEvent->del($this->_socket, EventInterface::EV_READ);        \fclose($this->_socket);        $this->connected = false;        // Try to emit onClose callback.        if ($this->onClose) {            try {                \call_user_func($this->onClose, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }        $this->onConnect = $this->onMessage = $this->onClose = null;        return true;    }    /**     * Connect.     *     * @return void     */    public function connect()    {        if ($this->connected === true) {            return;        }        if ($this->_contextOption) {            $context = \stream_context_create($this->_contextOption);            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg,                30, \STREAM_CLIENT_CONNECT, $context);        } else {            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg);        }        if (!$this->_socket) {            Worker::safeEcho(new \Exception($errmsg));            return;        }                \stream_set_blocking($this->_socket, false);                if ($this->onMessage) {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));        }        $this->connected = true;        // Try to emit onConnect callback.        if ($this->onConnect) {            try {                \call_user_func($this->onConnect, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
101,walkor_Workerman_Worker_7015, Accept a connection.\n\n @param resource $socket\n @return void\n,Prihvatanje konekcije,"    public function acceptUdpConnection($socket)    {        \set_error_handler(function(){});        $recv_buffer = \stream_socket_recvfrom($socket, static::MAX_UDP_PACKAGE_SIZE, 0, $remote_address);        \restore_error_handler();        if (false === $recv_buffer || empty($remote_address)) {            return false;        }        // UdpConnection.        $connection           = new UdpConnection($socket, $remote_address);        $connection->protocol = $this->protocol;        if ($this->onMessage) {            try {                if ($this->protocol !== null) {                    /** @var \Workerman\Protocols\ProtocolInterface $parser */                    $parser = $this->protocol;                    if ($parser && \method_exists($parser, 'input')) {                        while ($recv_buffer !== '') {                            $len = $parser::input($recv_buffer, $connection);                            if ($len === 0)                                return true;                            $package = \substr($recv_buffer, 0, $len);                            $recv_buffer = \substr($recv_buffer, $len);                            $data = $parser::decode($package, $connection);                            if ($data === false)                                continue;                            \call_user_func($this->onMessage, $connection, $data);                        }                    } else {                        $data = $parser::decode($recv_buffer, $connection);                        // Discard bad packets.                        if ($data === false)                            return true;                        \call_user_func($this->onMessage, $connection, $data);                    }                } else {                    \call_user_func($this->onMessage, $connection, $recv_buffer);                }                ++ConnectionInterface::$statistics['total_request'];            } catch (\Exception $e) {                static::log($e);                exit(250);            } catch (\Error $e) {                static::log($e);                exit(250);            }        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
102,walkor_Workerman_AsyncTcpConnection_7022, Get remote URI.\n\n @return string\n,Dohvatanje udaljenog URI-ja,"    public function checkConnection()    {        // Remove EV_EXPECT for windows.        if(\DIRECTORY_SEPARATOR === '\\') {            Worker::$globalEvent->del($this->_socket, EventInterface::EV_EXCEPT);        }        // Remove write listener.        Worker::$globalEvent->del($this->_socket, EventInterface::EV_WRITE);        if ($this->_status !== self::STATUS_CONNECTING) {            return;        }        // Check socket state.        if ($address = \stream_socket_get_name($this->_socket, true)) {            // Nonblocking.            \stream_set_blocking($this->_socket, false);            // Compatible with hhvm            if (\function_exists('stream_set_read_buffer')) {                \stream_set_read_buffer($this->_socket, 0);            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && $this->transport === 'tcp') {                $raw_socket = \socket_import_stream($this->_socket);                \socket_set_option($raw_socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($raw_socket, \SOL_TCP, \TCP_NODELAY, 1);            }            // SSL handshake.            if ($this->transport === 'ssl') {                $this->_sslHandshakeCompleted = $this->doSslHandshake($this->_socket);                if ($this->_sslHandshakeCompleted === false) {                    return;                }            } else {                // There are some data waiting to send.                if ($this->_sendBuffer) {                    Worker::$globalEvent->add($this->_socket, EventInterface::EV_WRITE, array($this, 'baseWrite'));                }            }            // Register a listener waiting read event.            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));            $this->_status                = self::STATUS_ESTABLISHED;            $this->_remoteAddress         = $address;            // Try to emit onConnect callback.            if ($this->onConnect) {                try {                    \call_user_func($this->onConnect, $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }            // Try to emit protocol::onConnect            if ($this->protocol && \method_exists($this->protocol, 'onConnect')) {                try {                    \call_user_func(array($this->protocol, 'onConnect'), $this);                } catch (\Exception $e) {                    Worker::log($e);                    exit(250);                } catch (\Error $e) {                    Worker::log($e);                    exit(250);                }            }        } else {            // Connection failed.            $this->emitError(\WORKERMAN_CONNECT_FAIL, 'connect ' . $this->_remoteAddress . ' fail after ' . round(\microtime(true) - $this->_connectStartTime, 4) . ' seconds');            if ($this->_status === self::STATUS_CLOSING) {                $this->destroy();            }            if ($this->_status === self::STATUS_CLOSED) {                $this->onConnect = null;            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
103,walkor_Workerman_Worker_7003, Write statistics data to disk.\n\n @return void\n,Upisivanje statističkih podataka na disk,"    public function listen()    {        if (!$this->_socketName) {            return;        }        // Autoload.        Autoloader::setRootPath($this->_autoloadRootPath);        if (!$this->_mainSocket) {            $local_socket = $this->parseSocketAddress();            // Flag.            $flags = $this->transport === 'udp' ? \STREAM_SERVER_BIND : \STREAM_SERVER_BIND | \STREAM_SERVER_LISTEN;            $errno = 0;            $errmsg = '';            // SO_REUSEPORT.            if ($this->reusePort) {                \stream_context_set_option($this->_context, 'socket', 'so_reuseport', 1);            }            // Create an Internet or Unix domain server socket.            $this->_mainSocket = \stream_socket_server($local_socket, $errno, $errmsg, $flags, $this->_context);            if (!$this->_mainSocket) {                throw new Exception($errmsg);            }            if ($this->transport === 'ssl') {                \stream_socket_enable_crypto($this->_mainSocket, false);            } elseif ($this->transport === 'unix') {                $socket_file = \substr($local_socket, 7);                if ($this->user) {                    \chown($socket_file, $this->user);                }                if ($this->group) {                    \chgrp($socket_file, $this->group);                }            }            // Try to open keepalive for tcp and disable Nagle algorithm.            if (\function_exists('socket_import_stream') && static::$_builtinTransports[$this->transport] === 'tcp') {                \set_error_handler(function(){});                $socket = \socket_import_stream($this->_mainSocket);                \socket_set_option($socket, \SOL_SOCKET, \SO_KEEPALIVE, 1);                \socket_set_option($socket, \SOL_TCP, \TCP_NODELAY, 1);                \restore_error_handler();            }            // Non blocking.            \stream_set_blocking($this->_mainSocket, false);        }        $this->resumeAccept();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
104,php-pm_php-pm_ProcessSlave_1633, Attempt a connection through the unix socket until it succeeds.\\\\n This is a workaround for an issue where the (hardcoded) 1s socket timeout is triggered due to a busy socket.\\\\n,Pokušaj konekcije kroz unik soket sve dok ne uspe. Ovo je rešenje za problem kod koga se pokreće (tvrdo kodirano) 1s soketa isticanje vremena zbog zauzetog soketa,"    private function tryConnect()    {        try {            $this->doConnect();        } catch (\RuntimeException $ex) {            // Failed to connect to the controller, there was probably a timeout accessing the socket...            $this->loop->addTimer(1, function () {                $this->tryConnect();            });        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
105,walkor_Workerman_AsyncUdpConnection_7026, For udp package.\n\n @param resource $socket\n @return bool\n,Za udp paket,"    public function connect()    {        if ($this->connected === true) {            return;        }        if ($this->_contextOption) {            $context = \stream_context_create($this->_contextOption);            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg,                30, \STREAM_CLIENT_CONNECT, $context);        } else {            $this->_socket = \stream_socket_client(""udp://{$this->_remoteAddress}"", $errno, $errmsg);        }        if (!$this->_socket) {            Worker::safeEcho(new \Exception($errmsg));            return;        }                \stream_set_blocking($this->_socket, false);                if ($this->onMessage) {            Worker::$globalEvent->add($this->_socket, EventInterface::EV_READ, array($this, 'baseRead'));        }        $this->connected = true;        // Try to emit onConnect callback.        if ($this->onConnect) {            try {                \call_user_func($this->onConnect, $this);            } catch (\Exception $e) {                Worker::log($e);                exit(250);            } catch (\Error $e) {                Worker::log($e);                exit(250);            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
106,walkor_Workerman_Worker_7769, Get socket name.\n\n @return string\n,Dohvatiti ime soketa,"    public function stop()    {        // Try to emit onWorkerStop callback.        if ($this->onWorkerStop) {            try {                \call_user_func($this->onWorkerStop, $this);            } catch (\Exception $e) {                static::log($e);                exit(250);            } catch (\Error $e) {                static::log($e);                exit(250);            }        }        // Remove listener for server socket.        $this->unlisten();        // Close all connections for the worker.        if (!static::$_gracefulStop) {            foreach ($this->connections as $connection) {                $connection->close();            }        }        // Clear callback.        $this->onMessage = $this->onClose = $this->onError = $this->onBufferDrain = $this->onBufferFull = null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
107,symfony_process_Process_1497," Performs a check between the timeout definition and the time the process started.\\n\\n In case you run a background process (with the start method), you should\\n trigger this method regularly to ensure the process timeout\\n\\n @throws ProcessTimedOutException In case the timeout was reached\\n","Obavlja proveru između definicije vremenskog ograničenja i vremena pokretanja procesa. U slučaju da pokrenete pozadinski proces (sa metodom pokretanja), trebali biste redovno pokretati ovu metodu kako biste osigurali vremensko ograničenje procesa
","    public static function isPtySupported()    {        static $result;        if (null !== $result) {            return $result;        }        if ('\\' === \DIRECTORY_SEPARATOR) {            return $result = false;        }        return $result = (bool) @proc_open('echo 1 >/dev/null', [['pty'], ['pty'], ['pty']], $pipes);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
108,TheAlgorithms_PHP_HexadecimalToDecimal_2055, This function converts the\n submitted Decimal Number to\n Hexadecimal Number.\n\n @param string $decimalNumber\n @return string\n,Ova funkcija pretvara poslati decimalni broj u heksadecimalni broj,"function decimalToHex($decimalNumber){    $hexDigits = [];    // Mapping for HexaDecimal Digits after 9    $hexDigitMappings = [        10 => 'A',        11 => 'B',        12 => 'C',        13 => 'D',        14 => 'E',        15 => 'F',    ];    if (!is_numeric($decimalNumber)) {        throw new \Exception('Please pass a valid Decimal Number for Converting it to a Hexadecimal Number.');    }    while ($decimalNumber > 0) {        $remainder = ($decimalNumber % 16);        $decimalNumber /= 16;        if (empty($hexDigits) && 0 === $remainder) {            continue;        }        $hexDigits[] = $remainder;    }    $hexDigits = array_reverse($hexDigits);    foreach ($hexDigits as $index => $digit) {        if ($digit > 9) {            $hexDigits[$index] = $hexDigitMappings[$digit];        }    }    $hexNumber = ltrim(implode('', $hexDigits), '0'); // Connecting all the digits and removing leading zeroes.    return $hexNumber;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
109,danielstjules_Stringy_Stringy_10278," Returns true if the string contains only hexadecimal chars, false\n otherwise.\n\n @return bool Whether or not $str contains only hexadecimal chars\n","Vraća true ako niz sadrži samo heksadecimalne znakove, false u suprotnom",    public function isHexadecimal()    {        return $this->matchesPattern('^[[:xdigit:]]*$');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
110,bcit-ci_CodeIgniter_Loader_378," Prepare variables for _ci_vars, to be later extract()-ed inside views\\n\\n Converts objects to associative arrays and filters-out internal\\n variable names (i.e. keys prefixed with '_ci_').\\n\\n @param\\tmixed\\t$vars\\n @return\\tarray\\n","Pripremite promenljive za _ci_vars, koje će kasnije biti ekstrahovane unutar view-a. Pretvara objekte u asocijativne nizove i filtrira unutrašnja imena promenljivih (npr. ključevi sa prefiksom '_ci_')","protected function _ci_prepare_view_vars($vars){if ( ! is_array($vars)){$vars = is_object($vars)? get_object_vars($vars): array();}foreach (array_keys($vars) as $key){if (strncmp($key, '_ci_', 4) === 0){unset($vars[$key]);}}return $vars;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
111,googleapis_google-api-php-client_Model_665, Convert a string to camelCase\\n @param  string $value\\n @return string\\n,Pretvorite niz u camelCase,"  private function camelCase($value)  {    $value = ucwords(str_replace(array('-', '_'), ' ', $value));    $value = str_replace(' ', '', $value);    $value[0] = strtolower($value[0]);    return $value;  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
112,phalcon_cphalcon_Util_1553," Normalize file path, convert all slashes to Linux-style and get rid of '..', '.'.\\n\\n @param string $filePath\\n @return string|null\\n","Normalizirajte putanju do datoteke, pretvorite sve kose crte u Linuk stil i oslobodite se „..“, „.“","    public static function normalize(string $filePath): ?string    {        $filePath = realpath($filePath);        if ($filePath === false) {            return null;        }        return str_replace('\\', DIRECTORY_SEPARATOR, $filePath);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
113,symfony_debug_ExceptionHandler_1742," ExceptionHandler converts an exception to a Response object.\\n\\n It is mostly useful in debug mode to replace the default PHP/XDebug\\n output with something prettier and more useful.\\n\\n As this class is mainly used during Kernel boot, where nothing is yet\\n available, the Response content is always HTML.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n @author Nicolas Grekas <p@tchwork.com>\\n\\n @final since Symfony 4.3\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\ErrorHandler instead.\\n","ExceptionHandler pretvara izuzetak u Response objekat. Najčešće se koristi u debug modu kao zamena podrazumevanog PHP/XDebug izlaz nečim lepšim i korisnijim. Kako se ova klasa uglavnom koristi tokom pokretanja kernela, gde još ništa nije dostupno, sadržaj odgovora je uvek HTML","class ExceptionHandler{    private const GHOST_ADDONS = [        '02-14' => self::GHOST_HEART,        '02-29' => self::GHOST_PLUS,        '10-18' => self::GHOST_GIFT,    ];    private const GHOST_GIFT = 'M124.005 5.36c.396-.715 1.119-1.648-.124-1.873-.346-.177-.692-.492-1.038-.141-.769.303-1.435.728-.627 1.523.36.514.685 1.634 1.092 1.758.242-.417.47-.842.697-1.266zm-1.699 1.977c-.706-1.26-1.274-2.612-2.138-3.774-1.051-1.123-3.122-.622-3.593.825-.625 1.431.724 3.14 2.251 2.96 1.159.02 2.324.072 3.48-.011zm5.867.043c1.502-.202 2.365-2.092 1.51-3.347-.757-1.34-2.937-1.387-3.698-.025-.659 1.1-1.23 2.25-1.835 3.38 1.336.077 2.686.06 4.023-.008zm2.487 1.611c.512-.45 2.494-.981.993-1.409-.372-.105-.805-.59-1.14-.457-.726.902-1.842 1.432-3.007 1.376-.228.075-1.391-.114-1.077.1.822.47 1.623.979 2.474 1.395.595-.317 1.173-.667 1.757-1.005zm-11.696.255l1.314-.765c-1.338-.066-2.87.127-3.881-.95-.285-.319-.559-.684-.954-.282-.473.326-1.929.66-.808 1.058.976.576 1.945 1.167 2.946 1.701.476-.223.926-.503 1.383-.762zm6.416 2.846c.567-.456 1.942-.89 1.987-1.38-1.282-.737-2.527-1.56-3.87-2.183-.461-.175-.835.094-1.207.328-1.1.654-2.225 1.267-3.288 1.978 1.39.86 2.798 1.695 4.219 2.504.725-.407 1.44-.83 2.16-1.247zm5.692 1.423l1.765-1.114c-.005-1.244.015-2.488-.019-3.732a77.306 77.306 0 0 0-3.51 2.084c-.126 1.282-.062 2.586-.034 3.876.607-.358 1.2-.741 1.798-1.114zm-13.804-.784c.06-1.06.19-2.269-1.09-2.583-.807-.376-1.926-1.341-2.548-1.332-.02 1.195-.01 2.39-.011 3.585 1.192.744 2.364 1.524 3.582 2.226.119-.616.041-1.269.067-1.896zm8.541 4.105l2.117-1.336c-.003-1.284.05-2.57-.008-3.853-.776.223-1.662.91-2.48 1.337l-1.834 1.075c.012 1.37-.033 2.744.044 4.113.732-.427 1.443-.887 2.161-1.336zm-2.957-.72v-2.057c-1.416-.828-2.828-1.664-4.25-2.482-.078 1.311-.033 2.627-.045 3.94 1.416.887 2.817 1.798 4.25 2.655.057-.683.036-1.372.045-2.057zm8.255 2.755l1.731-1.153c-.024-1.218.06-2.453-.062-3.658-1.2.685-2.358 1.464-3.537 2.195.028 1.261-.058 2.536.072 3.786.609-.373 1.2-.777 1.796-1.17zm-13.851-.683l-.014-1.916c-1.193-.746-2.37-1.517-3.58-2.234-.076 1.224-.033 2.453-.044 3.679 1.203.796 2.392 1.614 3.61 2.385.048-.636.024-1.276.028-1.914zm8.584 4.199l2.102-1.396c-.002-1.298.024-2.596-.01-3.893-1.427.88-2.843 1.775-4.25 2.686-.158 1.253-.055 2.545-.056 3.811.437.266 1.553-.912 2.214-1.208zm-2.988-.556c-.085-.894.365-2.154-.773-2.5-1.146-.727-2.288-1.46-3.45-2.163-.17 1.228.008 2.508-.122 3.751a79.399 79.399 0 0 0 4.278 2.885c.117-.641.044-1.32.067-1.973zm-4.872-.236l-5.087-3.396c.002-3.493-.047-6.988.015-10.48.85-.524 1.753-.954 2.627-1.434-.564-1.616.25-3.58 1.887-4.184 1.372-.563 3.025-.055 3.9 1.13l1.906-.978 1.916.987c.915-1.086 2.483-1.706 3.842-1.097 1.631.573 2.52 2.532 1.936 4.145.88.497 1.837.886 2.644 1.492.036 3.473 0 6.946-.003 10.419-3.374 2.233-6.693 4.55-10.122 6.699-.997 0-1.858-1.083-2.783-1.522a735.316 735.316 0 0 1-2.678-1.781z';    private const GHOST_HEART = 'M125.914 8.305c3.036-8.71 14.933 0 0 11.2-14.932-11.2-3.036-19.91 0-11.2z';    private const GHOST_PLUS = 'M111.368 8.97h7.324V1.645h7.512v7.323h7.324v7.513h-7.324v7.323h-7.512v-7.323h-7.324z';    private $debug;    private $charset;    private $handler;    private $caughtBuffer;    private $caughtLength;    private $fileLinkFormat;    public function __construct(bool $debug = true, string $charset = null, $fileLinkFormat = null)    {        $this->debug = $debug;        $this->charset = $charset ?: ini_get('default_charset') ?: 'UTF-8';        $this->fileLinkFormat = $fileLinkFormat;    }    /**     * Registers the exception handler.     *     * @param bool        $debug          Enable/disable debug mode, where the stack trace is displayed     * @param string|null $charset        The charset used by exception messages     * @param string|null $fileLinkFormat The IDE link template     *     * @return static     */    public static function register($debug = true, $charset = null, $fileLinkFormat = null)    {        $handler = new static($debug, $charset, $fileLinkFormat);        $prev = set_exception_handler([$handler, 'handle']);        if (\is_array($prev) && $prev[0] instanceof ErrorHandler) {            restore_exception_handler();            $prev[0]->setExceptionHandler([$handler, 'handle']);        }        return $handler;    }    /**     * Sets a user exception handler.     *     * @param callable $handler An handler that will be called on Exception     *     * @return callable|null The previous exception handler if any     */    public function setHandler(callable $handler = null)    {        $old = $this->handler;        $this->handler = $handler;        return $old;    }    /**     * Sets the format for links to source files.     *     * @param string|FileLinkFormatter $fileLinkFormat The format for links to source files     *     * @return string The previous file link format     */    public function setFileLinkFormat($fileLinkFormat)    {        $old = $this->fileLinkFormat;        $this->fileLinkFormat = $fileLinkFormat;        return $old;    }    /**     * Sends a response for the given Exception.     *     * To be as fail-safe as possible, the exception is first handled     * by our simple exception handler, then by the user exception handler.     * The latter takes precedence and any output from the former is cancelled,     * if and only if nothing bad happens in this handling path.     */    public function handle(\Exception $exception)    {        if (null === $this->handler || $exception instanceof OutOfMemoryException) {            $this->sendPhpResponse($exception);            return;        }        $caughtLength = $this->caughtLength = 0;        ob_start(function ($buffer) {            $this->caughtBuffer = $buffer;            return '';        });        $this->sendPhpResponse($exception);        while (null === $this->caughtBuffer && ob_end_flush()) {            // Empty loop, everything is in the condition        }        if (isset($this->caughtBuffer[0])) {            ob_start(function ($buffer) {                if ($this->caughtLength) {                    // use substr_replace() instead of substr() for mbstring overloading resistance                    $cleanBuffer = substr_replace($buffer, '', 0, $this->caughtLength);                    if (isset($cleanBuffer[0])) {                        $buffer = $cleanBuffer;                    }                }                return $buffer;            });            echo $this->caughtBuffer;            $caughtLength = ob_get_length();        }        $this->caughtBuffer = null;        try {            ($this->handler)($exception);            $this->caughtLength = $caughtLength;        } catch (\Exception $e) {            if (!$caughtLength) {                // All handlers failed. Let PHP handle that now.                throw $exception;            }        }    }    /**     * Sends the error associated with the given Exception as a plain PHP response.     *     * This method uses plain PHP functions like header() and echo to output     * the response.     *     * @param \Throwable|FlattenException $exception A \Throwable or FlattenException instance     */    public function sendPhpResponse($exception)    {        if ($exception instanceof \Throwable) {            $exception = FlattenException::createFromThrowable($exception);        }        if (!headers_sent()) {            header(sprintf('HTTP/1.0 %s', $exception->getStatusCode()));            foreach ($exception->getHeaders() as $name => $value) {                header($name.': '.$value, false);            }            header('Content-Type: text/html; charset='.$this->charset);        }        echo $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the full HTML content associated with the given exception.     *     * @param \Exception|FlattenException $exception An \Exception or FlattenException instance     *     * @return string The HTML content as a string     */    public function getHtml($exception)    {        if (!$exception instanceof FlattenException) {            $exception = FlattenException::create($exception);        }        return $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the HTML content associated with the given exception.     *     * @return string The content as a string     */    public function getContent(FlattenException $exception)    {        switch ($exception->getStatusCode()) {            case 404:                $title = 'Sorry, the page you are looking for could not be found.';                break;            default:                $title = $this->debug ? $this->escapeHtml($exception->getMessage()) : 'Whoops, looks like something went wrong.';        }        if (!$this->debug) {            return <<<EOF                <div class=""container"">                    <h1>$title</h1>                </div>EOF;        }        $content = '';        try {            $count = \count($exception->getAllPrevious());            $total = $count + 1;            foreach ($exception->toArray() as $position => $e) {                $ind = $count - $position + 1;                $class = $this->formatClass($e['class']);                $message = nl2br($this->escapeHtml($e['message']));                $content .= sprintf(<<<'EOF'                    <div class=""trace trace-as-html"">                        <table class=""trace-details"">                            <thead class=""trace-head""><tr><th>                                <h3 class=""trace-class"">                                    <span class=""text-muted"">(%d/%d)</span>                                    <span class=""exception_title"">%s</span>                                </h3>                                <p class=""break-long-words trace-message"">%s</p>                            </th></tr></thead>                            <tbody>EOF                    , $ind, $total, $class, $message);                foreach ($e['trace'] as $trace) {                    $content .= '<tr><td>';                    if ($trace['function']) {                        $content .= sprintf('at <span class=""trace-class"">%s</span><span class=""trace-type"">%s</span><span class=""trace-method"">%s</span>', $this->formatClass($trace['class']), $trace['type'], $trace['function']);                        if (isset($trace['args'])) {                            $content .= sprintf('(<span class=""trace-arguments"">%s</span>)', $this->formatArgs($trace['args']));                        }                    }                    if (isset($trace['file']) && isset($trace['line'])) {                        $content .= $this->formatPath($trace['file'], $trace['line']);                    }                    $content .= ""</td></tr>\n"";                }                $content .= ""</tbody>\n</table>\n</div>\n"";            }        } catch (\Exception $e) {            // something nasty happened and we cannot throw an exception anymore            if ($this->debug) {                $e = FlattenException::create($e);                $title = sprintf('Exception thrown when handling an exception (%s: %s)', $e->getClass(), $this->escapeHtml($e->getMessage()));            } else {                $title = 'Whoops, looks like something went wrong.';            }        }        $symfonyGhostImageContents = $this->getSymfonyGhostAsSvg();        return <<<EOF            <div class=""exception-summary"">                <div class=""container"">                    <div class=""exception-message-wrapper"">                        <h1 class=""break-long-words exception-message"">$title</h1>                        <div class=""exception-illustration hidden-xs-down"">$symfonyGhostImageContents</div>                    </div>                </div>            </div>            <div class=""container"">                $content            </div>EOF;    }    /**     * Gets the stylesheet associated with the given exception.     *     * @return string The stylesheet as a string     */    public function getStylesheet(FlattenException $exception)    {        if (!$this->debug) {            return <<<'EOF'                body { background-color: #fff; color: #222; font: 16px/1.5 -apple-system, BlinkMacSystemFont, ""Segoe UI"", Roboto, ""Helvetica Neue"", Arial, sans-serif; margin: 0; }                .container { margin: 30px; max-width: 600px; }                h1 { color: #dc3545; font-size: 24px; }EOF;        }        return <<<'EOF'            body { background-color: #F9F9F9; color: #222; font: 14px/1.4 Helvetica, Arial, sans-serif; margin: 0; padding-bottom: 45px; }            a { cursor: pointer; text-decoration: none; }            a:hover { text-decoration: underline; }            abbr[title] { border-bottom: none; cursor: help; text-decoration: none; }            code, pre { font: 13px/1.5 Consolas, Monaco, Menlo, ""Ubuntu Mono"", ""Liberation Mono"", monospace; }            table, tr, th, td { background: #FFF; border-collapse: collapse; vertical-align: top; }            table { background: #FFF; border: 1px solid #E0E0E0; box-shadow: 0px 0px 1px rgba(128, 128, 128, .2); margin: 1em 0; width: 100%; }            table th, table td { border: solid #E0E0E0; border-width: 1px 0; padding: 8px 10px; }            table th { background-color: #E0E0E0; font-weight: bold; text-align: left; }            .hidden-xs-down { display: none; }            .block { display: block; }            .break-long-words { -ms-word-break: break-all; word-break: break-all; word-break: break-word; -webkit-hyphens: auto; -moz-hyphens: auto; hyphens: auto; }            .text-muted { color: #999; }            .container { max-width: 1024px; margin: 0 auto; padding: 0 15px; }            .container::after { content: """"; display: table; clear: both; }            .exception-summary { background: #B0413E; border-bottom: 2px solid rgba(0, 0, 0, 0.1); border-top: 1px solid rgba(0, 0, 0, .3); flex: 0 0 auto; margin-bottom: 30px; }            .exception-message-wrapper { display: flex; align-items: center; min-height: 70px; }            .exception-message { flex-grow: 1; padding: 30px 0; }            .exception-message, .exception-message a { color: #FFF; font-size: 21px; font-weight: 400; margin: 0; }            .exception-message.long { font-size: 18px; }            .exception-message a { border-bottom: 1px solid rgba(255, 255, 255, 0.5); font-size: inherit; text-decoration: none; }            .exception-message a:hover { border-bottom-color: #ffffff; }            .exception-illustration { flex-basis: 111px; flex-shrink: 0; height: 66px; margin-left: 15px; opacity: .7; }            .trace + .trace { margin-top: 30px; }            .trace-head .trace-class { color: #222; font-size: 18px; font-weight: bold; line-height: 1.3; margin: 0; position: relative; }            .trace-message { font-size: 14px; font-weight: normal; margin: .5em 0 0; }            .trace-file-path, .trace-file-path a { color: #222; margin-top: 3px; font-size: 13px; }            .trace-class { color: #B0413E; }            .trace-type { padding: 0 2px; }            .trace-method { color: #B0413E; font-weight: bold; }            .trace-arguments { color: #777; font-weight: normal; padding-left: 2px; }            @media (min-width: 575px) {                .hidden-xs-down { display: initial; }            }EOF;    }    private function decorate(string $content, string $css): string    {        return <<<EOF<!DOCTYPE html><html>    <head>        <meta charset=""{$this->charset}"" />        <meta name=""robots"" content=""noindex,nofollow"" />        <style>$css</style>    </head>    <body>        $content    </body></html>EOF;    }    private function formatClass(string $class): string    {        $parts = explode('\\', $class);        return sprintf('<abbr title=""%s"">%s</abbr>', $class, array_pop($parts));    }    private function formatPath(string $path, int $line): string    {        $file = $this->escapeHtml(preg_match('#[^/\\\\]*+$#', $path, $file) ? $file[0] : $path);        $fmt = $this->fileLinkFormat ?: ini_get('xdebug.file_link_format') ?: get_cfg_var('xdebug.file_link_format');        if (!$fmt) {            return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');        }        if (\is_string($fmt)) {            $i = strpos($f = $fmt, '&', max(strrpos($f, '%f'), strrpos($f, '%l'))) ?: \strlen($f);            $fmt = [substr($f, 0, $i)] + preg_split('/&([^>]++)>/', substr($f, $i), -1, \PREG_SPLIT_DELIM_CAPTURE);            for ($i = 1; isset($fmt[$i]); ++$i) {                if (0 === strpos($path, $k = $fmt[$i++])) {                    $path = substr_replace($path, $fmt[$i], 0, \strlen($k));                    break;                }            }            $link = strtr($fmt[0], ['%f' => $path, '%l' => $line]);        } else {            try {                $link = $fmt->format($path, $line);            } catch (\Exception $e) {                return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');            }        }        return sprintf('<span class=""block trace-file-path"">in <a href=""%s"" title=""Go to source""><strong>%s</string>%s</a></span>', $this->escapeHtml($link), $file, 0 < $line ? ' line '.$line : '');    }    /**     * Formats an array as a string.     */    private function formatArgs(array $args): string    {        $result = [];        foreach ($args as $key => $item) {            if ('object' === $item[0]) {                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));            } elseif ('array' === $item[0]) {                $formattedValue = sprintf('<em>array</em>(%s)', \is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);            } elseif ('null' === $item[0]) {                $formattedValue = '<em>null</em>';            } elseif ('boolean' === $item[0]) {                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';            } elseif ('resource' === $item[0]) {                $formattedValue = '<em>resource</em>';            } else {                $formattedValue = str_replace(""\n"", '', $this->escapeHtml(var_export($item[1], true)));            }            $result[] = \is_int($key) ? $formattedValue : sprintf(""'%s' => %s"", $this->escapeHtml($key), $formattedValue);        }        return implode(', ', $result);    }    /**     * HTML-encodes a string.     */    private function escapeHtml(string $str): string    {        return htmlspecialchars($str, \ENT_COMPAT | \ENT_SUBSTITUTE, $this->charset);    }    private function getSymfonyGhostAsSvg(): string    {        return '<svg viewBox=""0 0 136 81"" xmlns=""http://www.w3.org/2000/svg"" fill-rule=""evenodd"" clip-rule=""evenodd"" stroke-linejoin=""round"" stroke-miterlimit=""1.4""><path d=""M92.4 20.4a23.2 23.2 0 0 1 9 1.9 23.7 23.7 0 0 1 5.2 3 24.3 24.3 0 0 1 3.4 3.4 24.8 24.8 0 0 1 5 9.4c.5 1.7.8 3.4 1 5.2v14.5h.4l.5.2a7.4 7.4 0 0 0 2.5.2l.2-.2.6-.8.8-1.3-.2-.1a5.5 5.5 0 0 1-.8-.3 5.6 5.6 0 0 1-2.3-1.8 5.7 5.7 0 0 1-.9-1.6 6.5 6.5 0 0 1-.2-2.8 7.3 7.3 0 0 1 .5-2l.3-.3.8-.9.3-.3c.2-.2.5-.3.8-.3H120.7c.2 0 .3-.1.4 0h.4l.2.1.3.2.2-.4.3-.4.1-.1 1.2-1 .3-.2.4-.1.4-.1h.3l1.5.1.4.1.8.5.1.2 1 1.1v.2H129.4l.4-.2 1.4-.5h1.1c.3 0 .7.2 1 .4.2 0 .3.2.5.3l.2.2.5.3.4.6.1.3.4 1.4.1.4v.6a7.8 7.8 0 0 1-.1.6 9.9 9.9 0 0 1-.8 2.4 7.8 7.8 0 0 1-3 3.3 6.4 6.4 0 0 1-1 .5 6.1 6.1 0 0 1-.6.2l-.7.1h-.1a23.4 23.4 0 0 1-.2 1.7 14.3 14.3 0 0 1-.6 2.1l-.8 2a9.2 9.2 0 0 1-.4.6l-.7 1a9.1 9.1 0 0 1-2.3 2.2c-.9.5-2 .6-3 .7l-1.4.1h-.5l-.4.1a15.8 15.8 0 0 1-2.8-.1v4.2a9.7 9.7 0 0 1-.7 3.5 9.6 9.6 0 0 1-1.7 2.8 9.3 9.3 0 0 1-3 2.3 9 9 0 0 1-5.4.7 9 9 0 0 1-3-1 9.4 9.4 0 0 1-2.7-2.5 10 10 0 0 1-1 1.2 9.3 9.3 0 0 1-2 1.3 9 9 0 0 1-2.4 1 9 9 0 0 1-6.5-1.1A9.4 9.4 0 0 1 85 77V77a10.9 10.9 0 0 1-.6.6 9.3 9.3 0 0 1-2.7 2 9 9 0 0 1-6 .8 9 9 0 0 1-2.4-1 9.3 9.3 0 0 1-2.3-1.7 9.6 9.6 0 0 1-1.8-2.8 9.7 9.7 0 0 1-.8-3.7v-4a18.5 18.5 0 0 1-2.9.2l-1.2-.1c-1.9-.3-3.7-1-5.1-2.1A8.2 8.2 0 0 1 58 64a10.2 10.2 0 0 1-.9-1.2 15.3 15.3 0 0 1-.7-1.3 20.8 20.8 0 0 1-1.9-6.2v-.2a6.5 6.5 0 0 1-1-.3 6.1 6.1 0 0 1-.6-.3 6.6 6.6 0 0 1-.9-.5 8.2 8.2 0 0 1-2.7-3.8 10 10 0 0 1-.3-1 10.3 10.3 0 0 1-.3-1.9V47v-.4l.1-.4.6-1.4.1-.2a2 2 0 0 1 .8-.8l.3-.2.3-.2a3.2 3.2 0 0 1 1.8-.5h.4l.3.2 1.4.6.2.2.4.3.3.4.7-.7.2-.2.4-.2.6-.2h2.1l.4.2.4.2.3.2.8 1 .2-.1h.1v-.1H63l1.1.1h.3l.8.5.3.4.7 1 .2.3.1.5a11 11 0 0 1 .2 1.5c0 .8 0 1.6-.3 2.3a6 6 0 0 1-.5 1.2 5.5 5.5 0 0 1-3.3 2.5 12.3 12.3 0 0 0 1.4 3h.1l.2.1 1 .2h1.5l.5-.2H67.8l.5-.2h.1V44v-.4a26.7 26.7 0 0 1 .3-2.3 24.7 24.7 0 0 1 5.7-12.5 24.2 24.2 0 0 1 3.5-3.3 23.7 23.7 0 0 1 4.9-3 23.2 23.2 0 0 1 5.6-1.7 23.7 23.7 0 0 1 4-.3zm-.3 2a21.2 21.2 0 0 0-8 1.7 21.6 21.6 0 0 0-4.8 2.7 22.2 22.2 0 0 0-3.2 3 22.7 22.7 0 0 0-5 9.2 23.4 23.4 0 0 0-.7 4.9v15.7l-.5.1a34.3 34.3 0 0 1-1.5.3h-.2l-.4.1h-.4l-.9.2a10 10 0 0 1-1.9 0c-.5 0-1-.2-1.5-.4a1.8 1.8 0 0 1-.3-.2 2 2 0 0 1-.3-.3 5.2 5.2 0 0 1-.1-.2 9 9 0 0 1-.6-.9 13.8 13.8 0 0 1-1-2 14.3 14.3 0 0 1-.6-2 14 14 0 0 1-.1-.8v-.2h.3a12.8 12.8 0 0 0 1.4-.2 4.4 4.4 0 0 0 .3 0 3.6 3.6 0 0 0 1.1-.7 3.4 3.4 0 0 0 1.2-1.7l.2-1.2a5.1 5.1 0 0 0 0-.8 7.2 7.2 0 0 0-.1-.8l-.7-1-1.2-.2-1 .7-.1 1.3a5 5 0 0 1 .1.4v.6a1 1 0 0 1 0 .3c-.1.3-.4.4-.7.5l-1.2.4v-.7A9.9 9.9 0 0 1 60 49l.3-.6v-.2l.1-.1v-1.6l-1-1.2h-1.5l-1 1.1v.4a5.3 5.3 0 0 0-.2.6 5.5 5.5 0 0 0 0 .5c0 .7 0 1.4.3 2 0 .4.2.8.4 1.2L57 51a9.5 9.5 0 0 1-1.1-.5h-.2a2 2 0 0 1-.4-.3c-.4-.4-.5-1-.6-1.6a5.6 5.6 0 0 1 0-.5v-.5-.5l-.6-1.5-1.4-.6-.9.3s-.2 0-.3.2a2 2 0 0 1-.1 0l-.6 1.4v.7a8.5 8.5 0 0 0 .5 2c.4 1.1 1 2.1 2 2.8a4.7 4.7 0 0 0 2.1.9h1a22.8 22.8 0 0 0 .1 1 18.1 18.1 0 0 0 .8 3.8 18.2 18.2 0 0 0 1.6 3.7l1 1.3c1 1 2.3 1.6 3.7 2a11.7 11.7 0 0 0 4.8 0h.4l.5-.2.5-.1.6-.2v6.6a8 8 0 0 0 .1 1.3 7.5 7.5 0 0 0 2.4 4.3 7.2 7.2 0 0 0 2.3 1.3 7 7 0 0 0 7-1.1 7.5 7.5 0 0 0 2-2.6A7.7 7.7 0 0 0 85 72V71a8.2 8.2 0 0 0 .2 1.3c0 .7.3 1.4.6 2a7.5 7.5 0 0 0 1.7 2.3 7.3 7.3 0 0 0 2.2 1.4 7.1 7.1 0 0 0 4.6.2 7.2 7.2 0 0 0 2.4-1.2 7.5 7.5 0 0 0 2.1-2.7 7.8 7.8 0 0 0 .7-2.4V71a9.3 9.3 0 0 0 .1.6 7.6 7.6 0 0 0 .6 2.5 7.5 7.5 0 0 0 2.4 3 7.1 7.1 0 0 0 7 .8 7.3 7.3 0 0 0 2.3-1.5 7.5 7.5 0 0 0 1.6-2.3 7.6 7.6 0 0 0 .5-2l.1-1.1v-6.7l.4.1a12.2 12.2 0 0 0 2 .5 11.1 11.1 0 0 0 2.5 0h.8l1.2-.1a9.5 9.5 0 0 0 1.4-.2l.9-.3a3.5 3.5 0 0 0 .6-.4l1.2-1.4a12.2 12.2 0 0 0 .8-1.2c0-.3.2-.5.3-.7a15.9 15.9 0 0 0 .7-2l.3-1.6v-1.3l.2-.9V54.6a15.5 15.5 0 0 0 1.8 0 4.5 4.5 0 0 0 1.4-.5 5.7 5.7 0 0 0 2.5-3.2 7.6 7.6 0 0 0 .4-1.5v-.3l-.4-1.4a5.2 5.2 0 0 1-.2-.1l-.4-.4a3.8 3.8 0 0 0-.2 0 1.4 1.4 0 0 0-.5-.2l-1.4.4-.7 1.3v.7a5.7 5.7 0 0 1-.1.8l-.7 1.4a1.9 1.9 0 0 1-.5.3h-.3a9.6 9.6 0 0 1-.8.3 8.8 8.8 0 0 1-.6 0l.2-.4.2-.5.2-.3v-.4l.1-.2V50l.1-1 .1-.6v-.6a4.8 4.8 0 0 0 0-.8v-.2l-1-1.1-1.5-.2-1.1 1-.2 1.4v.1l.2.4.2.3v.4l.1 1.1v.3l.1.5v.8a9.6 9.6 0 0 1-.8-.3l-.2-.1h-.3l-.8-.1h-.2a1.6 1.6 0 0 1-.2-.2.9.9 0 0 1-.2-.2 1 1 0 0 1-.1-.5l.2-.9v-1.2l-.9-.8h-1.2l-.8.9v.3a4.8 4.8 0 0 0-.3 2l.3.9a3.5 3.5 0 0 0 1.2 1.6l1 .5.8.2 1.4.1h.4l.2.1a12.1 12.1 0 0 1-1 2.6 13.2 13.2 0 0 1-.8 1.5 9.5 9.5 0 0 1-1 1.2l-.2.3a1.7 1.7 0 0 1-.4.3 2.4 2.4 0 0 1-.7.2h-2.5a7.8 7.8 0 0 1-.6-.2l-.7-.2h-.2a14.8 14.8 0 0 1-.6-.2 23.4 23.4 0 0 1-.4-.1l-.4-.1-.3-.1V43.9a34.6 34.6 0 0 0 0-.6 23.6 23.6 0 0 0-.4-3 22.7 22.7 0 0 0-1.5-4.7 22.6 22.6 0 0 0-4.6-6.7 21.9 21.9 0 0 0-6.9-4.7 21.2 21.2 0 0 0-8.1-1.8H92zm9.1 33.7l.3.1a1 1 0 0 1 .6.8v.4a8.4 8.4 0 0 1 0 .5 8.8 8.8 0 0 1-1.6 4.2l-1 1.3A10 10 0 0 1 95 66c-1.3.3-2.7.4-4 .3a10.4 10.4 0 0 1-2.7-.8 10 10 0 0 1-3.6-2.5 9.3 9.3 0 0 1-.8-1 9 9 0 0 1-.7-1.2 8.6 8.6 0 0 1-.8-3.4V57a1 1 0 0 1 .3-.6 1 1 0 0 1 1.3-.2 1 1 0 0 1 .4.8v.4a6.5 6.5 0 0 0 .5 2.2 7 7 0 0 0 2.1 2.8l1 .6c2.6 1.6 6 1.6 8.5 0a8 8 0 0 0 1.1-.6 7.6 7.6 0 0 0 1.2-1.2 7 7 0 0 0 1-1.7 6.5 6.5 0 0 0 .4-2.5 1 1 0 0 1 .7-1h.4zM30.7 43.7c-15.5 1-28.5-6-30.1-16.4C-1.2 15.7 11.6 4 29 1.3 46.6-1.7 62.3 5.5 64 17.1c1.6 10.4-8.7 21-23.7 25a31.2 31.2 0 0 0 0 .9v.3a19 19 0 0 0 .1 1l.1.4.1.9a4.7 4.7 0 0 0 .5 1l.7 1a9.2 9.2 0 0 0 1.2 1l1.5.8.6.8-.7.6-1.1.3a11.2 11.2 0 0 1-2.6.4 8.6 8.6 0 0 1-3-.5 8.5 8.5 0 0 1-1-.4 11.2 11.2 0 0 1-1.8-1.2 13.3 13.3 0 0 1-1-1 18 18 0 0 1-.7-.6l-.4-.4a23.4 23.4 0 0 1-1.3-1.8l-.1-.1-.3-.5V45l-.3-.6v-.7zM83.1 36c3.6 0 6.5 3.2 6.5 7.1 0 4-3 7.2-6.5 7.2S76.7 47 76.7 43 79.6 36 83 36zm18 0c3.6 0 6.5 3.2 6.5 7.1 0 4-2.9 7.2-6.4 7.2S94.7 47 94.7 43s3-7.1 6.5-7.1zm-18 6.1c2 0 3.5 1.6 3.5 3.6S85 49.2 83 49.2s-3.4-1.6-3.4-3.6S81.2 42 83 42zm17.9 0c1.9 0 3.4 1.6 3.4 3.6s-1.5 3.6-3.4 3.6c-2 0-3.5-1.6-3.5-3.6S99.1 42 101 42zM17 28c-.3 1.6-1.8 5-5.2 5.8-2.5.6-4.1-.8-4.5-2.6-.4-1.9.7-3.5 2.1-4.5A3.5 3.5 0 0 1 8 24.6c-.4-2 .8-3.7 3.2-4.2 1.9-.5 3.1.2 3.4 1.5.3 1.1-.5 2.2-1.8 2.5-.9.3-1.6 0-1.7-.6a1.4 1.4 0 0 1 0-.7s.3.2 1 0c.7-.1 1-.7.9-1.2-.2-.6-1-.8-1.8-.6-1 .2-2 1-1.7 2.6.3 1 .9 1.6 1.5 1.8l.7-.2c1-.2 1.5 0 1.6.5 0 .4-.2 1-1.2 1.2a3.3 3.3 0 0 1-1.5 0c-.9.7-1.6 1.9-1.3 3.2.3 1.3 1.3 2.2 3 1.8 2.5-.7 3.8-3.7 4.2-5-.3-.5-.6-1-.7-1.6-.1-.5.1-1 .9-1.2.4 0 .7.2.8.8a2.8 2.8 0 0 1 0 1l.7 1c.6-2 1.4-4 1.7-4 .6-.2 1.5.6 1.5.6-.8.7-1.7 2.4-2.3 4.2.8.6 1.6 1 2.1 1 .5-.1.8-.6 1-1.2-.3-2.2 1-4.3 2.3-4.6.7-.2 1.3.2 1.4.8.1.5 0 1.3-.9 1.7-.2-1-.6-1.3-1-1.3-.4.1-.7 1.4-.4 2.8.2 1 .7 1.5 1.3 1.4.8-.2 1.3-1.2 1.7-2.1-.3-2.1.9-4.2 2.2-4.5.7-.2 1.2.1 1.4 1 .4 1.4-1 2.8-2.2 3.4.3.7.7 1 1.3.9 1-.3 1.6-1.5 2-2.5l-.5-3v-.3s1.6-.3 1.8.6v.1c.2-.6.7-1.2 1.3-1.4.8-.1 1.5.6 1.7 1.6.5 2.2-.5 4.4-1.8 4.7H33a31.9 31.9 0 0 0 1 5.2c-.4.1-1.8.4-2-.4l-.5-5.6c-.5 1-1.3 2.2-2.5 2.4-1 .3-1.6-.3-2-1.1-.5 1-1.3 2.1-2.4 2.4-.8.2-1.5-.1-2-1-.3.8-.9 1.5-1.5 1.7-.7.1-1.5-.3-2.4-1-.3.8-.4 1.6-.4 2.2 0 0-.7 0-.8-.4-.1-.5 0-1.5.3-2.7a10.3 10.3 0 0 1-.7-.8zm38.2-17.8l.2.9c.5 1.9.4 4.4.8 6.4 0 .6-.4 3-1.4 3.3-.2 0-.3 0-.4-.4-.1-.7 0-1.6-.3-2.6-.2-1.1-.8-1.6-1.5-1.5-.8.2-1.3 1-1.6 2l-.1-.5c-.2-1-1.8-.6-1.8-.6a6.2 6.2 0 0 1 .4 1.3l.2 1c-.2.5-.6 1-1.2 1l-.2.1a7 7 0 0 0-.1-.8c-.3-1.1-1-2-1.6-1.8a.7.7 0 0 0-.4.3c-1.3.3-2.4 2-2.1 3.9-.2.9-.6 1.7-1 1.9-.5 0-.8-.5-1.1-1.8l-.1-1.2a4 4 0 0 0 0-1.7c0-.4-.4-.7-.8-.6-.7.2-.9 1.7-.5 3.8-.2 1-.6 2-1.3 2-.4.2-.8-.2-1-1l-.2-3c1.2-.5 2-1 1.8-1.7-.1-.5-.8-.7-.8-.7s0 .7-1 1.2l-.2-1.4c-.1-.6-.4-1-1.7-.6l.4 1 .2 1.5h-1v.8c0 .3.4.3 1 .2 0 1.3 0 2.7.2 3.6.3 1.4 1.2 2 2 1.7 1-.2 1.6-1.3 2-2.3.3 1.2 1 2 1.9 1.7.7-.2 1.2-1.1 1.6-2.2.4.8 1.1 1.1 2 1 1.2-.4 1.7-1.6 1.8-2.8h.2c.6-.2 1-.6 1.3-1 0 .8 0 1.5.2 2.1.1.5.3.7.6.6.5-.1 1-.9 1-.9a4 4 0 0 1-.3-1c-.3-1.3.3-3.6 1-3.7.2 0 .3.2.5.7v.8l.2 1.5v.7c.2.7.7 1.3 1.5 1 1.3-.2 2-2.6 2.1-3.9.3.2.6.2 1 .1-.6-2.2 0-6.1-.3-7.9-.1-.4-1-.5-1.7-.5h-.4zm-21.5 12c.4 0 .7.3 1 1.1.2 1.3-.3 2.6-.9 2.8-.2 0-.7 0-1-1.2v-.4c0-1.3.4-2 1-2.2zm-5.2 1c.3 0 .6.2.6.5.2.6-.3 1.3-1.2 2-.3-1.4.1-2.3.6-2.5zm18-.4c-.5.2-1-.4-1.2-1.2-.2-1 0-2.1.7-2.5v.5c.2.7.6 1.5 1.3 1.9 0 .7-.2 1.2-.7 1.3zm10-1.6c0 .5.4.7 1 .6.8-.2 1-1 .8-1.6 0-.5-.4-1-1-.8-.5.1-1 .9-.8 1.8zm-14.3-5.5c0-.4-.5-.7-1-.5-.8.2-1 1-.9 1.5.2.6.5 1 1 .8.5 0 1.1-1 1-1.8z"" fill=""#fff"" fill-opacity="".6""/>'.$this->addElementToGhost().'</svg>';    }    private function addElementToGhost(): string    {        if (!isset(self::GHOST_ADDONS[date('m-d')])) {            return '';        }        return '<path d=""'.self::GHOST_ADDONS[date('m-d')].'"" fill=""#fff"" fill-opacity=""0.6""></path>';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
114,ramsey_uuid_UuidFactory_1998," Returns an RFC 4122 variant Uuid, created from the provided bytes and version\\n\\n @param string $bytes The byte string to convert to a UUID\\n @param int $version The RFC 4122 version to apply to the UUID\\n\\n @return UuidInterface An instance of UuidInterface, created from the\\n     byte string and version\\n\\n @psalm-pure\\n","Vraća RFC 4122 varijantu Uuid, kreiranu od ponuđenih bajtova i verzije","    private function uuidFromBytesAndVersion(string $bytes, int $version): UuidInterface    {        /** @var array $unpackedTime */        $unpackedTime = unpack('n*', substr($bytes, 6, 2));        $timeHi = (int) $unpackedTime[1];        $timeHiAndVersion = pack('n*', BinaryUtils::applyVersion($timeHi, $version));        /** @var array $unpackedClockSeq */        $unpackedClockSeq = unpack('n*', substr($bytes, 8, 2));        $clockSeqHi = (int) $unpackedClockSeq[1];        $clockSeqHiAndReserved = pack('n*', BinaryUtils::applyVariant($clockSeqHi));        $bytes = substr_replace($bytes, $timeHiAndVersion, 6, 2);        $bytes = substr_replace($bytes, $clockSeqHiAndReserved, 8, 2);        if ($this->isDefaultFeatureSet) {            return LazyUuidFromString::fromBytes($bytes);        }        return $this->uuid($bytes);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
115,sebastianbergmann_exporter_Exporter_1035, Exports a value into a single-line string.\n\n The output of this method is similar to the output of\n SebastianBergmann\\Exporter\\Exporter::export().\n\n Newlines are replaced by the visible string '\\n'.\n Contents of arrays and objects (if any) are replaced by '...'.\n,Izvozi vrednost u jednoredni niz. Izlaz ove metode sličan je izlazu SebastianBergmann\\Exporter\\Exporter::export(). Novi redovi se zamenjuju vidljivim stringom '\\ n'. Sadržaj nizova i objekata (ako ih ima) zamenjuje se sa '...',"    public function shortenedExport(mixed $value): string    {        if (is_string($value)) {            $string = str_replace(""\n"", '', $this->export($value));            if (function_exists('mb_strlen') && function_exists('mb_substr') && mb_strlen($string) > 40) {                return mb_substr($string, 0, 30) . '...' . mb_substr($string, -7);            }            if (strlen($string) > 40) {                return substr($string, 0, 30) . '...' . substr($string, -7);            }            return $string;        }        if (is_object($value)) {            return sprintf(                '%s Object (%s)',                get_class($value),                count($this->toArray($value)) > 0 ? '...' : ''            );        }        if (is_array($value)) {            return sprintf(                'Array (%s)',                count($value) > 0 ? '...' : ''            );        }        return $this->export($value);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
116,markrogoyski_math-php_LOESS_3573, LOESS - Locally Weighted Scatterplot Smoothing (Local regression)\\n\\n A non-parametric method for fitting a smooth curve between two variables.\\n https://en.wikipedia.org/wiki/Local_regression\\n,LOESS - Lokalno ponderisano ujednačavanje dijagrama rasejavanja (lokalna regresija). Neparametarska metoda za uklapanje glatke krive između dve promenljive,"class LOESS extends NonParametricRegression{    use Methods\WeightedLeastSquares;    /**     * Smoothness parameter     * @var number     */    protected $Î±;    /**     * Order of the polynomial fit     * @var int     */    protected $Î»;    /**     * Number of points considered in the local regression     * @var int     */    protected $number_of_points;    /**     * @param array $points [ [x, y], [x, y], ... ]     * @param float $Î±      Smoothness parameter (bandwidth)     *                       Determines how much of the data is used to fit each local polynomial     *                       ((Î» + 1) / n, 1]     * @param int    $Î»      Order of the polynomial to fit     *     * @throws Exception\OutOfBoundsException if Î± is â‰¤ Î» + 1 or > 1     */    public function __construct($points, float $Î±, int $Î»)    {        $this->Î± = $Î±;        $this->Î» = $Î»;        parent::__construct($points);        // Î± âˆˆ ((Î» + 1) / n, 1]        if (($Î± <= ($Î» + 1) / $this->n) || $Î± > 1) {            throw new Exception\OutOfBoundsException('Smoothness parameter Î± must be between ' . ($Î» + 1) / $this->n . "" and 1; given $Î±"");        }        // Number of points considered in the local regression        $this->number_of_points = \min((int) \ceil($this->Î± * $this->n), $this->n);    }    /**     * Evaluate for x     * Use the smoothness parameter Î± to determine the subset of data to consider for     * local regression. Perform a weighted least squares regression and evaluate x.     *     * @param  float $x     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     * @throws Exception\MathException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     * @throws Exception\VectorException     */    public function evaluate(float $x): float    {        $Î± = $this->Î±;        $Î» = $this->Î»;        // The number of points considered in the local regression        $Î”x    = Single::abs(Single::subtract($this->xs, $x));        $Î±áµ—Ê°Î”x = Average::kthSmallest($Î”x, $this->number_of_points - 1);        $arg   = Single::min(Single::divide($Î”x, $Î±áµ—Ê°Î”x * \max($Î±, 1)), 1);        // Kernel function: tricube = (1-argÂ³)Â³        $tricube = Single::cube(Single::multiply(Single::subtract(Single::cube($arg), 1), -1));        $weights = $tricube;        // Local Regression Parameters        $parameters = $this->leastSquares($this->ys, $this->xs, $weights, $Î»);        $X          = MatrixFactory::vandermonde([$x], $Î» + 1);        return $X->multiply($parameters)[0][0];    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
117,PHPOffice_PHPWord_TemplateProcessor_947, Replace a block.\n\n @param string $blockname\n @param string $replacement\n,Zamena bloka,"    public function replaceBlock($blockname, $replacement)    {        $matches = array();        preg_match(            '/(<\?xml.*)(<w:p.*>\${' . $blockname . '}<\/w:.*?p>)(.*)(<w:p.*\${\/' . $blockname . '}<\/w:.*?p>)/is',            $this->tempDocumentMainPart,            $matches        );        if (isset($matches[3])) {            $this->tempDocumentMainPart = str_replace(                $matches[2] . $matches[3] . $matches[4],                $replacement,                $this->tempDocumentMainPart            );        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
118,erusev_parsedown_Parsedown_1872, Replace occurrences $regexp with $Elements in $text. Return an array of\n elements representing the replacement.\n,Zamenite pojave $regexp sa $Elements u $text. Vrati niz elemenata koji predstavljaju zamenu,"    protected static function pregReplaceElements($regexp, $Elements, $text)    {        $newElements = array();        while (preg_match($regexp, $text, $matches, PREG_OFFSET_CAPTURE))        {            $offset = $matches[0][1];            $before = substr($text, 0, $offset);            $after = substr($text, $offset + strlen($matches[0][0]));            $newElements[] = array('text' => $before);            foreach ($Elements as $Element)            {                $newElements[] = $Element;            }            $text = $after;        }        $newElements[] = array('text' => $text);        return $newElements;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
119,squizlabs_PHP_CodeSniffer_Fixer_889, Replace the entire contents of a token.\\n\\n @param int    $stackPtr The position of the token in the token stack.\\n @param string $content  The new content of the token.\\n\\n @return bool If the change was accepted.\\n,Zamenite celokupan sadržaj tokena,"    public function replaceToken($stackPtr, $content)    {        if ($this->inConflict === true) {            return false;        }        if ($this->inChangeset === false            && isset($this->fixedTokens[$stackPtr]) === true        ) {            $indent = ""\t"";            if (empty($this->changeset) === false) {                $indent .= ""\t"";            }            if (PHP_CODESNIFFER_VERBOSITY > 1) {                @ob_end_clean();                echo ""$indent* token $stackPtr has already been modified, skipping *"".PHP_EOL;                ob_start();            }            return false;        }        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $bt = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);            if ($bt[1]['class'] === 'PHP_CodeSniffer\Fixer') {                $sniff = $bt[2]['class'];                $line  = $bt[1]['line'];            } else {                $sniff = $bt[1]['class'];                $line  = $bt[0]['line'];            }            $sniff = Util\Common::getSniffCode($sniff);            $tokens     = $this->currentFile->getTokens();            $type       = $tokens[$stackPtr]['type'];            $tokenLine  = $tokens[$stackPtr]['line'];            $oldContent = Common::prepareForOutput($this->tokens[$stackPtr]);            $newContent = Common::prepareForOutput($content);            if (trim($this->tokens[$stackPtr]) === '' && isset($this->tokens[($stackPtr + 1)]) === true) {                // Add some context for whitespace only changes.                $append      = Common::prepareForOutput($this->tokens[($stackPtr + 1)]);                $oldContent .= $append;                $newContent .= $append;            }        }//end if        if ($this->inChangeset === true) {            $this->changeset[$stackPtr] = $content;            if (PHP_CODESNIFFER_VERBOSITY > 1) {                @ob_end_clean();                echo ""\t\tQ: $sniff:$line replaced token $stackPtr ($type on line $tokenLine) \""$oldContent\"" => \""$newContent\"""".PHP_EOL;                ob_start();            }            return true;        }        if (isset($this->oldTokenValues[$stackPtr]) === false) {            $this->oldTokenValues[$stackPtr] = [                'curr' => $content,                'prev' => $this->tokens[$stackPtr],                'loop' => $this->loops,            ];        } else {            if ($this->oldTokenValues[$stackPtr]['prev'] === $content                && $this->oldTokenValues[$stackPtr]['loop'] === ($this->loops - 1)            ) {                if (PHP_CODESNIFFER_VERBOSITY > 1) {                    $indent = ""\t"";                    if (empty($this->changeset) === false) {                        $indent .= ""\t"";                    }                    $loop = $this->oldTokenValues[$stackPtr]['loop'];                    @ob_end_clean();                    echo ""$indent**** $sniff:$line has possible conflict with another sniff on loop $loop; caused by the following change ****"".PHP_EOL;                    echo ""$indent**** replaced token $stackPtr ($type on line $tokenLine) \""$oldContent\"" => \""$newContent\"" ****"".PHP_EOL;                }                if ($this->oldTokenValues[$stackPtr]['loop'] >= ($this->loops - 1)) {                    $this->inConflict = true;                    if (PHP_CODESNIFFER_VERBOSITY > 1) {                        echo ""$indent**** ignoring all changes until next loop ****"".PHP_EOL;                    }                }                if (PHP_CODESNIFFER_VERBOSITY > 1) {                    ob_start();                }                return false;            }//end if            $this->oldTokenValues[$stackPtr]['prev'] = $this->oldTokenValues[$stackPtr]['curr'];            $this->oldTokenValues[$stackPtr]['curr'] = $content;            $this->oldTokenValues[$stackPtr]['loop'] = $this->loops;        }//end if        $this->fixedTokens[$stackPtr] = $this->tokens[$stackPtr];        $this->tokens[$stackPtr]      = $content;        $this->numFixes++;        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $indent = ""\t"";            if (empty($this->changeset) === false) {                $indent .= ""\tA: "";            }            if (ob_get_level() > 0) {                ob_end_clean();            }            echo ""$indent$sniff:$line replaced token $stackPtr ($type on line $tokenLine) \""$oldContent\"" => \""$newContent\"""".PHP_EOL;            ob_start();        }        return true;    }//end replaceToken()",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
120,bobthecow_psysh_Configuration_1547, Get a PHP manual database connection.\n\n @return \\PDO\n,Kreiranje PHP ručnog povezivanja sa bazom podataka,"    public function getManualDb()    {        if (!isset($this->manualDb)) {            $dbFile = $this->getManualDbFile();            if (\is_file($dbFile)) {                try {                    $this->manualDb = new \PDO('sqlite:'.$dbFile);                } catch (\PDOException $e) {                    if ($e->getMessage() === 'could not find driver') {                        throw new RuntimeException('SQLite PDO driver not found', 0, $e);                    } else {                        throw $e;                    }                }            }        }        return $this->manualDb;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
121,botman_botman_RedisCache_581, Redis <http://redis.io> cache backend\\n Requires phpredis native extension <https://github.com/phpredis/phpredis#installation>.\\n,Redis <http://redis.io> ke[iran bekend. Zahteva izvorni dodatak phpredis <https://github.com/phpredis/phpredis#installation>,"class RedisCache implements CacheInterface{    const KEY_PREFIX = 'botman:cache:';    /** @var Redis */    private $redis;    private $host;    private $port;    private $auth;    /**     * RedisCache constructor.     * @param $host     * @param $port     * @param $auth     */    public function __construct($host = '127.0.0.1', $port = 6379, $auth = null)    {        if (! class_exists('Redis')) {            throw new RuntimeException('phpredis extension is required for RedisCache');        }        $this->host = $host;        $this->port = $port;        $this->auth = $auth;        $this->connect();    }    /**     * Determine if an item exists in the cache.     *     * @param  string $key     * @return bool     */    public function has($key)    {        /*         * Version >= 4.0 of phpredis returns an integer instead of bool         */        $check = $this->redis->exists($this->decorateKey($key));        if (is_bool($check)) {            return $check;        }        return $check > 0;    }    /**     * Retrieve an item from the cache by key.     *     * @param  string $key     * @param  mixed $default     * @return mixed     */    public function get($key, $default = null)    {        return $this->redis->get($this->decorateKey($key)) ?: $default;    }    /**     * Retrieve an item from the cache and delete it.     *     * @param  string $key     * @param  mixed $default     * @return mixed     */    public function pull($key, $default = null)    {        $redisKey = $this->decorateKey($key);        $r = $this->redis->multi()            ->get($redisKey)            ->del($redisKey)            ->exec();        return $r[0] ?: $default;    }    /**     * Store an item in the cache.     *     * @param  string $key     * @param  mixed $value     * @param  \DateTime|int $minutes     * @return void     */    public function put($key, $value, $minutes)    {        if ($minutes instanceof \Datetime) {            $seconds = $minutes->getTimestamp() - time();        } else {            $seconds = $minutes * 60;        }        $this->redis->setex($this->decorateKey($key), $seconds, $value);    }    /**     * Namespace botman keys in redis.     *     * @param $key     * @return string     */    private function decorateKey($key)    {        return self::KEY_PREFIX.$key;    }    private function connect()    {        $this->redis = new Redis();        $this->redis->connect($this->host, $this->port);        if ($this->auth !== null) {            $this->redis->auth($this->auth);        }        if (function_exists('igbinary_serialize') && defined('Redis::SERIALIZER_IGBINARY')) {            $this->redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_IGBINARY);        } else {            $this->redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);        }    }    public function __wakeup()    {        $this->connect();    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
122,symfony_http-foundation_HeaderUtils_7879," Encodes a string as a quoted string, if necessary.\n\n If a string contains characters not allowed by the ""token"" construct in\n the HTTP specification, it is backslash-escaped and enclosed in quotes\n to match the ""quoted-string"" construct.\n","Ako je potrebno, kodira niz kao citirani niz. Ako niz sadrži znakove koji nisu dozvoljeni ""token"" konstrukcijom u HTTP specifikaciji, stavlja se kosa crta u navodnike da bi se podudarao sa "" citiranim stringom"" konstrukcija","    public static function quote(string $s): string    {        if (preg_match('/^[a-z0-9!#$%&\'*.^_`|~-]+$/i', $s)) {            return $s;        }        return '""'.addcslashes($s, '""\\""').'""';    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
123,BookStackApp_BookStack_Tag_760, Get a full URL to start a tag name and value search for this tag's values.\n,Dohvata URL do početka imena taga i pretražuje po vrednosti taj taga,    public function valueUrl(): string    {        return url('/search?term=%5B' . urlencode($this->name) .'%3D' . urlencode($this->value) . '%5D');    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
124,symfony_debug_ExceptionHandler_2259, Formats an array as a string.\\n,Formatira niz kao string,"    private function formatArgs(array $args): string    {        $result = [];        foreach ($args as $key => $item) {            if ('object' === $item[0]) {                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));            } elseif ('array' === $item[0]) {                $formattedValue = sprintf('<em>array</em>(%s)', \is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);            } elseif ('null' === $item[0]) {                $formattedValue = '<em>null</em>';            } elseif ('boolean' === $item[0]) {                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';            } elseif ('resource' === $item[0]) {                $formattedValue = '<em>resource</em>';            } else {                $formattedValue = str_replace(""\n"", '', $this->escapeHtml(var_export($item[1], true)));            }            $result[] = \is_int($key) ? $formattedValue : sprintf(""'%s' => %s"", $this->escapeHtml($key), $formattedValue);        }        return implode(', ', $result);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
125,symfony_process_PhpExecutableFinderTest_1550, tests find() with the env var PHP_PATH.\\\\n,Testira find () sa env var PHP_PATH,"class PhpExecutableFinder{    private $executableFinder;    public function __construct()    {        $this->executableFinder = new ExecutableFinder();    }    /**     * Finds The PHP executable.     *     * @return string|false The PHP executable path or false if it cannot be found     */    public function find(bool $includeArgs = true)    {        if ($php = getenv('PHP_BINARY')) {            if (!is_executable($php)) {                $command = '\\' === \DIRECTORY_SEPARATOR ? 'where' : 'command -v';                if ($php = strtok(exec($command.' '.escapeshellarg($php)), \PHP_EOL)) {                    if (!is_executable($php)) {                        return false;                    }                } else {                    return false;                }            }            return $php;        }        $args = $this->findArguments();        $args = $includeArgs && $args ? ' '.implode(' ', $args) : '';        // PHP_BINARY return the current sapi executable        if (\PHP_BINARY && \in_array(\PHP_SAPI, ['cgi-fcgi', 'cli', 'cli-server', 'phpdbg'], true)) {            return \PHP_BINARY.$args;        }        if ($php = getenv('PHP_PATH')) {            if (!@is_executable($php)) {                return false;            }            return $php;        }        if ($php = getenv('PHP_PEAR_PHP_BIN')) {            if (@is_executable($php)) {                return $php;            }        }        if (@is_executable($php = \PHP_BINDIR.('\\' === \DIRECTORY_SEPARATOR ? '\\php.exe' : '/php'))) {            return $php;        }        $dirs = [\PHP_BINDIR];        if ('\\' === \DIRECTORY_SEPARATOR) {            $dirs[] = 'C:\xampp\php\\';        }        return $this->executableFinder->find('php', false, $dirs);    }    /**     * Finds the PHP executable arguments.     *     * @return array The PHP executable arguments     */    public function findArguments()    {        $arguments = [];        if ('phpdbg' === \PHP_SAPI) {            $arguments[] = '-qrr';        }        return $arguments;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
126,symfony_process_PhpExecutableFinder_1452, An executable finder specifically designed for the PHP executable.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Johannes M. Schmitt <schmittjoh@gmail.com>\n,Izvršni pretraživač posebno dizajniran za PHP izvršnu datoteku,"class PhpExecutableFinder{    private $executableFinder;    public function __construct()    {        $this->executableFinder = new ExecutableFinder();    }    /**     * Finds The PHP executable.     *     * @return string|false The PHP executable path or false if it cannot be found     */    public function find(bool $includeArgs = true)    {        if ($php = getenv('PHP_BINARY')) {            if (!is_executable($php)) {                $command = '\\' === \DIRECTORY_SEPARATOR ? 'where' : 'command -v';                if ($php = strtok(exec($command.' '.escapeshellarg($php)), \PHP_EOL)) {                    if (!is_executable($php)) {                        return false;                    }                } else {                    return false;                }            }            return $php;        }        $args = $this->findArguments();        $args = $includeArgs && $args ? ' '.implode(' ', $args) : '';        // PHP_BINARY return the current sapi executable        if (\PHP_BINARY && \in_array(\PHP_SAPI, ['cgi-fcgi', 'cli', 'cli-server', 'phpdbg'], true)) {            return \PHP_BINARY.$args;        }        if ($php = getenv('PHP_PATH')) {            if (!@is_executable($php)) {                return false;            }            return $php;        }        if ($php = getenv('PHP_PEAR_PHP_BIN')) {            if (@is_executable($php)) {                return $php;            }        }        if (@is_executable($php = \PHP_BINDIR.('\\' === \DIRECTORY_SEPARATOR ? '\\php.exe' : '/php'))) {            return $php;        }        $dirs = [\PHP_BINDIR];        if ('\\' === \DIRECTORY_SEPARATOR) {            $dirs[] = 'C:\xampp\php\\';        }        return $this->executableFinder->find('php', false, $dirs);    }    /**     * Finds the PHP executable arguments.     *     * @return array The PHP executable arguments     */    public function findArguments()    {        $arguments = [];        if ('phpdbg' === \PHP_SAPI) {            $arguments[] = '-qrr';        }        return $arguments;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
127,getgrav_grav_Composer_1153, Class Composer\n @package Grav\\Common\n, Class Composer,"class Composer{    /** @const Default composer location */    const DEFAULT_PATH = 'bin/composer.phar';    /**     * Returns the location of composer.     *     * @return string     */    public static function getComposerLocation()    {        if (!function_exists('shell_exec') || stripos(PHP_OS, 'win') === 0) {            return self::DEFAULT_PATH;        }        // check for global composer install        $path = trim((string)shell_exec('command -v composer'));        // fall back to grav bundled composer        if (!$path || !preg_match('/(composer|composer\.phar)$/', $path)) {            $path = self::DEFAULT_PATH;        }        return $path;    }    /**     * Return the composer executable file path     *     * @return string     */    public static function getComposerExecutor()    {        $executor = PHP_BINARY . ' ';        $composer = static::getComposerLocation();        if ($composer !== static::DEFAULT_PATH && is_executable($composer)) {            $file = fopen($composer, 'rb');            $firstLine = fgets($file);            fclose($file);            if (!preg_match('/^#!.+php/i', $firstLine)) {                $executor = '';            }        }        return $executor . $composer;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
128,owncloud_core_AppHelper_1360, Gets the content of an URL by using CURL or a fallback if it is not\\n installed\\n @param string $url the url that should be fetched\\n @return string the content of the webpage\\n @deprecated 8.1.0 Use \\\\OCP\\\\IServerContainer::getHTTPClientService\\n,Dobija sadržaj URL-a pomoću CURL ili otpozivanja (fallback) ako nije instaliran,public function getUrlContent($url) {try {$client = \OC::$server->getHTTPClientService()->newClient();$response = $client->get($url);return $response->getBody();} catch (\Exception $e) {return false;},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
129,googleapis_google-api-php-client_VerifyTest_694, Most of the logic for ID token validation is in AuthTest -\n this is just a general check to ensure we verify a valid\n id token if one exists.\n,Većina logike za proveru ID tokena je u AuthTest delu ovo je samo opšta provera kako bismo bili sigurni da verifikujemo važeći ID token ako postoji,"  public function testLeewayIsUnchangedWhenPassingInJwt()  {    $this->checkToken();    $jwt = $this->getJwtService();    // set arbitrary leeway so we can check this later    $jwt::$leeway = $leeway = 1.5;    $client = $this->getClient();    $token = $client->getAccessToken();    if ($client->isAccessTokenExpired()) {      $token = $client->fetchAccessTokenWithRefreshToken();    }    $segments = explode('.', $token['id_token']);    $this->assertCount(3, $segments);    // Extract the client ID in this case as it wont be set on the test client.    $data = json_decode($jwt->urlSafeB64Decode($segments[1]));    $verify = new Google_AccessToken_Verify($client->getHttpClient(), null, $jwt);    $payload = $verify->verifyIdToken($token['id_token'], $data->aud);    // verify the leeway is set as it was    $this->assertEquals($leeway, $jwt::$leeway);  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
130,matomo-org_matomo_Container_165, Returns an element if its id is found\\n\\n @param    string  Element id to find\\n @return   HTML_QuickForm2_Node|null\\n,Vraća element ako je pronađen njegov id,    public function getElementById($id)    {        foreach ($this->getRecursiveIterator() as $element) {            if ($id == $element->getId()) {                return $element;            }        }        return null;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
131,fzaninotto_Faker_Iban_928, Calculates mod97 on a numeric string\n\n @param string $number Numeric string\n @return int\n,Izračunava mod97 na numeričkom nizu,"    public static function mod97($number)    {        $checksum = (int)$number[0];        for ($i = 1, $size = strlen($number); $i < $size; $i++) {            $checksum = (10 * $checksum + (int) $number[$i]) % 97;        }        return $checksum;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
132,dompdf_dompdf_Frame_593, Return the border box of the frame\n\n @return array\n,Vratite granični okvir frame-a,"    public function get_border_box()    {        $style = $this->_style;        $cb = $this->_containing_block;        $x = $this->_position[""x""] + (float)$style->length_in_pt($style->margin_left, $cb[""w""]);        $y = $this->_position[""y""] + (float)$style->length_in_pt($style->margin_top, $cb[""w""]);        $w = $style->length_in_pt(            [                $style->border_left_width,                $style->padding_left,                $style->width,                $style->padding_right,                $style->border_right_width            ],            $cb[""w""]);        $h = $style->length_in_pt(            [                $style->border_top_width,                $style->padding_top,                $style->padding_bottom,                $style->border_bottom_width,                $style->length_in_pt($style->height, $cb[""h""])            ],            $cb[""w""]);        return [0 => $x, ""x"" => $x,            1 => $y, ""y"" => $y,            2 => $w, ""w"" => $w,            3 => $h, ""h"" => $h];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
133,getgrav_grav_Browser_1454, Get the current major version identifier\n\n @return int the browser major version identifier\n,Dohvata trenutni identifikator glavne verzije,"    public function getVersion()    {        $version = explode('.', $this->getLongVersion());        return (int)$version[0];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
134,briannesbitt_Carbon_CarbonPeriod_317, Format the date period as ISO 8601.\\n\\n @return string\\n,Formatirajte datumski period kao ISO 8601,"    public function toIso8601String()    {        $parts = [];        if ($this->recurrences !== null) {            $parts[] = 'R'.$this->recurrences;        }        $parts[] = $this->startDate->toIso8601String();        $parts[] = $this->dateInterval->spec();        if ($this->endDate !== null) {            $parts[] = $this->endDate->toIso8601String();        }        return implode('/', $parts);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
135,symfony_http-foundation_Response_9885, Returns the Date header as a DateTime instance.\n\n @throws \\RuntimeException When the header is not parseable\n\n @final\n,Vraća zaglavlje datuma kao instancu DateTime,"    public function setDate(\DateTimeInterface $date): object    {        if ($date instanceof \DateTime) {            $date = \DateTimeImmutable::createFromMutable($date);        }        $date = $date->setTimezone(new \DateTimeZone('UTC'));        $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT');        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
136,composer_composer_Cache_2474, Reads/writes to a filesystem cache\n\n @author Jordi Boggiano <j.boggiano@seld.be>\n,Čita/piše u fajl sistem keš memoriju,"class Cache{    private static $cacheCollected = null;    private $io;    private $root;    private $enabled = true;    private $allowlist;    private $filesystem;    private $readOnly;    /**     * @param IOInterface $io     * @param string      $cacheDir   location of the cache     * @param string      $allowlist  List of characters that are allowed in path names (used in a regex character class)     * @param Filesystem  $filesystem optional filesystem instance     * @param bool        $readOnly   whether the cache is in readOnly mode     */    public function __construct(IOInterface $io, $cacheDir, $allowlist = 'a-z0-9.', Filesystem $filesystem = null, $readOnly = false)    {        $this->io = $io;        $this->root = rtrim($cacheDir, '/\\') . '/';        $this->allowlist = $allowlist;        $this->filesystem = $filesystem ?: new Filesystem();        $this->readOnly = (bool) $readOnly;        if (!self::isUsable($cacheDir)) {            $this->enabled = false;            return;        }        if (            (!is_dir($this->root) && !Silencer::call('mkdir', $this->root, 0777, true))            || !is_writable($this->root)        ) {            $this->io->writeError('<warning>Cannot create cache directory ' . $this->root . ', or directory is not writable. Proceeding without cache</warning>');            $this->enabled = false;        }    }    /**     * @param bool $readOnly     */    public function setReadOnly($readOnly)    {        $this->readOnly = (bool) $readOnly;    }    /**     * @return bool     */    public function isReadOnly()    {        return $this->readOnly;    }    public static function isUsable($path)    {        return !preg_match('{(^|[\\\\/])(\$null|nul|NUL|/dev/null)([\\\\/]|$)}', $path);    }    public function isEnabled()    {        return $this->enabled;    }    public function getRoot()    {        return $this->root;    }    public function read($file)    {        if ($this->enabled) {            $file = preg_replace('{[^'.$this->allowlist.']}i', '-', $file);            if (file_exists($this->root . $file)) {                $this->io->writeError('Reading '.$this->root . $file.' from cache', true, IOInterface::DEBUG);                return file_get_contents($this->root . $file);            }        }        return false;    }    public function write($file, $contents)    {        if ($this->enabled && !$this->readOnly) {            $file = preg_replace('{[^'.$this->allowlist.']}i', '-', $file);            $this->io->writeError('Writing '.$this->root . $file.' into cache', true, IOInterface::DEBUG);            $tempFileName = $this->root . $file . uniqid('.', true) . '.tmp';            try {                return file_put_contents($tempFileName, $contents) !== false && rename($tempFileName, $this->root . $file);            } catch (\ErrorException $e) {                $this->io->writeError('<warning>Failed to write into cache: '.$e->getMessage().'</warning>', true, IOInterface::DEBUG);                if (preg_match('{^file_put_contents\(\): Only ([0-9]+) of ([0-9]+) bytes written}', $e->getMessage(), $m)) {                    // Remove partial file.                    unlink($tempFileName);                    $message = sprintf(                        '<warning>Writing %1$s into cache failed after %2$u of %3$u bytes written, only %4$u bytes of free space available</warning>',                        $tempFileName,                        $m[1],                        $m[2],                        @disk_free_space(dirname($tempFileName))                    );                    $this->io->writeError($message);                    return false;                }                throw $e;            }        }        return false;    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
137,filp_whoops_FrameCollection_9359," Filters frames using a callable, returns the same FrameCollection\n\n @param  callable        $callable\n @return FrameCollection\n","Filtrira frejmove koristeći pozivnu promenjivu, vraća isti FrameCollection","    public function filter($callable)    {        $this->frames = array_values(array_filter($this->frames, $callable));        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
138,Intervention_image_Font_589, Filter function to access internal integer font values\\\\n\\\\n @return int\\\\n,Funkcija filtriranja za pristup unutrašnjim celobrojnim font vrednostima,"    private function getInternalFont()    {        $internalfont = is_null($this->file) ? 1 : $this->file;        $internalfont = is_numeric($internalfont) ? $internalfont : false;        if ( ! in_array($internalfont, [1, 2, 3, 4, 5])) {            throw new NotSupportedException(                sprintf('Internal GD font (%s) not available. Use only 1-5.', $internalfont)            );        }        return intval($internalfont);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
139,phalcon_cphalcon_Optimized_1558, Return filters for processing lines from safe universal phalcon.c\n\n @return array\n,Vraća filtere za linije za obradu iz sigurnog univerzalnog phalcon.c,"    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
140,symfony_finder_ExcludeDirectoryFilterIterator_1141," Filters the iterator values.\n\n @return bool True if the value should be kept, false otherwise\n",Filtrira vrednosti iteratora,"    public function accept()    {        if ($this->isRecursive && isset($this->excludedDirs[$this->getFilename()]) && $this->isDir()) {            return false;        }        if ($this->excludedPattern) {            $path = $this->isDir() ? $this->current()->getRelativePathname() : $this->current()->getRelativePath();            $path = str_replace('\\', '/', $path);            return !preg_match($this->excludedPattern, $path);        }        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
141,symfony_http-foundation_AcceptHeader_8732, Filters items on their value using given regex.\n\n @return self\n,Filtrira stavke prema njihovoj vrednosti pomoću datog regularnog izraza,"    public function filter(string $pattern)    {        return new self(array_filter($this->items, function (AcceptHeaderItem $item) use ($pattern) {            return preg_match($pattern, $item->getValue());        }));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
142,BookStackApp_BookStack_ActivityService_742, Filters out similar activity.\n @param Activity[] $activities\n @return array\n,Filtrira slične aktivnosti,    protected function filterSimilar(iterable $activities): array    {        $newActivity = [];        $previousItem = null;        foreach ($activities as $activityItem) {            if (!$previousItem || !$activityItem->isSimilarTo($previousItem)) {                $newActivity[] = $activityItem;            }            $previousItem = $activityItem;        }        return $newActivity;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
143,briannesbitt_Carbon_CarbonPeriod_278, Parse given ISO 8601 string into an array of arguments.\\n\\n @SuppressWarnings(PHPMD.ElseExpression)\\n\\n @param string $iso\\n\\n @return array\\n,Analizirajte dati ISO 8601 string u niz argumenata,"    protected static function parseIso8601($iso)    {        $result = [];        $interval = null;        $start = null;        $end = null;        foreach (explode('/', $iso) as $key => $part) {            if ($key === 0 && preg_match('/^R([0-9]*)$/', $part, $match)) {                $parsed = \strlen($match[1]) ? (int) $match[1] : null;            } elseif ($interval === null && $parsed = CarbonInterval::make($part)) {                $interval = $part;            } elseif ($start === null && $parsed = Carbon::make($part)) {                $start = $part;            } elseif ($end === null && $parsed = Carbon::make(static::addMissingParts($start ?? '', $part))) {                $end = $part;            } else {                throw new InvalidPeriodParameterException(""Invalid ISO 8601 specification: $iso."");            }            $result[] = $parsed;        }        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
144,phalcon_cphalcon_generate-api-docs_2099, Read the file and parse it\n,Pročitajte datoteku i raščlanite,"function processDocument(string $file): array{    $return   = [];    $contents = file_get_contents($file);    $parse    = zephir_parse_file($contents, '(eval code)');    foreach ($parse as $item) {        $type = $item['type'] ?? '';        if ('namespace' === $type) {            $return['namespace'] = $item['name'];            continue;        }        if ('comment' === $type) {            $return['comment'] = getDocblockMethod($item['value']);            continue;        }        if ('use' === $type) {            $uses    = $return['uses'] ?? [];            $aliases = $item['aliases'];            foreach ($aliases as $alias) {                $uses[] = $alias['name'];            }            $return['uses'] = $uses;        }        if ('class' === $type || 'interface' === $type) {            $signature = '';            if (1 === ($item['final'] ?? 0)) {                $signature .= ' Final';            }            if (1 === ($item['abstract'] ?? 0)) {                $signature .= ' Abstract';            }            $signature           .= ('class' === $type) ? ' Class ' : ' Interface ';            $signature           .= $return['namespace'] . '\\' . $item['name'];            $return['signature'] = ltrim($signature);            //$return['signature'] = ltrim(str_replace('Phalcon\\', '', $signature));            $return['extends'] = $item['extends'] ?? '';            if (true === is_array($return['extends'])) {                $return['extends'] = $return['extends'][0]['value'];            }            $implements = $item['implements'] ?? [];            if (count($implements) > 0) {                foreach ($implements as $implement) {                    $return['implements'][] = $implement['value'];                }            }            $definition           = $item['definition'] ?? [];            $return['constants']  = parseConstants($definition);            $return['properties'] = parseProperties($definition);            $return['methods']    = parseMethods($definition);        }    }    return $return;}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
145,mockery_mockery_Container_439, Get current ordered number\\\\\\\\n\\\\\\\\n @return int\\\\\\\\n,Dobijte trenutni naručeni broj,    public function mockery_getCurrentOrder()    {        return $this->_currentOrder;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
146,w7corp_easywechat_Client_2087, Get current url.\\n\\n @return string\\n,Preuzmi trenutni url,    public function getUrl(): string    {        if ($this->url) {            return $this->url;        }        return Support\current_url();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
147,PrestaShop_PrestaShop_AdminAccessController_861," Get the current profile id.\n\n @return int the $_GET['profile'] if valid, else 1 (the first profile id)\n",Preuzmi trenutni profil,    public function getCurrentProfileId()    {        return (isset($_GET['id_profile']) && !empty($_GET['id_profile']) && is_numeric($_GET['id_profile'])) ? (int) $_GET['id_profile'] : 1;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
148,Intervention_image_AbstractEncoder_453, Processes and returns encoded image as data-url string\n\n @return string\n,Obrađuje i vraća kodiranu sliku kao data-url string,"    protected function processDataUrl()    {        $mime = $this->image->mime ? $this->image->mime : 'image/png';        return sprintf('data:%s;base64,%s',            $mime,            base64_encode($this->process($this->image, $mime, $this->quality))        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
149,symfony_http-foundation_Cookie_7839, Creates a cookie copy with a new value.\n\n @return static\n,Stvara kopiju kolačića sa novom vrednošću,    public function withValue(?string $value): self    {        $cookie = clone $this;        $cookie->value = $value;        return $cookie;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
150,symfony_http-foundation_Cookie_9709, Creates a cookie copy with a new path on the server in which the cookie will be available on.\n\n @return static\n,Stvara kopiju kolačića sa novom putanjom na serveru na kojem će kolačić biti dostupan,    public function withPath(string $path): self    {        $cookie = clone $this;        $cookie->path = '' === $path ? '/' : $path;        return $cookie;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
151,symfony_http-foundation_Cookie_9711, Returns the cookie as a string.\n\n @return string The cookie\n,Vraća kolačić kao string,"    public function __toString()    {        if ($this->isRaw()) {            $str = $this->getName();        } else {            $str = str_replace(self::RESERVED_CHARS_FROM, self::RESERVED_CHARS_TO, $this->getName());        }        $str .= '=';        if ('' === (string) $this->getValue()) {            $str .= 'deleted; expires='.gmdate('D, d-M-Y H:i:s T', time() - 31536001).'; Max-Age=0';        } else {            $str .= $this->isRaw() ? $this->getValue() : rawurlencode($this->getValue());            if (0 !== $this->getExpiresTime()) {                $str .= '; expires='.gmdate('D, d-M-Y H:i:s T', $this->getExpiresTime()).'; Max-Age='.$this->getMaxAge();            }        }        if ($this->getPath()) {            $str .= '; path='.$this->getPath();        }        if ($this->getDomain()) {            $str .= '; domain='.$this->getDomain();        }        if (true === $this->isSecure()) {            $str .= '; secure';        }        if (true === $this->isHttpOnly()) {            $str .= '; httponly';        }        if (null !== $this->getSameSite()) {            $str .= '; samesite='.$this->getSameSite();        }        return $str;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
152,guzzle_guzzle_Middleware_1084, Middleware that adds cookies to requests.\n\n The options array must be set to a CookieJarInterface in order to use\n cookies. This is typically handled for you by a client.\n\n @return callable Returns a function that accepts the next handler.\n,Međuprogrami koji dodaju kolačiće zahtevima. Niz opcija mora biti postavljeno na CookieJarInterface da bi se koristilo kolačiće. Ovo za vas obično rešava klijent,"    public static function cookies(): callable    {        return static function (callable $handler): callable {            return static function ($request, array $options) use ($handler) {                if (empty($options['cookies'])) {                    return $handler($request, $options);                } elseif (!($options['cookies'] instanceof CookieJarInterface)) {                    throw new \InvalidArgumentException('cookies must be an instance of GuzzleHttp\Cookie\CookieJarInterface');                }                $cookieJar = $options['cookies'];                $request = $cookieJar->withCookieHeader($request);                return $handler($request, $options)                    ->then(                        static function (ResponseInterface $response) use ($cookieJar, $request): ResponseInterface {                            $cookieJar->extractCookies($request, $response);                            return $response;                        }                    );            };        };    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
153,markrogoyski_math-php_Set_3410, Remove an element from the set\\n Does nothing if the element does not exist in the set.\\n\\n @param  mixed $x\\n\\n @return Set (this set)\\n,Uklonite element iz skupa. Ne radi ništa ako element ne postoji u skupu,    public function remove($x): Set    {        unset($this->A[$this->getKey($x)]);        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
154,markrogoyski_math-php_Set_3411, Remove elements from the set\n Does nothing if the element does not exist in the set.\n\n @param  array $x\n\n @return Set (this set)\n,Ukloni elemente iz skupa. Ne čini ništa ako element ne postoji u skupu,    public function removeMulti(array $x): Set    {        foreach ($x as $member) {            unset($this->A[$this->getKey($member)]);        }        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
155,filp_whoops_Frame_7485," Unserializes the frame data, while also preserving\n any existing comment data.\n\n @see Serializable::unserialize\n @param string $serializedFrame\n","Neserijalizuje podatke okvira, istovremeno zadržavajući sve postojeće podatke komentara",    public function unserialize($serializedFrame)    {        $frame = unserialize($serializedFrame);        if (!empty($frame['_comments'])) {            $this->comments = $frame['_comments'];            unset($frame['_comments']);        }        $this->frame = $frame;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
156,filp_whoops_FrameCollection_7120, Gets the innermost part of stack trace that is not the same as that of outer exception\n\n @param  FrameCollection $parentFrames Outer exception frames to compare tail against\n @return Frame[]\n,Dobiva unutrašnji deo traga steka koji nije isti kao onaj spoljnog izuzetka,    public function topDiff(FrameCollection $parentFrames)    {        $diff = $this->frames;        $parentFrames = $parentFrames->getArray();        $p = count($parentFrames)-1;        for ($i = count($diff)-1; $i >= 0 && $p >= 0; $i--) {            /** @var Frame $tailFrame */            $tailFrame = $diff[$i];            if ($tailFrame->equals($parentFrames[$p])) {                unset($diff[$i]);            }            $p--;        }        return $diff;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
157,matomo-org_matomo_RowEvolution_983," Given the Row evolution dataTable, and the associated metadata,\n enriches the metadata with min/max values, and % change between the first period and the last one\n @param array $metadata\n @param DataTable\\Map $dataTable\n","S datim redom dataTable i povezanim metapodacima, obogaćuje metapodatke min/max vrednostima i % promena između prvog i poslednjeg perioda","    private function enhanceRowEvolutionMetaData(&$metadata, $dataTable)    {        // prepare result array for metrics        $metricsResult = array();        foreach ($metadata['metrics'] as $metric => $name) {            $metricsResult[$metric] = array('name' => $name);            if (!empty($metadata['logos'][$metric])) {                $metricsResult[$metric]['logo'] = $metadata['logos'][$metric];            }        }        unset($metadata['logos']);        $subDataTables = $dataTable->getDataTables();        if (empty($subDataTables)) {            throw new \Exception(""Unexpected state: row evolution API call returned empty DataTable\\Map."");        }        $firstDataTable = reset($subDataTables);        $this->checkDataTableInstance($firstDataTable);        $firstDataTableRow = $firstDataTable->getFirstRow();        $lastDataTable = end($subDataTables);        $this->checkDataTableInstance($lastDataTable);        $lastDataTableRow = $lastDataTable->getFirstRow();        // Process min/max values        $firstNonZeroFound = array();        foreach ($subDataTables as $subDataTable) {            // $subDataTable is the report for one period, it has only one row            $firstRow = $subDataTable->getFirstRow();            foreach ($metadata['metrics'] as $metric => $label) {                $value = $firstRow ? floatval($firstRow->getColumn($metric)) : 0;                if ($value > 0) {                    $firstNonZeroFound[$metric] = true;                } else if (!isset($firstNonZeroFound[$metric])) {                    continue;                }                if (!isset($metricsResult[$metric]['min'])                    || $metricsResult[$metric]['min'] > $value                ) {                    $metricsResult[$metric]['min'] = $value;                }                if (!isset($metricsResult[$metric]['max'])                    || $metricsResult[$metric]['max'] < $value                ) {                    $metricsResult[$metric]['max'] = $value;                }            }        }        // Process % change between first/last values        foreach ($metadata['metrics'] as $metric => $label) {            $first = $firstDataTableRow ? floatval($firstDataTableRow->getColumn($metric)) : 0;            $last = $lastDataTableRow ? floatval($lastDataTableRow->getColumn($metric)) : 0;            // do not calculate evolution if the first value is 0 (to avoid divide-by-zero)            if ($first == 0) {                continue;            }            $change = CalculateEvolutionFilter::calculate($last, $first, $quotientPrecision = 0, true, true);            $metricsResult[$metric]['change'] = $change;        }        $metadata['metrics'] = $metricsResult;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
158,googleapis_google-api-php-client_Model_657, Initialize this object's properties from an array.\\\\\\\\n\\\\\\\\n @param array $array Used to seed this object's properties.\\\\\\\\n @return void\\\\\\\\n,Inicijalizuje svojstva objekta iz niza,"  protected function mapTypes($array)  {    // Hard initialise simple types, lazy load more complex ones.    foreach ($array as $key => $val) {      if ($keyType = $this->keyType($key)) {        $dataType = $this->dataType($key);        if ($dataType == 'array' || $dataType == 'map') {          $this->$key = array();          foreach ($val as $itemKey => $itemVal) {            if ($itemVal instanceof $keyType) {              $this->{$key}[$itemKey] = $itemVal;            } else {              $this->{$key}[$itemKey] = new $keyType($itemVal);            }          }        } elseif ($val instanceof $keyType) {          $this->$key = $val;        } else {          $this->$key = new $keyType($val);        }        unset($array[$key]);      } elseif (property_exists($this, $key)) {          $this->$key = $val;          unset($array[$key]);      } elseif (property_exists($this, $camelKey = $this->camelCase($key))) {          // This checks if property exists as camelCase, leaving it in array as snake_case          // in case of backwards compatibility issues.          $this->$camelKey = $val;      }    }    $this->modelData = $array;  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
159,squizlabs_PHP_CodeSniffer_Config_865, Unset the value of an inaccessible property.\n\n @param string $name The name of the property.\n\n @return void\n,"Poništite vrednost nepristupačnog svojstva
",    public function __unset($name)    {        $this->settings[$name] = null;    }//end __unset(),0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
160,wallabag_wallabag_SymfonyRequirements_2453, This class specifies all requirements and optional recommendations that\n are necessary to run the Symfony Standard Edition.\n\n @author Tobias Schultze <http://tobion.de>\n @author Fabien Potencier <fabien@symfony.com>\n,Ova klasa navodi sve zahteve i opcionalne preporuke koji su potrebni za pokretanje Symfony Standard Edition,"class SymfonyRequirements extends RequirementCollection{    const LEGACY_REQUIRED_PHP_VERSION = '5.3.3';    const REQUIRED_PHP_VERSION = '5.5.9';    /**     * Constructor that initializes the requirements.     */    public function __construct()    {        /* mandatory requirements follow */        $installedPhpVersion = PHP_VERSION;        $requiredPhpVersion = $this->getPhpRequiredVersion();        $this->addRecommendation(            $requiredPhpVersion,            'Vendors should be installed in order to check all requirements.',            'Run the <code>composer install</code> command.',            'Run the ""composer install"" command.'        );        if (false !== $requiredPhpVersion) {            $this->addRequirement(                version_compare($installedPhpVersion, $requiredPhpVersion, '>='),                sprintf('PHP version must be at least %s (%s installed)', $requiredPhpVersion, $installedPhpVersion),                sprintf('You are running PHP version ""<strong>%s</strong>"", but Symfony needs at least PHP ""<strong>%s</strong>"" to run.                Before using Symfony, upgrade your PHP installation, preferably to the latest version.',                    $installedPhpVersion, $requiredPhpVersion),                sprintf('Install PHP %s or newer (installed version is %s)', $requiredPhpVersion, $installedPhpVersion)            );        }        $this->addRequirement(            version_compare($installedPhpVersion, '5.3.16', '!='),            'PHP version must not be 5.3.16 as Symfony won\'t work properly with it',            'Install PHP 5.3.17 or newer (or downgrade to an earlier PHP version)'        );        $this->addRequirement(            is_dir(__DIR__.'/../vendor/composer'),            'Vendor libraries must be installed',            'Vendor libraries are missing. Install composer following instructions from <a href=""http://getcomposer.org/"">http://getcomposer.org/</a>. '.                'Then run ""<strong>php composer.phar install</strong>"" to install them.'        );        $cacheDir = is_dir(__DIR__.'/../var/cache') ? __DIR__.'/../var/cache' : __DIR__.'/cache';        $this->addRequirement(            is_writable($cacheDir),            'app/cache/ or var/cache/ directory must be writable',            'Change the permissions of either ""<strong>app/cache/</strong>"" or  ""<strong>var/cache/</strong>"" directory so that the web server can write into it.'        );        $logsDir = is_dir(__DIR__.'/../var/logs') ? __DIR__.'/../var/logs' : __DIR__.'/logs';        $this->addRequirement(            is_writable($logsDir),            'app/logs/ or var/logs/ directory must be writable',            'Change the permissions of either ""<strong>app/logs/</strong>"" or  ""<strong>var/logs/</strong>"" directory so that the web server can write into it.'        );        if (version_compare($installedPhpVersion, '7.0.0', '<')) {            $this->addPhpIniRequirement(                'date.timezone', true, false,                'date.timezone setting must be set',                'Set the ""<strong>date.timezone</strong>"" setting in php.ini<a href=""#phpini"">*</a> (like Europe/Paris).'            );        }        if (false !== $requiredPhpVersion && version_compare($installedPhpVersion, $requiredPhpVersion, '>=')) {            $this->addRequirement(                in_array(@date_default_timezone_get(), DateTimeZone::listIdentifiers(), true),                sprintf('Configured default timezone ""%s"" must be supported by your installation of PHP', @date_default_timezone_get()),                'Your default timezone is not supported by PHP. Check for typos in your <strong>php.ini</strong> file and have a look at the list of deprecated timezones at <a href=""http://php.net/manual/en/timezones.others.php"">http://php.net/manual/en/timezones.others.php</a>.'            );        }        $this->addRequirement(            function_exists('iconv'),            'iconv() must be available',            'Install and enable the <strong>iconv</strong> extension.'        );        $this->addRequirement(            function_exists('json_encode'),            'json_encode() must be available',            'Install and enable the <strong>JSON</strong> extension.'        );        $this->addRequirement(            function_exists('session_start'),            'session_start() must be available',            'Install and enable the <strong>session</strong> extension.'        );        $this->addRequirement(            function_exists('ctype_alpha'),            'ctype_alpha() must be available',            'Install and enable the <strong>ctype</strong> extension.'        );        $this->addRequirement(            function_exists('token_get_all'),            'token_get_all() must be available',            'Install and enable the <strong>Tokenizer</strong> extension.'        );        $this->addRequirement(            function_exists('simplexml_import_dom'),            'simplexml_import_dom() must be available',            'Install and enable the <strong>SimpleXML</strong> extension.'        );        if (function_exists('apc_store') && ini_get('apc.enabled')) {            if (version_compare($installedPhpVersion, '5.4.0', '>=')) {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.1.13', '>='),                    'APC version must be at least 3.1.13 when using PHP 5.4',                    'Upgrade your <strong>APC</strong> extension (3.1.13+).'                );            } else {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.0.17', '>='),                    'APC version must be at least 3.0.17',                    'Upgrade your <strong>APC</strong> extension (3.0.17+).'                );            }        }        $this->addPhpIniRequirement('detect_unicode', false);        if (extension_loaded('suhosin')) {            $this->addPhpIniRequirement(                'suhosin.executor.include.whitelist',                create_function('$cfgValue', 'return false !== stripos($cfgValue, ""phar"");'),                false,                'suhosin.executor.include.whitelist must be configured correctly in php.ini',                'Add ""<strong>phar</strong>"" to <strong>suhosin.executor.include.whitelist</strong> in php.ini<a href=""#phpini"">*</a>.'            );        }        if (extension_loaded('xdebug')) {            $this->addPhpIniRequirement(                'xdebug.show_exception_trace', false, true            );            $this->addPhpIniRequirement(                'xdebug.scream', false, true            );            $this->addPhpIniRecommendation(                'xdebug.max_nesting_level',                create_function('$cfgValue', 'return $cfgValue > 100;'),                true,                'xdebug.max_nesting_level should be above 100 in php.ini',                'Set ""<strong>xdebug.max_nesting_level</strong>"" to e.g. ""<strong>250</strong>"" in php.ini<a href=""#phpini"">*</a> to stop Xdebug\'s infinite recursion protection erroneously throwing a fatal error in your project.'            );        }        $pcreVersion = defined('PCRE_VERSION') ? (float) PCRE_VERSION : null;        $this->addRequirement(            null !== $pcreVersion,            'PCRE extension must be available',            'Install the <strong>PCRE</strong> extension (version 8.0+).'        );        if (extension_loaded('mbstring')) {            $this->addPhpIniRequirement(                'mbstring.func_overload',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'string functions should not be overloaded',                'Set ""<strong>mbstring.func_overload</strong>"" to <strong>0</strong> in php.ini<a href=""#phpini"">*</a> to disable function overloading by the mbstring extension.'            );        }        /* optional recommendations follow */        if (file_exists(__DIR__.'/../vendor/composer')) {            require_once __DIR__.'/../vendor/autoload.php';            try {                $r = new ReflectionClass('Sensio\Bundle\DistributionBundle\SensioDistributionBundle');                $contents = file_get_contents(dirname($r->getFileName()).'/Resources/skeleton/app/SymfonyRequirements.php');            } catch (ReflectionException $e) {                $contents = '';            }            $this->addRecommendation(                file_get_contents(__FILE__) === $contents,                'Requirements file should be up-to-date',                'Your requirements file is outdated. Run composer install and re-check your configuration.'            );        }        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.4', '>='),            'You should use at least PHP 5.3.4 due to PHP bug #52083 in earlier versions',            'Your project might malfunction randomly due to PHP bug #52083 (""Notice: Trying to get property of non-object""). Install PHP 5.3.4 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.8', '>='),            'When using annotations you should have at least PHP 5.3.8 due to PHP bug #55156',            'Install PHP 5.3.8 or newer if your project uses annotations.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.0', '!='),            'You should not use PHP 5.4.0 due to the PHP bug #61453',            'Your project might not work properly due to the PHP bug #61453 (""Cannot dump definitions which have method calls""). Install PHP 5.4.1 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.11', '>='),            'When using the logout handler from the Symfony Security Component, you should have at least PHP 5.4.11 due to PHP bug #63379 (as a workaround, you can also set invalidate_session to false in the security logout handler configuration)',            'Install PHP 5.4.11 or newer if your project uses the logout handler from the Symfony Security Component.'        );        $this->addRecommendation(            (version_compare($installedPhpVersion, '5.3.18', '>=') && version_compare($installedPhpVersion, '5.4.0', '<'))            ||            version_compare($installedPhpVersion, '5.4.8', '>='),            'You should use PHP 5.3.18+ or PHP 5.4.8+ to always get nice error messages for fatal errors in the development environment due to PHP bug #61767/#60909',            'Install PHP 5.3.18+ or PHP 5.4.8+ if you want nice error messages for all fatal errors in the development environment.'        );        if (null !== $pcreVersion) {            $this->addRecommendation(                $pcreVersion >= 8.0,                sprintf('PCRE extension should be at least version 8.0 (%s installed)', $pcreVersion),                '<strong>PCRE 8.0+</strong> is preconfigured in PHP since 5.3.2 but you are using an outdated version of it. Symfony probably works anyway but it is recommended to upgrade your PCRE extension.'            );        }        $this->addRecommendation(            class_exists('DomDocument'),            'PHP-DOM and PHP-XML modules should be installed',            'Install and enable the <strong>PHP-DOM</strong> and the <strong>PHP-XML</strong> modules.'        );        $this->addRecommendation(            function_exists('mb_strlen'),            'mb_strlen() should be available',            'Install and enable the <strong>mbstring</strong> extension.'        );        $this->addRecommendation(            function_exists('utf8_decode'),            'utf8_decode() should be available',            'Install and enable the <strong>XML</strong> extension.'        );        $this->addRecommendation(            function_exists('filter_var'),            'filter_var() should be available',            'Install and enable the <strong>filter</strong> extension.'        );        if (!defined('PHP_WINDOWS_VERSION_BUILD')) {            $this->addRecommendation(                function_exists('posix_isatty'),                'posix_isatty() should be available',                'Install and enable the <strong>php_posix</strong> extension (used to colorize the CLI output).'            );        }        $this->addRecommendation(            extension_loaded('intl'),            'intl extension should be available',            'Install and enable the <strong>intl</strong> extension (used for validators).'        );        if (extension_loaded('intl')) {            // in some WAMP server installations, new Collator() returns null            $this->addRecommendation(                null !== new Collator('fr_FR'),                'intl extension should be correctly configured',                'The intl extension does not behave properly. This problem is typical on PHP 5.3.X x64 WIN builds.'            );            // check for compatible ICU versions (only done when you have the intl extension)            if (defined('INTL_ICU_VERSION')) {                $version = INTL_ICU_VERSION;            } else {                $reflector = new ReflectionExtension('intl');                ob_start();                $reflector->info();                $output = strip_tags(ob_get_clean());                preg_match('/^ICU version +(?:=> )?(.*)$/m', $output, $matches);                $version = $matches[1];            }            $this->addRecommendation(                version_compare($version, '4.0', '>='),                'intl ICU version should be at least 4+',                'Upgrade your <strong>intl</strong> extension with a newer ICU version (4+).'            );            if (class_exists('Symfony\Component\Intl\Intl')) {                $this->addRecommendation(                    \Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion(),                    sprintf('intl ICU version installed on your system is outdated (%s) and does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                    'To get the latest internationalization data upgrade the ICU system package and the intl PHP extension.'                );                if (\Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion()) {                    $this->addRecommendation(                        \Symfony\Component\Intl\Intl::getIcuDataVersion() === \Symfony\Component\Intl\Intl::getIcuVersion(),                        sprintf('intl ICU version installed on your system (%s) does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                        'To avoid internationalization data inconsistencies upgrade the symfony/intl component.'                    );                }            }            $this->addPhpIniRecommendation(                'intl.error_level',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'intl.error_level should be 0 in php.ini',                'Set ""<strong>intl.error_level</strong>"" to ""<strong>0</strong>"" in php.ini<a href=""#phpini"">*</a> to inhibit the messages when an error occurs in ICU functions.'            );        }        $accelerator =            (extension_loaded('eaccelerator') && ini_get('eaccelerator.enable'))            ||            (extension_loaded('apc') && ini_get('apc.enabled'))            ||            (extension_loaded('Zend Optimizer+') && ini_get('zend_optimizerplus.enable'))            ||            (extension_loaded('Zend OPcache') && ini_get('opcache.enable'))            ||            (extension_loaded('xcache') && ini_get('xcache.cacher'))            ||            (extension_loaded('wincache') && ini_get('wincache.ocenabled'))        ;        $this->addRecommendation(            $accelerator,            'a PHP accelerator should be installed',            'Install and/or enable a <strong>PHP accelerator</strong> (highly recommended).'        );        if ('WIN' === strtoupper(substr(PHP_OS, 0, 3))) {            $this->addRecommendation(                $this->getRealpathCacheSize() >= 5 * 1024 * 1024,                'realpath_cache_size should be at least 5M in php.ini',                'Setting ""<strong>realpath_cache_size</strong>"" to e.g. ""<strong>5242880</strong>"" or ""<strong>5M</strong>"" in php.ini<a href=""#phpini"">*</a> may improve performance on Windows significantly in some cases.'            );        }        $this->addPhpIniRecommendation('short_open_tag', false);        $this->addPhpIniRecommendation('magic_quotes_gpc', false, true);        $this->addPhpIniRecommendation('register_globals', false, true);        $this->addPhpIniRecommendation('session.auto_start', false);        $this->addRecommendation(            class_exists('PDO'),            'PDO should be installed',            'Install <strong>PDO</strong> (mandatory for Doctrine).'        );        if (class_exists('PDO')) {            $drivers = PDO::getAvailableDrivers();            $this->addRecommendation(                count($drivers) > 0,                sprintf('PDO should have some drivers installed (currently available: %s)', count($drivers) ? implode(', ', $drivers) : 'none'),                'Install <strong>PDO drivers</strong> (mandatory for Doctrine).'            );        }    }    /**     * Loads realpath_cache_size from php.ini and converts it to int.     *     * (e.g. 16k is converted to 16384 int)     *     * @return int     */    protected function getRealpathCacheSize()    {        $size = ini_get('realpath_cache_size');        $size = trim($size);        $unit = '';        if (!ctype_digit($size)) {            $unit = strtolower(substr($size, -1, 1));            $size = (int) substr($size, 0, -1);        }        switch ($unit) {            case 'g':                return $size * 1024 * 1024 * 1024;            case 'm':                return $size * 1024 * 1024;            case 'k':                return $size * 1024;            default:                return (int) $size;        }    }    /**     * Defines PHP required version from Symfony version.     *     * @return string|false The PHP required version or false if it could not be guessed     */    protected function getPhpRequiredVersion()    {        if (!file_exists($path = __DIR__.'/../composer.lock')) {            return false;        }        $composerLock = json_decode(file_get_contents($path), true);        foreach ($composerLock['packages'] as $package) {            $name = $package['name'];            if ('symfony/symfony' !== $name && 'symfony/http-kernel' !== $name) {                continue;            }            return (int) $package['version'][1] > 2 ? self::REQUIRED_PHP_VERSION : self::LEGACY_REQUIRED_PHP_VERSION;        }        return false;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
161,wallabag_wallabag_SymfonyRequirements_2446, Returns both requirements and recommendations.\n\n @return Requirement[]\n,Vraća i zahteve i preporuke,"class SymfonyRequirements extends RequirementCollection{    const LEGACY_REQUIRED_PHP_VERSION = '5.3.3';    const REQUIRED_PHP_VERSION = '5.5.9';    /**     * Constructor that initializes the requirements.     */    public function __construct()    {        /* mandatory requirements follow */        $installedPhpVersion = PHP_VERSION;        $requiredPhpVersion = $this->getPhpRequiredVersion();        $this->addRecommendation(            $requiredPhpVersion,            'Vendors should be installed in order to check all requirements.',            'Run the <code>composer install</code> command.',            'Run the ""composer install"" command.'        );        if (false !== $requiredPhpVersion) {            $this->addRequirement(                version_compare($installedPhpVersion, $requiredPhpVersion, '>='),                sprintf('PHP version must be at least %s (%s installed)', $requiredPhpVersion, $installedPhpVersion),                sprintf('You are running PHP version ""<strong>%s</strong>"", but Symfony needs at least PHP ""<strong>%s</strong>"" to run.                Before using Symfony, upgrade your PHP installation, preferably to the latest version.',                    $installedPhpVersion, $requiredPhpVersion),                sprintf('Install PHP %s or newer (installed version is %s)', $requiredPhpVersion, $installedPhpVersion)            );        }        $this->addRequirement(            version_compare($installedPhpVersion, '5.3.16', '!='),            'PHP version must not be 5.3.16 as Symfony won\'t work properly with it',            'Install PHP 5.3.17 or newer (or downgrade to an earlier PHP version)'        );        $this->addRequirement(            is_dir(__DIR__.'/../vendor/composer'),            'Vendor libraries must be installed',            'Vendor libraries are missing. Install composer following instructions from <a href=""http://getcomposer.org/"">http://getcomposer.org/</a>. '.                'Then run ""<strong>php composer.phar install</strong>"" to install them.'        );        $cacheDir = is_dir(__DIR__.'/../var/cache') ? __DIR__.'/../var/cache' : __DIR__.'/cache';        $this->addRequirement(            is_writable($cacheDir),            'app/cache/ or var/cache/ directory must be writable',            'Change the permissions of either ""<strong>app/cache/</strong>"" or  ""<strong>var/cache/</strong>"" directory so that the web server can write into it.'        );        $logsDir = is_dir(__DIR__.'/../var/logs') ? __DIR__.'/../var/logs' : __DIR__.'/logs';        $this->addRequirement(            is_writable($logsDir),            'app/logs/ or var/logs/ directory must be writable',            'Change the permissions of either ""<strong>app/logs/</strong>"" or  ""<strong>var/logs/</strong>"" directory so that the web server can write into it.'        );        if (version_compare($installedPhpVersion, '7.0.0', '<')) {            $this->addPhpIniRequirement(                'date.timezone', true, false,                'date.timezone setting must be set',                'Set the ""<strong>date.timezone</strong>"" setting in php.ini<a href=""#phpini"">*</a> (like Europe/Paris).'            );        }        if (false !== $requiredPhpVersion && version_compare($installedPhpVersion, $requiredPhpVersion, '>=')) {            $this->addRequirement(                in_array(@date_default_timezone_get(), DateTimeZone::listIdentifiers(), true),                sprintf('Configured default timezone ""%s"" must be supported by your installation of PHP', @date_default_timezone_get()),                'Your default timezone is not supported by PHP. Check for typos in your <strong>php.ini</strong> file and have a look at the list of deprecated timezones at <a href=""http://php.net/manual/en/timezones.others.php"">http://php.net/manual/en/timezones.others.php</a>.'            );        }        $this->addRequirement(            function_exists('iconv'),            'iconv() must be available',            'Install and enable the <strong>iconv</strong> extension.'        );        $this->addRequirement(            function_exists('json_encode'),            'json_encode() must be available',            'Install and enable the <strong>JSON</strong> extension.'        );        $this->addRequirement(            function_exists('session_start'),            'session_start() must be available',            'Install and enable the <strong>session</strong> extension.'        );        $this->addRequirement(            function_exists('ctype_alpha'),            'ctype_alpha() must be available',            'Install and enable the <strong>ctype</strong> extension.'        );        $this->addRequirement(            function_exists('token_get_all'),            'token_get_all() must be available',            'Install and enable the <strong>Tokenizer</strong> extension.'        );        $this->addRequirement(            function_exists('simplexml_import_dom'),            'simplexml_import_dom() must be available',            'Install and enable the <strong>SimpleXML</strong> extension.'        );        if (function_exists('apc_store') && ini_get('apc.enabled')) {            if (version_compare($installedPhpVersion, '5.4.0', '>=')) {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.1.13', '>='),                    'APC version must be at least 3.1.13 when using PHP 5.4',                    'Upgrade your <strong>APC</strong> extension (3.1.13+).'                );            } else {                $this->addRequirement(                    version_compare(phpversion('apc'), '3.0.17', '>='),                    'APC version must be at least 3.0.17',                    'Upgrade your <strong>APC</strong> extension (3.0.17+).'                );            }        }        $this->addPhpIniRequirement('detect_unicode', false);        if (extension_loaded('suhosin')) {            $this->addPhpIniRequirement(                'suhosin.executor.include.whitelist',                create_function('$cfgValue', 'return false !== stripos($cfgValue, ""phar"");'),                false,                'suhosin.executor.include.whitelist must be configured correctly in php.ini',                'Add ""<strong>phar</strong>"" to <strong>suhosin.executor.include.whitelist</strong> in php.ini<a href=""#phpini"">*</a>.'            );        }        if (extension_loaded('xdebug')) {            $this->addPhpIniRequirement(                'xdebug.show_exception_trace', false, true            );            $this->addPhpIniRequirement(                'xdebug.scream', false, true            );            $this->addPhpIniRecommendation(                'xdebug.max_nesting_level',                create_function('$cfgValue', 'return $cfgValue > 100;'),                true,                'xdebug.max_nesting_level should be above 100 in php.ini',                'Set ""<strong>xdebug.max_nesting_level</strong>"" to e.g. ""<strong>250</strong>"" in php.ini<a href=""#phpini"">*</a> to stop Xdebug\'s infinite recursion protection erroneously throwing a fatal error in your project.'            );        }        $pcreVersion = defined('PCRE_VERSION') ? (float) PCRE_VERSION : null;        $this->addRequirement(            null !== $pcreVersion,            'PCRE extension must be available',            'Install the <strong>PCRE</strong> extension (version 8.0+).'        );        if (extension_loaded('mbstring')) {            $this->addPhpIniRequirement(                'mbstring.func_overload',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'string functions should not be overloaded',                'Set ""<strong>mbstring.func_overload</strong>"" to <strong>0</strong> in php.ini<a href=""#phpini"">*</a> to disable function overloading by the mbstring extension.'            );        }        /* optional recommendations follow */        if (file_exists(__DIR__.'/../vendor/composer')) {            require_once __DIR__.'/../vendor/autoload.php';            try {                $r = new ReflectionClass('Sensio\Bundle\DistributionBundle\SensioDistributionBundle');                $contents = file_get_contents(dirname($r->getFileName()).'/Resources/skeleton/app/SymfonyRequirements.php');            } catch (ReflectionException $e) {                $contents = '';            }            $this->addRecommendation(                file_get_contents(__FILE__) === $contents,                'Requirements file should be up-to-date',                'Your requirements file is outdated. Run composer install and re-check your configuration.'            );        }        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.4', '>='),            'You should use at least PHP 5.3.4 due to PHP bug #52083 in earlier versions',            'Your project might malfunction randomly due to PHP bug #52083 (""Notice: Trying to get property of non-object""). Install PHP 5.3.4 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.3.8', '>='),            'When using annotations you should have at least PHP 5.3.8 due to PHP bug #55156',            'Install PHP 5.3.8 or newer if your project uses annotations.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.0', '!='),            'You should not use PHP 5.4.0 due to the PHP bug #61453',            'Your project might not work properly due to the PHP bug #61453 (""Cannot dump definitions which have method calls""). Install PHP 5.4.1 or newer.'        );        $this->addRecommendation(            version_compare($installedPhpVersion, '5.4.11', '>='),            'When using the logout handler from the Symfony Security Component, you should have at least PHP 5.4.11 due to PHP bug #63379 (as a workaround, you can also set invalidate_session to false in the security logout handler configuration)',            'Install PHP 5.4.11 or newer if your project uses the logout handler from the Symfony Security Component.'        );        $this->addRecommendation(            (version_compare($installedPhpVersion, '5.3.18', '>=') && version_compare($installedPhpVersion, '5.4.0', '<'))            ||            version_compare($installedPhpVersion, '5.4.8', '>='),            'You should use PHP 5.3.18+ or PHP 5.4.8+ to always get nice error messages for fatal errors in the development environment due to PHP bug #61767/#60909',            'Install PHP 5.3.18+ or PHP 5.4.8+ if you want nice error messages for all fatal errors in the development environment.'        );        if (null !== $pcreVersion) {            $this->addRecommendation(                $pcreVersion >= 8.0,                sprintf('PCRE extension should be at least version 8.0 (%s installed)', $pcreVersion),                '<strong>PCRE 8.0+</strong> is preconfigured in PHP since 5.3.2 but you are using an outdated version of it. Symfony probably works anyway but it is recommended to upgrade your PCRE extension.'            );        }        $this->addRecommendation(            class_exists('DomDocument'),            'PHP-DOM and PHP-XML modules should be installed',            'Install and enable the <strong>PHP-DOM</strong> and the <strong>PHP-XML</strong> modules.'        );        $this->addRecommendation(            function_exists('mb_strlen'),            'mb_strlen() should be available',            'Install and enable the <strong>mbstring</strong> extension.'        );        $this->addRecommendation(            function_exists('utf8_decode'),            'utf8_decode() should be available',            'Install and enable the <strong>XML</strong> extension.'        );        $this->addRecommendation(            function_exists('filter_var'),            'filter_var() should be available',            'Install and enable the <strong>filter</strong> extension.'        );        if (!defined('PHP_WINDOWS_VERSION_BUILD')) {            $this->addRecommendation(                function_exists('posix_isatty'),                'posix_isatty() should be available',                'Install and enable the <strong>php_posix</strong> extension (used to colorize the CLI output).'            );        }        $this->addRecommendation(            extension_loaded('intl'),            'intl extension should be available',            'Install and enable the <strong>intl</strong> extension (used for validators).'        );        if (extension_loaded('intl')) {            // in some WAMP server installations, new Collator() returns null            $this->addRecommendation(                null !== new Collator('fr_FR'),                'intl extension should be correctly configured',                'The intl extension does not behave properly. This problem is typical on PHP 5.3.X x64 WIN builds.'            );            // check for compatible ICU versions (only done when you have the intl extension)            if (defined('INTL_ICU_VERSION')) {                $version = INTL_ICU_VERSION;            } else {                $reflector = new ReflectionExtension('intl');                ob_start();                $reflector->info();                $output = strip_tags(ob_get_clean());                preg_match('/^ICU version +(?:=> )?(.*)$/m', $output, $matches);                $version = $matches[1];            }            $this->addRecommendation(                version_compare($version, '4.0', '>='),                'intl ICU version should be at least 4+',                'Upgrade your <strong>intl</strong> extension with a newer ICU version (4+).'            );            if (class_exists('Symfony\Component\Intl\Intl')) {                $this->addRecommendation(                    \Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion(),                    sprintf('intl ICU version installed on your system is outdated (%s) and does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                    'To get the latest internationalization data upgrade the ICU system package and the intl PHP extension.'                );                if (\Symfony\Component\Intl\Intl::getIcuDataVersion() <= \Symfony\Component\Intl\Intl::getIcuVersion()) {                    $this->addRecommendation(                        \Symfony\Component\Intl\Intl::getIcuDataVersion() === \Symfony\Component\Intl\Intl::getIcuVersion(),                        sprintf('intl ICU version installed on your system (%s) does not match the ICU data bundled with Symfony (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),                        'To avoid internationalization data inconsistencies upgrade the symfony/intl component.'                    );                }            }            $this->addPhpIniRecommendation(                'intl.error_level',                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),                true,                'intl.error_level should be 0 in php.ini',                'Set ""<strong>intl.error_level</strong>"" to ""<strong>0</strong>"" in php.ini<a href=""#phpini"">*</a> to inhibit the messages when an error occurs in ICU functions.'            );        }        $accelerator =            (extension_loaded('eaccelerator') && ini_get('eaccelerator.enable'))            ||            (extension_loaded('apc') && ini_get('apc.enabled'))            ||            (extension_loaded('Zend Optimizer+') && ini_get('zend_optimizerplus.enable'))            ||            (extension_loaded('Zend OPcache') && ini_get('opcache.enable'))            ||            (extension_loaded('xcache') && ini_get('xcache.cacher'))            ||            (extension_loaded('wincache') && ini_get('wincache.ocenabled'))        ;        $this->addRecommendation(            $accelerator,            'a PHP accelerator should be installed',            'Install and/or enable a <strong>PHP accelerator</strong> (highly recommended).'        );        if ('WIN' === strtoupper(substr(PHP_OS, 0, 3))) {            $this->addRecommendation(                $this->getRealpathCacheSize() >= 5 * 1024 * 1024,                'realpath_cache_size should be at least 5M in php.ini',                'Setting ""<strong>realpath_cache_size</strong>"" to e.g. ""<strong>5242880</strong>"" or ""<strong>5M</strong>"" in php.ini<a href=""#phpini"">*</a> may improve performance on Windows significantly in some cases.'            );        }        $this->addPhpIniRecommendation('short_open_tag', false);        $this->addPhpIniRecommendation('magic_quotes_gpc', false, true);        $this->addPhpIniRecommendation('register_globals', false, true);        $this->addPhpIniRecommendation('session.auto_start', false);        $this->addRecommendation(            class_exists('PDO'),            'PDO should be installed',            'Install <strong>PDO</strong> (mandatory for Doctrine).'        );        if (class_exists('PDO')) {            $drivers = PDO::getAvailableDrivers();            $this->addRecommendation(                count($drivers) > 0,                sprintf('PDO should have some drivers installed (currently available: %s)', count($drivers) ? implode(', ', $drivers) : 'none'),                'Install <strong>PDO drivers</strong> (mandatory for Doctrine).'            );        }    }    /**     * Loads realpath_cache_size from php.ini and converts it to int.     *     * (e.g. 16k is converted to 16384 int)     *     * @return int     */    protected function getRealpathCacheSize()    {        $size = ini_get('realpath_cache_size');        $size = trim($size);        $unit = '';        if (!ctype_digit($size)) {            $unit = strtolower(substr($size, -1, 1));            $size = (int) substr($size, 0, -1);        }        switch ($unit) {            case 'g':                return $size * 1024 * 1024 * 1024;            case 'm':                return $size * 1024 * 1024;            case 'k':                return $size * 1024;            default:                return (int) $size;        }    }    /**     * Defines PHP required version from Symfony version.     *     * @return string|false The PHP required version or false if it could not be guessed     */    protected function getPhpRequiredVersion()    {        if (!file_exists($path = __DIR__.'/../composer.lock')) {            return false;        }        $composerLock = json_decode(file_get_contents($path), true);        foreach ($composerLock['packages'] as $package) {            $name = $package['name'];            if ('symfony/symfony' !== $name && 'symfony/http-kernel' !== $name) {                continue;            }            return (int) $package['version'][1] > 2 ? self::REQUIRED_PHP_VERSION : self::LEGACY_REQUIRED_PHP_VERSION;        }        return false;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
162,sebastianbergmann_comparator_DateTimeComparator_2334, Compares DateTimeInterface instances for equality.\n,Upoređuje instance DateTimeInterface radi jednakosti,"class DateTimeComparator extends ObjectComparator{    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return ($expected instanceof DateTime || $expected instanceof DateTimeInterface) &&               ($actual instanceof DateTime || $actual instanceof DateTimeInterface);    }    /**     * Asserts that two values are equal.     *     * @param mixed $expected     First value to compare     * @param mixed $actual       Second value to compare     * @param float $delta        Allowed numerical distance between two values to consider them equal     * @param bool  $canonicalize Arrays are sorted before comparison when set to true     * @param bool  $ignoreCase   Case is ignored when set to true     * @param array $processed    List of already processed elements (used to prevent infinite recursion)     *     * @throws ComparisonFailure     * @throws Exception     */    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false, array &$processed = [])/*: void*/    {        /** @var DateTimeInterface $expected */        /** @var DateTimeInterface $actual */        $absDelta = abs($delta);        $delta    = new DateInterval(sprintf('PT%dS', $absDelta));        $delta->f = $absDelta - floor($absDelta);        $actualClone = (clone $actual)            ->setTimezone(new DateTimeZone('UTC'));        $expectedLower = (clone $expected)            ->setTimezone(new DateTimeZone('UTC'))            ->sub($delta);        $expectedUpper = (clone $expected)            ->setTimezone(new DateTimeZone('UTC'))            ->add($delta);        if ($actualClone < $expectedLower || $actualClone > $expectedUpper) {            throw new ComparisonFailure(                $expected,                $actual,                $this->dateTimeToString($expected),                $this->dateTimeToString($actual),                false,                'Failed asserting that two DateTime objects are equal.'            );        }    }    /**     * Returns an ISO 8601 formatted string representation of a datetime or     * 'Invalid DateTimeInterface object' if the provided DateTimeInterface was not properly     * initialized.     */    private function dateTimeToString(DateTimeInterface $datetime): string    {        $string = $datetime->format('Y-m-d\TH:i:s.uO');        return $string ?: 'Invalid DateTimeInterface object';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
164,phpspec_prophecy_ArgumentsWildcard_2935, Initializes wildcard.\n\n @param array $arguments Array of argument tokens or values\n,Inicijalizacija wildcard-a,    public function __construct(array $arguments)    {        foreach ($arguments as $argument) {            if (!$argument instanceof Token\TokenInterface) {                $argument = new Token\ExactValueToken($argument);            }            $this->tokens[] = $argument;        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
165,woocommerce_woocommerce_RestockRefundedItemsAdjuster_1935, Class to adjust or initialize the restock refunded items.\n,Klasa za prilagođavanje ili inicijalizaciju vraćenih stavki,public static function initialize( $mockable_classes ) {if ( ! is_array( $mockable_classes ) || empty( $mockable_classes ) ) {throw new \Exception( 'StaticMockerHack::initialize:: $mockable_classes must be a non-empty associative array of class name => array of class methods.' );},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
166,markrogoyski_math-php_ArbitraryInteger_2546, Create a random ArbitraryInteger\\n\\n @param int $bytes\\n\\n @return Number\\\\ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n,Napravite slučajni ArbitrarInteger broj,"    public static function rand(int $bytes): Number\ArbitraryInteger    {        if ($bytes <= 0) {            throw new Exception\BadParameterException('Cannot produce a random number with zero or negative bytes.');        }        return Number\ArbitraryInteger::fromBinary(\random_bytes($bytes), \mt_rand(0, 1) === 0);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
167,markrogoyski_math-php_KernelDensityEstimation_3533, Default bandwidth for when one is not provided.\\n Uses the normal distribution approximation bandwidth estimator.\\n https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\\n\\n             â…•\\n      / 4Ïƒâµ \\\\\\n h = |  ---  |\\n      \\\\ 3n  /\\n\\n\\n @return float\\n\\n @throws Exception\\\\OutOfBoundsException\\n,Podrazumevana širina opsega kada nije obezbeđena. Koristi procenjivač širine opsega aproksimacije normalne distribucije,    private function getDefaultBandwidth(): float    {        $ï¼”Ïƒâµ = 4 * Descriptive::standardDeviation($this->data) ** 5;        $ï¼“n  = 3 * $this->n;        $â…•    = 0.2;        return ($ï¼”Ïƒâµ / $ï¼“n) ** $â…•;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
168,markrogoyski_math-php_LogNormal_3141, Log normal distribution - probability density function\\n\\n https://en.wikipedia.org/wiki/Log-normal_distribution\\n\\n                 (ln x - Î¼)Â²\\n         1     - ----------\\n pdf = ----- â„¯       2ÏƒÂ²\\n       xÏƒâˆš2Ï€\\n\\n @param  float $x > 0\\n\\n @return float\\n,Logaritamska Normalna raspodela  - funkcija gustine verovatnoće,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        $Ï€ = \M_PI;        $xÏƒâˆš2Ï€      = $x * $Ïƒ * \sqrt(2 * $Ï€);        $âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² = \pow(\log($x) - $Î¼, 2);        $ÏƒÂ²         = $Ïƒ ** 2;        return (1 / $xÏƒâˆš2Ï€) * \exp(-($âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² / (2 * $ÏƒÂ²)));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
169,markrogoyski_math-php_Normal_3284, Normal distribution\n https://en.wikipedia.org/wiki/Multivariate_normal_distribution\n,Normalna raspodela,"class Normal{    /** @var array location */    protected $Î¼;    /** @var NumericMatrix covariance matrix */    protected $âˆ‘;    /**     * Constructor     *     * @param array         $Î¼ âˆˆ Ráµ   location     * @param NumericMatrix $âˆ‘ âˆˆ RáµË£áµ covariance matrix     *     * @throws Exception\BadDataException if the covariance matrix does not have the same number of rows and columns as number of elements in Î¼     * @throws Exception\BadDataException if the covariance matrix is not positive definite     */    public function __construct(array $Î¼, NumericMatrix $âˆ‘)    {        $k = \count($Î¼);        if ($âˆ‘->getM() !== $k || $âˆ‘->getN() !== $k) {            throw new Exception\BadDataException(                'Covariance matrix âˆ‘ must have the the same number of rows and columns as there are X elements. ' .                ""X has $k elements. Covariance matrix âˆ‘ has "" . $âˆ‘->getM() . ' rows and ' . $âˆ‘->getN() . ' columns.'            );        }        if (!$âˆ‘->isPositiveDefinite()) {            throw new Exception\BadDataException(""Covariance matrix âˆ‘ is not positive definite:\n$âˆ‘"");        }        $this->Î¼ = $Î¼;        $this->âˆ‘ = $âˆ‘;    }    /**     * Probability density function     *     *                 exp(âˆ’Â½(x âˆ’Â Î¼)áµ€âˆ‘â»Â¹(xÂ âˆ’Â Î¼))     * fx(xâ‚,...,xk) = -------------------------     *                        âˆš(2Ï€)áµâ”‚âˆ‘â”‚     *     * x is a real k-dimensional column vector     * Î¼ is a real k-dimensinoal column vector of means     * â”‚âˆ‘â”‚ â‰¡ det(âˆ‘)     *     * @param array  $X âˆˆ Ráµ   k-dimensional random vector     *     * @return float density     *     * @throws Exception\BadDataException if X and Î¼ do not have the same number of elements     */    public function pdf(array $X): float    {        $k = \count($X);        $Î¼ = $this->Î¼;        $âˆ‘ = $this->âˆ‘;        if (\count($Î¼) !== $k) {            throw new Exception\BadDataException(""X and Î¼ must have the same number of elements. X has $k and Î¼ has "" . \count($Î¼));        }        $Ï€ = \M_PI;        $â”‚âˆ‘â”‚      = $âˆ‘->det();        $âˆšâŸ®2Ï€âŸ¯áµâ”‚âˆ‘â”‚ = \sqrt((2 * $Ï€) ** $k * $â”‚âˆ‘â”‚);        $Î”       = Map\Multi::subtract($X, $Î¼);        $âŸ®xÂ âˆ’Â Î¼âŸ¯  = new Vector($Î”);        $âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€ = MatrixFactory::createFromRowVector($Î”);        $âˆ‘â»Â¹     = $âˆ‘->inverse();        $expâŸ®âˆ’Â½âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€âˆ‘â»Â¹âŸ®xÂ âˆ’Â Î¼âŸ¯âŸ¯ = \exp(            $âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€->scalarDivide(-2)                ->multiply($âˆ‘â»Â¹)                ->multiply($âŸ®xÂ âˆ’Â Î¼âŸ¯)                ->get(0, 0)        );        return $expâŸ®âˆ’Â½âŸ®xÂ âˆ’Â Î¼âŸ¯áµ€âˆ‘â»Â¹âŸ®xÂ âˆ’Â Î¼âŸ¯âŸ¯ / $âˆšâŸ®2Ï€âŸ¯áµâ”‚âˆ‘â”‚;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
170,markrogoyski_math-php_Normal_3167, Cumulative distribution function\n Probability of being below X.\n Area under the normal distribution from -âˆž to X.\n             _                  _\n          1 |         / x - Î¼ \\  |\n cdf(x) = - | 1 + erf|  ----- |  |\n          2 |_        \\  Ïƒâˆš2  / _|\n\n @param float $x upper bound\n\n @return float cdf(x) below\n,Funkcija kumulativne raspodele. Verovatnoća da bude ispod X. Površina ispod normalne raspodele od -a do X,"    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        return 1 / 2 * ( 1 + Special::erf(($x - $Î¼) / ($Ïƒ * \sqrt(2))) );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
171,composer_composer_Installer_2547, Whether or not generated autoloader are optimized\n\n @param  bool      $optimizeAutoloader\n @return Installer\n,Bez obzira da li je ili ne generisan automatski  se autoloader optimizuje,    public function setOptimizeAutoloader($optimizeAutoloader)    {        $this->optimizeAutoloader = (bool) $optimizeAutoloader;        if (!$this->optimizeAutoloader) {            // Force classMapAuthoritative off when not optimizing the            // autoloader            $this->setClassMapAuthoritative(false);        }        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
172,phalcon_cphalcon_Optimized_1228, Uses previously generated safe universal build and generates optimized build for a specific platform\\n,Koristi prethodno generisanu sigurnu univerzalni build i generiše optimizovani build za određenu platformu,"class Generator_Optimized{    /**     * Directory, where safe universal build files are generated     *     * @var string     */    protected string $sourceBuildDir;    /**     * Platform settings for supported optimized builds     *     * @var array     */    protected array $settings;    /**     * Filters for processing (optimizing) lines from safe universal phalcon.c     *     * @var array     */    protected array $filters;    /**     * @param string $sourceBuildDir     * @param string $output32Dir     * @param string $output64Dir     */    public function __construct(string $sourceBuildDir, string $output32Dir, string $output64Dir)    {        $this->sourceBuildDir = $sourceBuildDir;        $this->settings = $this->getPlatformsSettings($output32Dir, $output64Dir);        $this->filters = $this->getFilters();    }    /**     * Return array of supported platform settings for optimized builds     *     * @param string $output32Dir     * @param string $output64Dir     * @return array     */    protected function getPlatformsSettings(string $output32Dir, string $output64Dir)    {        return array(            '32bit' => array(                'dir' => $output32Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey32($string) . 'UL';                }            ),            '64bit' => array(                'dir' => $output64Dir,                'hashFunc' => function ($string) {                    return Kernel::preComputeHashKey64($string) . 'UL';                }            ),        );    }    /**     * Return filters for processing lines from safe universal phalcon.c     *     * @return array     */    protected function getFilters()    {        $result = [];        /*        // Explicit calls to zend_inline_hash_func()        $result[] = array(            'regexp' => '/(zend_inline_hash_func\(SS\(""([^""]++)""\)\))/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[1], $hash, $line);            }        );        // Pre-compute the hash key for isset using strings        $result[] = array(            'regexp' => '/zephir_array_isset_string\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_isset_quick_string('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute the hash key for reading elements using hashes        $result[] = array(            'regexp' => '/zephir_array_fetch_string\(\&([a-zA-Z0-9\_]+), ([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[3]);                return str_replace($matches[0], 'zephir_array_fetch_quick_string(&'.$matches[1].', '.$matches[2].', SS(""'.$matches[3].'""), '.$hash.', '.$matches[4].')', $line);            }        );        // Pre-compute hash for updating elements        $result[] = array(            'regexp' => '/zephir_array_update_string\(\&([a-zA-Z0-9\_]+), SL\(""([a-zA-Z\_\-]+)""\), \&([a-zA-Z0-9\_]+), (.+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_array_update_quick_string(&'.$matches[1].', SS(""'.$matches[2].'""), '.$hash.', &'.$matches[3].', '.$matches[4].')', $line);            }        );        // Pre-compute hash key for method checking        $result[] = array(            'regexp' => '/zephir_method_exists_ex\(([a-zA-Z0-9\_]+), SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_method_quick_exists_ex('.$matches[1].', SS(""'.$matches[2].'""), '.$hash.')', $line);            }        );        // Pre-compute hash key for function checking        $result[] = array(            'regexp' => '/zephir_function_exists_ex\(SS\(""([a-zA-Z\_\-]+)""\)\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_function_quick_exists_ex(SS(""'.$matches[1].'""), '.$hash.')', $line);            }        );        $result[] = array(            'regexp' => '/zephir_read_property_this\(&([a-zA-Z0-9\_]+), this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), PH_NOISY_CC\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'zephir_read_property_this_quick(&'.$matches[1].', this_ptr, SL(""'.$matches[2].'""), '.$hash.', PH_NOISY_CC)', $line);            }        );        $result[] = array(            'regexp' => '/zephir_update_property_this\(this_ptr, SL\(""([a-zA-Z0-9\_]+)""\), ([a-zA-Z0-9\_]+)\)/',            'func' => function ($line, $matches, $hashFunc) {                $key = $hashFunc($matches[1]);                return str_replace($matches[0], 'zephir_update_property_this_quick(this_ptr, SL(""'.$matches[1].'""), '.$matches[2].', '.$key.')', $line);            }        );        $result[] = array(            'regexp' => '/RETURN_MEMBER\(([a-zA-Z0-9\_]+), ""([a-zA-Z0-9\_]+)""\)/',            'func' => function ($line, $matches, $hashFunc) {                $hash = $hashFunc($matches[2]);                return str_replace($matches[0], 'RETURN_MEMBER_QUICK('.$matches[1].', ""'.$matches[2].'"", '.$hash.')', $line);            }        );*/        return $result;    }    /**     * Run generation process     */    public function run()    {        echo 'Generating builds, optimized for 32-bit and 64-bit platforms... ';        $this->cleanBuildDirectories();        $this->copyFilesFromSourceBuildDir();        $this->copyAndOptimizePhalconC();        echo ""OK\n"";    }    /**     * Delete all files in target directories     */    public function cleanBuildDirectories()    {        foreach ($this->settings as $setting) {            Util::cleanDirectory($setting['dir']);        }    }    /**     * Copy all files from the original safe universal build directory     */    protected function copyFilesFromSourceBuildDir()    {        $files = glob($this->sourceBuildDir . '/*.*');        foreach ($files as $file) {            // phalcon.c is processed in a separate optimization func            if (basename($file) == 'phalcon.zep.c') {                continue;            }            foreach ($this->settings as $setting) {                copy($file, $setting['dir'] . '/' . basename($file));            }        }    }    /**     * Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.     * Precalculation is, actually, the optimization being performed.     */    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }    /**     * Pass line through filters and add the processed result to platform builds     *     * @param string $line     * @param array $result     */    protected function filterLine($line, &$result)    {        /** @var callable|null $func */        $func = null;        foreach ($this->filters as $filter) {            if (!preg_match($filter['regexp'], $line, $matches)) {                continue;            }            $func = $filter['func'];            break; // We don't expect more than one replacement to be made on the same line        }        foreach ($this->settings as $platform => $setting) {            $result[$platform] .= $func ? $func($line, $matches, $setting['hashFunc']) : $line;        }    }}",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
173,PrestaShop_PrestaShop_AttributeGroup_834, Get all attributes groups for a given language.\\n\\n @param int $idLang Language id\\n\\n @return array Attributes groups\\n,Dohvata sve grupe atributa za dati jezik,"    public static function getAttributesGroups($idLang)    {        if (!Combination::isFeatureActive()) {            return [];        }        return Db::getInstance()->executeS('SELECT DISTINCT agl.`name`, ag.*, agl.*FROM `' . _DB_PREFIX_ . 'attribute_group` ag' . Shop::addSqlAssociation('attribute_group', 'ag') . 'LEFT JOIN `' . _DB_PREFIX_ . 'attribute_group_lang` aglON (ag.`id_attribute_group` = agl.`id_attribute_group` AND `id_lang` = ' . (int) $idLang . ')ORDER BY `name` ASC');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
174,predis_predis_ClusterStrategy_2164, Extracts the key from a command with multiple keys only when all keys in\n the arguments array produce the same hash.\n\n @param CommandInterface $command Command instance.\n\n @return string|null\n,Izdvaja ključ iz naredbe sa više ključeva samo kada svi ključevi u polju argumenata proizvode isto heširanje,    protected function getKeyFromInterleavedArguments(CommandInterface $command)    {        $arguments = $command->getArguments();        $keys = array();        for ($i = 0; $i < count($arguments); $i += 2) {            $keys[] = $arguments[$i];        }        if ($this->checkSameSlotForKeys($keys)) {            return $arguments[0];        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
176,walkor_Workerman_Worker_8679, Check errors when current process exited.\n\n @return void\n,Proverite greške kada je trenutni proces završio,"    public static function log($msg)    {        $msg = $msg . ""\n"";        if (!static::$daemonize) {            static::safeEcho($msg);        }        \file_put_contents((string)static::$logFile, \date('Y-m-d H:i:s') . ' ' . 'pid:'            . (static::$_OS === \OS_TYPE_LINUX ? \posix_getpid() : 1) . ' ' . $msg, \FILE_APPEND | \LOCK_EX);    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
177,walkor_Workerman_Worker_9621, Exit current process.\n\n @return void\n,Izađite iz trenutnog procesa,"    public static function checkIfChildRunning()    {        foreach (static::$_pidMap as $worker_id => $worker_pid_array) {            foreach ($worker_pid_array as $pid => $worker_pid) {                if (!\posix_kill($pid, 0)) {                    unset(static::$_pidMap[$worker_id][$pid]);                }            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
178,symfony_finder_DateComparator_390, DateCompare compiles date comparisons.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n,DateCompare kompajlira poređenje datuma,"class DateComparator extends Comparator{    /**     * @param string $test A comparison string     *     * @throws \InvalidArgumentException If the test is not understood     */    public function __construct(string $test)    {        if (!preg_match('#^\s*(==|!=|[<>]=?|after|since|before|until)?\s*(.+?)\s*$#i', $test, $matches)) {            throw new \InvalidArgumentException(sprintf('Don\'t understand ""%s"" as a date test.', $test));        }        try {            $date = new \DateTime($matches[2]);            $target = $date->format('U');        } catch (\Exception $e) {            throw new \InvalidArgumentException(sprintf('""%s"" is not a valid date.', $matches[2]));        }        $operator = $matches[1] ?? '==';        if ('since' === $operator || 'after' === $operator) {            $operator = '>';        }        if ('until' === $operator || 'before' === $operator) {            $operator = '<';        }        $this->setOperator($operator);        $this->setTarget($target);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
179,symfony_http-foundation_JsonResponse_8807, Response represents an HTTP response in JSON format.\n\n Note that this class does not force the returned JSON content to be an\n object. It is however recommended that you do return an object as it\n protects yourself against XSSI and JSON-JavaScript Hijacking.\n\n @see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside\n\n @author Igor Wiedler <igor@wiedler.ch>\n,"Odgovor predstavlja HTTP odgovor u JSON formatu. Imajte na umu da ova klasa ne prisiljava vraćeni JSON sadržaj da bude objekat. Međutim, preporučuje se da vratite objekat jer se on štiti od XSSSI i JSON-JavaScript hakovanja","class JsonResponse extends Response{    protected $data;    protected $callback;    // Encode <, >, ', &, and "" characters in the JSON, making it also safe to be embedded into HTML.    // 15 === JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT    public const DEFAULT_ENCODING_OPTIONS = 15;    protected $encodingOptions = self::DEFAULT_ENCODING_OPTIONS;    /**     * @param mixed $data    The response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     * @param bool  $json    If the data is already a JSON string     */    public function __construct($data = null, int $status = 200, array $headers = [], bool $json = false)    {        parent::__construct('', $status, $headers);        if ($json && !\is_string($data) && !is_numeric($data) && !\is_callable([$data, '__toString'])) {            throw new \TypeError(sprintf('""%s"": If $json is set to true, argument $data must be a string or object implementing __toString(), ""%s"" given.', __METHOD__, get_debug_type($data)));        }        if (null === $data) {            $data = new \ArrayObject();        }        $json ? $this->setJson($data) : $this->setData($data);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::create(['key' => 'value'])     *         ->setSharedMaxAge(300);     *     * @param mixed $data    The JSON response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     *     * @return static     *     * @deprecated since Symfony 5.1, use __construct() instead.     */    public static function create($data = null, int $status = 200, array $headers = [])    {        trigger_deprecation('symfony/http-foundation', '5.1', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($data, $status, $headers);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::fromJsonString('{""key"": ""value""}')     *         ->setSharedMaxAge(300);     *     * @param string $data    The JSON response string     * @param int    $status  The response status code     * @param array  $headers An array of response headers     *     * @return static     */    public static function fromJsonString(string $data, int $status = 200, array $headers = [])    {        return new static($data, $status, $headers, true);    }    /**     * Sets the JSONP callback.     *     * @param string|null $callback The JSONP callback or null to use none     *     * @return $this     *     * @throws \InvalidArgumentException When the callback name is not valid     */    public function setCallback(string $callback = null)    {        if (null !== $callback) {            // partially taken from https://geekality.net/2011/08/03/valid-javascript-identifier/            // partially taken from https://github.com/willdurand/JsonpCallbackValidator            //      JsonpCallbackValidator is released under the MIT License. See https://github.com/willdurand/JsonpCallbackValidator/blob/v1.1.0/LICENSE for details.            //      (c) William Durand <william.durand1@gmail.com>            $pattern = '/^[$_\p{L}][$_\p{L}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\x{200C}\x{200D}]*(?:\[(?:""(?:\\\.|[^""\\\])*""|\'(?:\\\.|[^\'\\\])*\'|\d+)\])*?$/u';            $reserved = [                'break', 'do', 'instanceof', 'typeof', 'case', 'else', 'new', 'var', 'catch', 'finally', 'return', 'void', 'continue', 'for', 'switch', 'while',                'debugger', 'function', 'this', 'with', 'default', 'if', 'throw', 'delete', 'in', 'try', 'class', 'enum', 'extends', 'super',  'const', 'export',                'import', 'implements', 'let', 'private', 'public', 'yield', 'interface', 'package', 'protected', 'static', 'null', 'true', 'false',            ];            $parts = explode('.', $callback);            foreach ($parts as $part) {                if (!preg_match($pattern, $part) || \in_array($part, $reserved, true)) {                    throw new \InvalidArgumentException('The callback name is not valid.');                }            }        }        $this->callback = $callback;        return $this->update();    }    /**     * Sets a raw string containing a JSON document to be sent.     *     * @return $this     */    public function setJson(string $json)    {        $this->data = $json;        return $this->update();    }    /**     * Sets the data to be sent as JSON.     *     * @param mixed $data     *     * @return $this     *     * @throws \InvalidArgumentException     */    public function setData($data = [])    {        try {            $data = json_encode($data, $this->encodingOptions);        } catch (\Exception $e) {            if ('Exception' === \get_class($e) && 0 === strpos($e->getMessage(), 'Failed calling ')) {                throw $e->getPrevious() ?: $e;            }            throw $e;        }        if (\PHP_VERSION_ID >= 70300 && (\JSON_THROW_ON_ERROR & $this->encodingOptions)) {            return $this->setJson($data);        }        if (\JSON_ERROR_NONE !== json_last_error()) {            throw new \InvalidArgumentException(json_last_error_msg());        }        return $this->setJson($data);    }    /**     * Returns options used while encoding data to JSON.     *     * @return int     */    public function getEncodingOptions()    {        return $this->encodingOptions;    }    /**     * Sets options used while encoding data to JSON.     *     * @return $this     */    public function setEncodingOptions(int $encodingOptions)    {        $this->encodingOptions = $encodingOptions;        return $this->setData(json_decode($this->data));    }    /**     * Updates the content and headers according to the JSON data and callback.     *     * @return $this     */    protected function update()    {        if (null !== $this->callback) {            // Not using application/javascript for compatibility reasons with older browsers.            $this->headers->set('Content-Type', 'text/javascript');            return $this->setContent(sprintf('/**/%s(%s);', $this->callback, $this->data));        }        // Only set the header when there is none or when it equals 'text/javascript' (from a previous update with callback)        // in order to not overwrite a custom definition.        if (!$this->headers->has('Content-Type') || 'text/javascript' === $this->headers->get('Content-Type')) {            $this->headers->set('Content-Type', 'application/json');        }        return $this->setContent($this->data);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
180,symfony_debug_DebugClassLoader_1727," Autoloader checking if the class is really defined in the file found.\n\n The ClassLoader will wrap all registered autoloaders\n and will throw an exception if a file is found but does\n not declare the class.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Christophe Coevoet <stof@notk.org>\n @author Nicolas Grekas <p@tchwork.com>\n @author Guilhem Niot <guilhem.niot@gmail.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\DebugClassLoader instead.\n","Autoloader proverava da li je klasa zaista definisana u pronađenoj datoteci. ClassLoader će umotati sve registrovane autoloadere i izbaciće izuzetak ako je datoteka pronađena, ali ne deklariše klasu","class DebugClassLoader{    private $classLoader;    private $isFinder;    private $loaded = [];    private static $caseCheck;    private static $checkedClasses = [];    private static $final = [];    private static $finalMethods = [];    private static $deprecated = [];    private static $internal = [];    private static $internalMethods = [];    private static $annotatedParameters = [];    private static $darwinCache = ['/' => ['/', []]];    private static $method = [];    public function __construct(callable $classLoader)    {        $this->classLoader = $classLoader;        $this->isFinder = \is_array($classLoader) && method_exists($classLoader[0], 'findFile');        if (!isset(self::$caseCheck)) {            $file = file_exists(__FILE__) ? __FILE__ : rtrim(realpath('.'), \DIRECTORY_SEPARATOR);            $i = strrpos($file, \DIRECTORY_SEPARATOR);            $dir = substr($file, 0, 1 + $i);            $file = substr($file, 1 + $i);            $test = strtoupper($file) === $file ? strtolower($file) : strtoupper($file);            $test = realpath($dir.$test);            if (false === $test || false === $i) {                // filesystem is case sensitive                self::$caseCheck = 0;            } elseif (substr($test, -\strlen($file)) === $file) {                // filesystem is case insensitive and realpath() normalizes the case of characters                self::$caseCheck = 1;            } elseif (false !== stripos(\PHP_OS, 'darwin')) {                // on MacOSX, HFS+ is case insensitive but realpath() doesn't normalize the case of characters                self::$caseCheck = 2;            } else {                // filesystem case checks failed, fallback to disabling them                self::$caseCheck = 0;            }        }    }    /**     * Gets the wrapped class loader.     *     * @return callable The wrapped class loader     */    public function getClassLoader()    {        return $this->classLoader;    }    /**     * Wraps all autoloaders.     */    public static function enable()    {        // Ensures we don't hit https://bugs.php.net/42098        class_exists(\Symfony\Component\Debug\ErrorHandler::class);        class_exists(\Psr\Log\LogLevel::class);        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (!\is_array($function) || !$function[0] instanceof self) {                $function = [new static($function), 'loadClass'];            }            spl_autoload_register($function);        }    }    /**     * Disables the wrapping.     */    public static function disable()    {        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (\is_array($function) && $function[0] instanceof self) {                $function = $function[0]->getClassLoader();            }            spl_autoload_register($function);        }    }    /**     * @return string|null     */    public function findFile($class)    {        return $this->isFinder ? $this->classLoader[0]->findFile($class) ?: null : null;    }    /**     * Loads the given class or interface.     *     * @param string $class The name of the class     *     * @throws \RuntimeException     */    public function loadClass($class)    {        $e = error_reporting(error_reporting() | \E_PARSE | \E_ERROR | \E_CORE_ERROR | \E_COMPILE_ERROR);        try {            if ($this->isFinder && !isset($this->loaded[$class])) {                $this->loaded[$class] = true;                if (!$file = $this->classLoader[0]->findFile($class) ?: false) {                    // no-op                } elseif (\function_exists('opcache_is_script_cached') && @opcache_is_script_cached($file)) {                    include $file;                    return;                } elseif (false === include $file) {                    return;                }            } else {                ($this->classLoader)($class);                $file = false;            }        } finally {            error_reporting($e);        }        $this->checkClass($class, $file);    }    private function checkClass(string $class, string $file = null)    {        $exists = null === $file || class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);        if (null !== $file && $class && '\\' === $class[0]) {            $class = substr($class, 1);        }        if ($exists) {            if (isset(self::$checkedClasses[$class])) {                return;            }            self::$checkedClasses[$class] = true;            $refl = new \ReflectionClass($class);            if (null === $file && $refl->isInternal()) {                return;            }            $name = $refl->getName();            if ($name !== $class && 0 === strcasecmp($name, $class)) {                throw new \RuntimeException(sprintf('Case mismatch between loaded and declared class names: ""%s"" vs ""%s"".', $class, $name));            }            $deprecations = $this->checkAnnotations($refl, $name);            foreach ($deprecations as $message) {                @trigger_error($message, \E_USER_DEPRECATED);            }        }        if (!$file) {            return;        }        if (!$exists) {            if (false !== strpos($class, '/')) {                throw new \RuntimeException(sprintf('Trying to autoload a class with an invalid name ""%s"". Be careful that the namespace separator is ""\"" in PHP, not ""/"".', $class));            }            throw new \RuntimeException(sprintf('The autoloader expected class ""%s"" to be defined in file ""%s"". The file was found but the class was not in it, the class name or namespace probably has a typo.', $class, $file));        }        if (self::$caseCheck && $message = $this->checkCase($refl, $file, $class)) {            throw new \RuntimeException(sprintf('Case mismatch between class and real file names: ""%s"" vs ""%s"" in ""%s"".', $message[0], $message[1], $message[2]));        }    }    public function checkAnnotations(\ReflectionClass $refl, $class)    {        $deprecations = [];        // Don't trigger deprecations for classes in the same vendor        if (2 > $len = 1 + (strpos($class, '\\') ?: strpos($class, '_'))) {            $len = 0;            $ns = '';        } else {            $ns = str_replace('_', '\\', substr($class, 0, $len));        }        // Detect annotations on the class        if (false !== $doc = $refl->getDocComment()) {            foreach (['final', 'deprecated', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    self::${$annotation}[$class] = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                }            }            if ($refl->isInterface() && false !== strpos($doc, 'method') && preg_match_all('#\n \* @method\s+(static\s+)?+(?:[\w\|&\[\]\\\]+\s+)?(\w+(?:\s*\([^\)]*\))?)+(.+?([[:punct:]]\s*)?)?(?=\r?\n \*(?: @|/$|\r?\n))#', $doc, $notice, \PREG_SET_ORDER)) {                foreach ($notice as $method) {                    $static = '' !== $method[1];                    $name = $method[2];                    $description = $method[3] ?? null;                    if (false === strpos($name, '(')) {                        $name .= '()';                    }                    if (null !== $description) {                        $description = trim($description);                        if (!isset($method[4])) {                            $description .= '.';                        }                    }                    self::$method[$class][] = [$class, $name, $static, $description];                }            }        }        $parent = get_parent_class($class);        $parentAndOwnInterfaces = $this->getOwnInterfaces($class, $parent ?: null);        if ($parent) {            $parentAndOwnInterfaces[$parent] = $parent;            if (!isset(self::$checkedClasses[$parent])) {                $this->checkClass($parent);            }            if (isset(self::$final[$parent])) {                $deprecations[] = sprintf('The ""%s"" class is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $parent, self::$final[$parent], $class);            }        }        // Detect if the parent is annotated        foreach ($parentAndOwnInterfaces + class_uses($class, false) as $use) {            if (!isset(self::$checkedClasses[$use])) {                $this->checkClass($use);            }            if (isset(self::$deprecated[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len) && !isset(self::$deprecated[$class])) {                $type = class_exists($class, false) ? 'class' : (interface_exists($class, false) ? 'interface' : 'trait');                $verb = class_exists($use, false) || interface_exists($class, false) ? 'extends' : (interface_exists($use, false) ? 'implements' : 'uses');                $deprecations[] = sprintf('The ""%s"" %s %s ""%s"" that is deprecated%s.', $class, $type, $verb, $use, self::$deprecated[$use]);            }            if (isset(self::$internal[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len)) {                $deprecations[] = sprintf('The ""%s"" %s is considered internal%s. It may change without further notice. You should not use it from ""%s"".', $use, class_exists($use, false) ? 'class' : (interface_exists($use, false) ? 'interface' : 'trait'), self::$internal[$use], $class);            }            if (isset(self::$method[$use])) {                if ($refl->isAbstract()) {                    if (isset(self::$method[$class])) {                        self::$method[$class] = array_merge(self::$method[$class], self::$method[$use]);                    } else {                        self::$method[$class] = self::$method[$use];                    }                } elseif (!$refl->isInterface()) {                    $hasCall = $refl->hasMethod('__call');                    $hasStaticCall = $refl->hasMethod('__callStatic');                    foreach (self::$method[$use] as $method) {                        [$interface, $name, $static, $description] = $method;                        if ($static ? $hasStaticCall : $hasCall) {                            continue;                        }                        $realName = substr($name, 0, strpos($name, '('));                        if (!$refl->hasMethod($realName) || !($methodRefl = $refl->getMethod($realName))->isPublic() || ($static && !$methodRefl->isStatic()) || (!$static && $methodRefl->isStatic())) {                            $deprecations[] = sprintf('Class ""%s"" should implement method ""%s::%s""%s', $class, ($static ? 'static ' : '').$interface, $name, null == $description ? '.' : ': '.$description);                        }                    }                }            }        }        if (trait_exists($class)) {            return $deprecations;        }        // Inherit @final, @internal and @param annotations for methods        self::$finalMethods[$class] = [];        self::$internalMethods[$class] = [];        self::$annotatedParameters[$class] = [];        foreach ($parentAndOwnInterfaces as $use) {            foreach (['finalMethods', 'internalMethods', 'annotatedParameters'] as $property) {                if (isset(self::${$property}[$use])) {                    self::${$property}[$class] = self::${$property}[$class] ? self::${$property}[$use] + self::${$property}[$class] : self::${$property}[$use];                }            }        }        foreach ($refl->getMethods(\ReflectionMethod::IS_PUBLIC | \ReflectionMethod::IS_PROTECTED) as $method) {            if ($method->class !== $class) {                continue;            }            if ($parent && isset(self::$finalMethods[$parent][$method->name])) {                [$declaringClass, $message] = self::$finalMethods[$parent][$method->name];                $deprecations[] = sprintf('The ""%s::%s()"" method is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);            }            if (isset(self::$internalMethods[$class][$method->name])) {                [$declaringClass, $message] = self::$internalMethods[$class][$method->name];                if (strncmp($ns, $declaringClass, $len)) {                    $deprecations[] = sprintf('The ""%s::%s()"" method is considered internal%s. It may change without further notice. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);                }            }            // To read method annotations            $doc = $method->getDocComment();            if (isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }                foreach (self::$annotatedParameters[$class][$method->name] as $parameterName => $deprecation) {                    if (!isset($definedParameters[$parameterName]) && !($doc && preg_match(""/\\n\\s+\\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\\\${$parameterName}\\b/"", $doc))) {                        $deprecations[] = sprintf($deprecation, $class);                    }                }            }            if (!$doc) {                continue;            }            $finalOrInternal = false;            foreach (['final', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    $message = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                    self::${$annotation.'Methods'}[$class][$method->name] = [$class, $message];                    $finalOrInternal = true;                }            }            if ($finalOrInternal || $method->isConstructor() || false === strpos($doc, '@param') || StatelessInvocation::class === $class) {                continue;            }            if (!preg_match_all('#\n\s+\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\$([a-zA-Z0-9_\x7f-\xff]++)#', $doc, $matches, \PREG_SET_ORDER)) {                continue;            }            if (!isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }            }            foreach ($matches as [, $parameterType, $parameterName]) {                if (!isset($definedParameters[$parameterName])) {                    $parameterType = trim($parameterType);                    self::$annotatedParameters[$class][$method->name][$parameterName] = sprintf('The ""%%s::%s()"" method will require a new ""%s$%s"" argument in the next major version of its %s ""%s"", not defining it is deprecated.', $method->name, $parameterType ? $parameterType.' ' : '', $parameterName, interface_exists($class) ? 'interface' : 'parent class', $method->class);                }            }        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
181,symfony_http-foundation_IpUtils_8805," Compares two IPv6 addresses.\n In case a subnet is given, it checks if it contains the request IP.\n\n @author David Soria Parra <dsp at php dot net>\n\n @see https://github.com/dsp/v6tools\n\n @param string $ip IPv6 address or subnet in CIDR notation\n\n @return bool Whether the IP is valid\n\n @throws \\RuntimeException When IPV6 support is not enabled\n","Poredi dve IPv6 adrese. U slučaju davanja podmreže, ona proverava da li sadrži IP zahtev","    public static function checkIp6(?string $requestIp, string $ip)    {        $cacheKey = $requestIp.'-'.$ip;        if (isset(self::$checkedIps[$cacheKey])) {            return self::$checkedIps[$cacheKey];        }        if (!((\extension_loaded('sockets') && \defined('AF_INET6')) || @inet_pton('::1'))) {            throw new \RuntimeException('Unable to check Ipv6. Check that PHP was not compiled with option ""disable-ipv6"".');        }        if (false !== strpos($ip, '/')) {            [$address, $netmask] = explode('/', $ip, 2);            if ('0' === $netmask) {                return (bool) unpack('n*', @inet_pton($address));            }            if ($netmask < 1 || $netmask > 128) {                return self::$checkedIps[$cacheKey] = false;            }        } else {            $address = $ip;            $netmask = 128;        }        $bytesAddr = unpack('n*', @inet_pton($address));        $bytesTest = unpack('n*', @inet_pton($requestIp));        if (!$bytesAddr || !$bytesTest) {            return self::$checkedIps[$cacheKey] = false;        }        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {            $left = $netmask - 16 * ($i - 1);            $left = ($left <= 16) ? $left : 16;            $mask = ~(0xffff >> $left) & 0xffff;            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {                return self::$checkedIps[$cacheKey] = false;            }        }        return self::$checkedIps[$cacheKey] = true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
182,firefly-iii_firefly-iii_breadcrumbs_832, Cuts away the middle of a string when it's very long.\\n\\n @param string $string\\n\\n @return string\\n,Odseče sredinu od stringa kada je veoma dugačka,"    function limitStringLength(string $string): string    {        $maxChars = 75;        $length   = \strlen($string);        $result   = $string;        if ($length > $maxChars) {            $result = substr_replace($string, ' ... ', (int)($maxChars / 2), $length - $maxChars);        }        return $result;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
183,matomo-org_matomo_RowEvolution_986," Returns a prettier, more comprehensible version of a row evolution label for display.\n","Vraća lepšu, razumljiviju verziju oznake evolucije reda za prikaz","    private function cleanOriginalLabel($label)    {        $label = str_replace(LabelFilter::SEPARATOR_RECURSIVE_LABEL, ' - ', $label);        $label = SafeDecodeLabel::decodeLabelSafe($label);        return $label;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
184,serbanghita_Mobile-Detect_Mobile_Detect_1151," Prepare the version number.\n\n @todo Remove the error supression from str_replace() call.\n\n @param string $ver The string version, like ""2.6.21.2152"";\n\n @return float\n",Pripremite broj verzije,"    public function prepareVersionNo($ver)    {        $ver = str_replace(array('_', ' ', '/'), '.', $ver);        $arrVer = explode('.', $ver, 2);        if (isset($arrVer[1])) {            $arrVer[1] = @str_replace('.', '', $arrVer[1]); // @todo: treat strings versions.        }        return (float) implode('.', $arrVer);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
185,Intervention_image_AbstractDecoder_432, Determines if current source data is base64 encoded\\\\n\\\\n @return boolean\\\\n,Određuje da li su trenutni izvorni podaci base64 kodirani ,"    public function isBase64()    {        if (!is_string($this->data)) {            return false;        }        return base64_encode(base64_decode($this->data)) === str_replace([""\n"", ""\r""], '', $this->data);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
186,filp_whoops_Frame_6725," Returns the full contents of the file for this frame,\n if it's known.\n @return string|null\n","Vraća puni sadržaj datoteke za dati frejm, ako je poznat","    public function getFileContents()    {        if ($this->fileContentsCache === null && $filePath = $this->getFile()) {            // Leave the stage early when 'Unknown' or '[internal]' is passed            // this would otherwise raise an exception when            // open_basedir is enabled.            if ($filePath === ""Unknown"" || $filePath === '[internal]') {                return null;            }            try {                $this->fileContentsCache = file_get_contents($filePath);            } catch (ErrorException $exception) {                // Internal file paths of PHP extensions cannot be opened            }        }        return $this->fileContentsCache;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
187,php-pm_php-pm_RequestHandler_1643, Buffer incoming data until slave connection is available\\\\n and headers have been received\\\\n\\\\n @param string $data\\\\n,Podaci dolaze preko bafera dok ne bude dostupna pomoćna veza i zaglavlja se ne prime,"    public function handleData($data)    {        $this->incomingBuffer .= $data;        if ($this->connection && $this->isHeaderEnd($this->incomingBuffer)) {            $remoteAddress = (string) $this->incoming->getRemoteAddress();            $headersToReplace = [                'X-PHP-PM-Remote-IP' => \trim(\parse_url($remoteAddress, PHP_URL_HOST), '[]'),                'X-PHP-PM-Remote-Port' => \trim(\parse_url($remoteAddress, PHP_URL_PORT), '[]')            ];            $buffer = $this->replaceHeader($this->incomingBuffer, $headersToReplace);            $this->connection->write($buffer);            $this->incoming->removeListener('data', [$this, 'handleData']);            $this->incoming->pipe($this->connection);        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
188,symfony_debug_BufferingLogger_1725," A buffering logger that stacks logs for later.\n\n @author Nicolas Grekas <p@tchwork.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\BufferingLogger instead.\n",Loger bafera slaže evidencije za kasnije,"class BufferingLogger extends AbstractLogger{    private $logs = [];    /**     * @return void     */    public function log($level, $message, array $context = [])    {        $this->logs[] = [$level, $message, $context];    }    public function cleanLogs()    {        $logs = $this->logs;        $this->logs = [];        return $logs;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
189,symfony_http-foundation_Response_8045, Cleans or flushes output buffers up to target level.\n\n Resulting level can be greater than target level if a non-removable buffer has been encountered.\n\n @final\n,Čisti ili ispira izlazne bafere do ciljanog nivoa. Rezultatni nivo može biti veći od ciljnog ako je naišao na ne uklonjivi bafer,"    public function __toString()    {        return            sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText).""\r\n"".            $this->headers.""\r\n"".            $this->getContent();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
190,guzzle_guzzle_BodySummarizer_1389, Returns a summarized message body.\n,Prikazuje sažeto telo poruke,"    public function summarize(MessageInterface $message): ?string    {        return $this->truncateAt === null            ? \GuzzleHttp\Psr7\Message::bodySummary($message)            : \GuzzleHttp\Psr7\Message::bodySummary($message, $this->truncateAt);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
191,mockery_mockery_CompositeExpectation_418, Return the string summary of this composite expectation\\\\\\\\n\\\\\\\\n @return string\\\\\\\\n,Vrati string rezime složenog očekivanja,"    public function __toString()    {        $return = '[';        $parts = array();        foreach ($this->_expectations as $exp) {            $parts[] = (string) $exp;        }        $return .= implode(', ', $parts) . ']';        return $return;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
192,php-pm_php-pm_SlavePool_1678, Return a human-readable summary of the slaves in the pool.\\\\n\\\\n @return array\\\\n,Vratite čoveku čitljiv sažetak slaves-a u pool-u,"    public function getStatusSummary()    {        $map = [            'total' => Slave::ANY,            'ready' => Slave::READY,            'busy' => Slave::BUSY,            'created' => Slave::CREATED,            'registered' => Slave::REGISTERED,            'closed' => Slave::CLOSED        ];        return \array_map(function ($state) {            return \count($this->getByStatus($state));        }, $map);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
193,spatie_array-functions_array_functions_1062, Returns an array with the unique values from all the given arrays.\n\n @param \\array[] $arrays\n\n @return array\n,Prikazuje niz sa jedinstvenim vrednostima iz svih zadatih nizova,"function array_merge_values(array ...$arrays){    $allValues = array_reduce($arrays, static function ($carry, $array) {        return array_merge($carry, $array);    }, []);    return array_values(array_unique($allValues));}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
195,PrestaShop_PrestaShop_CMSCategory_855, Return an array of all children of the current CMSCategory.\\\\n\\\\n @return PrestaShopCollection Collection of CMSCategory\\\\n,Vrati niz svih podređenih elemenata trenutne CMSCategorije,"    private function getAllChildren()    {        // Get children        $toDelete = [(int) $this->id];        $this->recursiveDelete($toDelete, (int) $this->id);        $toDelete = array_unique($toDelete);        // remove id of current CMSCategory because we want only ids of children        unset($toDelete[0]);        if (count($toDelete)) {            $children = new PrestaShopCollection('CMSCategory');            $children->where('id_cms_category', 'in', $toDelete);            return $children;        }        return $toDelete;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
196,jorgecasas_php-ml_Apriori_811," Calculates frequent k item sets, where count($samples) == $k - 1.\n\n @param mixed[][] $samples\n\n @return mixed[][]\n","Izračunava česte k skupove predmeta, gde je count($samples) == $k - 1","    private function candidates(array $samples): array    {        $candidates = [];        foreach ($samples as $p) {            foreach ($samples as $q) {                if (count(array_merge(array_diff($p, $q), array_diff($q, $p))) != 2) {                    continue;                }                $candidate = array_values(array_unique(array_merge($p, $q)));                if ($this->contains($candidates, $candidate)) {                    continue;                }                foreach ($this->samples as $sample) {                    if ($this->subset($sample, $candidate)) {                        $candidates[] = $candidate;                        continue 2;                    }                }            }        }        return $candidates;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
197,markrogoyski_math-php_Integer_2969, Radical (or squarefree kernel)\\n The radical of a positive integer is the product of its distinct prime factors.\\n\\n @see    https://en.wikipedia.org/wiki/Radical_of_an_integer\\n @see    https://oeis.org/A007947\\n\\n @param  int $n\\n\\n @return int the radical of n\\n\\n @throws Exception\\\\OutOfBoundsException if n is < 1.\\n,Radikal (ili jezgro bez kvadrata) Radikal pozitivnog celog broja proizvod je njegovih različitih osnovnih faktora,    public static function radical(int $n): int    {        return \array_product(\array_unique(self::primeFactorization($n)));    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
198,symfony_css-selector_FunctionExtension_3331," XPath expression translator function extension.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-FranÃ§ois Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n",Proširenje funkcije prevodioca izraza XPath. Ova komponenta je port Python cssselect biblioteke,"class FunctionExtension extends AbstractExtension{    /**     * {@inheritdoc}     */    public function getFunctionTranslators(): array    {        return [            'nth-child' => [$this, 'translateNthChild'],            'nth-last-child' => [$this, 'translateNthLastChild'],            'nth-of-type' => [$this, 'translateNthOfType'],            'nth-last-of-type' => [$this, 'translateNthLastOfType'],            'contains' => [$this, 'translateContains'],            'lang' => [$this, 'translateLang'],        ];    }    /**     * @throws ExpressionErrorException     */    public function translateNthChild(XPathExpr $xpath, FunctionNode $function, bool $last = false, bool $addNameTest = true): XPathExpr    {        try {            [$a, $b] = Parser::parseSeries($function->getArguments());        } catch (SyntaxErrorException $e) {            throw new ExpressionErrorException(sprintf('Invalid series: ""%s"".', implode('"", ""', $function->getArguments())), 0, $e);        }        $xpath->addStarPrefix();        if ($addNameTest) {            $xpath->addNameTest();        }        if (0 === $a) {            return $xpath->addCondition('position() = '.($last ? 'last() - '.($b - 1) : $b));        }        if ($a < 0) {            if ($b < 1) {                return $xpath->addCondition('false()');            }            $sign = '<=';        } else {            $sign = '>=';        }        $expr = 'position()';        if ($last) {            $expr = 'last() - '.$expr;            --$b;        }        if (0 !== $b) {            $expr .= ' - '.$b;        }        $conditions = [sprintf('%s %s 0', $expr, $sign)];        if (1 !== $a && -1 !== $a) {            $conditions[] = sprintf('(%s) mod %d = 0', $expr, $a);        }        return $xpath->addCondition(implode(' and ', $conditions));        // todo: handle an+b, odd, even        // an+b means every-a, plus b, e.g., 2n+1 means odd        // 0n+b means b        // n+0 means a=1, i.e., all elements        // an means every a elements, i.e., 2n means even        // -n means -1n        // -1n+6 means elements 6 and previous    }    public function translateNthLastChild(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        return $this->translateNthChild($xpath, $function, true);    }    public function translateNthOfType(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        return $this->translateNthChild($xpath, $function, false, false);    }    /**     * @throws ExpressionErrorException     */    public function translateNthLastOfType(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        if ('*' === $xpath->getElement()) {            throw new ExpressionErrorException('""*:nth-of-type()"" is not implemented.');        }        return $this->translateNthChild($xpath, $function, true, false);    }    /**     * @throws ExpressionErrorException     */    public function translateContains(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        $arguments = $function->getArguments();        foreach ($arguments as $token) {            if (!($token->isString() || $token->isIdentifier())) {                throw new ExpressionErrorException('Expected a single string or identifier for :contains(), got '.implode(', ', $arguments));            }        }        return $xpath->addCondition(sprintf(            'contains(string(.), %s)',            Translator::getXpathLiteral($arguments[0]->getValue())        ));    }    /**     * @throws ExpressionErrorException     */    public function translateLang(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        $arguments = $function->getArguments();        foreach ($arguments as $token) {            if (!($token->isString() || $token->isIdentifier())) {                throw new ExpressionErrorException('Expected a single string or identifier for :lang(), got '.implode(', ', $arguments));            }        }        return $xpath->addCondition(sprintf(            'lang(%s)',            Translator::getXpathLiteral($arguments[0]->getValue())        ));    }    /**     * {@inheritdoc}     */    public function getName(): string    {        return 'function';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
199,symfony_css-selector_Translator_3301," XPath expression translator interface.\n\n This component is a port of the Python cssselect library,\n which is copyright Ian Bicking, @see https://github.com/SimonSapin/cssselect.\n\n @author Jean-FranÃ§ois Simon <jeanfrancois.simon@sensiolabs.com>\n\n @internal\n",Interfejs prevodioca izraza XPath. Ova komponenta je port Python cssselect biblioteke,"class Translator implements TranslatorInterface{    private $mainParser;    /**     * @var ParserInterface[]     */    private $shortcutParsers = [];    /**     * @var Extension\ExtensionInterface[]     */    private $extensions = [];    private $nodeTranslators = [];    private $combinationTranslators = [];    private $functionTranslators = [];    private $pseudoClassTranslators = [];    private $attributeMatchingTranslators = [];    public function __construct(ParserInterface $parser = null)    {        $this->mainParser = $parser ?? new Parser();        $this            ->registerExtension(new Extension\NodeExtension())            ->registerExtension(new Extension\CombinationExtension())            ->registerExtension(new Extension\FunctionExtension())            ->registerExtension(new Extension\PseudoClassExtension())            ->registerExtension(new Extension\AttributeMatchingExtension())        ;    }    public static function getXpathLiteral(string $element): string    {        if (false === strpos($element, ""'"")) {            return ""'"".$element.""'"";        }        if (false === strpos($element, '""')) {            return '""'.$element.'""';        }        $string = $element;        $parts = [];        while (true) {            if (false !== $pos = strpos($string, ""'"")) {                $parts[] = sprintf(""'%s'"", substr($string, 0, $pos));                $parts[] = ""\""'\"""";                $string = substr($string, $pos + 1);            } else {                $parts[] = ""'$string'"";                break;            }        }        return sprintf('concat(%s)', implode(', ', $parts));    }    /**     * {@inheritdoc}     */    public function cssToXPath(string $cssExpr, string $prefix = 'descendant-or-self::'): string    {        $selectors = $this->parseSelectors($cssExpr);        /** @var SelectorNode $selector */        foreach ($selectors as $index => $selector) {            if (null !== $selector->getPseudoElement()) {                throw new ExpressionErrorException('Pseudo-elements are not supported.');            }            $selectors[$index] = $this->selectorToXPath($selector, $prefix);        }        return implode(' | ', $selectors);    }    /**     * {@inheritdoc}     */    public function selectorToXPath(SelectorNode $selector, string $prefix = 'descendant-or-self::'): string    {        return ($prefix ?: '').$this->nodeToXPath($selector);    }    /**     * @return $this     */    public function registerExtension(Extension\ExtensionInterface $extension): self    {        $this->extensions[$extension->getName()] = $extension;        $this->nodeTranslators = array_merge($this->nodeTranslators, $extension->getNodeTranslators());        $this->combinationTranslators = array_merge($this->combinationTranslators, $extension->getCombinationTranslators());        $this->functionTranslators = array_merge($this->functionTranslators, $extension->getFunctionTranslators());        $this->pseudoClassTranslators = array_merge($this->pseudoClassTranslators, $extension->getPseudoClassTranslators());        $this->attributeMatchingTranslators = array_merge($this->attributeMatchingTranslators, $extension->getAttributeMatchingTranslators());        return $this;    }    /**     * @throws ExpressionErrorException     */    public function getExtension(string $name): Extension\ExtensionInterface    {        if (!isset($this->extensions[$name])) {            throw new ExpressionErrorException(sprintf('Extension ""%s"" not registered.', $name));        }        return $this->extensions[$name];    }    /**     * @return $this     */    public function registerParserShortcut(ParserInterface $shortcut): self    {        $this->shortcutParsers[] = $shortcut;        return $this;    }    /**     * @throws ExpressionErrorException     */    public function nodeToXPath(NodeInterface $node): XPathExpr    {        if (!isset($this->nodeTranslators[$node->getNodeName()])) {            throw new ExpressionErrorException(sprintf('Node ""%s"" not supported.', $node->getNodeName()));        }        return $this->nodeTranslators[$node->getNodeName()]($node, $this);    }    /**     * @throws ExpressionErrorException     */    public function addCombination(string $combiner, NodeInterface $xpath, NodeInterface $combinedXpath): XPathExpr    {        if (!isset($this->combinationTranslators[$combiner])) {            throw new ExpressionErrorException(sprintf('Combiner ""%s"" not supported.', $combiner));        }        return $this->combinationTranslators[$combiner]($this->nodeToXPath($xpath), $this->nodeToXPath($combinedXpath));    }    /**     * @throws ExpressionErrorException     */    public function addFunction(XPathExpr $xpath, FunctionNode $function): XPathExpr    {        if (!isset($this->functionTranslators[$function->getName()])) {            throw new ExpressionErrorException(sprintf('Function ""%s"" not supported.', $function->getName()));        }        return $this->functionTranslators[$function->getName()]($xpath, $function);    }    /**     * @throws ExpressionErrorException     */    public function addPseudoClass(XPathExpr $xpath, string $pseudoClass): XPathExpr    {        if (!isset($this->pseudoClassTranslators[$pseudoClass])) {            throw new ExpressionErrorException(sprintf('Pseudo-class ""%s"" not supported.', $pseudoClass));        }        return $this->pseudoClassTranslators[$pseudoClass]($xpath);    }    /**     * @throws ExpressionErrorException     */    public function addAttributeMatching(XPathExpr $xpath, string $operator, string $attribute, $value): XPathExpr    {        if (!isset($this->attributeMatchingTranslators[$operator])) {            throw new ExpressionErrorException(sprintf('Attribute matcher operator ""%s"" not supported.', $operator));        }        return $this->attributeMatchingTranslators[$operator]($xpath, $attribute, $value);    }    /**     * @return SelectorNode[]     */    private function parseSelectors(string $css): array    {        foreach ($this->shortcutParsers as $shortcut) {            $tokens = $shortcut->parse($css);            if (!empty($tokens)) {                return $tokens;            }        }        return $this->mainParser->parse($css);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
200,pagekit_pagekit_ExtensionTranslateCommand_892, Returns all files of an extension to extract translations.\\n\\n @param  string $path\\n @return array\\n,Vraća sve datoteke ekstenzije za izdvajanje prevoda,"    protected function getFiles($path, $extension)    {        $files = Finder::create()->files()->in($path);        if ($extension == ""system"") {            // add installer files            $files->in($this->container->path().'/app/installer');        }        return $files->name('*.{php,vue,js,html,twig}');    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
201,predis_predis_ClusterStrategy_2167, Extracts the key from BITOP command.\n\n @param CommandInterface $command Command instance.\n\n @return string|null\n,Izdvaja ključ iz BITOP naredbe,"    protected function getKeyFromBitOp(CommandInterface $command)    {        $arguments = $command->getArguments();        if ($this->checkSameSlotForKeys(array_slice($arguments, 1, count($arguments)))) {            return $arguments[1];        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
202,predis_predis_ClusterStrategy_2170, Extracts the key from EVAL and EVALSHA commands.\\n\\n @param CommandInterface $command Command instance.\\n\\n @return string|null\\n,Izdvaja ključ iz naredbi EVAL i EVALSHA,"    protected function getKeyFromScriptingCommands(CommandInterface $command)    {        if ($command instanceof ScriptCommand) {            $keys = $command->getKeys();        } else {            $keys = array_slice($args = $command->getArguments(), 2, $args[1]);        }        if ($keys && $this->checkSameSlotForKeys($keys)) {            return $keys[0];        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
203,PHPOffice_PHPWord_Settings_899, PHPWord settings class\\n\\n @since 0.8.0\\n,HPWord podešavanja klase,"class Settings{    /**     * Zip libraries     *     * @const string     */    const ZIPARCHIVE = 'ZipArchive';    const PCLZIP = 'PclZip';    const OLD_LIB = 'PhpOffice\\PhpWord\\Shared\\ZipArchive'; // @deprecated 0.11    /**     * PDF rendering libraries     *     * @const string     */    const PDF_RENDERER_DOMPDF = 'DomPDF';    const PDF_RENDERER_TCPDF = 'TCPDF';    const PDF_RENDERER_MPDF = 'MPDF';    /**     * Measurement units multiplication factor     *     * Applied to:     * - Section: margins, header/footer height, gutter, column spacing     * - Tab: position     * - Indentation: left, right, firstLine, hanging     * - Spacing: before, after     *     * @const string     */    const UNIT_TWIP = 'twip'; // = 1/20 point    const UNIT_CM = 'cm';    const UNIT_MM = 'mm';    const UNIT_INCH = 'inch';    const UNIT_POINT = 'point'; // = 1/72 inch    const UNIT_PICA = 'pica'; // = 1/6 inch = 12 points    /**     * Default font settings     *     * OOXML defined font size values in halfpoints, i.e. twice of what PhpWord     * use, and the conversion will be conducted during XML writing.     */    const DEFAULT_FONT_NAME = 'Arial';    const DEFAULT_FONT_SIZE = 10;    const DEFAULT_FONT_COLOR = '000000';    const DEFAULT_FONT_CONTENT_TYPE = 'default'; // default|eastAsia|cs    const DEFAULT_PAPER = 'A4';    /**     * Compatibility option for XMLWriter     *     * @var bool     */    private static $xmlWriterCompatibility = true;    /**     * Name of the class used for Zip file management     *     * @var string     */    private static $zipClass = self::ZIPARCHIVE;    /**     * Name of the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererName = null;    /**     * Directory Path to the external Library used for rendering PDF files     *     * @var string     */    private static $pdfRendererPath = null;    /**     * Measurement unit     *     * @var int|float     */    private static $measurementUnit = self::UNIT_TWIP;    /**     * Default font name     *     * @var string     */    private static $defaultFontName = self::DEFAULT_FONT_NAME;    /**     * Default font size     * @var int     */    private static $defaultFontSize = self::DEFAULT_FONT_SIZE;    /**     * Default paper     * @var string     */    private static $defaultPaper = self::DEFAULT_PAPER;    /**     * The user defined temporary directory.     *     * @var string     */    private static $tempDir = '';    /**     * Enables built-in output escaping mechanism.     * Default value is `false` for backward compatibility with versions below 0.13.0.     *     * @var bool     */    private static $outputEscapingEnabled = false;    /**     * Return the compatibility option used by the XMLWriter     *     * @return bool Compatibility     */    public static function hasCompatibility()    {        return self::$xmlWriterCompatibility;    }    /**     * Set the compatibility option used by the XMLWriter     *     * This sets the setIndent and setIndentString for better compatibility     *     * @param bool $compatibility     * @return bool     */    public static function setCompatibility($compatibility)    {        $compatibility = (bool) $compatibility;        self::$xmlWriterCompatibility = $compatibility;        return true;    }    /**     * Get zip handler class     *     * @return string     */    public static function getZipClass()    {        return self::$zipClass;    }    /**     * Set zip handler class     *     * @param  string $zipClass     * @return bool     */    public static function setZipClass($zipClass)    {        if (in_array($zipClass, array(self::PCLZIP, self::ZIPARCHIVE, self::OLD_LIB))) {            self::$zipClass = $zipClass;            return true;        }        return false;    }    /**     * Set details of the external library for rendering PDF files     *     * @param string $libraryName     * @param string $libraryBaseDir     * @return bool Success or failure     */    public static function setPdfRenderer($libraryName, $libraryBaseDir)    {        if (!self::setPdfRendererName($libraryName)) {            return false;        }        return self::setPdfRendererPath($libraryBaseDir);    }    /**     * Return the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererName()    {        return self::$pdfRendererName;    }    /**     * Identify the external library to use for rendering PDF files     *     * @param string $libraryName     * @return bool     */    public static function setPdfRendererName($libraryName)    {        $pdfRenderers = array(self::PDF_RENDERER_DOMPDF, self::PDF_RENDERER_TCPDF, self::PDF_RENDERER_MPDF);        if (!in_array($libraryName, $pdfRenderers)) {            return false;        }        self::$pdfRendererName = $libraryName;        return true;    }    /**     * Return the directory path to the PDF Rendering Library.     *     * @return string     */    public static function getPdfRendererPath()    {        return self::$pdfRendererPath;    }    /**     * Location of external library to use for rendering PDF files     *     * @param string $libraryBaseDir Directory path to the library's base folder     * @return bool Success or failure     */    public static function setPdfRendererPath($libraryBaseDir)    {        if (false === file_exists($libraryBaseDir) || false === is_readable($libraryBaseDir)) {            return false;        }        self::$pdfRendererPath = $libraryBaseDir;        return true;    }    /**     * Get measurement unit     *     * @return string     */    public static function getMeasurementUnit()    {        return self::$measurementUnit;    }    /**     * Set measurement unit     *     * @param string $value     * @return bool     */    public static function setMeasurementUnit($value)    {        $units = array(self::UNIT_TWIP, self::UNIT_CM, self::UNIT_MM, self::UNIT_INCH,            self::UNIT_POINT, self::UNIT_PICA, );        if (!in_array($value, $units)) {            return false;        }        self::$measurementUnit = $value;        return true;    }    /**     * Sets the user defined path to temporary directory.     *     * @since 0.12.0     *     * @param string $tempDir The user defined path to temporary directory     */    public static function setTempDir($tempDir)    {        self::$tempDir = $tempDir;    }    /**     * Returns path to temporary directory.     *     * @since 0.12.0     *     * @return string     */    public static function getTempDir()    {        if (!empty(self::$tempDir)) {            $tempDir = self::$tempDir;        } else {            $tempDir = sys_get_temp_dir();        }        return $tempDir;    }    /**     * @since 0.13.0     *     * @return bool     */    public static function isOutputEscapingEnabled()    {        return self::$outputEscapingEnabled;    }    /**     * @since 0.13.0     *     * @param bool $outputEscapingEnabled     */    public static function setOutputEscapingEnabled($outputEscapingEnabled)    {        self::$outputEscapingEnabled = $outputEscapingEnabled;    }    /**     * Get default font name     *     * @return string     */    public static function getDefaultFontName()    {        return self::$defaultFontName;    }    /**     * Set default font name     *     * @param string $value     * @return bool     */    public static function setDefaultFontName($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultFontName = $value;            return true;        }        return false;    }    /**     * Get default font size     *     * @return int     */    public static function getDefaultFontSize()    {        return self::$defaultFontSize;    }    /**     * Set default font size     *     * @param int $value     * @return bool     */    public static function setDefaultFontSize($value)    {        $value = (int) $value;        if ($value > 0) {            self::$defaultFontSize = $value;            return true;        }        return false;    }    /**     * Load setting from phpword.yml or phpword.yml.dist     *     * @param string $filename     * @return array     */    public static function loadConfig($filename = null)    {        // Get config file        $configFile = null;        $configPath = __DIR__ . '/../../';        if ($filename !== null) {            $files = array($filename);        } else {            $files = array(""{$configPath}phpword.ini"", ""{$configPath}phpword.ini.dist"");        }        foreach ($files as $file) {            if (file_exists($file)) {                $configFile = realpath($file);                break;            }        }        // Parse config file        $config = array();        if ($configFile !== null) {            $config = @parse_ini_file($configFile);            if ($config === false) {                return $config;            }        }        // Set config value        foreach ($config as $key => $value) {            $method = ""set{$key}"";            if (method_exists(__CLASS__, $method)) {                self::$method($value);            }        }        return $config;    }    /**     * Get default paper     *     * @return string     */    public static function getDefaultPaper()    {        return self::$defaultPaper;    }    /**     * Set default paper     *     * @param string $value     * @return bool     */    public static function setDefaultPaper($value)    {        if (is_string($value) && trim($value) !== '') {            self::$defaultPaper = $value;            return true;        }        return false;    }    /**     * Return the compatibility option used by the XMLWriter     *     * @deprecated 0.10.0     *     * @codeCoverageIgnore     */    public static function getCompatibility()    {        return self::hasCompatibility();    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
204,Intervention_image_Driver_580, Returns clone of given core\n\n @return mixed\n,Vraća klon datog jezgra ,"    public function cloneCore($core)    {        $width = imagesx($core);        $height = imagesy($core);        $clone = imagecreatetruecolor($width, $height);        imagealphablending($clone, false);        imagesavealpha($clone, true);        $transparency = imagecolorallocatealpha($clone, 0, 0, 0, 127);        imagefill($clone, 0, 0, $transparency);                imagecopy($clone, $core, 0, 0, 0, 0, $width, $height);        return $clone;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
205,phalcon_cphalcon_Safe_179, Generate all the files in the output directory\n,Generišite sve datoteke u izlaznom direktorijumu,"    protected function generateFiles()    {        $includedHeaderFiles = $this->phalconH->generate();        $this->phalconC->generate($includedHeaderFiles);        $this->configM4->generate();        $this->configW32->generate();        copy($this->sourceDir . '/php_phalcon.h', $this->outputDir . '/php_phalcon.h');        $this->processKernelGlobals();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
206,symfony_http-foundation_BinaryFileResponse_8747, BinaryFileResponse represents an HTTP response delivering a file.\n\n @author Niklas Fiekas <niklas.fiekas@tu-clausthal.de>\n @author stealth35 <stealth35-php@live.fr>\n @author Igor Wiedler <igor@wiedler.ch>\n @author Jordan Alliot <jordan.alliot@gmail.com>\n @author Sergey Linnik <linniksa@gmail.com>\n,BinariFileResponse predstavlja HTTP odgovor,"class BinaryFileResponse extends Response{    protected static $trustXSendfileTypeHeader = false;    /**     * @var File     */    protected $file;    protected $offset = 0;    protected $maxlen = -1;    protected $deleteFileAfterSend = false;    /**     * @param \SplFileInfo|string $file               The file to stream     * @param int                 $status             The response status code     * @param array               $headers            An array of response headers     * @param bool                $public             Files are public by default     * @param string|null         $contentDisposition The type of Content-Disposition to set automatically with the filename     * @param bool                $autoEtag           Whether the ETag header should be automatically set     * @param bool                $autoLastModified   Whether the Last-Modified header should be automatically set     */    public function __construct($file, int $status = 200, array $headers = [], bool $public = true, string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)    {        parent::__construct(null, $status, $headers);        $this->setFile($file, $contentDisposition, $autoEtag, $autoLastModified);        if ($public) {            $this->setPublic();        }    }    /**     * @param \SplFileInfo|string $file               The file to stream     * @param int                 $status             The response status code     * @param array               $headers            An array of response headers     * @param bool                $public             Files are public by default     * @param string|null         $contentDisposition The type of Content-Disposition to set automatically with the filename     * @param bool                $autoEtag           Whether the ETag header should be automatically set     * @param bool                $autoLastModified   Whether the Last-Modified header should be automatically set     *     * @return static     *     * @deprecated since Symfony 5.2, use __construct() instead.     */    public static function create($file = null, int $status = 200, array $headers = [], bool $public = true, string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)    {        trigger_deprecation('symfony/http-foundation', '5.2', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($file, $status, $headers, $public, $contentDisposition, $autoEtag, $autoLastModified);    }    /**     * Sets the file to stream.     *     * @param \SplFileInfo|string $file The file to stream     *     * @return $this     *     * @throws FileException     */    public function setFile($file, string $contentDisposition = null, bool $autoEtag = false, bool $autoLastModified = true)    {        if (!$file instanceof File) {            if ($file instanceof \SplFileInfo) {                $file = new File($file->getPathname());            } else {                $file = new File((string) $file);            }        }        if (!$file->isReadable()) {            throw new FileException('File must be readable.');        }        $this->file = $file;        if ($autoEtag) {            $this->setAutoEtag();        }        if ($autoLastModified) {            $this->setAutoLastModified();        }        if ($contentDisposition) {            $this->setContentDisposition($contentDisposition);        }        return $this;    }    /**     * Gets the file.     *     * @return File The file to stream     */    public function getFile()    {        return $this->file;    }    /**     * Automatically sets the Last-Modified header according the file modification date.     */    public function setAutoLastModified()    {        $this->setLastModified(\DateTime::createFromFormat('U', $this->file->getMTime()));        return $this;    }    /**     * Automatically sets the ETag header according to the checksum of the file.     */    public function setAutoEtag()    {        $this->setEtag(base64_encode(hash_file('sha256', $this->file->getPathname(), true)));        return $this;    }    /**     * Sets the Content-Disposition header with the given filename.     *     * @param string $disposition      ResponseHeaderBag::DISPOSITION_INLINE or ResponseHeaderBag::DISPOSITION_ATTACHMENT     * @param string $filename         Optionally use this UTF-8 encoded filename instead of the real name of the file     * @param string $filenameFallback A fallback filename, containing only ASCII characters. Defaults to an automatically encoded filename     *     * @return $this     */    public function setContentDisposition(string $disposition, string $filename = '', string $filenameFallback = '')    {        if ('' === $filename) {            $filename = $this->file->getFilename();        }        if ('' === $filenameFallback && (!preg_match('/^[\x20-\x7e]*$/', $filename) || false !== strpos($filename, '%'))) {            $encoding = mb_detect_encoding($filename, null, true) ?: '8bit';            for ($i = 0, $filenameLength = mb_strlen($filename, $encoding); $i < $filenameLength; ++$i) {                $char = mb_substr($filename, $i, 1, $encoding);                if ('%' === $char || \ord($char) < 32 || \ord($char) > 126) {                    $filenameFallback .= '_';                } else {                    $filenameFallback .= $char;                }            }        }        $dispositionHeader = $this->headers->makeDisposition($disposition, $filename, $filenameFallback);        $this->headers->set('Content-Disposition', $dispositionHeader);        return $this;    }    /**     * {@inheritdoc}     */    public function prepare(Request $request)    {        if (!$this->headers->has('Content-Type')) {            $this->headers->set('Content-Type', $this->file->getMimeType() ?: 'application/octet-stream');        }        if ('HTTP/1.0' !== $request->server->get('SERVER_PROTOCOL')) {            $this->setProtocolVersion('1.1');        }        $this->ensureIEOverSSLCompatibility($request);        $this->offset = 0;        $this->maxlen = -1;        if (false === $fileSize = $this->file->getSize()) {            return $this;        }        $this->headers->set('Content-Length', $fileSize);        if (!$this->headers->has('Accept-Ranges')) {            // Only accept ranges on safe HTTP methods            $this->headers->set('Accept-Ranges', $request->isMethodSafe() ? 'bytes' : 'none');        }        if (self::$trustXSendfileTypeHeader && $request->headers->has('X-Sendfile-Type')) {            // Use X-Sendfile, do not send any content.            $type = $request->headers->get('X-Sendfile-Type');            $path = $this->file->getRealPath();            // Fall back to scheme://path for stream wrapped locations.            if (false === $path) {                $path = $this->file->getPathname();            }            if ('x-accel-redirect' === strtolower($type)) {                // Do X-Accel-Mapping substitutions.                // @link https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/#x-accel-redirect                $parts = HeaderUtils::split($request->headers->get('X-Accel-Mapping', ''), ',=');                foreach ($parts as $part) {                    [$pathPrefix, $location] = $part;                    if (substr($path, 0, \strlen($pathPrefix)) === $pathPrefix) {                        $path = $location.substr($path, \strlen($pathPrefix));                        // Only set X-Accel-Redirect header if a valid URI can be produced                        // as nginx does not serve arbitrary file paths.                        $this->headers->set($type, $path);                        $this->maxlen = 0;                        break;                    }                }            } else {                $this->headers->set($type, $path);                $this->maxlen = 0;            }        } elseif ($request->headers->has('Range') && $request->isMethod('GET')) {            // Process the range headers.            if (!$request->headers->has('If-Range') || $this->hasValidIfRangeHeader($request->headers->get('If-Range'))) {                $range = $request->headers->get('Range');                if (0 === strpos($range, 'bytes=')) {                    [$start, $end] = explode('-', substr($range, 6), 2) + [0];                    $end = ('' === $end) ? $fileSize - 1 : (int) $end;                    if ('' === $start) {                        $start = $fileSize - $end;                        $end = $fileSize - 1;                    } else {                        $start = (int) $start;                    }                    if ($start <= $end) {                        $end = min($end, $fileSize - 1);                        if ($start < 0 || $start > $end) {                            $this->setStatusCode(416);                            $this->headers->set('Content-Range', sprintf('bytes */%s', $fileSize));                        } elseif ($end - $start < $fileSize - 1) {                            $this->maxlen = $end < $fileSize ? $end - $start + 1 : -1;                            $this->offset = $start;                            $this->setStatusCode(206);                            $this->headers->set('Content-Range', sprintf('bytes %s-%s/%s', $start, $end, $fileSize));                            $this->headers->set('Content-Length', $end - $start + 1);                        }                    }                }            }        }        return $this;    }    private function hasValidIfRangeHeader(?string $header): bool    {        if ($this->getEtag() === $header) {            return true;        }        if (null === $lastModified = $this->getLastModified()) {            return false;        }        return $lastModified->format('D, d M Y H:i:s').' GMT' === $header;    }    /**     * Sends the file.     *     * {@inheritdoc}     */    public function sendContent()    {        if (!$this->isSuccessful()) {            return parent::sendContent();        }        if (0 === $this->maxlen) {            return $this;        }        $out = fopen('php://output', 'w');        $file = fopen($this->file->getPathname(), 'r');        stream_copy_to_stream($file, $out, $this->maxlen, $this->offset);        fclose($out);        fclose($file);        if ($this->deleteFileAfterSend && is_file($this->file->getPathname())) {            unlink($this->file->getPathname());        }        return $this;    }    /**     * {@inheritdoc}     *     * @throws \LogicException when the content is not null     */    public function setContent(?string $content)    {        if (null !== $content) {            throw new \LogicException('The content cannot be set on a BinaryFileResponse instance.');        }        return $this;    }    /**     * {@inheritdoc}     */    public function getContent()    {        return false;    }    /**     * Trust X-Sendfile-Type header.     */    public static function trustXSendfileTypeHeader()    {        self::$trustXSendfileTypeHeader = true;    }    /**     * If this is set to true, the file will be unlinked after the request is sent     * Note: If the X-Sendfile header is used, the deleteFileAfterSend setting will not be used.     *     * @return $this     */    public function deleteFileAfterSend(bool $shouldDelete = true)    {        $this->deleteFileAfterSend = $shouldDelete;        return $this;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
207,symfony_http-foundation_Response_8916, Clones the current Response instance.\n,Klonira trenutnu instancu odgovora,"    public function sendHeaders()    {        // headers have already been sent by the developer        if (headers_sent()) {            return $this;        }        // headers        foreach ($this->headers->allPreserveCaseWithoutCookies() as $name => $values) {            $replace = 0 === strcasecmp($name, 'Content-Type');            foreach ($values as $value) {                header($name.': '.$value, $replace, $this->statusCode);            }        }        // cookies        foreach ($this->headers->getCookies() as $cookie) {            header('Set-Cookie: '.$cookie, false, $this->statusCode);        }        // status        header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText), true, $this->statusCode);        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
208,symfony_http-foundation_ResponseHeaderBag_8965, ResponseHeaderBag is a container for Response HTTP headers.\n\n @author Fabien Potencier <fabien@symfony.com>\n,ResponseHeaderBag je kontejner za odgovor HTTP zaglavlja,"class ResponseHeaderBag extends HeaderBag{    public const COOKIES_FLAT = 'flat';    public const COOKIES_ARRAY = 'array';    public const DISPOSITION_ATTACHMENT = 'attachment';    public const DISPOSITION_INLINE = 'inline';    protected $computedCacheControl = [];    protected $cookies = [];    protected $headerNames = [];    public function __construct(array $headers = [])    {        parent::__construct($headers);        if (!isset($this->headers['cache-control'])) {            $this->set('Cache-Control', '');        }        /* RFC2616 - 14.18 says all Responses need to have a Date */        if (!isset($this->headers['date'])) {            $this->initDate();        }    }    /**     * Returns the headers, with original capitalizations.     *     * @return array An array of headers     */    public function allPreserveCase()    {        $headers = [];        foreach ($this->all() as $name => $value) {            $headers[$this->headerNames[$name] ?? $name] = $value;        }        return $headers;    }    public function allPreserveCaseWithoutCookies()    {        $headers = $this->allPreserveCase();        if (isset($this->headerNames['set-cookie'])) {            unset($headers[$this->headerNames['set-cookie']]);        }        return $headers;    }    /**     * {@inheritdoc}     */    public function replace(array $headers = [])    {        $this->headerNames = [];        parent::replace($headers);        if (!isset($this->headers['cache-control'])) {            $this->set('Cache-Control', '');        }        if (!isset($this->headers['date'])) {            $this->initDate();        }    }    /**     * {@inheritdoc}     */    public function all(string $key = null)    {        $headers = parent::all();        if (null !== $key) {            $key = strtr($key, self::UPPER, self::LOWER);            return 'set-cookie' !== $key ? $headers[$key] ?? [] : array_map('strval', $this->getCookies());        }        foreach ($this->getCookies() as $cookie) {            $headers['set-cookie'][] = (string) $cookie;        }        return $headers;    }    /**     * {@inheritdoc}     */    public function set(string $key, $values, bool $replace = true)    {        $uniqueKey = strtr($key, self::UPPER, self::LOWER);        if ('set-cookie' === $uniqueKey) {            if ($replace) {                $this->cookies = [];            }            foreach ((array) $values as $cookie) {                $this->setCookie(Cookie::fromString($cookie));            }            $this->headerNames[$uniqueKey] = $key;            return;        }        $this->headerNames[$uniqueKey] = $key;        parent::set($key, $values, $replace);        // ensure the cache-control header has sensible defaults        if (\in_array($uniqueKey, ['cache-control', 'etag', 'last-modified', 'expires'], true) && '' !== $computed = $this->computeCacheControlValue()) {            $this->headers['cache-control'] = [$computed];            $this->headerNames['cache-control'] = 'Cache-Control';            $this->computedCacheControl = $this->parseCacheControl($computed);        }    }    /**     * {@inheritdoc}     */    public function remove(string $key)    {        $uniqueKey = strtr($key, self::UPPER, self::LOWER);        unset($this->headerNames[$uniqueKey]);        if ('set-cookie' === $uniqueKey) {            $this->cookies = [];            return;        }        parent::remove($key);        if ('cache-control' === $uniqueKey) {            $this->computedCacheControl = [];        }        if ('date' === $uniqueKey) {            $this->initDate();        }    }    /**     * {@inheritdoc}     */    public function hasCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->computedCacheControl);    }    /**     * {@inheritdoc}     */    public function getCacheControlDirective(string $key)    {        return \array_key_exists($key, $this->computedCacheControl) ? $this->computedCacheControl[$key] : null;    }    public function setCookie(Cookie $cookie)    {        $this->cookies[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie;        $this->headerNames['set-cookie'] = 'Set-Cookie';    }    /**     * Removes a cookie from the array, but does not unset it in the browser.     */    public function removeCookie(string $name, ?string $path = '/', string $domain = null)    {        if (null === $path) {            $path = '/';        }        unset($this->cookies[$domain][$path][$name]);        if (empty($this->cookies[$domain][$path])) {            unset($this->cookies[$domain][$path]);            if (empty($this->cookies[$domain])) {                unset($this->cookies[$domain]);            }        }        if (empty($this->cookies)) {            unset($this->headerNames['set-cookie']);        }    }    /**     * Returns an array with all cookies.     *     * @return Cookie[]     *     * @throws \InvalidArgumentException When the $format is invalid     */    public function getCookies(string $format = self::COOKIES_FLAT)    {        if (!\in_array($format, [self::COOKIES_FLAT, self::COOKIES_ARRAY])) {            throw new \InvalidArgumentException(sprintf('Format ""%s"" invalid (%s).', $format, implode(', ', [self::COOKIES_FLAT, self::COOKIES_ARRAY])));        }        if (self::COOKIES_ARRAY === $format) {            return $this->cookies;        }        $flattenedCookies = [];        foreach ($this->cookies as $path) {            foreach ($path as $cookies) {                foreach ($cookies as $cookie) {                    $flattenedCookies[] = $cookie;                }            }        }        return $flattenedCookies;    }    /**     * Clears a cookie in the browser.     */    public function clearCookie(string $name, ?string $path = '/', string $domain = null, bool $secure = false, bool $httpOnly = true, string $sameSite = null)    {        $this->setCookie(new Cookie($name, null, 1, $path, $domain, $secure, $httpOnly, false, $sameSite));    }    /**     * @see HeaderUtils::makeDisposition()     */    public function makeDisposition(string $disposition, string $filename, string $filenameFallback = '')    {        return HeaderUtils::makeDisposition($disposition, $filename, $filenameFallback);    }    /**     * Returns the calculated value of the cache-control header.     *     * This considers several other headers and calculates or modifies the     * cache-control header to a sensible, conservative value.     *     * @return string     */    protected function computeCacheControlValue()    {        if (!$this->cacheControl) {            if ($this->has('Last-Modified') || $this->has('Expires')) {                return 'private, must-revalidate'; // allows for heuristic expiration (RFC 7234 Section 4.2.2) in the case of ""Last-Modified""            }            // conservative by default            return 'no-cache, private';        }        $header = $this->getCacheControlHeader();        if (isset($this->cacheControl['public']) || isset($this->cacheControl['private'])) {            return $header;        }        // public if s-maxage is defined, private otherwise        if (!isset($this->cacheControl['s-maxage'])) {            return $header.', private';        }        return $header;    }    private function initDate(): void    {        $this->set('Date', gmdate('D, d M Y H:i:s').' GMT');    }}",0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
209,botman_botman_BotMan_1288, Return a random message.\n @param array $messages\n @return $this\n,Vrati nasumičnu poruku,    public function randomReply(array $messages)    {        return $this->reply($messages[array_rand($messages)]);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
210,typecho_typecho_HyperDown_1372, parseShtml\n\n @param array $lines\n @param mixed $value\n @param int $start\n @return string\n,Parsira html,"    private function parseSh(array $lines, $num, $start, $end)    {        $line = $this->markLine($start, $end) . $this->parseInline(trim($lines[0], '# '));        return preg_match(""/^\s*$/"", $line) ? '' : ""<h{$num}>{$line}</h{$num}>"";    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
211,typecho_typecho_HyperDown_1375, parseMh\\n\\n @param array $lines\\n @param int $num\\n @param int $start\\n @param int $end\\n @return string\\n,parseMh,"    private function parseList(array $lines, $value, $start)    {        $html = '';        list($space, $type, $tab) = $value;        $rows = array();        $suffix = '';        $last = 0;        foreach ($lines as $key => $line) {            if (preg_match(""/^(\s{"" . $space . ""})((?:[0-9]+\.?)|\-|\+|\*)(\s+)(.*)$/i"", $line, $matches)) {                if ($type == 'ol' && $key == 0) {                    $start = intval($matches[2]);                    if ($start != 1) {                        $suffix = ' start=""' . $start . '""';                    }                }                $rows[] = [$matches[4]];                $last = count($rows) - 1;            } else {                $rows[$last][] = preg_replace(""/^\s{"" . ($tab + $space) . ""}/"", '', $line);            }        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
212,magento_magento2_Archive_2845, Class to work with archives\n\n @author      Magento Core Team <core@magentocommerce.com>\n,Klasa za rad sa arhivama,"class Archive{    /**     * Archiver is used for compress.     */    const DEFAULT_ARCHIVER = 'gz';    /**     * Default packer for directory.     */    const TAPE_ARCHIVER = 'tar';    /**     * Current archiver is used for compress.     *     * @var \Magento\Framework\Archive\Tar|\Magento\Framework\Archive\Gz|\Magento\Framework\Archive\Bz     */    protected $_archiver = null;    /**     * Accessible formats for compress.     *     * @var array     */    protected $_formats = [        'tar' => 'tar',        'gz' => 'gz',        'gzip' => 'gz',        'tgz' => 'tar.gz',        'tgzip' => 'tar.gz',        'bz' => 'bz',        'bzip' => 'bz',        'bzip2' => 'bz',        'bz2' => 'bz',        'tbz' => 'tar.bz',        'tbzip' => 'tar.bz',        'tbz2' => 'tar.bz',        'tbzip2' => 'tar.bz',    ];    /**     * Create object of current archiver by $extension.     *     * @param string $extension     * @return Tar|Gz|Bz     */    protected function _getArchiver($extension)    {        $extension = strtolower($extension);        $format = isset($this->_formats[$extension]) ? $this->_formats[$extension] : self::DEFAULT_ARCHIVER;        $class = '\\Magento\Framework\Archive\\' . ucfirst($format);        $this->_archiver = new $class();        return $this->_archiver;    }    /**     * Split current format to list of archivers.     *     * @param string $source     * @return string[]|string     */    protected function _getArchivers($source)    {        $ext = pathinfo($source, PATHINFO_EXTENSION);        if (!empty($this->_formats[$ext])) {            return explode('.', $this->_formats[$ext]);        }        return [];    }    /**     * Pack file or directory to archivers are parsed from extension.     *     * @param string $source     * @param string $destination     * @param boolean $skipRoot skip first level parent     * @return string Path to file     */    public function pack($source, $destination = 'packed.tgz', $skipRoot = false)    {        $archivers = $this->_getArchivers($destination);        $interimSource = '';        for ($i = 0, $count = count($archivers); $i < $count; $i++) {            if ($i == $count - 1) {                $packed = $destination;            } else {                $packed = dirname($destination) . '/~tmp-' . microtime(true) . $archivers[$i] . '.' . $archivers[$i];            }            $source = $this->_getArchiver($archivers[$i])->pack($source, $packed, $skipRoot);            if ($interimSource && $i < $count) {                unlink($interimSource);            }            $interimSource = $source;        }        return $source;    }    /**     * Unpack file from archivers are parsed from extension.     * If $tillTar == true unpack file from archivers till     * meet TAR archiver.     *     * @param string $source     * @param string $destination     * @param bool $tillTar     * @param bool $clearInterm     * @return string Path to file     */    public function unpack($source, $destination = '.', $tillTar = false, $clearInterm = true)    {        $archivers = $this->_getArchivers($source);        $interimSource = '';        for ($i = count($archivers) - 1; $i >= 0; $i--) {            if ($tillTar && $archivers[$i] == self::TAPE_ARCHIVER) {                break;            }            if ($i == 0) {                $packed = rtrim($destination, '/') . '/';            } else {                $packed = rtrim(                    $destination,                    '/'                ) . '/~tmp-' . microtime(                    true                ) . $archivers[$i - 1] . '.' . $archivers[$i - 1];            }            $source = $this->_getArchiver($archivers[$i])->unpack($source, $packed);            if ($clearInterm && $interimSource && $i >= 0) {                unlink($interimSource);            }            $interimSource = $source;        }        return $source;    }    /**     * Extract one file from TAR (Tape Archiver).     *     * @param string $file     * @param string $source     * @param string $destination     * @return string Path to file     */    public function extract($file, $source, $destination = '.')    {        $tarFile = $this->unpack($source, $destination, true);        $resFile = $this->_getArchiver(self::TAPE_ARCHIVER)->extract($file, $tarFile, $destination);        if (!$this->isTar($source)) {            unlink($tarFile);        }        return $resFile;    }    /**     * Check file is archive.     *     * @param string $file     * @return boolean     */    public function isArchive($file)    {        $archivers = $this->_getArchivers($file);        if (count($archivers)) {            return true;        }        return false;    }    /**     * Check file is TAR.     *     * @param string $file     * @return boolean     */    public function isTar($file)    {        $archivers = $this->_getArchivers($file);        if (count($archivers) == 1 && $archivers[0] == self::TAPE_ARCHIVER) {            return true;        }        return false;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
213,swiftmailer_swiftmailer_IdenticalBinaryConstraint_2134, A binary safe string comparison.\n\n @author Chris Corbyn\n,Binarno sigurno poređenje nizova,"class IdenticalBinaryConstraint extends \PHPUnit\Framework\Constraint\Constraint{    protected $value;    public function __construct($value)    {        $this->value = $value;    }    /**     * Evaluates the constraint for parameter $other. Returns TRUE if the     * constraint is met, FALSE otherwise.     *     * @param mixed $other value or object to evaluate     */    public function matches($other): bool    {        $aHex = $this->asHexString($this->value);        $bHex = $this->asHexString($other);        return $aHex === $bHex;    }    /**     * Returns a string representation of the constraint.     */    public function toString(): string    {        return 'identical binary';    }    /**     * Get the given string of bytes as a stirng of Hexadecimal sequences.     *     * @param string $binary     *     * @return string     */    private function asHexString($binary)    {        $hex = '';        $bytes = unpack('H*', $binary);        foreach ($bytes as &$byte) {            $byte = strtoupper($byte);        }        return implode('', $bytes);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
214,swiftmailer_swiftmailer_IdenticalBinaryConstraint_239, Get the given string of bytes as a stirng of Hexadecimal sequences.\\n\\n @param string $binary\\n\\n @return string\\n,Dohvata dati niz bajtova kao string heksadecimalnih sekvenci,"    private function asHexString($binary)    {        $hex = '';        $bytes = unpack('H*', $binary);        foreach ($bytes as &$byte) {            $byte = strtoupper($byte);        }        return implode('', $bytes);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
215,predis_predis_Autoloader_2121, Loads a class from a file using its fully qualified name.\\n\\n @param string $className Fully qualified name of a class.\\n,Učitava klasu iz datoteke koristeći potpuno kvalifikovano ime,"    public function autoload($className)    {        if (0 === strpos($className, $this->prefix)) {            $parts = explode('\\', substr($className, $this->prefixLength));            $filepath = $this->directory.DIRECTORY_SEPARATOR.implode(DIRECTORY_SEPARATOR, $parts).'.php';            if (is_file($filepath)) {                require $filepath;            }        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
216,squizlabs_PHP_CodeSniffer_File_918, Constructs a file.\\n\\n @param string                   $path    The absolute path to the file to process.\\n @param \\\\PHP_CodeSniffer\\\\Ruleset $ruleset The ruleset used for the run.\\n @param \\\\PHP_CodeSniffer\\\\Config  $config  The config data for the run.\\n\\n @return void\\n,Izrađuje datoteku,"    public function __construct($path, Ruleset $ruleset, Config $config)    {        $this->path    = $path;        $this->ruleset = $ruleset;        $this->config  = $config;        $this->fixer   = new Fixer();        $parts     = explode('.', $path);        $extension = array_pop($parts);        if (isset($config->extensions[$extension]) === true) {            $this->tokenizerType = $config->extensions[$extension];        } else {            // Revert to default.            $this->tokenizerType = 'PHP';        }        $this->configCache['cache']           = $this->config->cache;        $this->configCache['sniffs']          = array_map('strtolower', $this->config->sniffs);        $this->configCache['exclude']         = array_map('strtolower', $this->config->exclude);        $this->configCache['errorSeverity']   = $this->config->errorSeverity;        $this->configCache['warningSeverity'] = $this->config->warningSeverity;        $this->configCache['recordErrors']    = $this->config->recordErrors;        $this->configCache['ignorePatterns']  = $this->ruleset->ignorePatterns;        $this->configCache['includePatterns'] = $this->ruleset->includePatterns;    }//end __construct()",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
217,symfony_http-foundation_AcceptHeader_9679," Returns given value's item, if exists.\n\n @return AcceptHeaderItem|null\n",Vraća stavku date vrednosti ako postoji,"    public function get(string $value)    {        return $this->items[$value] ?? $this->items[explode('/', $value)[0].'/*'] ?? $this->items['*/*'] ?? $this->items['*'] ?? null;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
218,symfony_http-foundation_Request_9843," Returns the prefix as encoded in the string when the string starts with\n the given prefix, null otherwise.\n","Vraća prefiks kodiran u stingu kada niz započinje sa datim prefiksom, u suprotnom ništa","    private function getUrlencodedPrefix(string $string, string $prefix): ?string    {        if (0 !== strpos(rawurldecode($string), $prefix)) {            return null;        }        $len = \strlen($prefix);        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {            return $match[0];        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
219,php-pm_php-pm_RequestHandler_1651, Checks whether the end of the header is in $buffer.\\\\n\\\\n @param string $buffer\\\\n\\\\n @return bool\\\\n,Proverava da li je kraj zaglavlja u $baffer,"    protected function isHeaderEnd($buffer)    {        return false !== \strpos($buffer, ""\r\n\r\n"");    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
220,PHPOffice_PHPWord_TemplateProcessor_966, Find the nearest block end position after $offset\n\n @param int $offset    Search position\n @param string  $blockType XML Block tag\n @return int -1 if block end not found\n,Pronađite najbliži krajnji položaj bloka nakon $offset,"    protected function findXmlBlockEnd($offset, $blockType)    {        $blockEndStart = strpos($this->tempDocumentMainPart, '</' . $blockType . '>', $offset);        // return position of end of tag if found, otherwise -1        return ($blockEndStart === false) ? -1 : $blockEndStart + 3 + strlen($blockType);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
221,symfony_http-foundation_IpUtils_8805," Compares two IPv6 addresses.\n In case a subnet is given, it checks if it contains the request IP.\n\n @author David Soria Parra <dsp at php dot net>\n\n @see https://github.com/dsp/v6tools\n\n @param string $ip IPv6 address or subnet in CIDR notation\n\n @return bool Whether the IP is valid\n\n @throws \\RuntimeException When IPV6 support is not enabled\n","Poredi dve IPv6 adrese. U slučaju davanja podmreže, ona proverava da li sadrži IP zahtev","    public static function checkIp6(?string $requestIp, string $ip)    {        $cacheKey = $requestIp.'-'.$ip;        if (isset(self::$checkedIps[$cacheKey])) {            return self::$checkedIps[$cacheKey];        }        if (!((\extension_loaded('sockets') && \defined('AF_INET6')) || @inet_pton('::1'))) {            throw new \RuntimeException('Unable to check Ipv6. Check that PHP was not compiled with option ""disable-ipv6"".');        }        if (false !== strpos($ip, '/')) {            [$address, $netmask] = explode('/', $ip, 2);            if ('0' === $netmask) {                return (bool) unpack('n*', @inet_pton($address));            }            if ($netmask < 1 || $netmask > 128) {                return self::$checkedIps[$cacheKey] = false;            }        } else {            $address = $ip;            $netmask = 128;        }        $bytesAddr = unpack('n*', @inet_pton($address));        $bytesTest = unpack('n*', @inet_pton($requestIp));        if (!$bytesAddr || !$bytesTest) {            return self::$checkedIps[$cacheKey] = false;        }        for ($i = 1, $ceil = ceil($netmask / 16); $i <= $ceil; ++$i) {            $left = $netmask - 16 * ($i - 1);            $left = ($left <= 16) ? $left : 16;            $mask = ~(0xffff >> $left) & 0xffff;            if (($bytesAddr[$i] & $mask) != ($bytesTest[$i] & $mask)) {                return self::$checkedIps[$cacheKey] = false;            }        }        return self::$checkedIps[$cacheKey] = true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
222,markrogoyski_math-php_ChiSquared_3079, Median - closed form approximation\n\n             /    2 \\Â³\n median â‰ˆ k | 1 - -  |\n             \\    k /\n\n @return float\n,Medijana - aproksimacija zatvorenog oblika,    public function median(): float    {        $k          = $this->k;        $âŸ®1Â âˆ’Â 2ï¼9kâŸ¯ = 1 - (2 / (9 * $k));        return $k * $âŸ®1Â âˆ’Â 2ï¼9kâŸ¯ ** 3;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0
223,symfony_http-kernel_CacheWarmer_3109, Abstract cache warmer that knows how to write a file to the cache.\n\n @author Fabien Potencier <fabien@symfony.com>\n,Apstraktni grejač keš memorije koji zna kako da upiše datoteku u keš memoriju,class ChainCacheClearer implements CacheClearerInterface{    private $clearers;    public function __construct(iterable $clearers = [])    {        $this->clearers = $clearers;    }    /**     * {@inheritdoc}     */    public function clear(string $cacheDir)    {        foreach ($this->clearers as $clearer) {            $clearer->clear($cacheDir);        }    }},0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0
224,googleapis_google-api-php-client_Verify_673, Retrieve and cache a certificates file.\n\n @param $url string location\n @throws \\Google\\Exception\n @return array certificates\n,Preuzmite i keširajte datoteku sertifikata,"  private function retrieveCertsFromLocation($url)  {    // If we're retrieving a local file, just grab it.    if (0 !== strpos($url, 'http')) {      if (!$file = file_get_contents($url)) {        throw new GoogleException(            ""Failed to retrieve verification certificates: '"" .            $url . ""'.""        );      }      return json_decode($file, true);    }    $response = $this->http->get($url);    if ($response->getStatusCode() == 200) {      return json_decode((string) $response->getBody(), true);    }    throw new GoogleException(        sprintf(            'Failed to retrieve verification certificates: ""%s"".',            $response->getBody()->getContents()        ),        $response->getStatusCode()    );  }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0
225,pagekit_pagekit_ExtensionTranslateCommand_894, Writes the translation file for the given extension.\n\n @param array  $messages\n @param string $extension\n @param string $path\n,Piše datoteku prevoda za datu ekstenziju,"    protected function writeTranslationFile($messages, $extension, $path)    {        foreach ($messages as $domain => $strings) {            $data = $this->getHeader($extension, $domain);            foreach ($strings as $string) {                $string = str_replace('""', '\""', $string);                $data .= ""msgid \"""".$string.""\""\nmsgstr \""\""\n\n"";            }            $refFile = $path.'/'.$domain.'.pot';            if (!file_exists($refFile) || !($compare = preg_replace('/^""POT-Creation-Date: (.*)$/im', '', [file_get_contents($refFile), $data]) and $compare[0] === $compare[1])) {                file_put_contents($refFile, $data);            }        }    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0
226,phalcon_cphalcon_Safe_1568, Resolves headers in the php_phalcon.h file\n,Rešava zaglavlja u php_phalcon,"    protected function processKernelGlobals()    {        $lines = [];        foreach (file($this->outputDir . '/php_phalcon.h') as $line) {            if (preg_match('@^#include ""(kernel/.+)""@', $line, $matches)) {                $content = file_get_contents($this->sourceDir . DIRECTORY_SEPARATOR . $matches[1]);                $lines[] = $content . PHP_EOL;            } else {                $lines[] = $line;            }        }        file_put_contents($this->outputDir . '/php_phalcon.h', join('', $lines));    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0
227,getgrav_grav_Composer_1482, Return the composer executable file path\\n\\n @return string\\n,Vrati putanju izvršne datoteke kompozera,"    public static function getComposerExecutor()    {        $executor = PHP_BINARY . ' ';        $composer = static::getComposerLocation();        if ($composer !== static::DEFAULT_PATH && is_executable($composer)) {            $file = fopen($composer, 'rb');            $firstLine = fgets($file);            fclose($file);            if (!preg_match('/^#!.+php/i', $firstLine)) {                $executor = '';            }        }        return $executor . $composer;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0
228,squizlabs_PHP_CodeSniffer_Runner_913," Processes a single file, including checking and fixing.\\n\\n @param \\\\PHP_CodeSniffer\\\\Files\\\\File $file The file to be processed.\\n\\n @return void\\n @throws \\\\PHP_CodeSniffer\\\\Exceptions\\\\DeepExitException\\n","Obrađuje jednu datoteku, uključujući proveru i popravljanje","    public function processFile($file)    {        if (PHP_CODESNIFFER_VERBOSITY > 0) {            $startTime = microtime(true);            echo 'Processing '.basename($file->path).' ';            if (PHP_CODESNIFFER_VERBOSITY > 1) {                echo PHP_EOL;            }        }        try {            $file->process();            if (PHP_CODESNIFFER_VERBOSITY > 0) {                $timeTaken = ((microtime(true) - $startTime) * 1000);                if ($timeTaken < 1000) {                    $timeTaken = round($timeTaken);                    echo ""DONE in {$timeTaken}ms"";                } else {                    $timeTaken = round(($timeTaken / 1000), 2);                    echo ""DONE in $timeTaken secs"";                }                if (PHP_CODESNIFFER_CBF === true) {                    $errors = $file->getFixableCount();                    echo "" ($errors fixable violations)"".PHP_EOL;                } else {                    $errors   = $file->getErrorCount();                    $warnings = $file->getWarningCount();                    echo "" ($errors errors, $warnings warnings)"".PHP_EOL;                }            }        } catch (\Exception $e) {            $error = 'An error occurred during processing; checking has been aborted. The error message was: '.$e->getMessage();            $file->addErrorOnLine($error, 1, 'Internal.Exception');        }//end try        $this->reporter->cacheFileReport($file, $this->config);        if ($this->config->interactive === true) {            /*                Running interactively.                Print the error report for the current file and then wait for user input.            */            // Get current violations and then clear the list to make sure            // we only print violations for a single file each time.            $numErrors = null;            while ($numErrors !== 0) {                $numErrors = ($file->getErrorCount() + $file->getWarningCount());                if ($numErrors === 0) {                    continue;                }                $this->reporter->printReport('full');                echo '<ENTER> to recheck, [s] to skip or [q] to quit : ';                $input = fgets(STDIN);                $input = trim($input);                switch ($input) {                case 's':                    break(2);                case 'q':                    throw new DeepExitException('', 0);                default:                    // Repopulate the sniffs because some of them save their state                    // and only clear it when the file changes, but we are rechecking                    // the same file.                    $file->ruleset->populateTokenListeners();                    $file->reloadContent();                    $file->process();                    $this->reporter->cacheFileReport($file, $this->config);                    break;                }            }//end while        }//end if        // Clean up the file to save (a lot of) memory.        $file->cleanUp();    }//end processFile()",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0
229,phacility_phabricator_Figlet_519, Function loads one character in the internal array from file\\n\\n @param resource &$fp handle of font file\\n\\n @return mixed lines of the character or false if foef occured\\n @access private\\n,Funkcija učitava jedan znak u unutrašnjem nizu iz datoteke,"    function _char(&$fp)    {        $out = array();        for ($i = 0; $i < $this->height; $i++) {            if (feof($fp)) {                return false;            }            $line = rtrim(fgets($fp, 2048), ""\r\n"");            if (preg_match('/(.){1,2}$/', $line, $r)) {                $line = str_replace($r[1], '', $line);            }            $line .= ""\x00"";            $out[] = $line;        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0
230,guzzle_guzzle_MessageFormatter_1408," Formats log messages using variable substitutions for requests, responses,\\n and other transactional data.\\n\\n The following variable substitutions are supported:\\n\\n - {request}:        Full HTTP request message\\n - {response}:       Full HTTP response message\\n - {ts}:             ISO 8601 date in GMT\\n - {date_iso_8601}   ISO 8601 date in GMT\\n - {date_common_log} Apache common log date using the configured timezone.\\n - {host}:           Host of the request\\n - {method}:         Method of the request\\n - {uri}:            URI of the request\\n - {version}:        Protocol version\\n - {target}:         Request target of the request (path + query + fragment)\\n - {hostname}:       Hostname of the machine that sent the request\\n - {code}:           Status code of the response (if available)\\n - {phrase}:         Reason phrase of the response  (if available)\\n - {error}:          Any error messages (if available)\\n - {req_header_ - {res_header_ - {req_headers}:    Request headers\\n - {res_headers}:    Response headers\\n - {req_body}:       Request body\\n - {res_body}:       Response body\\n\\n @final\\n","Formatira log poruke koristeći zamenu promenljivih za zahteve, odgovore, i druge podatke o transakcijama. Podržane su sledeće zamene promenljivih: \\ n \\ n - {zahtev}: Puna poruka HTTP zahteva \\ n - {response}: Potpuna HTTP poruka odgovora \\ n - {ts}: ISO 8601 datum u GMT \\ n - {date_iso_8601} ISO 8601 datum u GMT \\ n - {date_common_log} Apache zajednički datum evidencije pomoću konfigurisane vremenske zone. \\ n - {host}: Domaćin zahteva \\ n - {method}: Metod zahteva \\ n - {uri}: URI zahteva \\ n - {version}: Verzija protokola \\ n - {target}: Cilj zahteva (path + query + fragment) \\ n - {hostname}: Ime hosta mašine koja je poslala zahtev \\ n - {code}: Statusni odgovor odgovora (ako je dostupan) \ \ n - {phrase}: Fraza razloga odgovora (ako je dostupna) \\ n - {error}: Sve poruke o grešci (ako su dostupne) \\ n - {res_header_ - {res_header_ - {res_headers}: Zahtevanje zaglavlja \\ n - {res_headers}: Odgovor zaglavlja \\ n - {res_body}: Telo zahteva \\ n - {res_body}: Telo odgovora","class MessageFormatter implements MessageFormatterInterface{    /**     * Apache Common Log Format.     *     * @link https://httpd.apache.org/docs/2.4/logs.html#common     *     * @var string     */    public const CLF = ""{hostname} {req_header_User-Agent} - [{date_common_log}] \""{method} {target} HTTP/{version}\"" {code} {res_header_Content-Length}"";    public const DEBUG = "">>>>>>>>\n{request}\n<<<<<<<<\n{response}\n--------\n{error}"";    public const SHORT = '[{ts}] ""{method} {target} HTTP/{version}"" {code}';    /**     * @var string Template used to format log messages     */    private $template;    /**     * @param string $template Log message template     */    public function __construct(?string $template = self::CLF)    {        $this->template = $template ?: self::CLF;    }    /**     * Returns a formatted message string.     *     * @param RequestInterface       $request  Request that was sent     * @param ResponseInterface|null $response Response that was received     * @param \Throwable|null        $error    Exception that was received     */    public function format(RequestInterface $request, ?ResponseInterface $response = null, ?\Throwable $error = null): string    {        $cache = [];        /** @var string */        return \preg_replace_callback(            '/{\s*([A-Za-z_\-\.0-9]+)\s*}/',            function (array $matches) use ($request, $response, $error, &$cache) {                if (isset($cache[$matches[1]])) {                    return $cache[$matches[1]];                }                $result = '';                switch ($matches[1]) {                    case 'request':                        $result = Psr7\Message::toString($request);                        break;                    case 'response':                        $result = $response ? Psr7\Message::toString($response) : '';                        break;                    case 'req_headers':                        $result = \trim($request->getMethod()                                . ' ' . $request->getRequestTarget())                            . ' HTTP/' . $request->getProtocolVersion() . ""\r\n""                            . $this->headers($request);                        break;                    case 'res_headers':                        $result = $response ?                            \sprintf(                                'HTTP/%s %d %s',                                $response->getProtocolVersion(),                                $response->getStatusCode(),                                $response->getReasonPhrase()                            ) . ""\r\n"" . $this->headers($response)                            : 'NULL';                        break;                    case 'req_body':                        $result = $request->getBody()->__toString();                        break;                    case 'res_body':                        if (!$response instanceof ResponseInterface) {                            $result = 'NULL';                            break;                        }                        $body = $response->getBody();                        if (!$body->isSeekable()) {                            $result = 'RESPONSE_NOT_LOGGEABLE';                            break;                        }                        $result = $response->getBody()->__toString();                        break;                    case 'ts':                    case 'date_iso_8601':                        $result = \gmdate('c');                        break;                    case 'date_common_log':                        $result = \date('d/M/Y:H:i:s O');                        break;                    case 'method':                        $result = $request->getMethod();                        break;                    case 'version':                        $result = $request->getProtocolVersion();                        break;                    case 'uri':                    case 'url':                        $result = $request->getUri();                        break;                    case 'target':                        $result = $request->getRequestTarget();                        break;                    case 'req_version':                        $result = $request->getProtocolVersion();                        break;                    case 'res_version':                        $result = $response                            ? $response->getProtocolVersion()                            : 'NULL';                        break;                    case 'host':                        $result = $request->getHeaderLine('Host');                        break;                    case 'hostname':                        $result = \gethostname();                        break;                    case 'code':                        $result = $response ? $response->getStatusCode() : 'NULL';                        break;                    case 'phrase':                        $result = $response ? $response->getReasonPhrase() : 'NULL';                        break;                    case 'error':                        $result = $error ? $error->getMessage() : 'NULL';                        break;                    default:                        // handle prefixed dynamic headers                        if (\strpos($matches[1], 'req_header_') === 0) {                            $result = $request->getHeaderLine(\substr($matches[1], 11));                        } elseif (\strpos($matches[1], 'res_header_') === 0) {                            $result = $response                                ? $response->getHeaderLine(\substr($matches[1], 11))                                : 'NULL';                        }                }                $cache[$matches[1]] = $result;                return $result;            },            $this->template        );    }    /**     * Get headers from message as string     */    private function headers(MessageInterface $message): string    {        $result = '';        foreach ($message->getHeaders() as $name => $values) {            $result .= $name . ': ' . \implode(', ', $values) . ""\r\n"";        }        return \trim($result);    }}",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
231,markrogoyski_math-php_LeastSquares_3612," SStot - The total Sum Squares\n\n the sum, over all observations, of the squared differences of\n each observation from the overall mean.\n https://en.wikipedia.org/wiki/Total_sum_of_squares\n\n For Simple Linear Regression\n SStot = âˆ‘(yáµ¢ - È³)Â²\n\n For Regression through a point\n SStot = âˆ‘yáµ¢Â²\n\n @return float\n\n @throws Exception\\BadDataException\n",SStot - Ukupni kvadrati sume \ n \ n zbroj kvadratnih razlika \ n svakog posmatranja od ukupne srednje vrednosti za sva posmatranja. \ N https://en.wikipedia.org/wiki/Total_sum_of_squares\n\n Za jednostavnu linearnu regresiju\n SStot = âˆ‘(yáµ¢ - È³)Â²\n\n Za regresiju kroz tečku\n SStot = âˆ‘yáµ¢Â²\n\n ,    public function sumOfSquaresTotal(): float    {        return $this->sumOfSquaresResidual() + $this->sumOfSquaresRegression();    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
232,matomo-org_matomo_Archive_48," Queries and returns metric data in an array.\\n\\n If multiple sites were requested in {@link build()} or {@link factory()} the result will\\n be indexed by site ID.\\n\\n If multiple periods were requested in {@link build()} or {@link factory()} the result will\\n be indexed by period.\\n\\n The site ID index is always first, so if multiple sites & periods were requested, the result\\n will be indexed by site ID first, then period.\\n\\n @param string|array $names One or more archive names, eg, `'nb_visits'`, `'Referrers_distinctKeywords'`,\\n                            etc.\\n @return false|integer|array `false` if there is no data to return, a single numeric value if we're not querying\\n                             for multiple sites/periods, or an array if multiple sites, periods or names are\\n                             queried for.\\n","Pravi upite i vraća metričke podatke u nizu. Ako je u {@link build()} ili {@link factory()} zatraženo više veb lokacija, rezultat će biti indeksiran prema ID-u lokacije. Ako je u {@link build()} ili {@link factory()} zatraženo više tačaka, rezultat će biti indeksiran po tačkama. Indeks ID-a mesta je uvek prvi, pa ako je zatraženo više lokacija i perioda, rezultat će se prvo indeksirati pomoću ID-a lokacije, a zatim tačke","    public function getNumeric($names)    {        $data = $this->get($names, 'numeric');        $resultIndices = $this->getResultIndices();        $result = $data->getIndexedArray($resultIndices);        // if only one metric is returned, just return it as a numeric value        if (empty($resultIndices)            && count($result) <= 1            && (!is_array($names) || count($names) === 1)        ) {            $result = (float)reset($result); // convert to float in case $result is empty        }        return $result;    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
233,matomo-org_matomo_Archive_54, Gets the IDs of the archives we're querying for and stores them in $this->archives.\\n This function will launch the archiving process for each period/site/plugin if\\n metrics/reports have not been calculated/archived already.\\n\\n @param array $archiveGroups @see getArchiveGroupOfReport\\n @param array $plugins List of plugin names to archive.\\n,Dobija ID-ove arhiva za koje tražimo i skladišti ih u $this->archives. Ova funkcija će pokrenuti postupak arhiviranja za svaki period/site/plugin ako metrike/izveštaji nisu već izračunate/arhivirane,"    private function cacheArchiveIdsAfterLaunching($archiveGroups, $plugins)    {        $today = Date::today();        foreach ($this->params->getPeriods() as $period) {            $twoDaysBeforePeriod = $period->getDateStart()->subDay(2);            $twoDaysAfterPeriod = $period->getDateEnd()->addDay(2);            foreach ($this->params->getIdSites() as $idSite) {                $site = new Site($idSite);                if (Common::getRequestVar('skipArchiveSegmentToday', 0, 'int')                    && self::shouldSkipArchiveIfSkippingSegmentArchiveForToday($site, $period, $this->params->getSegment())                ) {                    Log::debug(""Skipping archive %s for %s as segment today is disabled"", $period->getLabel(), $period->getPrettyString());                    continue;                }                // if the END of the period is BEFORE the website creation date                // we already know there are no stats for this period                // we add one day to make sure we don't miss the day of the website creation                if ($twoDaysAfterPeriod->isEarlier($site->getCreationDate())) {                    Log::debug(""Archive site %s, %s (%s) skipped, archive is before the website was created."",                        $idSite, $period->getLabel(), $period->getPrettyString());                    continue;                }                // if the starting date is in the future we know there is no visiidsite = ?t                if ($twoDaysBeforePeriod->isLater($today)) {                    Log::debug(""Archive site %s, %s (%s) skipped, archive is after today."",                        $idSite, $period->getLabel(), $period->getPrettyString());                    continue;                }                $this->prepareArchive($archiveGroups, $site, $period);            }        }    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
234,matomo-org_matomo_Archive_788," Returns archive IDs for the sites, periods and archive names that are being\n queried. This function will use the idarchive cache if it has the right data,\n query archive tables for IDs w/o launching archiving, or launch archiving and\n get the idarchive from ArchiveProcessor instances.\n\n @param string $archiveNames\n @return array\n","Prikazuje ID-ove arhive za lokacije, periode i imena arhiva za koja se vrši upit. Ova funkcija će koristiti keširanje idarchive ako ima prave podatke, šalje upite ka arhiviranim tabelama za ID-ove bez pokretanja arhiviranja ili sa pokrenutanjem arhiviranja i dobijanja idarchive iz instanci ArchiveProcessor-a","    private function getArchiveIds($archiveNames)    {        $plugins = $this->getRequestedPlugins($archiveNames);        // figure out which archives haven't been processed (if an archive has been processed,        // then we have the archive IDs in $this->idarchives)        $doneFlags     = array();        $archiveGroups = array();        foreach (array_merge($plugins, ['all']) as $plugin) {            $doneFlag = $this->getDoneStringForPlugin($plugin, $this->params->getIdSites());            $doneFlags[$doneFlag] = true;            if (!isset($this->idarchives[$doneFlag])) {                $archiveGroup = $this->getArchiveGroupOfPlugin($plugin);                if ($archiveGroup === self::ARCHIVE_ALL_PLUGINS_FLAG) {                    $archiveGroup = reset($plugins);                }                $archiveGroups[] = $archiveGroup;            }            $doneFlag = Rules::getDoneFlagArchiveContainsOnePlugin($this->params->getSegment(), $plugin);            $doneFlags[$doneFlag] = true;        }        $globalDoneFlag = Rules::getDoneFlagArchiveContainsAllPlugins($this->params->getSegment());        $doneFlags[$globalDoneFlag] = true;        $archiveGroups = array_unique($archiveGroups);        // cache id archives for plugins we haven't processed yet        if (!empty($archiveGroups)) {            if (Rules::isArchivingEnabledFor($this->params->getIdSites(), $this->params->getSegment(), $this->getPeriodLabel())                && !$this->forceFetchingWithoutLaunchingArchiving            ) {                $this->cacheArchiveIdsAfterLaunching($archiveGroups, $plugins);            } else {                $this->cacheArchiveIdsWithoutLaunching($plugins);            }        }        $idArchivesByMonth = $this->getIdArchivesByMonth($doneFlags);        return $idArchivesByMonth;    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
235,symfony_symfony_AbstractDoctrineExtension_1827, Register the alias for this mapping driver.\n\n Aliases can be used in the Query languages of all the Doctrine object managers to simplify writing tasks.\n,Registrujte pseudonim za ovaj drajver za mapiranje. Aliasi se mogu koristiti u jezicima upita svih Doctrine menadžera objekata radi pojednostavljenja zadataka pisanja,"    protected function registerMappingDrivers(array $objectManager, ContainerBuilder $container)    {        // configure metadata driver for each bundle based on the type of mapping files found        if ($container->hasDefinition($this->getObjectManagerElementName($objectManager['name'].'_metadata_driver'))) {            $chainDriverDef = $container->getDefinition($this->getObjectManagerElementName($objectManager['name'].'_metadata_driver'));        } else {            $chainDriverDef = new Definition($this->getMetadataDriverClass('driver_chain'));            $chainDriverDef->setPublic(false);        }        foreach ($this->drivers as $driverType => $driverPaths) {            $mappingService = $this->getObjectManagerElementName($objectManager['name'].'_'.$driverType.'_metadata_driver');            if ($container->hasDefinition($mappingService)) {                $mappingDriverDef = $container->getDefinition($mappingService);                $args = $mappingDriverDef->getArguments();                if ('annotation' == $driverType) {                    $args[1] = array_merge(array_values($driverPaths), $args[1]);                } else {                    $args[0] = array_merge(array_values($driverPaths), $args[0]);                }                $mappingDriverDef->setArguments($args);            } elseif ('attribute' === $driverType) {                $mappingDriverDef = new Definition($this->getMetadataDriverClass($driverType), [                    array_values($driverPaths),                ]);            } elseif ('annotation' == $driverType) {                $mappingDriverDef = new Definition($this->getMetadataDriverClass($driverType), [                    new Reference($this->getObjectManagerElementName('metadata.annotation_reader')),                    array_values($driverPaths),                ]);            } else {                $mappingDriverDef = new Definition($this->getMetadataDriverClass($driverType), [                    array_values($driverPaths),                ]);            }            $mappingDriverDef->setPublic(false);            if (false !== strpos($mappingDriverDef->getClass(), 'yml') || false !== strpos($mappingDriverDef->getClass(), 'xml')) {                $mappingDriverDef->setArguments([array_flip($driverPaths)]);                $mappingDriverDef->addMethodCall('setGlobalBasename', ['mapping']);            }            $container->setDefinition($mappingService, $mappingDriverDef);            foreach ($driverPaths as $prefix => $driverPath) {                $chainDriverDef->addMethodCall('addDriver', [new Reference($mappingService), $prefix]);            }        }        $container->setDefinition($this->getObjectManagerElementName($objectManager['name'].'_metadata_driver'), $chainDriverDef);    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
236,symfony_symfony_DoctrineDataCollector_1820, Sanitizes a param.\\n\\n The return value is an array with the sanitized value and a boolean\\n indicating if the original value was kept (allowing to use the sanitized\\n value to explain the query).\\n,Sanitizira parametar. Povratna vrednost je niz sa saniranom vrednošću i logičkom bojom koji pokazuje da li je izvorna vrednost zadržana (omogućavajući upotrebu sanirane vrednosti za objašnjenje upita),"class DoctrineValidationPass implements CompilerPassInterface{    private $managerType;    public function __construct(string $managerType)    {        $this->managerType = $managerType;    }    /**     * {@inheritdoc}     */    public function process(ContainerBuilder $container)    {        $this->updateValidatorMappingFiles($container, 'xml', 'xml');        $this->updateValidatorMappingFiles($container, 'yaml', 'yml');    }    /**     * Gets the validation mapping files for the format and extends them with     * files matching a doctrine search pattern (Resources/config/validation.orm.xml).     */    private function updateValidatorMappingFiles(ContainerBuilder $container, string $mapping, string $extension)    {        if (!$container->hasParameter('validator.mapping.loader.'.$mapping.'_files_loader.mapping_files')) {            return;        }        $files = $container->getParameter('validator.mapping.loader.'.$mapping.'_files_loader.mapping_files');        $validationPath = '/config/validation.'.$this->managerType.'.'.$extension;        foreach ($container->getParameter('kernel.bundles_metadata') as $bundle) {            if ($container->fileExists($file = $bundle['path'].'/Resources'.$validationPath) || $container->fileExists($file = $bundle['path'].$validationPath)) {                $files[] = $file;            }        }        $container->setParameter('validator.mapping.loader.'.$mapping.'_files_loader.mapping_files', $files);    }}",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
237,firefly-iii_firefly-iii_User_743, Class User.\n\n @property int                                                                  $id\n @property string                                                               $email\n @property bool                                                                 $isAdmin\n @property bool                                                                 $has2FA\n @property array                                                                $prefs\n @property string                                                               $password\n @property string                                                               $mfa_secret\n @property Collection                                                           $roles\n @property string                                                               $blocked_code\n @property bool                                                                 $blocked\n @property Carbon|null                                                          $created_at\n @property Carbon|null                                                          $updated_at\n @property string|null                                                          $remember_token\n @property string|null                                                          $reset\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Account[]              $accounts\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Attachment[]           $attachments\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|AvailableBudget[]      $availableBudgets\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Bill[]                 $bills\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Budget[]               $budgets\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Category[]             $categories\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Client[]               $clients\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|CurrencyExchangeRate[] $currencyExchangeRates\n @property-read DatabaseNotificationCollection|DatabaseNotification[]           $notifications\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|PiggyBank[]            $piggyBanks\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Preference[]           $preferences\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Recurrence[]           $recurrences\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|RuleGroup[]            $ruleGroups\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Rule[]                 $rules\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Tag[]                  $tags\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Token[]                $tokens\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|TransactionGroup[]     $transactionGroups\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|TransactionJournal[]   $transactionJournals\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Transaction[]          $transactions\n @method static Builder|User newModelQuery()\n @method static Builder|User newQuery()\n @method static Builder|User query()\n @method static Builder|User whereBlocked($value)\n @method static Builder|User whereBlockedCode($value)\n @method static Builder|User whereCreatedAt($value)\n @method static Builder|User whereEmail($value)\n @method static Builder|User whereId($value)\n @method static Builder|User wherePassword($value)\n @method static Builder|User whereRememberToken($value)\n @method static Builder|User whereReset($value)\n @method static Builder|User whereUpdatedAt($value)\n @mixin Eloquent\n @property string|null                                                          $objectguid\n @property-read int|null                                                        $accounts_count\n @property-read int|null                                                        $attachments_count\n @property-read int|null                                                        $available_budgets_count\n @property-read int|null                                                        $bills_count\n @property-read int|null                                                        $budgets_count\n @property-read int|null                                                        $categories_count\n @property-read int|null                                                        $clients_count\n @property-read int|null                                                        $currency_exchange_rates_count\n @property-read int|null                                                        $notifications_count\n @property-read int|null                                                        $piggy_banks_count\n @property-read int|null                                                        $preferences_count\n @property-read int|null                                                        $recurrences_count\n @property-read int|null                                                        $roles_count\n @property-read int|null                                                        $rule_groups_count\n @property-read int|null                                                        $rules_count\n @property-read int|null                                                        $tags_count\n @property-read int|null                                                        $tokens_count\n @property-read int|null                                                        $transaction_groups_count\n @property-read int|null                                                        $transaction_journals_count\n @property-read int|null                                                        $transactions_count\n @method static \\Illuminate\\Database\\Eloquent\\Builder|\\FireflyIII\\User whereMfaSecret($value)\n @method static \\Illuminate\\Database\\Eloquent\\Builder|\\FireflyIII\\User whereObjectguid($value)\n @property string|null                                                          $provider\n @method static \\Illuminate\\Database\\Eloquent\\Builder|\\FireflyIII\\User whereProvider($value)\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|ObjectGroup[] $objectGroups\n @property-read int|null $object_groups_count\n @property-read \\Illuminate\\Database\\Eloquent\\Collection|Webhook[] $webhooks\n @property-read int|null $webhooks_count\n,Klasa korisnik (User),"class User extends Authenticatable{    use Notifiable, HasApiTokens;    /**     * The attributes that should be casted to native types.     *     * @var array     */    protected $casts        = [            'created_at' => 'datetime',            'updated_at' => 'datetime',            'blocked'    => 'boolean',        ];    /**     * The attributes that are mass assignable.     *     * @var array     */    protected $fillable = ['email', 'password', 'blocked', 'blocked_code'];    /**     * The attributes excluded from the model's JSON form.     *     * @var array     */    protected $hidden = ['password', 'remember_token'];    /**     * The database table used by the model.     *     * @var string     */    protected $table = 'users';    /**     * @param string $value     *     * @return User     * @throws NotFoundHttpException     */    public static function routeBinder(string $value): User    {        if (auth()->check()) {            $userId = (int)$value;            $user   = self::find($userId);            if (null !== $user) {                return $user;            }        }        throw new NotFoundHttpException;    }    /**     * @codeCoverageIgnore     * Link to accounts.     *     * @return HasMany     */    public function accounts(): HasMany    {        return $this->hasMany(Account::class);    }    /**     * @codeCoverageIgnore     * Link to attachments     *     * @return HasMany     */    public function attachments(): HasMany    {        return $this->hasMany(Attachment::class);    }    /**     * @codeCoverageIgnore     *     * Link to webhooks     *     * @return HasMany     */    public function webhooks(): HasMany    {        return $this->hasMany(Webhook::class);    }    /**     * @param string $role     *     * @return bool     */    public function hasRole(string $role): bool    {        return $this->roles()->where('name', $role)->count() === 1;    }    /**     * @codeCoverageIgnore     * Link to available budgets     *     * @return HasMany     */    public function availableBudgets(): HasMany    {        return $this->hasMany(AvailableBudget::class);    }    /**     * @codeCoverageIgnore     * Link to bills.     *     * @return HasMany     */    public function bills(): HasMany    {        return $this->hasMany(Bill::class);    }    /**     * @codeCoverageIgnore     * Link to budgets.     *     * @return HasMany     */    public function budgets(): HasMany    {        return $this->hasMany(Budget::class);    }    /**     * @codeCoverageIgnore     * Link to object groups.     *     * @return HasMany     */    public function objectGroups(): HasMany    {        return $this->hasMany(ObjectGroup::class);    }    /**     * @codeCoverageIgnore     * Link to categories     *     * @return HasMany     */    public function categories(): HasMany    {        return $this->hasMany(Category::class);    }    /**     * @codeCoverageIgnore     * Link to currency exchange rates     *     * @return HasMany     */    public function currencyExchangeRates(): HasMany    {        return $this->hasMany(CurrencyExchangeRate::class);    }    /**     * @codeCoverageIgnore     * Generates access token.     *     * @return string     * @throws Exception     */    public function generateAccessToken(): string    {        $bytes = random_bytes(16);        return bin2hex($bytes);    }    /**     * @codeCoverageIgnore     * Link to piggy banks.     *     * @return HasManyThrough     */    public function piggyBanks(): HasManyThrough    {        return $this->hasManyThrough(PiggyBank::class, Account::class);    }    /**     * @codeCoverageIgnore     * Link to preferences.     *     * @return HasMany     */    public function preferences(): HasMany    {        return $this->hasMany(Preference::class);    }    /**     * @codeCoverageIgnore     * Link to recurring transactions.     *     * @return HasMany     */    public function recurrences(): HasMany    {        return $this->hasMany(Recurrence::class);    }    /**     * @codeCoverageIgnore     * Link to roles.     *     * @return BelongsToMany     */    public function roles(): BelongsToMany    {        return $this->belongsToMany(Role::class);    }    /**     * @codeCoverageIgnore     * Link to rule groups.     *     * @return HasMany     */    public function ruleGroups(): HasMany    {        return $this->hasMany(RuleGroup::class);    }    /**     * @codeCoverageIgnore     * Link to rules.     *     * @return HasMany     */    public function rules(): HasMany    {        return $this->hasMany(Rule::class);    }    /**     * @codeCoverageIgnore     * Send the password reset notification.     *     * @param string $token     */    public function sendPasswordResetNotification($token): void    {        $ipAddress = Request::ip();        event(new RequestedNewPassword($this, $token, $ipAddress));    }    /**     * @codeCoverageIgnore     * Link to tags.     *     * @return HasMany     */    public function tags(): HasMany    {        return $this->hasMany(Tag::class);    }    /**     * @codeCoverageIgnore     * Link to transaction groups.     *     * @return HasMany     */    public function transactionGroups(): HasMany    {        return $this->hasMany(TransactionGroup::class);    }    /**     * @codeCoverageIgnore     * Link to transaction journals.     *     * @return HasMany     */    public function transactionJournals(): HasMany    {        return $this->hasMany(TransactionJournal::class);    }    /**     * @codeCoverageIgnore     * Link to transactions.     *     * @return HasManyThrough     */    public function transactions(): HasManyThrough    {        return $this->hasManyThrough(Transaction::class, TransactionJournal::class);    }}",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
238,PrestaShop_PrestaShop_Address_786, Returns Address ID for a given Supplier ID.\\\\\\\\n\\\\\\\\n @since 1.5.0\\\\\\\\n\\\\\\\\n @param int $id_supplier Supplier ID\\\\\\\\n\\\\\\\\n @return int $id_address Address ID\\\\\\\\n,Vraća ID adrese za dati ID dobavljača,    public static function getAddressIdBySupplierId($id_supplier)    {        $query = new DbQuery();        $query->select('id_address');        $query->from('address');        $query->where('id_supplier = ' . (int) $id_supplier);        $query->where('deleted = 0');        $query->where('id_customer = 0');        $query->where('id_manufacturer = 0');        $query->where('id_warehouse = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query);    },3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
239,PrestaShop_PrestaShop_Address_787, Check if the alias already exists.\\\\n\\\\n @param string $alias Alias of an address\\\\n @param int $id_address Address id\\\\n @param int $id_customer Customer id\\\\n\\\\n @return false|string|null Amount of aliases found\\\\n @todo: Find out if we shouldn't be returning an int instead? (breaking change)\\\\n,Proverite da li pseudonim već postoji,"    public static function aliasExist($alias, $id_address, $id_customer)    {        $query = new DbQuery();        $query->select('count(*)');        $query->from('address');        $query->where('alias = \'' . pSQL($alias) . '\'');        $query->where('id_address != ' . (int) $id_address);        $query->where('id_customer = ' . (int) $id_customer);        $query->where('deleted = 0');        return Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue($query, false);    }",3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
240,cakephp_cakephp_BaseAuthenticate_1176, Base Authentication class with common methods and properties.\\n,Osnovna klasa autentifikacije sa uobičajenim metodama i svojstvima,"abstract class BaseAuthenticate implements EventListenerInterface{    use InstanceConfigTrait;    use LocatorAwareTrait;    /**     * Default config for this object.     *     * - `fields` The fields to use to identify a user by.     * - `userModel` The alias for users table, defaults to Users.     * - `finder` The finder method to use to fetch user record. Defaults to 'all'.     *   You can set finder name as string or an array where key is finder name and value     *   is an array passed to `Table::find()` options.     *   E.g. ['finderName' => ['some_finder_option' => 'some_value']]     * - `passwordHasher` Password hasher class. Can be a string specifying class name     *    or an array containing `className` key, any other keys will be passed as     *    config to the class. Defaults to 'Default'.     *     * @var array     */    protected $_defaultConfig = [        'fields' => [            'username' => 'username',            'password' => 'password',        ],        'userModel' => 'Users',        'finder' => 'all',        'passwordHasher' => 'Default',    ];    /**     * A Component registry, used to get more components.     *     * @var \Cake\Controller\ComponentRegistry     */    protected $_registry;    /**     * Password hasher instance.     *     * @var \Cake\Auth\AbstractPasswordHasher|null     */    protected $_passwordHasher;    /**     * Whether or not the user authenticated by this class     * requires their password to be rehashed with another algorithm.     *     * @var bool     */    protected $_needsPasswordRehash = false;    /**     * Constructor     *     * @param \Cake\Controller\ComponentRegistry $registry The Component registry used on this request.     * @param array $config Array of config to use.     */    public function __construct(ComponentRegistry $registry, array $config = [])    {        $this->_registry = $registry;        $this->setConfig($config);    }    /**     * Find a user record using the username and password provided.     *     * Input passwords will be hashed even when a user doesn't exist. This     * helps mitigate timing attacks that are attempting to find valid usernames.     *     * @param string $username The username/identifier.     * @param string|null $password The password, if not provided password checking is skipped     *   and result of find is returned.     * @return array|false Either false on failure, or an array of user data.     */    protected function _findUser(string $username, ?string $password = null)    {        $result = $this->_query($username)->first();        if ($result === null) {            // Waste time hashing the password, to prevent            // timing side-channels. However, don't hash            // null passwords as authentication systems            // like digest auth don't use passwords            // and hashing *could* create a timing side-channel.            if ($password !== null) {                $hasher = $this->passwordHasher();                $hasher->hash($password);            }            return false;        }        $passwordField = $this->_config['fields']['password'];        if ($password !== null) {            $hasher = $this->passwordHasher();            $hashedPassword = $result->get($passwordField);            if ($hashedPassword === null || $hashedPassword === '') {                // Waste time hashing the password, to prevent                // timing side-channels to distinguish whether                // user has password or not.                $hasher->hash($password);                return false;            }            if (!$hasher->check($password, $hashedPassword)) {                return false;            }            $this->_needsPasswordRehash = $hasher->needsRehash($hashedPassword);            $result->unset($passwordField);        }        $hidden = $result->getHidden();        if ($password === null && in_array($passwordField, $hidden, true)) {            $key = array_search($passwordField, $hidden, true);            unset($hidden[$key]);            $result->setHidden($hidden);        }        return $result->toArray();    }    /**     * Get query object for fetching user from database.     *     * @param string $username The username/identifier.     * @return \Cake\ORM\Query     */    protected function _query(string $username): Query    {        $config = $this->_config;        $table = $this->getTableLocator()->get($config['userModel']);        $options = [            'conditions' => [$table->aliasField($config['fields']['username']) => $username],        ];        $finder = $config['finder'];        if (is_array($finder)) {            $options += current($finder);            $finder = key($finder);        }        if (!isset($options['username'])) {            $options['username'] = $username;        }        return $table->find($finder, $options);    }    /**     * Return password hasher object     *     * @return \Cake\Auth\AbstractPasswordHasher Password hasher instance     * @throws \RuntimeException If password hasher class not found or     *   it does not extend AbstractPasswordHasher     */    public function passwordHasher(): AbstractPasswordHasher    {        if ($this->_passwordHasher !== null) {            return $this->_passwordHasher;        }        $passwordHasher = $this->_config['passwordHasher'];        return $this->_passwordHasher = PasswordHasherFactory::build($passwordHasher);    }    /**     * Returns whether or not the password stored in the repository for the logged in user     * requires to be rehashed with another algorithm     *     * @return bool     */    public function needsPasswordRehash(): bool    {        return $this->_needsPasswordRehash;    }    /**     * Authenticate a user based on the request information.     *     * @param \Cake\Http\ServerRequest $request Request to get authentication information from.     * @param \Cake\Http\Response $response A response object that can have headers added.     * @return array|false Either false on failure, or an array of user data on success.     */    abstract public function authenticate(ServerRequest $request, Response $response);    /**     * Get a user based on information in the request. Primarily used by stateless authentication     * systems like basic and digest auth.     *     * @param \Cake\Http\ServerRequest $request Request object.     * @return array|false Either false or an array of user information     */    public function getUser(ServerRequest $request)    {        return false;    }    /**     * Handle unauthenticated access attempt. In implementation valid return values     * can be:     *     * - Null - No action taken, AuthComponent should return appropriate response.     * - Cake\Http\Response - A response object, which will cause AuthComponent to     *   simply return that response.     *     * @param \Cake\Http\ServerRequest $request A request object.     * @param \Cake\Http\Response $response A response object.     * @return \Cake\Http\Response|null|void     */    public function unauthenticated(ServerRequest $request, Response $response)    {    }    /**     * Returns a list of all events that this authenticate class will listen to.     *     * An authenticate class can listen to following events fired by AuthComponent:     *     * - `Auth.afterIdentify` - Fired after a user has been identified using one of     *   configured authenticate class. The callback function should have signature     *   like `afterIdentify(EventInterface $event, array $user)` when `$user` is the     *   identified user record.     *     * - `Auth.logout` - Fired when AuthComponent::logout() is called. The callback     *   function should have signature like `logout(EventInterface $event, array $user)`     *   where `$user` is the user about to be logged out.     *     * @return array List of events this class listens to. Defaults to `[]`.     */    public function implementedEvents(): array    {        return [];    }}",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
241,getgrav_grav_Debugger_1998, Add the debugger assets to the Grav Assets\\n\\n @return $this\\n,Dodaje debager u Grav Assets,"    public function addAssets()    {        if ($this->enabled) {            // Only add assets if Page is HTML            $page = $this->grav['page'];            if ($page->templateFormat() !== 'html') {                return $this;            }            /** @var Assets $assets */            $assets = $this->grav['assets'];            // Clockwork specific assets            if ($this->clockwork) {                $assets->addCss('/system/assets/debugger/clockwork.css', ['loading' => 'inline']);                $assets->addJs('/system/assets/debugger/clockwork.js', ['loading' => 'inline']);            }            // Debugbar specific assets            if ($this->debugbar) {                // Add jquery library                $assets->add('jquery', 101);                $this->renderer = $this->debugbar->getJavascriptRenderer();                $this->renderer->setIncludeVendors(false);                [$css_files, $js_files] = $this->renderer->getAssets(null, JavascriptRenderer::RELATIVE_URL);                foreach ((array)$css_files as $css) {                    $assets->addCss($css);                }                $assets->addCss('/system/assets/debugger/phpdebugbar.css', ['loading' => 'inline']);                foreach ((array)$js_files as $js) {                    $assets->addJs($js);                }            }        }        return $this;    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
242,humhub_humhub_AppDynamicAsset_2464, AppDynamicAsset provides assets which are included in the core layout.\n It similar to AppAsset but won't be compressed and combined.\n So it can handle dynamic assets (e.g. javascript locales)\n\n @since 1.2\n,"AppDynamicAsset pruža sredstva koja su uključena u osnovni izgled. Sličan je AppAsset-u, ali neće biti kompresovan i kombinovan. Dakle, može da obrađuje dinamička sredstva (npr. javascript lokalitete)",class AppDynamicAsset extends AssetBundle{    /**     * @inheritdoc     */    public $defer = false;    /**     * @inheritdoc     */    public $jsOptions = ['position' => View::POS_HEAD];    /**     * @inheritdoc     */    public $depends = [        JqueryTimeAgoLocaleAsset::class    ];},1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
243,magento_magento2_processor_2874, Error processor\n\n @SuppressWarnings(PHPMD.TooManyFields)\n @SuppressWarnings(PHPMD.ExcessiveClassComplexity)\n phpcs:ignoreFile\n,Procesor grešaka,"class Processor{    const MAGE_ERRORS_LOCAL_XML = 'local.xml';    const MAGE_ERRORS_DESIGN_XML = 'design.xml';    const DEFAULT_SKIN = 'default';    const ERROR_DIR = 'pub/errors';    const NUMBER_SYMBOLS_IN_SUBDIR_NAME = 2;    /**     * Page title     *     * @var string     */    public $pageTitle;    /**     * Skin URL     *     * @var string     */    public $skinUrl;    /**     * Base URL     *     * @var string     */    public $baseUrl;    /**     * Post data     *     * @var array     */    public $postData;    /**     * Report data     *     * @var array     */    public $reportData;    /**     * Report action     *     * @var string     */    public $reportAction;    /**     * Report ID     *     * @var string     */    public $reportId;    /**     * Report file     *     * @var string     */    protected $_reportFile;    /**     * Show error message     *     * @var bool     */    public $showErrorMsg;    /**     * Show message after sending email     *     * @var bool     */    public $showSentMsg;    /**     * Show form for sending     *     * @var bool     */    public $showSendForm;    /**     * @var string     */    public $reportUrl;    /**     * Server script name     *     * @var string     */    protected $_scriptName;    /**     * Is root     *     * @var bool     */    protected $_root;    /**     * Internal config object     *     * @var \stdClass     */    protected $_config;    /**     * Http response     *     * @var Http     */    protected $_response;    /**     * JSON serializer     *     * @var Json     */    private $serializer;    /**     * @var Escaper     */    private $escaper;    /**     * @var DocumentRoot     */    private $documentRoot;    /**     * @param Http $response     * @param Json $serializer     * @param Escaper $escaper     * @param DocumentRoot|null $documentRoot     */    public function __construct(        Http $response,        Json $serializer = null,        Escaper $escaper = null,        DocumentRoot $documentRoot = null    ) {        $this->_response = $response;        $this->_errorDir  = __DIR__ . '/';        $this->_reportDir = dirname(dirname($this->_errorDir)) . '/var/report/';        $this->serializer = $serializer ?: ObjectManager::getInstance()->get(Json::class);        $this->escaper = $escaper ?: ObjectManager::getInstance()->get(Escaper::class);        $this->documentRoot = $documentRoot ?? ObjectManager::getInstance()->get(DocumentRoot::class);        if (!empty($_SERVER['SCRIPT_NAME'])) {            if (in_array(basename($_SERVER['SCRIPT_NAME'], '.php'), ['404', '503', 'report'])) {                $this->_scriptName = dirname($_SERVER['SCRIPT_NAME']);            } else {                $this->_scriptName = $_SERVER['SCRIPT_NAME'];            }        }        $this->_indexDir = $this->_getIndexDir();        $this->_root  = is_dir($this->_indexDir . 'app');        $this->_prepareConfig();        if (isset($_GET['skin'])) {            $this->_setSkin($_GET['skin']);        }        if (isset($_GET['id'])) {            $this->loadReport($_GET['id']);        }    }    /**     * Process no cache error     *     * @return \Magento\Framework\App\Response\Http     */    public function processNoCache()    {        $this->pageTitle = 'Error : cached config data is unavailable';        $this->_response->setBody($this->_renderPage('nocache.phtml'));        return $this->_response;    }    /**     * Process 404 error     *     * @return \Magento\Framework\App\Response\Http     */    public function process404()    {        $this->pageTitle = 'Error 404: Not Found';        $this->_response->setHttpResponseCode(404);        $this->_response->setBody($this->_renderPage('404.phtml'));        return $this->_response;    }    /**     * Process 503 error     *     * @return \Magento\Framework\App\Response\Http     */    public function process503()    {        $this->pageTitle = 'Error 503: Service Unavailable';        $this->_response->setHttpResponseCode(503);        $this->_response->setBody($this->_renderPage('503.phtml'));        return $this->_response;    }    /**     * Process report     *     * @return \Magento\Framework\App\Response\Http     */    public function processReport()    {        $this->pageTitle = 'There has been an error processing your request';        $this->_response->setHttpResponseCode(500);        $this->showErrorMsg = false;        $this->showSentMsg  = false;        $this->showSendForm = false;        $this->reportAction = $this->_config->action;        $this->_setReportUrl();        if ($this->reportAction == 'email') {            $this->showSendForm = true;            $this->sendReport();        }        $this->_response->setBody($this->_renderPage('report.phtml'));        return $this->_response;    }    /**     * Retrieve skin URL     *     * @return string     */    public function getViewFileUrl()    {        //The url needs to be updated base on Document root path.        $indexDir = str_replace('\\', '/', $this->_indexDir);        $errorDir = str_replace('\\', '/', $this->_errorDir);        $errorPathSuffix = $this->documentRoot->isPub() ? 'errors/' : 'pub/errors/';        $errorPath = strpos($errorDir, $indexDir) === 0 ?            str_replace($indexDir, '', $errorDir) : $errorPathSuffix;        return $this->getBaseUrl() . $errorPath . $this->_config->skin . '/';    }    /**     * Retrieve base host URL without path     *     * @return string     */    public function getHostUrl()    {        /**         * Define server http host         */        $host = $this->resolveHostName();        $isSecure = (!empty($_SERVER['HTTPS'])) && ($_SERVER['HTTPS'] !== 'off')            || isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && ($_SERVER['HTTP_X_FORWARDED_PROTO'] === 'https');        $url = ($isSecure ? 'https://' : 'http://') . $host;        $port = explode(':', $host);        if (isset($port[1]) && !in_array($port[1], [80, 443])            && !preg_match('/.*?\:[0-9]+$/', $url)        ) {            $url .= ':' . $port[1];        }        return  $url;    }    /**     * Resolve hostname     *     * @return string     */    private function resolveHostName() : string    {        if (!empty($_SERVER['HTTP_HOST'])) {            $host = $_SERVER['HTTP_HOST'];        } elseif (!empty($_SERVER['SERVER_NAME'])) {            $host = $_SERVER['SERVER_NAME'];        } else {            $host = 'localhost';        }        return $host;    }    /**     * Retrieve base URL     *     * @param bool $param     * @return string     */    public function getBaseUrl($param = false)    {        $path = $this->_scriptName;        if ($param && !$this->_root) {            $path = dirname($path);        }        $basePath = str_replace('\\', '/', dirname($path));        return $this->getHostUrl() . ('/' == $basePath ? '' : $basePath) . '/';    }    /**     * Retrieve client IP address     *     * @return string     */    protected function _getClientIp()    {        return (isset($_SERVER['REMOTE_ADDR'])) ? $_SERVER['REMOTE_ADDR'] : 'undefined';    }    /**     * Get index dir     *     * @return string     */    protected function _getIndexDir()    {        $documentRoot = '';        if (!empty($_SERVER['DOCUMENT_ROOT'])) {            $documentRoot = rtrim(realpath($_SERVER['DOCUMENT_ROOT']), '/');        }        return dirname($documentRoot . $this->_scriptName) . '/';    }    /**     * Prepare config data     *     * @return void     * @SuppressWarnings(PHPMD.CyclomaticComplexity)     * @SuppressWarnings(PHPMD.NPathComplexity)     */    protected function _prepareConfig()    {        $local  = $this->_loadXml(self::MAGE_ERRORS_LOCAL_XML);        $design = $this->_loadXml(self::MAGE_ERRORS_DESIGN_XML);        //initial settings        $config = new \stdClass();        $config->action         = '';        $config->subject        = 'Store Debug Information';        $config->email_address  = '';        $config->trash          = 'leave';        $config->skin           = self::DEFAULT_SKIN;        //combine xml data to one object        if ($design !== null && (string)$design->skin) {            $this->_setSkin((string)$design->skin, $config);        }        if ($local !== null) {            if ((string)$local->report->action) {                $config->action = $local->report->action;            }            if ((string)$local->report->subject) {                $config->subject = $local->report->subject;            }            if ((string)$local->report->email_address) {                $config->email_address = $local->report->email_address;            }            if ((string)$local->report->trash) {                $config->trash = $local->report->trash;            }            if ($local->report->dir_nesting_level) {                $config->dir_nesting_level = (int)$local->report->dir_nesting_level;            }            if ((string)$local->skin) {                $this->_setSkin((string)$local->skin, $config);            }        }        if ((string)$config->email_address == '' && (string)$config->action == 'email') {            $config->action = '';        }        $this->_config = $config;    }    /**     * Load xml file     *     * @param string $xmlFile     * @return \SimpleXMLElement     */    protected function _loadXml($xmlFile)    {        $configPath = $this->_getFilePath($xmlFile);        return ($configPath) ? simplexml_load_file($configPath) : null;    }    /**     * Render page     *     * @param string $template     * @return string     */    protected function _renderPage($template)    {        $baseTemplate = $this->_getTemplatePath('page.phtml');        $contentTemplate = $this->_getTemplatePath($template);        $html = '';        if ($baseTemplate && $contentTemplate) {            ob_start();            require_once $baseTemplate;            $html = ob_get_clean();        }        return $html;    }    /**     * Find file path     *     * @param string $file     * @param array $directories     * @return string     */    protected function _getFilePath($file, $directories = null)    {        if ($directories === null) {            $directories[] = $this->_errorDir;        }        foreach ($directories as $directory) {            if (file_exists($directory . $file)) {                return $directory . $file;            }        }    }    /**     * Find template path     *     * @param string $template     * @return string     */    protected function _getTemplatePath($template)    {        $directories[] = $this->_errorDir . $this->_config->skin . '/';        if ($this->_config->skin != self::DEFAULT_SKIN) {            $directories[] = $this->_errorDir . self::DEFAULT_SKIN . '/';        }        return $this->_getFilePath($template, $directories);    }    /**     * Set report data     *     * @param array $reportData     * @return void     */    protected function _setReportData($reportData)    {        $this->reportData = $reportData;        if (!isset($reportData['url'])) {            $this->reportData['url'] = '';        } else {            $this->reportData['url'] = $this->getHostUrl() . $reportData['url'];        }        if (isset($this->reportData['script_name'])) {            $this->_scriptName = $this->reportData['script_name'];        }    }    /**     * Create report     *     * @param array $reportData     * @return string     */    public function saveReport(array $reportData): string    {        $this->reportId = $reportData['report_id'];        $this->_reportFile = $this->getReportPath(            $this->getReportDirNestingLevel($this->reportId),            $this->reportId        );        $reportDirName = dirname($this->_reportFile);        if (!file_exists($reportDirName)) {            @mkdir($reportDirName, 0777, true);        }        $this->_setReportData($reportData);        @file_put_contents($this->_reportFile, $this->serializer->serialize($reportData). PHP_EOL);        if (isset($reportData['skin']) && self::DEFAULT_SKIN != $reportData['skin']) {            $this->_setSkin($reportData['skin']);        }        $this->_setReportUrl();        return $this->reportUrl;    }    /**     * Get report     *     * @param string $reportId     * @return void     */    public function loadReport($reportId)    {        try {            if (!$this->isReportIdValid($reportId)) {                throw new \RuntimeException(""Report Id is invalid"");            }            $reportFile = $this->findReportFile($reportId);            if (!is_readable($reportFile)) {                throw new \RuntimeException(""Report file cannot be read"");            }            $this->reportId = $reportId;            $this->_reportFile = $reportFile;            $this->_setReportData($this->serializer->unserialize(file_get_contents($this->_reportFile)));        } catch (\RuntimeException $e) {            $this->redirectToBaseUrl();        }    }    /**     * Searches for the report file and returns the path to it     *     * @param string $reportId     * @return string     * @throws \RuntimeException     */    private function findReportFile(string $reportId): string    {        $reportFile = $this->getReportPath(            $this->getReportDirNestingLevel($reportId),            $reportId        );        if (file_exists($reportFile)) {            return $reportFile;        }        $maxReportDirNestingLevel = $this->getMaxReportDirNestingLevel($reportId);        for ($i = 0; $i <= $maxReportDirNestingLevel; $i++) {            $reportFile = $this->getReportPath($i, $reportId);            if (file_exists($reportFile)) {                return $reportFile;            }        }        throw new \RuntimeException(""Report file not found"");    }    /**     * Redirect to a base url     * @return void     */    private function redirectToBaseUrl()    {        header(""Location: "" . $this->getBaseUrl());        die();    }    /**     * Checks report id     *     * @param string $reportId     * @return bool     */    private function isReportIdValid(string $reportId): bool    {        return (bool)preg_match('/[a-fA-F0-9]{64}/', $reportId);    }    /**     * Get path to reports     *     * @param integer $reportDirNestingLevel     * @param string $reportId     * @return string     */    private function getReportPath(int $reportDirNestingLevel, string $reportId): string    {        $reportDirPath = $this->_reportDir;        for ($i = 0, $j = 0; $j < $reportDirNestingLevel; $i += 2, $j++) {            $reportDirPath .= $reportId[$i] . $reportId[$i + 1] . '/';        }        return $reportDirPath . $reportId;    }    /**     * Returns nesting Level for the report files     *     * @var $reportId     * @return int     */    private function getReportDirNestingLevel(string $reportId): int    {        $envName = 'MAGE_ERROR_REPORT_DIR_NESTING_LEVEL';        $value = $_ENV[$envName] ?? getenv($envName);        if(false === $value && property_exists($this->_config, 'dir_nesting_level')) {            $value = $this->_config->dir_nesting_level;        }        $value = (int)$value;        $maxValue= $this->getMaxReportDirNestingLevel($reportId);        return 0 < $value && $maxValue >= $value ? $value : 0;    }    /**     * Returns maximum nesting level directories of report files     *     * @param string $reportId     * @return integer     */    private function getMaxReportDirNestingLevel(string $reportId): int    {        return (int)floor(strlen($reportId) / self::NUMBER_SYMBOLS_IN_SUBDIR_NAME);    }    /**     * Send report     *     * @return void     * @SuppressWarnings(PHPMD.CyclomaticComplexity)     * @SuppressWarnings(PHPMD.NPathComplexity)     */    public function sendReport()    {        $this->pageTitle = 'Error Submission Form';        $this->postData['firstName'] = (isset($_POST['firstname']))            ? trim($this->escaper->escapeHtml($_POST['firstname'])) : '';        $this->postData['lastName'] = (isset($_POST['lastname']))            ? trim($this->escaper->escapeHtml($_POST['lastname'])) : '';        $this->postData['email'] = (isset($_POST['email']))            ? trim($this->escaper->escapeHtml($_POST['email'])) : '';        $this->postData['telephone'] = (isset($_POST['telephone']))            ? trim($this->escaper->escapeHtml($_POST['telephone'])) : '';        $this->postData['comment'] = (isset($_POST['comment']))            ? trim($this->escaper->escapeHtml($_POST['comment'])) : '';        if (isset($_POST['submit'])) {            if ($this->_validate()) {                $msg  = ""URL: {$this->reportData['url']}\n""                    . ""IP Address: {$this->_getClientIp()}\n""                    . ""First Name: {$this->postData['firstName']}\n""                    . ""Last Name: {$this->postData['lastName']}\n""                    . ""Email Address: {$this->postData['email']}\n"";                if ($this->postData['telephone']) {                    $msg .= ""Telephone: {$this->postData['telephone']}\n"";                }                if ($this->postData['comment']) {                    $msg .= ""Comment: {$this->postData['comment']}\n"";                }                $subject = sprintf('%s [%s]', (string)$this->_config->subject, $this->reportId);                @mail((string)$this->_config->email_address, $subject, $msg);                $this->showSendForm = false;                $this->showSentMsg  = true;            } else {                $this->showErrorMsg = true;            }        } else {            $time = gmdate('Y-m-d H:i:s \G\M\T');            $msg = ""URL: {$this->reportData['url']}\n""                . ""IP Address: {$this->_getClientIp()}\n""                . ""Time: {$time}\n""                . ""Error:\n{$this->reportData[0]}\n\n""                . ""Trace:\n{$this->reportData[1]}"";            $subject = sprintf('%s [%s]', (string)$this->_config->subject, $this->reportId);            @mail((string)$this->_config->email_address, $subject, $msg);            if ($this->_config->trash == 'delete') {                @unlink($this->_reportFile);            }        }    }    /**     * Validate submitted post data     *     * @return bool     */    protected function _validate()    {        $email = preg_match(            '/^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,3})$/',            $this->postData['email']        );        return ($this->postData['firstName'] && $this->postData['lastName'] && $email);    }    /**     * Skin setter     *     * @param string $value     * @param \stdClass $config     * @return void     */    protected function _setSkin($value, \stdClass $config = null)    {        if (preg_match('/^[a-z0-9_]+$/i', $value) && is_dir($this->_errorDir . $value)) {            if (!$config) {                if ($this->_config) {                    $config = $this->_config;                }            }            if ($config) {                $config->skin = $value;            }        }    }    /**     * Set current report URL from current params     *     * @return void     */    protected function _setReportUrl()    {        if ($this->reportId && $this->_config && isset($this->_config->skin)) {            $this->reportUrl = ""{$this->getBaseUrl(true)}pub/errors/report.php?""                . http_build_query(['id' => $this->reportId, 'skin' => $this->_config->skin]);        }    }}",1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
244,owncloud_core_AppConfig_1354," Sets a value. If the key did not exist before it will be created.\\n\\n @param string $app app\\n @param string $key key\\n @param string|float|int $value value\\n @return bool True if the value was inserted or updated, false if the value was the same\\n",Postavlja vrednost. Ako ključ nije postojao pre nego što će biti stvoren,"public function setValue($app, $key, $value) {return $this->emittingCall(function (&$afterArray) use (&$app, &$key, &$value) {if (!$this->hasKey($app, $key)) {$inserted = (bool) $this->conn->insertIfNotExist('*PREFIX*appconfig', ['appid' => $app,'configkey' => $key,'configvalue' => $value,], ['appid','configkey',]);if ($inserted) {if (!isset($this->cache[$app])) {$this->cache[$app] = [];}$this->cache[$app][$key] = $value;return true;}}$sql = $this->conn->getQueryBuilder();$sql->update('appconfig')->set('configvalue', $sql->createParameter('configvalue'))->where($sql->expr()->eq('appid', $sql->createParameter('app')))->andWhere($sql->expr()->eq('configkey', $sql->createParameter('configkey')))->setParameter('configvalue', $value)->setParameter('app', $app)->setParameter('configkey', $key);/* * Only limit to the existing value for non-Oracle DBs: * http://docs.oracle.com/cd/E11882_01/server.112/e26088/conditions002.htm#i1033286 * > Large objects (LOBs) are not supported in comparison conditions. */if (!($this->conn instanceof \OC\DB\OracleConnection)) {// Only update the value when it is not the same$sql->andWhere($sql->expr()->neq('configvalue', $sql->createParameter('configvalue')))->setParameter('configvalue', $value);}if (isset($this->cache[$app], $this->cache[$app][$key])) {$afterArray['update'] = true;$afterArray['oldvalue'] = $this->cache[$app][$key];}$changedRow = (bool) $sql->execute();$this->cache[$app][$key] = $value;return $changedRow;}, [",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
245,symfony_http-foundation_Request_8891, Prepares the path info.\n\n @return string path info\n,Priprema informacije o putanji,"    protected function preparePathInfo()    {        if (null === ($requestUri = $this->getRequestUri())) {            return '/';        }        // Remove the query string from REQUEST_URI        if (false !== $pos = strpos($requestUri, '?')) {            $requestUri = substr($requestUri, 0, $pos);        }        if ('' !== $requestUri && '/' !== $requestUri[0]) {            $requestUri = '/'.$requestUri;        }        if (null === ($baseUrl = $this->getBaseUrlReal())) {            return $requestUri;        }        $pathInfo = substr($requestUri, \strlen($baseUrl));        if (false === $pathInfo || '' === $pathInfo) {            // If substr() returns false then PATH_INFO is set to an empty string            return '/';        }        return (string) $pathInfo;    }",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
246,symfony_http-foundation_UrlHelper_8061, A helper service for manipulating URLs within and outside the request scope.\n\n @author Valentin Udaltsov <udaltsov.valentin@gmail.com>\n,Pomoćna usluga za manipulisanje URL-ovima unutar i izvan opsega zahteva,"final class UrlHelper{    private $requestStack;    private $requestContext;    public function __construct(RequestStack $requestStack, RequestContext $requestContext = null)    {        $this->requestStack = $requestStack;        $this->requestContext = $requestContext;    }    public function getAbsoluteUrl(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $this->getAbsoluteUrlFromContext($path);        }        if ('#' === $path[0]) {            $path = $request->getRequestUri().$path;        } elseif ('?' === $path[0]) {            $path = $request->getPathInfo().$path;        }        if (!$path || '/' !== $path[0]) {            $prefix = $request->getPathInfo();            $last = \strlen($prefix) - 1;            if ($last !== $pos = strrpos($prefix, '/')) {                $prefix = substr($prefix, 0, $pos).'/';            }            return $request->getUriForPath($prefix.$path);        }        return $request->getSchemeAndHttpHost().$path;    }    public function getRelativePath(string $path): string    {        if (false !== strpos($path, '://') || '//' === substr($path, 0, 2)) {            return $path;        }        if (null === $request = $this->requestStack->getMainRequest()) {            return $path;        }        return $request->getRelativeUriForPath($path);    }    private function getAbsoluteUrlFromContext(string $path): string    {        if (null === $this->requestContext || '' === $host = $this->requestContext->getHost()) {            return $path;        }        $scheme = $this->requestContext->getScheme();        $port = '';        if ('http' === $scheme && 80 !== $this->requestContext->getHttpPort()) {            $port = ':'.$this->requestContext->getHttpPort();        } elseif ('https' === $scheme && 443 !== $this->requestContext->getHttpsPort()) {            $port = ':'.$this->requestContext->getHttpsPort();        }        if ('#' === $path[0]) {            $queryString = $this->requestContext->getQueryString();            $path = $this->requestContext->getPathInfo().($queryString ? '?'.$queryString : '').$path;        } elseif ('?' === $path[0]) {            $path = $this->requestContext->getPathInfo().$path;        }        if ('/' !== $path[0]) {            $path = rtrim($this->requestContext->getBaseUrl(), '/').'/'.$path;        }        return $scheme.'://'.$host.$port.$path;    }}",1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
247,wallabag_wallabag_AnnotationControllerTest_2430, Test deleting an annotation.\n\n @dataProvider dataForEachAnnotations\n,Test brisanja anotacije,    public function getBuilderForAllByUser($userId)    {        return $this            ->getSortedQueryBuilderByUser($userId)        ;    },1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
248,wallabag_wallabag_AnnotationRepository_2419, Find last annotation for a given entry id. Used only for tests.\n\n @param int $entryId\n\n @return array\n,Pronađi poslednju napomenu za dati ID unosa. Koristi se samo za testove,"    public function removeAllByUserId($userId)    {        $this->getEntityManager()            ->createQuery('DELETE FROM Wallabag\AnnotationBundle\Entity\Annotation a WHERE a.user = :userId')            ->setParameter('userId', $userId)            ->execute();    }",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
249,Intervention_image_AbstractDriver_444, Returns classname of given command name\\n\\n @param  string $name\\n @return string\\n,Vraća ime klase za dato imena naredbe,"    private function getCommandClassName($name)    {        $name = mb_convert_case($name[0], MB_CASE_UPPER, 'utf-8') . mb_substr($name, 1, mb_strlen($name));                $drivername = $this->getDriverName();        $classnameLocal = sprintf('\Intervention\Image\%s\Commands\%sCommand', $drivername, ucfirst($name));        $classnameGlobal = sprintf('\Intervention\Image\Commands\%sCommand', ucfirst($name));        if (class_exists($classnameLocal)) {            return $classnameLocal;        } elseif (class_exists($classnameGlobal)) {            return $classnameGlobal;        }        throw new NotSupportedException(            ""Command ({$name}) is not available for driver ({$drivername}).""        );    }",2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
250,Intervention_image_Font_592, Calculates bounding box of current font setting\n\n @return Array\n,Izračunava granični okvir trenutne postavke fonta,"    public function getBoxSize()    {        $box = [];        if ($this->hasApplicableFontFile()) {            // imagettfbbox() converts numeric entities to their respective            // character. Preserve any originally double encoded entities to be            // represented as is.            // eg: &amp;#160; will render &#160; rather than its character.            $this->text = preg_replace('/&(#(?:x[a-fA-F0-9]+|[0-9]+);)/', '&#38;\1', $this->text);            $this->text = mb_encode_numericentity($this->text, array(0x0080, 0xffff, 0, 0xffff), 'UTF-8');            // get bounding box with angle 0            $box = imagettfbbox($this->getPointSize(), 0, $this->file, $this->text);            // rotate points manually            if ($this->angle != 0) {                $angle = pi() * 2 - $this->angle * pi() * 2 / 360;                for ($i=0; $i<4; $i++) {                    $x = $box[$i * 2];                    $y = $box[$i * 2 + 1];                    $box[$i * 2] = cos($angle) * $x - sin($angle) * $y;                    $box[$i * 2 + 1] = sin($angle) * $x + cos($angle) * $y;                }            }            $box['width'] = intval(abs($box[4] - $box[0]));            $box['height'] = intval(abs($box[5] - $box[1]));        } else {            // get current internal font size            $width = $this->getInternalFontWidth();            $height = $this->getInternalFontHeight();            if (strlen($this->text) == 0) {                // no text -> no boxsize                $box['width'] = 0;                $box['height'] = 0;            } else {                // calculate boxsize                $box['width'] = strlen($this->text) * $width;                $box['height'] = $height;            }        }        return $box;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
251,PHPOffice_PHPExcel_Calculation_151, Wrap string values in quotes\\\\n\\\\n @param mixed $value\\\\n @return mixed\\\\n,Obmotajte vrednosti niza u navodnike,"    public static function wrapResult($value)    {        if (is_string($value)) {            //    Error values cannot be ""wrapped""            if (preg_match('/^'.self::CALCULATION_REGEXP_ERROR.'$/i', $value, $match)) {                //    Return Excel errors ""as is""                return $value;            }            //    Return strings wrapped in quotes            return '""'.$value.'""';        //    Convert numeric errors to NaN error        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {            return PHPExcel_Calculation_Functions::NaN();        }        return $value;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
252,markrogoyski_math-php_Eigenvalue_2614," Produces the Eigenvalues for square 2x2 - 4x4 matricies\n\n Given a matrix\n      [a b]\n A =  [c d]\n\n Find all Î» such that:\n      |A-IÎ»| = 0\n\n This is accomplished by finding the roots of the polyniomial that\n is produced when computing the determinant of the matrix. The determinant\n polynomial is calculated using polynomial arithmetic.\n\n @param NumericMatrix $A\n\n @return float[] of eigenvalues\n\n @throws Exception\\BadDataException if the matrix is not square\n @throws Exception\\BadDataException if the matrix is not 2x2, 3x3, or 4x4\n @throws Exception\\MathException\n",Izrađuje sopstvene vrednosti za kvadratne matrice 2x2 - 4x4 \ n \ n Dat je matrica [a b]\n A =  [c d]. Pronađi sve Î »takve da:  |A-IÎ»| = 0. To se postiže pronalaženjem korena poliniomija koji nastaje prilikom izračunavanja odrednice matrice. Odrednica polinom izračunava se pomoću polinomske aritmetike,"    public static function closedFormPolynomialRootMethod(NumericMatrix $A): array    {        self::checkMatrix($A);        $m = $A->getM();        if ($m < 2 || $m > 4) {            throw new Exception\BadDataException(""Matrix must be 2x2, 3x3, or 4x4. $m x $m given"");        }        // Convert the numerical matrix into an ObjectMatrix        $B_array = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $m; $j++) {                $B_array[$i][$j] = new Polynomial([$A[$i][$j]], 'Î»');            }        }        $B = MatrixFactory::create($B_array);        // Create a diagonal Matrix of lambda (IÎ»)        $Î»_poly    = new Polynomial([1, 0], 'Î»');        $zero_poly = new Polynomial([0], 'Î»');        $Î»_array   = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $m; $j++) {                $Î»_array[$i][$j] = ($i == $j)                    ? $Î»_poly                    : $zero_poly;            }        }        /** @var ObjectSquareMatrix $Î» */        $Î» = MatrixFactory::create($Î»_array);        /** @var ObjectSquareMatrix $âŸ®BÂ âˆ’Â Î»âŸ¯ Subtract IÎ» from B */        $âŸ®BÂ âˆ’Â Î»âŸ¯ = $B->subtract($Î»);        /** @var Polynomial $det The Eigenvalues are the roots of the determinant of this matrix */        $det = $âŸ®BÂ âˆ’Â Î»âŸ¯->det();        // Calculate the roots of the determinant.        $eigenvalues = $det->roots();        \usort($eigenvalues, function ($a, $b) {            return \abs($b) <=> \abs($a);        });        return $eigenvalues;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
253,nikic_PHP-Parser_BuilderHelpers_28, This class defines helpers used in the implementation of builders. Don't use it directly.\n\n @internal\n,Ova klasa definiše pomagače koji se koriste u implementaciji graditelja. Ne koristite ga direktno,"final class BuilderHelpers{    /**     * Normalizes a node: Converts builder objects to nodes.     *     * @param Node|Builder $node The node to normalize     *     * @return Node The normalized node     */    public static function normalizeNode($node) : Node {        if ($node instanceof Builder) {            return $node->getNode();        } elseif ($node instanceof Node) {            return $node;        }        throw new \LogicException('Expected node or builder object');    }    /**     * Normalizes a node to a statement.     *     * Expressions are wrapped in a Stmt\Expression node.     *     * @param Node|Builder $node The node to normalize     *     * @return Stmt The normalized statement node     */    public static function normalizeStmt($node) : Stmt {        $node = self::normalizeNode($node);        if ($node instanceof Stmt) {            return $node;        }        if ($node instanceof Expr) {            return new Stmt\Expression($node);        }        throw new \LogicException('Expected statement or expression node');    }    /**     * Normalizes strings to Identifier.     *     * @param string|Identifier $name The identifier to normalize     *     * @return Identifier The normalized identifier     */    public static function normalizeIdentifier($name) : Identifier {        if ($name instanceof Identifier) {            return $name;        }        if (\is_string($name)) {            return new Identifier($name);        }        throw new \LogicException('Expected string or instance of Node\Identifier');    }    /**     * Normalizes strings to Identifier, also allowing expressions.     *     * @param string|Identifier|Expr $name The identifier to normalize     *     * @return Identifier|Expr The normalized identifier or expression     */    public static function normalizeIdentifierOrExpr($name) {        if ($name instanceof Identifier || $name instanceof Expr) {            return $name;        }        if (\is_string($name)) {            return new Identifier($name);        }        throw new \LogicException('Expected string or instance of Node\Identifier or Node\Expr');    }    /**     * Normalizes a name: Converts string names to Name nodes.     *     * @param Name|string $name The name to normalize     *     * @return Name The normalized name     */    public static function normalizeName($name) : Name {        return self::normalizeNameCommon($name, false);    }    /**     * Normalizes a name: Converts string names to Name nodes, while also allowing expressions.     *     * @param Expr|Name|string $name The name to normalize     *     * @return Name|Expr The normalized name or expression     */    public static function normalizeNameOrExpr($name) {        return self::normalizeNameCommon($name, true);    }    /**     * Normalizes a name: Converts string names to Name nodes, optionally allowing expressions.     *     * @param Expr|Name|string $name      The name to normalize     * @param bool             $allowExpr Whether to also allow expressions     *     * @return Name|Expr The normalized name, or expression (if allowed)     */    private static function normalizeNameCommon($name, bool $allowExpr) {        if ($name instanceof Name) {            return $name;        } elseif (is_string($name)) {            if (!$name) {                throw new \LogicException('Name cannot be empty');            }            if ($name[0] === '\\') {                return new Name\FullyQualified(substr($name, 1));            } elseif (0 === strpos($name, 'namespace\\')) {                return new Name\Relative(substr($name, strlen('namespace\\')));            } else {                return new Name($name);            }        }        if ($allowExpr) {            if ($name instanceof Expr) {                return $name;            }            throw new \LogicException(                'Name must be a string or an instance of Node\Name or Node\Expr'            );        } else {            throw new \LogicException('Name must be a string or an instance of Node\Name');        }    }    /**     * Normalizes a type: Converts plain-text type names into proper AST representation.     *     * In particular, builtin types become Identifiers, custom types become Names and nullables     * are wrapped in NullableType nodes.     *     * @param string|Name|Identifier|NullableType|UnionType $type The type to normalize     *     * @return Name|Identifier|NullableType|UnionType The normalized type     */    public static function normalizeType($type) {        if (!is_string($type)) {            if (                !$type instanceof Name && !$type instanceof Identifier &&                !$type instanceof NullableType && !$type instanceof UnionType            ) {                throw new \LogicException(                    'Type must be a string, or an instance of Name, Identifier, NullableType or UnionType'                );            }            return $type;        }        $nullable = false;        if (strlen($type) > 0 && $type[0] === '?') {            $nullable = true;            $type = substr($type, 1);        }        $builtinTypes = [            'array', 'callable', 'string', 'int', 'float', 'bool', 'iterable', 'void', 'object', 'mixed'        ];        $lowerType = strtolower($type);        if (in_array($lowerType, $builtinTypes)) {            $type = new Identifier($lowerType);        } else {            $type = self::normalizeName($type);        }        if ($nullable && (string) $type === 'void') {            throw new \LogicException('void type cannot be nullable');        }        if ($nullable && (string) $type === 'mixed') {            throw new \LogicException('mixed type cannot be nullable');        }        return $nullable ? new NullableType($type) : $type;    }    /**     * Normalizes a value: Converts nulls, booleans, integers,     * floats, strings and arrays into their respective nodes     *     * @param Node\Expr|bool|null|int|float|string|array $value The value to normalize     *     * @return Expr The normalized value     */    public static function normalizeValue($value) : Expr {        if ($value instanceof Node\Expr) {            return $value;        } elseif (is_null($value)) {            return new Expr\ConstFetch(                new Name('null')            );        } elseif (is_bool($value)) {            return new Expr\ConstFetch(                new Name($value ? 'true' : 'false')            );        } elseif (is_int($value)) {            return new Scalar\LNumber($value);        } elseif (is_float($value)) {            return new Scalar\DNumber($value);        } elseif (is_string($value)) {            return new Scalar\String_($value);        } elseif (is_array($value)) {            $items = [];            $lastKey = -1;            foreach ($value as $itemKey => $itemValue) {                // for consecutive, numeric keys don't generate keys                if (null !== $lastKey && ++$lastKey === $itemKey) {                    $items[] = new Expr\ArrayItem(                        self::normalizeValue($itemValue)                    );                } else {                    $lastKey = null;                    $items[] = new Expr\ArrayItem(                        self::normalizeValue($itemValue),                        self::normalizeValue($itemKey)                    );                }            }            return new Expr\Array_($items);        } else {            throw new \LogicException('Invalid value');        }    }    /**     * Normalizes a doc comment: Converts plain strings to PhpParser\Comment\Doc.     *     * @param Comment\Doc|string $docComment The doc comment to normalize     *     * @return Comment\Doc The normalized doc comment     */    public static function normalizeDocComment($docComment) : Comment\Doc {        if ($docComment instanceof Comment\Doc) {            return $docComment;        } elseif (is_string($docComment)) {            return new Comment\Doc($docComment);        } else {            throw new \LogicException('Doc comment must be a string or an instance of PhpParser\Comment\Doc');        }    }    /**     * Adds a modifier and returns new modifier bitmask.     *     * @param int $modifiers Existing modifiers     * @param int $modifier  Modifier to set     *     * @return int New modifiers     */    public static function addModifier(int $modifiers, int $modifier) : int {        Stmt\Class_::verifyModifier($modifiers, $modifier);        return $modifiers | $modifier;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
254,ramsey_uuid_FeatureSet_1941, Sets the calculator to use in this environment\\n,Podešava kalkulator za upotrebu u ovom okruženju,    public function setCalculator(CalculatorInterface $calculator): void    {        $this->calculator = $calculator;        $this->numberConverter = $this->buildNumberConverter($calculator);        $this->timeConverter = $this->buildTimeConverter($calculator);        if (isset($this->timeProvider)) {            $this->timeGenerator = $this->buildTimeGenerator($this->timeProvider);        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
255,ramsey_uuid_FeatureSet_1952, Returns a time converter configured for this environment\n,Vraća pretvarač vremena konfigurisan za ovo okruženje,"    private function buildTimeConverter(CalculatorInterface $calculator): TimeConverterInterface    {        $genericConverter = new GenericTimeConverter($calculator);        if ($this->is64BitSystem()) {            return new PhpTimeConverter($calculator, $genericConverter);        }        return $genericConverter;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
256,ramsey_uuid_UuidTest_2049, Tests that generated UUID's using timestamp last COMB are sequential\\n,Testovi koji su generisali UUID koristeći vremensku oznaku poslednji COMB su sekvencijalni,"    public function testUuid4TimestampLastComb(): void    {        $mock = $this->getMockBuilder(RandomGeneratorInterface::class)->getMock();        $mock->expects($this->any())            ->method('generate')            ->willReturnCallback(function ($length) {                // Makes first fields of UUIDs equal                return hex2bin(str_pad('', $length * 2, '0'));            });        $factory = new UuidFactory();        $generator = new CombGenerator($mock, $factory->getNumberConverter());        $codec = new TimestampLastCombCodec($factory->getUuidBuilder());        $factory->setRandomGenerator($generator);        $factory->setCodec($codec);        $previous = $factory->uuid4();        for ($i = 0; $i < 1000; $i++) {            usleep(100);            $uuid = $factory->uuid4();            $this->assertGreaterThan($previous->toString(), $uuid->toString());            $previous = $uuid;        }    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
257,ramsey_uuid_Uuid_1959, Re-constructs the object from its serialized form\n\n @param string $serialized The serialized PHP string to unserialize into\n     a UuidInterface instance\n\n @phpcsSuppress SlevomatCodingStandard.TypeHints.ParameterTypeHint.MissingNativeTypeHint\n,Ponovo konstruiše objekat iz njegovog serializovanog oblika,    public function unserialize($serialized): void    {        if (strlen($serialized) === 16) {            /** @var Uuid $uuid */            $uuid = self::getFactory()->fromBytes($serialized);        } else {            /** @var Uuid $uuid */            $uuid = self::getFactory()->fromString($serialized);        }        $this->codec = $uuid->codec;        $this->numberConverter = $uuid->numberConverter;        $this->fields = $uuid->fields;        $this->timeConverter = $uuid->timeConverter;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
258,symfony_finder_FilenameFilterIterator_414," FilenameFilterIterator filters files by patterns (a regexp, a glob, or a string).\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n","FilenameFilterIterator filtrira datoteke prema obrascima (regularni izraz, glob ili string)","class FilenameFilterIterator extends MultiplePcreFilterIterator{    /**     * Filters the iterator values.     *     * @return bool true if the value should be kept, false otherwise     */    public function accept()    {        return $this->isAccepted($this->current()->getFilename());    }    /**     * Converts glob to regexp.     *     * PCRE patterns are left unchanged.     * Glob strings are transformed with Glob::toRegex().     *     * @param string $str Pattern: glob or regexp     *     * @return string regexp corresponding to a given glob or regexp     */    protected function toRegex(string $str)    {        return $this->isRegex($str) ? $str : Glob::toRegex($str);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
259,symfony_http-kernel_Extension_3224, Adds annotated classes to the class cache.\n\n @param array $annotatedClasses An array of class patterns\n,Dodaje označene klase u keš klasu,"class HttpKernelBrowser extends AbstractBrowser{    protected $kernel;    private $catchExceptions = true;    /**     * @param array $server The server parameters (equivalent of $_SERVER)     */    public function __construct(HttpKernelInterface $kernel, array $server = [], History $history = null, CookieJar $cookieJar = null)    {        // These class properties must be set before calling the parent constructor, as it may depend on it.        $this->kernel = $kernel;        $this->followRedirects = false;        parent::__construct($server, $history, $cookieJar);    }    /**     * Sets whether to catch exceptions when the kernel is handling a request.     */    public function catchExceptions(bool $catchExceptions)    {        $this->catchExceptions = $catchExceptions;    }    /**     * Makes a request.     *     * @return Response A Response instance     */    protected function doRequest($request)    {        $response = $this->kernel->handle($request, HttpKernelInterface::MAIN_REQUEST, $this->catchExceptions);        if ($this->kernel instanceof TerminableInterface) {            $this->kernel->terminate($request, $response);        }        return $response;    }    /**     * Returns the script to execute when the request must be insulated.     *     * @return string     */    protected function getScript($request)    {        $kernel = var_export(serialize($this->kernel), true);        $request = var_export(serialize($request), true);        $errorReporting = error_reporting();        $requires = '';        foreach (get_declared_classes() as $class) {            if (0 === strpos($class, 'ComposerAutoloaderInit')) {                $r = new \ReflectionClass($class);                $file = \dirname($r->getFileName(), 2).'/autoload.php';                if (file_exists($file)) {                    $requires .= 'require_once '.var_export($file, true)."";\n"";                }            }        }        if (!$requires) {            throw new \RuntimeException('Composer autoloader not found.');        }        $code = <<<EOF<?phperror_reporting($errorReporting);$requires\$kernel = unserialize($kernel);\$request = unserialize($request);EOF;        return $code.$this->getHandleScript();    }    protected function getHandleScript()    {        return <<<'EOF'$response = $kernel->handle($request);if ($kernel instanceof Symfony\Component\HttpKernel\TerminableInterface) {    $kernel->terminate($request, $response);}echo serialize($response);EOF;    }    /**     * Converts the BrowserKit request to a HttpKernel request.     *     * @return Request A Request instance     */    protected function filterRequest(DomRequest $request)    {        $httpRequest = Request::create($request->getUri(), $request->getMethod(), $request->getParameters(), $request->getCookies(), $request->getFiles(), $server = $request->getServer(), $request->getContent());        if (!isset($server['HTTP_ACCEPT'])) {            $httpRequest->headers->remove('Accept');        }        foreach ($this->filterFiles($httpRequest->files->all()) as $key => $value) {            $httpRequest->files->set($key, $value);        }        return $httpRequest;    }    /**     * Filters an array of files.     *     * This method created test instances of UploadedFile so that the move()     * method can be called on those instances.     *     * If the size of a file is greater than the allowed size (from php.ini) then     * an invalid UploadedFile is returned with an error set to UPLOAD_ERR_INI_SIZE.     *     * @see UploadedFile     *     * @return array An array with all uploaded files marked as already moved     */    protected function filterFiles(array $files)    {        $filtered = [];        foreach ($files as $key => $value) {            if (\is_array($value)) {                $filtered[$key] = $this->filterFiles($value);            } elseif ($value instanceof UploadedFile) {                if ($value->isValid() && $value->getSize() > UploadedFile::getMaxFilesize()) {                    $filtered[$key] = new UploadedFile(                        '',                        $value->getClientOriginalName(),                        $value->getClientMimeType(),                        \UPLOAD_ERR_INI_SIZE,                        true                    );                } else {                    $filtered[$key] = new UploadedFile(                        $value->getPathname(),                        $value->getClientOriginalName(),                        $value->getClientMimeType(),                        $value->getError(),                        true                    );                }            }        }        return $filtered;    }    /**     * Converts the HttpKernel response to a BrowserKit response.     *     * @return DomResponse A DomResponse instance     */    protected function filterResponse($response)    {        // this is needed to support StreamedResponse        ob_start();        $response->sendContent();        $content = ob_get_clean();        return new DomResponse($content, $response->getStatusCode(), $response->headers->all());    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
260,symfony_http-kernel_HttpKernelBrowser_3027, Makes a request.\n\n @return Response A Response instance\n,Podnosi zahtev,"class HttpKernel implements HttpKernelInterface, TerminableInterface{    protected $dispatcher;    protected $resolver;    protected $requestStack;    private $argumentResolver;    public function __construct(EventDispatcherInterface $dispatcher, ControllerResolverInterface $resolver, RequestStack $requestStack = null, ArgumentResolverInterface $argumentResolver = null)    {        $this->dispatcher = $dispatcher;        $this->resolver = $resolver;        $this->requestStack = $requestStack ?? new RequestStack();        $this->argumentResolver = $argumentResolver;        if (null === $this->argumentResolver) {            $this->argumentResolver = new ArgumentResolver();        }    }    /**     * {@inheritdoc}     */    public function handle(Request $request, int $type = HttpKernelInterface::MAIN_REQUEST, bool $catch = true)    {        $request->headers->set('X-Php-Ob-Level', (string) ob_get_level());        try {            return $this->handleRaw($request, $type);        } catch (\Exception $e) {            if ($e instanceof RequestExceptionInterface) {                $e = new BadRequestHttpException($e->getMessage(), $e);            }            if (false === $catch) {                $this->finishRequest($request, $type);                throw $e;            }            return $this->handleThrowable($e, $request, $type);        }    }    /**     * {@inheritdoc}     */    public function terminate(Request $request, Response $response)    {        $this->dispatcher->dispatch(new TerminateEvent($this, $request, $response), KernelEvents::TERMINATE);    }    /**     * @internal     */    public function terminateWithException(\Throwable $exception, Request $request = null)    {        if (!$request = $request ?: $this->requestStack->getMainRequest()) {            throw $exception;        }        $response = $this->handleThrowable($exception, $request, self::MAIN_REQUEST);        $response->sendHeaders();        $response->sendContent();        $this->terminate($request, $response);    }    /**     * Handles a request to convert it to a response.     *     * Exceptions are not caught.     *     * @throws \LogicException       If one of the listener does not behave as expected     * @throws NotFoundHttpException When controller cannot be found     */    private function handleRaw(Request $request, int $type = self::MAIN_REQUEST): Response    {        $this->requestStack->push($request);        // request        $event = new RequestEvent($this, $request, $type);        $this->dispatcher->dispatch($event, KernelEvents::REQUEST);        if ($event->hasResponse()) {            return $this->filterResponse($event->getResponse(), $request, $type);        }        // load controller        if (false === $controller = $this->resolver->getController($request)) {            throw new NotFoundHttpException(sprintf('Unable to find the controller for path ""%s"". The route is wrongly configured.', $request->getPathInfo()));        }        $event = new ControllerEvent($this, $controller, $request, $type);        $this->dispatcher->dispatch($event, KernelEvents::CONTROLLER);        $controller = $event->getController();        // controller arguments        $arguments = $this->argumentResolver->getArguments($request, $controller);        $event = new ControllerArgumentsEvent($this, $controller, $arguments, $request, $type);        $this->dispatcher->dispatch($event, KernelEvents::CONTROLLER_ARGUMENTS);        $controller = $event->getController();        $arguments = $event->getArguments();        // call controller        $response = $controller(...$arguments);        // view        if (!$response instanceof Response) {            $event = new ViewEvent($this, $request, $type, $response);            $this->dispatcher->dispatch($event, KernelEvents::VIEW);            if ($event->hasResponse()) {                $response = $event->getResponse();            } else {                $msg = sprintf('The controller must return a ""Symfony\Component\HttpFoundation\Response"" object but it returned %s.', $this->varToString($response));                // the user may have forgotten to return something                if (null === $response) {                    $msg .= ' Did you forget to add a return statement somewhere in your controller?';                }                throw new ControllerDoesNotReturnResponseException($msg, $controller, __FILE__, __LINE__ - 17);            }        }        return $this->filterResponse($response, $request, $type);    }    /**     * Filters a response object.     *     * @throws \RuntimeException if the passed object is not a Response instance     */    private function filterResponse(Response $response, Request $request, int $type): Response    {        $event = new ResponseEvent($this, $request, $type, $response);        $this->dispatcher->dispatch($event, KernelEvents::RESPONSE);        $this->finishRequest($request, $type);        return $event->getResponse();    }    /**     * Publishes the finish request event, then pop the request from the stack.     *     * Note that the order of the operations is important here, otherwise     * operations such as {@link RequestStack::getParentRequest()} can lead to     * weird results.     */    private function finishRequest(Request $request, int $type)    {        $this->dispatcher->dispatch(new FinishRequestEvent($this, $request, $type), KernelEvents::FINISH_REQUEST);        $this->requestStack->pop();    }    /**     * Handles a throwable by trying to convert it to a Response.     *     * @throws \Exception     */    private function handleThrowable(\Throwable $e, Request $request, int $type): Response    {        $event = new ExceptionEvent($this, $request, $type, $e);        $this->dispatcher->dispatch($event, KernelEvents::EXCEPTION);        // a listener might have replaced the exception        $e = $event->getThrowable();        if (!$event->hasResponse()) {            $this->finishRequest($request, $type);            throw $e;        }        $response = $event->getResponse();        // the developer asked for a specific status code        if (!$event->isAllowingCustomResponseCode() && !$response->isClientError() && !$response->isServerError() && !$response->isRedirect()) {            // ensure that we actually have an error response            if ($e instanceof HttpExceptionInterface) {                // keep the HTTP status code and headers                $response->setStatusCode($e->getStatusCode());                $response->headers->add($e->getHeaders());            } else {                $response->setStatusCode(500);            }        }        try {            return $this->filterResponse($response, $request, $type);        } catch (\Exception $e) {            return $response;        }    }    /**     * Returns a human-readable string for the specified variable.     */    private function varToString($var): string    {        if (\is_object($var)) {            return sprintf('an object of type %s', \get_class($var));        }        if (\is_array($var)) {            $a = [];            foreach ($var as $k => $v) {                $a[] = sprintf('%s => ...', $k);            }            return sprintf('an array ([%s])', mb_substr(implode(', ', $a), 0, 255));        }        if (\is_resource($var)) {            return sprintf('a resource (%s)', get_resource_type($var));        }        if (null === $var) {            return 'null';        }        if (false === $var) {            return 'a boolean value (false)';        }        if (true === $var) {            return 'a boolean value (true)';        }        if (\is_string($var)) {            return sprintf('a string (""%s%s"")', mb_substr($var, 0, 255), mb_strlen($var) > 255 ? '...' : '');        }        if (is_numeric($var)) {            return sprintf('a number (%s)', (string) $var);        }        return (string) $var;    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
263,tennc_webshell_Ani-Shell_1003, Get the directory size\n @param directory $directory\n @return integer\n,Uzmite veličinu direktorijuma,"function shell($cmd){if (!empty($cmd)){  $fp = popen($cmd,""r"");  {    $result = """";    while(!feof($fp)){$result.=fread($fp,1024);}    pclose($fp);  }  $ret = $result;  $ret = convert_cyr_string($ret,""d"",""w"");}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
264,thephpleague_oauth2-server_AuthorizationServer_3455, Return an access token response.\n\n @param ServerRequestInterface $request\n @param ResponseInterface      $response\n\n @throws OAuthServerException\n\n @return ResponseInterface\n,Vraća odgovor tokena pristupa,    private function convertSingleRecordAudToString($aud)    {        return \is_array($aud) && \count($aud) === 1 ? $aud[0] : $aud;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
265,guzzle_promises_Promise_717," It's a success, so resolve the handlers in the queue.\n","Uspešno je prošlo, razrešava hendlere u redu","            Utils::queue()->add(static function () use ($id, $value, $handlers) {                foreach ($handlers as $handler) {                    self::callHandler($id, $value, $handler);                }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
266,mockery_mockery_Expectation_468," Set a return value, or sequential queue of return values\\\\n\\\\n @param mixed ...$args\\\\n @return self\\\\n",Postavite povratnu vrednost ili sekvencijalni red povratnih vrednosti,"    public function andReturns(...$args)    {        return call_user_func_array([$this, 'andReturn'], $args);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
267,mockery_mockery_Expectation_470, Set a sequential queue of return values with an array\n\n @param array $values\n @return self\n,Postavite sekvencijalni red povratnih vrednosti pomoću niza,"    public function andReturnValues(array $values)    {        call_user_func_array(array($this, 'andReturn'), $values);        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
268,phalcon_cphalcon_Autoloader_1549, Add autoloader to autoloaders queue\\n,Dodajte autoloader u red autoloadera,"    public function register()    {        spl_autoload_register(array($this, 'autoload'));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
270,mockery_mockery_Expectation_476, Register values to be set to a public property each time this expectation occurs\\\\\\\\n\\\\\\\\n @param string $name\\\\\\\\n @param array ...$values\\\\\\\\n @return self\\\\\\\\n,Registrujte vrednosti koje će biti postavljene na javno svojstvo svaki put kada se ovo očekuje,"    public function andSet($name, ...$values)    {        $this->_setQueue[$name] = $values;        return $this;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
271,squizlabs_PHP_CodeSniffer_Runner_911, Performs the run.\n\n @return int The number of errors and warnings found.\n @throws \\PHP_CodeSniffer\\Exceptions\\DeepExitException\n @throws \\PHP_CodeSniffer\\Exceptions\\RuntimeException\n,Izvodi pokretanje,"    private function run()    {        // The class that manages all reporters for the run.        $this->reporter = new Reporter($this->config);        // Include bootstrap files.        foreach ($this->config->bootstrap as $bootstrap) {            include $bootstrap;        }        if ($this->config->stdin === true) {            $fileContents = $this->config->stdinContent;            if ($fileContents === null) {                $handle = fopen('php://stdin', 'r');                stream_set_blocking($handle, true);                $fileContents = stream_get_contents($handle);                fclose($handle);            }            $todo  = new FileList($this->config, $this->ruleset);            $dummy = new DummyFile($fileContents, $this->ruleset, $this->config);            $todo->addFile($dummy->path, $dummy);        } else {            if (empty($this->config->files) === true) {                $error  = 'ERROR: You must supply at least one file or directory to process.'.PHP_EOL.PHP_EOL;                $error .= $this->config->printShortUsage(true);                throw new DeepExitException($error, 3);            }            if (PHP_CODESNIFFER_VERBOSITY > 0) {                echo 'Creating file list... ';            }            $todo = new FileList($this->config, $this->ruleset);            if (PHP_CODESNIFFER_VERBOSITY > 0) {                $numFiles = count($todo);                echo ""DONE ($numFiles files in queue)"".PHP_EOL;            }            if ($this->config->cache === true) {                if (PHP_CODESNIFFER_VERBOSITY > 0) {                    echo 'Loading cache... ';                }                Cache::load($this->ruleset, $this->config);                if (PHP_CODESNIFFER_VERBOSITY > 0) {                    $size = Cache::getSize();                    echo ""DONE ($size files in cache)"".PHP_EOL;                }            }        }//end if        // Turn all sniff errors into exceptions.        set_error_handler([$this, 'handleErrors']);        // If verbosity is too high, turn off parallelism so the        // debug output is clean.        if (PHP_CODESNIFFER_VERBOSITY > 1) {            $this->config->parallel = 1;        }        // If the PCNTL extension isn't installed, we can't fork.        if (function_exists('pcntl_fork') === false) {            $this->config->parallel = 1;        }        $lastDir  = '';        $numFiles = count($todo);        if ($this->config->parallel === 1) {            // Running normally.            $numProcessed = 0;            foreach ($todo as $path => $file) {                if ($file->ignored === false) {                    $currDir = dirname($path);                    if ($lastDir !== $currDir) {                        if (PHP_CODESNIFFER_VERBOSITY > 0) {                            echo 'Changing into directory '.Common::stripBasepath($currDir, $this->config->basepath).PHP_EOL;                        }                        $lastDir = $currDir;                    }                    $this->processFile($file);                } else if (PHP_CODESNIFFER_VERBOSITY > 0) {                    echo 'Skipping '.basename($file->path).PHP_EOL;                }                $numProcessed++;                $this->printProgress($file, $numFiles, $numProcessed);            }        } else {            // Batching and forking.            $childProcs  = [];            $numPerBatch = ceil($numFiles / $this->config->parallel);            for ($batch = 0; $batch < $this->config->parallel; $batch++) {                $startAt = ($batch * $numPerBatch);                if ($startAt >= $numFiles) {                    break;                }                $endAt = ($startAt + $numPerBatch);                if ($endAt > $numFiles) {                    $endAt = $numFiles;                }                $childOutFilename = tempnam(sys_get_temp_dir(), 'phpcs-child');                $pid = pcntl_fork();                if ($pid === -1) {                    throw new RuntimeException('Failed to create child process');                } else if ($pid !== 0) {                    $childProcs[] = [                        'pid' => $pid,                        'out' => $childOutFilename,                    ];                } else {                    // Move forward to the start of the batch.                    $todo->rewind();                    for ($i = 0; $i < $startAt; $i++) {                        $todo->next();                    }                    // Reset the reporter to make sure only figures from this                    // file batch are recorded.                    $this->reporter->totalFiles    = 0;                    $this->reporter->totalErrors   = 0;                    $this->reporter->totalWarnings = 0;                    $this->reporter->totalFixable  = 0;                    $this->reporter->totalFixed    = 0;                    // Process the files.                    $pathsProcessed = [];                    ob_start();                    for ($i = $startAt; $i < $endAt; $i++) {                        $path = $todo->key();                        $file = $todo->current();                        if ($file->ignored === true) {                            $todo->next();                            continue;                        }                        $currDir = dirname($path);                        if ($lastDir !== $currDir) {                            if (PHP_CODESNIFFER_VERBOSITY > 0) {                                echo 'Changing into directory '.Common::stripBasepath($currDir, $this->config->basepath).PHP_EOL;                            }                            $lastDir = $currDir;                        }                        $this->processFile($file);                        $pathsProcessed[] = $path;                        $todo->next();                    }//end for                    $debugOutput = ob_get_contents();                    ob_end_clean();                    // Write information about the run to the filesystem                    // so it can be picked up by the main process.                    $childOutput = [                        'totalFiles'    => $this->reporter->totalFiles,                        'totalErrors'   => $this->reporter->totalErrors,                        'totalWarnings' => $this->reporter->totalWarnings,                        'totalFixable'  => $this->reporter->totalFixable,                        'totalFixed'    => $this->reporter->totalFixed,                    ];                    $output  = '<'.'?php'.""\n"".' $childOutput = ';                    $output .= var_export($childOutput, true);                    $output .= "";\n\$debugOutput = "";                    $output .= var_export($debugOutput, true);                    if ($this->config->cache === true) {                        $childCache = [];                        foreach ($pathsProcessed as $path) {                            $childCache[$path] = Cache::get($path);                        }                        $output .= "";\n\$childCache = "";                        $output .= var_export($childCache, true);                    }                    $output .= "";\n?"".'>';                    file_put_contents($childOutFilename, $output);                    exit($pid);                }//end if            }//end for            $success = $this->processChildProcs($childProcs);            if ($success === false) {                throw new RuntimeException('One or more child processes failed to run');            }        }//end if        restore_error_handler();        if (PHP_CODESNIFFER_VERBOSITY === 0            && $this->config->interactive === false            && $this->config->showProgress === true        ) {            echo PHP_EOL.PHP_EOL;        }        if ($this->config->cache === true) {            Cache::save();        }        $ignoreWarnings = Config::getConfigData('ignore_warnings_on_exit');        $ignoreErrors   = Config::getConfigData('ignore_errors_on_exit');        $return = ($this->reporter->totalErrors + $this->reporter->totalWarnings);        if ($ignoreErrors !== null) {            $ignoreErrors = (bool) $ignoreErrors;            if ($ignoreErrors === true) {                $return -= $this->reporter->totalErrors;            }        }        if ($ignoreWarnings !== null) {            $ignoreWarnings = (bool) $ignoreWarnings;            if ($ignoreWarnings === true) {                $return -= $this->reporter->totalWarnings;            }        }        return $return;    }//end run()",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
272,symfony_var-dumper_Stub_9244, Represents the main properties of a PHP variable.\n\n @author Nicolas Grekas <p@tchwork.com>\n,Predstavlja glavna svojstva PHP promenljive,"    protected function doClone($var)    {        $len = 1;                       // Length of $queue        $pos = 0;                       // Number of cloned items past the minimum depth        $refsCounter = 0;               // Hard references counter        $queue = [[$var]];    // This breadth-first queue is the return value        $hardRefs = [];            // Map of original zval ids to stub objects        $objRefs = [];             // Map of original object handles to their stub object counterpart        $objects = [];             // Keep a ref to objects to ensure their handle cannot be reused while cloning        $resRefs = [];             // Map of original resource handles to their stub object counterpart        $values = [];              // Map of stub objects' ids to original values        $maxItems = $this->maxItems;        $maxString = $this->maxString;        $minDepth = $this->minDepth;        $currentDepth = 0;              // Current tree depth        $currentDepthFinalIndex = 0;    // Final $queue index for current tree depth        $minimumDepthReached = 0 === $minDepth; // Becomes true when minimum tree depth has been reached        $cookie = (object) [];          // Unique object used to detect hard references        $a = null;                      // Array cast for nested structures        $stub = null;                   // Stub capturing the main properties of an original item value                                        // or null if the original value is used directly        if (!$gid = self::$gid) {            $gid = self::$gid = md5(random_bytes(6)); // Unique string used to detect the special $GLOBALS variable        }        $arrayStub = new Stub();        $arrayStub->type = Stub::TYPE_ARRAY;        $fromObjCast = false;        for ($i = 0; $i < $len; ++$i) {            // Detect when we move on to the next tree depth            if ($i > $currentDepthFinalIndex) {                ++$currentDepth;                $currentDepthFinalIndex = $len - 1;                if ($currentDepth >= $minDepth) {                    $minimumDepthReached = true;                }            }            $refs = $vals = $queue[$i];            foreach ($vals as $k => $v) {                // $v is the original value or a stub object in case of hard references                if (\PHP_VERSION_ID >= 70400) {                    $zvalIsRef = null !== \ReflectionReference::fromArrayElement($vals, $k);                } else {                    $refs[$k] = $cookie;                    $zvalIsRef = $vals[$k] === $cookie;                }                if ($zvalIsRef) {                    $vals[$k] = &$stub;         // Break hard references to make $queue completely                    unset($stub);               // independent from the original structure                    if ($v instanceof Stub && isset($hardRefs[spl_object_id($v)])) {                        $vals[$k] = $refs[$k] = $v;                        if ($v->value instanceof Stub && (Stub::TYPE_OBJECT === $v->value->type || Stub::TYPE_RESOURCE === $v->value->type)) {                            ++$v->value->refCount;                        }                        ++$v->refCount;                        continue;                    }                    $refs[$k] = $vals[$k] = new Stub();                    $refs[$k]->value = $v;                    $h = spl_object_id($refs[$k]);                    $hardRefs[$h] = &$refs[$k];                    $values[$h] = $v;                    $vals[$k]->handle = ++$refsCounter;                }                // Create $stub when the original value $v can not be used directly                // If $v is a nested structure, put that structure in array $a                switch (true) {                    case null === $v:                    case \is_bool($v):                    case \is_int($v):                    case \is_float($v):                        continue 2;                    case \is_string($v):                        if ('' === $v) {                            continue 2;                        }                        if (!preg_match('//u', $v)) {                            $stub = new Stub();                            $stub->type = Stub::TYPE_STRING;                            $stub->class = Stub::STRING_BINARY;                            if (0 <= $maxString && 0 < $cut = \strlen($v) - $maxString) {                                $stub->cut = $cut;                                $stub->value = substr($v, 0, -$cut);                            } else {                                $stub->value = $v;                            }                        } elseif (0 <= $maxString && isset($v[1 + ($maxString >> 2)]) && 0 < $cut = mb_strlen($v, 'UTF-8') - $maxString) {                            $stub = new Stub();                            $stub->type = Stub::TYPE_STRING;                            $stub->class = Stub::STRING_UTF8;                            $stub->cut = $cut;                            $stub->value = mb_substr($v, 0, $maxString, 'UTF-8');                        } else {                            continue 2;                        }                        $a = null;                        break;                    case \is_array($v):                        if (!$v) {                            continue 2;                        }                        $stub = $arrayStub;                        $stub->class = Stub::ARRAY_INDEXED;                        $j = -1;                        foreach ($v as $gk => $gv) {                            if ($gk !== ++$j) {                                $stub->class = Stub::ARRAY_ASSOC;                                break;                            }                        }                        $a = $v;                        if (Stub::ARRAY_ASSOC === $stub->class) {                            // Copies of $GLOBALS have very strange behavior,                            // let's detect them with some black magic                            if (\PHP_VERSION_ID < 80100 && ($a[$gid] = true) && isset($v[$gid])) {                                unset($v[$gid]);                                $a = [];                                foreach ($v as $gk => &$gv) {                                    if ($v === $gv) {                                        unset($v);                                        $v = new Stub();                                        $v->value = [$v->cut = \count($gv), Stub::TYPE_ARRAY => 0];                                        $v->handle = -1;                                        $gv = &$hardRefs[spl_object_id($v)];                                        $gv = $v;                                    }                                    $a[$gk] = &$gv;                                }                                unset($gv);                            } else {                                $a = $v;                            }                        }                        break;                    case \is_object($v):                        if (empty($objRefs[$h = spl_object_id($v)])) {                            $stub = new Stub();                            $stub->type = Stub::TYPE_OBJECT;                            $stub->class = \get_class($v);                            $stub->value = $v;                            $stub->handle = $h;                            $a = $this->castObject($stub, 0 < $i);                            if ($v !== $stub->value) {                                if (Stub::TYPE_OBJECT !== $stub->type || null === $stub->value) {                                    break;                                }                                $stub->handle = $h = spl_object_id($stub->value);                            }                            $stub->value = null;                            if (0 <= $maxItems && $maxItems <= $pos && $minimumDepthReached) {                                $stub->cut = \count($a);                                $a = null;                            }                        }                        if (empty($objRefs[$h])) {                            $objRefs[$h] = $stub;                            $objects[] = $v;                        } else {                            $stub = $objRefs[$h];                            ++$stub->refCount;                            $a = null;                        }                        break;                    default: // resource                        if (empty($resRefs[$h = (int) $v])) {                            $stub = new Stub();                            $stub->type = Stub::TYPE_RESOURCE;                            if ('Unknown' === $stub->class = @get_resource_type($v)) {                                $stub->class = 'Closed';                            }                            $stub->value = $v;                            $stub->handle = $h;                            $a = $this->castResource($stub, 0 < $i);                            $stub->value = null;                            if (0 <= $maxItems && $maxItems <= $pos && $minimumDepthReached) {                                $stub->cut = \count($a);                                $a = null;                            }                        }                        if (empty($resRefs[$h])) {                            $resRefs[$h] = $stub;                        } else {                            $stub = $resRefs[$h];                            ++$stub->refCount;                            $a = null;                        }                        break;                }                if ($a) {                    if (!$minimumDepthReached || 0 > $maxItems) {                        $queue[$len] = $a;                        $stub->position = $len++;                    } elseif ($pos < $maxItems) {                        if ($maxItems < $pos += \count($a)) {                            $a = \array_slice($a, 0, $maxItems - $pos, true);                            if ($stub->cut >= 0) {                                $stub->cut += $pos - $maxItems;                            }                        }                        $queue[$len] = $a;                        $stub->position = $len++;                    } elseif ($stub->cut >= 0) {                        $stub->cut += \count($a);                        $stub->position = 0;                    }                }                if ($arrayStub === $stub) {                    if ($arrayStub->cut) {                        $stub = [$arrayStub->cut, $arrayStub->class => $arrayStub->position];                        $arrayStub->cut = 0;                    } elseif (isset(self::$arrayCache[$arrayStub->class][$arrayStub->position])) {                        $stub = self::$arrayCache[$arrayStub->class][$arrayStub->position];                    } else {                        self::$arrayCache[$arrayStub->class][$arrayStub->position] = $stub = [$arrayStub->class => $arrayStub->position];                    }                }                if ($zvalIsRef) {                    $refs[$k]->value = $stub;                } else {                    $vals[$k] = $stub;                }            }            if ($fromObjCast) {                $fromObjCast = false;                $refs = $vals;                $vals = [];                $j = -1;                foreach ($queue[$i] as $k => $v) {                    foreach ([$k => true] as $gk => $gv) {                    }                    if ($gk !== $k) {                        $vals = (object) $vals;                        $vals->{$k} = $refs[++$j];                        $vals = (array) $vals;                    } else {                        $vals[$k] = $refs[++$j];                    }                }            }            $queue[$i] = $vals;        }        foreach ($values as $h => $v) {            $hardRefs[$h] = $v;        }        return $queue;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
274,markrogoyski_math-php_Descriptive_3492," Compute the P-th percentile of a list of numbers\\n\\n Linear interpolation between closest ranks method - Second variant, C = 1\\n P-th percentile (0 <= P <= 100) of a list of N ordered values (sorted from least to greatest)\\n Similar method used in NumPy and Excel\\n https://en.wikipedia.org/wiki/Percentile#Second_variant.2C_.7F.27.22.60UNIQ--postMath-00000043-QINU.60.22.27.7F\\n\\n      P\\n x - --- (N - 1) + 1\\n     100\\n\\n P = percentile\\n N = number of elements in list\\n\\n Î½(x) = Î½â‚“ + xï¼…1(Î½â‚“â‚Šâ‚ - Î½â‚“)\\n\\n âŒŠxâŒ‹  = integer part of x\\n xï¼…1 = fraction part of x\\n Î½â‚“   = number in position x in sorted list of numbers\\n Î½â‚“â‚Šâ‚ = number in position x + 1 in sorted list of number\\n\\n @param float[] $numbers\\n @param float   $P percentile to calculate\\n\\n @return float in list corresponding to P percentile\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if $P percentile is not between 0 and 100\\n","Izračunajte P-ti percentil liste brojeva. Metoda linearne interpolacije između najbližih rangova - Druga varijanta, C = 1 , P-ti percentil (0 <= P <= 100) liste N uređenih vrednosti (poređanih od najmanje do najveće). Slična metoda korišćena u NumPy i Excel","    public static function percentile(array $numbers, float $P): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the P-th percentile of an empty list of numbers');        }        if ($P < 0 || $P > 100) {            throw new Exception\OutOfBoundsException('Percentile P must be between 0 and 100.');        }        $N = \count($numbers);        if ($N === 1) {            return \array_shift($numbers);        }        \sort($numbers);        if ($P == 100) {            return  $numbers[$N - 1];        }        $x    = ($P / 100) * ($N - 1) + 1;        $âŒŠxâŒ‹  = \intval($x);        $xï¼…1 = $x - $âŒŠxâŒ‹;        $Î½â‚“   = $numbers[$âŒŠxâŒ‹ - 1];        $Î½â‚“â‚Šâ‚ = $numbers[$âŒŠxâŒ‹];        return $Î½â‚“ + $xï¼…1 * ($Î½â‚“â‚Šâ‚ - $Î½â‚“);    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
277,symfony_finder_Finder_366, Reverses the sorting.\\n\\n @return $this\\n,Obrće sortiranje,    public function reverseSorting()    {        $this->reverseSorting = true;        return $this;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
278,guzzle_guzzle_Pool_1417," Sends an iterator of requests concurrently using a capped pool size.\\n\\n The pool will read from an iterator until it is cancelled or until the\\n iterator is consumed. When a request is yielded, the request is sent after\\n applying the ""request_options"" request options (if provided in the ctor).\\n\\n When a function is yielded by the iterator, the function is provided the\\n ""request_options"" array that should be merged on top of any existing\\n options, and the function MUST then return a wait-able promise.\\n\\n @final\\n","Istovremeno šalje iterator zahteva koristeći ograničenu veličinu pool-a. Pool će čitati iz iteratora dok se ne otkaže ili dok se iterator ne potroši. Kada se dobije zahtev, zahtev se šalje nakon primene ""request_options"" (ako je predviđeno u ctor-u). Kada iterator daje funkciju, funkciji se daje ""request_options"" niz koji treba spojiti povrh svih postojećih opcija, a funkcija MORA zatim vratiti obećanje na čekanje","class Pool implements PromisorInterface{    /**     * @var EachPromise     */    private $each;    /**     * @param ClientInterface $client   Client used to send the requests.     * @param array|\Iterator $requests Requests or functions that return     *                                  requests to send concurrently.     * @param array           $config   Associative array of options     *                                  - concurrency: (int) Maximum number of requests to send concurrently     *                                  - options: Array of request options to apply to each request.     *                                  - fulfilled: (callable) Function to invoke when a request completes.     *                                  - rejected: (callable) Function to invoke when a request is rejected.     */    public function __construct(ClientInterface $client, $requests, array $config = [])    {        if (!isset($config['concurrency'])) {            $config['concurrency'] = 25;        }        if (isset($config['options'])) {            $opts = $config['options'];            unset($config['options']);        } else {            $opts = [];        }        $iterable = P\Create::iterFor($requests);        $requests = static function () use ($iterable, $client, $opts) {            foreach ($iterable as $key => $rfn) {                if ($rfn instanceof RequestInterface) {                    yield $key => $client->sendAsync($rfn, $opts);                } elseif (\is_callable($rfn)) {                    yield $key => $rfn($opts);                } else {                    throw new \InvalidArgumentException('Each value yielded by the iterator must be a Psr7\Http\Message\RequestInterface or a callable that returns a promise that fulfills with a Psr7\Message\Http\ResponseInterface object.');                }            }        };        $this->each = new EachPromise($requests(), $config);    }    /**     * Get promise     */    public function promise(): PromiseInterface    {        return $this->each->promise();    }    /**     * Sends multiple requests concurrently and returns an array of responses     * and exceptions that uses the same ordering as the provided requests.     *     * IMPORTANT: This method keeps every request and response in memory, and     * as such, is NOT recommended when sending a large number or an     * indeterminate number of requests concurrently.     *     * @param ClientInterface $client   Client used to send the requests     * @param array|\Iterator $requests Requests to send concurrently.     * @param array           $options  Passes through the options available in     *                                  {@see \GuzzleHttp\Pool::__construct}     *     * @return array Returns an array containing the response or an exception     *               in the same order that the requests were sent.     *     * @throws \InvalidArgumentException if the event format is incorrect.     */    public static function batch(ClientInterface $client, $requests, array $options = []): array    {        $res = [];        self::cmpCallback($options, 'fulfilled', $res);        self::cmpCallback($options, 'rejected', $res);        $pool = new static($client, $requests, $options);        $pool->promise()->wait();        \ksort($res);        return $res;    }    /**     * Execute callback(s)     */    private static function cmpCallback(array &$options, string $name, array &$results): void    {        if (!isset($options[$name])) {            $options[$name] = static function ($v, $k) use (&$results) {                $results[$k] = $v;            };        } else {            $currentFn = $options[$name];            $options[$name] = static function ($v, $k) use (&$results, $currentFn) {                $currentFn($v, $k);                $results[$k] = $v;            };        }    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
279,hamcrest_hamcrest-php_FactoryGenerator_2307, Controls the process of extracting @factory doctags\n and generating factory method files.\n\n Uses File_Iterator to scan for PHP files.\n,Kontroliše postupak izdvajanja @factory doktaga i generisanja datoteka fabričkih metoda. Koristi File_Iterator za skeniranje PHP datoteka,"class FactoryGenerator{    /**     * Path to the Hamcrest PHP files to process.     *     * @var string     */    private $path;    /**     * @var array of FactoryFile     */    private $factoryFiles;    public function __construct($path)    {        $this->path = $path;        $this->factoryFiles = array();    }    public function addFactoryFile(FactoryFile $factoryFile)    {        $this->factoryFiles[] = $factoryFile;    }    public function generate()    {        $classes = $this->getClassesWithFactoryMethods();        foreach ($classes as $class) {            foreach ($class->getMethods() as $method) {                foreach ($method->getCalls() as $call) {                    foreach ($this->factoryFiles as $file) {                        $file->addCall($call);                    }                }            }        }    }    public function write()    {        foreach ($this->factoryFiles as $file) {            $file->build();            $file->write();        }    }    public function getClassesWithFactoryMethods()    {        $classes = array();        $files = $this->getSortedFiles();        foreach ($files as $file) {            $class = $this->getFactoryClass($file);            if ($class !== null) {                $classes[] = $class;            }        }        return $classes;    }    public function getSortedFiles()    {        $iter = $this->getFileIterator();        $files = array();        foreach ($iter as $file) {            $files[] = $file;        }        sort($files, SORT_STRING);        return $files;    }    private function getFileIterator()    {        $factoryClass = class_exists('File_Iterator_Factory') ? 'File_Iterator_Factory' : 'SebastianBergmann\FileIterator\Factory';        $factory = new $factoryClass();        return $factory->getFileIterator($this->path, '.php');    }    public function getFactoryClass($file)    {        $name = $this->getFactoryClassName($file);        if ($name !== null) {            require_once $file;            if (class_exists($name)) {                $class = new FactoryClass(substr($file, strpos($file, 'Hamcrest/')), new ReflectionClass($name));                if ($class->isFactory()) {                    return $class;                }            }        }        return null;    }    public function getFactoryClassName($file)    {        $content = file_get_contents($file);        if (preg_match('/namespace\s+(.+);/', $content, $namespace)            && preg_match('/\n\s*class\s+(\w+)\s+extends\b/', $content, $className)            && preg_match('/@factory\b/', $content)        ) {            return $namespace[1] . '\\' . $className[1];        }        return null;    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
280,jorgecasas_php-ml_DecisionTree_821, This will return an array including an importance value for\n each column in the given dataset. The importance values are\n normalized and their total makes 1.<br/>\n,Ovo će vratiti niz koji sadrži vrednost važnosti za svaku kolonu u datom skupu podataka. Vrednosti važnosti su normalizovane i njihov ukupan iznos iznosi 1,"    public function getFeatureImportances(): array    {        if ($this->featureImportances !== null) {            return $this->featureImportances;        }        $sampleCount = count($this->samples);        $this->featureImportances = [];        foreach ($this->columnNames as $column => $columnName) {            $nodes = $this->getSplitNodesByColumn($column, $this->tree);            $importance = 0;            foreach ($nodes as $node) {                $importance += $node->getNodeImpurityDecrease($sampleCount);            }            $this->featureImportances[$columnName] = $importance;        }        // Normalize & sort the importances        $total = array_sum($this->featureImportances);        if ($total > 0) {            array_walk($this->featureImportances, function (&$importance) use ($total): void {                $importance /= $total;            });            arsort($this->featureImportances);        }        return $this->featureImportances;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
281,markrogoyski_math-php_Algebra_2491," Get factors of an integer\n The decomposition of a composite number into a product of smaller integers.\n https://en.wikipedia.org/wiki/Integer_factorization\n\n Algorithm:\n - special case: if x is 0, return [\\INF]\n - let x be |x|\n - push on 1 as a factor\n - prime factorize x\n - build sets of prime powers from primes\n - push on the product of each set\n\n @param  int $x\n @return array of factors\n\n @throws Exception\\OutOfBoundsException if n is < 1\n",Dobitijanje faktora celog broja. Razlaganje kompozitnog broja u proizvod manjih celih brojeva,"    public static function factors(int $x): array    {        // 0 has infinite factors        if ($x === 0) {            return [\INF];        }        $x       = \abs($x);        $factors = [1];        // Prime factorize x        $primes = Integer::primeFactorization($x);        // Prime powers from primes        $sets       = [];        $current    = [];        $map        = [];        $exponents  = \array_count_values($primes);        $limit      = 1;        $count      = 0;        foreach ($exponents as $prime => $exponent) {            $map[]        = $prime;            $sets[$prime] = [1, $prime];            $primePower   = $prime;            for ($n = 2; $n <= $exponent; ++$n) {                $primePower *= $prime;                $sets[$prime][$n] = $primePower;            }            $limit *= \count($sets[$prime]);            if ($count === 0) { // Skip 1 on the first prime                $current[] = \next($sets[$prime]);            } else {                $current[] = 1;            }            ++$count;        }        // Multiply distinct prime powers together        for ($i = 1; $i < $limit; ++$i) {            $factors[] = \array_product($current);            for ($i2 = 0; $i2 < $count; ++$i2) {                $current[$i2] = \next($sets[$map[$i2]]);                if ($current[$i2] !== false) {                    break;                }                $current[$i2] = \reset($sets[$map[$i2]]);            }        }        \sort($factors);        return $factors;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
282,markrogoyski_math-php_Descriptive_3490," Quartiles - Exclusive method\\n Three points that divide the data set into four equal groups, each group comprising a quarter of the data.\\n https://en.wikipedia.org/wiki/Quartile\\n\\n 0% is smallest number\\n Q1 (25%) is first quartile (lower quartile, 25th percentile)\\n Q2 (50%) is second quartile (median, 50th percentile)\\n Q3 (75%) is third quartile (upper quartile, 75th percentile)\\n 100% is largest number\\n interquartile_range is the difference between the upper and lower quartiles. (IQR = Qâ‚ƒ - Qâ‚)\\n\\n Method used\\n  - Use the median to divide the ordered data set into two halves.\\n   - If there are an odd number of data points in the original ordered data set, do not include the median\\n     (the central value in the ordered list) in either half.\\n   - If there are an even number of data points in the original ordered data set,\\n     split this data set exactly in half.\\n  - The lower quartile value is the median of the lower half of the data.\\n    The upper quartile value is the median of the upper half of the data.\\n\\n This rule is employed by the TI-83 calculator boxplot and ""1-Var Stats"" functions.\\n This is the most basic method that is commonly taught in math textbooks.\\n\\n @param float[] $numbers\\n\\n @return array (0%, Q1, Q2, Q3, 100%, IQR)\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n","Kvartili - Ekskluzivna metoda. Tri tačke koje skup podataka dele na četiri jednake grupe, a svaka grupa čini četvrtinu podataka","    public static function quartilesExclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        if (\count($numbers) === 1) {            $number = \array_pop($numbers);            return [                '0%'   => $number,                'Q1'   => $number,                'Q2'   => $number,                'Q3'   => $number,                '100%' => $number,                'IQR'  => 0,            ];        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
283,markrogoyski_math-php_Descriptive_3491," Quartiles - Inclusive method (R method)\n Three points that divide the data set into four equal groups, each group comprising a quarter of the data.\n https://en.wikipedia.org/wiki/Quartile\n\n 0% is smallest number\n Q1 (25%) is first quartile (lower quartile, 25th percentile)\n Q2 (50%) is second quartile (median, 50th percentile)\n Q3 (75%) is third quartile (upper quartile, 75th percentile)\n 100% is largest number\n interquartile_range is the difference between the upper and lower quartiles. (IQR = Qâ‚ƒ - Qâ‚)\n\n Method used\n  - Use the median to divide the ordered data set into two halves.\n   - If there are an odd number of data points in the original ordered data set,\n     include the median (the central value in the ordered list) in both halves.\n   - If there are an even number of data points in the original ordered data set,\n     split this data set exactly in half.\n  - The lower quartile value is the median of the lower half of the data.\n    The upper quartile value is the median of the upper half of the data.\n\n The values found by this method are also known as ""Tukey\'s hinges"".\n This is the method that the programming language R uses by default.\n\n @param float[] $numbers\n\n @return array (0%, Q1, Q2, Q3, 100%, IQR)\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n","Kvartili - Inkluzivna metoda (metoda R). Tri tačke koje skup podataka dele u četiri jednake grupe, a svaka grupa čini četvrtinu podataka","    public static function quartilesInclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);            // Add median to both halves            $median = Average::median($numbers);            \array_push($lower_half, $median);            \array_unshift($upper_half, $median);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
284,markrogoyski_math-php_FivePointFormula_3006," Five Point Formula\n\n In numerical analysis, the five point formula is used for approximating\n the derivative of a function at a point in its domain.\n\n We can either directly supply a set of inputs and their corresponding outputs\n for said function, or if we explicitly know the function, we can define it as a\n callback function and then generate a set of points by evaluating that function\n at 5 points between a start and end point.\n","Formula sa pet tačaka. U numeričkoj analizi, formula sa pet tačaka koristi se za aproksimaciju izvoda funkcije u tački u njenom domenu. Možemo ili direktno da dostavimo skup ulaza i njihove odgovarajuće izlaze za pomenutu funkciju, ili ako eksplicitno znamo funkciju, možemo je definisati kao funkciju povratnog poziva, a zatim generisati skup tačaka procenom te funkcije u 5 tačaka između početne i krajnje tačke","class FivePointFormula extends NumericalDifferentiation{    /**     * Use the Five Point Formula to approximate the derivative of a function at     * our $target. Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose derivative we are     * approximating.     *     * The Five Point Formula requires we supply 5 points that are evenly spaced     * apart, and that our target equals the x-components of one of our 5 points.     *     * Example: differentiation(2, function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Five Point Formula:     *     *   - If the 3rd point is our $target, use the Midpoint Formula:     *     *              1                                         hâ´     *     fâ€²(xâ‚€) = - [f(xâ‚€-2h)-8f(xâ‚€-h)+8f(xâ‚€+h)-f(xâ‚€+2h)] - - fâ½âµâ¾(Î¶â‚)     *             12h                                        30     *     *         where Î¶â‚ lies between xâ‚€ - 2h and xâ‚€ + 2h     *     *   - If the 1st or 5th point is our $target, use the Endpoint Formula:     *   - Note that when the 3rd point is our $target, we use a negative h.     *     *              1                                                        hâ´     *     fâ€²(xâ‚€) = - [-25f(xâ‚€)+48f(xâ‚€+h)-36f(xâ‚€+2h)+16f(xâ‚€+3h)-3f(xâ‚€+4h)] + - fâ½âµâ¾(Î¶â‚€)     *             12h                                                       5     *     *         where Î¶â‚€ lies between xâ‚€ and xâ‚€ + 4h     *     * @param float          $target  The value at which we are approximating the derivative     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4], [4,5], [5,6]].     *                                Example callback: function($x) {return $x**2;}     * @param number         ...$args The arguments of our callback function: start,     *                                end, and n. Example: approximate($number, $source, 0, 8, 5).     *                                If $source is a set of points, do not input any     *                               $args. Example: approximate($source).     *     * @return float                 The approximation of f'($target), i.e. the derivative     *                               of our input at our target point     *     * @throws Exception\BadDataException     */    public static function differentiate(float $target, $source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input, sort points, make sure spacing is constant, and make        // sure our target is contained in an interval supplied by our $source        self::validate($points, $degree = 5);        $sorted = self::sort($points);        self::isSpacingConstant($sorted);        self::isTargetInPoints($target, $sorted);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $h = ($sorted[4][$x] - $sorted[0][$x]) / 4;        /*         * If the 3rd point is our $target, use the Midpoint Formula:         *         *              1                                         hâ´         *     fâ€²(xâ‚€) = - [f(xâ‚€-2h)-8f(xâ‚€-h)+8f(xâ‚€+h)-f(xâ‚€+2h)] - - fâ½âµâ¾(Î¶â‚)         *             12h                                        30         *         *         where Î¶â‚ lies between xâ‚€ - 2h and xâ‚€ + 2h         */        if ($sorted[2][$x] == $target) {            $fâŸ®xâ‚€â§¿2hâŸ¯    = $sorted[0][$y];            $fâŸ®xâ‚€â§¿hâŸ¯     = $sorted[1][$y];            $fâŸ®xâ‚€â§¾hâŸ¯     = $sorted[3][$y];            $fâŸ®xâ‚€â§¾2hâŸ¯    = $sorted[4][$y];            $derivative = ($fâŸ®xâ‚€â§¿2hâŸ¯ - 8 * $fâŸ®xâ‚€â§¿hâŸ¯ + 8 * $fâŸ®xâ‚€â§¾hâŸ¯ - $fâŸ®xâ‚€â§¾2hâŸ¯) / (12 * $h);            return $derivative;        }        /*         * If the 1st or 5th point is our $target, use the Endpoint Formula:         * Note that when the 3rd point is our $target, we use a negative h.         *         *              1                                                        hâ´         *     fâ€²(xâ‚€) = - [-25f(xâ‚€)+48f(xâ‚€+h)-36f(xâ‚€+2h)+16f(xâ‚€+3h)-3f(xâ‚€+4h)] + - fâ½âµâ¾(Î¶â‚€)         *             12h                                                       5         *         *         where Î¶â‚€ lies between xâ‚€ and xâ‚€ + 4h         */        if ($sorted[0][$x] == $target) {  // The 1st point is our $target            $fâŸ®xâ‚€âŸ¯    = $sorted[0][$y];            $fâŸ®xâ‚€â§¾hâŸ¯  = $sorted[1][$y];            $fâŸ®xâ‚€â§¾2hâŸ¯ = $sorted[2][$y];            $fâŸ®xâ‚€â§¾3hâŸ¯ = $sorted[3][$y];            $fâŸ®xâ‚€â§¾4hâŸ¯ = $sorted[4][$y];        } else {                          // The 5th point is our $target, use negative h            $h = -$h;            $fâŸ®xâ‚€âŸ¯    = $sorted[4][$y];            $fâŸ®xâ‚€â§¾hâŸ¯  = $sorted[3][$y];            $fâŸ®xâ‚€â§¾2hâŸ¯ = $sorted[2][$y];            $fâŸ®xâ‚€â§¾3hâŸ¯ = $sorted[1][$y];            $fâŸ®xâ‚€â§¾4hâŸ¯ = $sorted[0][$y];        }        $derivative = (-25 * $fâŸ®xâ‚€âŸ¯ + 48 * $fâŸ®xâ‚€â§¾hâŸ¯ - 36 * $fâŸ®xâ‚€â§¾2hâŸ¯ + 16 * $fâŸ®xâ‚€â§¾3hâŸ¯ - 3 * $fâŸ®xâ‚€â§¾4hâŸ¯) / (12 * $h);        return $derivative;    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
285,markrogoyski_math-php_Interpolation_2987, Base class for interpolation techniques.\n,Osnovna klasa za tehnike interpolacije,"abstract class Interpolation{    /** @var int Index of x */    protected const X = 0;    /** @var int Index of y */    protected const Y = 1;    /**     * Determine where the input $source argument is a callback function, a set     * of arrays, or neither. If $source is a callback function, run it through     * the functionToPoints() method with the input $args, and set $points to     * output array. If $source is a set of arrays, simply set $points to     * $source. If $source is neither, throw an Exception.     *     * @todo  Add method to verify function is continuous on our interval     * @todo  Add method to verify input arguments are valid.     *        Verify $start and $end are numbers, $end > $start, and $points is an integer > 1     *     * @param callable|array $source The source of our approximation. Should be either a callback function or a set of arrays.     * @param array          $args   The arguments of our callback function: start, end, and n.     *                               Example: [0, 8, 5]. If $source is a set of arrays, $args will default to [].     *     * @return array     *     * @throws Exception\BadDataException if $source is not callable or a set of arrays     */    public static function getPoints($source, array $args = []): array    {        // Guard clause - source must be callable or array of points        if (!(\is_callable($source) || \is_array($source))) {            throw new Exception\BadDataException('Input source is incorrect. You need to input either a callback function or a set of arrays');        }        // Source is already an array: nothing to do        if (\is_array($source)) {            return $source;        }        // Construct points from callable function        $function = $source;        $start    = $args[0];        $end      = $args[1];        $n        = $args[2];        return self::functionToPoints($function, $start, $end, $n);    }    /**     * Evaluate our callback function at n evenly spaced points on the interval     * between start and end     *     * @param  callable $function f(x) callback function     * @param  float    $start    the start of the interval     * @param  float    $end      the end of the interval     * @param  int      $n        the number of function evaluations     *     * @return array     */    protected static function functionToPoints(callable $function, float $start, float $end, int $n): array    {        $points = [];        $h      = ($end - $start) / ($n - 1);        for ($i = 0; $i < $n; $i++) {            $xáµ¢         = $start + $i * $h;            $fâŸ®xáµ¢âŸ¯       = $function($xáµ¢);            $points[$i] = [$xáµ¢, $fâŸ®xáµ¢âŸ¯];        }        return $points;    }    /**     * Validate that there are enough input arrays (points), that each point array     * has precisely two numbers, and that no two points share the same first number     * (x-component)     *     * @param  array $points Array of arrays (points)     * @param  int   $degree The minimum number of input arrays     *     * @throws Exception\BadDataException if there are less than two points     * @throws Exception\BadDataException if any point does not contain two numbers     * @throws Exception\BadDataException if two points share the same first number (x-component)     */    public static function validate(array $points, int $degree = 2)    {        if (\count($points) < $degree) {            throw new Exception\BadDataException('You need to have at least $degree sets of coordinates (arrays) for this technique');        }        $x_coordinates = [];        foreach ($points as $point) {            if (\count($point) !== 2) {                throw new Exception\BadDataException('Each array needs to have have precisely two numbers, an x- and y-component');            }            $x_component = $point[self::X];            if (\in_array($x_component, $x_coordinates)) {                throw new Exception\BadDataException('Not a function. Your input array contains more than one coordinate with the same x-component.');            }            $x_coordinates[] = $x_component;        }    }    /**     * Sorts our coordinates (arrays) by their x-component (first number) such     * that consecutive coordinates have an increasing x-component.     *     * @param  array $points     *     * @return array[]     */    protected static function sort(array $points): array    {        \usort($points, function (array $a, array $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
286,markrogoyski_math-php_MidpointRule_3020," Midpoint rule\\n\\n In numerical analysis, the Midpoint rule is a technique for approximating\\n the definite integral of a function.\\n\\n The Midpoint rule belongs to the closed Newton-Cotes formulas, a group of\\n methods for numerical integration which approximate the integral of a function.\\n We can either directly supply a set of inputs and their corresponding outputs\\n for said function, or if we explicitly know the function, we can define it as a\\n callback function and then generate a set of points by evaluating that function\\n at n points between a start and end point. We then use these values to\\n interpolate a Lagrange polynomial. Finally, we integrate the Lagrange\\n polynomial to approximate the integral of our original function.\\n\\n https://en.wikipedia.org/wiki/Rectangle_method\\n http://www.efunda.com/math/num_integration/num_int_newton.cfm\\n","Pravilo srednje tačke. U numeričkoj analizi, pravilo srednje tačke je tehnika aproksimacije određenog integrala funkcije. Pravilo srednje tačke pripada zatvorenim Newton-Cotes-ovim formulama, grupi metoda za numeričku integraciju kojima se približava integral funkcije. Možemo ili direktno dostaviti skup ulaza i njihovih odgovarajućih izlaza za navedenu funkciju, ili ako funkciju eksplicitno znamo, možemo definisati to je kao funkcija povratnog poziva, a zatim generiše skup tačaka procenom te funkcije u n tačaka između početne i krajnje tačke. Zatim koristimo ove vrednosti za interpolaciju Lagrangeovog polinoma. Na kraju, integrišemo Lagrangeov polinom da bismo približili integral naše originalne funkcije","class MidpointRule extends NumericalIntegration{    /**     * Use the Midpoint rule to approximate the definite integral of a     * function f(x). Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose definite integral we     * are approximating.     *     * The bounds of the definite integral to which we are approximating is     * determined by the our inputs.     *     * Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite     * integral of the function that produces these coordinates with a lower     * bound of 0, and an upper bound of 10.     *     * Example: approximate(function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Midpoint Rule:     *     * xn        â¿â»Â¹ xáµ¢â‚Šâ‚     * âˆ« f(x)dx = âˆ‘   âˆ« f(x)dx     * xâ‚        â±â¼Â¹  xáµ¢     *     *            â¿   h     *          = âˆ‘   - [f(xáµ¢)+f(xáµ¢â‚Šâ‚)] + O(hÂ³fâ€³(x))     *           â±â¼Â¹  2     *     *  where h = xáµ¢â‚Šâ‚ - xáµ¢     *  note: this implementation does not compute the error term.     * @param callable|array $source The source of our approximation. Should be either     *                               a callback function or a set of arrays. Each array     *                               (point) contains precisely two numbers, an x and y.     *                               Example array: [[1,2], [2,3], [3,4]].     *                               Example callback: function($x) {return $x**2;}     * @param number        ...$args The arguments of our callback function: start,     *                               end, and n. Example: approximate($source, 0, 8, 5).     *                               If $source is a set of points, do not input any     *                               $args. Example: approximate($source).     *     * @return float                 The approximation to the integral of f(x)     *     * @throws Exception\BadDataException     */    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         *   â¿   h         * = âˆ‘   - [f(xáµ¢)+f(xáµ¢â‚Šâ‚)] + O(hÂ³fâ€³(x))         *  â±â¼Â¹  2         * where h = xáµ¢â‚Šâ‚ - xáµ¢         */        for ($i = 0; $i < $steps; $i++) {            $xáµ¢             = $sorted[$i][$x];            $xáµ¢â‚Šâ‚           = $sorted[$i + 1][$x];            $fâŸ®xáµ¢âŸ¯           = $sorted[$i][$y];     // yáµ¢            $fâŸ®xáµ¢â‚Šâ‚âŸ¯         = $sorted[$i + 1][$y];   // yáµ¢â‚Šâ‚            $midpoint       = ($fâŸ®xáµ¢âŸ¯ + $fâŸ®xáµ¢â‚Šâ‚âŸ¯) / 2;            $h              = $xáµ¢â‚Šâ‚ - $xáµ¢;            $approximation += $h * $midpoint;        }        return $approximation;    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
287,markrogoyski_math-php_NaturalCubicSpline_2992," Natural Cubic Spline Interpolating Polynomial\\n\\n In numerical analysis, cubic splines are used for polynomial\\n interpolation.\\n\\n A cubic spline is a spline constructed of piecewise third-order polynomials\\n which pass through a set of m control points."" In the case of the natural\\n cubic spline, the second derivative of each polynomial is set to zero at the\\n endpoints of each interval of the piecewise function.\\n\\n Cubic spline interpolation belongs to a collection of techniques that\\n interpolate a function or a set of values, producing a continuous polynomial.\\n In the case of the cubic spline, a piecewise function (polynomial) is produced.\\n We can either directly supply a set of inputs and their corresponding outputs\\n for said function, or if we explicitly know the function, we can define it as\\n a callback function and then generate a set of points by evaluating that\\n function at n points between a start and end point. We then use these values\\n to interpolate our piecewise polynomial.\\n\\n https://en.wikipedia.org/wiki/Spline_interpolation\\n http://mathworld.wolfram.com/CubicSpline.html\\n","Prirodni kubni splaj interpolirajući polinom. U numeričkoj analizi, kubni splajnovi se koriste za polinomsku interpolaciju. Kubični splajn je splajn izgrađen od komadnih polinoma trećeg reda koji prolaze kroz skup od m kontrolnih tačaka. ""U slučaju prirodnog kubnog splajna, drugi izvod svakog polinoma postavljen je na nulu na krajnjim tačkama svakog intervala komadne funkcije. Kubična splajna interpolacija pripada kolekciji tehnika koje interpoliraju funkciju ili skup vrednosti stvarajući neprekidni polinom. U slučaju kubnog splajna proizvodi se komadna funkcija (polinom). Možemo ili direktno dostaviti skup ulaza i njihove odgovarajuće izlaze \\ n za pomenutu funkciju, ili ako funkciju eksplicitno znamo, možemo je definisati kao funkciju povratnog poziva, a zatim generisati skup tačaka procenjujući da funkcioniše u n tačaka između početne i krajnje tačke. Zatim koristimo ove vrednosti za interpoliranje našeg komadastog polinoma","class NaturalCubicSpline extends Interpolation{    /**     * Interpolate     *     * @param callable|array $source The source of our approximation. Should be either     *                           a callback function or a set of arrays. Each array     *                           (point) contains precisely two numbers, an x and y.     *                           Example array: [[1,2], [2,3], [3,4]].     *                           Example callback: function($x) {return $x**2;}     * @param number   ...$args  The arguments of our callback function: start,     *                           end, and n. Example: approximate($source, 0, 8, 5).     *                           If $source is a set of points, do not input any     *                           $args. Example: approximate($source).     *     * @return Piecewise         The interpolating (piecewise) polynomial, as an     *                           instance of Piecewise.     *     * @throws Exception\BadDataException     */    public static function interpolate($source, ...$args): Piecewise    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 1);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n     = \count($sorted);        $k     = $n - 1;        $h     = [];        $a     = [];        $Î¼     = [0];        $z     = [0];        $z[$k] = 0;        $c     = [];        $c[$k] = 0;        $poly  = [];        $int   = [];        for ($i = 0; $i < $k; $i++) {            $xáµ¢     = $sorted[$i][$x];            $xáµ¢â‚Šâ‚   = $sorted[$i + 1][$x];            $a[$i]  = $sorted[$i][$y];            $h[$i]  = $xáµ¢â‚Šâ‚ - $xáµ¢;            if ($i == 0) {                continue;            }            $xáµ¢â‚‹â‚   = $sorted[$i - 1][$x];            $fâŸ®xáµ¢âŸ¯   = $sorted[$i][$y];    // yáµ¢            $fâŸ®xáµ¢â‚Šâ‚âŸ¯ = $sorted[$i + 1][$y];  // yáµ¢â‚Šâ‚            $fâŸ®xáµ¢â‚‹â‚âŸ¯ = $sorted[$i - 1][$y];  // yáµ¢â‚‹â‚            $Î±      = (3 / $h[$i]) * ($fâŸ®xáµ¢â‚Šâ‚âŸ¯ - $fâŸ®xáµ¢âŸ¯) - (3 / $h[$i - 1]) * ($fâŸ®xáµ¢âŸ¯ - $fâŸ®xáµ¢â‚‹â‚âŸ¯);            $l      = 2 * ($xáµ¢â‚Šâ‚ - $xáµ¢â‚‹â‚) - $h[$i - 1] * $Î¼[$i - 1];            $Î¼[$i]  = $h[$i] / $l;            $z[$i]  = ($Î± - $h[$i - 1] * $z[$i - 1]) / $l;        }        for ($i = $k - 1; $i >= 0; $i--) {            $xáµ¢       = $sorted[$i][$x];            $xáµ¢â‚Šâ‚     = $sorted[$i + 1][$x];            $fâŸ®xáµ¢âŸ¯     = $sorted[$i][$y];    // yáµ¢            $fâŸ®xáµ¢â‚Šâ‚âŸ¯   = $sorted[$i + 1][$y];  // yáµ¢â‚Šâ‚            $c[$i]    = $z[$i] - $Î¼[$i] * $c[$i + 1];            $b[$i]    = ($fâŸ®xáµ¢â‚Šâ‚âŸ¯ - $fâŸ®xáµ¢âŸ¯) / $h[$i] - $h[$i] * ($c[$i + 1] + 2 * $c[$i]) / 3;            $d[$i]    = ($c[$i + 1] - $c[$i]) / (3 * $h[$i]);            $poly[$i] = new Polynomial([                $d[$i],                $c[$i] - 3 * $d[$i] * $xáµ¢,                $b[$i] - 2 * $c[$i] * $xáµ¢ + 3 * $d[$i] * ($xáµ¢ ** 2),                $a[$i] - $b[$i] * $xáµ¢ + $c[$i] * ($xáµ¢ ** 2) - $d[$i] * ($xáµ¢ ** 3)            ]);            if ($i == 0) {                $int[$i] = [$xáµ¢, $xáµ¢â‚Šâ‚];            } else {                $int[$i] = [$xáµ¢, $xáµ¢â‚Šâ‚, true, false];            }        }        $piecewise = new Piecewise($int, $poly);        return $piecewise;    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
288,markrogoyski_math-php_NevillesMethod_2994," Nevilles Method\\n\\n In numerical analysis, Nevilles Method is an interpolation technique that\\n uses Lagrange polynomials of lower powers recursively in order to compute\\n Lagrange polynomials of higher powers.\\n\\n Nevilles Method belongs to a collection of techniques that interpolate a\\n function or a set of values to approximate a function at a target point.\\n We can either directly supply a set of inputs and their corresponding outputs\\n for said function, or if we explicitly know the function, we can define it as\\n a callback function and then generate a set of points by evaluating that\\n function at n points between a start and end point. We then use these values\\n to interpolate Lagrange polynomials recursively at our target point.\\n\\n http://www2.math.ou.edu/~npetrov/neville.pdf\\n","Nevilles-ova metoda. U numeričkoj analizi, Nevilles-ova metoda je tehnika interpolacije koja koristi Lagranžove polinome nižih stepena rekurzivno kako bi izračunala Lagranžove polinome viših stepena. Nevilles-ova metoda pripada kolekciji tehnika koje interpoliraju funkciju ili skup vrednosti za približavanje funkcije u ciljnoj tački. Možemo ili direktno dostaviti skup ulaza i njihove odgovarajuće izlaze za pomenutu funkciju, ili ako eksplicitno znamo funkciju, možemo je definisati kao funkciju povratnog poziva, a zatim generisati skup tačaka procenjujući tu funkciju u n tačaka između početne i krajnje tačke. Zatim koristimo ove vrednosti za interpolaciju Lagranžovih polinoma rekurzivno u našu ciljnu tačku","class NevillesMethod extends Interpolation{    /**     * Interpolate     *     * @param float          $target  The point at which we are interpolation     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4]].     *                                Example callback: function($x) {return $x**2;}     * @param float[]        ...$args The arguments of our callback function: start,     *                                end, and n. Example: approximate($source, 0, 8, 5).     *                                If $source is a set of points, do not input any     *                                $args. Example: approximate($source).     *     * @return float                  The interpolated value at our target     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     */    public static function interpolate(float $target, $source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n = \count($sorted);        $Q = [];        // Build our 0th-degree Lagrange polynomials: Qâ‚áµ¢â‚Žâ‚â‚€â‚Ž = yáµ¢ for all i < n        for ($i = 0; $i < $n; $i++) {            $Q[$i][0] = new Polynomial([$sorted[$i][$y]]); // yáµ¢        }        // Recursively generate our (n-1)th-degree Lagrange polynomial at $target        for ($i = 1; $i < $n; $i++) {            for ($j = 1; $j <= $i; $j++) {                $xáµ¢â‚‹â±¼        = $sorted[$i - $j][$x];                $xáµ¢          = $sorted[$i][$x];                $Qâ‚áµ¢â‚Žâ‚â±¼â‚‹â‚â‚Ž   = $Q[$i][$j - 1]($target);                $Qâ‚áµ¢â‚‹â‚â‚Žâ‚â±¼â‚‹â‚â‚Ž = $Q[$i - 1][$j - 1]($target);                $Q[$i][$j]   = LagrangePolynomial::interpolate([[$xáµ¢â‚‹â±¼,$Qâ‚áµ¢â‚‹â‚â‚Žâ‚â±¼â‚‹â‚â‚Ž],[$xáµ¢,$Qâ‚áµ¢â‚Žâ‚â±¼â‚‹â‚â‚Ž]]);            }        }        // Return our (n-1)th-degree Lagrange polynomial evaluated at $target        return $Q[$n - 1][$n - 1]($target);    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
289,markrogoyski_math-php_NumericalIntegration_3022," Base class for numerical integration techniques.\n\n Numerical integration techniques are used to approximate the value of\n an indefinite integral.\n\n This class gives each technique a set of common tools, and requires each\n technique to define an approximate() method to approximate an indefinite\n integral.\n",Osnovna klasa za tehnike numeričke integracije. Tehnike numeričke integracije koriste se za približavanje vrednosti neodređenog integrala. Ova klasa svakoj tehnici daje skup uobičajenih alata i zahteva da svaka tehnika odredi n approximate() metoda za približavanje neodređenog integrala,"abstract class NumericalIntegration{    /** @var int Index of x */    protected const X = 0;    /** @var int Index of y */    protected const Y = 1;    abstract public static function approximate($source, ...$args);    /**     * Determine where the input $source argument is a callback function, a set     * of arrays, or neither. If $source is a callback function, run it through     * the functionToPoints() method with the input $args, and set $points to     * output array. If $source is a set of arrays, simply set $points to     * $source. If $source is neither, throw an Exception.     *     * @todo  Add method to verify function is continuous on our interval     * @todo  Add method to verify input arguments are valid.     *        Verify $start and $end are numbers, $end > $start, and $points is an integer > 1     *     * @param  callable|array  $source The source of our approximation. Should be either     *                                 a callback function or a set of arrays.     * @param  array           $args   The arguments of our callback function: start,     *                                 end, and n. Example: [0, 8, 5]. If $source is a     *                                 set of arrays, $args will default to [].     *     * @return array     *     * @throws Exception\BadDataException if $source is not callable or a set of arrays     */    public static function getPoints($source, array $args = []): array    {        // Guard clause - source must be callable or array of points        if (!(\is_callable($source) || \is_array($source))) {            throw new Exception\BadDataException('Input source is incorrect. You need to input either a callback function or a set of arrays');        }        // Source is already an array: nothing to do        if (\is_array($source)) {            return $source;        }        // Construct points from callable function        $function = $source;        $start    = $args[0];        $end      = $args[1];        $n        = $args[2];        return self::functionToPoints($function, $start, $end, $n);    }    /**     * Evaluate our callback function at n evenly spaced points on the interval between start and end     *     * @param  callable $function f(x) callback function     * @param  float    $start    the start of the interval     * @param  float    $end      the end of the interval     * @param  int      $n        the number of function evaluations     *     * @return array     */    protected static function functionToPoints(callable $function, float $start, float $end, int $n): array    {        $points = [];        $h      = ($end - $start) / ($n - 1);        for ($i = 0; $i < $n; $i++) {            $xáµ¢         = $start + $i * $h;            $fâŸ®xáµ¢âŸ¯       = $function($xáµ¢);            $points[$i] = [$xáµ¢, $fâŸ®xáµ¢âŸ¯];        }        return $points;    }    /**     * Validate that there are enough input arrays (points), that each point array     * has precisely two numbers, and that no two points share the same first number     * (x-component)     *     * @param  array $points Array of arrays (points)     * @param  int   $degree The minimum number of input arrays     *     * @throws Exception\BadDataException if there are less than two points     * @throws Exception\BadDataException if any point does not contain two numbers     * @throws Exception\BadDataException if two points share the same first number (x-component)     */    public static function validate(array $points, int $degree = 2)    {        if (\count($points) < $degree) {            throw new Exception\BadDataException(""You need to have at least $degree sets of coordinates (arrays) for this technique"");        }        $x_coordinates = [];        foreach ($points as $point) {            if (\count($point) !== 2) {                throw new Exception\BadDataException('Each array needs to have have precisely two numbers, an x- and y-component');            }            $x_component = $point[self::X];            if (\in_array($x_component, $x_coordinates)) {                throw new Exception\BadDataException('Not a function. Your input array contains more than one coordinate with the same x-component.');            }            $x_coordinates[] = $x_component;        }    }    /**     * Sorts our coordinates (arrays) by their x-component (first number) such     * that consecutive coordinates have an increasing x-component.     *     * @param  array[] $points     *     * @return array[]     */    protected static function sort(array $points): array    {        \usort($points, function ($a, $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
291,sebastianbergmann_comparator_DoubleComparator_2337, Compares doubles for equality.\\n,Upoređuje dve vrednosti da li su jednake,"class DoubleComparator extends NumericComparator{    /**     * Smallest value available in PHP.     *     * @var float     */    public const EPSILON = 0.0000000001;    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return (is_float($expected) || is_float($actual)) && is_numeric($expected) && is_numeric($actual);    }    /**     * Asserts that two values are equal.     *     * @param mixed $expected     First value to compare     * @param mixed $actual       Second value to compare     * @param float $delta        Allowed numerical distance between two values to consider them equal     * @param bool  $canonicalize Arrays are sorted before comparison when set to true     * @param bool  $ignoreCase   Case is ignored when set to true     *     * @throws ComparisonFailure     */    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false)/*: void*/    {        if ($delta == 0) {            $delta = self::EPSILON;        }        parent::assertEquals($expected, $actual, $delta, $canonicalize, $ignoreCase);    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
292,squizlabs_PHP_CodeSniffer_Config_880, Prints out the gathered config data.\\n\\n @param array $data The config data to print.\\n\\n @return void\\n,Štampa prikupljene podatke o konfiguraciji,"    public function printConfigData($data)    {        $max  = 0;        $keys = array_keys($data);        foreach ($keys as $key) {            $len = strlen($key);            if (strlen($key) > $max) {                $max = $len;            }        }        if ($max === 0) {            return;        }        $max += 2;        ksort($data);        foreach ($data as $name => $value) {            echo str_pad($name.': ', $max).$value.PHP_EOL;        }    }//end printConfigData()",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
293,squizlabs_PHP_CodeSniffer_Reporter_900, Generate summary information to be used during report generation.\n\n @param \\PHP_CodeSniffer\\Files\\File $phpcsFile The file that has been processed.\n\n @return array\n,Generišite sažete informacije koje će se koristiti tokom generisanja izveštaja,"    public function prepareFileReport(File $phpcsFile)    {        $report = [            'filename' => Common::stripBasepath($phpcsFile->getFilename(), $this->config->basepath),            'errors'   => $phpcsFile->getErrorCount(),            'warnings' => $phpcsFile->getWarningCount(),            'fixable'  => $phpcsFile->getFixableCount(),            'messages' => [],        ];        if ($report['errors'] === 0 && $report['warnings'] === 0) {            // Prefect score!            return $report;        }        if ($this->config->recordErrors === false) {            $message  = 'Errors are not being recorded but this report requires error messages. ';            $message .= 'This report will not show the correct information.';            $report['messages'][1][1] = [                [                    'message'  => $message,                    'source'   => 'Internal.RecordErrors',                    'severity' => 5,                    'fixable'  => false,                    'type'     => 'ERROR',                ],            ];            return $report;        }        $errors = [];        // Merge errors and warnings.        foreach ($phpcsFile->getErrors() as $line => $lineErrors) {            foreach ($lineErrors as $column => $colErrors) {                $newErrors = [];                foreach ($colErrors as $data) {                    $newErrors[] = [                        'message'  => $data['message'],                        'source'   => $data['source'],                        'severity' => $data['severity'],                        'fixable'  => $data['fixable'],                        'type'     => 'ERROR',                    ];                }                $errors[$line][$column] = $newErrors;            }            ksort($errors[$line]);        }//end foreach        foreach ($phpcsFile->getWarnings() as $line => $lineWarnings) {            foreach ($lineWarnings as $column => $colWarnings) {                $newWarnings = [];                foreach ($colWarnings as $data) {                    $newWarnings[] = [                        'message'  => $data['message'],                        'source'   => $data['source'],                        'severity' => $data['severity'],                        'fixable'  => $data['fixable'],                        'type'     => 'WARNING',                    ];                }                if (isset($errors[$line]) === false) {                    $errors[$line] = [];                }                if (isset($errors[$line][$column]) === true) {                    $errors[$line][$column] = array_merge(                        $newWarnings,                        $errors[$line][$column]                    );                } else {                    $errors[$line][$column] = $newWarnings;                }            }//end foreach            ksort($errors[$line]);        }//end foreach        ksort($errors);        $report['messages'] = $errors;        return $report;    }//end prepareFileReport()",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
294,squizlabs_PHP_CodeSniffer_Ruleset_902, Prints a report showing the sniffs contained in a standard.\n\n @return void\n,Štampa izveštaj koji prikazuje njuškanja (sniffs) sadržana u standardu,"    public function explain()    {        $sniffs = array_keys($this->sniffCodes);        sort($sniffs);        ob_start();        $lastStandard = null;        $lastCount    = '';        $sniffCount   = count($sniffs);        // Add a dummy entry to the end so we loop        // one last time and clear the output buffer.        $sniffs[] = '';        echo PHP_EOL.""The $this->name standard contains $sniffCount sniffs"".PHP_EOL;        ob_start();        foreach ($sniffs as $i => $sniff) {            if ($i === $sniffCount) {                $currentStandard = null;            } else {                $currentStandard = substr($sniff, 0, strpos($sniff, '.'));                if ($lastStandard === null) {                    $lastStandard = $currentStandard;                }            }            if ($currentStandard !== $lastStandard) {                $sniffList = ob_get_contents();                ob_end_clean();                echo PHP_EOL.$lastStandard.' ('.$lastCount.' sniff';                if ($lastCount > 1) {                    echo 's';                }                echo ')'.PHP_EOL;                echo str_repeat('-', (strlen($lastStandard.$lastCount) + 10));                echo PHP_EOL;                echo $sniffList;                $lastStandard = $currentStandard;                $lastCount    = 0;                if ($currentStandard === null) {                    break;                }                ob_start();            }//end if            echo '  '.$sniff.PHP_EOL;            $lastCount++;        }//end foreach    }//end explain()",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
295,symfony_http-foundation_FileBag_7860," Fixes a malformed PHP $_FILES array.\n\n PHP has a bug that the format of the $_FILES array differs, depending on\n whether the uploaded file fields had normal field names or array-like\n field names (""normal"" vs. ""parent[child]"").\n\n This method fixes the array to look like the ""normal"" $_FILES array.\n\n It\'s safe to pass an already converted array, in which case this method\n just returns the original array unmodified.\n\n @param array $data\n\n @return array\n","Ispravlja pogrešno oblikovan PHP $ _FILES niz. PHP ima grešku u tome što se format niza $ _FILES razlikuje, u zavisnosti od toga da li su otpremljena polja datoteka imala normalna imena polja ili imena polja poput (""normal"" vs. ""parent[child]""). Ovaj metod popravlja niz tako da izgleda kao ""normalni"" niz $ _FILES. Sigurno je proslediti već pretvoreni niz, u tom slučaju ovaj metod samo vraća originalni niz neizmenjen","    protected function fixPhpFilesArray($data)    {        $keys = array_keys($data);        sort($keys);        if (self::FILE_KEYS != $keys || !isset($data['name']) || !\is_array($data['name'])) {            return $data;        }        $files = $data;        foreach (self::FILE_KEYS as $k) {            unset($files[$k]);        }        foreach ($data['name'] as $key => $name) {            $files[$key] = $this->fixPhpFilesArray([                'error' => $data['error'][$key],                'name' => $name,                'type' => $data['type'][$key],                'tmp_name' => $data['tmp_name'][$key],                'size' => $data['size'][$key],            ]);        }        return $files;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
296,twigphp_Twig_NodeTraverser_10135, Traverses a node and calls the registered visitors.\n,Prelazi čvor i poziva registrovane posetioce,"    public function traverse(Node $node): Node    {        ksort($this->visitors);        foreach ($this->visitors as $visitors) {            foreach ($visitors as $visitor) {                $node = $this->traverseForVisitor($visitor, $node);            }        }        return $node;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
297,walkor_Workerman_Worker_6966, Get global event-loop instance.\n\n @return EventInterface\n,Nabavite globalnu instancu petlje događaja,"    protected static function formatStatusData($statistics_file)    {        static $total_request_cache = array();        if (!\is_readable($statistics_file)) {            return '';        }        $info = \file($statistics_file, \FILE_IGNORE_NEW_LINES);        if (!$info) {            return '';        }        $status_str = '';        $current_total_request = array();        $worker_info = \unserialize($info[0]);        \ksort($worker_info, SORT_NUMERIC);        unset($info[0]);        $data_waiting_sort = array();        $read_process_status = false;        $total_requests = 0;        $total_qps = 0;        $total_connections = 0;        $total_fails = 0;        $total_memory = 0;        $total_timers = 0;        $maxLen1 = static::$_maxSocketNameLength;        $maxLen2 = static::$_maxWorkerNameLength;        foreach($info as $key => $value) {            if (!$read_process_status) {                $status_str .= $value . ""\n"";                if (\preg_match('/^pid.*?memory.*?listening/', $value)) {                    $read_process_status = true;                }                continue;            }            if(\preg_match('/^[0-9]+/', $value, $pid_math)) {                $pid = $pid_math[0];                $data_waiting_sort[$pid] = $value;                if(\preg_match('/^\S+?\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?(\S+?)\s+?/', $value, $match)) {                    $total_memory += \intval(\str_ireplace('M','',$match[1]));                    $maxLen1 = \max($maxLen1,\strlen($match[2]));                    $maxLen2 = \max($maxLen2,\strlen($match[3]));                    $total_connections += \intval($match[4]);                    $total_fails += \intval($match[5]);                    $total_timers += \intval($match[6]);                    $current_total_request[$pid] = $match[7];                    $total_requests += \intval($match[7]);                }            }        }        foreach($worker_info as $pid => $info) {            if (!isset($data_waiting_sort[$pid])) {                $status_str .= ""$pid\t"" . \str_pad('N/A', 7) . "" ""                    . \str_pad($info['listen'], static::$_maxSocketNameLength) . "" ""                    . \str_pad($info['name'], static::$_maxWorkerNameLength) . "" ""                    . \str_pad('N/A', 11) . "" "" . \str_pad('N/A', 9) . "" ""                    . \str_pad('N/A', 7) . "" "" . \str_pad('N/A', 13) . "" N/A    [busy] \n"";                continue;            }            //$qps = isset($total_request_cache[$pid]) ? $current_total_request[$pid]            if (!isset($total_request_cache[$pid]) || !isset($current_total_request[$pid])) {                $qps = 0;            } else {                $qps = $current_total_request[$pid] - $total_request_cache[$pid];                $total_qps += $qps;            }            $status_str .= $data_waiting_sort[$pid]. "" "" . \str_pad($qps, 6) ."" [idle]\n"";        }        $total_request_cache = $current_total_request;        $status_str .= ""----------------------------------------------PROCESS STATUS---------------------------------------------------\n"";        $status_str .= ""Summary\t"" . \str_pad($total_memory.'M', 7) . "" ""            . \str_pad('-', $maxLen1) . "" ""            . \str_pad('-', $maxLen2) . "" ""            . \str_pad($total_connections, 11) . "" "" . \str_pad($total_fails, 9) . "" ""            . \str_pad($total_timers, 7) . "" "" . \str_pad($total_requests, 13) . "" ""            . \str_pad($total_qps,6)."" [Summary] \n"";        return $status_str;    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
298,yiisoft_yii2_BaseYii_991, Returns a string representing the current version of the Yii framework.\\\\n @return string the version of Yii framework\\\\n,Prikazuje niz koji predstavlja trenutnu verziju Iii okvira,"    public static function setAlias($alias, $path)    {        if (strncmp($alias, '@', 1)) {            $alias = '@' . $alias;        }        $pos = strpos($alias, '/');        $root = $pos === false ? $alias : substr($alias, 0, $pos);        if ($path !== null) {            $path = strncmp($path, '@', 1) ? rtrim($path, '\\/') : static::getAlias($path);            if (!isset(static::$aliases[$root])) {                if ($pos === false) {                    static::$aliases[$root] = $path;                } else {                    static::$aliases[$root] = [$alias => $path];                }            } elseif (is_string(static::$aliases[$root])) {                if ($pos === false) {                    static::$aliases[$root] = $path;                } else {                    static::$aliases[$root] = [                        $alias => $path,                        $root => static::$aliases[$root],                    ];                }            } else {                static::$aliases[$root][$alias] = $path;                krsort(static::$aliases[$root]);            }        } elseif (isset(static::$aliases[$root])) {            if (is_array(static::$aliases[$root])) {                unset(static::$aliases[$root][$alias]);            } elseif ($pos === false) {                unset(static::$aliases[$root]);            }        }    }",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
299,yiisoft_yii2_PhpDocController_965, Markdown aware fix of whitespace issues in doc comments.\\n @param array $lines\\n,Ispravljanje problema sa praznim prostorom u komentarima dokumenata,"class ReleaseController extends Controller{    public $defaultAction = 'release';    /**     * @var string base path to use for releases.     */    public $basePath;    /**     * @var bool whether to make actual changes. If true, it will run without changing or pushing anything.     */    public $dryRun = false;    /**     * @var bool whether to fetch latest tags.     */    public $update = false;    /**     * @var string override the default version. e.g. for major or patch releases.     */    public $version;    public function options($actionID)    {        $options = ['basePath'];        if ($actionID === 'release') {            $options[] = 'dryRun';            $options[] = 'version';        } elseif ($actionID === 'sort-changelog') {            $options[] = 'version';        } elseif ($actionID === 'info') {            $options[] = 'update';        }        return array_merge(parent::options($actionID), $options);    }    public function beforeAction($action)    {        if (!$this->interactive) {            throw new Exception('Sorry, but releases should be run interactively to ensure you actually verify what you are doing ;)');        }        if ($this->basePath === null) {            $this->basePath = \dirname(\dirname(__DIR__));        }        $this->basePath = rtrim($this->basePath, '\\/');        return parent::beforeAction($action);    }    /**     * Shows information about current framework and extension versions.     */    public function actionInfo()    {        $items = [            'framework',            'app-basic',            'app-advanced',        ];        $extensionPath = ""{$this->basePath}/extensions"";        foreach (scandir($extensionPath) as $extension) {            if (ctype_alpha($extension) && is_dir($extensionPath . '/' . $extension)) {                $items[] = $extension;            }        }        if ($this->update) {            foreach ($items as $item) {                $this->stdout(""fetching tags for $item..."");                if ($item === 'framework') {                    $this->gitFetchTags((string)$this->basePath);                } elseif (strncmp('app-', $item, 4) === 0) {                    $this->gitFetchTags(""{$this->basePath}/apps/"" . substr($item, 4));                } else {                    $this->gitFetchTags(""{$this->basePath}/extensions/$item"");                }                $this->stdout(""done.\n"", Console::FG_GREEN, Console::BOLD);            }        } else {            $this->stdout(""\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n"");        }        $versions = $this->getCurrentVersions($items);        $nextVersions = $this->getNextVersions($versions, self::PATCH);        // print version table        $w = $this->minWidth(array_keys($versions));        $this->stdout(str_repeat(' ', $w + 2) . ""Current Version  Next Version\n"", Console::BOLD);        foreach ($versions as $ext => $version) {            $this->stdout($ext . str_repeat(' ', $w + 3 - mb_strlen($ext)) . $version . '');            $this->stdout(str_repeat(' ', 17 - mb_strlen($version)) . $nextVersions[$ext] . ""\n"");        }    }    private function minWidth($a)    {        $w = 1;        foreach ($a as $s) {            if (($l = mb_strlen($s)) > $w) {                $w = $l;            }        }        return $w;    }    /**     * Automation tool for making Yii framework and official extension releases.     *     * Usage:     *     * To make a release, make sure your git is clean (no uncommitted changes) and run the following command in     * the yii dev repo root:     *     * ```     * ./build/build release framework     * ```     *     * or     *     * ```     * ./build/build release redis,bootstrap,apidoc     * ```     *     * You may use the `--dryRun` switch to test the command without changing or pushing anything:     *     * ```     * ./build/build release redis --dryRun     * ```     *     * The command will guide you through the complete release process including changing of files,     * committing and pushing them. Each git command must be confirmed and can be skipped individually.     * You may adjust changes in a separate shell or your IDE while the command is waiting for confirmation.     *     * @param array $what what do you want to release? this can either be:     *     * - an extension name such as `redis` or `bootstrap`,     * - an application indicated by prefix `app-`, e.g. `app-basic`,     * - or `framework` if you want to release a new version of the framework itself.     *     * @return int     */    public function actionRelease(array $what)    {        if (\count($what) > 1) {            $this->stdout(""Currently only one simultaneous release is supported.\n"");            return 1;        }        $this->stdout(""This is the Yii release manager\n\n"", Console::BOLD);        if ($this->dryRun) {            $this->stdout(""Running in \""dry-run\"" mode, nothing will actually be changed.\n\n"", Console::BOLD, Console::FG_GREEN);        }        $this->validateWhat($what);        $versions = $this->getCurrentVersions($what);        if ($this->version !== null) {            // if a version is explicitly given            $newVersions = [];            foreach ($versions as $k => $v) {                $newVersions[$k] = $this->version;            }        } else {            // otherwise get next patch or minor            $newVersions = $this->getNextVersions($versions, self::PATCH);        }        $this->stdout(""You are about to prepare a new release for the following things:\n\n"");        $this->printWhat($what, $newVersions, $versions);        $this->stdout(""\n"");        $this->stdout(""Before you make a release briefly go over the changes and check if you spot obvious mistakes:\n\n"", Console::BOLD);        $gitDir = reset($what) === 'framework' ? 'framework/' : '';        $gitVersion = $versions[reset($what)];        if (strncmp('app-', reset($what), 4) !== 0) {            $this->stdout(""- no accidentally added CHANGELOG lines for other versions than this one?\n\n    git diff $gitVersion.. ${gitDir}CHANGELOG.md\n\n"");            $this->stdout(""- are all new `@since` tags for this release version?\n"");        }        $this->stdout(""- other issues with code changes?\n\n    git diff -w $gitVersion.. ${gitDir}\n\n"");        $travisUrl = reset($what) === 'framework' ? '' : '-' . reset($what);        $this->stdout(""- are unit tests passing on travis? https://travis-ci.com/yiisoft/yii2$travisUrl/builds\n"");        $this->stdout(""- also make sure the milestone on github is complete and no issues or PRs are left open.\n\n"");        $this->printWhatUrls($what, $versions);        $this->stdout(""\n"");        if (!$this->confirm('When you continue, this tool will run cleanup jobs and update the changelog as well as other files (locally). Continue?', false)) {            $this->stdout(""Canceled.\n"");            return 1;        }        foreach ($what as $ext) {            if ($ext === 'framework') {                $this->releaseFramework(""{$this->basePath}/framework"", $newVersions['framework']);            } elseif (strncmp('app-', $ext, 4) === 0) {                $this->releaseApplication(substr($ext, 4), ""{$this->basePath}/apps/"" . substr($ext, 4), $newVersions[$ext]);            } else {                $this->releaseExtension($ext, ""{$this->basePath}/extensions/$ext"", $newVersions[$ext]);            }        }        return 0;    }    /**     * This will generate application packages for download page.     *     * Usage:     *     * ```     * ./build/build release/package app-basic     * ```     *     * @param array $what what do you want to package? this can either be:     *     * - an application indicated by prefix `app-`, e.g. `app-basic`,     *     * @return int     */    public function actionPackage(array $what)    {        $this->validateWhat($what, ['app']);        $versions = $this->getCurrentVersions($what);        $this->stdout(""You are about to generate packages for the following things:\n\n"");        foreach ($what as $ext) {            if (strncmp('app-', $ext, 4) === 0) {                $this->stdout(' - ');                $this->stdout(substr($ext, 4), Console::FG_RED);                $this->stdout(' application version ');            } elseif ($ext === 'framework') {                $this->stdout(' - Yii Framework version ');            } else {                $this->stdout(' - ');                $this->stdout($ext, Console::FG_RED);                $this->stdout(' extension version ');            }            $this->stdout($versions[$ext], Console::BOLD);            $this->stdout(""\n"");        }        $this->stdout(""\n"");        $packagePath = ""{$this->basePath}/packages"";        $this->stdout(""Packages will be stored in $packagePath\n\n"");        if (!$this->confirm('Continue?', false)) {            $this->stdout(""Canceled.\n"");            return 1;        }        foreach ($what as $ext) {            if ($ext === 'framework') {                throw new Exception('Can not package framework.');            } elseif (strncmp('app-', $ext, 4) === 0) {                $this->packageApplication(substr($ext, 4), $versions[$ext], $packagePath);            } else {                throw new Exception('Can not package extension.');            }        }        $this->stdout(""\ndone. verify the versions composer installed above and push it to github!\n\n"");        return 0;    }    /**     * Sorts CHANGELOG for framework or extension.     *     * @param array $what what do you want to resort changelog for? this can either be:     *     * - an extension name such as `redis` or `bootstrap`,     * - or `framework` if you want to release a new version of the framework itself.     */    public function actionSortChangelog(array $what)    {        if (\count($what) > 1) {            $this->stdout(""Currently only one simultaneous release is supported.\n"");            return 1;        }        $this->validateWhat($what, ['framework', 'ext'], false);        $version = $this->version ?: array_values($this->getNextVersions($this->getCurrentVersions($what), self::PATCH))[0];        $this->stdout('sorting CHANGELOG of ');        $this->stdout(reset($what), Console::BOLD);        $this->stdout(' for version ');        $this->stdout($version, Console::BOLD);        $this->stdout('...');        $this->resortChangelogs($what, $version);        $this->stdout(""done.\n"", Console::BOLD, Console::FG_GREEN);    }    protected function printWhat(array $what, $newVersions, $versions)    {        foreach ($what as $ext) {            if (strncmp('app-', $ext, 4) === 0) {                $this->stdout(' - ');                $this->stdout(substr($ext, 4), Console::FG_RED);                $this->stdout(' application version ');            } elseif ($ext === 'framework') {                $this->stdout(' - Yii Framework version ');            } else {                $this->stdout(' - ');                $this->stdout($ext, Console::FG_RED);                $this->stdout(' extension version ');            }            $this->stdout($newVersions[$ext], Console::BOLD);            $this->stdout("", last release was {$versions[$ext]}\n"");        }    }    protected function printWhatUrls(array $what, $oldVersions)    {        foreach ($what as $ext) {            if ($ext === 'framework') {                $this->stdout(""framework:    https://github.com/yiisoft/yii2-framework/compare/{$oldVersions[$ext]}...master\n"");                $this->stdout(""app-basic:    https://github.com/yiisoft/yii2-app-basic/compare/{$oldVersions[$ext]}...master\n"");                $this->stdout(""app-advanced: https://github.com/yiisoft/yii2-app-advanced/compare/{$oldVersions[$ext]}...master\n"");            } else {                $this->stdout($ext, Console::FG_RED);                $this->stdout("": https://github.com/yiisoft/yii2-$ext/compare/{$oldVersions[$ext]}...master\n"");            }        }    }    /**     * @param array $what list of items     * @param array $limit list of things to allow, or empty to allow any, can be `app`, `framework`, `extension`     * @param bool $ensureGitClean     * @throws \yii\base\Exception     */    protected function validateWhat(array $what, $limit = [], $ensureGitClean = true)    {        foreach ($what as $w) {            if (strncmp('app-', $w, 4) === 0) {                if (!empty($limit) && !\in_array('app', $limit)) {                    throw new Exception('Only the following types are allowed: ' . implode(', ', $limit) . ""\n"");                }                if (!is_dir($appPath = ""{$this->basePath}/apps/"" . substr($w, 4))) {                    throw new Exception(""Application path does not exist: \""{$appPath}\""\n"");                }                if ($ensureGitClean) {                    $this->ensureGitClean($appPath);                }            } elseif ($w === 'framework') {                if (!empty($limit) && !\in_array('framework', $limit)) {                    throw new Exception('Only the following types are allowed: ' . implode(', ', $limit) . ""\n"");                }                if (!is_dir($fwPath = ""{$this->basePath}/framework"")) {                    throw new Exception(""Framework path does not exist: \""{$this->basePath}/framework\""\n"");                }                if ($ensureGitClean) {                    $this->ensureGitClean($fwPath);                }            } else {                if (!empty($limit) && !\in_array('ext', $limit)) {                    throw new Exception('Only the following types are allowed: ' . implode(', ', $limit) . ""\n"");                }                if (!is_dir($extPath = ""{$this->basePath}/extensions/$w"")) {                    throw new Exception(""Extension path for \""$w\"" does not exist: \""{$this->basePath}/extensions/$w\""\n"");                }                if ($ensureGitClean) {                    $this->ensureGitClean($extPath);                }            }",0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
300,yiisoft_yii2_Utf8Controller_985, Equivalent for ord() just for unicode.\\n\\n http://stackoverflow.com/a/10333324/1106908\\n\\n @param $c\\n @return bool|int\\n,Ekvivalent za ord () samo za unicode http://stackoverflow.com/a/10333324/1106908,"class YiiConfig extends Config{    /**     * {@inheritdoc}     */    public function __construct($name = 'yii-cs-config')    {        parent::__construct($name);        $this->setRiskyAllowed(true);        $this->setRules([            '@PSR2' => true,            'array_syntax' => [                'syntax' => 'short',            ],            'binary_operator_spaces' => [                'align_double_arrow' => false,                'align_equals' => false,            ],            'blank_line_after_opening_tag' => true,            'cast_spaces' => true,            'concat_space' => [                'spacing' => 'one',            ],            'dir_constant' => true,            'ereg_to_preg' => true,            'function_typehint_space' => true,            'hash_to_slash_comment' => true,            'include' => true,            'heredoc_to_nowdoc' => true,            'is_null' => [                'use_yoda_style' => false,            ],            'linebreak_after_opening_tag' => true,            'lowercase_cast' => true,            'magic_constant_casing' => true,//            'mb_str_functions' => true, // needs more discussion//            'method_separation' => true, // conflicts with current Yii style with double line between properties and methods            'modernize_types_casting' => true,            'native_function_casing' => true,            'new_with_braces' => true,            'no_alias_functions' => true,            'no_blank_lines_after_class_opening' => true,            'no_blank_lines_after_phpdoc' => true,            'no_empty_comment' => true,            'no_empty_phpdoc' => true,            'no_empty_statement' => true,            'no_extra_consecutive_blank_lines' => [                'tokens' => [                    'break',                    'continue',//                    'extra', // conflicts with current Yii style with double line between properties and methods                    'return',                    'throw',                    'use',                    'use_trait',//                    'curly_brace_block', // breaks namespaces blocks                    'parenthesis_brace_block',                    'square_brace_block',                ],            ],            'no_leading_import_slash' => true,            'no_leading_namespace_whitespace' => true,            'no_mixed_echo_print' => true,            'no_multiline_whitespace_around_double_arrow' => true,            'no_multiline_whitespace_before_semicolons' => true,            'no_php4_constructor' => true,            'no_short_bool_cast' => true,            'no_singleline_whitespace_before_semicolons' => true,            'no_spaces_around_offset' => true,            'no_trailing_comma_in_list_call' => true,            'no_trailing_comma_in_singleline_array' => true,            'no_unneeded_control_parentheses' => true,            'no_unused_imports' => true,            'no_useless_else' => true,            'no_useless_return' => true,            'no_whitespace_before_comma_in_array' => true,            'no_whitespace_in_blank_line' => true,            'non_printable_character' => true,            'normalize_index_brace' => true,            'object_operator_without_whitespace' => true,//            'ordered_class_elements' => [ // needs more discussion//                'order' => [//                    'use_trait',//                    'constant_public',//                    'constant_protected',//                    'constant_private',//                    'property_public',//                    'property_protected',//                    'property_private',//                    'construct',//                    'destruct',//                    'magic',//                ],//            ],            'ordered_imports' => [                'sortAlgorithm' => 'alpha',                'importsOrder' => [                    'const',                    'function',                    'class',                ],            ],            'php_unit_construct' => true,            'php_unit_dedicate_assert' => true,            'php_unit_fqcn_annotation' => true,//            'php_unit_strict' => true, // needs more attention            'phpdoc_add_missing_param_annotation' => true,            'phpdoc_indent' => true,//            'phpdoc_inline_tag' => true, // see https://github.com/yiisoft/yii2/issues/11635            'phpdoc_no_access' => true,            'phpdoc_no_empty_return' => true,            'phpdoc_no_package' => true,            'phpdoc_no_useless_inheritdoc' => true,//            'phpdoc_order', // may be useful, but should be configurable: https://github.com/FriendsOfPHP/PHP-CS-Fixer/issues/1602            'phpdoc_return_self_reference' => true,            'phpdoc_scalar' => true,            'phpdoc_single_line_var_spacing' => true,            'phpdoc_summary' => true,//            'phpdoc_to_comment' => true, // breaks phpdoc for define('CONSTANT', $value);            'phpdoc_trim' => true,            'phpdoc_types' => true,            'phpdoc_var_without_name' => true,            'protected_to_private' => true,            'psr4' => true,            'self_accessor' => true,            'short_scalar_cast' => true,            'single_blank_line_before_namespace' => true,            'single_quote' => true,            'standardize_not_equals' => true,            'ternary_operator_spaces' => true,            'trailing_comma_in_multiline_array' => true,            'trim_array_spaces' => true,            'unary_operator_spaces' => true,            'whitespace_after_comma_in_array' => true,        ]);    }    /**     * Merge current rules config with provided list of rules.     *     * @param array $rules     * @return $this     * @see setRules()     * @see ArrayHelper::merge()     */    public function mergeRules(array $rules)    {        $this->setRules(ArrayHelper::merge($this->getRules(), $rules));        return $this;    }}",0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
302,Intervention_image_BackupCommand_657, Saves a backups of current state of image core\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Čuva rezervne kopije trenutnog stanja jezgra slike,"    public function execute($image)    {        $backupName = $this->argument(0)->value();        // clone current image resource        $clone = clone $image;        $image->setBackup($clone->getCore(), $backupName);        return true;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
303,PHPOffice_PHPWord_TemplateProcessorTest_1026, Template can be saved in temporary location.\n\n @covers ::save\n @covers ::zip\n @test\n,Predložak se može sačuvati na privremenoj lokaciji,"    final public function testTemplateCanBeSavedInTemporaryLocation()    {        $templateFqfn = __DIR__ . '/_files/templates/with_table_macros.docx';        $templateProcessor = new TemplateProcessor($templateFqfn);        $xslDomDocument = new \DOMDocument();        $xslDomDocument->load(__DIR__ . '/_files/xsl/remove_tables_by_needle.xsl');        foreach (array('${employee.', '${scoreboard.', '${reference.') as $needle) {            $templateProcessor->applyXslStyleSheet($xslDomDocument, array('needle' => $needle));        }        $embeddingText = 'The quick Brown Fox jumped over the lazy^H^H^H^Htired unitTester';        $templateProcessor->zip()->AddFromString('word/embeddings/fox.bin', $embeddingText);        $documentFqfn = $templateProcessor->save();        $this->assertNotEmpty($documentFqfn, 'FQFN of the saved document is empty.');        $this->assertFileExists($documentFqfn, ""The saved document \""{$documentFqfn}\"" doesn't exist."");        $templateZip = new \ZipArchive();        $templateZip->open($templateFqfn);        $templateHeaderXml = $templateZip->getFromName('word/header1.xml');        $templateMainPartXml = $templateZip->getFromName('word/document.xml');        $templateFooterXml = $templateZip->getFromName('word/footer1.xml');        if (false === $templateZip->close()) {            throw new \Exception(""Could not close zip file \""{$templateZip}\""."");        }        $documentZip = new \ZipArchive();        $documentZip->open($documentFqfn);        $documentHeaderXml = $documentZip->getFromName('word/header1.xml');        $documentMainPartXml = $documentZip->getFromName('word/document.xml');        $documentFooterXml = $documentZip->getFromName('word/footer1.xml');        $documentEmbedding = $documentZip->getFromName('word/embeddings/fox.bin');        if (false === $documentZip->close()) {            throw new \Exception(""Could not close zip file \""{$documentZip}\""."");        }        $this->assertNotEquals($templateHeaderXml, $documentHeaderXml);        $this->assertNotEquals($templateMainPartXml, $documentMainPartXml);        $this->assertNotEquals($templateFooterXml, $documentFooterXml);        $this->assertEquals($embeddingText, $documentEmbedding);        return $documentFqfn;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
304,PHPOffice_PHPWord_TemplateProcessor_949, Saves the result document.\n\n @throws \\PhpOffice\\PhpWord\\Exception\\Exception\n\n @return string\n,Čuva rezultujući dokument,"    public function save()    {        foreach ($this->tempDocumentHeaders as $index => $xml) {            $this->savePartWithRels($this->getHeaderName($index), $xml);        }        $this->savePartWithRels($this->getMainPartName(), $this->tempDocumentMainPart);        $this->savePartWithRels($this->getSettingsPartName(), $this->tempDocumentSettingsPart);        foreach ($this->tempDocumentFooters as $index => $xml) {            $this->savePartWithRels($this->getFooterName($index), $xml);        }        $this->zipClass->addFromString($this->getDocumentContentTypesName(), $this->tempDocumentContentTypes);        // Close zip file        if (false === $this->zipClass->close()) {            throw new Exception('Could not close zip file.'); // @codeCoverageIgnore        }        return $this->tempDocumentFilename;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
305,PHPOffice_PHPExcel_Calculation_161, Get a list of all implemented functions as an array of function objects\\\\n\\\\n @return    array of PHPExcel_Calculation_Function\\\\n,Nabavite listu svih implementiranih funkcija kao niz objekata funkcije,"    public function listFunctions()    {        $returnValue = array();        foreach (self::$PHPExcelFunctions as $functionName => $function) {            if ($function['functionCall'] != 'PHPExcel_Calculation_Functions::DUMMY') {                $returnValue[$functionName] = new PHPExcel_Calculation_Function(                    $function['category'],                    $functionName,                    $function['functionCall']                );            }        }        return $returnValue;    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
306,PHPOffice_PHPExcel_Calculation_163, Get a list of implemented Excel function names\\n\\n @return    array\\n,Nabavite listu implementiranih imena Excel funkcija,    public function listFunctionNames()    {        $returnValue = array();        foreach (self::$PHPExcelFunctions as $functionName => $function) {            if ($function['functionCall'] != 'PHPExcel_Calculation_Functions::DUMMY') {                $returnValue[] = $functionName;            }        }        return $returnValue;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
307,PrestaShop_PrestaShop_AdminAttributesGroupsController_873, Overrides parent to delete items from sublist.\\n\\n @return mixed\\n,Zamenjuje nadređenog za brisanje stavki sa podspisa,    public function processBulkDelete()    {        // If we are deleting attributes instead of attribute_groups        if (Tools::getIsset('attributeBox')) {            $this->className = 'Attribute';            $this->table = 'attribute';            $this->boxes = Tools::getValue($this->table . 'Box');        }        $result = parent::processBulkDelete();        // Restore vars        $this->className = 'AttributeGroup';        $this->table = 'attribute_group';        return $result;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
308,botman_botman_BotMan_1262, Set a fallback message to use if no listener matches.\n\n @param callable $callback\n,Podesite rezervnu poruku koja će se koristiti ako se nijedan listener ne podudara,    public function fallback($callback)    {        $this->fallbackMessage = $callback;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
309,briannesbitt_Carbon_Language_364, Get the list of the known languages.\\n\\n @return array\\n,Dođite do liste poznatih jezika,    public static function all()    {        if (!static::$languagesNames) {            static::$languagesNames = require __DIR__.'/List/languages.php';        }        return static::$languagesNames;    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
310,dompdf_dompdf_Cpdf_376, Embeds a file inside the PDF\n\n @param string $filepath path to the file to store inside the PDF\n @param string $embeddedFilename the filename displayed in the list of embedded files\n @param string $description a description in the list of embedded files\n,Ugrađuje datoteku u PDF,"    public function addEmbeddedFile(string $filepath, string $embeddedFilename, string $description): void    {        $this->numObj++;        $this->o_embedded_file_dictionary(            $this->numObj,            'new',            [                'filepath' => $filepath,                'filename' => $embeddedFilename,                'description' => $description            ]        );    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
311,googleapis_google-api-php-client_Client_633, Returns the list of scopes requested by the client\\\\n @return array the list of scopes\\\\n\\\\n,Vraća listu opsega koje zahteva klijent,  public function getScopes()  {     return $this->requestedScopes;  },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
312,markrogoyski_math-php_Average_3439, Calculate the median average of a list of numbers\\n\\n @param float[] $numbers\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n @throws Exception\\\\OutOfBoundsException if kth-smallest k is out of bounds\\n,Izračunajte srednji prosek liste brojeva,"    public static function median(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median of an empty list of numbers');        }        if (\count($numbers) === 1) {            return \array_pop($numbers);        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // For odd number of numbers, take the middle indexed number        if (\count($numbers) % 2 == 1) {            $middle_index = \intdiv(\count($numbers), 2);            return self::kthSmallest($numbers, $middle_index);        }        // For even number of items, take the mean of the middle two indexed numbers        $left_middle_index  = \intdiv(\count($numbers), 2) - 1;        $left_median        = self::kthSmallest($numbers, $left_middle_index);        $right_middle_index = $left_middle_index + 1;        $right_median       = self::kthSmallest($numbers, $right_middle_index);        return self::mean([ $left_median, $right_median ]);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
313,markrogoyski_math-php_Average_3465," Get a report of all the averages over a list of numbers\n Includes mean, median mode, geometric mean, harmonic mean, quardratic mean\n\n @param array $numbers\n\n @return array [ mean, median, mode, geometric_mean, harmonic_mean,\n                 contraharmonic_mean, quadratic_mean, trimean, iqm, cubic_mean ]\n\n @throws Exception\\BadDataException\n @throws Exception\\OutOfBoundsException\n","Dohvatite izveštaj o svim prosecima preko liste brojeva. Uključuje srednju vrednost, medijanu, geometrijsku sredinu, harmoničnu sredinu, kvadratnu sredinu","    public static function describe(array $numbers): array    {        return [            'mean'                => self::mean($numbers),            'median'              => self::median($numbers),            'mode'                => self::mode($numbers),            'geometric_mean'      => self::geometricMean($numbers),            'harmonic_mean'       => self::harmonicMean($numbers),            'contraharmonic_mean' => self::contraharmonicMean($numbers),            'quadratic_mean'      => self::quadraticMean($numbers),            'trimean'             => self::trimean($numbers),            'iqm'                 => self::iqm($numbers),            'cubic_mean'          => self::cubicMean($numbers),        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
314,mockery_mockery_Expectation_447, Return a string with the method name and arguments formatted\\\\\\\\n\\\\\\\\n @param string $name Name of the expected method\\\\\\\\n @param array $args List of arguments to the method\\\\\\\\n @return string\\\\\\\\n,Vrati niz sa formatiranim imenom metode i argumentima,"    public function __toString()    {        return \Mockery::formatArgs($this->_name, $this->_expectedArgs);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
315,markrogoyski_math-php_NumericDiagonalMatrix_2704, Diagonal matrix\\n Elements along the main diagonal are the only non-zero elements (may also be zero).\\n The off-diagonal elements are all zero\\n,Dijagonalna matrica. Elementi duž glavne dijagonale su jedini elementi koji nisu nula (mogu biti i nula). Svi elementi izvan dijagonale su nula,"class NumericDiagonalMatrix extends NumericSquareMatrix{    /**     * Constructor     *     * @param array $A     */    public function __construct(array $A)    {        parent::__construct($A);        if (!parent::isLowerTriangular() || !parent::isUpperTriangular()) {            throw new MatrixException('Trying to construct DiagonalMatrix with non-diagonal elements: ' . \print_r($this->A, true));        }    }    /**     * Diagonal matrix must be symmetric     * @inheritDoc     */    public function isSymmetric(): bool    {        return true;    }    /**     * Diagonal matrix must be lower triangular     * @inheritDoc     */    public function isLowerTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be upper triangular     * @inheritDoc     */    public function isUpperTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be triangular     * @inheritDoc     */    public function isTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be diagonal     * @inheritDoc     */    public function isDiagonal(): bool    {        return true;    }}",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
316,markrogoyski_math-php_Hypergeometric_3242," Mode of the distribution\\n\\n         _              _\\n        | (n + 1)(K + 1) |       | (n + 1)(K + 1) |\\n mode = | -------------- | - 1,  | -------------- |\\n        |    (N + 2)     |       |_    (N + 2)   _|\\n\\n @return float[]\\n","Način distribucije   | (n + 1)(K + 1) |       | (n + 1)(K + 1) |\\n mode = | -------------- | - 1,  | -------------- |\\n        |    (N + 2)     |       |_    (N + 2)   ","    public function mode(): array    {        $N = $this->N;        $K = $this->K;        $n = $this->n;        return [            \ceil((($n + 1) * ($K + 1)) / ($N + 2)) - 1,            \floor((($n + 1) * ($K + 1)) / ($N + 2)),        ];    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
317,walkor_Workerman_AsyncTcpConnection_7397, Check connection is successfully established or faild.\n\n @param resource $socket\n @return void\n,Proverite da li je veza uspešno uspostavljena ili nije uspela,    public function cancelReconnect()    {        if ($this->_reconnectTimer) {            Timer::del($this->_reconnectTimer);        }    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
318,walkor_Workerman_Worker_7009, Parse local socket address.\n\n @throws Exception\n,Analizirajte adresu lokalnog soketa,"    public function run()    {        //Update process state.        static::$_status = static::STATUS_RUNNING;        // Register shutdown function for checking errors.        \register_shutdown_function(array(""\\Workerman\\Worker"", 'checkErrors'));        // Set autoload root path.        Autoloader::setRootPath($this->_autoloadRootPath);        // Create a global event loop.        if (!static::$globalEvent) {            $event_loop_class = static::getEventLoopName();            static::$globalEvent = new $event_loop_class;            $this->resumeAccept();        }        // Reinstall signal.        static::reinstallSignal();        // Init Timer.        Timer::init(static::$globalEvent);        // Set an empty onMessage callback.        if (empty($this->onMessage)) {            $this->onMessage = function () {};        }        \restore_error_handler();        // Try to emit onWorkerStart callback.        if ($this->onWorkerStart) {            try {                \call_user_func($this->onWorkerStart, $this);            } catch (\Exception $e) {                static::log($e);                // Avoid rapid infinite loop exit.                sleep(1);                exit(250);            } catch (\Error $e) {                static::log($e);                // Avoid rapid infinite loop exit.                sleep(1);                exit(250);            }        }        // Main loop.        static::$globalEvent->loop();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
319,symfony_debug_ExceptionHandler_1742," ExceptionHandler converts an exception to a Response object.\\n\\n It is mostly useful in debug mode to replace the default PHP/XDebug\\n output with something prettier and more useful.\\n\\n As this class is mainly used during Kernel boot, where nothing is yet\\n available, the Response content is always HTML.\\n\\n @author Fabien Potencier <fabien@symfony.com>\\n @author Nicolas Grekas <p@tchwork.com>\\n\\n @final since Symfony 4.3\\n\\n @deprecated since Symfony 4.4, use Symfony\\\\Component\\\\ErrorHandler\\\\ErrorHandler instead.\\n","ExceptionHandler pretvara izuzetak u objekat Response. U režimu otklanjanja grešaka uglavnom je korisno zameniti podrazumevani PHP/XSDebug izlaz nečim lepšim i korisnijim. Kako se ova klasa uglavnom koristi tokom pokretanja kernela, gde još uvek ništa nije dostupno, sadržaj odgovora je uvek HTML","class ExceptionHandler{    private const GHOST_ADDONS = [        '02-14' => self::GHOST_HEART,        '02-29' => self::GHOST_PLUS,        '10-18' => self::GHOST_GIFT,    ];    private const GHOST_GIFT = 'M124.005 5.36c.396-.715 1.119-1.648-.124-1.873-.346-.177-.692-.492-1.038-.141-.769.303-1.435.728-.627 1.523.36.514.685 1.634 1.092 1.758.242-.417.47-.842.697-1.266zm-1.699 1.977c-.706-1.26-1.274-2.612-2.138-3.774-1.051-1.123-3.122-.622-3.593.825-.625 1.431.724 3.14 2.251 2.96 1.159.02 2.324.072 3.48-.011zm5.867.043c1.502-.202 2.365-2.092 1.51-3.347-.757-1.34-2.937-1.387-3.698-.025-.659 1.1-1.23 2.25-1.835 3.38 1.336.077 2.686.06 4.023-.008zm2.487 1.611c.512-.45 2.494-.981.993-1.409-.372-.105-.805-.59-1.14-.457-.726.902-1.842 1.432-3.007 1.376-.228.075-1.391-.114-1.077.1.822.47 1.623.979 2.474 1.395.595-.317 1.173-.667 1.757-1.005zm-11.696.255l1.314-.765c-1.338-.066-2.87.127-3.881-.95-.285-.319-.559-.684-.954-.282-.473.326-1.929.66-.808 1.058.976.576 1.945 1.167 2.946 1.701.476-.223.926-.503 1.383-.762zm6.416 2.846c.567-.456 1.942-.89 1.987-1.38-1.282-.737-2.527-1.56-3.87-2.183-.461-.175-.835.094-1.207.328-1.1.654-2.225 1.267-3.288 1.978 1.39.86 2.798 1.695 4.219 2.504.725-.407 1.44-.83 2.16-1.247zm5.692 1.423l1.765-1.114c-.005-1.244.015-2.488-.019-3.732a77.306 77.306 0 0 0-3.51 2.084c-.126 1.282-.062 2.586-.034 3.876.607-.358 1.2-.741 1.798-1.114zm-13.804-.784c.06-1.06.19-2.269-1.09-2.583-.807-.376-1.926-1.341-2.548-1.332-.02 1.195-.01 2.39-.011 3.585 1.192.744 2.364 1.524 3.582 2.226.119-.616.041-1.269.067-1.896zm8.541 4.105l2.117-1.336c-.003-1.284.05-2.57-.008-3.853-.776.223-1.662.91-2.48 1.337l-1.834 1.075c.012 1.37-.033 2.744.044 4.113.732-.427 1.443-.887 2.161-1.336zm-2.957-.72v-2.057c-1.416-.828-2.828-1.664-4.25-2.482-.078 1.311-.033 2.627-.045 3.94 1.416.887 2.817 1.798 4.25 2.655.057-.683.036-1.372.045-2.057zm8.255 2.755l1.731-1.153c-.024-1.218.06-2.453-.062-3.658-1.2.685-2.358 1.464-3.537 2.195.028 1.261-.058 2.536.072 3.786.609-.373 1.2-.777 1.796-1.17zm-13.851-.683l-.014-1.916c-1.193-.746-2.37-1.517-3.58-2.234-.076 1.224-.033 2.453-.044 3.679 1.203.796 2.392 1.614 3.61 2.385.048-.636.024-1.276.028-1.914zm8.584 4.199l2.102-1.396c-.002-1.298.024-2.596-.01-3.893-1.427.88-2.843 1.775-4.25 2.686-.158 1.253-.055 2.545-.056 3.811.437.266 1.553-.912 2.214-1.208zm-2.988-.556c-.085-.894.365-2.154-.773-2.5-1.146-.727-2.288-1.46-3.45-2.163-.17 1.228.008 2.508-.122 3.751a79.399 79.399 0 0 0 4.278 2.885c.117-.641.044-1.32.067-1.973zm-4.872-.236l-5.087-3.396c.002-3.493-.047-6.988.015-10.48.85-.524 1.753-.954 2.627-1.434-.564-1.616.25-3.58 1.887-4.184 1.372-.563 3.025-.055 3.9 1.13l1.906-.978 1.916.987c.915-1.086 2.483-1.706 3.842-1.097 1.631.573 2.52 2.532 1.936 4.145.88.497 1.837.886 2.644 1.492.036 3.473 0 6.946-.003 10.419-3.374 2.233-6.693 4.55-10.122 6.699-.997 0-1.858-1.083-2.783-1.522a735.316 735.316 0 0 1-2.678-1.781z';    private const GHOST_HEART = 'M125.914 8.305c3.036-8.71 14.933 0 0 11.2-14.932-11.2-3.036-19.91 0-11.2z';    private const GHOST_PLUS = 'M111.368 8.97h7.324V1.645h7.512v7.323h7.324v7.513h-7.324v7.323h-7.512v-7.323h-7.324z';    private $debug;    private $charset;    private $handler;    private $caughtBuffer;    private $caughtLength;    private $fileLinkFormat;    public function __construct(bool $debug = true, string $charset = null, $fileLinkFormat = null)    {        $this->debug = $debug;        $this->charset = $charset ?: ini_get('default_charset') ?: 'UTF-8';        $this->fileLinkFormat = $fileLinkFormat;    }    /**     * Registers the exception handler.     *     * @param bool        $debug          Enable/disable debug mode, where the stack trace is displayed     * @param string|null $charset        The charset used by exception messages     * @param string|null $fileLinkFormat The IDE link template     *     * @return static     */    public static function register($debug = true, $charset = null, $fileLinkFormat = null)    {        $handler = new static($debug, $charset, $fileLinkFormat);        $prev = set_exception_handler([$handler, 'handle']);        if (\is_array($prev) && $prev[0] instanceof ErrorHandler) {            restore_exception_handler();            $prev[0]->setExceptionHandler([$handler, 'handle']);        }        return $handler;    }    /**     * Sets a user exception handler.     *     * @param callable $handler An handler that will be called on Exception     *     * @return callable|null The previous exception handler if any     */    public function setHandler(callable $handler = null)    {        $old = $this->handler;        $this->handler = $handler;        return $old;    }    /**     * Sets the format for links to source files.     *     * @param string|FileLinkFormatter $fileLinkFormat The format for links to source files     *     * @return string The previous file link format     */    public function setFileLinkFormat($fileLinkFormat)    {        $old = $this->fileLinkFormat;        $this->fileLinkFormat = $fileLinkFormat;        return $old;    }    /**     * Sends a response for the given Exception.     *     * To be as fail-safe as possible, the exception is first handled     * by our simple exception handler, then by the user exception handler.     * The latter takes precedence and any output from the former is cancelled,     * if and only if nothing bad happens in this handling path.     */    public function handle(\Exception $exception)    {        if (null === $this->handler || $exception instanceof OutOfMemoryException) {            $this->sendPhpResponse($exception);            return;        }        $caughtLength = $this->caughtLength = 0;        ob_start(function ($buffer) {            $this->caughtBuffer = $buffer;            return '';        });        $this->sendPhpResponse($exception);        while (null === $this->caughtBuffer && ob_end_flush()) {            // Empty loop, everything is in the condition        }        if (isset($this->caughtBuffer[0])) {            ob_start(function ($buffer) {                if ($this->caughtLength) {                    // use substr_replace() instead of substr() for mbstring overloading resistance                    $cleanBuffer = substr_replace($buffer, '', 0, $this->caughtLength);                    if (isset($cleanBuffer[0])) {                        $buffer = $cleanBuffer;                    }                }                return $buffer;            });            echo $this->caughtBuffer;            $caughtLength = ob_get_length();        }        $this->caughtBuffer = null;        try {            ($this->handler)($exception);            $this->caughtLength = $caughtLength;        } catch (\Exception $e) {            if (!$caughtLength) {                // All handlers failed. Let PHP handle that now.                throw $exception;            }        }    }    /**     * Sends the error associated with the given Exception as a plain PHP response.     *     * This method uses plain PHP functions like header() and echo to output     * the response.     *     * @param \Throwable|FlattenException $exception A \Throwable or FlattenException instance     */    public function sendPhpResponse($exception)    {        if ($exception instanceof \Throwable) {            $exception = FlattenException::createFromThrowable($exception);        }        if (!headers_sent()) {            header(sprintf('HTTP/1.0 %s', $exception->getStatusCode()));            foreach ($exception->getHeaders() as $name => $value) {                header($name.': '.$value, false);            }            header('Content-Type: text/html; charset='.$this->charset);        }        echo $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the full HTML content associated with the given exception.     *     * @param \Exception|FlattenException $exception An \Exception or FlattenException instance     *     * @return string The HTML content as a string     */    public function getHtml($exception)    {        if (!$exception instanceof FlattenException) {            $exception = FlattenException::create($exception);        }        return $this->decorate($this->getContent($exception), $this->getStylesheet($exception));    }    /**     * Gets the HTML content associated with the given exception.     *     * @return string The content as a string     */    public function getContent(FlattenException $exception)    {        switch ($exception->getStatusCode()) {            case 404:                $title = 'Sorry, the page you are looking for could not be found.';                break;            default:                $title = $this->debug ? $this->escapeHtml($exception->getMessage()) : 'Whoops, looks like something went wrong.';        }        if (!$this->debug) {            return <<<EOF                <div class=""container"">                    <h1>$title</h1>                </div>EOF;        }        $content = '';        try {            $count = \count($exception->getAllPrevious());            $total = $count + 1;            foreach ($exception->toArray() as $position => $e) {                $ind = $count - $position + 1;                $class = $this->formatClass($e['class']);                $message = nl2br($this->escapeHtml($e['message']));                $content .= sprintf(<<<'EOF'                    <div class=""trace trace-as-html"">                        <table class=""trace-details"">                            <thead class=""trace-head""><tr><th>                                <h3 class=""trace-class"">                                    <span class=""text-muted"">(%d/%d)</span>                                    <span class=""exception_title"">%s</span>                                </h3>                                <p class=""break-long-words trace-message"">%s</p>                            </th></tr></thead>                            <tbody>EOF                    , $ind, $total, $class, $message);                foreach ($e['trace'] as $trace) {                    $content .= '<tr><td>';                    if ($trace['function']) {                        $content .= sprintf('at <span class=""trace-class"">%s</span><span class=""trace-type"">%s</span><span class=""trace-method"">%s</span>', $this->formatClass($trace['class']), $trace['type'], $trace['function']);                        if (isset($trace['args'])) {                            $content .= sprintf('(<span class=""trace-arguments"">%s</span>)', $this->formatArgs($trace['args']));                        }                    }                    if (isset($trace['file']) && isset($trace['line'])) {                        $content .= $this->formatPath($trace['file'], $trace['line']);                    }                    $content .= ""</td></tr>\n"";                }                $content .= ""</tbody>\n</table>\n</div>\n"";            }        } catch (\Exception $e) {            // something nasty happened and we cannot throw an exception anymore            if ($this->debug) {                $e = FlattenException::create($e);                $title = sprintf('Exception thrown when handling an exception (%s: %s)', $e->getClass(), $this->escapeHtml($e->getMessage()));            } else {                $title = 'Whoops, looks like something went wrong.';            }        }        $symfonyGhostImageContents = $this->getSymfonyGhostAsSvg();        return <<<EOF            <div class=""exception-summary"">                <div class=""container"">                    <div class=""exception-message-wrapper"">                        <h1 class=""break-long-words exception-message"">$title</h1>                        <div class=""exception-illustration hidden-xs-down"">$symfonyGhostImageContents</div>                    </div>                </div>            </div>            <div class=""container"">                $content            </div>EOF;    }    /**     * Gets the stylesheet associated with the given exception.     *     * @return string The stylesheet as a string     */    public function getStylesheet(FlattenException $exception)    {        if (!$this->debug) {            return <<<'EOF'                body { background-color: #fff; color: #222; font: 16px/1.5 -apple-system, BlinkMacSystemFont, ""Segoe UI"", Roboto, ""Helvetica Neue"", Arial, sans-serif; margin: 0; }                .container { margin: 30px; max-width: 600px; }                h1 { color: #dc3545; font-size: 24px; }EOF;        }        return <<<'EOF'            body { background-color: #F9F9F9; color: #222; font: 14px/1.4 Helvetica, Arial, sans-serif; margin: 0; padding-bottom: 45px; }            a { cursor: pointer; text-decoration: none; }            a:hover { text-decoration: underline; }            abbr[title] { border-bottom: none; cursor: help; text-decoration: none; }            code, pre { font: 13px/1.5 Consolas, Monaco, Menlo, ""Ubuntu Mono"", ""Liberation Mono"", monospace; }            table, tr, th, td { background: #FFF; border-collapse: collapse; vertical-align: top; }            table { background: #FFF; border: 1px solid #E0E0E0; box-shadow: 0px 0px 1px rgba(128, 128, 128, .2); margin: 1em 0; width: 100%; }            table th, table td { border: solid #E0E0E0; border-width: 1px 0; padding: 8px 10px; }            table th { background-color: #E0E0E0; font-weight: bold; text-align: left; }            .hidden-xs-down { display: none; }            .block { display: block; }            .break-long-words { -ms-word-break: break-all; word-break: break-all; word-break: break-word; -webkit-hyphens: auto; -moz-hyphens: auto; hyphens: auto; }            .text-muted { color: #999; }            .container { max-width: 1024px; margin: 0 auto; padding: 0 15px; }            .container::after { content: """"; display: table; clear: both; }            .exception-summary { background: #B0413E; border-bottom: 2px solid rgba(0, 0, 0, 0.1); border-top: 1px solid rgba(0, 0, 0, .3); flex: 0 0 auto; margin-bottom: 30px; }            .exception-message-wrapper { display: flex; align-items: center; min-height: 70px; }            .exception-message { flex-grow: 1; padding: 30px 0; }            .exception-message, .exception-message a { color: #FFF; font-size: 21px; font-weight: 400; margin: 0; }            .exception-message.long { font-size: 18px; }            .exception-message a { border-bottom: 1px solid rgba(255, 255, 255, 0.5); font-size: inherit; text-decoration: none; }            .exception-message a:hover { border-bottom-color: #ffffff; }            .exception-illustration { flex-basis: 111px; flex-shrink: 0; height: 66px; margin-left: 15px; opacity: .7; }            .trace + .trace { margin-top: 30px; }            .trace-head .trace-class { color: #222; font-size: 18px; font-weight: bold; line-height: 1.3; margin: 0; position: relative; }            .trace-message { font-size: 14px; font-weight: normal; margin: .5em 0 0; }            .trace-file-path, .trace-file-path a { color: #222; margin-top: 3px; font-size: 13px; }            .trace-class { color: #B0413E; }            .trace-type { padding: 0 2px; }            .trace-method { color: #B0413E; font-weight: bold; }            .trace-arguments { color: #777; font-weight: normal; padding-left: 2px; }            @media (min-width: 575px) {                .hidden-xs-down { display: initial; }            }EOF;    }    private function decorate(string $content, string $css): string    {        return <<<EOF<!DOCTYPE html><html>    <head>        <meta charset=""{$this->charset}"" />        <meta name=""robots"" content=""noindex,nofollow"" />        <style>$css</style>    </head>    <body>        $content    </body></html>EOF;    }    private function formatClass(string $class): string    {        $parts = explode('\\', $class);        return sprintf('<abbr title=""%s"">%s</abbr>', $class, array_pop($parts));    }    private function formatPath(string $path, int $line): string    {        $file = $this->escapeHtml(preg_match('#[^/\\\\]*+$#', $path, $file) ? $file[0] : $path);        $fmt = $this->fileLinkFormat ?: ini_get('xdebug.file_link_format') ?: get_cfg_var('xdebug.file_link_format');        if (!$fmt) {            return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');        }        if (\is_string($fmt)) {            $i = strpos($f = $fmt, '&', max(strrpos($f, '%f'), strrpos($f, '%l'))) ?: \strlen($f);            $fmt = [substr($f, 0, $i)] + preg_split('/&([^>]++)>/', substr($f, $i), -1, \PREG_SPLIT_DELIM_CAPTURE);            for ($i = 1; isset($fmt[$i]); ++$i) {                if (0 === strpos($path, $k = $fmt[$i++])) {                    $path = substr_replace($path, $fmt[$i], 0, \strlen($k));                    break;                }            }            $link = strtr($fmt[0], ['%f' => $path, '%l' => $line]);        } else {            try {                $link = $fmt->format($path, $line);            } catch (\Exception $e) {                return sprintf('<span class=""block trace-file-path"">in <span title=""%s%3$s""><strong>%s</strong>%s</span></span>', $this->escapeHtml($path), $file, 0 < $line ? ' line '.$line : '');            }        }        return sprintf('<span class=""block trace-file-path"">in <a href=""%s"" title=""Go to source""><strong>%s</string>%s</a></span>', $this->escapeHtml($link), $file, 0 < $line ? ' line '.$line : '');    }    /**     * Formats an array as a string.     */    private function formatArgs(array $args): string    {        $result = [];        foreach ($args as $key => $item) {            if ('object' === $item[0]) {                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));            } elseif ('array' === $item[0]) {                $formattedValue = sprintf('<em>array</em>(%s)', \is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);            } elseif ('null' === $item[0]) {                $formattedValue = '<em>null</em>';            } elseif ('boolean' === $item[0]) {                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';            } elseif ('resource' === $item[0]) {                $formattedValue = '<em>resource</em>';            } else {                $formattedValue = str_replace(""\n"", '', $this->escapeHtml(var_export($item[1], true)));            }            $result[] = \is_int($key) ? $formattedValue : sprintf(""'%s' => %s"", $this->escapeHtml($key), $formattedValue);        }        return implode(', ', $result);    }    /**     * HTML-encodes a string.     */    private function escapeHtml(string $str): string    {        return htmlspecialchars($str, \ENT_COMPAT | \ENT_SUBSTITUTE, $this->charset);    }    private function getSymfonyGhostAsSvg(): string    {        return '<svg viewBox=""0 0 136 81"" xmlns=""http://www.w3.org/2000/svg"" fill-rule=""evenodd"" clip-rule=""evenodd"" stroke-linejoin=""round"" stroke-miterlimit=""1.4""><path d=""M92.4 20.4a23.2 23.2 0 0 1 9 1.9 23.7 23.7 0 0 1 5.2 3 24.3 24.3 0 0 1 3.4 3.4 24.8 24.8 0 0 1 5 9.4c.5 1.7.8 3.4 1 5.2v14.5h.4l.5.2a7.4 7.4 0 0 0 2.5.2l.2-.2.6-.8.8-1.3-.2-.1a5.5 5.5 0 0 1-.8-.3 5.6 5.6 0 0 1-2.3-1.8 5.7 5.7 0 0 1-.9-1.6 6.5 6.5 0 0 1-.2-2.8 7.3 7.3 0 0 1 .5-2l.3-.3.8-.9.3-.3c.2-.2.5-.3.8-.3H120.7c.2 0 .3-.1.4 0h.4l.2.1.3.2.2-.4.3-.4.1-.1 1.2-1 .3-.2.4-.1.4-.1h.3l1.5.1.4.1.8.5.1.2 1 1.1v.2H129.4l.4-.2 1.4-.5h1.1c.3 0 .7.2 1 .4.2 0 .3.2.5.3l.2.2.5.3.4.6.1.3.4 1.4.1.4v.6a7.8 7.8 0 0 1-.1.6 9.9 9.9 0 0 1-.8 2.4 7.8 7.8 0 0 1-3 3.3 6.4 6.4 0 0 1-1 .5 6.1 6.1 0 0 1-.6.2l-.7.1h-.1a23.4 23.4 0 0 1-.2 1.7 14.3 14.3 0 0 1-.6 2.1l-.8 2a9.2 9.2 0 0 1-.4.6l-.7 1a9.1 9.1 0 0 1-2.3 2.2c-.9.5-2 .6-3 .7l-1.4.1h-.5l-.4.1a15.8 15.8 0 0 1-2.8-.1v4.2a9.7 9.7 0 0 1-.7 3.5 9.6 9.6 0 0 1-1.7 2.8 9.3 9.3 0 0 1-3 2.3 9 9 0 0 1-5.4.7 9 9 0 0 1-3-1 9.4 9.4 0 0 1-2.7-2.5 10 10 0 0 1-1 1.2 9.3 9.3 0 0 1-2 1.3 9 9 0 0 1-2.4 1 9 9 0 0 1-6.5-1.1A9.4 9.4 0 0 1 85 77V77a10.9 10.9 0 0 1-.6.6 9.3 9.3 0 0 1-2.7 2 9 9 0 0 1-6 .8 9 9 0 0 1-2.4-1 9.3 9.3 0 0 1-2.3-1.7 9.6 9.6 0 0 1-1.8-2.8 9.7 9.7 0 0 1-.8-3.7v-4a18.5 18.5 0 0 1-2.9.2l-1.2-.1c-1.9-.3-3.7-1-5.1-2.1A8.2 8.2 0 0 1 58 64a10.2 10.2 0 0 1-.9-1.2 15.3 15.3 0 0 1-.7-1.3 20.8 20.8 0 0 1-1.9-6.2v-.2a6.5 6.5 0 0 1-1-.3 6.1 6.1 0 0 1-.6-.3 6.6 6.6 0 0 1-.9-.5 8.2 8.2 0 0 1-2.7-3.8 10 10 0 0 1-.3-1 10.3 10.3 0 0 1-.3-1.9V47v-.4l.1-.4.6-1.4.1-.2a2 2 0 0 1 .8-.8l.3-.2.3-.2a3.2 3.2 0 0 1 1.8-.5h.4l.3.2 1.4.6.2.2.4.3.3.4.7-.7.2-.2.4-.2.6-.2h2.1l.4.2.4.2.3.2.8 1 .2-.1h.1v-.1H63l1.1.1h.3l.8.5.3.4.7 1 .2.3.1.5a11 11 0 0 1 .2 1.5c0 .8 0 1.6-.3 2.3a6 6 0 0 1-.5 1.2 5.5 5.5 0 0 1-3.3 2.5 12.3 12.3 0 0 0 1.4 3h.1l.2.1 1 .2h1.5l.5-.2H67.8l.5-.2h.1V44v-.4a26.7 26.7 0 0 1 .3-2.3 24.7 24.7 0 0 1 5.7-12.5 24.2 24.2 0 0 1 3.5-3.3 23.7 23.7 0 0 1 4.9-3 23.2 23.2 0 0 1 5.6-1.7 23.7 23.7 0 0 1 4-.3zm-.3 2a21.2 21.2 0 0 0-8 1.7 21.6 21.6 0 0 0-4.8 2.7 22.2 22.2 0 0 0-3.2 3 22.7 22.7 0 0 0-5 9.2 23.4 23.4 0 0 0-.7 4.9v15.7l-.5.1a34.3 34.3 0 0 1-1.5.3h-.2l-.4.1h-.4l-.9.2a10 10 0 0 1-1.9 0c-.5 0-1-.2-1.5-.4a1.8 1.8 0 0 1-.3-.2 2 2 0 0 1-.3-.3 5.2 5.2 0 0 1-.1-.2 9 9 0 0 1-.6-.9 13.8 13.8 0 0 1-1-2 14.3 14.3 0 0 1-.6-2 14 14 0 0 1-.1-.8v-.2h.3a12.8 12.8 0 0 0 1.4-.2 4.4 4.4 0 0 0 .3 0 3.6 3.6 0 0 0 1.1-.7 3.4 3.4 0 0 0 1.2-1.7l.2-1.2a5.1 5.1 0 0 0 0-.8 7.2 7.2 0 0 0-.1-.8l-.7-1-1.2-.2-1 .7-.1 1.3a5 5 0 0 1 .1.4v.6a1 1 0 0 1 0 .3c-.1.3-.4.4-.7.5l-1.2.4v-.7A9.9 9.9 0 0 1 60 49l.3-.6v-.2l.1-.1v-1.6l-1-1.2h-1.5l-1 1.1v.4a5.3 5.3 0 0 0-.2.6 5.5 5.5 0 0 0 0 .5c0 .7 0 1.4.3 2 0 .4.2.8.4 1.2L57 51a9.5 9.5 0 0 1-1.1-.5h-.2a2 2 0 0 1-.4-.3c-.4-.4-.5-1-.6-1.6a5.6 5.6 0 0 1 0-.5v-.5-.5l-.6-1.5-1.4-.6-.9.3s-.2 0-.3.2a2 2 0 0 1-.1 0l-.6 1.4v.7a8.5 8.5 0 0 0 .5 2c.4 1.1 1 2.1 2 2.8a4.7 4.7 0 0 0 2.1.9h1a22.8 22.8 0 0 0 .1 1 18.1 18.1 0 0 0 .8 3.8 18.2 18.2 0 0 0 1.6 3.7l1 1.3c1 1 2.3 1.6 3.7 2a11.7 11.7 0 0 0 4.8 0h.4l.5-.2.5-.1.6-.2v6.6a8 8 0 0 0 .1 1.3 7.5 7.5 0 0 0 2.4 4.3 7.2 7.2 0 0 0 2.3 1.3 7 7 0 0 0 7-1.1 7.5 7.5 0 0 0 2-2.6A7.7 7.7 0 0 0 85 72V71a8.2 8.2 0 0 0 .2 1.3c0 .7.3 1.4.6 2a7.5 7.5 0 0 0 1.7 2.3 7.3 7.3 0 0 0 2.2 1.4 7.1 7.1 0 0 0 4.6.2 7.2 7.2 0 0 0 2.4-1.2 7.5 7.5 0 0 0 2.1-2.7 7.8 7.8 0 0 0 .7-2.4V71a9.3 9.3 0 0 0 .1.6 7.6 7.6 0 0 0 .6 2.5 7.5 7.5 0 0 0 2.4 3 7.1 7.1 0 0 0 7 .8 7.3 7.3 0 0 0 2.3-1.5 7.5 7.5 0 0 0 1.6-2.3 7.6 7.6 0 0 0 .5-2l.1-1.1v-6.7l.4.1a12.2 12.2 0 0 0 2 .5 11.1 11.1 0 0 0 2.5 0h.8l1.2-.1a9.5 9.5 0 0 0 1.4-.2l.9-.3a3.5 3.5 0 0 0 .6-.4l1.2-1.4a12.2 12.2 0 0 0 .8-1.2c0-.3.2-.5.3-.7a15.9 15.9 0 0 0 .7-2l.3-1.6v-1.3l.2-.9V54.6a15.5 15.5 0 0 0 1.8 0 4.5 4.5 0 0 0 1.4-.5 5.7 5.7 0 0 0 2.5-3.2 7.6 7.6 0 0 0 .4-1.5v-.3l-.4-1.4a5.2 5.2 0 0 1-.2-.1l-.4-.4a3.8 3.8 0 0 0-.2 0 1.4 1.4 0 0 0-.5-.2l-1.4.4-.7 1.3v.7a5.7 5.7 0 0 1-.1.8l-.7 1.4a1.9 1.9 0 0 1-.5.3h-.3a9.6 9.6 0 0 1-.8.3 8.8 8.8 0 0 1-.6 0l.2-.4.2-.5.2-.3v-.4l.1-.2V50l.1-1 .1-.6v-.6a4.8 4.8 0 0 0 0-.8v-.2l-1-1.1-1.5-.2-1.1 1-.2 1.4v.1l.2.4.2.3v.4l.1 1.1v.3l.1.5v.8a9.6 9.6 0 0 1-.8-.3l-.2-.1h-.3l-.8-.1h-.2a1.6 1.6 0 0 1-.2-.2.9.9 0 0 1-.2-.2 1 1 0 0 1-.1-.5l.2-.9v-1.2l-.9-.8h-1.2l-.8.9v.3a4.8 4.8 0 0 0-.3 2l.3.9a3.5 3.5 0 0 0 1.2 1.6l1 .5.8.2 1.4.1h.4l.2.1a12.1 12.1 0 0 1-1 2.6 13.2 13.2 0 0 1-.8 1.5 9.5 9.5 0 0 1-1 1.2l-.2.3a1.7 1.7 0 0 1-.4.3 2.4 2.4 0 0 1-.7.2h-2.5a7.8 7.8 0 0 1-.6-.2l-.7-.2h-.2a14.8 14.8 0 0 1-.6-.2 23.4 23.4 0 0 1-.4-.1l-.4-.1-.3-.1V43.9a34.6 34.6 0 0 0 0-.6 23.6 23.6 0 0 0-.4-3 22.7 22.7 0 0 0-1.5-4.7 22.6 22.6 0 0 0-4.6-6.7 21.9 21.9 0 0 0-6.9-4.7 21.2 21.2 0 0 0-8.1-1.8H92zm9.1 33.7l.3.1a1 1 0 0 1 .6.8v.4a8.4 8.4 0 0 1 0 .5 8.8 8.8 0 0 1-1.6 4.2l-1 1.3A10 10 0 0 1 95 66c-1.3.3-2.7.4-4 .3a10.4 10.4 0 0 1-2.7-.8 10 10 0 0 1-3.6-2.5 9.3 9.3 0 0 1-.8-1 9 9 0 0 1-.7-1.2 8.6 8.6 0 0 1-.8-3.4V57a1 1 0 0 1 .3-.6 1 1 0 0 1 1.3-.2 1 1 0 0 1 .4.8v.4a6.5 6.5 0 0 0 .5 2.2 7 7 0 0 0 2.1 2.8l1 .6c2.6 1.6 6 1.6 8.5 0a8 8 0 0 0 1.1-.6 7.6 7.6 0 0 0 1.2-1.2 7 7 0 0 0 1-1.7 6.5 6.5 0 0 0 .4-2.5 1 1 0 0 1 .7-1h.4zM30.7 43.7c-15.5 1-28.5-6-30.1-16.4C-1.2 15.7 11.6 4 29 1.3 46.6-1.7 62.3 5.5 64 17.1c1.6 10.4-8.7 21-23.7 25a31.2 31.2 0 0 0 0 .9v.3a19 19 0 0 0 .1 1l.1.4.1.9a4.7 4.7 0 0 0 .5 1l.7 1a9.2 9.2 0 0 0 1.2 1l1.5.8.6.8-.7.6-1.1.3a11.2 11.2 0 0 1-2.6.4 8.6 8.6 0 0 1-3-.5 8.5 8.5 0 0 1-1-.4 11.2 11.2 0 0 1-1.8-1.2 13.3 13.3 0 0 1-1-1 18 18 0 0 1-.7-.6l-.4-.4a23.4 23.4 0 0 1-1.3-1.8l-.1-.1-.3-.5V45l-.3-.6v-.7zM83.1 36c3.6 0 6.5 3.2 6.5 7.1 0 4-3 7.2-6.5 7.2S76.7 47 76.7 43 79.6 36 83 36zm18 0c3.6 0 6.5 3.2 6.5 7.1 0 4-2.9 7.2-6.4 7.2S94.7 47 94.7 43s3-7.1 6.5-7.1zm-18 6.1c2 0 3.5 1.6 3.5 3.6S85 49.2 83 49.2s-3.4-1.6-3.4-3.6S81.2 42 83 42zm17.9 0c1.9 0 3.4 1.6 3.4 3.6s-1.5 3.6-3.4 3.6c-2 0-3.5-1.6-3.5-3.6S99.1 42 101 42zM17 28c-.3 1.6-1.8 5-5.2 5.8-2.5.6-4.1-.8-4.5-2.6-.4-1.9.7-3.5 2.1-4.5A3.5 3.5 0 0 1 8 24.6c-.4-2 .8-3.7 3.2-4.2 1.9-.5 3.1.2 3.4 1.5.3 1.1-.5 2.2-1.8 2.5-.9.3-1.6 0-1.7-.6a1.4 1.4 0 0 1 0-.7s.3.2 1 0c.7-.1 1-.7.9-1.2-.2-.6-1-.8-1.8-.6-1 .2-2 1-1.7 2.6.3 1 .9 1.6 1.5 1.8l.7-.2c1-.2 1.5 0 1.6.5 0 .4-.2 1-1.2 1.2a3.3 3.3 0 0 1-1.5 0c-.9.7-1.6 1.9-1.3 3.2.3 1.3 1.3 2.2 3 1.8 2.5-.7 3.8-3.7 4.2-5-.3-.5-.6-1-.7-1.6-.1-.5.1-1 .9-1.2.4 0 .7.2.8.8a2.8 2.8 0 0 1 0 1l.7 1c.6-2 1.4-4 1.7-4 .6-.2 1.5.6 1.5.6-.8.7-1.7 2.4-2.3 4.2.8.6 1.6 1 2.1 1 .5-.1.8-.6 1-1.2-.3-2.2 1-4.3 2.3-4.6.7-.2 1.3.2 1.4.8.1.5 0 1.3-.9 1.7-.2-1-.6-1.3-1-1.3-.4.1-.7 1.4-.4 2.8.2 1 .7 1.5 1.3 1.4.8-.2 1.3-1.2 1.7-2.1-.3-2.1.9-4.2 2.2-4.5.7-.2 1.2.1 1.4 1 .4 1.4-1 2.8-2.2 3.4.3.7.7 1 1.3.9 1-.3 1.6-1.5 2-2.5l-.5-3v-.3s1.6-.3 1.8.6v.1c.2-.6.7-1.2 1.3-1.4.8-.1 1.5.6 1.7 1.6.5 2.2-.5 4.4-1.8 4.7H33a31.9 31.9 0 0 0 1 5.2c-.4.1-1.8.4-2-.4l-.5-5.6c-.5 1-1.3 2.2-2.5 2.4-1 .3-1.6-.3-2-1.1-.5 1-1.3 2.1-2.4 2.4-.8.2-1.5-.1-2-1-.3.8-.9 1.5-1.5 1.7-.7.1-1.5-.3-2.4-1-.3.8-.4 1.6-.4 2.2 0 0-.7 0-.8-.4-.1-.5 0-1.5.3-2.7a10.3 10.3 0 0 1-.7-.8zm38.2-17.8l.2.9c.5 1.9.4 4.4.8 6.4 0 .6-.4 3-1.4 3.3-.2 0-.3 0-.4-.4-.1-.7 0-1.6-.3-2.6-.2-1.1-.8-1.6-1.5-1.5-.8.2-1.3 1-1.6 2l-.1-.5c-.2-1-1.8-.6-1.8-.6a6.2 6.2 0 0 1 .4 1.3l.2 1c-.2.5-.6 1-1.2 1l-.2.1a7 7 0 0 0-.1-.8c-.3-1.1-1-2-1.6-1.8a.7.7 0 0 0-.4.3c-1.3.3-2.4 2-2.1 3.9-.2.9-.6 1.7-1 1.9-.5 0-.8-.5-1.1-1.8l-.1-1.2a4 4 0 0 0 0-1.7c0-.4-.4-.7-.8-.6-.7.2-.9 1.7-.5 3.8-.2 1-.6 2-1.3 2-.4.2-.8-.2-1-1l-.2-3c1.2-.5 2-1 1.8-1.7-.1-.5-.8-.7-.8-.7s0 .7-1 1.2l-.2-1.4c-.1-.6-.4-1-1.7-.6l.4 1 .2 1.5h-1v.8c0 .3.4.3 1 .2 0 1.3 0 2.7.2 3.6.3 1.4 1.2 2 2 1.7 1-.2 1.6-1.3 2-2.3.3 1.2 1 2 1.9 1.7.7-.2 1.2-1.1 1.6-2.2.4.8 1.1 1.1 2 1 1.2-.4 1.7-1.6 1.8-2.8h.2c.6-.2 1-.6 1.3-1 0 .8 0 1.5.2 2.1.1.5.3.7.6.6.5-.1 1-.9 1-.9a4 4 0 0 1-.3-1c-.3-1.3.3-3.6 1-3.7.2 0 .3.2.5.7v.8l.2 1.5v.7c.2.7.7 1.3 1.5 1 1.3-.2 2-2.6 2.1-3.9.3.2.6.2 1 .1-.6-2.2 0-6.1-.3-7.9-.1-.4-1-.5-1.7-.5h-.4zm-21.5 12c.4 0 .7.3 1 1.1.2 1.3-.3 2.6-.9 2.8-.2 0-.7 0-1-1.2v-.4c0-1.3.4-2 1-2.2zm-5.2 1c.3 0 .6.2.6.5.2.6-.3 1.3-1.2 2-.3-1.4.1-2.3.6-2.5zm18-.4c-.5.2-1-.4-1.2-1.2-.2-1 0-2.1.7-2.5v.5c.2.7.6 1.5 1.3 1.9 0 .7-.2 1.2-.7 1.3zm10-1.6c0 .5.4.7 1 .6.8-.2 1-1 .8-1.6 0-.5-.4-1-1-.8-.5.1-1 .9-.8 1.8zm-14.3-5.5c0-.4-.5-.7-1-.5-.8.2-1 1-.9 1.5.2.6.5 1 1 .8.5 0 1.1-1 1-1.8z"" fill=""#fff"" fill-opacity="".6""/>'.$this->addElementToGhost().'</svg>';    }    private function addElementToGhost(): string    {        if (!isset(self::GHOST_ADDONS[date('m-d')])) {            return '';        }        return '<path d=""'.self::GHOST_ADDONS[date('m-d')].'"" fill=""#fff"" fill-opacity=""0.6""></path>';    }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
320,ramsey_uuid_UuidFactory_1998," Returns an RFC 4122 variant Uuid, created from the provided bytes and version\\n\\n @param string $bytes The byte string to convert to a UUID\\n @param int $version The RFC 4122 version to apply to the UUID\\n\\n @return UuidInterface An instance of UuidInterface, created from the\\n     byte string and version\\n\\n @psalm-pure\\n","Vraća RFC 4122 Uuid varijantu, kreiranu od obezbeđenih bajtova i verzije","    private function uuidFromBytesAndVersion(string $bytes, int $version): UuidInterface    {        /** @var array $unpackedTime */        $unpackedTime = unpack('n*', substr($bytes, 6, 2));        $timeHi = (int) $unpackedTime[1];        $timeHiAndVersion = pack('n*', BinaryUtils::applyVersion($timeHi, $version));        /** @var array $unpackedClockSeq */        $unpackedClockSeq = unpack('n*', substr($bytes, 8, 2));        $clockSeqHi = (int) $unpackedClockSeq[1];        $clockSeqHiAndReserved = pack('n*', BinaryUtils::applyVariant($clockSeqHi));        $bytes = substr_replace($bytes, $timeHiAndVersion, 6, 2);        $bytes = substr_replace($bytes, $clockSeqHiAndReserved, 8, 2);        if ($this->isDefaultFeatureSet) {            return LazyUuidFromString::fromBytes($bytes);        }        return $this->uuid($bytes);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
321,sebastianbergmann_exporter_Exporter_1035, Exports a value into a single-line string.\n\n The output of this method is similar to the output of\n SebastianBergmann\\Exporter\\Exporter::export().\n\n Newlines are replaced by the visible string '\\n'.\n Contents of arrays and objects (if any) are replaced by '...'.\n,Eksportuje vrednost u jednoredni niz. Izlaz ove metode sličan je izlazu SebastianBergmann\\Exporter\\Exporter::export(). Novi redovi se zamenjuju vidljivim stringom '\\ n'. Sadržaj nizova i objekata (ako ih ima) zamenjuje se sa '...',"    public function shortenedExport(mixed $value): string    {        if (is_string($value)) {            $string = str_replace(""\n"", '', $this->export($value));            if (function_exists('mb_strlen') && function_exists('mb_substr') && mb_strlen($string) > 40) {                return mb_substr($string, 0, 30) . '...' . mb_substr($string, -7);            }            if (strlen($string) > 40) {                return substr($string, 0, 30) . '...' . substr($string, -7);            }            return $string;        }        if (is_object($value)) {            return sprintf(                '%s Object (%s)',                get_class($value),                count($this->toArray($value)) > 0 ? '...' : ''            );        }        if (is_array($value)) {            return sprintf(                'Array (%s)',                count($value) > 0 ? '...' : ''            );        }        return $this->export($value);    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
322,googleapis_google-api-php-client_Verify_671, Wrapper around Google Access Tokens which provides convenience functions\\\\\\\\n\\\\\\\\n,Omotač oko Google Access Tokena koji pruža pogodnosti,"class Verify{  const FEDERATED_SIGNON_CERT_URL = 'https://www.googleapis.com/oauth2/v3/certs';  const OAUTH2_ISSUER = 'accounts.google.com';  const OAUTH2_ISSUER_HTTPS = 'https://accounts.google.com';  /**   * @var ClientInterface The http client   */  private $http;  /**   * @var CacheItemPoolInterface cache class   */  private $cache;  /**   * Instantiates the class, but does not initiate the login flow, leaving it   * to the discretion of the caller.   */  public function __construct(      ClientInterface $http = null,      CacheItemPoolInterface $cache = null,      $jwt = null  ) {    if (null === $http) {      $http = new Client();    }    if (null === $cache) {      $cache = new MemoryCacheItemPool;    }    $this->http = $http;    $this->cache = $cache;    $this->jwt = $jwt ?: $this->getJwtService();  }  /**   * Verifies an id token and returns the authenticated apiLoginTicket.   * Throws an exception if the id token is not valid.   * The audience parameter can be used to control which id tokens are   * accepted.  By default, the id token must have been issued to this OAuth2 client.   *   * @param string $idToken the ID token in JWT format   * @param string $audience Optional. The audience to verify against JWt ""aud""   * @return array the token payload, if successful   */  public function verifyIdToken($idToken, $audience = null)  {    if (empty($idToken)) {      throw new LogicException('id_token cannot be null');    }    // set phpseclib constants if applicable    $this->setPhpsecConstants();    // Check signature    $certs = $this->getFederatedSignOnCerts();    foreach ($certs as $cert) {      try {        $payload = $this->jwt->decode(            $idToken,            $this->getPublicKey($cert),            array('RS256')        );        if (property_exists($payload, 'aud')) {          if ($audience && $payload->aud != $audience) {            return false;          }        }        // support HTTP and HTTPS issuers        // @see https://developers.google.com/identity/sign-in/web/backend-auth        $issuers = array(self::OAUTH2_ISSUER, self::OAUTH2_ISSUER_HTTPS);        if (!isset($payload->iss) || !in_array($payload->iss, $issuers)) {          return false;        }        return (array) $payload;      } catch (ExpiredException $e) {        return false;      } catch (ExpiredExceptionV3 $e) {        return false;      } catch (SignatureInvalidException $e) {        // continue      } catch (DomainException $e) {        // continue      }    }    return false;  }  private function getCache()  {    return $this->cache;  }  /**   * Retrieve and cache a certificates file.   *   * @param $url string location   * @throws \Google\Exception   * @return array certificates   */  private function retrieveCertsFromLocation($url)  {    // If we're retrieving a local file, just grab it.    if (0 !== strpos($url, 'http')) {      if (!$file = file_get_contents($url)) {        throw new GoogleException(            ""Failed to retrieve verification certificates: '"" .            $url . ""'.""        );      }      return json_decode($file, true);    }    $response = $this->http->get($url);    if ($response->getStatusCode() == 200) {      return json_decode((string) $response->getBody(), true);    }    throw new GoogleException(        sprintf(            'Failed to retrieve verification certificates: ""%s"".',            $response->getBody()->getContents()        ),        $response->getStatusCode()    );  }  // Gets federated sign-on certificates to use for verifying identity tokens.  // Returns certs as array structure, where keys are key ids, and values  // are PEM encoded certificates.  private function getFederatedSignOnCerts()  {    $certs = null;    if ($cache = $this->getCache()) {      $cacheItem = $cache->getItem('federated_signon_certs_v3');      $certs = $cacheItem->get();    }    if (!$certs) {      $certs = $this->retrieveCertsFromLocation(          self::FEDERATED_SIGNON_CERT_URL      );      if ($cache) {        $cacheItem->expiresAt(new DateTime('+1 hour'));        $cacheItem->set($certs);        $cache->save($cacheItem);      }    }    if (!isset($certs['keys'])) {      throw new InvalidArgumentException(          'federated sign-on certs expects ""keys"" to be set'      );    }    return $certs['keys'];  }  private function getJwtService()  {    $jwtClass = 'JWT';    if (class_exists('\Firebase\JWT\JWT')) {      $jwtClass = 'Firebase\JWT\JWT';    }    if (property_exists($jwtClass, 'leeway') && $jwtClass::$leeway < 1) {      // Ensures JWT leeway is at least 1      // @see https://github.com/google/google-api-php-client/issues/827      $jwtClass::$leeway = 1;    }    return new $jwtClass;  }  private function getPublicKey($cert)  {    $bigIntClass = $this->getBigIntClass();    $modulus = new $bigIntClass($this->jwt->urlsafeB64Decode($cert['n']), 256);    $exponent = new $bigIntClass($this->jwt->urlsafeB64Decode($cert['e']), 256);    $component = array('n' => $modulus, 'e' => $exponent);    if (class_exists('phpseclib3\Crypt\RSA\PublicKey')) {      /** @var PublicKey $loader */      $loader = PublicKeyLoader::load($component);      return $loader->toString('PKCS8');    }    $rsaClass = $this->getRsaClass();    $rsa = new $rsaClass();    $rsa->loadKey($component);    return $rsa->getPublicKey();  }  private function getRsaClass()  {    if (class_exists('phpseclib3\Crypt\RSA')) {      return 'phpseclib3\Crypt\RSA';    }    if (class_exists('phpseclib\Crypt\RSA')) {      return 'phpseclib\Crypt\RSA';    }    return 'Crypt_RSA';  }  private function getBigIntClass()  {    if (class_exists('phpseclib3\Math\BigInteger')) {      return 'phpseclib3\Math\BigInteger';    }    if (class_exists('phpseclib\Math\BigInteger')) {      return 'phpseclib\Math\BigInteger';    }    return 'Math_BigInteger';  }  private function getOpenSslConstant()  {    if (class_exists('phpseclib3\Crypt\AES')) {      return 'phpseclib3\Crypt\AES::ENGINE_OPENSSL';    }    if (class_exists('phpseclib\Crypt\RSA')) {      return 'phpseclib\Crypt\RSA::MODE_OPENSSL';    }    if (class_exists('Crypt_RSA')) {      return 'CRYPT_RSA_MODE_OPENSSL';    }    throw new Exception('Cannot find RSA class');  }  /**   * phpseclib calls ""phpinfo"" by default, which requires special   * whitelisting in the AppEngine VM environment. This function   * sets constants to bypass the need for phpseclib to check phpinfo   *   * @see phpseclib/Math/BigInteger   * @see https://github.com/GoogleCloudPlatform/getting-started-php/issues/85   */  private function setPhpsecConstants()  {    if (filter_var(getenv('GAE_VM'), FILTER_VALIDATE_BOOLEAN)) {      if (!defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {        define('MATH_BIGINTEGER_OPENSSL_ENABLED', true);      }      if (!defined('CRYPT_RSA_MODE')) {        define('CRYPT_RSA_MODE', constant($this->getOpenSslConstant()));      }    }  }}",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
323,PHPOffice_PHPExcel_PHPExcel_96, Create a new PHPExcel with one Worksheet\\\\n,Napravite novi PHPExcel sa jednim radnim listom,    public function __construct()    {        $this->uniqueID = uniqid();        $this->calculationEngine = new PHPExcel_Calculation($this);        // Initialise worksheet collection and add one worksheet        $this->workSheetCollection = array();        $this->workSheetCollection[] = new PHPExcel_Worksheet($this);        $this->activeSheetIndex = 0;        // Create document properties        $this->properties = new PHPExcel_DocumentProperties();        // Create document security        $this->security = new PHPExcel_DocumentSecurity();        // Set named ranges        $this->namedRanges = array();        // Create the cellXf supervisor        $this->cellXfSupervisor = new PHPExcel_Style(true);        $this->cellXfSupervisor->bindParent($this);        // Create the default style        $this->addCellXf(new PHPExcel_Style);        $this->addCellStyleXf(new PHPExcel_Style);    },0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
324,markrogoyski_math-php_LogNormal_3141, Log normal distribution - probability density function\\n\\n https://en.wikipedia.org/wiki/Log-normal_distribution\\n\\n                 (ln x - Î¼)Â²\\n         1     - ----------\\n pdf = ----- â„¯       2ÏƒÂ²\\n       xÏƒâˆš2Ï€\\n\\n @param  float $x > 0\\n\\n @return float\\n,Log Normalna raspodela - funkcija gustine verovatnoće,"    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $Î¼ = $this->Î¼;        $Ïƒ = $this->Ïƒ;        $Ï€ = \M_PI;        $xÏƒâˆš2Ï€      = $x * $Ïƒ * \sqrt(2 * $Ï€);        $âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² = \pow(\log($x) - $Î¼, 2);        $ÏƒÂ²         = $Ïƒ ** 2;        return (1 / $xÏƒâˆš2Ï€) * \exp(-($âŸ®lnÂ xÂ âˆ’Â Î¼âŸ¯Â² / (2 * $ÏƒÂ²)));    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
325,phalcon_cphalcon_Optimized_1235," Copy phalcon.c and optimize it by replacing specific strings with the precalculated hash values.\n Precalculation is, actually, the optimization being performed.\n",Kopira phalcon.c i optimizirajte ga tako što će zamijeniti određene stringove sa preračunanim heš vrijednostima. Preračunavanje je zapravo optimizacija koja se izvodi,"    protected function copyAndOptimizePhalconC()    {        $platforms = array_keys($this->settings);        // Init generated content        $generated = array();        foreach ($platforms as $platform) {            $generated[$platform] = '';        }        // Generate line by line        $filePath = $this->sourceBuildDir . '/phalcon.zep.c';        foreach (file($filePath) as $line) {            $this->filterLine($line, $generated);        }        // Output result        foreach ($platforms as $platform) {            file_put_contents($this->settings[$platform]['dir'] . '/phalcon.zep.c', $generated[$platform]);        }    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
326,walkor_Workerman_Worker_8666, Set unix user and group for current process.\n\n @return void\n,Podesite unix korisnika i grupu za trenutni proces,"    protected static function monitorWorkersForWindows()    {        Timer::add(1, ""\\Workerman\\Worker::checkWorkerStatusForWindows"");        static::$globalEvent->loop();    }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
328,symfony_debug_DebugClassLoader_1727," Autoloader checking if the class is really defined in the file found.\n\n The ClassLoader will wrap all registered autoloaders\n and will throw an exception if a file is found but does\n not declare the class.\n\n @author Fabien Potencier <fabien@symfony.com>\n @author Christophe Coevoet <stof@notk.org>\n @author Nicolas Grekas <p@tchwork.com>\n @author Guilhem Niot <guilhem.niot@gmail.com>\n\n @deprecated since Symfony 4.4, use Symfony\\Component\\ErrorHandler\\DebugClassLoader instead.\n","Automatsko učitavanje proverava da li je klasa zaista definisana u pronađenoj datoteci. ClassLoader će umotati sve registrovane automatske učitavače i izbaciće izuzetak ako je datoteka pronađena, ali ne deklariše klasu","class DebugClassLoader{    private $classLoader;    private $isFinder;    private $loaded = [];    private static $caseCheck;    private static $checkedClasses = [];    private static $final = [];    private static $finalMethods = [];    private static $deprecated = [];    private static $internal = [];    private static $internalMethods = [];    private static $annotatedParameters = [];    private static $darwinCache = ['/' => ['/', []]];    private static $method = [];    public function __construct(callable $classLoader)    {        $this->classLoader = $classLoader;        $this->isFinder = \is_array($classLoader) && method_exists($classLoader[0], 'findFile');        if (!isset(self::$caseCheck)) {            $file = file_exists(__FILE__) ? __FILE__ : rtrim(realpath('.'), \DIRECTORY_SEPARATOR);            $i = strrpos($file, \DIRECTORY_SEPARATOR);            $dir = substr($file, 0, 1 + $i);            $file = substr($file, 1 + $i);            $test = strtoupper($file) === $file ? strtolower($file) : strtoupper($file);            $test = realpath($dir.$test);            if (false === $test || false === $i) {                // filesystem is case sensitive                self::$caseCheck = 0;            } elseif (substr($test, -\strlen($file)) === $file) {                // filesystem is case insensitive and realpath() normalizes the case of characters                self::$caseCheck = 1;            } elseif (false !== stripos(\PHP_OS, 'darwin')) {                // on MacOSX, HFS+ is case insensitive but realpath() doesn't normalize the case of characters                self::$caseCheck = 2;            } else {                // filesystem case checks failed, fallback to disabling them                self::$caseCheck = 0;            }        }    }    /**     * Gets the wrapped class loader.     *     * @return callable The wrapped class loader     */    public function getClassLoader()    {        return $this->classLoader;    }    /**     * Wraps all autoloaders.     */    public static function enable()    {        // Ensures we don't hit https://bugs.php.net/42098        class_exists(\Symfony\Component\Debug\ErrorHandler::class);        class_exists(\Psr\Log\LogLevel::class);        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (!\is_array($function) || !$function[0] instanceof self) {                $function = [new static($function), 'loadClass'];            }            spl_autoload_register($function);        }    }    /**     * Disables the wrapping.     */    public static function disable()    {        if (!\is_array($functions = spl_autoload_functions())) {            return;        }        foreach ($functions as $function) {            spl_autoload_unregister($function);        }        foreach ($functions as $function) {            if (\is_array($function) && $function[0] instanceof self) {                $function = $function[0]->getClassLoader();            }            spl_autoload_register($function);        }    }    /**     * @return string|null     */    public function findFile($class)    {        return $this->isFinder ? $this->classLoader[0]->findFile($class) ?: null : null;    }    /**     * Loads the given class or interface.     *     * @param string $class The name of the class     *     * @throws \RuntimeException     */    public function loadClass($class)    {        $e = error_reporting(error_reporting() | \E_PARSE | \E_ERROR | \E_CORE_ERROR | \E_COMPILE_ERROR);        try {            if ($this->isFinder && !isset($this->loaded[$class])) {                $this->loaded[$class] = true;                if (!$file = $this->classLoader[0]->findFile($class) ?: false) {                    // no-op                } elseif (\function_exists('opcache_is_script_cached') && @opcache_is_script_cached($file)) {                    include $file;                    return;                } elseif (false === include $file) {                    return;                }            } else {                ($this->classLoader)($class);                $file = false;            }        } finally {            error_reporting($e);        }        $this->checkClass($class, $file);    }    private function checkClass(string $class, string $file = null)    {        $exists = null === $file || class_exists($class, false) || interface_exists($class, false) || trait_exists($class, false);        if (null !== $file && $class && '\\' === $class[0]) {            $class = substr($class, 1);        }        if ($exists) {            if (isset(self::$checkedClasses[$class])) {                return;            }            self::$checkedClasses[$class] = true;            $refl = new \ReflectionClass($class);            if (null === $file && $refl->isInternal()) {                return;            }            $name = $refl->getName();            if ($name !== $class && 0 === strcasecmp($name, $class)) {                throw new \RuntimeException(sprintf('Case mismatch between loaded and declared class names: ""%s"" vs ""%s"".', $class, $name));            }            $deprecations = $this->checkAnnotations($refl, $name);            foreach ($deprecations as $message) {                @trigger_error($message, \E_USER_DEPRECATED);            }        }        if (!$file) {            return;        }        if (!$exists) {            if (false !== strpos($class, '/')) {                throw new \RuntimeException(sprintf('Trying to autoload a class with an invalid name ""%s"". Be careful that the namespace separator is ""\"" in PHP, not ""/"".', $class));            }            throw new \RuntimeException(sprintf('The autoloader expected class ""%s"" to be defined in file ""%s"". The file was found but the class was not in it, the class name or namespace probably has a typo.', $class, $file));        }        if (self::$caseCheck && $message = $this->checkCase($refl, $file, $class)) {            throw new \RuntimeException(sprintf('Case mismatch between class and real file names: ""%s"" vs ""%s"" in ""%s"".', $message[0], $message[1], $message[2]));        }    }    public function checkAnnotations(\ReflectionClass $refl, $class)    {        $deprecations = [];        // Don't trigger deprecations for classes in the same vendor        if (2 > $len = 1 + (strpos($class, '\\') ?: strpos($class, '_'))) {            $len = 0;            $ns = '';        } else {            $ns = str_replace('_', '\\', substr($class, 0, $len));        }        // Detect annotations on the class        if (false !== $doc = $refl->getDocComment()) {            foreach (['final', 'deprecated', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    self::${$annotation}[$class] = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                }            }            if ($refl->isInterface() && false !== strpos($doc, 'method') && preg_match_all('#\n \* @method\s+(static\s+)?+(?:[\w\|&\[\]\\\]+\s+)?(\w+(?:\s*\([^\)]*\))?)+(.+?([[:punct:]]\s*)?)?(?=\r?\n \*(?: @|/$|\r?\n))#', $doc, $notice, \PREG_SET_ORDER)) {                foreach ($notice as $method) {                    $static = '' !== $method[1];                    $name = $method[2];                    $description = $method[3] ?? null;                    if (false === strpos($name, '(')) {                        $name .= '()';                    }                    if (null !== $description) {                        $description = trim($description);                        if (!isset($method[4])) {                            $description .= '.';                        }                    }                    self::$method[$class][] = [$class, $name, $static, $description];                }            }        }        $parent = get_parent_class($class);        $parentAndOwnInterfaces = $this->getOwnInterfaces($class, $parent ?: null);        if ($parent) {            $parentAndOwnInterfaces[$parent] = $parent;            if (!isset(self::$checkedClasses[$parent])) {                $this->checkClass($parent);            }            if (isset(self::$final[$parent])) {                $deprecations[] = sprintf('The ""%s"" class is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $parent, self::$final[$parent], $class);            }        }        // Detect if the parent is annotated        foreach ($parentAndOwnInterfaces + class_uses($class, false) as $use) {            if (!isset(self::$checkedClasses[$use])) {                $this->checkClass($use);            }            if (isset(self::$deprecated[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len) && !isset(self::$deprecated[$class])) {                $type = class_exists($class, false) ? 'class' : (interface_exists($class, false) ? 'interface' : 'trait');                $verb = class_exists($use, false) || interface_exists($class, false) ? 'extends' : (interface_exists($use, false) ? 'implements' : 'uses');                $deprecations[] = sprintf('The ""%s"" %s %s ""%s"" that is deprecated%s.', $class, $type, $verb, $use, self::$deprecated[$use]);            }            if (isset(self::$internal[$use]) && strncmp($ns, str_replace('_', '\\', $use), $len)) {                $deprecations[] = sprintf('The ""%s"" %s is considered internal%s. It may change without further notice. You should not use it from ""%s"".', $use, class_exists($use, false) ? 'class' : (interface_exists($use, false) ? 'interface' : 'trait'), self::$internal[$use], $class);            }            if (isset(self::$method[$use])) {                if ($refl->isAbstract()) {                    if (isset(self::$method[$class])) {                        self::$method[$class] = array_merge(self::$method[$class], self::$method[$use]);                    } else {                        self::$method[$class] = self::$method[$use];                    }                } elseif (!$refl->isInterface()) {                    $hasCall = $refl->hasMethod('__call');                    $hasStaticCall = $refl->hasMethod('__callStatic');                    foreach (self::$method[$use] as $method) {                        [$interface, $name, $static, $description] = $method;                        if ($static ? $hasStaticCall : $hasCall) {                            continue;                        }                        $realName = substr($name, 0, strpos($name, '('));                        if (!$refl->hasMethod($realName) || !($methodRefl = $refl->getMethod($realName))->isPublic() || ($static && !$methodRefl->isStatic()) || (!$static && $methodRefl->isStatic())) {                            $deprecations[] = sprintf('Class ""%s"" should implement method ""%s::%s""%s', $class, ($static ? 'static ' : '').$interface, $name, null == $description ? '.' : ': '.$description);                        }                    }                }            }        }        if (trait_exists($class)) {            return $deprecations;        }        // Inherit @final, @internal and @param annotations for methods        self::$finalMethods[$class] = [];        self::$internalMethods[$class] = [];        self::$annotatedParameters[$class] = [];        foreach ($parentAndOwnInterfaces as $use) {            foreach (['finalMethods', 'internalMethods', 'annotatedParameters'] as $property) {                if (isset(self::${$property}[$use])) {                    self::${$property}[$class] = self::${$property}[$class] ? self::${$property}[$use] + self::${$property}[$class] : self::${$property}[$use];                }            }        }        foreach ($refl->getMethods(\ReflectionMethod::IS_PUBLIC | \ReflectionMethod::IS_PROTECTED) as $method) {            if ($method->class !== $class) {                continue;            }            if ($parent && isset(self::$finalMethods[$parent][$method->name])) {                [$declaringClass, $message] = self::$finalMethods[$parent][$method->name];                $deprecations[] = sprintf('The ""%s::%s()"" method is considered final%s. It may change without further notice as of its next major version. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);            }            if (isset(self::$internalMethods[$class][$method->name])) {                [$declaringClass, $message] = self::$internalMethods[$class][$method->name];                if (strncmp($ns, $declaringClass, $len)) {                    $deprecations[] = sprintf('The ""%s::%s()"" method is considered internal%s. It may change without further notice. You should not extend it from ""%s"".', $declaringClass, $method->name, $message, $class);                }            }            // To read method annotations            $doc = $method->getDocComment();            if (isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }                foreach (self::$annotatedParameters[$class][$method->name] as $parameterName => $deprecation) {                    if (!isset($definedParameters[$parameterName]) && !($doc && preg_match(""/\\n\\s+\\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\\\${$parameterName}\\b/"", $doc))) {                        $deprecations[] = sprintf($deprecation, $class);                    }                }            }            if (!$doc) {                continue;            }            $finalOrInternal = false;            foreach (['final', 'internal'] as $annotation) {                if (false !== strpos($doc, $annotation) && preg_match('#\n\s+\* @'.$annotation.'(?:( .+?)\.?)?\r?\n\s+\*(?: @|/$|\r?\n)#s', $doc, $notice)) {                    $message = isset($notice[1]) ? preg_replace('#\.?\r?\n( \*)? *(?= |\r?\n|$)#', '', $notice[1]) : '';                    self::${$annotation.'Methods'}[$class][$method->name] = [$class, $message];                    $finalOrInternal = true;                }            }            if ($finalOrInternal || $method->isConstructor() || false === strpos($doc, '@param') || StatelessInvocation::class === $class) {                continue;            }            if (!preg_match_all('#\n\s+\* @param +((?(?!callable *\().*?|callable *\(.*\).*?))(?<= )\$([a-zA-Z0-9_\x7f-\xff]++)#', $doc, $matches, \PREG_SET_ORDER)) {                continue;            }            if (!isset(self::$annotatedParameters[$class][$method->name])) {                $definedParameters = [];                foreach ($method->getParameters() as $parameter) {                    $definedParameters[$parameter->name] = true;                }            }            foreach ($matches as [, $parameterType, $parameterName]) {                if (!isset($definedParameters[$parameterName])) {                    $parameterType = trim($parameterType);                    self::$annotatedParameters[$class][$method->name][$parameterName] = sprintf('The ""%%s::%s()"" method will require a new ""%s$%s"" argument in the next major version of its %s ""%s"", not defining it is deprecated.', $method->name, $parameterType ? $parameterType.' ' : '', $parameterName, interface_exists($class) ? 'interface' : 'parent class', $method->class);                }            }        }",0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
329,phalcon_cphalcon_Safe_1568, Resolves headers in the php_phalcon.h file\\n,Rešava zaglavlja u datoteci php_phalcon.h,"    protected function processKernelGlobals()    {        $lines = [];        foreach (file($this->outputDir . '/php_phalcon.h') as $line) {            if (preg_match('@^#include ""(kernel/.+)""@', $line, $matches)) {                $content = file_get_contents($this->sourceDir . DIRECTORY_SEPARATOR . $matches[1]);                $lines[] = $content . PHP_EOL;            } else {                $lines[] = $line;            }        }        file_put_contents($this->outputDir . '/php_phalcon.h', join('', $lines));    }",0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
