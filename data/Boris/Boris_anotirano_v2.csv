annotation_matrix_Boris
pair_id,comment,Komentar,code,"upit
","pretvaranje int u string
","red sa prioritetom
","pretvaranje string u datum
","sortiranje string liste
","čuvanje liste u datoteku
","postgresql konekcija
","konfuziona matrica
","postavljanje radnog direktorijuma
","grupisanje po izbrojanim podacima
","binomna raspodela
","aes šifrovanje
","linearna regresija
","vreme tolerisanja za prijem na soketu
","upisivanje u csv datoteku
","pretvaranje decimalnog u heksadecimalni broj
","izvoz podataka u excel
","dijagram rasejanja
","pretvaranje json u csv
","lepo ispiši json
","zamena delova datoteke
","klasterizacija metodom k-srednjih vrednosti
","povezivanje na sql server
","html šifrovan string
","određivanje proteklog vremena korišćenjem časovnika
","parsiranje binarne datoteke u prilagođenu klasu
","dohvatanje trenutne ip adrese
","pretvaranje int u bool
","isčitavanje tekstualne datoteke liniju po liniju
","dohvatanje putanje izvršavanja
","odprema json datoteke pomoću HttpClient POST zahteva
","dohvatanje unutrašnjeg svojstva html taga
","pretvaranje string u broj
","formatiranje datuma
","nepromenjivi (readonly) niz
","filtriranje niza
","mapa u json
","parsiranje json datoteke
","dohvati trenutnu vrednost posmatrača
","dohvati naziv za vrednost enumerisanog tipa podatka
","šifriraj url
","kreiraj kolačić
","kako isprazniti niz
","kako dohvatiti današnji datum
","kako štiklirati checkbox
","inicijalizacija niza
","kako obrnuti string
","pročitaj svojstva datoteke
","prekopiraj u klibord
","pretvaranje html stranice u pdf
","konverzija json u xml datoteku
","kako nasumično izabrati broj
","normalna raspodela
","Nelder-Mead optimizacija
","hashset za određivanje broja različitih elemenata
","kako dohvatiti naziv tabele iz baze
","deserializacija json-a
","pronađi int unutar stringa
","dohvatanje jedinstvenog identifikatora trenutnog procesa
","regex ne razlikuje velika i mala slova
","prilagođeni http odgovor greške
","kako odrediti da li je string valida reč
","zamena http entiteta
","sakrij atribute datoteke
","sortiraj više nizova na osnovu redosleda drugih sortiranih nizova
","levenshteinova slicnost stringova
","kako dohvatiti html kod sa veb sajta
","baferisano čitanje teksta čitačem fajlova
","aes šifrovanje u ctr načinu rada
","matrica množenja
","štampanje rezimea modela
","jedinstveni elementi
","izvlačenje podataka iz sadržaja html koda
",toplotna mapa iz 3d koordinata,"dohvatanje svih roditelja xml čvora
","kako rekurzivno raspakovati zip datoteku
","podvuci tekst u label vidžetu
","raspakivanje velikih datoteka
","kopiranje putanje fajla
","dohvati opis http statusnog koda
","nasumično izvuci x stavki iz liste
","konvertuj string datum u yyyymmdd format
","pretvoriti utc vreme u epohu
","sve permutacije liste
","izvuci geografsku širinu i dužinu iz datog unosa
","kako proveriti da je checkbox štikliran
",pretvoriti uint8 niz u sliku,"memoizacija na disk - persistentna memoizacija
","parsiranje argumenata komandne linije
","kako pročitati sadržaj iz .gz zapakovanog fajla
","slanje binarnih podataka preko seriske veze
","otpakovanje podataka iz tekstualne datoteke
","pozicije podstingova u stringu
","čitanje elemenata iz html-a - <td>
","oduzimanje medijana iz svake kolone
","uklanjanja zaglavlja prilikom spajanja nekoliko datoteka
","parsiranje query stringa u url-u
","rangiranje fazi članova na osnovu stepena podudaranja
","izlaz u html datoteku
",kako efikasno pročitati .csv datoteku
BookStackApp_BookStack_ActivityService_740, Get a new activity instance for the current user.\n,Daj novu instancu aktivnosti za trenutnog korisnika.,"    protected function newActivityForUser(string $type): Activity    {        return $this->activity->newInstance()->forceFill([            'type'     => strtolower($type),            'user_id' => user()->id,        ]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_CommentRepo_753, Update an existing comment.\n,Osveži postojeći komentar.,"    public function update(Comment $comment, string $text): Comment    {        $comment->updated_by = user()->id;        $comment->text = $text;        $comment->html = $this->commentToHtml($text);        $comment->save();        return $comment;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_CommentRepo_754, Delete a comment from the system.\n,Obriši komentar iz sistema.,    public function delete(Comment $comment)    {        $comment->delete();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_Comment_747, Check if a comment has been updated since creation.\n,Provera da li je komentar menjan od kada je napravljen,    public function isUpdated(): bool    {        return $this->updated_at->timestamp > $this->created_at->timestamp;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
BookStackApp_BookStack_helpers_731, Check if current user is a signed in user.\n,Provera da li je korisnik prijavljen,function signedInUser(): bool{    return auth()->user() && !auth()->user()->isDefault();},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_AddMessageDateCommand_7039," This concrete command tweaks receiver to add current date to messages\n invoker just knows that it can call ""execute""\n",Ova konkretna komanda menja prijemnika tako da dodaje trenutni datum u poruke kako bi prizivač znao da može da pozove “execute”,"class AddMessageDateCommand implements UndoableCommand{    /**     * Each concrete command is built with different receivers.     * There can be one, many or completely no receivers, but there can be other commands in the parameters.     */    public function __construct(private Receiver $output)    {    }    /**     * Execute and make receiver to enable displaying messages date.     */    public function execute()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->enableDate();    }    /**     * Undo the command and make receiver to disable displaying messages date.     */    public function undo()    {        // sometimes, there is no receiver and this is the command which        // does all the work        $this->output->disableDate();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_HelloCommand_6673," execute and output ""Hello World"".\n",Izvrši i ispiši “Zdravo svete”,"    public function execute()    {        // sometimes, there is no receiver and this is the command which does all the work        $this->output->write('Hello World');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_PostId_6684, This is a perfect example of a value object that is identifiable by it's value alone and\n is guaranteed to be valid each time an instance is created. Another important property of value objects\n is immutability.\n\n Notice also the use of a named constructor (fromInt) which adds a little context when creating an instance.\n,Ovo je savršeni primer vrednosti objekta koja je prepoznatljiva već po svojoj vrednosti i garantovano je važeća svaki put kada se napravi instanca. Još jedno bitno svojstvo vrednostnih objekata je nepromenljivost. Primetite takođe i upotrebu nazvanog konstruktora (fromInt) koji dodaje još malo konkteksta prilikom kreiranja instance.,class PostId{    public static function fromInt(int $id): PostId    {        self::ensureIsValid($id);        return new self($id);    }    private function __construct(private int $id)    {    }    public function toInt(): int    {        return $this->id;    }    private static function ensureIsValid(int $id)    {        if ($id <= 0) {            throw new InvalidArgumentException('Invalid PostId given');        }    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DesignPatternsPHP_DesignPatternsPHP_Receiver_6406, Disable receiver to display message date\n,Onemogući prijemniku da prikazuje datum.,    public function disableDate()    {        $this->enableDate = false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_403, Initiates color object from integer\n\n @param  int $value\n @return \\Intervention\\Image\\AbstractColor\n,Inicijalizuje objekat boje od celog broja.,    abstract public function initFromInteger($value);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_407," Initiates color object from given R, G and B values\n\n @param  int $r\n @param  int $g\n @param  int $b\n @return \\Intervention\\Image\\AbstractColor\n","Inicijalizuje objekat boje od zadate R, G i B vrednosti.","    abstract public function initFromRgb($r, $g, $b);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_408," Initiates color object from given R, G, B and A values\\n\\n @param  int $r\\n @param  int $g\\n @param  int $b\\n @param  float   $a\\n @return \\\\Intervention\\\\Image\\\\AbstractColor\\n","Inicijalizu objekat boje od zadatih R, G, B i A Vrednosti.","    abstract public function initFromRgba($r, $g, $b, $a);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_409, Calculates integer value of current color instance\\\\n\\\\n @return int\\\\n,Računa celobrojnu vrednost trenutne instance boje.,    abstract public function getInt();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_410, Calculates hexadecimal value of current color instance\n\n @param  string $prefix\n @return string\n,Računa heksadecimalnu vrednost trenutne instance boje.,    abstract public function getHex($prefix);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractColor_411, Calculates RGB(A) in array format of current color instance\n\n @return array\n,Računa RGB(A) u obliku niza za trenutnu instancu boje.,    abstract public function getArray();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_417, Initiates new image from binary data\n\n @param  string $data\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku od binarnih podataka,    abstract public function initFromBinary($data);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDecoder_418, Initiates new image from GD resource\n\n @param  Resource $resource\n @return \\Intervention\\Image\\Image\n,Inicijalizuj novu sliku od GD resursa,    abstract public function initFromGdResource($resource);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_AbstractDriver_437, Creates new image instance\\\\n\\\\n @param  int     $width\\\\n @param  int     $height\\\\n @param  string  $background\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Napravi novu instancu slike,"    abstract public function newImage($width, $height, $background);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_BlurCommand_594, Applies blur effect on image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Primeni efekat zamućivanja na sliku.,"public function execute($image)    {        $amount = $this->argument(0)->between(0, 100)->value(1);        for ($i=0; $i < intval($amount); $i++) {            imagefilter($image->getCore(), IMG_FILTER_GAUSSIAN_BLUR);        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_BrightnessCommand_595, Changes image brightness\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return boolean\\\\n,Promeni osvetljenost slike,"public function execute($image)    {        $level = $this->argument(0)->between(-100, 100)->required()->value();        return imagefilter($image->getCore(), IMG_FILTER_BRIGHTNESS, ($level * 2.55));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_569, Calculates integer value of current color instance\\n\\n @return int\\n,Izračunaj celobrojnu vrednost trenutne instance boje,public function getInt()    {        return ($this->a << 24) + ($this->r << 16) + ($this->g << 8) + $this->b;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_Color_634, Calculates RGB(A) in array format of current color instance\\n\\n @return array\\n,Izračunaj RGB(A) u obliku niza za trenutnu instancu boje,"    public function getArray()    {        return [            $this->getRedValue(),            $this->getGreenValue(),            $this->getBlueValue(),            $this->getAlphaValue()        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_FilterInterface_563, Applies filter to given image\\\\n\\\\n @param  \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image $image\\\\n @return \\\\\\\\Intervention\\\\\\\\Image\\\\\\\\Image\\\\n,Primeni filter na datu sliku,    public function applyFilter(Image $image);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Intervention_image_GammaCommand_603, Applies gamma correction to a given image\\n\\n @param  \\\\Intervention\\\\Image\\\\Image $image\\n @return boolean\\n,Primeni gama korekciju na zadatu sliku,"public function execute($image)    {        $gamma = $this->argument(0)->type('numeric')->required()->value();        return imagegammacorrect($image->getCore(), 1, $gamma);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_156,Ensure that paired matrix operands are both matrices of the same size\\\\\\\\n\\\\\\\\n @param    mixed        &$matrix1    First matrix operand\\\\\\\\n @param    mixed        &$matrix2    Second matrix operand\\\\\\\\n @param    integer        $matrix1Rows    Row size of first matrix operand\\\\\\\\n @param    integer        $matrix1Columns    Column size of first matrix operand\\\\\\\\n @param    integer        $matrix2Rows    Row size of second matrix operand\\\\\\\\n @param    integer        $matrix2Columns    Column size of second matrix operand\\\\\\\\n,Pobrini se da su oba člana operacije matrica matrice iste veličine,"private static function resizeMatricesExtend(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)    {        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {            if ($matrix2Columns < $matrix1Columns) {                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $x = $matrix2[$i][$matrix2Columns-1];                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {                        $matrix2[$i][$j] = $x;                    }                }            }            if ($matrix2Rows < $matrix1Rows) {                $x = $matrix2[$matrix2Rows-1];                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $matrix2[$i] = $x;                }            }        }        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {            if ($matrix1Columns < $matrix2Columns) {                for ($i = 0; $i < $matrix1Rows; ++$i) {                    $x = $matrix1[$i][$matrix1Columns-1];                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {                        $matrix1[$i][$j] = $x;                    }                }            }            if ($matrix1Rows < $matrix2Rows) {                $x = $matrix1[$matrix1Rows-1];                for ($i = 0; $i < $matrix2Rows; ++$i) {                    $matrix1[$i] = $x;                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Calculation_159,Compare two strings in the same way as strcmp() except that lowercase come before uppercase letters\\\\\\\\n @param    string    $str1    First string value for the comparison\\\\\\\\n @param    string    $str2    Second string value for the comparison\\\\\\\\n @return   integer\\\\\\\\n,"Uporedi dva stringa na isti način kao strcmp(), ali da sva slova budu velika.","private function strcmpLowercaseFirst($str1, $str2)    {        $inversedStr1 = PHPExcel_Shared_String::StrCaseReverse($str1);        $inversedStr2 = PHPExcel_Shared_String::StrCaseReverse($str2);        return strcmp($inversedStr1, $inversedStr2);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_176,    Does this cell contain a Hyperlink?\\n\\n    @return boolean\\n    @throws    PHPExcel_Exception\\n,Da li ova ćelija sadrži vezu?,    public function hasHyperlink()    {        if (!isset($this->parent)) {            throw new PHPExcel_Exception('Cannot check for hyperlink when cell is not bound to a worksheet');        }        return $this->getWorksheet()->hyperlinkExists($this->getCoordinate());    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_185,    Build range from coordinate strings\\n\\n    @param    array    $pRange    Array containg one or more arrays containing one or two coordinate strings\\n    @return    string    String representation of $pRange\\n    @throws    PHPExcel_Exception\\n,Napravi raspon od koordinata stringova.,"public static function buildRange($pRange)    {        // Verify range        if (!is_array($pRange) || empty($pRange) || !is_array($pRange[0])) {            throw new PHPExcel_Exception('Range does not contain any information');        }        // Build range        $imploded = array();        $counter = count($pRange);        for ($i = 0; $i < $counter; ++$i) {            $pRange[$i] = implode(':', $pRange[$i]);        }        $imploded = implode(',', $pRange);        return $imploded;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_186,"Compare 2 cells\\\\n\\\\n @param    PHPExcel_Cell    $a    Cell a\\\\n @param    PHPExcel_Cell    $b    Cell b\\\\n @return    int        Result of comparison (always -1 or 1, never zero!)\\\\n",Uporedi dve ćelije,"public static function compareCells(PHPExcel_Cell $a, PHPExcel_Cell $b)    {        if ($a->getRow() < $b->getRow()) {            return -1;        } elseif ($a->getRow() > $b->getRow()) {            return 1;        } elseif (self::columnIndexFromString($a->getColumn()) < self::columnIndexFromString($b->getColumn())) {            return -1;        } else {            return 1;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPExcel_Cell_192, Convert to string\\\\n\\\\n @return string\\\\n,Prevedi u string.,    public function __toString()    {        return (string) $this->getValue();    },0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessorTest_1027, XSL stylesheet can be applied.\\n\\n @test\\n @covers ::applyXslStyleSheet\\n @depends testTemplateCanBeSavedInTemporaryLocation\\n\\n @param string $actualDocumentFqfn\\n\\n @throws \\\\Exception\\n,Proveri da li XSL stylesheet može da se primeni.,"final public function testXslStyleSheetCanBeApplied($actualDocumentFqfn)    {        $expectedDocumentFqfn = __DIR__ . '/_files/documents/without_table_macros.docx';        $actualDocumentZip = new \ZipArchive();        $actualDocumentZip->open($actualDocumentFqfn);        $actualHeaderXml = $actualDocumentZip->getFromName('word/header1.xml');        $actualMainPartXml = $actualDocumentZip->getFromName('word/document.xml');        $actualFooterXml = $actualDocumentZip->getFromName('word/footer1.xml');        if (false === $actualDocumentZip->close()) {            throw new \Exception(""Could not close zip file \""{$actualDocumentFqfn}\""."");        }        $expectedDocumentZip = new \ZipArchive();        $expectedDocumentZip->open($expectedDocumentFqfn);        $expectedHeaderXml = $expectedDocumentZip->getFromName('word/header1.xml');        $expectedMainPartXml = $expectedDocumentZip->getFromName('word/document.xml');        $expectedFooterXml = $expectedDocumentZip->getFromName('word/footer1.xml');        if (false === $expectedDocumentZip->close()) {            throw new \Exception(""Could not close zip file \""{$expectedDocumentFqfn}\""."");        }        $this->assertXmlStringEqualsXmlString($expectedHeaderXml, $actualHeaderXml);        $this->assertXmlStringEqualsXmlString($expectedMainPartXml, $actualMainPartXml);        $this->assertXmlStringEqualsXmlString($expectedFooterXml, $actualFooterXml);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PHPOffice_PHPWord_TemplateProcessor_964," Raplaces variables with values from array, array keys are the variable names\\n\\n @param array $variableReplacements\\n @param string $xmlBlock\\n\\n @return string[]\\n",Menja promenljive vrednostima iz niza gde su ključevi niza nazivi promenljivih.,"    protected function replaceClonedVariables($variableReplacements, $xmlBlock)    {        $results = array();        foreach ($variableReplacements as $replacementArray) {            $localXmlBlock = $xmlBlock;            foreach ($replacementArray as $search => $replacement) {                $localXmlBlock = $this->setValueForPart(self::ensureMacroCompleted($search), $replacement, $localXmlBlock, self::MAXIMUM_REPLACEMENTS_DEFAULT);            }            $results[] = $localXmlBlock;        }        return $results;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PrestaShop_PrestaShop_Address_782, Check if Address is used (at least one order placed).\\n\\n @return int Order count for this Address\\n,Proveri da li je adresa u upotrebi (bar jedna narudžba je napravljena sa adrese),public function isUsed()    {        if ((int) $this->id <= 0) {            return false;        }        $result = (int) Db::getInstance(_PS_USE_SQL_SLAVE_)->getValue('SELECT COUNT(`id_order`) AS usedFROM `' . _DB_PREFIX_ . 'orders`WHERE `id_address_delivery` = ' . (int) $this->id . 'OR `id_address_invoice` = ' . (int) $this->id);        return $result > 0 ? (int) $result : false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1187," Remove an item from the queue\n\n This is different than {@link extract()}; its purpose is to dequeue an\n item.\n\n This operation is potentially expensive, as it requires\n re-initialization and re-population of the inner queue.\n\n Note: this removes the first item matching the provided item found. If\n the same item has been added multiple times, it will not remove other\n instances.\n\n @param  mixed $datum\n @return bool False if the item was not found, true otherwise.\n\n @psalm-param T $datum\n","Izbaci obejkat iz reda. Ovo je drugačije od extract jer objekat više neće biti u redu. Ova operacija je potencijalno skupa jer zahteva reinicijalizaciju i ponovnu populaciju unutrašnjeg reda. Napomena: ovo izbacuje prvi pronađeni objekat koji se poklapa sa datim objektom. Ukoliko ih ima više, ostali neće biti izbačeni.","    public function remove($datum)    {        $found = false;        foreach ($this->items as $key => $item) {            if ($item['data'] === $datum) {                $found = true;                break;            }        }        if ($found) {            unset($this->items[$key]);            $this->queue = null;            if (! $this->isEmpty()) {                $queue = $this->getQueue();                foreach ($this->items as $item) {                    $queue->insert($item['data'], $item['priority']);                }            }            return true;        }        return false;    }",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1188, Is the queue empty?\n\n @return bool\n,Da li je red prazan?,public function isEmpty()    {        return (0 === $this->count());    },0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1189, How many items are in the queue?\n\n @return int\n,Koliko stavki postoji u redu?,    public function count()    {        return count($this->items);    },0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_1198, Get the inner priority queue instance\n\n @throws Exception\\DomainException\n @return SplPriorityQueue\n,Vraća instancu unutrašnjeg reda sa prioritetom.,"    protected function getQueue()    {        if (null === $this->queue) {            $this->queue = new $this->queueClass();            if (! $this->queue instanceof \SplPriorityQueue) {                throw new Exception\DomainException(sprintf(                    'PriorityQueue expects an internal queue of type SplPriorityQueue; received ""%s""',                    get_class($this->queue)                ));            }        }        return $this->queue;    }",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Sylius_Sylius_LaminasPriorityQueueStub_462, Does the queue have an item with the given priority?\\n\\n @param  int $priority\\n @return bool\\n,Da li red sadrži objekat sa datim prioritetom?,    public function hasPriority($priority)    {        foreach ($this->items as $item) {            if ($item['priority'] === $priority) {                return true;            }        }        return false;    },0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_BinaryToDecimal_2053, This function converts the\n submitted Decimal Number to\n Binary Number.\n\n @param string $decimalNumber\n @return string\n,Ova funkcija pretvara dati decimalni broj u binarni broj.,function decimalToBinary($decimalNumber){    if (!is_numeric($decimalNumber)) {        throw new \Exception('Please pass a valid Decimal Number for Converting it to a Binary Number.');    }    $binaryNumber = '';    while ($decimalNumber > 0) {        $binaryNumber = ($decimalNumber % 2) . $binaryNumber;        $decimalNumber /= 2;    }    return $binaryNumber;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_CheckPrime_2060, This function check whether\n the provided integer is a prime\n number or not.\n\n @param Integer $number An integer input\n @return boolean whether the number is prime or not\n,Ova funkcija proverava da li je dati ceo broj prost broj ili ne.,function isPrime(int $number){    if ($number === 2) {        return true;    }    if ($number % 2 === 0 or $number < 2) {        return false;    }    $i = 3;    while ($i <= sqrt($number)) {        if ($number % $i === 0) {            return false;        }        $i += 2;    }    return true;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_OctalToDecimal_2057, This function converts the\n submitted Decimal Number to\n Octal Number.\n\n @param string $decimalNumber\n @return string\n,Ova funkcija pretvara dati decimalni broj u oktalni broj.,function decimalToOctal($decimalNumber){    if (!is_numeric($decimalNumber)) {        throw new \Exception('Please pass a valid Decimal Number for Converting it to an Octal Number.');    }    $octalNumber = '';    while ($decimalNumber > 0) {        $octalNumber = ($decimalNumber % 8) . $octalNumber;        $decimalNumber /= 8;    }    return $octalNumber;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
TheAlgorithms_PHP_PerfectSquare_2063, This function check whether\n the provided number is a\n perfect square or not.\n\n @param Decimal $number A decimal input\n @return boolean whether the number is perfect square or not\n,Funkcija proverava da li dati broj savršeni kvadrat ili ne.,function is_perfect_square($number){    $root = (int) sqrt($number);    return (($root * $root) === $number); // If number's square root is an integer then it's a perfect square else not},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
YOURLS_YOURLS_functions-auth_647, Check a submitted password sent in plain text against stored password which can be a salted hash\n\n,Proverava da li je podneta lozinka koja je u formi teksta ista kao lozinka koja je heširana.,"function yourls_check_password_hash( $user, $submitted_password ) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
YOURLS_YOURLS_functions-formatting_686," Make sure a date is m(m)/d(d)/yyyy, return false otherwise\n\n","Proveri da li je datum u m(m)/d(d)/yyyy formatu, inače vrati false","function yourls_sanitize_date( $date ) {if( !preg_match( '!^\d{1,2}/\d{1,2}/\d{4}$!' , $date ) ) {return false;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_ConfigPaths_1463," Get potential config directory paths.\n\n Returns `~/.psysh`, `%APPDATA%/PsySH` (when on Windows), and all\n XDG Base Directory config directories:\n\n     http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\n\n @return string[]\n",Vrati potencijalne putanje do direktorijuma koji bi mogli da sadrže konfiguraciju.,"    public function configDirs()    {        if ($this->configDir !== null) {            return [$this->configDir];        }        $configDirs = $this->getEnvArray('XDG_CONFIG_DIRS') ?: ['/etc/xdg'];        return $this->allDirNames(\array_merge([$this->homeConfigDir()], $configDirs));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_ConfigPaths_1466," Get the current home config directory.\n\n Returns the highest precedence home config directory which actually\n exists. If none of them exists, returns the highest precedence home\n config directory (`%APPDATA%/PsySH` on Windows, `~/.config/psysh`\n everywhere else).\n\n @see self::homeConfigDir\n\n @return string\n","Vrati trenutnu putanju do home direktorijuma. Vraća najviši direktorijum koji trenutno postoji. Ako nijedan ne postoji, vraća direktorijum u zavisnosti od operativnog sistema.",public function currentConfigDir()    {        if ($this->configDir !== null) {            return $this->configDir;        }        $configDirs = $this->allDirNames([$this->homeConfigDir()]);        foreach ($configDirs as $configDir) {            if (@\is_dir($configDir)) {                return $configDir;            }        }        return $configDirs[0];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_ConfigPaths_1471, Find real data files in config directories.\n\n @param string[] $names Config file names\n\n @return string[]\n,Nalazi stvarne fajlove u konfiguracionim direktorijima.,"    public function dataFiles(array $names)    {        return $this->allRealFiles($this->dataDirs(), $names);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
bobthecow_psysh_ConfigPaths_1475," Given a list of directories, and a list of filenames, find the ones that\n are real files.\n\n @return string[]\n","Za listu direktorijuma i listu nazia fajlova, nalazi one koji su zaista fajlovi.","    private function allRealFiles(array $dirNames, array $fileNames)    {        $files = [];        foreach ($dirNames as $dir) {            foreach ($fileNames as $name) {                $file = $dir.'/'.$name;                if (@\is_file($file)) {                    $files[] = $file;                }            }        }        return $files;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
botman_botman_BotMan_553, Return a random message.\\n @param array $messages\\n @return $this\\n,Vrati nasumičnu poruku,    public function randomReply(array $messages)    {        return $this->reply($messages[array_rand($messages)]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonImmutable_4, Create a very old date representing start of time.\\n\\n @return static\\n,Napravi jako stari datum koji predstavlja početak vremena,public static function startOfTime(): self    {        $date = static::parse('0001-01-01')->years(self::getStartOfTimeYear());        $date->startOfTime = true;        return $date;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_107, Prepare the object for JSON serialization.\n\n @return array|string\n,Pripremi objekat za JSON serijalizaciju.,    public function jsonSerialize();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_108,Determines if the instance is less (before) than another\\n\\n @example\\n ```\\n Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:15'); // false\\n Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:16'); // false\\n Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:17'); // true\\n ```\\n\\n @param \\\\Carbon\\\\Carbon|\\\\DateTimeInterface|mixed $date\\n\\n @return bool\\n,Proveri da li je instanca pre neke druge. Na primer Carbon::parse('2018-07-25 12:45:16')->lessThan('2018-07-25 12:45:15');,    public function lessThan($date): bool;,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_125, Go forward to the next weekday.\\n\\n @return static\\n,Idi na sledeći radni dan,    public function nextWeekday();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_133, Go backward to the previous weekday.\\n\\n @return static\\n,Idi nazad na prethodni radni dan.,    public function previousWeekday();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_143,The number of seconds until 23:59:59.\\\\n\\\\n @return int\\\\n,Broj sekundi do kraja dana,    public function secondsUntilEndOfDay();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_146," Set the date with gregorian year, month and day numbers.\\n\\n @see https://php.net/manual/en/datetime.setdate.php\\n\\n @param int $year\\n @param int $month\\n @param int $day\\n\\n @return static\\n",Postavi datum pomoću gregorijanskih godina meseci i dana.,"    public function setDate($year, $month, $day);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_152, Set the time by time string.\n\n @param string $time\n\n @return static\n,Postavi datum pomoću stringa.,    public function setTimeFromTimeString($time);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_153," Set the instance's timestamp.\\\\n\\\\n Timestamp input can be given as int, float or a string containing one or more numbers.\\\\n\\\\n @param float|int|string $unixTimestamp\\\\n\\\\n @return static\\\\n",,    public function setTimestamp($unixTimestamp);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_153," Set the instance's timestamp.\n\n Timestamp input can be given as int, float or a string containing one or more numbers.\n\n @param float|int|string $unixTimestamp\n\n @return static\n",,    public function setTimestamp($unixTimestamp);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_154, Set the instance's timezone from a string or object.\\n\\n @param DateTimeZone|string $value\\n\\n @return static\\n,,    public function setTimezone($value);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_156, Set the default translator instance to use.\\\\n\\\\n @param \\\\\\\\Symfony\\\\\\\\Component\\\\\\\\Translation\\\\\\\\TranslatorInterface $translator\\\\n\\\\n @return void\\\\n,,    public static function setTranslator(\Symfony\Component\Translation\TranslatorInterface $translator);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_16, Returns the list of properties to dump on serialize() called on.\\\\n\\\\n @return array\\\\n,,    public function __sleep();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_163, Set the instance's timezone from a string or object and add/subtract the offset difference.\n\n @param DateTimeZone|string $value\n\n @return static\n,,    public function shiftTimezone($value);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_164, Get the month overflow global behavior (can be overridden in specific instances).\n\n @return bool\n,,    public static function shouldOverflowMonths();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_165, Get the month overflow global behavior (can be overridden in specific instances).\\\\n\\\\n @return bool\\\\n,,    public static function shouldOverflowYears();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_168,Resets the date to the first day of the century and the time to 00:00:00\\n\\n @example\\n ```\\n echo Carbon::parse('2018-07-25 12:45:16')->startOfCentury();\\n ```\\n\\n @return static\\n,,    public function startOfCentury();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_169,Resets the time to 00:00:00 start of day\\\\n\\\\n @example\\\\n ```\\\\n echo Carbon::parse('2018-07-25 12:45:16')->startOfDay();\\\\n ```\\\\n\\\\n @return static\\\\n,,    public function startOfDay();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_17, Format the instance as a string using the set format\\n\\n @example\\n ```\\n echo Carbon::now(); // Carbon instances can be casted to string\\n ```\\n\\n @return string\\n,,    public function __toString();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_17, Format the instance as a string using the set format\\\\n\\\\n @example\\\\n ```\\\\n echo Carbon::now(); // Carbon instances can be casted to string\\\\n ```\\\\n\\\\n @return string\\\\n,,    public function __toString();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_170,Resets the date to the first day of the decade and the time to 00:00:00\\\\n\\\\n @example\\\\n ```\\\\n echo Carbon::parse('2018-07-25 12:45:16')->startOfDecade();\\\\n ```\\\\n\\\\n @return static\\\\n,,    public function startOfDecade();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_172,Resets the date to the first day of the millennium and the time to 00:00:00\n\n @example\n ```\n echo Carbon::parse('2018-07-25 12:45:16')->startOfMillennium();\n ```\n\n @return static\n,,    public function startOfMillennium();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_174,Resets the date to the first day of the month and the time to 00:00:00\n\n @example\n ```\n echo Carbon::parse('2018-07-25 12:45:16')->startOfMonth();\n ```\n\n @return static\n,,    public function startOfMonth();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_174,Resets the date to the first day of the month and the time to 00:00:00\\\\n\\\\n @example\\\\n ```\\\\n echo Carbon::parse('2018-07-25 12:45:16')->startOfMonth();\\\\n ```\\\\n\\\\n @return static\\\\n,,    public function startOfMonth();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_175,Resets the date to the first day of the quarter and the time to 00:00:00\n\n @example\n ```\n echo Carbon::parse('2018-07-25 12:45:16')->startOfQuarter();\n ```\n\n @return static\n,,    public function startOfQuarter();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_175,Resets the date to the first day of the quarter and the time to 00:00:00\\n\\n @example\\n ```\\n echo Carbon::parse('2018-07-25 12:45:16')->startOfQuarter();\\n ```\\n\\n @return static\\n,,    public function startOfQuarter();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_176,"Modify to start of current second, microseconds become 0\\n\\n @example\\n ```\\n echo Carbon::parse('2018-07-25 12:45:16.334455')\\n   ->startOfSecond()\\n   ->format('H:i:s.u');\\n ```\\n\\n @return static\\n",,    public function startOfSecond();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_177,Resets the date to the first day of the year and the time to 00:00:00\\n\\n @example\\n ```\\n echo Carbon::parse('2018-07-25 12:45:16')->startOfYear();\\n ```\\n\\n @return static\\n,,    public function startOfYear();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_181, Get default array representation.\\\\n\\\\n @example\\\\n ```\\\\n var_dump(Carbon::now()->toArray());\\\\n ```\\\\n\\\\n @return array\\\\n,,    public function toArray();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
briannesbitt_Carbon_CarbonInterface_181, Get default array representation.\\n\\n @example\\n ```\\n var_dump(Carbon::now()->toArray());\\n ```\\n\\n @return array\\n,,    public function toArray();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_Config_2510, Turns relative paths in absolute paths without realpath()\n\n Since the dirs might not exist yet we can not call realpath or it will fail.\n\n @param  string $path\n @return string\n,Pretvara relativne putanje u apsolutne putanje bez realpath(). S obzirom da možda ne postoje svi direktorijumi realpath() ne sme da se pozove jer može da pukne.,"private function realpath($path)    {        if (preg_match('{^(?:/|[a-z]:|[a-z0-9.]+://)}i', $path)) {            return $path;        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
composer_composer_InstalledVersions_2525, Returns a list of all package names with a specific type e.g. 'library'\n\n @param  string   $type\n @return string[]\n @psalm-return list<string>\n,"Vraća listu naziva svih paketa određenog tipa, npr ‘biblioteka’.",    public static function getInstalledPackagesByType($type)    {        $packagesByType = array();        foreach (self::getInstalled() as $installed) {            foreach ($installed['versions'] as $name => $package) {                if (isset($package['type']) && $package['type'] === $type) {                    $packagesByType[] = $name;                }            }        }        return $packagesByType;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10262," Trims the string and replaces consecutive whitespace characters with a\n single space. This includes tabs and newline characters, as well as\n multibyte whitespace such as the thin space and ideographic space.\n\n @return static Object with a trimmed $str and condensed whitespace\n","Skraćuje string i menja uzastopne razmake sa pojedinačnim razmacima. Razmaci uključuju tabove i karaktere za novi red, kao i višebajtovske razmake.","    public function collapseWhitespace()    {        return $this->regexReplace('[[:space:]]+', ' ')->trim();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10266," Ensures that the string begins with $substring. If it doesn't, it's\n prepended.\n\n @param  string $substring The substring to add if not present\n @return static Object with its $str prefixed by the $substring\n","Proverava da li string počinje sa podstringom, ako ne, dodaje ga na početak.","    public function ensureLeft($substring)    {        $stringy = static::create($this->str, $this->encoding);        if (!$stringy->startsWith($substring)) {            $stringy->str = $substring . $stringy->str;        }        return $stringy;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10272," Returns true if the string contains an upper case char, false\n otherwise.\n\n @return bool Whether or not the string contains an upper case character.\n",Vraća tačno ukoliko string sadrži veliko slovo.,    public function hasUpperCase()    {        return $this->matchesPattern('.*[[:upper:]]');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10274, Inserts $substring into the string at the $index provided.\n\n @param  string $substring String to be inserted\n @param  int    $index     The index at which to insert the substring\n @return static Object with the resulting $str after the insertion\n,Ubacuje podstring u string na željenu poziciju.,"public function insert($substring, $index)    {        $stringy = static::create($this->str, $this->encoding);        if ($index > $stringy->length()) {            return $stringy;        }        $start = \mb_substr($stringy->str, 0, $index, $stringy->encoding);        $end = \mb_substr($stringy->str, $index, $stringy->length(),            $stringy->encoding);        $stringy->str = $start . $substring . $end;        return $stringy;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10279,"Returns true if the string is JSON, false otherwise. Unlike json_decode\n in PHP 5.x, this method is consistent with PHP 7 and other JSON parsers,\n in that an empty string is not considered valid JSON.\n\n @return bool Whether or not $str is JSON\n","Vraća tačno ukoliko je string JSON, a inače netačno. Ovaj metod je konzistantan sa PHP 7 i drugim JSON parserima u tome da se prazan string ne računa kao ispravan JSON.",    public function isJson()    {        if (!$this->length()) {            return false;        }        json_decode($this->str);        return (json_last_error() === JSON_ERROR_NONE);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10285, Returns the length of the string. An alias for PHP's mb_strlen() function.\n\n @return int The number of characters in $str given the encoding\n,Vraća dužinu stringa. Menja PHPovu mb_strlen() funkciju.,"    public function length()    {        return \mb_strlen($this->str, $this->encoding);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10296," Returns a new string with the prefix $substring removed, if present.\n\n @param  string $substring The prefix to remove\n @return static Object having a $str without the prefix $substring\n",Vraća novi string kome je prefiks u obliku podstringa uklonjen ukoliko postoji.,"    public function removeLeft($substring)    {        $stringy = static::create($this->str, $this->encoding);        if ($stringy->startsWith($substring)) {            $substringLength = \mb_strlen($substring, $stringy->encoding);            return $stringy->substr($substringLength);        }        return $stringy;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0
danielstjules_Stringy_Stringy_10300, Returns a reversed string. A multibyte version of strrev().\n\n @return static Object with a reversed $str\n,Obrće string unazad.,"public function reverse()    {        $strLength = $this->length();        $reversed = '';        // Loop from last index of string to first        for ($i = $strLength - 1; $i >= 0; $i--) {            $reversed .= \mb_substr($this->str, $i, 1, $this->encoding);        }        return static::create($reversed, $this->encoding);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_339,draw a bezier curve based on 4 control points\n\n @param $x0\n @param $y0\n @param $x1\n @param $y1\n @param $x2\n @param $y2\n @param $x3\n @param $y3\n,Crta bezier-ovu krivu zasnovanu na četiri kontrolne tačke.,"function curve($x0, $y0, $x1, $y1, $x2, $y2, $x3, $y3)    {        // in the current line style, draw a bezier curve from (x0,y0) to (x3,y3) using the other two points        // as the control points for the curve.        $this->addContent(            sprintf(""\n%.3F %.3F m %.3F %.3F %.3F %.3F %.3F %.3F c S"", $x0, $y0, $x1, $y1, $x2, $y2, $x3, $y3)        );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_345,"a filled rectangle, note that it is the width and height of the rectangle which are the secondary parameters, not\n the coordinates of the upper-right corner\n\n @param $x1\n @param $y1\n @param $width\n @param $height\n","Ispunjen pravougaonik. Obratiti pažnju da su širina i visina sekundarni parametri, a ne koordinate gornjeg desnog ugla.","function filledRectangle($x1, $y1, $width, $height)    {        $this->addContent(sprintf(""\n%.3F %.3F %.3F %.3F re f"", $x1, $y1, $width, $height));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_362, apply graphic transformations\n\n @param array $tm transformation matrix\n,Primeni grafičku transformaciju.,"function transform($tm)    {        $this->addContent(vsprintf(""\n %.3F %.3F %.3F %.3F %.3F %.3F cm"", $tm));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_Cpdf_377, extract an integer from a position in a byte stream\n\n @param $data\n @param $pos\n @param $num\n @return int\n,Vrati ceo broj sa pozicije u toku bajtova.,"private function getBytes(&$data, $pos, $num)    {        // return the integer represented by $num bytes from $pos within $data        $ret = 0;        for ($i = 0; $i < $num; $i++) {            $ret *= 256;            $ret += ord($data[$pos + $i]);        }        return $ret;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dompdf_dompdf_JavascriptEmbedder_623, Embeds Javascript into the PDF document\n\n @package dompdf\n,Usađuje javascript u PDF dokument,class JavascriptEmbedder{    /**     * @var Dompdf     */    protected $_dompdf;    /**     * JavascriptEmbedder constructor.     *     * @param Dompdf $dompdf     */    public function __construct(Dompdf $dompdf)    {        $this->_dompdf = $dompdf;    }    /**     * @param $script     */    public function insert($script)    {        $this->_dompdf->getCanvas()->javascript($script);    }    /**     * @param Frame $frame     */    public function render(Frame $frame)    {        if (!$this->_dompdf->getOptions()->getIsJavascriptEnabled()) {            return;        }        $this->insert($frame->get_node()->nodeValue);    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_FrameCollection_6736," Returns an array with all frames, does not affect\n the internal array.\n\n @todo   If this gets any more complex than this,\n         have getIterator use this method.\n @see    FrameCollection::getIterator\n @return array\n","Vraća niz sa svim frejmovima, bez da utiče na lokalni niz.",    public function getArray()    {        return $this->frames;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_FrameCollection_7500, Count the frames that belongs to the application.\n\n @return int\n,Izbroj frejmove koji pripadaju aplikaciji.,"    public function countIsApplication()    {        return count(array_filter($this->frames, function (Frame $f) {            return $f->isApplication();        }));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
filp_whoops_Frame_7102, Compares Frame against one another\n @param  Frame $frame\n @return bool\n,Proverava da li su dva frejma jednaka,    public function equals(Frame $frame)    {        if (!$this->getFile() || $this->getFile() === 'Unknown' || !$this->getLine()) {            return false;        }        return $frame->getFile() === $this->getFile() && $frame->getLine() === $this->getLine();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
fzaninotto_Faker_Iban_929, Checks whether an IBAN has a valid checksum\\\\n\\\\n @param string $iban\\\\n @return boolean\\\\n,Proverava da li IBAN ima validnu checksumu,"public static function isValid($iban)    {        return self::checksum($iban) === substr($iban, 2, 2);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Cache_1469, Returns a boolean state of whether or not the item exists in the cache based on id key\n\n @param string $id    the id of the cached data entry\n @return bool         true if the cached items exists\n,Vraća logičko stanje toga da li stavka postoji u kešu za zadati id ključ.,    public function contains($id)    {        if ($this->enabled) {            return $this->driver->contains(($id));        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1202, Measure how long it takes to do an action.\\n\\n @param string $timerId\\n @param string $timerTitle\\n @param callable $callback\\n @return mixed   Returns value returned by the callable.\\n,Meri koliko vremena traje određena akcija.,"    public function measureTime(string $timerId, string $timerTitle, callable $callback)    {        $debugger = $this['debugger'];        $debugger->startTimer($timerId, $timerTitle);        $result = $callback();        $debugger->stopTimer($timerId);        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
getgrav_grav_Grav_1205," This attempts to find media, other files, and download them\\n\\n @param string $path\\n @return PageInterface|false\\n",Pokušava da nađe medije i druge fajlove i da ih preuzme.,"    public function fallbackUrl($path)    {        $this->fireEvent('onPageFallBackUrl');        /** @var Uri $uri */        $uri = $this['uri'];        /** @var Config $config */        $config = $this['config'];        $uri_extension = strtolower($uri->extension());        $fallback_types = $config->get('system.media.allowed_fallback_types', null);        $supported_types = $config->get('media.types');        // Check whitelist first, then ensure extension is a valid media type        if (!empty($fallback_types) && !in_array($uri_extension, $fallback_types, true)) {            return false;        }        if (!array_key_exists($uri_extension, $supported_types)) {            return false;        }        $path_parts = pathinfo($path);        /** @var Pages $pages */        $pages = $this['pages'];        $page = $pages->find($path_parts['dirname'], true);        if ($page) {            $media = $page->media()->all();            $parsed_url = parse_url(rawurldecode($uri->basename()));            $media_file = $parsed_url['path'];            // if this is a media object, try actions first            if (isset($media[$media_file])) {                /** @var Medium $medium */                $medium = $media[$media_file];                foreach ($uri->query(null, true) as $action => $params) {                    if (in_array($action, ImageMedium::$magic_actions, true)) {                        call_user_func_array([&$medium, $action], explode(',', $params));                    }                }                Utils::download($medium->path(), false);            }            // unsupported media type, try to download it...            if ($uri_extension) {                $extension = $uri_extension;            } else {                if (isset($path_parts['extension'])) {                    $extension = $path_parts['extension'];                } else {                    $extension = null;                }            }            if ($extension) {                $download = true;                if (in_array(ltrim($extension, '.'), $config->get('system.media.unsupported_inline_types', []), true)) {                    $download = false;                }                Utils::download($page->path() . DIRECTORY_SEPARATOR . $uri->basename(), $download);            }            // Nothing found            return false;        }        return $page;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
googleapis_google-api-php-client_Model_665, Convert a string to camelCase\n @param  string $value\n @return string\n,Prevodi string u camelCase,"private function camelCase($value)  {    $value = ucwords(str_replace(array('-', '_'), ' ', $value));    $value = str_replace(' ', '', $value);    $value[0] = strtolower($value[0]);    return $value;  }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1806, Evaluates to true if any item in an array satisfies the given matcher.\n\n @param mixed $item as a {@link Hamcrest\\Matcher} or a value.\n\n @return \\Hamcrest\\Arrays\\IsArrayContaining\n,Vraća tačno ukoliko bar jedan objekat u nizu zadovoljava uslov.,    function hasItemInArray($item)    {        return \Hamcrest\Arrays\IsArrayContaining::hasItemInArray($item);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1808, An array with elements that match the given matchers.\\n,Niz elemenata koji se podudaraju sa datim šablonima,"    function arrayContainingInAnyOrder(/* args... */)    {        $args = func_get_args();        return call_user_func_array(array('\Hamcrest\Arrays\IsArrayContainingInAnyOrder', 'arrayContainingInAnyOrder'), $args);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1814, Test if an array has both an key and value in parity with each other.\\n,Proveri da li niz sadrži i ključ i vrednost koji su upareni.,"    function hasKeyValuePair($key, $value)    {        return \Hamcrest\Arrays\IsArrayContainingKeyValuePair::hasKeyValuePair($key, $value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1817, Matches an empty array.\\n,Podudara se sa praznim nizom,    function emptyArray()    {        return \Hamcrest\Arrays\IsArrayWithSize::emptyArray();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1833," Is the value equal to another value, as tested by the use of the ""==""\n comparison operator?\n","Da li je jedna vrednost jednaka drugoj vrednosti, kao kad bi bio korišćen operator ==.",    function equalTo($item)    {        return \Hamcrest\Core\IsEqual::equalTo($item);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1834," Tests of the value is identical to $value as tested by the ""==="" operator.\\n","Proverava da li su dve vrednosti identične, kao kada bi bio korišćen operator ===.",    function identicalTo($value)    {        return \Hamcrest\Core\IsIdentical::identicalTo($value);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1836," Is the value an instance of a particular type?\\n This version assumes no relationship between the required type and\\n the signature of the method that sets it up, for example in\\n <code>assertThat($anObject, anInstanceOf('Thing'));</code>\\n",Proverava da li je vrednost instance određenog tipa. Ova verzija ne podrazumeva nikakav odnos između traženog tipa i potpisa metoda koji ga postavlja.,    function any($theClass)    {        return \Hamcrest\Core\IsInstanceOf::anInstanceOf($theClass);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1860, Matches if value is a string that matches regular expression $pattern.\n,Podudara se ako je vrednost string koji se podudara sa regularnim izrazom.,    function matchesPattern($pattern)    {        return \Hamcrest\Text\MatchesPattern::matchesPattern($pattern);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1861, Matches if value is a string that contains $substring.\n,Podudara se ako je vrednost string koji sadržei podstring.,    function containsString($substring)    {        return \Hamcrest\Text\StringContains::containsString($substring);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1862, Matches if value is a string that contains $substring regardless of the case.\n,"Slaže se ukoliko string sadrži podstring, bez obzira na mala i velika slova.",    function containsStringIgnoringCase($substring)    {        return \Hamcrest\Text\StringContainsIgnoringCase::containsStringIgnoringCase($substring);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1865, Matches if value is a string that starts with $substring.\\n,Slaže se ukoliko string počinje podstringom,    function startsWith($substring)    {        return \Hamcrest\Text\StringStartsWith::startsWith($substring);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1866, Is the value an array?\n,Proverava da li je vrednost niz,    function arrayValue()    {        return \Hamcrest\Type\IsArray::arrayValue();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1868, Is the value a boolean?\n,Proverava da li je vrednost logička,    function boolValue()    {        return \Hamcrest\Type\IsBoolean::booleanValue();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_1875, Is the value an object?\\n,Proverava da li je vrednost objekat.,    function objectValue()    {        return \Hamcrest\Type\IsObject::objectValue();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hamcrest_hamcrest-php_Hamcrest_2366, Matches if value is a non-zero-length string.\n,Slaže se ukoliko je vrednost string nenulte dužine.,    function isNonEmptyString()    {        return \Hamcrest\Text\IsEmptyString::isNonEmptyString();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_AdaBoost_840, Returns the classifier with the lowest error rate with the\n consideration of current sample weights\n,Vrati klasifikator sa najmanjom greškom uz razmatranje težina trenutnog uzorka,"protected function getBestClassifier(): Classifier    {        $ref = new ReflectionClass($this->baseClassifier);        /** @var Classifier $classifier */        $classifier = count($this->classifierOptions) === 0 ? $ref->newInstance() : $ref->newInstanceArgs($this->classifierOptions);        if ($classifier instanceof WeightedClassifier) {            $classifier->setSampleWeights($this->weights);            $classifier->train($this->samples, $this->targets);        } else {            [$samples, $targets] = $this->resample();            $classifier->train($samples, $targets);        }        return $classifier;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Adaline_852, Adapts the weights with respect to given samples and targets\n by use of gradient descent learning rule\n,Prilagođava težine uzimajući u obzir date uzorke i ciljeve koristeći gradijentni spust.,"protected function runTraining(array $samples, array $targets): void    {        // The cost function is the sum of squares        $callback = function ($weights, $sample, $target): array {            $this->weights = $weights;            $output = $this->output($sample);            $gradient = $output - $target;            $error = $gradient ** 2;            return [$error, $gradient];        };        $isBatch = $this->trainingType == self::BATCH_TRAINING;        parent::runGradientDescent($samples, $targets, $callback, $isBatch);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_ConjugateGradient_931, Executes the callback function for the problem and returns\n sum of the gradient for all samples & targets.\n,Izvršava funkciju povratnog poziva i vraća sumu gradijenta za sve uzorke i ciljeve,"protected function gradient(array $theta): array    {        [, $updates, $penalty] = parent::gradient($theta);        // Calculate gradient for each dimension        $gradient = [];        for ($i = 0; $i <= $this->dimensions; ++$i) {            if ($i === 0) {                $gradient[$i] = array_sum($updates);            } else {                $col = array_column($this->samples, $i - 1);                $error = 0;                foreach ($col as $index => $val) {                    $error += $val * $updates[$index];                }                $gradient[$i] = $error + $penalty * $theta[$i];            }        }        return $gradient;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_ConjugateGradient_943, Element-wise <b>subtraction</b> of a vector with a scalar\n,Oduzimanje skalara od vektora. Od svakog elementa vektora se oduzima vrednost skalara.,"public static function subs(array $m1, float $m2): array    {        return self::adds($m1, $m2, -1);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_DecisionStump_857, Returns the probability of the sample of belonging to the given label\n\n Probability of a sample is calculated as the proportion of the label\n within the labels of the training samples in the decision node\n\n @param mixed $label\n,Vraća verovatnoću da uzorak pripada datom cilju. Verovatnoća uzorka se računa kao odnos cilj među ciljevima uzoraka iz skupa za obučavanje za čvor odlučivanja.,"protected function predictProbability(array $sample, $label): float    {        $predicted = $this->predictSampleBinary($sample);        if ((string) $predicted == (string) $label) {            return $this->prob[$label];        }        return 0.0;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_EigenTransformerBase_897, Class to compute eigen pairs (values & vectors) of a given matrix\n with the consideration of numFeatures or totalVariance to be preserved\n\n @author hp\n,Klasa za računanje sopstvenih parova (vrednosti i vektora) date matrice sa obaziranjem da numFeatures ili totalVariance budu očuvane.,abstract class EigenTransformerBase{    /**     * Total variance to be conserved after the reduction     *     * @var float     */    public $totalVariance = 0.9;    /**     * Number of features to be preserved after the reduction     *     * @var int     */    public $numFeatures = null;    /**     * Top eigenvectors of the matrix     *     * @var array     */    protected $eigVectors = [];    /**     * Top eigenValues of the matrix     *     * @var array     */    protected $eigValues = [];    /**     * Calculates eigenValues and eigenVectors of the given matrix. Returns     * top eigenVectors along with the largest eigenValues. The total explained variance     * of these eigenVectors will be no less than desired $totalVariance value     */    protected function eigenDecomposition(array $matrix): void    {        $eig = new EigenvalueDecomposition($matrix);        $eigVals = $eig->getRealEigenvalues();        $eigVects = $eig->getEigenvectors();        $totalEigVal = array_sum($eigVals);        // Sort eigenvalues in descending order        arsort($eigVals);        $explainedVar = 0.0;        $vectors = [];        $values = [];        foreach ($eigVals as $i => $eigVal) {            $explainedVar += $eigVal / $totalEigVal;            $vectors[] = $eigVects[$i];            $values[] = $eigVal;            if ($this->numFeatures !== null) {                if (count($vectors) == $this->numFeatures) {                    break;                }            } else {                if ($explainedVar >= $this->totalVariance) {                    break;                }            }        }        $this->eigValues = $values;        $this->eigVectors = $vectors;    }    /**     * Returns the reduced data     */    protected function reduce(array $data): array    {        $m1 = new Matrix($data);        $m2 = new Matrix($this->eigVectors);        return $m1->multiply($m2->transpose())->toArray();    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_EigenvalueDecomposition_1002, Performs complex division.\n\n @param int|float $xr\n @param int|float $xi\n @param int|float $yr\n @param int|float $yi\n,Izvršava deljenje dva kompleksna broja.,"    private function cdiv($xr, $xi, $yr, $yi): void    {        if (abs($yr) > abs($yi)) {            $r = $yi / $yr;            $d = $yr + $r * $yi;            $this->cdivr = ($xr + $r * $xi) / $d;            $this->cdivi = ($xi - $r * $xr) / $d;        } else {            $r = $yr / $yi;            $d = $yi + $r * $yr;            $this->cdivr = ($r * $xr + $xi) / $d;            $this->cdivi = ($r * $xi - $xr) / $d;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_EigenvalueDecomposition_995, Return the eigenvector matrix\n,Vraća matricu sopstvenih vektora.,"public function getEigenvectors(): array    {        $vectors = $this->V;        // Always return the eigenvectors of length 1.0        $vectors = new Matrix($vectors);        $vectors = array_map(function ($vect) {            $sum = 0;            $count = count($vect);            for ($i = 0; $i < $count; ++$i) {                $sum += $vect[$i] ** 2;            }            $sum **= .5;            for ($i = 0; $i < $count; ++$i) {                $vect[$i] /= $sum;            }            return $vect;        }, $vectors->transpose()->toArray());        return $vectors;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_FuzzyCMeans_877, The objective is to minimize the distance between all data points\n and all cluster centers. This method returns the summation of all\n these distances\n,Cilj je minimizacija udaljenost između svih tačaka i svih centara grupa. Metod vraća sumu svih ovih udaljenosti.,"protected function getObjective(): float    {        $sum = 0.0;        $distance = new Euclidean();        for ($i = 0; $i < $this->clustersNumber; ++$i) {            $clust = $this->clusters[$i]->getCoordinates();            for ($k = 0; $k < $this->sampleCount; ++$k) {                $point = $this->samples[$k];                $sum += $distance->distance($clust, $point);            }        }        return $sum;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_LDA_910, Calculates mean of each column for each class and returns\n n by m matrix where n is number of labels and m is number of columns\n,"Računa srednju svake kolone za svaku klasu i vraća nxm matricu gde je n broj labela, a m broj kolona.","protected function calculateMeans(array $data, array $classes): array    {        $means = [];        $counts = [];        $overallMean = array_fill(0, count($data[0]), 0.0);        foreach ($data as $index => $row) {            $label = array_search($classes[$index], $this->labels, true);            foreach ($row as $col => $val) {                if (!isset($means[$label][$col])) {                    $means[$label][$col] = 0.0;                }                $means[$label][$col] += $val;                $overallMean[$col] += $val;            }            if (!isset($counts[$label])) {                $counts[$label] = 0;            }            ++$counts[$label];        }        foreach ($means as $index => $row) {            foreach ($row as $col => $sum) {                $means[$index][$col] = $sum / $counts[$index];            }        }        // Calculate overall mean of the dataset for each column        $numElements = array_sum($counts);        $map = function ($el) use ($numElements) {            return $el / $numElements;        };        $this->overallMean = array_map($map, $overallMean);        $this->counts = $counts;        return $means;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_LogisticRegression_869, Returns the probability of the sample of belonging to the given label.\n\n The probability is simply taken as the distance of the sample\n to the decision plane.\n\n @param mixed $label\n,Vraća verovatnoću da dat uzorak pripada zadatom cilju. Verovatnoća se prosto uzima kao udaljenost uzorka do ravni odlučivanja.,"protected function predictProbability(array $sample, $label): float    {        $sample = $this->checkNormalizedSample($sample);        $probability = $this->output($sample);        if (array_search($label, $this->labels, true) > 0) {            return $probability;        }        return 1 - $probability;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Matrix_964, Element-wise subtracting of another matrix from this one\n,Oduzimanje druge matrice od ove po elementima.,"public function subtract(self $other): self    {        return $this->sum($other, -1);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Matrix_967," Returns the dot product of two arrays<br>\n Matrix::dot(x, y) ==> x.y'\n",Vraća skalarni proizvod dva niza.,"public static function dot(array $array1, array $array2): array    {        $m1 = new self($array1, false);        $m2 = new self($array2, false);        return $m1->multiply($m2->transpose())->toArray()[0];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_PCA_914, Takes a data and returns a lower dimensional version\n of this data while preserving $totalVariance or $numFeatures. <br>\n $data is an n-by-m matrix and returned array is\n n-by-k matrix where k <= m\n,Uzima podatke i vraća njihovu niže dimenzionalnu verzija sa učanjem ukupne varijanse ili broja odlika. Podaci su nxm matrica a vraćena matrica je nxk matrica gde je k <= m.,"public function fit(array $data): array    {        $n = count($data[0]);        $data = $this->normalize($data, $n);        $covMatrix = Covariance::covarianceMatrix($data, array_fill(0, $n, 0));        $this->eigenDecomposition($covMatrix);        $this->fit = true;        return $this->reduce($data);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_PCA_916, Normalization of the data includes subtracting mean from\n each dimension therefore dimensions will be centered to zero\n,"Normalizacija koja podrazumeva oduzimanje srednje vrednosti od svake dimenzije, tako da su sve dimenzije centrirane na nulu.","protected function normalize(array $data, int $n): array    {        if (count($this->means) === 0) {            $this->calculateMeans($data, $n);        }        // Normalize data        foreach (array_keys($data) as $i) {            for ($k = 0; $k < $n; ++$k) {                $data[$i][$k] -= $this->means[$k];            }        }        return $data;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_Set_982, Removes duplicates and rewrites index.\n\n @param string[]|int[]|float[]|bool[] $elements\n\n @return string[]|int[]|float[]|bool[]\n,Briše duplikate I prepisuje indekse.,"    private static function sanitize(array $elements): array    {        sort($elements, SORT_ASC);        return array_values(array_unique($elements, SORT_ASC));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_StandardDeviation_1020, Sum of squares deviations\n ∑⟮xᵢ - μ⟯²\n\n @param float[]|int[] $numbers\n,Suma kvadrata devijacija.,"public static function sumOfSquares(array $numbers): float    {        if (count($numbers) === 0) {            throw new InvalidArgumentException('The array has zero elements');        }        $mean = Mean::arithmetic($numbers);        return array_sum(array_map(            static function ($val) use ($mean): float {                return ($val - $mean) ** 2;            },            $numbers        ));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
jorgecasas_php-ml_StochasticGD_949, Stochastic Gradient Descent optimization method\n to find a solution for the equation A.ϴ = y where\n  A (samples) and y (targets) are known and ϴ is unknown.\n,"Stohastični gradijentni spust kao metod optimizacija za nalaženje rešenja jednačine Atheta=y gde su A (uzorci) i y (ciljevi) poznati, a theta nije poznato.","class StochasticGD extends Optimizer{    /**     * A (samples)     *     * @var array     */    protected $samples = [];    /**     * y (targets)     *     * @var array     */    protected $targets = [];    /**     * Callback function to get the gradient and cost value     * for a specific set of theta (ϴ) and a pair of sample & target     *     * @var \Closure|null     */    protected $gradientCb;    /**     * Maximum number of iterations used to train the model     *     * @var int     */    protected $maxIterations = 1000;    /**     * Learning rate is used to control the speed of the optimization.<br>     *     * Larger values of lr may overshoot the optimum or even cause divergence     * while small values slows down the convergence and increases the time     * required for the training     *     * @var float     */    protected $learningRate = 0.001;    /**     * Minimum amount of change in the weights and error values     * between iterations that needs to be obtained to continue the training     *     * @var float     */    protected $threshold = 1e-4;    /**     * Enable/Disable early stopping by checking the weight & cost values     * to see whether they changed large enough to continue the optimization     *     * @var bool     */    protected $enableEarlyStop = true;    /**     * List of values obtained by evaluating the cost function at each iteration     * of the algorithm     *     * @var array     */    protected $costValues = [];    /**     * Initializes the SGD optimizer for the given number of dimensions     */    public function __construct(int $dimensions)    {        // Add one more dimension for the bias        parent::__construct($dimensions + 1);        $this->dimensions = $dimensions;    }    public function setTheta(array $theta): Optimizer    {        if (count($theta) !== $this->dimensions + 1) {            throw new InvalidArgumentException(sprintf('Number of values in the weights array should be %s', $this->dimensions + 1));        }        $this->theta = $theta;        return $this;    }    /**     * Sets minimum value for the change in the theta values     * between iterations to continue the iterations.<br>     *     * If change in the theta is less than given value then the     * algorithm will stop training     *     * @return $this     */    public function setChangeThreshold(float $threshold = 1e-5)    {        $this->threshold = $threshold;        return $this;    }    /**     * Enable/Disable early stopping by checking at each iteration     * whether changes in theta or cost value are not large enough     *     * @return $this     */    public function setEarlyStop(bool $enable = true)    {        $this->enableEarlyStop = $enable;        return $this;    }    /**     * @return $this     */    public function setLearningRate(float $learningRate)    {        $this->learningRate = $learningRate;        return $this;    }    /**     * @return $this     */    public function setMaxIterations(int $maxIterations)    {        $this->maxIterations = $maxIterations;        return $this;    }    /**     * Optimization procedure finds the unknow variables for the equation A.ϴ = y     * for the given samples (A) and targets (y).<br>     *     * The cost function to minimize and the gradient of the function are to be     * handled by the callback function provided as the third parameter of the method.     */    public function runOptimization(array $samples, array $targets, Closure $gradientCb): array    {        $this->samples = $samples;        $this->targets = $targets;        $this->gradientCb = $gradientCb;        $currIter = 0;        $bestTheta = null;        $bestScore = 0.0;        $this->costValues = [];        while ($this->maxIterations > $currIter++) {            $theta = $this->theta;            // Update the guess            $cost = $this->updateTheta();            // Save the best theta in the ""pocket"" so that            // any future set of theta worse than this will be disregarded            if ($bestTheta === null || $cost <= $bestScore) {                $bestTheta = $theta;                $bestScore = $cost;            }            // Add the cost value for this iteration to the list            $this->costValues[] = $cost;            // Check for early stop            if ($this->enableEarlyStop && $this->earlyStop($theta)) {                break;            }        }        $this->clear();        // Solution in the pocket is better than or equal to the last state        // so, we use this solution        return $this->theta = (array) $bestTheta;    }    /**     * Returns the list of cost values for each iteration executed in     * last run of the optimization     */    public function getCostValues(): array    {        return $this->costValues;    }    protected function updateTheta(): float    {        $jValue = 0.0;        $theta = $this->theta;        if ($this->gradientCb === null) {            throw new InvalidOperationException('Gradient callback is not defined');        }        foreach ($this->samples as $index => $sample) {            $target = $this->targets[$index];            $result = ($this->gradientCb)($theta, $sample, $target);            [$error, $gradient, $penalty] = array_pad($result, 3, 0);            // Update bias            $this->theta[0] -= $this->learningRate * $gradient;            // Update other values            for ($i = 1; $i <= $this->dimensions; ++$i) {                $this->theta[$i] -= $this->learningRate *                    ($gradient * $sample[$i - 1] + $penalty * $this->theta[$i]);            }            // Sum error rate            $jValue += $error;        }        return $jValue / count($this->samples);    }    /**     * Checks if the optimization is not effective enough and can be stopped     * in case large enough changes in the solution do not happen     */    protected function earlyStop(array $oldTheta): bool    {        // Check for early stop: No change larger than threshold (default 1e-5)        $diff = array_map(            function ($w1, $w2) {                return abs($w1 - $w2) > $this->threshold ? 1 : 0;            },            $oldTheta,            $this->theta        );        if (array_sum($diff) == 0) {            return true;        }        // Check if the last two cost values are almost the same        $costs = array_slice($this->costValues, -2);        if (count($costs) === 2 && abs($costs[1] - $costs[0]) < $this->threshold) {            return true;        }        return false;    }    /**     * Clears the optimizer internal vars after the optimization process.     */    protected function clear(): void    {        $this->samples = [];        $this->targets = [];        $this->gradientCb = null;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
lcobucci_jwt_Decoder_3360," Decodes from JSON, validating the errors\n\n @return mixed\n\n @throws CannotDecodeContent When something goes wrong while decoding.\n",Dekodira JSON I validira greške,    public function jsonDecode(string $json);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
lcobucci_jwt_Encoder_3363,Encodes to base64url\n\n @link http://tools.ietf.org/html/rfc4648#section-5\n,Enkodira podatke kao base64url.,public function base64UrlEncode(string $data): string;,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
lcobucci_jwt_Signer_3367, Returns if the expected hash matches with the data and key\n\n @throws InvalidKeyProvided When issue key is invalid/incompatible.\n @throws ConversionFailed   When signature could not be converted.\n,Proverava da li se hash poklapa sa podacima i datim ključem.,"    public function verify(string $expected, string $payload, Key $key): bool;",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_Archive_2849, Check file is TAR.\n\n @param string $file\n @return boolean\n,Proverava da li je Fajl TAR.,public function isTar($file)    {        $archivers = $this->_getArchivers($file);        if (count($archivers) == 1 && $archivers[0] == self::TAPE_ARCHIVER) {            return true;        }        return false;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_CanViewNotification_2792, Validate if notification popup can be shown and set the notification flag\n\n @param array $arguments Attributes from element node.\n @inheritdoc\n,Potvrdi da li je moguće prikazati iskačuće obaveštenje i postavi flag.,"    public function isVisible(array $arguments): bool    {        $cacheKey = self::$cachePrefix;        $value = $this->cacheStorage->load($cacheKey);        if ($value !== 'log-exists') {            $logExists = $this->viewerLogger->checkLogExists();            if ($logExists) {                $this->cacheStorage->save('log-exists', $cacheKey);            }            return !$logExists;        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
magento_magento2_processor_2883, Retrieve client IP address\n\n @return string\n,Dohvati klijentsu IP adresu.,    protected function _getClientIp()    {        return (isset($_SERVER['REMOTE_ADDR'])) ? $_SERVER['REMOTE_ADDR'] : 'undefined';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Algebra_2490,"Least common multiple\n The smallest positive integer that is divisible by both a and b.\n For example, the LCM of 5 and 2 is 10.\n https://en.wikipedia.org/wiki/Least_common_multiple\n\n              |a ⋅ b|\n lcm(a, b) = ---------\n             gcd(a, b)\n\n @param  int $a\n @param  int $b\n\n @return int\n","Najmanji zajednički sadržalac. Najmanji pozitivni ceo broj koji je deljiv i sa a i sa b. Na primer, NZS brojeva 5 i 2 je 10.","public static function lcm(int $a, int $b): int    {        // Special case        if ($a === 0 || $b === 0) {            return 0;        }        return \abs($a * $b) / Algebra::gcd($a, $b);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Algebra_2493,Discriminant\\n https://en.wikipedia.org/wiki/Discriminant\\n\\n Δ = b² - 4ac\\n\\n @param  float $a x² coefficient\\n @param  float $b x coefficient\\n @param  float $c constant coefficient\\n\\n @return float\\n,Diskriminanta.,"public static function discriminant(float $a, float $b, float $c): float    {        return $b ** 2 - (4 * $a * $c);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2900,String representation - Display the number in base 10\\n\\n @return string\\n\\n @throws Exception\\\\BadParameterException\\n,"Predstavi broj u bazi 10, kao string.","public function __toString(): string    {        $sign = $this->isPositive ? '' : '-';        return $sign . BaseEncoderDecoder::toBase($this, 10);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2902,"Negate - Multiply by -1\\n\\n If $this is zero, then do nothing\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n",Negacija - množenje sa -1,"public function negate(): ArbitraryInteger    {        return self::fromBinary($this->base256, $this->base256 == \chr(0) ? true : !$this->isPositive);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2905, Factorial\\n\\n Calculate the factorial of an ArbitraryInteger\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n,Faktorijel. Izračunaj faktorijel za ArbitraryInteger.,public function fact(): ArbitraryInteger    {        $result = new ArbitraryInteger(1);        $i_obj  = new ArbitraryInteger(0);        for ($i = 1; !$this->lessThan($i); $i++) {            $i_obj  = $i_obj->add(1);            $result = $result->multiply($i_obj);        }        return $result;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2908," Multiply\\n Return the result of multiplying two ArbitraryIntegers, or an ArbitraryInteger and an integer.\\n @todo use Karatsuba algorithm\\n\\n @param int|string|ArbitraryInteger $number\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n",Množenje. Vrati rezultat množenja dva ArbitratyIntegera.,"public function multiply($number): ArbitraryInteger    {        $number_obj  = self::create($number);        $number  = $number_obj->toBinary();        $length  = \strlen($number);        $product = new ArbitraryInteger(0);        for ($i = 1; $i <= $length; $i++) {            $this_len      = \strlen($this->base256);            $base_digit    = \ord(\substr($number, -1 * $i, 1));            $carry         = 0;            $inner_product = '';            for ($j = 1; $j <= $this_len; $j++) {                $digit         = \ord(\substr($this->base256, -1 * $j, 1));                $step_product  = $digit * $base_digit + $carry;                $mod           = $step_product % 256;                $carry         = \intdiv($step_product, 256);                $inner_product = \chr($mod) . $inner_product;            }            if ($carry > 0) {                $inner_product = \chr($carry) . $inner_product;            }            $inner_product = $inner_product . \str_repeat(\chr(0), $i - 1);            $inner_obj     = self::fromBinary($inner_product, true);            $product       = $product->add($inner_obj);        }        return ($this->isPositive ^ $number_obj->isPositive()) ? $product->negate() : $product;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ArbitraryInteger_2913, Left Shift\\n\\n Shift the bits of $this $bits steps to the left\\n @param int|string|ArbitraryInteger $bits\\n\\n @return ArbitraryInteger\\n\\n @throws Exception\\\\BadParameterException\\n @throws Exception\\\\IncorrectTypeException\\n,Pomeranje bitova objekta za bits koraka u levo.,"public function leftShift($bits)    {        $bits           = self::create($bits);        $shifted_string = '';        $length         = \strlen($this->base256);        [$bytes, $bits] = $bits->fullIntdiv(8);        $bits           = $bits->toInt();        $carry          = 0;        for ($i = 0; $i < $length; $i++) {            $chr = \ord($this->base256[$i]);            // If $shifted string is empty, don’t add 0x00.            $new_value = \chr($carry + \intdiv($chr << $bits, 256));            if ($shifted_string !== """" || $new_value !== \chr(0)) {                $shifted_string .= $new_value;            }            $carry = ($chr << $bits) % 256;        }        $shifted_string .= \chr($carry);        // Pad $bytes of 0x00 on the right.        $shifted_string = $shifted_string . \str_repeat(\chr(0), $bytes->toInt());        return self::fromBinary($shifted_string, true);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3437, Calculate the mean average of a list of numbers\\n\\n     ∑⟮xᵢ⟯\\n x̄ = -----\\n       n\\n\\n @param float[] $numbers\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException if the input array of numbers is empty\\n,Računa srednju vrednost liste brojeva.,    public static function mean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the average of an empty list of numbers');        }        return \array_sum($numbers) / \count($numbers);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3440,"Return the kth smallest value in an array\n Uses a linear-time algorithm: O(n) time in worst case.\n\n if $a = [1,2,3,4,6,7]\n\n kthSmallest($a, 4) = 6\n\n Algorithm:\n  1) If n is small, just sort and return\n  2) Otherwise, group into 5-element subsets and mind the median\n  3) Find the median of the medians\n  4) Find L and U sets\n     - L is numbers lower than the median of medians\n     - U is numbers higher than the median of medians\n  5) Recursive step\n     - if k is the median of medians, return that\n     - Otherwise, recursively search in smaller group.\n\n @param float[] $numbers\n @param int    $k zero indexed - must be less than n (count of $numbers)\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n @throws Exception\\OutOfBoundsException if k ≥ n\n",Vraća k-tu najmanju vrednost u nizu. Koristi algoritam linearne složenosti O(n) u najgorem slučaju.,"public static function kthSmallest(array $numbers, int $k): float    {        $n = \count($numbers);        if ($n === 0) {            throw new Exception\BadDataException('Cannot find the k-th smallest of an empty list of numbers');        }        if ($k >= $n) {            throw new Exception\OutOfBoundsException('k cannot be greater than or equal to the count of numbers');        }        // Reset the array key indexes because we don't know what might be passed in        $numbers = \array_values($numbers);        // If the array is 5 elements or smaller, use quicksort and return the element of interest.        if ($n <= 5) {            \sort($numbers);            return $numbers[$k];        }        // Otherwise, we are going to slice $numbers into 5-element slices and find the median of each.        $num_slices = \ceil($n / 5);        $median_array = [];        for ($i = 0; $i < $num_slices; $i++) {            $median_array[] = self::median(\array_slice($numbers, 5 * $i, 5));        }        // Then we find the median of the medians.        $median_of_medians = self::median($median_array);        // Next we walk the array and separate it into values that are greater than or less than this ""median of medians"".        $lower_upper   = self::splitAtValue($numbers, $median_of_medians);        $lower_number = \count($lower_upper['lower']);        $equal_number = $lower_upper['equal'];        // Lastly, we find which group of values our value of interest is in, and find it in the smaller array.        if ($k < $lower_number) {            return self::kthSmallest($lower_upper['lower'], $k);        } elseif ($k < ($lower_number + $equal_number)) {            return $median_of_medians;        } else {            return self::kthSmallest($lower_upper['upper'], $k - $lower_number - $equal_number);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3443, Geometric mean\n A type of mean which indicates the central tendency or typical value of a set of numbers\n by using the product of their values (as opposed to the arithmetic mean which uses their sum).\n https://en.wikipedia.org/wiki/Geometric_mean\n                    __________\n Geometric mean = ⁿ√a₀a₁a₂ ⋯\n\n @param  float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n,Geometrijska sredina. Tip sredine koji ukazuje centralnu naklonost ili tipičnu vrednost skipa brojeva koristeći proizvod njihovih vrednosti. (Za razliku od aritmetičke sredine koja koristi njihovu sumu).,"public static function geometricMean(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the geometric mean of an empty list of numbers');        }        $n       = \count($numbers);        $a₀a₁a₂⋯ = \array_reduce(            $numbers,            function ($carry, $a) {                return $carry * $a;            },            1        );        $ⁿ√a₀a₁a₂⋯ = \pow($a₀a₁a₂⋯, 1 / $n);        return $ⁿ√a₀a₁a₂⋯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Average_3465," Get a report of all the averages over a list of numbers\\n Includes mean, median mode, geometric mean, harmonic mean, quardratic mean\\n\\n @param array $numbers\\n\\n @return array [ mean, median, mode, geometric_mean, harmonic_mean,\\n                 contraharmonic_mean, quadratic_mean, trimean, iqm, cubic_mean ]\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\OutOfBoundsException\\n","Napravi izveštaj za sve proseke liste brojeva. Uključuje srednju vrednost, harmonijsku sredinu, kvadratnu sredinu, kontraharmonijsku sredinu, trimijansku sredinu i inverznu kvadratnu sredinu.","    public static function describe(array $numbers): array    {        return [            'mean'                => self::mean($numbers),            'median'              => self::median($numbers),            'mode'                => self::mode($numbers),            'geometric_mean'      => self::geometricMean($numbers),            'harmonic_mean'       => self::harmonicMean($numbers),            'contraharmonic_mean' => self::contraharmonicMean($numbers),            'quadratic_mean'      => self::quadraticMean($numbers),            'trimean'             => self::trimean($numbers),            'iqm'                 => self::iqm($numbers),            'cubic_mean'          => self::cubicMean($numbers),        ];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Basic_3391,"Digit sum (sum of digits)\n https://en.wikipedia.org/wiki/Digit_sum\n https://oeis.org/A007953\n\n Example\n  n = 11\n  Sequence:    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1\n  Array index: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1\n\n @param  int $n How many numbers in the sequence\n\n @return array Indexed from 0 (indexes are the n in the digitSum(n))\n",Suma cifara.,public static function digitSum(int $n): array    {        if ($n <= 0) {            return [];        }        $digit_sums = [];        for ($i = 0; $i < $n; $i++) {            $digit_sums[] = Arithmetic::digitSum($i);        }        return $digit_sums;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Bernoulli_3208, Bernoulli distribution\\n\\n https://en.wikipedia.org/wiki/Bernoulli_distribution\\n,Bernulijeva raspodela.,"class Bernoulli extends Discrete{    /**     * Distribution parameter bounds limits     * p ∈ (0,1)     * @var array     */    public const PARAMETER_LIMITS = [        'p' => '(0,1)',        'q' => '[0,1)',    ];    /**     * Distribution support bounds limits     * k ∈ [0,1]     * p ∈ (0,1)     * @var array     */    public const SUPPORT_LIMITS = [        'k' => '[0,1]',    ];    /** @var float probability of success */    protected $p;    /** @var float */    protected $q;    /**     * Constructor     *     * @param float $p success probability  0 < p < 1     */    public function __construct(float $p)    {        $q = 1 - $p;        parent::__construct($p, $q);    }    /**     * Probability mass function     *     * q = (1 - p)  for k = 0     * p            for k = 1     *     * @param  int $k number of successes  k ∈ {0, 1}     *     * @return float     */    public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        if ($k === 0) {            return $this->q;        } else {            return $this->p;        }    }    /**     * Cumulative distribution function     *     * 0      for k < 0     * 1 - p  for 0 ≤ k < 1     * 1      for k ≥ 1     *     * @param  int $k number of successes  k ∈ {0, 1}     *     * @return float     */    public function cdf(int $k): float    {        if ($k < 0) {            return 0;        }        if ($k < 1) {            return 1 - $this->p;        }        return 1;    }    /**     * Mean of the distribution     *     * μ = p     *     * @return float     */    public function mean(): float    {        return $this->p;    }    /**     * Median of the distribution     *     * 0    for p < ½     * ½    for p = ½     * 1    for p > ½     *     * @return float     */    public function median(): float    {        $p = $this->p;        $½ = 0.5;        if ($p < $½) {            return 0;        }        if ($p == $½) {            return $½;        }        return 1;    }    /**     * Mode of the distribution     *     * 0    for p < ½     * 0,1  for p = ½     * 1    for p > ½     *     * @return float[]     */    public function mode(): array    {        $p = $this->p;        $½ = 0.5;        if ($p < $½) {            return [0];        }        if ($p == $½) {            return [0, 1];        }        return [1];    }    /**     * Variance of the distribution     *     * σ² = p(1 - p) = pq     *     * @return float     */    public function variance(): float    {        return $this->p * $this->q;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Bernoulli_3210,"Probability mass function\\n\\n q = (1 - p)  for k = 0\\n p            for k = 1\\n\\n @param  int $k number of successes  k ∈ {0, 1}\\n\\n @return float\\n",Gustina verovatnoće,"public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        if ($k === 0) {            return $this->q;        } else {            return $this->p;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Bernoulli_3211,"Cumulative distribution function\n\n 0      for k < 0\n 1 - p  for 0 ≤ k < 1\n 1      for k ≥ 1\n\n @param  int $k number of successes  k ∈ {0, 1}\n\n @return float\n",Kumulativna raspodela,public function cdf(int $k): float    {        if ($k < 0) {            return 0;        }        if ($k < 1) {            return 1 - $this->p;        }        return 1;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Bernoulli_3212, Mean of the distribution\n\n μ = p\n\n @return float\n,Srednja vrednost raspodele.,    public function mean(): float    {        return $this->p;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Bernoulli_3213,Median of the distribution\n\n 0    for p < ½\n ½    for p = ½\n 1    for p > ½\n\n @return float\n,Medijana raspodele.,public function median(): float    {        $p = $this->p;        $½ = 0.5;        if ($p < $½) {            return 0;        }        if ($p == $½) {            return $½;        }        return 1;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3216, Binomial distribution - probability mass function\\n\\n https://en.wikipedia.org/wiki/Binomial_distribution\\n,Binomijalna raspodela - funkcija gustine verovatnoće,"class Binomial extends Discrete{    /**     * Distribution parameter bounds limits     * n ∈ [0,∞)     * p ∈ [0,1]     * @var array     */    public const PARAMETER_LIMITS = [        'n' => '[0,∞)',        'p' => '[0,1]',    ];    /**     * Distribution support bounds limits     * r ∈ [0,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'r' => '[0,∞)',    ];    /** @var int number of events */    protected $n;    /** @var float probability of success */    protected $p;    /**     * Constructor     *     * @param int   $n number of events n >= 0     * @param float $p probability of success 0 <= p <= 1     */    public function __construct(int $n, float $p)    {        parent::__construct($n, $p);    }    /**     * Probability mass function     *     * P(X = r) = nCr pʳ (1 - p)ⁿ⁻ʳ     *     * If n is large, combinatorial factorial blows up,     * so use the multiplication method instead.     *     * @param  int $r number of successful events     *     * @return float     */    public function pmf(int $r): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['r' => $r]);        return $this->n < 150            ? $this->combinatorialMethod($r)            : $this->multiplicationMethod($r, $this->n, $this->p);    }    /**     * PMF combinatorial method     *     * P(X = r) = nCr pʳ (1 - p)ⁿ⁻ʳ     *     * @param int $r number of successful events     *     * @return float     *     * @throws \MathPHP\Exception\OutOfBoundsException     */    private function combinatorialMethod(int $r): float    {        $n = $this->n;        $p = $this->p;        $nCr       = Combinatorics::combinations($n, $r);        $pʳ        = \pow($p, $r);        $⟮1 − p⟯ⁿ⁻ʳ = \pow(1 - $p, $n - $r);        return $nCr * $pʳ * $⟮1 − p⟯ⁿ⁻ʳ;    }    /**     * PMF multiplication method     *     * Evaluate binomial probabilities using a method that avoids unnecessary overflow and underflow     * Catherine Loader: http://octave.1599824.n4.nabble.com/attachment/3829107/0/loader2000Fast.pdf     *     *               x             x   n-x     *              __  n - x + i __   __     * p(x; n, p) = ||  --------- || p ||  (1 - p)     *              ⁱ⁼¹     i     ⁱ⁼¹  ⁱ⁼¹     *     * @param int   $r number of successful events     * @param int   $n number of events     * @param float $p probability of success     *     * @return float     */    private function multiplicationMethod(int $r, int $n, float $p): float    {        if (2 * $r > $n) {            return $this->multiplicationMethod($n - $r, $n, 1 - $p);        }        [$j₀, $j₁, $j₂] = [0, 0, 0];        $f = 1;        while (($j₀ < $r) | ($j₁ < $r) | ($j₂ < $n - $r)) {            if (($j₀ < $r) && ($f < 1)) {                $j₀++;                $f *= ($n - $r + $j₀) / $j₀;            } elseif ($j₁ < $r) {                $j₁++;                $f *= $p;            } else {                $j₂++;                $f *= 1 - $p;            }        }        return $f;    }    /**     * Cumulative distribution function     * Computes and sums the binomial distribution at each of the values in r.     *     * @param  int $r number of successful events     *     * @return float     */    public function cdf(int $r): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['r' => $r]);        $cdf = 0;        for ($i = $r; $i >= 0; $i--) {            $cdf += $this->pmf($i);        }        return $cdf;    }    /**     * Mean of the distribution     *     * μ = np     *     * @return float     */    public function mean(): float    {        return $this->n * $this->p;    }    /**     * Variance of the distribution     *     * σ² = np(1 - p)     *     * @return float     */    public function variance(): float    {        $n = $this->n;        $p = $this->p;        return $n * $p * (1 - $p);    }}",0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3222, Mean of the distribution\\n\\n μ = np\\n\\n @return float\\n,Srednja vrednost raspodele.,    public function mean(): float    {        return $this->n * $this->p;    },0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Binomial_3223,Variance of the distribution\\n\\n σ² = np(1 - p)\\n\\n @return float\\n,Varijansa raspodele.,public function variance(): float    {        $n = $this->n;        $p = $this->p;        return $n * $p * (1 - $p);    },0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cauchy_3065, Cauchy distribution\n https://en.wikipedia.org/wiki/Cauchy_distribution\n,Košijeva raspodela.,"class Cauchy extends Continuous{    /**     * Distribution parameter bounds limits     * x₀ ∈ (-∞,∞)     * γ  ∈ (0,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'x₀' => '(-∞,∞)',        'γ'  => '(0,∞)',    ];    /**     * Distribution support bounds limits     * x  ∈ (-∞,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x'  => '(-∞,∞)',    ];    /** @var number Location Parameter */    protected $x₀;    /** @var number Scale Parameter */    protected $γ;    /**     * Constructor     *     * @param float $x₀ location parameter     * @param float $γ  scale parameter γ > 0     */    public function __construct(float $x₀, float $γ)    {        parent::__construct($x₀, $γ);    }    /**     * Probability density function     *     *                1     *    --------------------------     *       ┌        / x - x₀ \ ² ┐     *    πγ | 1  +  | ---------|  |     *       └        \    γ   /   ┘     *     * @param float $x     *     * @return float     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π  = \M_PI;        return 1 / ($π * $γ * (1 + (($x - $x₀) / $γ) ** 2));    }    /**     * Cumulative distribution function     * Calculate the cumulative value value up to a point, left tail.     *     * @param float $x     *     * @return float     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π  = \M_PI;        return 1 / $π * \atan(($x - $x₀) / $γ) + .5;    }    /**     * Inverse CDF (Quantile function)     *     * Q(p;x₀,γ) = x₀ + γ tan[π(p - ½)]     *     * @param float $p     *     * @return float     */    public function inverse(float $p): float    {        Support::checkLimits(['p' => '[0,1]'], ['p' => $p]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π = \M_PI;        return $x₀ + $γ * \tan($π * ($p - .5));    }    /**     * Mean of the distribution (undefined)     *     * μ is undefined     *     * @return float \NAN     */    public function mean(): float    {        return \NAN;    }    /**     * Median of the distribution     *     * @return float x₀     */    public function median(): float    {        return $this->x₀;    }    /**     * Mode of the distribution     *     * @return float x₀     */    public function mode(): float    {        return $this->x₀;    }    /**     * Variance of the distribution (undefined)     *     * @return float     */    public function variance(): float    {        return \NAN;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Cauchy_3068," Cumulative distribution function\\n Calculate the cumulative value value up to a point, left tail.\\n\\n @param float $x\\n\\n @return float\\n",Kumulativna raspodela,"public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $x₀ = $this->x₀;        $γ  = $this->γ;        $π  = \M_PI;        return 1 / $π * \atan(($x - $x₀) / $γ) + .5;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Combinatorics_3047,Factorial (iterative)\n Represents the number of ways to arrange n things (permutations)\n n! = n(n - 1)(n - 2) ・・・ (n - (n - 1))\n\n @param  int $n\n\n @return float number of permutations of n\n\n @throws Exception\\OutOfBoundsException if n < 0\n,Faktorijel. Predstavlja broj načina da se n stvari rasporedi. n!=n(n-1)(n-2)…(n-(n-1)),public static function factorial(int $n): float    {        if ($n < 0) {            throw new Exception\OutOfBoundsException('Cannot compute factorial of a negative number.');        }        $factorial = 1;        while ($n > 1) {            $factorial *= $n;            --$n;        }        return $factorial;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_ComplexMatrix_2609, Validate the matrix is entirely complex\n\n @throws Exception\\IncorrectTypeException if all elements are not complex\n,Potvrdi da li je matrica u potpunosti kompleksna.,"    protected function validateComplexData(array $A)    {        foreach ($A as $i => $row) {            foreach ($row as $object) {                if (!$object instanceof Complex) {                    throw new Exception\IncorrectTypeException(""All elements in the complex matrix must be complex. Got "" . \get_class($object));                }            }        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2917,"Complex Numbers\\n\\n A complex number is a number that can be expressed in the form a + bi,\\n where a and b are real numbers and i is the imaginary unit, satisfying the\\n equation i² = −1. In this expression, a is the real part and b is the imaginary\\n part of the complex number.\\n https://en.wikipedia.org/wiki/Complex_number\\n\\n @property-read number $r\\n @property-read number $i\\n","Kompleksni brojevi. Kompleksni broj je onaj broj koji se može izraziti u formi a + bi gde su a i b realni brojevi, a i je imaginarna jedinica koja zadovoljava jednakost i^2=-1. U ovom izrazu, a je realni deo, a b je imaginarni deo kompleksnog broja.","class Complex implements ObjectArithmetic{    /**     * Real part of the complex number     * @var number     */    protected $r;    /**     * Imaginary part fo the complex number     * @var number     */    protected $i;    /**     * Floating-point range near zero to consider insignificant.     */    private const EPSILON = 1e-6;    /**     * Constructor     *     * @param number $r Real part     * @param number $i Imaginary part     */    public function __construct($r, $i)    {        $this->r = $r;        $this->i = $i;    }    /**     * Creates 0 + 0i     *     * @return Complex     */    public static function createZeroValue(): ObjectArithmetic    {        return new Complex(0, 0);    }    /**     * String representation of a complex number     * a + bi, a - bi, etc.     *     * @return string     */    public function __toString(): string    {        if ($this->r == 0 & $this->i == 0) {            return '0';        } elseif ($this->r == 0) {            return ""$this->i"" . 'i';        } elseif ($this->i == 0) {            return ""$this->r"";        } elseif ($this->i > 0) {            return ""$this->r"" . ' + ' . ""$this->i"" . 'i';        } else {            return ""$this->r"" . ' - ' . (string) \abs($this->i) . 'i';        }    }    /**     * Get r or i     *     * @param string $part     *     * @return number     *     * @throws Exception\BadParameterException if something other than r or i is attempted     */    public function __get(string $part)    {        switch ($part) {            case 'r':            case 'i':                return $this->$part;            default:                throw new Exception\BadParameterException(""The $part property does not exist in Complex number"");        }    }    /**************************************************************************     * UNARY FUNCTIONS     **************************************************************************/    /**     * The conjugate of a complex number     *     * https://en.wikipedia.org/wiki/Complex_number#Conjugate     *     * @return Complex     */    public function complexConjugate(): Complex    {        return new Complex($this->r, -1 * $this->i);    }    /**     * The absolute value (magnitude) of a complex number (modulus)     * https://en.wikipedia.org/wiki/Complex_number#Absolute_value_and_argument     *     * If z = a + bi     *        _______     * |z| = √a² + b²     *     * @return number     */    public function abs()    {        return \sqrt($this->r ** 2 + $this->i ** 2);    }    /**     * The argument (phase) of a complex number     * The argument of z is the angle of the radius OP with the positive real axis, and is written as arg(z).     * https://en.wikipedia.org/wiki/Complex_number#Absolute_value_and_argument     *     * If z = a + bi     * arg(z) = atan(b, a)     *     * @return number     */    public function arg()    {        return \atan2($this->i, $this->r);    }    /**     * The square root of a complex number     * https://en.wikipedia.org/wiki/Complex_number#Square_root     *     * The roots of a + bi (with b ≠ 0) are ±(γ + δi), where     *     *         ____________     *        /     _______     *       / a + √a² + b²     * γ =  /  ------------     *     √         2     *     *               ____________     *              /      _______     *             / -a + √a² + b²     * δ = sgn(b) /  -------------     *           √         2     *     * The square root returns the positive root.     *     * @return Complex (positive root)     */    public function sqrt(): Complex    {        return $this->roots()[0];    }    /**     * The roots of a complex number     * https://en.wikipedia.org/wiki/Complex_number#Square_root     *     * The roots of a + bi (with b ≠ 0) are ±(γ + δi), where     *     *         ____________     *        /     _______     *       / a + √a² + b²     * γ =  /  ------------     *     √         2     *     *               ____________     *              /      _______     *             / -a + √a² + b²     * δ = sgn(b) /  -------------     *           √         2     *     *     * @return array Complex[] (two roots)     */    public function roots(): array    {        $sgn = Special::sgn($this->i) >= 0 ? 1 : -1;        $γ   = \sqrt(($this->r + $this->abs()) / 2);        $δ   = $sgn * \sqrt((-$this->r + $this->abs()) / 2);        $z₁ = new Complex($γ, $δ);        $z₂ = new Complex(-$γ, -$δ);        return [$z₁, $z₂];    }    /**     * The inverse of a complex number (reciprocal)     *     * https://en.wikipedia.org/wiki/Complex_number#Reciprocal     *     * @return Complex     *     * @throws Exception\BadDataException if = to 0 + 0i     */    public function inverse(): Complex    {        if ($this->r == 0 && $this->i == 0) {            throw new Exception\BadDataException('Cannot take inverse of 0 + 0i');        }        return $this->complexConjugate()->divide($this->abs() ** 2);    }    /**     * Negate the complex number     * Switches the signs of both the real and imaginary parts.     *     * @return Complex     */    public function negate(): Complex    {        return new Complex(-$this->r, -$this->i);    }    /**     * Polar form     * https://en.wikipedia.org/wiki/Complex_number#Polar_form     *     * z = a + bi = r(cos(θ) + i  sin(θ))     * Where     *  r = |z|     *  θ = arg(z) (in radians)     *     * @return Complex     */    public function polarForm(): Complex    {        $r = $this->abs();        $θ = $this->arg();        return new Complex($r * \cos($θ), $r * \sin($θ));    }    /**************************************************************************     * BINARY FUNCTIONS     **************************************************************************/    /**     * Complex addition     * https://en.wikipedia.org/wiki/Complex_number#Addition_and_subtraction     *     * (a + bi) + (c + di) = (a + c) + (b + d)i     *     * @param mixed $c     *     * @return Complex     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Complex.     */    public function add($c): Complex    {        if (\is_numeric($c)) {            $r = $this->r + $c;            $i = $this->i;        } elseif ($c instanceof Complex) {            $r = $this->r + $c->r;            $i = $this->i + $c->i;        } else {            throw new Exception\IncorrectTypeException('Argument must be real or complex number');        }        return new Complex($r, $i);    }    /**     * Complex subtraction     * https://en.wikipedia.org/wiki/Complex_number#Addition_and_subtraction     *     * (a + bi) - (c + di) = (a - c) + (b - d)i     *     * @param mixed $c     *     * @return Complex     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Complex.     */    public function subtract($c): Complex    {        if (\is_numeric($c)) {            $r = $this->r - $c;            $i = $this->i;        } elseif ($c instanceof Complex) {            $r = $this->r - $c->r;            $i = $this->i - $c->i;        } else {            throw new Exception\IncorrectTypeException('Argument must be real or complex number');        }        return new Complex($r, $i);    }    /**     * Complex multiplication     * https://en.wikipedia.org/wiki/Complex_number#Multiplication_and_division     *     * (a + bi)(c + di) = (ac - bd) + (bc + ad)i     *     * @param mixed $c     *     * @return Complex     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Complex.     */    public function multiply($c): Complex    {        if (\is_numeric($c)) {            $r = $c * $this->r;            $i = $c * $this->i;        } elseif ($c instanceof Complex) {            $r = $this->r * $c->r - $this->i * $c->i;            $i = $this->i * $c->r + $this->r * $c->i;        } else {            throw new Exception\IncorrectTypeException('Argument must be real or complex number');        }        return new Complex($r, $i);    }    /**     * Complex division     * Dividing two complex numbers is accomplished by multiplying the first by the inverse of the second     * https://en.wikipedia.org/wiki/Complex_number#Multiplication_and_division     *     * @param mixed $c     *     * @return Complex     *     * @throws Exception\IncorrectTypeException if the argument is not numeric or Complex.     */    public function divide($c): Complex    {        if (\is_numeric($c)) {            $r = $this->r / $c;            $i = $this->i / $c;            return new Complex($r, $i);        } elseif ($c instanceof Complex) {            return $this->multiply($c->inverse());        } else {            throw new Exception\IncorrectTypeException('Argument must be real or complex number');        }    }    /**************************************************************************     * COMPARISON FUNCTIONS     **************************************************************************/    /**     * Test for equality     * Two complex numbers are equal if and only if both their real and imaginary parts are equal.     *     * https://en.wikipedia.org/wiki/Complex_number#Equality     *     * @param Complex $c     *     * @return bool     */    public function equals(Complex $c): bool    {        return \abs($this->r - $c->r) < self::EPSILON && \abs($this->i - $c->i) < self::EPSILON;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2923, The absolute value (magnitude) of a complex number (modulus)\\n https://en.wikipedia.org/wiki/Complex_number#Absolute_value_and_argument\\n\\n If z = a + bi\\n        _______\\n |z| = √a² + b²\\n\\n @return number\\n,Apsolutna vrednost (magnituda) kompleksnog broja (moduo).,public function abs()    {        return \sqrt($this->r ** 2 + $this->i ** 2);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2925,"The square root of a complex number\n https://en.wikipedia.org/wiki/Complex_number#Square_root\n\n The roots of a + bi (with b ≠ 0) are ±(γ + δi), where\n\n         ____________\n        /     _______\n       / a + √a² + b²\n γ =  /  ------------\n     √         2\n\n               ____________\n              /      _______\n             / -a + √a² + b²\n δ = sgn(b) /  -------------\n           √         2\n\n The square root returns the positive root.\n\n @return Complex (positive root)\n",Kvadratni koren kompleksnog broja.,public function sqrt(): Complex    {        return $this->roots()[0];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2928, Negate the complex number\n Switches the signs of both the real and imaginary parts.\n\n @return Complex\n,Negacija kompleksnog broja. Menja znakove i realnog i imaginarnog dela.,"    public function negate(): Complex    {        return new Complex(-$this->r, -$this->i);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Complex_2934, Test for equality\n Two complex numbers are equal if and only if both their real and imaginary parts are equal.\n\n https://en.wikipedia.org/wiki/Complex_number#Equality\n\n @param Complex $c\n\n @return bool\n,Proverava jednakost. Dva kompleksna broja su jednaka ako i samo ako su njihovi i realni i imaginarni delovi jednaki.,    public function equals(Complex $c): bool    {        return \abs($this->r - $c->r) < self::EPSILON && \abs($this->i - $c->i) < self::EPSILON;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Correlation_3473, Statistical correlation\n  - covariance\n  - correlation coefficient (r)\n  - coefficient of determination (R²)\n  - Kendall's tau (τ)\n  - Spearman's rho (ρ)\n  - confidence ellipse\n,Statistička korelacija - kovarijansa - korelacioni koeficijent - koeficijent odlučnosti - Kendalovo Tau - Spirmanovo rho - elipsa sigurnosti.,"class Correlation{    private const X = 0;    private const Y = 1;    /**     * Covariance     * Convenience method to access population and sample covariance.     *     * A measure of how much two random variables change together.     * Average product of their deviations from their respective means.     * The population covariance is defined in terms of the sample means x, y     * https://en.wikipedia.org/wiki/Covariance     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param bool $population Optional flag for population or sample covariance     *     * @return float     *     * @throws Exception\BadDataException     */    public static function covariance(array $X, array $Y, bool $population = false): float    {        return $population            ? self::populationCovariance($X, $Y)            : self::sampleCovariance($X, $Y);    }    /**     * Population Covariance     * A measure of how much two random variables change together.     * Average product of their deviations from their respective means.     * The population covariance is defined in terms of the population means μx, μy     * https://en.wikipedia.org/wiki/Covariance     *     * cov(X, Y) = σxy = E[⟮X - μx⟯⟮Y - μy⟯]     *     *                   ∑⟮xᵢ - μₓ⟯⟮yᵢ - μy⟯     * cov(X, Y) = σxy = -----------------     *                           N     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException if X and Y do not have the same number of elements     */    public static function populationCovariance(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('X and Y must have the same number of elements.');        }        $μₓ = Average::mean($X);        $μy = Average::mean($Y);        $∑⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ = \array_sum(\array_map(            function ($xᵢ, $yᵢ) use ($μₓ, $μy) {                return ( $xᵢ - $μₓ ) * ( $yᵢ - $μy );            },            $X,            $Y        ));        $N = \count($X);        return $∑⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ / $N;    }    /**     * Sample covariance     * A measure of how much two random variables change together.     * Average product of their deviations from their respective means.     * The population covariance is defined in terms of the sample means x, y     * https://en.wikipedia.org/wiki/Covariance     *     * cov(X, Y) = Sxy = E[⟮X - x⟯⟮Y - y⟯]     *     *                   ∑⟮xᵢ - x⟯⟮yᵢ - y⟯     * cov(X, Y) = Sxy = ---------------     *                         n - 1     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException if X and Y do not have the same number of elements     */    public static function sampleCovariance(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('X and Y must have the same number of elements.');        }        $x = Average::mean($X);        $y = Average::mean($Y);        $∑⟮xᵢ − x⟯⟮yᵢ − y⟯ = \array_sum(\array_map(            function ($xᵢ, $yᵢ) use ($x, $y) {                return ( $xᵢ - $x ) * ( $yᵢ - $y );            },            $X,            $Y        ));        $n = \count($X);        return $∑⟮xᵢ − x⟯⟮yᵢ − y⟯ / ($n - 1);    }    /**     * Weighted covariance     * A measure of how much two random variables change together with weights.     * https://en.wikipedia.org/wiki/Pearson_correlation_coefficient#Weighted_correlation_coefficient     *     *                       ∑wᵢ⟮xᵢ - μₓ⟯⟮yᵢ - μy⟯     * cov(X, Y, w) = sxyw = --------------------     *                              ∑wᵢ     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param array $w values for weights     *     * @return float     *     * @throws Exception\BadDataException if X and Y do not have the same number of elements     */    public static function weightedCovariance(array $X, array $Y, array $w): float    {        if (\count($X) !== \count($Y) || \count($X) !== \count($w)) {            throw new Exception\BadDataException('X, Y and w must have the same number of elements.');        }        $μₓ = Average::weightedMean($X, $w);        $μy = Average::weightedMean($Y, $w);        $∑wᵢ⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ = \array_sum(\array_map(            function ($xᵢ, $yᵢ, $wᵢ) use ($μₓ, $μy) {                return $wᵢ * ( $xᵢ - $μₓ ) * ( $yᵢ - $μy );            },            $X,            $Y,            $w        ));        $∑wᵢ = \array_sum($w);        return $∑wᵢ⟮xᵢ − μₓ⟯⟮yᵢ − μy⟯ / $∑wᵢ;    }    /**     * r - correlation coefficient     * Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r)     *     * Convenience method for population and sample correlationCoefficient     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param bool $population Optional flag for population or sample covariance     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function r(array $X, array $Y, bool $population = false): float    {        return $population            ? self::populationCorrelationCoefficient($X, $Y)            : self::sampleCorrelationCoefficient($X, $Y);    }    /**     * Population correlation coefficient     * Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r)     *     * A normalized measure of the linear correlation between two variables X and Y,     * giving a value between +1 and −1 inclusive, where 1 is total positive correlation,     * 0 is no correlation, and −1 is total negative correlation.     * It is widely used in the sciences as a measure of the degree of linear dependence     * between two variables.     * https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient     *     * The correlation coefficient of two variables in a data sample is their covariance     * divided by the product of their individual standard deviations.     *     *        cov(X,Y)     * ρxy = ----------     *         σx σy     *     *  conv(X,Y) is the population covariance     *  σx is the population standard deviation of X     *  σy is the population standard deviation of Y     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function populationCorrelationCoefficient(array $X, array $Y): float    {        $cov⟮X，Y⟯ = self::populationCovariance($X, $Y);        $σx      = Descriptive::standardDeviation($X, true);        $σy      = Descriptive::standardDeviation($Y, true);        return $cov⟮X，Y⟯ / ( $σx * $σy );    }    /**     * Sample correlation coefficient     * Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r)     *     * A normalized measure of the linear correlation between two variables X and Y,     * giving a value between +1 and −1 inclusive, where 1 is total positive correlation,     * 0 is no correlation, and −1 is total negative correlation.     * It is widely used in the sciences as a measure of the degree of linear dependence     * between two variables.     * https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient     *     * The correlation coefficient of two variables in a data sample is their covariance     * divided by the product of their individual standard deviations.     *     *          Sxy     * rxy = ----------     *         sx sy     *     *  Sxy is the sample covariance     *  σx is the sample standard deviation of X     *  σy is the sample standard deviation of Y     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function sampleCorrelationCoefficient(array $X, array $Y): float    {        $Sxy = self::sampleCovariance($X, $Y);        $sx  = Descriptive::standardDeviation($X, Descriptive::SAMPLE);        $sy  = Descriptive::standardDeviation($Y, Descriptive::SAMPLE);        return $Sxy / ( $sx * $sy );    }    /**     * R² - coefficient of determination     * Convenience wrapper for coefficientOfDetermination     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param bool $popluation     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function r2(array $X, array $Y, bool $popluation = false): float    {        return \pow(self::r($X, $Y, $popluation), 2);    }    /**     * R² - coefficient of determination     *     * Indicates the proportion of the variance in the dependent variable     * that is predictable from the independent variable.     * Range of 0 - 1. Close to 1 means the regression line is a good fit     * https://en.wikipedia.org/wiki/Coefficient_of_determination     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param bool $popluation     *     * @return float     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function coefficientOfDetermination(array $X, array $Y, bool $popluation = false): float    {        return \pow(self::r($X, $Y, $popluation), 2);    }    /**     * Weighted correlation coefficient     * Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r) width weighted values     *     * A normalized measure of the linear correlation between two variables X and Y,     * giving a value between +1 and −1 inclusive, where 1 is total positive correlation,     * 0 is no correlation, and −1 is total negative correlation.     * It is widely used in the sciences as a measure of the degree of linear dependence between two variables.     * https://en.wikipedia.org/wiki/Pearson_correlation_coefficient#Weighted_correlation_coefficient     *     * The weighted correlation coefficient of two variables in a data sample is their covariance     * divided by the product of their individual standard deviations.     *     *          cov(X,Y,w)     * ρxyw = -------------     *          √(sxw syw)     *     *  conv(X,Y, w) is the weighted covariance     *  sxw is the weighted variance of X     *  syw is the weighted variance of Y     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     * @param array $w values for weights     *     * @return float     *     * @throws Exception\BadDataException     */    public static function weightedCorrelationCoefficient(array $X, array $Y, array $w): float    {        $cov⟮X，Y，w⟯ = self::weightedCovariance($X, $Y, $w);        $sxw         = Descriptive::weightedSampleVariance($X, $w, true);        $syw         = Descriptive::weightedSampleVariance($Y, $w, true);        return $cov⟮X，Y，w⟯ / \sqrt($sxw * $syw);    }    /**     * τ - Kendall rank correlation coefficient (Kendall's tau)     *     * A statistic used to measure the ordinal association between two     * measured quantities. It is a measure of rank correlation:     * the similarity of the orderings of the data when ranked by each     * of the quantities.     * https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient     * https://onlinecourses.science.psu.edu/stat509/node/158     *     * tau-a (no rank ties):     *     *        nc - nd     *   τ = ----------     *       n(n - 1)/2     *     *   Where     *     nc: number of concordant pairs     *     nd: number of discordant pairs     *     * tau-b (rank ties exist):     *     *                 nc - nd     *   τ = -----------------------------     *       √(nc + nd + X₀)(nc + nd + Y₀)     *     *   Where     *     X₀: number of pairs tied only on the X variable     *     Y₀: number of pairs tied only on the Y variable     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @todo Implement with algorithm faster than O(n²)     *     * @return float     *     * @throws Exception\BadDataException if both random variables do not have the same number of elements     */    public static function kendallsTau(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('Both random variables must have the same number of elements');        }        $n = \count($X);        // Match X and Y pairs and sort by X rank        $xy = \array_map(            function ($x, $y) {                return [$x, $y];            },            $X,            $Y        );        \usort($xy, function ($a, $b) {            return $a[0] <=> $b[0];        });        // Initialize counters        $nc      = 0;  // concordant pairs        $nd      = 0;  // discordant pairs        $ties_x  = 0;  // ties xᵢ = xⱼ        $ties_y  = 0;  // ties yᵢ = yⱼ        $ties_xy = 0;  // ties xᵢ = xⱼ and yᵢ = yⱼ        // Tally concordant, discordant, and tied pairs        for ($i = 0; $i < $n; $i++) {            for ($j = $i + 1; $j < $n; $j++) {                // xᵢ = xⱼ and yᵢ = yⱼ -- neither concordant or discordant                if ($xy[$i][self::X] == $xy[$j][self::X] && $xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_xy++;                // xᵢ = xⱼ -- neither concordant or discordant                } elseif ($xy[$i][self::X] == $xy[$j][self::X]) {                    $ties_x++;                // yᵢ = yⱼ -- neither concordant or discordant                } elseif ($xy[$i][self::Y] == $xy[$j][self::Y]) {                    $ties_y++;                // xᵢ < xⱼ and yᵢ < yⱼ -- concordant                } elseif ($xy[$i][self::X] < $xy[$j][self::X] && $xy[$i][self::Y] < $xy[$j][self::Y]) {                    $nc++;                // xᵢ > xⱼ and yᵢ < yⱼ or  xᵢ < xⱼ and yᵢ > yⱼ -- discordant                } else {                    $nd++;                }            }        }        // Numerator: (number of concordant pairs) - (number of discordant pairs)        $⟮nc − nd⟯ = $nc - $nd;        /* tau-a (no rank ties):         *         *        nc - nd         *   τ = ----------         *       n(n - 1)/2         */        if ($ties_x == 0 && $ties_y == 0) {            return $⟮nc − nd⟯ / (($n * ($n - 1)) / 2);        }        /* tau-b (rank ties exist):         *         *                 nc - nd         *   τ = -----------------------------         *       √(nc + nd + X₀)(nc + nd + Y₀)         */        return $⟮nc − nd⟯ / \sqrt(($nc + $nd + $ties_x) * ($nc + $nd + $ties_y));    }    /**     * ρ - Spearman's rank correlation coefficient (Spearman's rho)     *     * https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient     *     *     cov(rgᵪ, rgᵧ)     * ρ = ------------     *        σᵣᵪσᵣᵧ     *     *   Where     *    cov(rgᵪ, rgᵧ): covariance of the rank variables     *    σᵣᵪ and σᵣᵧ:   standard deviations of the rank variables     *     * @param array $X values for random variable X     * @param array $Y values for random variable Y     *     * @return float     *     * @throws Exception\BadDataException if both random variables do not have the same number of elements     * @throws Exception\OutOfBoundsException if one of the random variables is empty     */    public static function spearmansRho(array $X, array $Y): float    {        if (\count($X) !== \count($Y)) {            throw new Exception\BadDataException('Both random variables for spearmansRho must have the same number of elements');        }        $rgᵪ         = Distribution::fractionalRanking($X);        $rgᵧ         = Distribution::fractionalRanking($Y);        $cov⟮rgᵪ、rgᵧ⟯ = Correlation::covariance($rgᵪ, $rgᵧ);        $σᵣᵪ         = Descriptive::sd($rgᵪ);        $σᵣᵧ         = Descriptive::sd($rgᵧ);        return $cov⟮rgᵪ、rgᵧ⟯  / ($σᵣᵪ * $σᵣᵧ);    }    /**     * Descriptive correlation report about two random variables     *     * @param  array $X values for random variable X     * @param  array $Y values for random variable Y     * @param  bool $population Optional flag if all samples of a population are present     *     * @return array [cov, r, R2, tau, rho]     *     * @throws Exception\BadDataException     * @throws Exception\OutOfBoundsException     */    public static function describe(array $X, array $Y, bool $population = false): array    {        return [            'cov' => self::covariance($X, $Y, $population),            'r'   => self::r($X, $Y, $population),            'r2'  => self::r2($X, $Y, $population),            'tau' => self::kendallsTau($X, $Y),            'rho' => self::spearmansRho($X, $Y),        ];    }    /**     * Confidence ellipse (error ellipse)     * Given the data in $X and $Y, create an ellipse     * surrounding the data at $z standard deviations.     *     * The function will return $num_points pairs of X,Y data     * http://stackoverflow.com/questions/3417028/ellipse-around-the-data-in-matlab     *     * @param array $X an array of independent data     * @param array $Y an array of dependent data     * @param float $z the number of standard deviations to encompass     * @param int $num_points the number of points to include around the ellipse. The actual array     *                          will be one larger because the first point and last will be repeated     *                          to ease display.     *     * @return array paired x and y points on an ellipse aligned with the data provided     *     * @throws Exception\BadDataException     * @throws Exception\BadParameterException     * @throws Exception\IncorrectTypeException     * @throws Exception\MatrixException     * @throws Exception\OutOfBoundsException     */    public static function confidenceEllipse(array $X, array $Y, float $z, int $num_points = 11): array    {        $standardNormal = new StandardNormal();        $p  = 2 * $standardNormal->cdf($z) - 1;        $chiSquared = new ChiSquared(2);        $χ² = $chiSquared->inverse($p);        $data_array[] = $X;        $data_array[] = $Y;        $data_matrix  = new NumericMatrix($data_array);        $covariance_matrix = $data_matrix->covarianceMatrix();        // Scale the data by the confidence interval        $cov         = $covariance_matrix->scalarMultiply($χ²);        $eigenvalues = Eigenvalue::closedFormPolynomialRootMethod($cov);        // Sort the eigenvalues from highest to lowest        \rsort($eigenvalues);        $V = Eigenvector::eigenvectors($cov, $eigenvalues);        // Make ia diagonal matrix of the eigenvalues        $D = MatrixFactory::diagonal($eigenvalues);        $D = $D->map('\sqrt');        $transformation_matrix = $V->multiply($D);        $x_bar = Average::mean($X);        $y_bar = Average::mean($Y);        $translation_matrix = new NumericMatrix([[$x_bar],[$y_bar]]);        // We add a row to allow the transformation matrix to also traslate the ellipse to a different location        $transformation_matrix = $transformation_matrix->augment($translation_matrix);        $unit_circle = new NumericMatrix(Trigonometry::unitCircle($num_points));        // We add a column of ones to allow us to translate the ellipse        $unit_circle_with_ones = $unit_circle->augment(MatrixFactory::one($num_points, 1));        // The unit circle is rotated, stretched, and translated to the appropriate ellipse by the translation matrix.        $ellipse = $transformation_matrix->multiply($unit_circle_with_ones->transpose())->transpose();        return $ellipse->getMatrix();    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Correlation_3477,"Population correlation coefficient\\n Pearson product-moment correlation coefficient (PPMCC or PCC or Pearson's r)\\n\\n A normalized measure of the linear correlation between two variables X and Y,\\n giving a value between +1 and −1 inclusive, where 1 is total positive correlation,\\n 0 is no correlation, and −1 is total negative correlation.\\n It is widely used in the sciences as a measure of the degree of linear dependence\\n between two variables.\\n https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\\n\\n The correlation coefficient of two variables in a data sample is their covariance\\n divided by the product of their individual standard deviations.\\n\\n        cov(X,Y)\\n ρxy = ----------\\n         σx σy\\n\\n  conv(X,Y) is the population covariance\\n  σx is the population standard deviation of X\\n  σy is the population standard deviation of Y\\n\\n @param array $X values for random variable X\\n @param array $Y values for random variable Y\\n\\n @return float\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\OutOfBoundsException\\n","Populacioni korelacioni koeficijent. Pirsonov proizvod. Normalizovana mera linearne korelacije između dve promenljive X i Y koja vraća vrednost između 1 i -1 gde je 1 potpuno pozitivna korelacija, 0 predstavlja nedostatak korelacije, a -1 je potpuna negativna korelacija. Koristi se u nauci kao mera linearne zavisnosti između dve promenljive.","    public static function populationCorrelationCoefficient(array $X, array $Y): float    {        $cov⟮X，Y⟯ = self::populationCovariance($X, $Y);        $σx      = Descriptive::standardDeviation($X, true);        $σy      = Descriptive::standardDeviation($Y, true);        return $cov⟮X，Y⟯ / ( $σx * $σy );    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3482, Descriptive statistics\n Summary statistics that quantitatively describe or summarize features of a collection of information.\n https://en.wikipedia.org/wiki/Descriptive_statistics\n,Deskriptivna statistika. Sažetak koji kvantitativno opisuje ili sumira obeležja skupa informacija.,"class Descriptive{    public const POPULATION = true;    public const SAMPLE     = false;    /**     * Range - the difference between the largest and smallest values     * It is the size of the smallest interval which contains all the data.     * It provides an indication of statistical dispersion.     * (https://en.wikipedia.org/wiki/Range_(statistics))     *     * R = max x - min x     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function range(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the range of an empty list of numbers');        }        return \max($numbers) - \min($numbers);    }    /**     * Midrange - the mean of the largest and smallest values     * It is the midpoint of the range; as such, it is a measure of central tendency.     * (https://en.wikipedia.org/wiki/Mid-range)     *     *     max x + min x     * M = -------------     *           2     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function midrange(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the midrange of an empty list of numbers');        }        return Average::mean([\min($numbers), \max($numbers)]);    }    /**     * Variance     *     * Variance measures how far a set of numbers are spread out.     * A variance of zero indicates that all the values are identical.     * Variance is always non-negative: a small variance indicates that the data points     * tend to be very close to the mean (expected value) and hence to each other.     * A high variance indicates that the data points are very spread out around the mean     * and from each other.     * (https://en.wikipedia.org/wiki/Variance)     *     *      ∑⟮xᵢ - μ⟯²     * σ² = ----------     *          ν     *     * Generalized method that allows setting the degrees of freedom.     * For population variance, set d.f. (ν) to n     * For sample variance, set d.f (ν) to n - 1     * Or use populationVariance or sampleVariance convenience methods.     *     * μ is the population mean     * ν is the degrees of freedom, which usually is     *   the number of numbers in the population set or n - 1 for sample set.     *     * @param float[] $numbers     * @param int     $ν degrees of freedom     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function variance(array $numbers, int $ν): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the variance of an empty list of numbers');        }        if ($ν <= 0) {            throw new Exception\OutOfBoundsException('Degrees of freedom must be > 0');        }        $∑⟮xᵢ − μ⟯² = RandomVariable::sumOfSquaresDeviations($numbers);        return $∑⟮xᵢ − μ⟯² / $ν;    }    /**     * Population variance - Use when all possible observations of the system are present.     * If used with a subset of data (sample variance), it will be a biased variance.     *     *      ∑⟮xᵢ - μ⟯²     * σ² = ----------     *          N     *     * μ is the population mean     * N is the number of numbers in the population set     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function populationVariance(array $numbers): float    {        $N = \count($numbers);        return self::variance($numbers, $N);    }    /**     * Unbiased sample variance     * Use when only a subset of all possible observations of the system are present.     *     *      ∑⟮xᵢ - x̄⟯²     * S² = ----------     *        n - 1     *     * x̄ is the sample mean     * n is the number of numbers in the sample set     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function sampleVariance(array $numbers): float    {        if (\count($numbers) == 1) {            return 0;        }        $n = \count($numbers);        return self::variance($numbers, $n - 1);    }    /**     * Weighted sample variance     *     * Biased case     *     *       ∑wᵢ⟮xᵢ - μw⟯²     * σ²w = ----------     *           ∑wᵢ     *     * Unbiased estimator for frequency weights     *     *       ∑wᵢ⟮xᵢ - μw⟯²     * σ²w = ----------     *         ∑wᵢ - 1     *     * μw is the weighted mean     *     * https://en.wikipedia.org/wiki/Weighted_arithmetic_mean#Weighted_sample_variance     *     * @param float[] $numbers     * @param float[] $weights     * @param bool    $biased     *     * @return float     *     * @throws Exception\BadDataException if the number of numbers and weights are not equal     */    public static function weightedSampleVariance(array $numbers, array $weights, bool $biased = false): float    {        if (\count($numbers) === 1) {            return 0;        }        if (\count($numbers) !== \count($weights)) {            throw new Exception\BadDataException('Numbers and weights must have the same number of elements.');        }        $μw           = Average::weightedMean($numbers, $weights);        $∑wᵢ⟮xᵢ − μw⟯² = \array_sum(\array_map(            function ($xᵢ, $wᵢ) use ($μw) {                return $wᵢ * \pow(($xᵢ - $μw), 2);            },            $numbers,            $weights        ));        $∑wᵢ = $biased            ? \array_sum($weights)            : \array_sum($weights) - 1;        return $∑wᵢ⟮xᵢ − μw⟯² / $∑wᵢ;    }    /**     * Standard deviation     * A measure that is used to quantify the amount of variation or dispersion of a set of data values.     * A low standard deviation indicates that the data points tend to be close to the mean     * (also called the expected value) of the set.     * A high standard deviation indicates that the data points are spread out over a wider range of values.     * (https://en.wikipedia.org/wiki/Standard_deviation)     *     * σ   = √⟮σ²⟯ = √⟮variance⟯     * SD+ = √⟮σ²⟯ = √⟮sample variance⟯     *     * @param float[] $numbers     * @param bool    $SD＋ : true returns SD+ (uses population variance);     *                false returns SD (uses sample variance);     *                Default is false (SD (sample variance))     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function standardDeviation(array $numbers, bool $SD＋ = false): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the standard deviation of an empty list of numbers');        }        return $SD＋            ? \sqrt(self::populationVariance($numbers))            : \sqrt(self::sampleVariance($numbers));    }    /**     * sd - Standard deviation - convenience method     *     * @param float[] $numbers     * @param bool    $SD＋ : true returns SD+ (uses population variance);     *                false returns SD (uses sample variance);     *                Default is false (SD (sample variance))     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function sd(array $numbers, bool $SD＋ = false): float    {        return self::standardDeviation($numbers, $SD＋);    }    /**     * MAD - mean absolute deviation     *     * The average of the absolute deviations from a central point.     * It is a summary statistic of statistical dispersion or variability.     * (https://en.wikipedia.org/wiki/Average_absolute_deviation)     *     *       ∑|xᵢ - x̄|     * MAD = ---------     *           N     *     * x̄ is the mean     * N is the number of numbers in the population set     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function meanAbsoluteDeviation(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the mean absolute deviation of an empty list of numbers');        }        $x         = Average::mean($numbers);        $∑│xᵢ − x│ = \array_sum(\array_map(            function ($xᵢ) use ($x) {                return \abs($xᵢ - $x);            },            $numbers        ));        $N = \count($numbers);        return $∑│xᵢ − x│ / $N;    }    /**     * MAD - median absolute deviation     *     * The average of the absolute deviations from a central point.     * It is a summary statistic of statistical dispersion or variability.     * It is a robust measure of the variability of a univariate sample of quantitative data.     * (https://en.wikipedia.org/wiki/Median_absolute_deviation)     *     * MAD = median(|xᵢ - x̄|)     *     * x̄ is the median     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function medianAbsoluteDeviation(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the median absolute deviation of an empty list of numbers');        }        $x = Average::median($numbers);        return Average::median(\array_map(            function ($xᵢ) use ($x) {                return \abs($xᵢ - $x);            },            $numbers        ));    }    /**     * Quartiles     * Three points that divide the data set into four equal groups, each group comprising a quarter of the data.     * https://en.wikipedia.org/wiki/Quartile     *     * There are multiple methods for computing quartiles:     *  - Inclusive     *  - Exclusive     *     * @param float[] $numbers     * @param string  $method What quartile method to use (optional - default: exclusive)     *     * @return float[] (0%, Q1, Q2, Q3, 100%, IQR)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quartiles(array $numbers, string $method = 'exclusive'): array    {        switch (strtolower($method)) {            case 'inclusive':                return self::quartilesInclusive($numbers);            case 'exclusive':                return self::quartilesExclusive($numbers);            default:                return self::quartilesExclusive($numbers);        }    }    /**     * Quartiles - Exclusive method     * Three points that divide the data set into four equal groups, each group comprising a quarter of the data.     * https://en.wikipedia.org/wiki/Quartile     *     * 0% is smallest number     * Q1 (25%) is first quartile (lower quartile, 25th percentile)     * Q2 (50%) is second quartile (median, 50th percentile)     * Q3 (75%) is third quartile (upper quartile, 75th percentile)     * 100% is largest number     * interquartile_range is the difference between the upper and lower quartiles. (IQR = Q₃ - Q₁)     *     * Method used     *  - Use the median to divide the ordered data set into two halves.     *   - If there are an odd number of data points in the original ordered data set, do not include the median     *     (the central value in the ordered list) in either half.     *   - If there are an even number of data points in the original ordered data set,     *     split this data set exactly in half.     *  - The lower quartile value is the median of the lower half of the data.     *    The upper quartile value is the median of the upper half of the data.     *     * This rule is employed by the TI-83 calculator boxplot and ""1-Var Stats"" functions.     * This is the most basic method that is commonly taught in math textbooks.     *     * @param float[] $numbers     *     * @return array (0%, Q1, Q2, Q3, 100%, IQR)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quartilesExclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        if (\count($numbers) === 1) {            $number = \array_pop($numbers);            return [                '0%'   => $number,                'Q1'   => $number,                'Q2'   => $number,                'Q3'   => $number,                '100%' => $number,                'IQR'  => 0,            ];        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }    /**     * Quartiles - Inclusive method (R method)     * Three points that divide the data set into four equal groups, each group comprising a quarter of the data.     * https://en.wikipedia.org/wiki/Quartile     *     * 0% is smallest number     * Q1 (25%) is first quartile (lower quartile, 25th percentile)     * Q2 (50%) is second quartile (median, 50th percentile)     * Q3 (75%) is third quartile (upper quartile, 75th percentile)     * 100% is largest number     * interquartile_range is the difference between the upper and lower quartiles. (IQR = Q₃ - Q₁)     *     * Method used     *  - Use the median to divide the ordered data set into two halves.     *   - If there are an odd number of data points in the original ordered data set,     *     include the median (the central value in the ordered list) in both halves.     *   - If there are an even number of data points in the original ordered data set,     *     split this data set exactly in half.     *  - The lower quartile value is the median of the lower half of the data.     *    The upper quartile value is the median of the upper half of the data.     *     * The values found by this method are also known as ""Tukey's hinges"".     * This is the method that the programming language R uses by default.     *     * @param float[] $numbers     *     * @return array (0%, Q1, Q2, Q3, 100%, IQR)     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function quartilesInclusive(array $numbers): array    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the quartiles of an empty list of numbers');        }        \sort($numbers);        $length = \count($numbers);        if ($length % 2 == 0) {            $lower_half = \array_slice($numbers, 0, $length / 2);            $upper_half = \array_slice($numbers, $length / 2);        } else {            $lower_half = \array_slice($numbers, 0, \intdiv($length, 2));            $upper_half = \array_slice($numbers, \intdiv($length, 2) + 1);            // Add median to both halves            $median = Average::median($numbers);            \array_push($lower_half, $median);            \array_unshift($upper_half, $median);        }        $lower_quartile = Average::median($lower_half);        $upper_quartile = Average::median($upper_half);        return [            '0%'   => \min($numbers),            'Q1'   => $lower_quartile,            'Q2'   => Average::median($numbers),            'Q3'   => $upper_quartile,            '100%' => \max($numbers),            'IQR'  => $upper_quartile - $lower_quartile,        ];    }    /**     * IQR - Interquartile range (midspread, middle fifty)     * A measure of statistical dispersion.     * Difference between the upper and lower quartiles.     * https://en.wikipedia.org/wiki/Interquartile_range     *     * IQR = Q₃ - Q₁     *     * @param float[] $numbers     * @param string  $method What quartile method to use (optional - default: exclusive)     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function interquartileRange(array $numbers, string $method = 'exclusive'): float    {        return self::quartiles($numbers, $method)['IQR'];    }    /**     * IQR - Interquartile range (midspread, middle fifty)     * Convenience wrapper function for interquartileRange.     *     * @param float[] $numbers     * @param string  $method What quartile method to use (optional - default: exclusive)     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function iqr(array $numbers, string $method = 'exclusive'): float    {        return self::quartiles($numbers, $method)['IQR'];    }    /**     * Compute the P-th percentile of a list of numbers     *     * Linear interpolation between closest ranks method - Second variant, C = 1     * P-th percentile (0 <= P <= 100) of a list of N ordered values (sorted from least to greatest)     * Similar method used in NumPy and Excel     * https://en.wikipedia.org/wiki/Percentile#Second_variant.2C_.7F.27.22.60UNIQ--postMath-00000043-QINU.60.22.27.7F     *     *      P     * x - --- (N - 1) + 1     *     100     *     * P = percentile     * N = number of elements in list     *     * ν(x) = νₓ + x％1(νₓ₊₁ - νₓ)     *     * ⌊x⌋  = integer part of x     * x％1 = fraction part of x     * νₓ   = number in position x in sorted list of numbers     * νₓ₊₁ = number in position x + 1 in sorted list of number     *     * @param float[] $numbers     * @param float   $P percentile to calculate     *     * @return float in list corresponding to P percentile     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if $P percentile is not between 0 and 100     */    public static function percentile(array $numbers, float $P): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the P-th percentile of an empty list of numbers');        }        if ($P < 0 || $P > 100) {            throw new Exception\OutOfBoundsException('Percentile P must be between 0 and 100.');        }        $N = \count($numbers);        if ($N === 1) {            return \array_shift($numbers);        }        \sort($numbers);        if ($P == 100) {            return  $numbers[$N - 1];        }        $x    = ($P / 100) * ($N - 1) + 1;        $⌊x⌋  = \intval($x);        $x％1 = $x - $⌊x⌋;        $νₓ   = $numbers[$⌊x⌋ - 1];        $νₓ₊₁ = $numbers[$⌊x⌋];        return $νₓ + $x％1 * ($νₓ₊₁ - $νₓ);    }    /**     * Midhinge     * The average of the first and third quartiles and is thus a measure of location.     * Equivalently, it is the 25% trimmed mid-range or 25% midsummary; it is an L-estimator.     * https://en.wikipedia.org/wiki/Midhinge     *     * Midhinge = (first quartile, third quartile) / 2     *     * @param  float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     */    public static function midhinge(array $numbers): float    {        $quartiles = self::quartiles($numbers);        $Q1        = $quartiles['Q1'];        $Q2        = $quartiles['Q3'];        return Average::mean([$Q1, $Q2]);    }    /**     * Coefficient of variation (cᵥ)     * Also known as relative standard deviation (RSD)     *     * A standardized measure of dispersion of a probability distribution or     * frequency distribution. It is often expressed as a percentage.     * The ratio of the standard deviation to the mean.     * https://en.wikipedia.org/wiki/Coefficient_of_variation     *     *      σ     * cᵥ = -     *      μ     *     * @param float[] $numbers     *     * @return float     *     * @throws Exception\BadDataException if the input array of numbers is empty     * @throws Exception\OutOfBoundsException if degrees of freedom is ≤ 0     */    public static function coefficientOfVariation(array $numbers): float    {        $σ = self::standardDeviation($numbers);        $μ = Average::mean($numbers);        return $σ / $μ;    }    /**     * Get a report of all the descriptive statistics over a list of numbers     * Includes mean, median, mode, range, midrange, variance, standard deviation, quartiles, etc.     *     * @param float[] $numbers     * @param bool    $population : true means all possible observations of the system are present;     *                           false means a sample is used.     *     * @return array [n, mean, median, mode, range, midrange, variance, sd, CV, mean_mad,     *                median_mad, quartiles, skewness, kurtosis, sem, ci_95, ci_99]     *     * @throws Exception\OutOfBoundsException     * @throws Exception\BadDataException     */    public static function describe(array $numbers, bool $population = false): array    {        $n = \count($numbers);        $μ = Average::mean($numbers);        $σ = self::standardDeviation($numbers, $population);        return [            'n'                  => $n,            'min'                => \min($numbers),            'max'                => \max($numbers),            'mean'               => $μ,            'median'             => Average::median($numbers),            'mode'               => Average::mode($numbers),            'range'              => self::range($numbers),            'midrange'           => self::midrange($numbers),            'variance'           => $population ? self::populationVariance($numbers) : self::sampleVariance($numbers),            'sd'                 => $σ,            'cv'                 => $μ ? $σ / $μ : \NAN,            'mean_mad'           => self::meanAbsoluteDeviation($numbers),            'median_mad'         => self::medianAbsoluteDeviation($numbers),            'quartiles'          => self::quartiles($numbers),            'midhinge'           => self::midhinge($numbers),            'skewness'           => $population                ? ($n > 0 ? RandomVariable::populationSkewness($numbers) : null)                : ($n >= 3 ? RandomVariable::skewness($numbers) : null),            'ses'                => $n > 2 ? RandomVariable::ses($n) : null,            'kurtosis'           => $population                ? ($n > 3 ? RandomVariable::populationKurtosis($numbers) : null)                : ($n > 0 ? RandomVariable::sampleKurtosis($numbers) : null),            'sek'                => $n > 3 ? RandomVariable::sek($n) : null,            'sem'                => RandomVariable::standardErrorOfTheMean($numbers),            'ci_95'              => RandomVariable::confidenceInterval($μ, $n, $σ, '95'),            'ci_99'              => RandomVariable::confidenceInterval($μ, $n, $σ, '99'),        ];    }    /**     * Five number summary     * A descriptive statistic that provides information about a set of observations.     * It consists of the five most important sample percentiles:     *  1) the sample minimum (smallest observation)     *  2) the lower quartile or first quartile     *  3) the median (middle value)     *  4) the upper quartile or third quartile     *  5) the sample maximum (largest observation)     *     * https://en.wikipedia.org/wiki/Five-number_summary     *     * @param  array  $numbers     *     * @return array [min, Q1, median, Q3, max]     *     * @throws Exception\BadDataException     */    public static function fiveNumberSummary(array $numbers): array    {        $quartiles = self::quartiles($numbers);        return [            'min'    => \min($numbers),            'Q1'     => $quartiles['Q1'],            'median' => Average::median($numbers),            'Q3'     => $quartiles['Q3'],            'max'    => \max($numbers),        ];    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3484,"Midrange - the mean of the largest and smallest values\n It is the midpoint of the range; as such, it is a measure of central tendency.\n (https://en.wikipedia.org/wiki/Mid-range)\n\n     max x + min x\n M = -------------\n           2\n\n @param float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n",Sredina - pola puta između najveće i najmanje vrednosti. Mera je centralne tendencije.,"    public static function midrange(array $numbers): float    {        if (empty($numbers)) {            throw new Exception\BadDataException('Cannot find the midrange of an empty list of numbers');        }        return Average::mean([\min($numbers), \max($numbers)]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Descriptive_3486,"Population variance - Use when all possible observations of the system are present.\n If used with a subset of data (sample variance), it will be a biased variance.\n\n      ∑⟮xᵢ - μ⟯²\n σ² = ----------\n          N\n\n μ is the population mean\n N is the number of numbers in the population set\n\n @param float[] $numbers\n\n @return float\n\n @throws Exception\\BadDataException if the input array of numbers is empty\n @throws Exception\\OutOfBoundsException if degrees of freedom is ≤ 0\n",Varijansa populacije - Koristi se kada su sva merenja dostupna. Ako se koristi na podskupu podataka može biti pristrasna varijansa. ,"    public static function populationVariance(array $numbers): float    {        $N = \count($numbers);        return self::variance($numbers, $N);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Distance_3502," Manhattan distance (Taxicab geometry)\n\n https://en.wikipedia.org/wiki/Taxicab_geometry\n\n The taxicab metric is also known as rectilinear distance, L₁ distance, L¹ distance , snake distance, city block\n distance, Manhattan distance or Manhattan length, with corresponding variations in the name of the geometry.\n\n Σ|xᵢ - yᵢ|\n\n @param float[] $xs input array\n @param float[] $ys input array\n\n @return float\n\n @throws Exception\\BadDataException if p and q do not have the same number of elements\n",Manhattan udaljenost (udaljenost na mreži) odnosno gradskih blokova. Ima i druge nazive.,"public static function manhattan(array $xs, array $ys): float    {        return self::minkowski($xs, $ys, 1);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Divergence_3516,"Kullback-Leibler divergence\\n (also known as: discrimination information, information divergence, information gain, relative entropy, KLIC, KL divergence)\\n A measure of the difference between two probability distributions P and Q.\\n https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\\n\\n                       P(i)\\n Dkl(P‖Q) = ∑ P(i) log ----\\n            ⁱ\\u2009         Q(i)\\n\\n\\n\\n @param  array  $p distribution p\\n @param  array  $q distribution q\\n\\n @return float difference between distributions\\n\\n @throws Exception\\\\BadDataException if p and q do not have the same number of elements\\n @throws Exception\\\\BadDataException if p and q are not probability distributions that add up to 1\\n","Kulbak-Leiblerova divergencija, odnosno relativna entropija je mera razlike između dve raspodele verovatnoća.","public static function kullbackLeibler(array $p, array $q): float    {        // Arrays must have the same number of elements        if (\count($p) !== \count($q)) {            throw new Exception\BadDataException('p and q must have the same number of elements');        }        // Probability distributions must add up to 1.0        if ((\abs(\array_sum($p) - 1) > self::ONE_TOLERANCE) || (\abs(\array_sum($q) - 1) > self::ONE_TOLERANCE)) {            throw new Exception\BadDataException('Distributions p and q must add up to 1');        }        // Defensive measures against taking the log of 0 which would be -∞ or dividing by 0        $p = \array_map(            function ($pᵢ) {                return $pᵢ == 0 ? 1e-15 : $pᵢ;            },            $p        );        $q = \array_map(            function ($qᵢ) {                return $qᵢ == 0 ? 1e-15 : $qᵢ;            },            $q        );        // ∑ P(i) log(P(i)/Q(i))        $Dkl⟮P‖Q⟯ = \array_sum(\array_map(            function ($P, $Q) {                return $P * \log($P / $Q);            },            $p,            $q        ));        return $Dkl⟮P‖Q⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Eigenvector_2616," Count the number of rows that contain all zeroes, starting at the bottom.\n In reduced row echelon form, all the rows of zero will be on the bottom.\n\n @param NumericMatrix $M\n\n @return int\n","Broj redova koji sadrže sve nule, počevši od dna.","private static function countSolutions(NumericMatrix $M): int    {        $number_of_solutions = 0;        // There are solutions to be found.        $more_solutions = true;        $m = $M->getM();        // We will count the number of rows with all zeros, starting at the bottom.        for ($i = $m - 1; $i >= 0 && $more_solutions; $i--) {            // Every row of zeros is a degree of freedom (a solution) with that eigenvalue            if ($M->getRow($i) == \array_fill(0, $m, 0)) {                $number_of_solutions++;            } else {                 // Once we find a row with nonzero values, there are no more.                 $more_solutions = false;            }        }        return $number_of_solutions;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Geometric_3229, Geometric distribution\\n\\n https://en.wikipedia.org/wiki/Geometric_distribution\\n,Geometrijska raspodela,"class Geometric extends Discrete{    /**     * Distribution parameter bounds limits     * p ∈ (0,1]     * @var array     */    public const PARAMETER_LIMITS = [        'p' => '(0,1]',    ];    /**     * Distribution parameter bounds limits     * k ∈ [1,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'k' => '[1,∞)',    ];    /** @var float success probability  0 < p ≤ 1 */    protected $p;    /**     * Constructor     *     * @param float $p success probability  0 < p ≤ 1     */    public function __construct(float $p)    {        parent::__construct($p);    }    /**     * Probability mass function     *     * The probability distribution of the number Y = X − 1 of failures     * before the first success, supported on the set { 0, 1, 2, 3, ... }     *     * k failures where k ∈ {0, 1, 2, 3, ...}     *     * pmf = (1 - p)ᵏp     *     * @param  int   $k number of trials     k ≥ 1     *     * @return float     */    public function pmf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ = \pow(1 - $p, $k);        return $⟮1 − p⟯ᵏ * $p;    }    /**     * Cumulative distribution function (lower cumulative)     *     * The probability distribution of the number Y = X − 1 of failures     * before the first success, supported on the set { 0, 1, 2, 3, ... }     *     * k failures where k ∈ {0, 1, 2, 3, ...}     *     * pmf = 1 - (1 - p)ᵏ⁺¹     *     * @param  int   $k number of trials     k ≥ 0     *     * @return float     */    public function cdf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ⁺¹ = \pow(1 - $p, $k + 1);        return 1 - $⟮1 − p⟯ᵏ⁺¹;    }    /**     * Mean of the distribution     *     *     1 - p     * μ = -----     *       p     *     * @return float     */    public function mean(): float    {        return (1 - $this->p) / $this->p;    }    /**     * Median of the distribution     *     *           _           _     *          |     -1      |     * median = | ----------- | - 1     *          | log₂(1 - p) |     *     * @return float     */    public function median(): float    {        $log₂⟮1 − p⟯ = \log(1 - $this->p, 2);        return \ceil(-1 / $log₂⟮1 − p⟯) - 1;    }    /**     * Mode of the distribution     *     * mode = 0     *     * @return int     */    public function mode(): int    {        return 0;    }    /**     * Variance of the distribution     *     *      1 - p     * σ² = -----     *        p²     *     * @return float     */    public function variance(): float    {        return (1 - $this->p) / $this->p ** 2;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Geometric_3232,"Cumulative distribution function (lower cumulative)\\n\\n The probability distribution of the number Y = X − 1 of failures\\n before the first success, supported on the set { 0, 1, 2, 3, ... }\\n\\n k failures where k ∈ {0, 1, 2, 3, ...}\\n\\n pmf = 1 - (1 - p)ᵏ⁺¹\\n\\n @param  int   $k number of trials     k ≥ 0\\n\\n @return float\\n",Kumulativna raspodela,"public function cdf(int $k): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['k' => $k]);        $p = $this->p;        $⟮1 − p⟯ᵏ⁺¹ = \pow(1 - $p, $k + 1);        return 1 - $⟮1 − p⟯ᵏ⁺¹;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_HanesWoolf_3571, Calculate the regression parameters by least squares on linearized data\\n x / y = x / V + K / V\\n\\n @throws Exception\\\\BadDataException\\n @throws Exception\\\\MatrixException\\n @throws Exception\\\\MathException\\n,Izračunaj regresione parametre metodom najmanjih kvadrata na linearizovanim podacima.,"public function calculate(): void    {        // Linearize the relationship by dividing x by y        $y’ = Multi::divide($this->xs, $this->ys);        // Perform Least Squares Fit        $linear_parameters = $this->leastSquares($y’, $this->xs)->getColumn(0);        $V = 1 / $linear_parameters[1];        $K = $linear_parameters[0] * $V;        $this->parameters = [$V, $K];    }",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Integer_2965," Detect if an integer is a perfect number.\\n A perfect number is a positive integer that is equal to the sum of its proper positive divisors,\\n that is, the sum of its positive divisors excluding the number itself\\n\\n @see    https://en.wikipedia.org/wiki/Perfect_number\\n\\n @param  int $n\\n\\n @return bool\\n",Proverava da li je ceo broj savršen broj. Savršen broj je pozitivan ceo broj koji je jednak sumi svojih pozitivnih delilaca.,public static function isPerfectNumber(int $n): bool    {        if ($n <= 1) {            return false;        }        return $n === self::aliquotSum($n);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Integer_2978,"Prime factorization\n The prime factors of an integer.\n https://en.wikipedia.org/wiki/Prime_factor\n\n Algorithm\n  1) Let n be the ongoing remainder\n  2) Try prime factoring n with 2 and 3\n  3) Try prime factoring n with increasing ℕ of the form 6𝑘±1 up through √n (all other ℕ are divisible by 2 and/or 3)\n  4) If n is still > 1, the remainder is a prime factor\n\n @param  int $n\n\n @return int[] of prime factors\n\n @throws Exception\\OutOfBoundsException if n is < 1.\n",Faktorizacija na proste činioce. ,"public static function primeFactorization(int $n): array    {        if ($n < 1) {            throw new Exception\OutOfBoundsException(""n must be ≥ 1. ($n provided)"");        }        $remainder = $n;        $factors   = [];        foreach ([2, 3] as $divisor) {            while ($remainder % $divisor === 0) {                $factors[] = $divisor;                $remainder = \intdiv($remainder, $divisor);            }        }        $divisor = 5;        $√n = \sqrt($remainder);        while ($divisor <= $√n) {            while ($remainder % $divisor === 0) {                $factors[] = $divisor;                $remainder = \intdiv($remainder, $divisor);                $√n        = \sqrt($remainder);            }            $divisor += 2;            while ($remainder % $divisor === 0) {                $factors[] = $divisor;                $remainder = \intdiv($remainder, $divisor);                $√n        = \sqrt($remainder);            }            $divisor += 4;        }        if ($remainder > 1) {            $factors[] = $remainder;        }        return $factors;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Integer_2982, Odd number\\n\\n @param  int $x\\n\\n @return bool true if x is odd; false otherwise\\n,Neparan broj. Proverava da li je broj neparan.,public static function isOdd(int $x): bool    {        return (\abs($x) % 2) === 1;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Interpolation_2989, Sorts our coordinates (arrays) by their x-component (first number) such\n that consecutive coordinates have an increasing x-component.\n\n @param  array $points\n\n @return array[]\n,Sortira koordinate prema njihovoj x komponenti u rastućem poretku.,"    protected static function sort(array $points): array    {        \usort($points, function (array $a, array $b) {            return $a[self::X] <=> $b[self::X];        });        return $points;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2648, Interchange two rows\\n\\n Row mᵢ changes to position mⱼ\\n Row mⱼ changes to position mᵢ\\n\\n @param int $mᵢ Row to swap into row position mⱼ\\n @param int $mⱼ Row to swap into row position mᵢ\\n\\n @return Matrix with rows mᵢ and mⱼ interchanged\\n\\n @throws Exception\\\\MatrixException if row to interchange does not exist\\n @throws Exception\\\\IncorrectTypeException\\n,Zameni mesta dvaju redova u matrici. Red mj menja poziciju na mi i obrnuto.,"public function rowInterchange(int $mᵢ, int $mⱼ): Matrix    {        if ($mᵢ >= $this->m || $mⱼ >= $this->m) {            throw new Exception\MatrixException('Row to interchange does not exist');        }        $m = $this->m;        $R = [];        for ($i = 0; $i < $m; $i++) {            switch ($i) {                case $mᵢ:                    $R[$i] = $this->A[$mⱼ];                    break;                case $mⱼ:                    $R[$i] = $this->A[$mᵢ];                    break;                default:                    $R[$i] = $this->A[$i];            }        }        return MatrixFactory::create($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Matrix_2650, Interchange two columns\n\n Column nᵢ changes to position nⱼ\n Column nⱼ changes to position nᵢ\n\n @param int $nᵢ Column to swap into column position nⱼ\n @param int $nⱼ Column to swap into column position nᵢ\n\n @return Matrix with columns nᵢ and nⱼ interchanged\n\n @throws Exception\\MatrixException if column to interchange does not exist\n @throws Exception\\IncorrectTypeException\n,Zameni mesta dvema kolonama. Kolona nj Menja pozociju na ni i obrnuto.,"public function columnInterchange(int $nᵢ, int $nⱼ): Matrix    {        if ($nᵢ >= $this->n || $nⱼ >= $this->n) {            throw new Exception\MatrixException('Column to interchange does not exist');        }        $m = $this->m;        $n = $this->n;        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                switch ($j) {                    case $nᵢ:                        $R[$i][$j] = $this->A[$i][$nⱼ];                        break;                    case $nⱼ:                        $R[$i][$j] = $this->A[$i][$nᵢ];                        break;                    default:                        $R[$i][$j] = $this->A[$i][$j];                }            }        }        return MatrixFactory::create($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NegativeBinomial_3244, Negative binomial distribution (Pascal distribution)\\n https://en.wikipedia.org/wiki/Negative_binomial_distribution\\n,Negativna binomijalna raspodela (Paskalova raspodela),"class NegativeBinomial extends Discrete{    /**     * Distribution parameter bounds limits     * r ∈ [0,∞)     * p ∈ [0,1]     * @var array     */    public const PARAMETER_LIMITS = [        'r' => '[0,∞)',        'p' => '[0,1]',    ];    /**     * Distribution support bounds limits     * x ∈ [0,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '[0,∞)',    ];    /** @var int number of successful events */    protected $r;    /** @var float probability of success on an individual trial */    protected $p;    /**     * Constructor     *     * @param  int   $r number of failures until the experiment is stopped     * @param  float $p probability of success on an individual trial     */    public function __construct(int $r, float $p)    {        parent::__construct($r, $p);    }    /**     * Probability mass function     *     *               / x + r - 1 \     * b(k; r, p) = |             | (1 - p)ˣ pʳ     *               \     x     /     *     *     *            = ₓ₊ᵣ₋₁Cₓ (1 - p)ˣ pʳ     *     * @param  int $x number of successes     *     * @return float     *     * @throws MathException     */    public function pmf(int $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $r = $this->r;        $p = $this->p;        $ₓ₊ᵣ₋₁Cₓ = Combinatorics::combinations($x + $r - 1, $x);        $⟮1 − p⟯ˣ = \pow(1 - $p, $x);        $pʳ      = \pow($p, $r);        return $ₓ₊ᵣ₋₁Cₓ * $⟮1 − p⟯ˣ * $pʳ;    }    /**     * Cumulative distribution function (lower cumulative distribution)     *     *               ₓ     * P(x; r, p) =  Σ pmf(k, r, p)     *              ᵏ⁼⁰     *     * @param int $x number of successes     *     * @return float     *     * @throws MathException     */    public function cdf(int $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        return \array_sum(            \array_map(                [$this, 'pmf'],                \range(0, $x)            )        );    }    /**     * Mean of the distribution     *     *       pr     * μ = -----     *     1 - p     *     * @return float     */    public function mean(): float    {        return ($this->p * $this->r) / (1 - $this->p);    }    /**     * Mode of the distribution     *     *        | p(r - 1) |     * mode = | -------- |  for r > 1     *        |_  1 - p _|     *     * mode = 0             for r ≤ 1     *     * @return float     */    public function mode(): float    {        if ($this->r <= 1) {            return 0;        }        $r = $this->r;        $p = $this->p;        return \floor(($p * ($r - 1)) / (1 - $p));    }    /**     * Variance of the distribution     *     *         pr     * σ² = --------     *      (1 - p)²     *     * @return float     */    public function variance(): float    {        return ($this->p * $this->r) / (1 - $this->p) ** 2;    }}",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NegativeBinomial_3246,"Probability mass function\\n\\n               / x + r - 1 \\\\\\n b(k; r, p) = |             | (1 - p)ˣ pʳ\\n               \\\\     x     /\\n\\n\\n            = ₓ₊ᵣ₋₁Cₓ (1 - p)ˣ pʳ\\n\\n @param  int $x number of successes\\n\\n @return float\\n\\n @throws MathException\\n",Funkcija gustine verovatnoće,"public function pmf(int $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $r = $this->r;        $p = $this->p;        $ₓ₊ᵣ₋₁Cₓ = Combinatorics::combinations($x + $r - 1, $x);        $⟮1 − p⟯ˣ = \pow(1 - $p, $x);        $pʳ      = \pow($p, $r);        return $ₓ₊ᵣ₋₁Cₓ * $⟮1 − p⟯ˣ * $pʳ;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NegativeBinomial_3250,Variance of the distribution\\n\\n         pr\\n σ² = --------\\n      (1 - p)²\\n\\n @return float\\n,Varijansa raspodele.,public function variance(): float    {        return ($this->p * $this->r) / (1 - $this->p) ** 2;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NewtonsMethod_3040," Newton's Method (also known as the Newton–Raphson method)\\n\\n In numerical analysis, Newton's method is a method for finding successively better\\n approximations to the roots (or zeroes) of a real-valued function.\\n","Njutnov metod, takođe poznat kao Njutn-Rapsonov metod. U numeričkoj analizi, Njutnov metod je metod za nalaženje iterativno boljih aproksimacija korena funkcije.","class NewtonsMethod{    /**     * Use Newton's Method to find the x which produces $target = $function(x) value     * $args is an array of parameters to pass to $function, but having the element that     * will be changed and serve as the initial guess in position $position.     *     * @param callable $function     f(x) callback function     * @param array    $args         Parameters to pass to callback function. The initial value for the     *                               parameter of interest must be in this array.     * @param number   $target       Value of f(x) we a trying to solve for     * @param float    $tol          Tolerance; How close to the actual solution we would like.     * @param int      $position     Which element in the $args array will be changed; also serves as initial guess     * @param int      $iterations     *     * @return number     *     * @throws Exception\OutOfBoundsException if the tolerance is not valid     */    public static function solve(callable $function, array $args, $target, float $tol, int $position = 0, int $iterations = 100)    {        Validation::tolerance($tol);        // Initialize        $args1 = $args;        $guess = $args[$position];        $i     = 0;        do {            $args1[$position] = $guess + $tol; // load the initial guess into the arguments            $args[$position]  = $guess;        // load the initial guess into the arguments            $y                = $function(...$args);            $y_at_xplusdelx   = $function(...$args1);            $slope            = ($y_at_xplusdelx - $y) / $tol;            $del_y            = $target - $y;            if (\abs($slope) < $tol) {                return \NAN;            }            $guess            = $del_y / $slope + $guess;            $dif              = \abs($del_y);            $i++;        } while ($dif > $tol && $i < $iterations);        if ($dif > $tol) {            return \NAN;        }        return $guess;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3164, Normal distribution\n https://en.wikipedia.org/wiki/Normal_distribution\n,Normalna raspodela.,"class Normal extends Continuous{    /**     * Distribution parameter bounds limits     * μ ∈ (-∞,∞)     * σ ∈ (0,∞)     * @var array     */    public const PARAMETER_LIMITS = [        'μ' => '(-∞,∞)',        'σ' => '(0,∞)',    ];    /**     * Distribution support bounds limits     * x ∈ (-∞,∞)     * @var array     */    public const SUPPORT_LIMITS = [        'x' => '(-∞,∞)',    ];    /** @var float Mean Parameter */    protected $μ;    /** @var float Standard Deviation Parameter */    protected $σ;    /**     * Normal constructor     *     * @param float $μ     * @param float $σ     */    public function __construct(float $μ, float $σ)    {        parent::__construct($μ, $σ);    }    /**     * Probability density function     *     *              1     * f(x|μ,σ) = ----- ℯ^−⟮x − μ⟯²∕2σ²     *            σ√⟮2π⟯     *     * @param float $x random variable     *     * @return float f(x|μ,σ)     */    public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ     = $this->μ;        $σ     = $this->σ;        $π     = \M_PI;        $σ√⟮2π⟯ = $σ * \sqrt(2 * $π);        $⟮x − μ⟯²∕2σ² = \pow(($x - $μ), 2) / (2 * $σ ** 2);        $ℯ＾−⟮x − μ⟯²∕2σ² = \exp(-$⟮x − μ⟯²∕2σ²);        return ( 1 / $σ√⟮2π⟯ ) * $ℯ＾−⟮x − μ⟯²∕2σ²;    }    /**     * Cumulative distribution function     * Probability of being below X.     * Area under the normal distribution from -∞ to X.     *             _                  _     *          1 |         / x - μ \  |     * cdf(x) = - | 1 + erf|  ----- |  |     *          2 |_        \  σ√2  / _|     *     * @param float $x upper bound     *     * @return float cdf(x) below     */    public function cdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ = $this->μ;        $σ = $this->σ;        return 1 / 2 * ( 1 + Special::erf(($x - $μ) / ($σ * \sqrt(2))) );    }    /**     * Inverse CDF (quantile)     *     * @param float $p     *     * @return float     */    public function inverse(float $p): float    {        if ($p == 0) {            return -\INF;        }        if ($p == 1) {            return \INF;        }        return parent::inverse($p);    }    /**     * Mean of the distribution     *     * μ = μ     *     * @return float     */    public function mean(): float    {        return $this->μ;    }    /**     * Median of the distribution     *     * median = μ     *     * @return float     */    public function median(): float    {        return $this->μ;    }    /**     * Mode of the distribution     *     * mode = μ     *     * @return float     */    public function mode(): float    {        return $this->μ;    }    /**     * Variance of the distribution     *     * var[X] = σ²     *     * @return float     */    public function variance(): float    {        return $this->σ ** 2;    }    /**     * Random number - Box–Muller transform     *     * https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform     */    public function rand()    {        $rand1 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        $rand2 = \random_int(0, \PHP_INT_MAX) / \PHP_INT_MAX;        return \sqrt(-2 * \log($rand1)) * \cos(2 * pi() * $rand2) * $this->σ + $this->μ;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Normal_3166,"Probability density function\\n\\n              1\\n f(x|μ,σ) = ----- ℯ^−⟮x − μ⟯²∕2σ²\\n            σ√⟮2π⟯\\n\\n @param float $x random variable\\n\\n @return float f(x|μ,σ)\\n",Funkcija gustine verovatnoće-,"public function pdf(float $x): float    {        Support::checkLimits(self::SUPPORT_LIMITS, ['x' => $x]);        $μ     = $this->μ;        $σ     = $this->σ;        $π     = \M_PI;        $σ√⟮2π⟯ = $σ * \sqrt(2 * $π);        $⟮x − μ⟯²∕2σ² = \pow(($x - $μ), 2) / (2 * $σ ** 2);        $ℯ＾−⟮x − μ⟯²∕2σ² = \exp(-$⟮x − μ⟯²∕2σ²);        return ( 1 / $σ√⟮2π⟯ ) * $ℯ＾−⟮x − μ⟯²∕2σ²;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericDiagonalMatrix_2704, Diagonal matrix\n Elements along the main diagonal are the only non-zero elements (may also be zero).\n The off-diagonal elements are all zero\n,"Dijagonalna matrica. Elementi duž glavne dijagonale su jedini nenulti elementi, mada mogu imati nulte vrednosti. Svi elementi van glavne dijagonale su nule.","class NumericDiagonalMatrix extends NumericSquareMatrix{    /**     * Constructor     *     * @param array $A     */    public function __construct(array $A)    {        parent::__construct($A);        if (!parent::isLowerTriangular() || !parent::isUpperTriangular()) {            throw new MatrixException('Trying to construct DiagonalMatrix with non-diagonal elements: ' . \print_r($this->A, true));        }    }    /**     * Diagonal matrix must be symmetric     * @inheritDoc     */    public function isSymmetric(): bool    {        return true;    }    /**     * Diagonal matrix must be lower triangular     * @inheritDoc     */    public function isLowerTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be upper triangular     * @inheritDoc     */    public function isUpperTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be triangular     * @inheritDoc     */    public function isTriangular(): bool    {        return true;    }    /**     * Diagonal matrix must be diagonal     * @inheritDoc     */    public function isDiagonal(): bool    {        return true;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2714, Get the type of objects that are stored in the matrix\n\n @return string The class of the objects\n,Vrati tip objekata koji su skladišteni u matrici.,    public function getObjectType(): string    {        return 'number';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2717, Is this matrix equal to some other matrix?\\n\\n @param NumericMatrix $B\\n\\n @return bool\\n,Da li je matrica jednaka nekoj drugoj matrici?,"public function isEqual(NumericMatrix $B): bool    {        if (!$this->isEqualSizeAndType($B)) {            return false;        }        $m = $this->m;        $n = $this->n;        $ε = $this->ε;        // All elements are the same        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                if (Support::isNotEqual($this->A[$i][$j], $B[$i][$j], $ε)) {                    return false;                }            }        }        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2750, Direct sum of two matrices: A ⊕ B\n The direct sum of any pair of matrices A of size m × n and B of size p × q\n is a matrix of size (m + p) × (n + q)\n https://en.wikipedia.org/wiki/Matrix_addition#Direct_sum\n\n @param  NumericMatrix $B Matrix to add to this matrix\n\n @return NumericMatrix\n\n @throws Exception\\IncorrectTypeException\n,"Direktna suma dve matrice. Direktna suma bilo koja dva para matrica A, veličine mxn i B, veličine pxq je matrica veličine (m+p)x(n+q).","public function directSum(NumericMatrix $B): NumericMatrix    {        $m = $this->m + $B->getM();        $n = $this->n + $B->getN();        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = 0;            }        }        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j];            }        }        $m = $B->getM();        $n = $B->getN();        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i + $this->m][$j + $this->n] = $B[$i][$j];            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2752, Subtract two matrices - Entrywise subtraction\n Adds each element of one matrix to the same element in the other matrix.\n Returns a new matrix.\n https://en.wikipedia.org/wiki/Matrix_addition#Entrywise_sum\n\n @param NumericMatrix $B Matrix to subtract from this matrix\n\n @return NumericMatrix\n\n @throws Exception\\MatrixException if matrices have a different number of rows or columns\n @throws Exception\\IncorrectTypeException\n,Razlika dve matrice. Oduzima svaki element jedne matrice odgovarajućem elementu druge matrice. Vraća novu matricu.,"public function subtract($B): NumericMatrix    {        if ($B->getM() !== $this->m) {            throw new Exception\MatrixException('Matrices have different number of rows');        }        if ($B->getN() !== $this->n) {            throw new Exception\MatrixException('Matrices have different number of columns');        }        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] - $B[$i][$j];            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2754, Scalar matrix multiplication\\n https://en.wikipedia.org/wiki/Matrix_multiplication#Scalar_multiplication\\n\\n @param  float $λ\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\BadParameterException if λ is not a number\\n @throws Exception\\\\IncorrectTypeException\\n,Skalarno množenje matrica.,"public function scalarMultiply(float $λ): NumericMatrix    {        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] * $λ;            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2756,Scalar matrix division\\n\\n @param  float $λ\\n\\n @return NumericMatrix\\n\\n @throws Exception\\\\BadParameterException if λ is not a number\\n @throws Exception\\\\BadParameterException if λ is 0\\n @throws Exception\\\\IncorrectTypeException\\n,Skalarno deljenje matrica,"public function scalarDivide(float $λ): NumericMatrix    {        if ($λ == 0) {            throw new Exception\BadParameterException('Parameter λ cannot equal 0');        }        $R = [];        for ($i = 0; $i < $this->m; $i++) {            for ($j = 0; $j < $this->n; $j++) {                $R[$i][$j] = $this->A[$i][$j] / $λ;            }        }        return MatrixFactory::createNumeric($R, $this->ε);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_NumericMatrix_2771," Sums of each column, returned as a Vector\n\n @return Vector\n","Suma svih kolona, u obliku vektora.","public function columnSums(): Vector    {        $sums = [];        for ($i = 0; $i < $this->n; $i++) {            $sums[] = \array_sum(\array_column($this->A, $i));        }        return new Vector($sums);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_PCA_3564, Principal component analysis\\n\\n PCA uses the correlation between data vectors to find a transformation that minimizes variability.\\n\\n https://en.wikipedia.org/wiki/Principal_component_analysis\\n,Analiza osnovnih komponenti. PCA koristi korelaciju između vektora da nađe transformaciju koja minimizuje varijabilnost.,"class PCA{    /** @var NumericMatrix Dataset */    private $data;    /** @var Vector Means */    private $center;    /** @var Vector Scale */    private $scale;    /** @var Vector $EVal Eigenvalues of the correlation Matrix - Also the Loading Matrix for the PCA */    private $EVal = null;    /** @var NumericMatrix $EVec Eigenvectors of the correlation matrix */    private $EVec = null;    /**     * Constructor     *     * @param NumericMatrix $M      each row is a sample, each column is a variable     * @param bool          $center - Sets if the columns are to be centered to μ = 0     * @param bool          $scale  - Sets if the columns are to be scaled to σ  = 1     *     * @throws Exception\BadDataException if any rows have a different column count     * @throws Exception\MathException     */    public function __construct(NumericMatrix $M, bool $center = true, bool $scale = true)    {        // Check that there is enough data: at least two columns and rows        if (!($M->getM() > 1) || !($M->getN() > 1)) {            throw new Exception\BadDataException('Data matrix must be at least 2x2.');        }        $this->center = $center === true            ? $this->center = $M->columnMeans()            : $this->center = new Vector(\array_fill(0, $M->getN(), 0));        if ($scale === true) {            $scaleArray = [];            for ($i = 0; $i < $M->getN(); $i++) {                $scaleArray[] = Descriptive::standardDeviation($M->getColumn($i));            }            $this->scale = new Vector($scaleArray);        } else {            $this->scale = new Vector(\array_fill(0, $M->getN(), 1));        }        // Save the source data to the class        $this->data = $M;        // Center and scale the data as needed        $this->data = $this->standardizeData();        // Create the correlation / variance-covarience Matrix        $samples       = $M->getM();        $corrCovMatrix = $this->data->transpose()->multiply($this->data)->scalarDivide($samples - 1);        // Eigenvalues and vectors        $this->EVal = new Vector($corrCovMatrix->eigenvalues(Eigenvalue::JACOBI_METHOD));        $this->EVec = $corrCovMatrix->eigenvectors(Eigenvalue::JACOBI_METHOD);    }    /**     * Verify that the matrix has the same number of columns as the original data     *     * @param NumericMatrix $newData     *     * @throws Exception\BadDataException if the matrix is not square     */    private function checkNewData(NumericMatrix $newData): void    {        if ($newData->getN() !== $this->data->getN()) {            throw new Exception\BadDataException('Data does not have the same number of columns');        }    }    /**     * Standardize the data     * Use the object $center and $scale Vectors to transform the provided data     *     * @param NumericMatrix $new_data - An optional Matrix of new data which is standardized against the original data     *     * @return NumericMatrix     *     * @throws Exception\MathException     */    public function standardizeData(NumericMatrix $new_data = null): NumericMatrix    {        if ($new_data === null) {            $X = $this->data;        } else {            $this->checkNewData($new_data);            $X = $new_data;        }        $ones_column = MatrixFactory::one($X->getM(), 1);        // Create a matrix the same dimensions as $new_data, each element is the average of that column in the original data.        $center_matrix = $ones_column->multiply(MatrixFactory::create([$this->center->getVector()]));        $scale_matrix  = MatrixFactory::diagonal($this->scale->getVector())->inverse();        // scaled data: ($X - μ) / σ        return $X->subtract($center_matrix)->multiply($scale_matrix);    }    /**     * The loadings are the unit eigenvectors of the correlation matrix     *     * @return NumericMatrix     */    public function getLoadings(): NumericMatrix    {        return $this->EVec;    }    /**     * The eigenvalues of the correlation matrix     *     * @return Vector     *     * @throws Exception\MathException     */    public function getEigenvalues(): Vector    {        $EV = [];        for ($i = 0; $i < $this->data->getN(); $i++) {            $EV[] = Descriptive::standardDeviation($this->getScores()->getColumn($i)) ** 2;        }        return new Vector($EV);    }    /**     * Get Scores     *     * Transform the standardized data with the loadings matrix     *     * @param NumericMatrix|null $new_data     *     * @return NumericMatrix     *     * @throws Exception\MathException     */    public function getScores(NumericMatrix $new_data = null): NumericMatrix    {        if ($new_data === null) {            $scaled_data = $this->data;        } else {            $this->checkNewData($new_data);            $scaled_data = $this->standardizeData($new_data);        }        return $scaled_data->multiply($this->EVec);    }    /**     * Get R² Values     *     * R² for each component is eigenvalue divided by the sum of all eigenvalues     *     * @return float[]     */    public function getR2(): array    {        $total_variance = $this->EVal->sum();        return $this->EVal->scalarDivide($total_variance)->getVector();    }    /**     * Get the cumulative R²     *     * @return float[]     */    public function getCumR2(): array    {        $result = [];        $sum    = 0;        foreach ($this->getR2() as $R²value) {            $sum += $R²value;            $result[] = $sum;        }        return $result;    }    /**     * Get the Q Residuals     *     * The Q residual is the error in the model at a given model complexity.     * For each row (i) in the data Matrix x, and retained components (j):     * Qᵢ = eᵢ'eᵢ = xᵢ(I-PⱼPⱼ')xᵢ'     *     * @param NumericMatrix $new_data - An optional Matrix of new data which is standardized against the original data     *     * @return NumericMatrix of Q residuals     *     * @throws Exception\MathException     */    public function getQResiduals(NumericMatrix $new_data = null): NumericMatrix    {        $vars = $this->data->getN();        if ($new_data === null) {            $X = $this->data;        } else {            $this->checkNewData($new_data);            $X = $this->standardizeData($new_data);        }        $X′ = $X->transpose();        $I  = MatrixFactory::identity($vars);        // Initial element with initialization of result matrix        $P  = $this->EVec->submatrix(0, 0, $vars - 1, 0);  // Get the first column of the loading matrix        $P′ = $P->transpose();        $Q  = MatrixFactory::create([$X->multiply($I->subtract($P->multiply($P′)))->multiply($X′)->getDiagonalElements()])->transpose();        for ($i = 1; $i < $vars; $i++) {            // Get the first $i+1 columns of the loading matrix            $P  = $this->EVec->submatrix(0, 0, $vars - 1, $i);            $P′ = $P->transpose();            $Qᵢ = MatrixFactory::create([$X->multiply($I->subtract($P->multiply($P′)))->multiply($X′)->getDiagonalElements()])->transpose();            $Q  = $Q->augment($Qᵢ);        }        return $Q;    }    /**     * Get the T² Distance     *     * Get the distance from the score to the center of the model plane.     * For each row (i) in the data matrix, and retained componenets (j)     * Tᵢ² = XᵢPⱼΛⱼ⁻¹Pⱼ'Xᵢ'     *     * @param NumericMatrix $new_data - An optional Matrix of new data which is standardized against the original data     *     * @return NumericMatrix     *     * @throws Exception\MathException     */    public function getT2Distances(NumericMatrix $new_data = null): NumericMatrix    {        $vars = $this->data->getN();        if ($new_data === null) {            $X = $this->data;        } else {            $this->checkNewData($new_data);            $X = $this->standardizeData($new_data);        }        $X′ = $X->transpose();        // Initial element with initialization of result matrix        $P    = $this->EVec->submatrix(0, 0, $vars - 1, 0); // // Get the first column of the loading matrix        $P′   = $P->transpose();        $Λⱼ⁻¹ = MatrixFactory::diagonal(\array_slice($this->EVal->getVector(), 0, 0 + 1))->inverse();        $T²   = MatrixFactory::create([$X->multiply($P)->multiply($Λⱼ⁻¹)->multiply($P′)->multiply($X′)->getDiagonalElements()])->transpose();        for ($i = 1; $i < $this->data->getN(); $i++) {            // Get the first $i+1 columns of the loading matrix            $P    = $this->EVec->submatrix(0, 0, $vars - 1, $i);            $P′   = $P->transpose();            $Λⱼ⁻¹ = MatrixFactory::diagonal(\array_slice($this->EVal->getVector(), 0, $i + 1))->inverse();            $Tᵢ²  = MatrixFactory::create([$X->multiply($P)->multiply($Λⱼ⁻¹)->multiply($P′)->multiply($X′)->getDiagonalElements()])->transpose();            $T²   = $T²->augment($Tᵢ²);        }        return $T²;    }    /**     * Calculate the critical limits of T²     *     * @param float $alpha the probability limit of the critical value     *     * @return float[] Critical values for each model complexity     */    public function getCriticalT2(float $alpha = .05): array    {        $samp = $this->data->getM();        $vars = $this->data->getN();        $T²Critical = [];        for ($i = 1; $i <= $vars; $i++) {            $F = new F($i, $samp - $i);            $T = $i * ($samp - 1) * $F->inverse(1 - $alpha) / ($samp - $i);            $T²Critical[] = $T;        }        return $T²Critical;    }    /**     * Calculate the critical limits of Q     *     * @param float $alpha the probability limit of the critical value     *     * @return float[] Critical values for each model complexity     *     * @throws Exception\MathException     */    public function getCriticalQ(float $alpha = .05): array    {        $vars  = $this->data->getN();        $QCritical = [];        for ($i = 0; $i < $vars - 1; $i++) {            $evals = \array_slice($this->getEigenvalues()->getVector(), $i + 1);            $t1 = \array_sum($evals);            $t2 = \array_sum(Single::square($evals));            $t3 = \array_sum(Single::pow($evals, 3));            $h0 = 1 - 2 * $t1 * $t3 / 3 / $t2 ** 2;            if ($h0 < .001) {                $h0 = .001;            }            $normal = new StandardNormal();            $ca     = $normal->inverse(1 - $alpha);            $h1 = $ca * \sqrt(2 * $t2 * $h0 ** 2) / $t1;            $h2 = $t2 * $h0 * ($h0 - 1) / $t1 ** 2;            $QCritical[] = $t1 * (1 + $h1 + $h2) ** (1 / $h0);        }        // The final value is always zero since the model is perfectly fit.        $QCritical[] = 0;        return $QCritical;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Rational_2945,"String representation of a rational number\n 5 6/7, 456079/13745859, etc.\n\n @return string\n",Predstava racionalnog broja stringom. Na primer 6/7 ili 456079/13745859,public function __toString(): string    {        $sign     = '';        $whole    = '';        $fraction = '';        if (Special::sgn($this->whole) === -1 || Special::sgn($this->numerator) === -1) {            $sign = '-';        }        if ($this->whole !== 0) {            $whole = \abs($this->whole);        }        if ($this->numerator !== 0) {            if ($this->whole !== 0) {                $whole .= ' ';            }            $fraction = $this->numeratorToSuperscript() . '/' . $this->denominatorToSubscript();        }        $string = $sign . $whole . $fraction;        if ($string == '') {            $string = '0';        }        return $string;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RectangleMethod_3025," Rectangle Method\n\n In numerical analysis, the rectangle method is a technique for approximating\n the definite integral of a function.\n\n The rectangle method belongs to the closed Newton-Cotes formulas, a group of\n methods for numerical integration which approximate the integral of a function.\n We can either directly supply a set of inputs and their corresponding outputs\n for said function, or if we explicitly know the function, we can define it as a\n callback function and then generate a set of points by evaluating that function\n at n points between a start and end point. We then use these values to\n interpolate a Lagrange polynomial. Finally, we integrate the Lagrange\n polynomial to approximate the integral of our original function.\n\n The rectangle method is produced by integrating the zero-th degree Lagrange Polynomial\n\n https://en.wikipedia.org/wiki/Rectangle_method\n http://www.efunda.com/math/num_integration/num_int_newton.cfm\n","Pravougaoni metod. U numeričkoj analizi, metod pravougaonika je tehnika za aproksimaciju određenog integrala funkcije. Ovaj metod pripada Njutn-Kotovim formulama, grupi metoda numeričke integracije koje aproksimiraju integram funkcije. Možemo da dostavimo skip ulaza i njihovih odgovarajućih izlaza za datu funkciju ili, ukoliko eksplicitno znamo funkciju, možemo je definisati kao callback funkciju i generisati skup tačaka na kojima ćemo uzeti njenu vrednost. Ove vrednosti zatim koristimo da interpoliramo Lagranžov polinom. Konačno, integralimo Lagranžov polinom da aproksimiramo integral naše originalne funkcije.","class RectangleMethod extends NumericalIntegration{    /**     * Use the Rectangle Method to approximate the definite integral of a     * function f(x). Our input can support either a set of arrays, or a callback     * function with arguments (to produce a set of arrays). Each array in our     * input contains two numbers which correspond to coordinates (x, y) or     * equivalently, (x, f(x)), of the function f(x) whose definite integral we     * are approximating.     *     * The bounds of the definite integral to which we are approximating is     * determined by the our inputs.     *     * Example: approximate([0, 10], [3, 5], [10, 7]) will approximate the definite     * integral of the function that produces these coordinates with a lower     * bound of 0, and an upper bound of 10.     *     * Example: approximate(function($x) {return $x**2;}, 0, 4 ,5) will produce     * a set of arrays by evaluating the callback at 5 evenly spaced points     * between 0 and 4. Then, this array will be used in our approximation.     *     * Rectangle Rule:     *     * xn        ⁿ⁻¹ xᵢ₊₁     * ∫ f(x)dx = ∑   ∫ f(x)dx     * x₁        ⁱ⁼¹  xᵢ     *     *            ⁿ     *          = ∑   h [f(xᵢ)] + O(h³f″(x))     *           ⁱ⁼¹     *     *  where h = xᵢ₊₁ - xᵢ     *  note: this implementation does not compute the error term.     * @param callable|array $source  The source of our approximation. Should be either     *                                a callback function or a set of arrays. Each array     *                                (point) contains precisely two numbers, an x and y.     *                                Example array: [[1,2], [2,3], [3,4]].     *                                Example callback: function($x) {return $x**2;}     * @param number         ...$args The arguments of our callback function: start,     *                                end, and n. Example: approximate($source, 0, 8, 5).     *                                If $source is a set of points, do not input any     *                                $args. Example: approximate($source).     *     * @return float                  The approximation to the integral of f(x)     *     * @throws Exception\BadDataException     * @throws Exception\IncorrectTypeException     */    public static function approximate($source, ...$args): float    {        // Get an array of points from our $source argument        $points = self::getPoints($source, $args);        // Validate input and sort points        self::validate($points, $degree = 2);        $sorted = self::sort($points);        // Descriptive constants        $x = self::X;        $y = self::Y;        // Initialize        $n             = \count($sorted);        $steps         = $n - 1;        $approximation = 0;        /*         * Summation         *   ⁿ         * = ∑   h [f(xᵢ)] + O(h³f″(x))         *  ⁱ⁼¹         * where h = xᵢ₊₁ - xᵢ         */        for ($i = 0; $i < $steps; $i++) {            $xᵢ             = $sorted[$i][$x];            $xᵢ₊₁           = $sorted[$i + 1][$x];            $f⟮xᵢ⟯           = $sorted[$i][$y];   // yᵢ            $lagrange       = LagrangePolynomial::interpolate([[$xᵢ, $f⟮xᵢ⟯]]);            $integral       = $lagrange->integrate();            $approximation += $integral($xᵢ₊₁) - $integral($xᵢ); // definite integral of lagrange polynomial        }        return $approximation;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_RegularGridInterpolator_3004, Dynamically accessing multidimensional array value.\n\n @param array $data\n @param array $keys\n\n @return array|mixed\n,Dinamički pristup vrednosti višedimenzionalnog niza.,"    private function flatCall(array $data, array $keys)    {        $current = $data;        foreach ($keys as $key) {            $current = $current[$key];        }        return $current;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Search_2508, Search Sorted\\n Find the array indices where items should be inserted to maintain sorted order.\\n\\n Inspired by and similar to Python NumPy's searchsorted\\n\\n @param float[]|int[] $haystack Sorted array with standard increasing numerical array keys\\n @param float         $needle   Item wanting to insert\\n\\n @return int Index of where you would insert the needle and maintain sorted order\\n,Traži u sortiranom. Nađi indeks niza gde treba dodati vrednosti kako bi se očuvao redosled. Inspirisano Python funkcijom searchsorted.,"public static function sorted(array $haystack, float $needle): int    {        if (empty($haystack)) {            return 0;        }        $index = 0;        foreach ($haystack as $i => $val) {            if ($needle > $val) {                $index++;            } else {                return $index;            }        }        return $index;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Search_2509," ArgMax\\n Find the array index of the maximum value.\\n\\n In case of the maximum value appearing multiple times, the index of the first occurrence is returned.\\n In the case NAN is present, the index of the first NAN is returned.\\n\\n Inspired by and similar to Python NumPy's argmax\\n\\n @param float[]|int[] $values\\n\\n @return int Index of the first occurrence of the maximum value\\n\\n @throws Exception\\\\BadDataException if the array of values is empty\\n","Nađi indeks maksimalne vrednosti niza. U slučaju da se maksimalna vrednost pojavljuje više puta, vraća se indeks prvog pojavljivanja.","public static function argMax(array $values): int    {        if (empty($values)) {            throw new Exception\BadDataException('Cannot find the argMax of an empty array');        }        // Special case: NAN wins if present        $nanPresent = \array_filter(            $values,            function ($value) {                return \is_float($value) && \is_nan($value);            }        );        if (\count($nanPresent) > 0) {            foreach ($values as $i => $v) {                if (\is_nan($v)) {                    return $i;                }            }        }        // Standard case: Find max and return index        return self::baseArgMax($values);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Search_2514," Base argMin calculation\n Find the array index of the minimum value.\n\n In case of the maximum value appearing multiple times, the index of the first occurrence is returned.\n\n @param float[]|int[] $values\n\n @return int Index of the first occurrence of the minimum value\n","Nađi indeks minimalne vrednosti niza. U slučaju da se minimalna vrednost pojavljuje više puta, vraća se indeks prvog pojavljivanja.",    private static function baseArgMin(array $values): int    {        $max = \min($values);        foreach ($values as $i => $v) {            if ($v === $max) {                return $i;            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3408, Add an element to the set\\n Does nothing if element already exists in the set.\\n\\n @param mixed $x\\n\\n @return Set (this set)\\n,Dodaj element u skup. Ne radi ništa ukoliko element već postoji u skupu.,    public function add($x): Set    {        $this->A[$this->getKey($x)] = $x;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3409, Add an array of elements to the set\n Does nothing if element already exists in the set.\n\n @param array $members\n\n @return Set (this set)\n,Dodaj niz elemenata u skup. Ne radi ništa ukoliko element već postoji u skupu.,    public function addMulti(array $members): Set    {        foreach ($members as $member) {            $this->A[$this->getKey($member)] = $member;        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Set_3414," Subset (A ⊆ B)\\n Is the set a subset of the other set?\\n In other words, does the other set contain all the elements of the set?\\n\\n @param  Set $B\\n\\n @return boolean\\n","Podskup. Proverava da li je skup podskup drugog skupa. U drugim rečima, da li drugi skup sadrži sve elemente prvog skupa","    public function isSubset(Set $B): bool    {        $B_array  = $B->asArray();        $A∩B = \array_intersect_key($this->A, $B_array);        $A∖B = \array_diff_key($this->A, $B_array);        return (\count($A∩B) === \count($this->A)) && (empty($A∖B));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Special_2559," Beta function\\n\\n https://en.wikipedia.org/wiki/Beta_function\\n\\n           Γ(x)Γ(y)\\n β(x, y) = --------\\n           Γ(x + y)\\n\\n @param  float $x\\n @param  float $y\\n\\n @return float\\n\\n @throws Exception\\\\OutOfBoundsException\\n",Beta funkcija,"public static function beta(float $x, float $y): float    {        if ($x == 0 || $y == 0) {            return \INF;        }        $Γ⟮x⟯Γ⟮y⟯   = self::gamma($x) * self::gamma($y);        $Γ⟮x ＋ y⟯ = self::gamma($x + $y);        return $Γ⟮x⟯Γ⟮y⟯ / $Γ⟮x ＋ y⟯;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Validation_3045, Verify that the start and end of of an interval are distinct numbers.\\n\\n @param number $a The start of the interval\\n @param number $b The end of the interval\\n\\n @throws Exception\\\\BadDataException if $a = $b\\n,Potvrdi da su početak i kraj intervala jedinstveni brojevi.,"    public static function interval($a, $b)    {        if ($a === $b) {            throw new Exception\BadDataException('Start point and end point of interval cannot be the same.');        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
markrogoyski_math-php_Vector_2840, Outer product (A⨂B)\\n https://en.wikipedia.org/wiki/Outer_product\\n Same as direct product.\\n\\n @param Vector $B\\n\\n @return NumericMatrix\\n,Spoljašnji proizvod dva vektora.,public function outerProduct(Vector $B): NumericMatrix    {        $m = $this->n;        $n = $B->getN();        $R = [];        for ($i = 0; $i < $m; $i++) {            for ($j = 0; $j < $n; $j++) {                $R[$i][$j] = $this->A[$i] * $B[$j];            }        }        return MatrixFactory::create($R);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_36," If the user doesn't have an ADMIN access for at least one website, throws an exception\\n\\n @throws \\\\Piwik\\\\NoAccessException\\n","Ukoliko korisnik nema ADMIN pristup za bar jedan sajt, podiže izuzetak.","    public function checkUserHasSomeAdminAccess()    {        if (!$this->isUserHasSomeAdminAccess()) {            $this->throwNoAccessException(Piwik::translate('General_ExceptionPrivilegeAtLeastOneWebsite', array('admin')));        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_43," Returns the level of access the current user has to the given site.\\n\\n @param int $idSite The site to check.\\n @return string The access level, eg, 'view', 'admin', 'noaccess'.\\n",Vraća nivo pristupa koji tretnutni koristnik ima na zadatom sajtu.,"    public function getRoleForSite($idSite)    {        if ($this->hasSuperUserAccess            || in_array($idSite, $this->getSitesIdWithAdminAccess())        ) {            return 'admin';        }        if (in_array($idSite, $this->getSitesIdWithWriteAccess())) {            return 'write';        }        if (in_array($idSite, $this->getSitesIdWithViewAccess())) {            return 'view';        }        return 'noaccess';    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Access_46, Returns true if the current user is logged in or not.\\n\\n @return bool\\n,Vraća tačno ukoliko je koristnik prijavljen,    public function isUserLoggedIn()    {        return !empty($this->login);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Archive_792, Returns an array describing what metadata to use when indexing a query result.\n For use with DataCollection.\n\n @return array\n,Vraća niz koji opisuje koju metadatu treba koristiti kada se indeksira rezultat upita.,private function getResultIndices()    {        $indices = array();        if (count($this->params->getIdSites()) > 1            || $this->forceIndexedBySite        ) {            $indices['site'] = 'idSite';        }        if (count($this->params->getPeriods()) > 1            || $this->forceIndexedByDate        ) {            $indices['period'] = 'date';        }        return $indices;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_AssetManager_87, Check if the merged file directory exists and is writable.\\n\\n @return string The directory location\\n @throws Exception if directory is not writable.\\n,Proverava da li direktorijum u koji će se upisati fajl postoji i da li imamo dozvolu da upisujemo u njega.,"    public function getAssetDirectory()    {        $mergedFileDirectory = StaticContainer::get('path.tmp') . '/assets';        if (!is_dir($mergedFileDirectory)) {            Filesystem::mkdir($mergedFileDirectory);        }        if (!is_writable($mergedFileDirectory)) {            throw new Exception(""Directory "" . $mergedFileDirectory . "" has to be writable."");        }        return $mergedFileDirectory;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_CliMulti_127, Remove files older than one week. They should be cleaned up automatically after each request but for whatever\\n reason there can be always some files left.\\n,"Obriši fajlove koji su stariji od jedne nedelje. Trebalo bi da se obrišu automatski posle svakog zahteva, međutim iz nekog razloga uvek neki ostanu.",public static function cleanupNotRemovedFiles()    {        $timeOneWeekAgo = strtotime('-1 week');        $files = _glob(self::getTmpPath() . '/*');        if (empty($files)) {            return;        }        foreach ($files as $file) {            if (file_exists($file)) {                $timeLastModified = filemtime($file);                if ($timeLastModified !== false && $timeOneWeekAgo > $timeLastModified) {                    unlink($file);                }            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Common2_134,"Base class for HTML classes\\n\\n Implements methods for working with HTML attributes, parsing and generating\\n attribute strings. Port of HTML_Common class for PHP4 originally written by\\n Adam Daniel with contributions from numerous other developers.\\n\\n @category   HTML\\n @package    HTML_Common2\\n @author     Alexey Borzov <avb@php.net>\\n @version    Release: @package_version@\\n","Osnovna klasa za HTML klase. Implementira metode za rad za HTML atributima, parsiranje i generisanje stringova atributa. Port je HTML_Common klase za PHP4 koju je originalno napisao Adam Daniel uz doprinose mnogobrojnih razvijača.","abstract class HTML_Common2{   /**    * Associative array of attributes    * @var array    */    protected $attributes = array();   /**    * List of attribites changes to which will be announced via onAttributeChange()    * method rather than performed by HTML_Common2 class itself    * @var array    * @see onAttributeChange()    */    protected $watchedAttributes = array();   /**    * Indentation level of the element    * @var int    */    private $_indentLevel = 0;   /**    * Comment associated with the element    * @var string    */    private $_comment = null;   /**    * Global options for all elements generated by subclasses of HTML_Common2    *    * Preset options are    * - 'charset': charset parameter used in htmlspecialchars() calls,    *   defaults to 'ISO-8859-1'    * - 'indent': string used to indent HTML elements, defaults to ""\11""    * - 'linebreak': string used to indicate linebreak, defaults to ""\12""    *    * @var array    */    private static $_options = array(        'charset'   => 'ISO-8859-1',        'indent'    => ""\11"",        'linebreak' => ""\12""    );   /**    * Sets global option(s)    *    * @param    string|array    Option name or array ('option name' => 'option value')    * @param    mixed           Option value, if first argument is not an array    */    public static function setOption($nameOrOptions, $value = null)    {        if (is_array($nameOrOptions)) {            foreach ($nameOrOptions as $k => $v) {                self::setOption($k, $v);            }        } else {            $linebreaks = array('win' => ""\15\12"", 'unix' => ""\12"", 'mac' => ""\15"");            if ('linebreak' == $nameOrOptions && isset($linebreaks[$value])) {                $value = $linebreaks[$value];            }            self::$_options[$nameOrOptions] = $value;        }    }   /**    * Returns global option(s)    *    * @param    string  Option name    * @return   mixed   Option value, null if option does not exist,    *                   array of all options if $name is not given    */    public static function getOption($name = null)    {        if (null === $name) {            return self::$_options;        } else {            return isset(self::$_options[$name])? self::$_options[$name]: null;        }    }   /**    * Parses the HTML attributes given as string    *    * @param    string  HTML attribute string    * @return   array   An associative aray of attributes    */    protected static function parseAttributes($attrString)    {        $attributes = array();        if (preg_match_all(                ""/(([A-Za-z_:]|[^\\x00-\\x7F])([A-Za-z0-9_:.-]|[^\\x00-\\x7F])*)"" .                ""([ \\n\\t\\r]+)?(=([ \\n\\t\\r]+)?(\""[^\""]*\""|'[^']*'|[^ \\n\\t\\r]*))?/"",                $attrString,                $regs           )) {            for ($i = 0; $i < count($regs[1]); $i++) {                $name  = trim($regs[1][$i]);                $check = trim($regs[0][$i]);                $value = trim($regs[7][$i]);                if ($name == $check) {                    $attributes[strtolower($name)] = strtolower($name);                } else {                    if (!empty($value) && ($value[0] == '\'' || $value[0] == '""')) {                        $value = substr($value, 1, -1);                    }                    $attributes[strtolower($name)] = $value;                }            }        }        return $attributes;    }   /**    * Creates a valid attribute array from either a string or an array    *    * @param    mixed   Array of attributes or HTML attribute string    * @return   array   An associative aray of attributes    */    protected static function prepareAttributes($attributes)    {        $prepared = array();        if (is_string($attributes)) {            return self::parseAttributes($attributes);        } elseif (is_array($attributes)) {            foreach ($attributes as $key => $value) {                if (is_int($key)) {                    $key = strtolower($value);                    $prepared[$key] = $key;                } else {                    $prepared[strtolower($key)] = (string)$value;                }            }        }        return $prepared;    }   /**    * Removes an attribute from an attribute array    *    * @param    array   Attribute array    * @param    string  Name of attribute to remove    */    protected static function removeAttributeArray(&$attributes, $name)    {        unset($attributes[strtolower($name)]);    }   /**    * Creates HTML attribute string from array    *    * @param    array   Attribute array    * @return   string  Attribute string    */    protected static function getAttributesString($attributes)    {        $str = '';        if (is_array($attributes)) {            $charset = self::getOption('charset');            foreach ($attributes as $key => $value) {                $str .= ' ' . $key . '=""' . htmlspecialchars($value, ENT_QUOTES, $charset) . '""';            }        }        return $str;    }   /**    * Class constructor, sets default attributes    *    * @param    mixed   Array of attribute 'name' => 'value' pairs or HTML attribute string    */    public function __construct($attributes = null)    {        $this->mergeAttributes($attributes);    }   /**    * Sets the value of the attribute    *    * @param    string  Attribute name    * @param    string  Attribute value (will be set to $name if omitted)    * @return   HTML_Common2    */    public function setAttribute($name, $value = null)    {        $name = strtolower($name);        if (is_null($value)) {            $value = $name;        }        if (in_array($name, $this->watchedAttributes)) {            $this->onAttributeChange($name, $value);        } else {            $this->attributes[$name] = (string)$value;        }        return $this;    }   /**    * Returns the value of an attribute    *    * @param    string  Attribute name    * @return   string  Attribute value, null if attribute does not exist    */    public function getAttribute($name)    {        $name = strtolower($name);        return isset($this->attributes[$name])? $this->attributes[$name]: null;    }   /**    * Sets the attributes    *    * @param    mixed   Array of attribute 'name' => 'value' pairs or HTML attribute string    * @return   HTML_Common2    */    public function setAttributes($attributes)    {        $attributes = self::prepareAttributes($attributes);        $watched    = array();        foreach ($this->watchedAttributes as $watchedKey) {            if (isset($attributes[$watchedKey])) {                $this->setAttribute($watchedKey, $attributes[$watchedKey]);                unset($attributes[$watchedKey]);            } else {                $this->removeAttribute($watchedKey);            }            if (isset($this->attributes[$watchedKey])) {                $watched[$watchedKey] = $this->attributes[$watchedKey];            }        }        $this->attributes = array_merge($watched, $attributes);        return $this;    }   /**    * Returns the attribute array or string    *    * @param    bool    Whether to return attributes as string    * @return   mixed   Either an array or string of attributes    */    public function getAttributes($asString = false)    {        if ($asString) {            return self::getAttributesString($this->attributes);        } else {            return $this->attributes;        }    }   /**    * Merges the existing attributes with the new ones    *    * @param    mixed   Array of attribute 'name' => 'value' pairs or HTML attribute string    * @return   HTML_Common2    */    public function mergeAttributes($attributes)    {        $attributes = self::prepareAttributes($attributes);        foreach ($this->watchedAttributes as $watchedKey) {            if (isset($attributes[$watchedKey])) {                $this->onAttributeChange($watchedKey, $attributes[$watchedKey]);                unset($attributes[$watchedKey]);            }        }        $this->attributes = array_merge($this->attributes, $attributes);        return $this;    }   /**    * Removes an attribute    *    * @param    string  Name of attribute to remove    * @return   HTML_Common2    */    public function removeAttribute($attribute)    {        if (in_array(strtolower($attribute), $this->watchedAttributes)) {            $this->onAttributeChange(strtolower($attribute), null);        } else {            self::removeAttributeArray($this->attributes, $attribute);        }        return $this;    }   /**    * Sets the indentation level    *    * @param    int    * @return   HTML_Common2    */    public function setIndentLevel($level)    {        $level = intval($level);        if (0 <= $level) {            $this->_indentLevel = $level;        }        return $this;    }   /**    * Gets the indentation level    *    * @return   int    */    public function getIndentLevel()    {        return $this->_indentLevel;    }   /**    * Returns the string to indent the element    *    * @return   string    */    protected function getIndent()    {        return str_repeat(self::getOption('indent'), $this->getIndentLevel());    }   /**    * Sets the comment for the element    *    * @param    string    * @return   HTML_Common2    */    public function setComment($comment)    {        $this->_comment = $comment;        return $this;    }   /**    * Returns the comment associated with the element    *    * @return   string    */    public function getComment()    {        return $this->_comment;    }   /**    * Checks whether the element has given CSS class    *    * @param    string  Class name    * @return   bool    */    public function hasClass($class)    {        $regex = '/(^|\s)' . preg_quote($class, '/') . '(\s|$)/';        return (bool)preg_match($regex, $this->getAttribute('class'));    }   /**    * Adds the given CSS class(es) to the element    *    * @param    string|array    Class name, multiple class names separated by    *                           whitespace, array of class names    * @return   HTML_Common2    */    public function addClass($class)    {        if (!is_array($class)) {            $class = preg_split('/\s+/', $class, null, PREG_SPLIT_NO_EMPTY);        }        $curClass = preg_split('/\s+/', $this->getAttribute('class'),                               null, PREG_SPLIT_NO_EMPTY);        foreach ($class as $c) {            if (!in_array($c, $curClass)) {                $curClass[] = $c;            }        }        $this->setAttribute('class', implode(' ', $curClass));        return $this;    }   /**    * Removes the given CSS class(es) from the element    *    * @param    string|array    Class name, multiple class names separated by    *                           whitespace, array of class names    * @return   HTML_Common2    */    public function removeClass($class)    {        if (!is_array($class)) {            $class = preg_split('/\s+/', $class, null, PREG_SPLIT_NO_EMPTY);        }        $curClass = array_diff(            preg_split('/\s+/', $this->getAttribute('class'),                       null, PREG_SPLIT_NO_EMPTY),            $class        );        if (0 == count($curClass)) {            $this->removeAttribute('class');        } else {            $this->setAttribute('class', implode(' ', $curClass));        }        return $this;    }   /**    * Returns the HTML representation of the element    *    * This magic method allows using the instances of HTML_Common2 in string    * contexts    *    * @return string    */    abstract public function __toString();   /**    * Called if trying to change an attribute with name in $watchedAttributes    *    * This method is called for each attribute whose name is in the    * $watchedAttributes array and which is being changed by setAttribute(),    * setAttributes() or mergeAttributes() or removed via removeAttribute().    * Note that the operation for the attribute is not carried on after calling    * this method, it is the responsibility of this method to change or remove    * (or not) the attribute.    *    * @param    string  Attribute name    * @param    string  Attribute value, null if attribute is being removed    */    protected function onAttributeChange($name, $value = null)    {    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
matomo-org_matomo_Common2_883, Checks whether the element has given CSS class\n\n @param    string  Class name\n @return   bool\n,Proverava da li element ima zadatu CSS klasu.,"    public function hasClass($class)    {        $regex = '/(^|\s)' . preg_quote($class, '/') . '(\s|$)/';        return (bool)preg_match($regex, $this->getAttribute('class'));    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_168, Returns the number of elements in the container\\n\\n @return    int\\n,Vraća broj elemenata u kontejneru.,    public function count()    {        return count($this->elements);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Container_901, Returns an array of elements which name corresponds to element\n\n @param    string  Elements name to find\n @return   array\n,Vrača niz elemenata čije ime odgovara elementu.,    public function getElementsByName($name)    {        $found = array();        foreach ($this->getRecursiveIterator() as $element) {            if ($element->getName() == $name) {                $found[] = $element;            }        }        return $found;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_921,"Handles an action\n\n This will be called if the page itself does not have a handler for a\n specific action. The method also loads and uses default handlers for\n common actions, if specific ones were not added.\n\n @param    HTML_QuickForm2_Controller_Page form page\n @param    string                          action name\n @throws   HTML_QuickForm2_NotFoundException   if handler for an action is missing\n","Rukuje akcijama. Ovo će se pozvati ukoliko stranica nema način da upravlja određenom akcijom. Takođe, metod učitava i koristi podrazumevane upravljače za česte akcije ukoliko drugi nisu dodati.","public function handle(HTML_QuickForm2_Controller_Page $page, $actionName)    {        if (!isset($this->handlers[$actionName])            && in_array($actionName, array('next', 'back', 'submit', 'display', 'jump'))        ) {            $className = 'HTML_QuickForm2_Controller_Action_' . ucfirst($actionName);            if (!class_exists($className)) {                HTML_QuickForm2_Loader::loadClass($className);            }            $this->addHandler($actionName, new $className());        }        if (isset($this->handlers[$actionName])) {            return $this->handlers[$actionName]->perform($page, $actionName);        } else {            throw new HTML_QuickForm2_NotFoundException(                ""Unhandled action '{$actionName}' for page '{$page->getForm()->getId()}'""            );        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Controller_929," Merges two arrays\n\n Merges two arrays like the PHP function array_merge_recursive does,\n the difference being that existing integer keys will not be renumbered.\n\n @param    array\n @param    array\n @return   array   resulting array\n",Spaja dva niza. Spaja dva niza kao php funkcija array_merge_recursive. Razlika je što trenutni celobrojni indeksi neće biti ponovno prebrojeni.,"    protected static function arrayMerge($a, $b)    {        foreach ($b as $k => $v) {            if (!is_array($v) || isset($a[$k]) && !is_array($a[$k])) {                $a[$k] = $v;            } else {                $a[$k] = self::arrayMerge(isset($a[$k])? $a[$k]: array(), $v);            }        }        return $a;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Element_935,Renders the element using the given renderer\n\n @param    HTML_QuickForm2_Renderer    Renderer instance\n @return   HTML_QuickForm2_Renderer\n,Renderuje element pomoću zadatog renderera.,public function render(HTML_QuickForm2_Renderer $renderer)    {        foreach ($this->rules as $rule) {            if ($rule[1] & HTML_QuickForm2_Rule::RUNAT_CLIENT) {                $renderer->getJavascriptBuilder()->addRule($rule[0]);            }        }        $renderer->renderElement($this);        return $renderer;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_Exception_939,"Exception that denotes invalid arguments were passed\n\n One example is trying to create an element of type which is unknown to Factory\n <code>\n try {\n     $el = HTML_QuickForm2_Factory::createElement(\'unknown\');\n } catch (HTML_QuickForm2_InvalidArgumentException $e) {\n     echo $e->getMessage();\n }\n </code>\n This code will output ""Element type \'unknown\' is not known""\n\n @category   HTML\n @package    HTML_QuickForm2\n @version    Release: @package_version@\n",Izuzetak koji označava da su neispravni argumenti dati. Jedan primer je pokušavaj kreiranja elementa čiji je tip nepoznat.,class HTML_QuickForm2_InvalidArgumentException extends HTML_QuickForm2_Exception{},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ManyVisitsWithGeoIP_1006,Adds one new website and tracks 35 visits from 18 visitors with geolocation using\n free GeoIP databases. The GeoIP databases are downloaded if they do not exist already.\n,Dodaje jedan novi sajt i prati 35 poseta od 18 korisnika sa geolokacijom koristeći besplatne GeoIP baze koje su preuzete ukoliko već ne postoje.,"class ManyVisitsWithGeoIP extends Fixture{    const GEOIP_IMPL_TO_TEST = 'geoip2php';    public $idSite = 1;    public $dateTime = '2010-01-03 11:22:33';    public $ips = array(        '194.57.91.215', // in Besançon, FR (unicode city name)        '::ffff:137.82.130.49', // in British Columbia (mapped ipv4)        '137.82.130.0', // anonymization tests        '137.82.0.0',        '2003:f6:93bf:26f:9ec7:a6ff:fe29:27df', // ipv6 in US (without region or city)        '113.62.1.1', // in Lhasa, Tibet        '151.100.101.92', // in Rome, Italy (using country DB, so only Italy will show)        '103.29.196.229', // in Indonesia, Central Java (Bali)    );    public $userAgents = array(        'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.136 Mobile Safari/537.36',        'Mozilla/5.0 (Linux; U; Android 2.3.7; fr-fr; HTC Desire Build/GRI40; MildWild CM-8.0 JG Stable) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1',        'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.76 Safari/537.36',        'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; GTB6.3; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; OfficeLiveConnector.1.4; OfficeLivePatch.1.3)',        'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; MDDSJS; rv:11.0) like Gecko',        'Mozilla/5.0 (Linux; Android 4.1.1; SGPT13 Build/TJDS0170) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.114 Safari/537.36',        'Mozilla/5.0 (Linux; U; Android 4.3; zh-cn; SM-N9006 Build/JSS15J) AppleWebKit/537.36 (KHTML, like Gecko)Version/4.0 MQQBrowser/5.0 Mobile Safari/537.36',        'Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9.0.14) Gecko/2009090216 Ubuntu/9.04 (jaunty) Firefox/3.0.14'    );    protected $idGoal;    protected $idGoal2;    public function setUp(): void    {        // set option, so tracked data for the past won't get converted        Option::set(GeoIp2::SWITCH_TO_ISO_REGIONS_OPTION_NAME, 1);        $this->setUpWebsitesAndGoals();        $this->setMockLocationProvider();        $this->trackVisits(9, false);        $this->setLocationProvider('GeoIP2-City.mmdb');        $this->trackVisits(2, true, $useLocal = false);        $this->trackVisits(4, true, $useLocal = false, $doBulk = true);        $this->setLocationProvider('GeoIP2-Country.mmdb');        $this->trackVisits(2, true);        $this->trackOtherVisits();        $this->setLocationProvider('GeoIP2-City.mmdb');    }    public function tearDown(): void    {        $this->unsetLocationProvider();    }    private function setUpWebsitesAndGoals()    {        if (!self::siteCreated($idSite = 1)) {            self::createWebsite($this->dateTime, 0, ""Site 1"");        }        if (!self::goalExists($idSite = 1, $idGoal = 1)) {            $this->idGoal = API::getInstance()->addGoal($this->idSite, 'all', 'url', 'http', 'contains', false, 5);        }        if (!self::goalExists($idSite = 1, $idGoal = 2)) {            $this->idGoal2 = API::getInstance()->addGoal($this->idSite, 'two', 'url', 'xxxxxxxxxxxxx', 'contains', false, 5, false, 'twodesc');        }    }    protected $calledCounter = 0;    private function trackVisits($visitorCount, $setIp = false, $useLocal = true, $doBulk = false)    {        $this->calledCounter++;        $dateTime = $this->dateTime;        $idSite = $this->idSite;        if ($useLocal) {            Cache::getTransientCache()->flushAll(); // make sure dimension cache is empty between local tracking runs            Visit::$dimensions = null;        }        // use local tracker so mock location provider can be used        $t = self::getTracker($idSite, $dateTime, $defaultInit = true, $useLocal);        if ($doBulk) {            $t->enableBulkTracking();        }        $t->setTokenAuth(self::getTokenAuth());        for ($i = 0; $i != $visitorCount; ++$i) {            $this->trackVisit($t, $this->calledCounter, $i, $doBulk, array('setIp' => $setIp));        }        if ($doBulk) {            self::checkBulkTrackingResponse($t->doBulkTrack());        }    }    /**     * Insert a new visit into the database.     * @param \MatomoTracker $t          The tracker to record the visits on     * @param int $fixtureCounter       Number of times this fixture has been run      * @param int $visitorCounter       Visitor counter within this execution of the fixture     * @param boolean $doBulk           Should this visit be left for bulk insert later, or processed now?     * @param array $params             Other params as required to set up the visit     */    protected function trackVisit(\MatomoTracker $t, $fixtureCounter, $visitorCounter, $doBulk, array $params)    {        $setIp = isset($params['setIp']) && $params['setIp'];        // NOTE: floor() is so some visits share the same visit ID        $t->setVisitorId( substr(md5(floor($visitorCounter / 2) + $fixtureCounter * 1000), 0, $t::LENGTH_VISITOR_ID));        $userAgent = null;        if ($setIp) {            $userAgent = current($this->userAgents);            $t->setIp(current($this->ips));            $t->setUserAgent($userAgent);            next($this->userAgents);            next($this->ips);        } else {            $t->setIp(""1.2.4.$visitorCounter"");        }        // first visit        $date = Date::factory($this->dateTime)->addDay($visitorCounter);        $t->setForceVisitDateTime($date->getDatetime());        $t->setUrl(""http://piwik.net/grue/lair"");        $t->setCustomVariable(1, 'Cvar 1 name', 'Cvar1 value is ' .$visitorCounter , 'visit');        $t->setCustomVariable(5, 'Cvar 5 name', 'Cvar5 value is ' .$visitorCounter , 'visit');        $t->setCustomVariable(2, 'Cvar 2 PAGE name', 'Cvar2 PAGE value is ' .$visitorCounter, 'page');        $t->setCustomVariable(5, 'Cvar 5 PAGE name', 'Cvar5 PAGE value is ' .$visitorCounter, 'page');        $r = $t->doTrackPageView('It\'s <script> pitch black...');        if (!$doBulk) {            self::checkResponse($r);        }        // second visit        if ($userAgent) {            $t->setUserAgent($userAgent); // unset in doTrack...        }        $date = $date->addHour(1);        $t->setForceVisitDateTime($date->getDatetime());        $t->setUrl(""http://piwik.net/space/quest/iv"");        // Manually record some data        $r = $t->doTrackPageView(""Space Quest XII"");        if (!$doBulk) {            self::checkResponse($r);        }        if ($userAgent) {            $t->setUserAgent($userAgent); // unset in doTrack...        }        // Track site search (for AutoSuggestAPI test)        // Only for half visitors so they don't all have a ""site search"" as last action and some of them have a standard page view as last action        $date = $date->addHour(0.1);        $t->setForceVisitDateTime($date->getDatetime());        if( ($visitorCounter % 2) == 0) {            $r = $t->doTrackSiteSearch('Bring on the party', 'CAT', $visitorCounter*6);        }        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.2);        $t->setForceVisitDateTime($date->getDatetime());        $r = $t->doTrackGoal($this->idGoal2);        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.05);        $t->setForceVisitDateTime($date->getDatetime());        $t->doTrackAction('http://example.org/path/file' . $visitorCounter . '.zip', ""download"" );        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.05);        $t->setForceVisitDateTime($date->getDatetime());        $r = $t->doTrackAction('http://example-outlink.org/' . $visitorCounter . '.html', ""link"" );        if (!$doBulk) {            self::checkResponse($r);        }        $date = $date->addHour(0.05);        $t->setForceVisitDateTime($date->getDatetime());        $r = $t->doTrackEvent('Cat' . $visitorCounter,             'Action' . $visitorCounter,             'Name' . $visitorCounter,             345.678 + $visitorCounter        );        if (!$doBulk) {            self::checkResponse($r);        }    }    private function trackOtherVisits()    {        $dateTime = $this->dateTime;        $idSite = $this->idSite;        $t = self::getTracker($idSite, $dateTime, $defaultInit = true);        $t->setVisitorId('fed33392d3a48ab2');        $t->setTokenAuth(self::getTokenAuth());        $t->setForceVisitDateTime(Date::factory($dateTime)->addDay(20)->getDatetime());        $t->setIp('194.57.91.215');        $t->setUserId('userid.email@example.org');        $t->setCountry('us');        $t->setRegion('CA');        $t->setCity('not a city');        $t->setLatitude(1);        $t->setLongitude(2);        $t->setUrl(""http://piwik.net/grue/lair"");        $t->setUrlReferrer('http://google.com/?q=Wikileaks FTW');        $t->setUserAgent(""Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.2.6) AppleWebKit/522+ (KHTML, like Gecko) Safari/419.3 (.NET CLR 3.5.30729)"");        self::checkResponse($t->doTrackPageView('It\'s pitch black...'));    }    public function setLocationProvider($file)    {        GeoIp2::$dbNames['loc'] = array($file);        LocationProvider::$providers = null;        LocationProvider::setCurrentProvider(self::GEOIP_IMPL_TO_TEST);        if (LocationProvider::getCurrentProviderId() !== self::GEOIP_IMPL_TO_TEST) {            throw new Exception(""Failed to set the current location provider to '"" . self::GEOIP_IMPL_TO_TEST . ""'."");        }        $possibleFiles = GeoIp2::$dbNames['loc'];        if (GeoIp2::getPathToGeoIpDatabase($possibleFiles) === false) {            throw new Exception(""The GeoIP2 location provider cannot find the '$file' file! Tests will fail."");        }    }    private function setMockLocationProvider()    {        LocationProvider::$providers = array();        LocationProvider::$providers[] = new MockLocationProvider();        LocationProvider::setCurrentProvider('mock_provider');        MockLocationProvider::$locations = array(            self::makeLocation('Stratford-upon-Avon', 'WAR', 'gb', 123.456, 21.321), // template location            // same region, different city, same country            self::makeLocation('Nuneaton and Bedworth', 'WAR', 'gb', $isp = 'comcast.net'),            // same region, city & country (different lat/long)            self::makeLocation('Stratford-upon-Avon', 'WAR', 'gb', 124.456, 22.231, $isp = 'comcast.net'),            // same country, different region & city            self::makeLocation('London', 'LND', 'gb'),            // same country, different region, same city            self::makeLocation('Stratford-upon-Avon', 'KEN', 'gb', $lat = null, $long = null, $isp = 'awesomeisp.com'),            // different country, diff region, same city            self::makeLocation('Stratford-upon-Avon', 'SPE', 'ru'),            // different country, diff region (same as last), different city            self::makeLocation('Hluboká nad Vltavou', 'SPE', 'ru'),            // different country, diff region (same as last), same city            self::makeLocation('Stratford-upon-Avon', '18', 'mk'),            // unknown location            self::makeLocation(null, null, null),        );    }    public static function unsetLocationProvider()    {        try {            LocationProvider::setCurrentProvider('default');        } catch(Exception $e) {            // ignore error        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
matomo-org_matomo_ProcessedReport_236, Verfies whether the given metric belongs to the given report.\\n\\n @param int $idSite\\n @param string $metric     For example 'nb_visits'\\n @param string $apiMethodUniqueId  For example 'MultiSites_getAll'\\n\\n @return bool\\n,Proverava da li zadata metrika pripada datom izveštaju.,"    public function isValidMetricForReport($metric, $idSite, $apiMethodUniqueId)    {        $translation = $this->translateMetric($metric, $idSite, $apiMethodUniqueId);        return !empty($translation);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
nikic_PHP-Parser_Comment_52," Gets the reformatted comment text.\\\\n\\\\n ""Reformatted"" here means that we try to clean up the whitespace at the\\\\n starts of the lines. This is necessary because we receive the comments\\\\n without trailing whitespace on the first line, but with trailing whitespace\\\\n on all subsequent lines.\\\\n\\\\n @return mixed|string\\\\n",Vraća reformatiran tekst komentara. Reformatiran ovde znači da pokušavamo da očistimo razmake ne početku redova. Ovo je neophodno jer primamo koemntare bez pratećih razmaka na prvoj liniji ali sa pratećim razmacima na scim narednim linijama.,    public function getReformattedText() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
pagekit_pagekit_ExtensionTranslateCommand_891," Extracts translateable strings from a given file.\\n\\n @param  string $file Path to the file\\n @return array Array of strings to be translated, grouped by message domain.\\n               Example:\\n               ['messages' = ['Hello' => 'Hello', 'Apple' => 'Apple'], 'customdomain' => ['One' => 'One']]\\n",Izvlači prevodive stringove iz datog fajla.,"protected function extractStrings($file)    {        $content = file_get_contents($file);        // collect pairs of [$domain, string] from all matches        $pairs = [];        // vue matches {{ 'foo' | trans [args] }}        preg_match_all('/({{\s*(\'|"")((?:(?!\2).)+)\2\s*\|\s*trans\s+([^\s]+\s+((\'|"")((?:(?!\6).)+)\6))?.*}})/', $content, $matches);        foreach ($matches[3] as $i => $string) {            $domain = $matches[7][$i] ?: 'messages';            $pairs[] = [$domain, $string];        }        // vue matches {{ 'foo' | transChoice [args] }}        preg_match_all('/({{\s*(\'|"")((?:(?!\2).)+)\2\s*\|\s*transChoice\s+([^\s]+\s+[^\s]+\s+((\'|"")((?:(?!\6).)+)\6))?.*}})/', $content, $matches);        foreach ($matches[3] as $i => $string) {            $domain = $matches[7][$i] ?: 'messages';            $pairs[] = [$domain, $string];        }        // vue, js files        // $trans('foo', [args])        // $transChoice('foo'[, args])        preg_match_all('/\$trans(Choice)?\((\'|"")((?:(?!\2).)+)\2/', $content, $matches);        foreach ($matches[3] as $i => $string) {            $domain = 'messages'; // TODO: allow custom domain            $pairs[] = [$domain, $string];        }        // php matches ...->trans('foo'[, args]) or __('foo'[, args])        // php matches ...->transChoice('foo'[, args]) or _c('foo'[, args])        $this->visitor->traverse([$file]);        foreach ($this->visitor->results as $domain => $strings) {            foreach ($strings as $string => $attr) {                $pairs[] = [$domain, $string];            }        }        // group strings by message domain        $messages = [];        foreach ($pairs as $pair) {            list($domain, $string) = $pair;            if (!isset($messages[$domain])) {                $messages[$domain] = [];            }            $messages[$domain][$string] = $string;        }        return $messages;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
paragonie_random_compat_libsodium_735,Generate an unbiased random integer between 0 and a specified value\n /dev/urandom\n\n @param int $upperBoundNonInclusive\n @return int\n,Proizvodi nepristrasan nasumičan ceo broj između 0 i zadate vrednosti.,        function randombytes_uniform(,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
paragonie_random_compat_random_int_729, Fetch a random integer between $min and $max inclusive\\n\\n @param int $min\\n @param int $max\\n\\n @throws Exception\\n\\n @return int\\n,Dostavlja nasumičan ceo broj između i uključujući min i max ,"function random_int($min, $max)    {        /**         * Type and input logic checks         *         * If you pass it a float in the range (~PHP_INT_MAX, PHP_INT_MAX)         * (non-inclusive), it will sanely cast it to an int. If you it's equal to         * ~PHP_INT_MAX or PHP_INT_MAX, we let it fail as not an integer. Floats         * lose precision, so the <= and => operators might accidentally let a float         * through.         */        try {            /** @var int $min */            $min = RandomCompat_intval($min);        } catch (TypeError $ex) {            throw new TypeError(                'random_int(): $min must be an integer'            );        }        try {            /** @var int $max */            $max = RandomCompat_intval($max);        } catch (TypeError $ex) {            throw new TypeError(                'random_int(): $max must be an integer'            );        }        /**         * Now that we've verified our weak typing system has given us an integer,         * let's validate the logic then we can move forward with generating random         * integers along a given range.         */        if ($min > $max) {            throw new Error(                'Minimum value must be less than or equal to the maximum value'            );        }        if ($max === $min) {            return (int) $min;        }        /**         * Initialize variables to 0         *         * We want to store:         * $bytes => the number of random bytes we need         * $mask => an integer bitmask (for use with the &) operator         *          so we can minimize the number of discards         */        $attempts = $bits = $bytes = $mask = $valueShift = 0;        /** @var int $attempts */        /** @var int $bits */        /** @var int $bytes */        /** @var int $mask */        /** @var int $valueShift */        /**         * At this point, $range is a positive number greater than 0. It might         * overflow, however, if $max - $min > PHP_INT_MAX. PHP will cast it to         * a float and we will lose some precision.         *         * @var int|float $range         */        $range = $max - $min;        /**         * Test for integer overflow:         */        if (!is_int($range)) {            /**             * Still safely calculate wider ranges.             * Provided by @CodesInChaos, @oittaa             *             * @ref https://gist.github.com/CodesInChaos/03f9ea0b58e8b2b8d435             *             * We use ~0 as a mask in this case because it generates all 1s             *             * @ref https://eval.in/400356 (32-bit)             * @ref http://3v4l.org/XX9r5  (64-bit)             */            $bytes = PHP_INT_SIZE;            /** @var int $mask */            $mask = ~0;        } else {            /**             * $bits is effectively ceil(log($range, 2)) without dealing with             * type juggling             */            while ($range > 0) {                if ($bits % 8 === 0) {                    ++$bytes;                }                ++$bits;                $range >>= 1;                /** @var int $mask */                $mask = $mask << 1 | 1;            }            $valueShift = $min;        }        /** @var int $val */        $val = 0;        /**         * Now that we have our parameters set up, let's begin generating         * random integers until one falls between $min and $max         */        /** @psalm-suppress RedundantCondition */        do {            /**             * The rejection probability is at most 0.5, so this corresponds             * to a failure probability of 2^-128 for a working RNG             */            if ($attempts > 128) {                throw new Exception(                    'random_int: RNG is broken - too many rejections'                );            }            /**             * Let's grab the necessary number of random bytes             */            $randomByteString = random_bytes($bytes);            /**             * Let's turn $randomByteString into an integer             *             * This uses bitwise operators (<< and |) to build an integer             * out of the values extracted from ord()             *             * Example: [9F] | [6D] | [32] | [0C] =>             *   159 + 27904 + 3276800 + 201326592 =>             *   204631455             */            $val &= 0;            for ($i = 0; $i < $bytes; ++$i) {                $val |= ord($randomByteString[$i]) << ($i * 8);            }            /** @var int $val */            /**             * Apply mask             */            $val &= $mask;            $val += $valueShift;            ++$attempts;            /**             * If $val overflows to a floating point number,             * ... or is larger than $max,             * ... or smaller than $min,             * then try again.             */        } while (!is_int($val) || $val > $max || $val < $min);        return (int) $val;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_AphrontRequest_648," Determine if security policy rules will allow cookies to be set when\\n responding to the request.\\n\\n @return bool True if setCookie() will succeed. If this method returns\\n              false, setCookie() will throw.\\n\\n @task cookie\\n",Proveri da li bezbednosna politika dozvoljava postavljanje kolačića prilikom odgovora na zahtev.,  public function canSetCookies() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_AphrontRequest_649," Set a cookie which does not expire for a long time.\\n\\n To set a temporary cookie, see @{method:setTemporaryCookie}.\\n\\n @param string  Cookie name.\\n @param string  Cookie value.\\n @return this\\n @task cookie\\n",Postavi kolačić koji neće isteći dugo vremena. Za postavljanje privremenog kolačića pogledaj metod setTemporaryCookie,"  public function setCookie($name, $value) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_AphrontRequest_650," Set a cookie which expires soon.\n\n To set a durable cookie, see @{method:setCookie}.\n\n @param string  Cookie name.\n @param string  Cookie value.\n @return this\n @task cookie\n",Postavi kolačić koji će uskoro isteći. Za postavljanje dugotrajnog kolačića pogledaj setCookie.,"  public function setTemporaryCookie($name, $value) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_Figlet_519, Function loads one character in the internal array from file\n\n @param resource &$fp handle of font file\n\n @return mixed lines of the character or false if foef occured\n @access private\n,Funkcija učitava jedan karakter u svoj niz iz fajla.,"function _char(&$fp)    {        $out = array();        for ($i = 0; $i < $this->height; $i++) {            if (feof($fp)) {                return false;            }            $line = rtrim(fgets($fp, 2048), ""\r\n"");            if (preg_match('/(.){1,2}$/', $line, $r)) {                $line = str_replace($r[1], '', $line);            }            $line .= ""\x00"";            $out[] = $line;        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_525,"Check that a string looks roughly like an email address should\n Static so it can be used without instantiation\n Tries to use PHP built-in validator in the filter extension (from PHP 5.2), falls back to a reasonably competent regex validator\n Conforms approximately to RFC2822\n @link http://www.hexillion.com/samples/#Regex Original pattern found here\n @param string $address The email address to check\n @return boolean\n @static\n @access public\n","Proveri da li string izgleda otprilike kako bi email adresa trebalo da izgleda. Statičan kako bi mogao da se koristi bez instanciranja. Pokušava da koristi ugrađeni validator, ali u slučaju da ne može da ga koristi, uzima razumno složen regex validator.","public static function ValidateAddress($address) {    if (function_exists('filter_var')) { //Introduced in PHP 5.2      if(filter_var($address, FILTER_VALIDATE_EMAIL) === FALSE) {        return false;      } else {        return true;      }    } else {      return preg_match('/^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!\.)){0,61}[a-zA-Z0-9_-]?\.)+[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!$)){0,61}[a-zA-Z0-9_]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/', $address);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_536, Assembles the message body.  Returns an empty string on failure.\\n @access public\\n @return string The assembled message body\\n,"Sastavlja telo poruke. Ako ne uspe, vraća prazan string.",  public function CreateBody() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_540,  Returns a formatted header line.\n @access public\n @return string\n,Vraća formatirano zaglavlje.,"  public function HeaderLine($name, $value) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_543," Attaches all fs, string, and binary attachments to the message.\\n Returns an empty string on failure.\\n @access private\\n @return string\\n","Spaja sve funkcije, stringove i binarne priloge u poruci.",  private function AttachAll() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_class.phpmailer-lite_544, Checks if a string contains multibyte characters.\n @access public\n @param string $str multi-byte text to wrap encode\n @return bool\n,Proverava da li string sadrži višebajtske karaktere,"  public function HasMultiBytes($str) {    if (function_exists('mb_strlen')) {      return (strlen($str) > mb_strlen($str, $this->CharSet));    } else { // Assume no multibytes (we can't handle without mbstring functions anyway)      return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_448,Compute the number of bits in an int.\n The normal answer for JavaScript is 32.\n @return {number} Max bits\n,Računa broj bitova u celom broju. Uobičajen odgovor za javascript je 32,function getMaxBits() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_451, Split a text into an array of strings.  Reduce the texts to a string of\n hashes where each Unicode character represents one line.\n Modifies linearray and linehash through being a closure.\n @param {string} text String to encode\n @return {string} Encoded string\n @private\n,Deli tekst u niz stringova. Zatim smanjuje tekst u string hešova gde svaki karakter odgovara jednoj liniji.,"function diff_linesToCharsMunge($text, &$lineArray, &$lineHash) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_453,Explore the intersection points between the two texts.\n @param {string} text1 Old string to be diffed.\n @param {string} text2 New string to be diffed.\n @return {Array.<Array.<number|string>>?} Array of diff tuples or null if no\n     diff available.\n @private\n,Razmatra presek između dva teksta.,"function diff_map($text1, $text2) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_456,Determine the common prefix of two strings\\n @param {string} text1 First string.\\n @param {string} text2 Second string.\\n @return {number} The number of characters common to the start of each\\n     string.\\n,Nalazi zajednički prefiks za dva stringa.,"function diff_commonPrefix($text1, $text2) {for ($i = 0; 1; $i++) {$t1 = mb_substr($text1, $i, 1);$t2 = mb_substr($text2, $i, 1);if($t1==='' || $t2==='' || $t1 !== $t2 ){return $i;}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_466, Convert a diff array into a pretty HTML report.\n @param {Array.<Array.<number|string>>} diffs Array of diff tuples.\n @return {string} HTML representation.\n,Prevara razliku nizova u lep HTML izveštaj,function diff_prettyHtml($diffs) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_469," Compute the Levenshtein distance; the number of inserted, deleted or\\n substituted characters.\\n @param {Array.<Array.<number|string>>} diffs Array of diff tuples.\\n @return {number} Number of changes.\\n","Računa levenshteinovu udaljenost. To je broj dodatih, obrisanih ili zamenjenih karaktera.",function diff_levenshtein($diffs) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_470,"Crush the diff into an encoded string which describes the operations\n required to transform text1 into text2.\n E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n Operations are tab-separated.  Inserted text is escaped using %xx notation.\n @param {Array.<Array.<number|string>>} diffs Array of diff tuples.\n @return {string} Delta text.\n","Predstavlja razliku kao enkodovan string koji opisuje operacije potrebne da se tekst1 transformiše u tekst2. Na primer =3\\t-2\\t+ing znači zadrži 3 karaktera, obriši dva karaktera i dodaj ing. Operacije su odvojene tabovima.",function diff_toDelta($diffs) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phacility_phabricator_diff_match_patch_471,"Given the original text1, and an encoded string which describes the\n operations required to transform text1 into text2, compute the full diff.\n @param {string} text1 Source string for the diff.\n @param {string} delta Delta text.\n @return {Array.<Array.<number|string>>} Array of diff tuples.\n @throws {Error} If invalid input.\n",Za originalni tekst i enkodiran string razlika računa razliku između dva teksta.,"function diff_fromDelta($text1, $delta) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Optimized_172, Delete all files in target directories\n,Obriši sve fajlove u ciljnim direktorijima.,    public function cleanBuildDirectories()    {        foreach ($this->settings as $setting) {            Util::cleanDirectory($setting['dir']);        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
phalcon_cphalcon_Util_1227, Recursively deletes everything in the directory\\n\\n @param string $dir\\n,Rekurzivno briše sve u direktorijumu.,    public static function cleanDirectory(string $dir): void    {        $iterator = new DirectoryIterator($dir);        foreach ($iterator as $entry) {            /** @var $entry DirectoryIterator */            if ($entry->isDot() || $entry->getBasename() == 'tests') {                continue;            }            if ($entry->isDir() && !$entry->isLink()) {                self::cleanDirectory($entry->getPathname());                rmdir($entry->getPathname());            } else {                if (is_writable($dir)) {                    unlink($entry->getPathname());                }            }        }    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-fig_http-message_MessageInterface_2409,"Retrieves the HTTP protocol version as a string.\\n\\n The string MUST contain only the HTTP version number (e.g., ""1.1"", ""1.0"").\\n\\n @return string HTTP protocol version.\\n","Dohvata HTTP protokol verziju kao string. String mora da sadrži samo verziju HTTP-a, na primer 1.1 ili 1.0.",    public function getProtocolVersion();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-fig_http-message_MessageInterface_2412, Checks if a header exists by the given case-insensitive name.\\n\\n @param string $name Case-insensitive header field name.\\n @return bool Returns true if any header names match the given header\\n     name using a case-insensitive string comparison. Returns false if\\n     no matching header name is found in the message.\\n,Proverava da li zaglavlje postoji za dato ime nevezano za mala ili velika slova.,    public function hasHeader($name);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
php-fig_http-message_ResponseInterface_2425,Gets the response status code.\n\n The status code is a 3-digit integer result code of the server's attempt\n to understand and satisfy the request.\n\n @return int Status code.\n,Vraća status odgovora. Status je trocifreni ceo broj i rezultat je pokušaja servera da razume i zadovolji zahtev.,    public function getStatusCode();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_Client_2129, Closes the underlying connection and disconnects from the server.\n,Zatvara osnovnu vezu i otkačuje se sa servera.,    public function disconnect()    {        $this->connection->disconnect();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_Client_2131, Returns the current state of the underlying connection.\n\n @return bool\n,Vraća trenutno stanje osnovne veze.,    public function isConnected()    {        return $this->connection->isConnected();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
predis_predis_CommunicationException_2151, Base exception class for network-related errors.\n\n @author Daniele Alessandri <suppakilla@gmail.com>\n,Osnovna klasa izuzetaka za greške vezane za mrežu.,"abstract class CommunicationException extends PredisException{    private $connection;    /**     * @param NodeConnectionInterface $connection     Connection that generated the exception.     * @param string                  $message        Error message.     * @param int                     $code           Error code.     * @param \Exception              $innerException Inner exception for wrapping the original error.     */    public function __construct(        NodeConnectionInterface $connection,        $message = null,        $code = null,        \Exception $innerException = null    ) {        $this->connection = $connection;        parent::__construct($message, $code, $innerException);    }    /**     * Gets the connection that generated the exception.     *     * @return NodeConnectionInterface     */    public function getConnection()    {        return $this->connection;    }    /**     * Indicates if the receiver should reset the underlying connection.     *     * @return bool     */    public function shouldResetConnection()    {        return true;    }    /**     * Helper method to handle exceptions generated by a connection object.     *     * @param CommunicationException $exception Exception.     *     * @throws CommunicationException     */    public static function handle(CommunicationException $exception)    {        if ($exception->shouldResetConnection()) {            $connection = $exception->getConnection();            if ($connection->isConnected()) {                $connection->disconnect();            }        }        throw $exception;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_ArrayComparator_2322, Compares arrays for equality.\\n\\n Arrays are equal if they contain the same key-value pairs.\\n The order of the keys does not matter.\\n The types of key-value pairs do not matter.\\n,Poredi nizove. Nizovi su jednaki ako sadrže iste ključ-vrednost parove. Redosled ključeva nije bitan. Tipovi ključ-vrednost parova nisu bitni.,"class ArrayComparator extends Comparator{    /**     * Returns whether the comparator can compare two values.     *     * @param mixed $expected The first value to compare     * @param mixed $actual   The second value to compare     *     * @return bool     */    public function accepts($expected, $actual)    {        return is_array($expected) && is_array($actual);    }    /**     * Asserts that two arrays are equal.     *     * @param mixed $expected     First value to compare     * @param mixed $actual       Second value to compare     * @param float $delta        Allowed numerical distance between two values to consider them equal     * @param bool  $canonicalize Arrays are sorted before comparison when set to true     * @param bool  $ignoreCase   Case is ignored when set to true     * @param array $processed    List of already processed elements (used to prevent infinite recursion)     *     * @throws ComparisonFailure     */    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = false, $ignoreCase = false, array &$processed = [])/*: void*/    {        if ($canonicalize) {            sort($expected);            sort($actual);        }        $remaining        = $actual;        $actualAsString   = ""Array (\n"";        $expectedAsString = ""Array (\n"";        $equal            = true;        foreach ($expected as $key => $value) {            unset($remaining[$key]);            if (!array_key_exists($key, $actual)) {                $expectedAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $this->exporter->shortenedExport($value)                );                $equal = false;                continue;            }            try {                $comparator = $this->factory->getComparatorFor($value, $actual[$key]);                $comparator->assertEquals($value, $actual[$key], $delta, $canonicalize, $ignoreCase, $processed);                $expectedAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $this->exporter->shortenedExport($value)                );                $actualAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $this->exporter->shortenedExport($actual[$key])                );            } catch (ComparisonFailure $e) {                $expectedAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $e->getExpectedAsString() ? $this->indent($e->getExpectedAsString()) : $this->exporter->shortenedExport($e->getExpected())                );                $actualAsString .= sprintf(                    ""    %s => %s\n"",                    $this->exporter->export($key),                    $e->getActualAsString() ? $this->indent($e->getActualAsString()) : $this->exporter->shortenedExport($e->getActual())                );                $equal = false;            }        }        foreach ($remaining as $key => $value) {            $actualAsString .= sprintf(                ""    %s => %s\n"",                $this->exporter->export($key),                $this->exporter->shortenedExport($value)            );            $equal = false;        }        $expectedAsString .= ')';        $actualAsString .= ')';        if (!$equal) {            throw new ComparisonFailure(                $expected,                $actual,                $expectedAsString,                $actualAsString,                false,                'Failed asserting that two arrays are equal.'            );        }    }    protected function indent($lines)    {        return trim(str_replace(""\n"", ""\n    "", $lines));    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_comparator_DateTimeComparator_2336,Returns an ISO 8601 formatted string representation of a datetime or\n 'Invalid DateTimeInterface object' if the provided DateTimeInterface was not properly\n initialized.\n,"Vraća ISO 8601 formatiran string koji predstavlja datum i vreme, odnosno ‘Invalid DateTimeInterface object’ ukoliko dat DateTimeInterface nije pravilno inicijalizovan.",    private function dateTimeToString(DateTimeInterface $datetime): string    {        $string = $datetime->format('Y-m-d\TH:i:s.uO');        return $string ?: 'Invalid DateTimeInterface object';    },0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
sebastianbergmann_exporter_Exporter_1036," Converts an object to an array containing all of its private, protected\\\\n and public properties.\\\\n","Pretvara objekat u niz koji sadrži sve privatne, zaštićene i javne osobine.","public function toArray(mixed $value): array    {        if (!is_object($value)) {            return (array) $value;        }        $array = [];        foreach ((array) $value as $key => $val) {            // Exception traces commonly reference hundreds to thousands of            // objects currently loaded in memory. Including them in the result            // has a severe negative performance impact.            if (""\0Error\0trace"" === $key || ""\0Exception\0trace"" === $key) {                continue;            }            // properties are transformed to keys in the following way:            // private   $property => ""\0Classname\0property""            // protected $property => ""\0*\0property""            // public    $property => ""property""            if (preg_match('/^\0.+\0(.+)$/', (string) $key, $matches)) {                $key = $matches[1];            }            // See https://github.com/php/php-src/commit/5721132            if ($key === ""\0gcdata"") {                continue;            }            $array[$key] = $val;        }        // Some internal classes like SplObjectStorage don't work with the        // above (fast) mechanism nor with reflection in Zend.        // Format the output similarly to print_r() in this case        if ($value instanceof SplObjectStorage) {            foreach ($value as $_value) {                $array[spl_object_hash($_value)] = [                    'obj' => $_value,                    'inf' => $value->getInfo(),                ];            }        }        return $array;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1133," Retrieves a particular header. If it doesn\\\'t exist, no exception/error is caused.\\n Simply null is returned.\\n\\n @param string $header The name of the header to retrieve. Can be HTTP compliant such as\\n                       ""User-Agent"" or ""X-Device-User-Agent"" or can be php-esque with the\\n                       all-caps, HTTP_ prefixed, underscore seperated awesomeness.\\n\\n @return string|null The value of the header.\\n","Vraća određeno zaglavlje. Ako ne postoji, ne prijavljuje se greška ili izuzetak već se jednostavno vrati null vrednost.","    public function getHttpHeader($header)    {        // are we using PHP-flavored headers?        if (strpos($header, '_') === false) {            $header = str_replace('-', '_', $header);            $header = strtoupper($header);        }        // test the alternate, too        $altHeader = 'HTTP_' . $header;        //Test both the regular and the HTTP_ prefix        if (isset($this->httpHeaders[$header])) {            return $this->httpHeaders[$header];        } elseif (isset($this->httpHeaders[$altHeader])) {            return $this->httpHeaders[$altHeader];        }        return null;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
serbanghita_Mobile-Detect_Mobile_Detect_1147, Check the HTTP headers for signs of mobile.\\n This is the fastest mobile check possible; it's used\\n inside isMobile() method.\\n\\n @return bool\\n,Proveri HTTP zaglavlja za znak mobilnosti. Ovo je najvbrža provera mobilnosti.,"    public function checkHttpHeadersForMobile()    {        foreach ($this->getMobileHeaders() as $mobileHeader => $matchType) {            if (isset($this->httpHeaders[$mobileHeader])) {                if (isset($matchType['matches']) && is_array($matchType['matches'])) {                    foreach ($matchType['matches'] as $_match) {                        if (strpos($this->httpHeaders[$mobileHeader], $_match) !== false) {                            return true;                        }                    }                    return false;                } else {                    return true;                }            }        }        return false;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
slimphp_Slim_PhpFunctionOverrides_2774, Have headers been sent?\n\n @return false\n,Da li su zaglavlja već poslata?,function headers_sent(){    return false;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
slimphp_Slim_PhpFunctionOverrides_2775, Allows the mocking of invalid HTTP states.\n\n @return int\n,Omogućava oponašanje nevažećih HTTP stanja,function connection_status(){    if (isset($GLOBALS['connection_status_return'])) {        return $GLOBALS['connection_status_return'];    }    return \connection_status();},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_File_925, Remove vars stored in this file that are no longer required.\\\\n\\\\n @return void\\\\n,Uklanja promenljive sačuvane u ovom fajlu koje više nisu potrebne.,    public function cleanUp()    {        $this->listenerTimes = null;        $this->content       = null;        $this->tokens        = null;        $this->metricTokens  = null;        $this->tokenizer     = null;        $this->fixer         = null;        $this->config        = null;        $this->ruleset       = null;    }//end cleanUp(),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
squizlabs_PHP_CodeSniffer_Runner_912," Converts all PHP errors into exceptions.\\\\n\\\\n This method forces a sniff to stop processing if it is not\\\\n able to handle a specific piece of code, instead of continuing\\\\n and potentially getting into a loop.\\\\n\\\\n @param int    $code    The level of error raised.\\\\n @param string $message The error message.\\\\n @param string $file    The path of the file that raised the error.\\\\n @param int    $line    The line number the error was raised at.\\\\n\\\\n @return void\\\\n @throws \\\\\\\\PHP_CodeSniffer\\\\\\\\Exceptions\\\\\\\\RuntimeException\\\\n",Pretvara sve PHP greške u izuzetke. Ovaj metod prisiljava sniff da prestane procesiranje ako nije u stanju da rukuje specifičnim delom koda umesto da nastavlja i potencijalno upadne u petlju.,"public function handleErrors($code, $message, $file, $line)    {        if ((error_reporting() & $code) === 0) {            // This type of error is being muted.            return true;        }        throw new RuntimeException(""$message in $file on line $line"");    }//end handleErrors()",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_AddressEncoder_1289, Encodes an email address.\\n\\n @throws Swift_AddressEncoderException if the email cannot be represented in\\n                                       the encoding implemented by this class\\n,Enkodira email adresu.,    public function encodeString(string $address): string;,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
swiftmailer_swiftmailer_CharacterReader_1621,Returns an integer which specifies how many more bytes to read.\n\n A positive integer indicates the number of more bytes to fetch before invoking\n this method again.\n\n A value of zero means this is already a valid character.\n A value of -1 means this cannot possibly be a valid character.\n\n @param int[] $bytes\n @param int   $size\n\n @return int\n,"Vraća ceo broj koji govori koliko je još bajtova ostalo da se pročita. Pozitivan ceo broj govori koliko još bajtova treba dohvatiti pre ponovnog poziva ovog metoda. Vrednost nula govori da je u pitanju validan karakter, a vrednost -1 govori da nema šanse da je u pitanju validan karakter.","    public function validateByteSequence($bytes, $size);",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_1747, Gets the HTML content associated with the given exception.\n\n @return string The content as a string\n,Dohvata HTML sadržaj koji odgovara datom izuzetku.,"public function getContent(FlattenException $exception)    {        switch ($exception->getStatusCode()) {            case 404:                $title = 'Sorry, the page you are looking for could not be found.';                break;            default:                $title = $this->debug ? $this->escapeHtml($exception->getMessage()) : 'Whoops, looks like something went wrong.';        }        if (!$this->debug) {            return <<<EOF                <div class=""container"">                    <h1>$title</h1>                </div>EOF;        }        $content = '';        try {            $count = \count($exception->getAllPrevious());            $total = $count + 1;            foreach ($exception->toArray() as $position => $e) {                $ind = $count - $position + 1;                $class = $this->formatClass($e['class']);                $message = nl2br($this->escapeHtml($e['message']));                $content .= sprintf(<<<'EOF'                    <div class=""trace trace-as-html"">                        <table class=""trace-details"">                            <thead class=""trace-head""><tr><th>                                <h3 class=""trace-class"">                                    <span class=""text-muted"">(%d/%d)</span>                                    <span class=""exception_title"">%s</span>                                </h3>                                <p class=""break-long-words trace-message"">%s</p>                            </th></tr></thead>                            <tbody>EOF                    , $ind, $total, $class, $message);                foreach ($e['trace'] as $trace) {                    $content .= '<tr><td>';                    if ($trace['function']) {                        $content .= sprintf('at <span class=""trace-class"">%s</span><span class=""trace-type"">%s</span><span class=""trace-method"">%s</span>', $this->formatClass($trace['class']), $trace['type'], $trace['function']);                        if (isset($trace['args'])) {                            $content .= sprintf('(<span class=""trace-arguments"">%s</span>)', $this->formatArgs($trace['args']));                        }                    }                    if (isset($trace['file']) && isset($trace['line'])) {                        $content .= $this->formatPath($trace['file'], $trace['line']);                    }                    $content .= ""</td></tr>\n"";                }                $content .= ""</tbody>\n</table>\n</div>\n"";            }        } catch (\Exception $e) {            // something nasty happened and we cannot throw an exception anymore            if ($this->debug) {                $e = FlattenException::create($e);                $title = sprintf('Exception thrown when handling an exception (%s: %s)', $e->getClass(), $this->escapeHtml($e->getMessage()));            } else {                $title = 'Whoops, looks like something went wrong.';            }        }        $symfonyGhostImageContents = $this->getSymfonyGhostAsSvg();        return <<<EOF            <div class=""exception-summary"">                <div class=""container"">                    <div class=""exception-message-wrapper"">                        <h1 class=""break-long-words exception-message"">$title</h1>                        <div class=""exception-illustration hidden-xs-down"">$symfonyGhostImageContents</div>                    </div>                </div>            </div>            <div class=""container"">                $content            </div>EOF;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_debug_ExceptionHandler_1750, HTML-encodes a string.\n,Enkodira string za HTML.,"    private function escapeHtml(string $str): string    {        return htmlspecialchars($str, \ENT_COMPAT | \ENT_SUBSTITUTE, $this->charset);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1094," Excludes ""hidden"" directories and files (starting with a dot).\n\n This option is enabled by default.\n\n @return $this\n\n @see ExcludeDirectoryFilterIterator\n",Odstranjuje skrivene direktorijume i fajlove (sve koji počinju tačkom). Ova opcija je podrazumevano omogućena.,    public function ignoreDotFiles(bool $ignoreDotFiles)    {        if ($ignoreDotFiles) {            $this->ignore |= static::IGNORE_DOT_FILES;        } else {            $this->ignore &= ~static::IGNORE_DOT_FILES;        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_Finder_1099," Sorts files and directories by type (directories before files), then by name.\n\n This can be slow as all the matching files and directories must be retrieved for comparison.\n\n @return $this\n\n @see SortableIterator\n","Sortira fajlove i direktorijume po tipu (direktorijumi pre fajlova), pa onda po imenu. Ovo može biti sporo jer svi fajlovi i direktorijumi moraju biti dohvaćeni zarad poređenja.",    public function sortByType()    {        $this->sort = Iterator\SortableIterator::SORT_BY_TYPE;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_MultiplePcreFilterIterator_1155," Checks whether the string is accepted by the regex filters.\n\n If there is no regexps defined in the class, this method will accept the string.\n Such case can be handled by child classes before calling the method if they want to\n apply a different behavior.\n\n @return bool\n","Proverava da li je string prihvaćen od regex filtera. Ako nema regexps definisanih u klasi, ovaj metod će prihvatiti string. ","    protected function isAccepted(string $string)    {        // should at least not match one rule to exclude        foreach ($this->noMatchRegexps as $regex) {            if (preg_match($regex, $string)) {                return false;            }        }        // should at least match one rule        if ($this->matchRegexps) {            foreach ($this->matchRegexps as $regex) {                if (preg_match($regex, $string)) {                    return true;                }            }            return false;        }        // If there is no match rules, the file is accepted        return true;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_MultiplePcreFilterIterator_1156, Checks whether the string is a regex.\n\n @return bool\n,Proverava da li je string regex.,"protected function isRegex(string $str)    {        if (preg_match('/^(.{3,}?)[imsxuADU]*$/', $str, $m)) {            $start = substr($m[1], 0, 1);            $end = substr($m[1], -1);            if ($start === $end) {                return !preg_match('/[*?[:alnum:] \\\\]/', $start);            }            foreach ([['{', '}'], ['(', ')'], ['[', ']'], ['<', '>']] as $delimiters) {                if ($start === $delimiters[0] && $end === $delimiters[1]) {                    return true;                }            }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_MultiplePcreFilterIterator_1157, Converts string into regexp.\n\n @return string\n,Pretvara string u regexp.,    abstract protected function toRegex(string $str);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_SplFileInfo_1119, Returns the contents of the file.\n\n @return string the contents of the file\n\n @throws \\RuntimeException\n,Vraća sadržaj fajla.,"    public function getContents()    {        set_error_handler(function ($type, $msg) use (&$error) { $error = $msg; });        $content = file_get_contents($this->getPathname());        restore_error_handler();        if (false === $content) {            throw new \RuntimeException($error);        }        return $content;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_finder_SplFileInfo_383, Returns the relative path name.\\n\\n This path contains the file name.\\n\\n @return string the relative path name\\n,Vraća relativan naziv putanje. Ovaj naziv sadrži naziv fajla.,    public function getRelativePathname()    {        return $this->relativePathname;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeaderItem_9687, Returns header value's string representation.\n\n @return string\n,Vraća vrednost zaglavlja u obliku stringa.,"public function __toString()    {        $string = $this->value.($this->quality < 1 ? ';q='.$this->quality : '');        if (\count($this->attributes) > 0) {            $string .= '; '.HeaderUtils::toString($this->attributes, ';');        }        return $string;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_AcceptHeader_8728, Tests if header has given value.\n\n @return bool\n,Proverava da li zaglavlje sadrži datu vrednost.,    public function has(string $value)    {        return isset($this->items[$value]);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_IpUtils_8806,Anonymizes an IP/IPv6.\n\n Removes the last byte for v4 and the last 8 bytes for v6 IPs\n,"Anonimizira IP/IPv6. Uklanja poslednji bajt za v4, a poslednjih 8 bajtova za v6 IP-jeve.","public static function anonymize(string $ip): string    {        $wrappedIPv6 = false;        if ('[' === substr($ip, 0, 1) && ']' === substr($ip, -1, 1)) {            $wrappedIPv6 = true;            $ip = substr($ip, 1, -1);        }        $packedAddress = inet_pton($ip);        if (4 === \strlen($packedAddress)) {            $mask = '255.255.255.0';        } elseif ($ip === inet_ntop($packedAddress & inet_pton('::ffff:ffff:ffff'))) {            $mask = '::ffff:ffff:ff00';        } elseif ($ip === inet_ntop($packedAddress & inet_pton('::ffff:ffff'))) {            $mask = '::ffff:ff00';        } else {            $mask = 'ffff:ffff:ffff:ffff:0000:0000:0000:0000';        }        $ip = inet_ntop($packedAddress & inet_pton($mask));        if ($wrappedIPv6) {            $ip = '['.$ip.']';        }        return $ip;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_JsonResponse_7891, Returns options used while encoding data to JSON.\n\n @return int\n,Vraća koje su opcije korišćene kada su podaci enkodirani u JSON.,    public function getEncodingOptions()    {        return $this->encodingOptions;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_JsonResponse_9757, Response represents an HTTP response in JSON format.\n\n Note that this class does not force the returned JSON content to be an\n object. It is however recommended that you do return an object as it\n protects yourself against XSSI and JSON-JavaScript Hijacking.\n\n @see https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md#always-return-json-with-an-object-on-the-outside\n\n @author Igor Wiedler <igor@wiedler.ch>\n,"Predstava HTTP odgovora u JSON formatu. Bitno je naglasiti da ova klasa ne zahteva da JSON sadržaj bude objekat, ali je preporučljivo da vratite objekat kako bi se izbeglo XSSI i JSON-JavaScript otimanje.","class JsonResponse extends Response{    protected $data;    protected $callback;    // Encode <, >, ', &, and "" characters in the JSON, making it also safe to be embedded into HTML.    // 15 === JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT    public const DEFAULT_ENCODING_OPTIONS = 15;    protected $encodingOptions = self::DEFAULT_ENCODING_OPTIONS;    /**     * @param mixed $data    The response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     * @param bool  $json    If the data is already a JSON string     */    public function __construct($data = null, int $status = 200, array $headers = [], bool $json = false)    {        parent::__construct('', $status, $headers);        if ($json && !\is_string($data) && !is_numeric($data) && !\is_callable([$data, '__toString'])) {            throw new \TypeError(sprintf('""%s"": If $json is set to true, argument $data must be a string or object implementing __toString(), ""%s"" given.', __METHOD__, get_debug_type($data)));        }        if (null === $data) {            $data = new \ArrayObject();        }        $json ? $this->setJson($data) : $this->setData($data);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::create(['key' => 'value'])     *         ->setSharedMaxAge(300);     *     * @param mixed $data    The JSON response data     * @param int   $status  The response status code     * @param array $headers An array of response headers     *     * @return static     *     * @deprecated since Symfony 5.1, use __construct() instead.     */    public static function create($data = null, int $status = 200, array $headers = [])    {        trigger_deprecation('symfony/http-foundation', '5.1', 'The ""%s()"" method is deprecated, use ""new %s()"" instead.', __METHOD__, static::class);        return new static($data, $status, $headers);    }    /**     * Factory method for chainability.     *     * Example:     *     *     return JsonResponse::fromJsonString('{""key"": ""value""}')     *         ->setSharedMaxAge(300);     *     * @param string $data    The JSON response string     * @param int    $status  The response status code     * @param array  $headers An array of response headers     *     * @return static     */    public static function fromJsonString(string $data, int $status = 200, array $headers = [])    {        return new static($data, $status, $headers, true);    }    /**     * Sets the JSONP callback.     *     * @param string|null $callback The JSONP callback or null to use none     *     * @return $this     *     * @throws \InvalidArgumentException When the callback name is not valid     */    public function setCallback(string $callback = null)    {        if (null !== $callback) {            // partially taken from https://geekality.net/2011/08/03/valid-javascript-identifier/            // partially taken from https://github.com/willdurand/JsonpCallbackValidator            //      JsonpCallbackValidator is released under the MIT License. See https://github.com/willdurand/JsonpCallbackValidator/blob/v1.1.0/LICENSE for details.            //      (c) William Durand <william.durand1@gmail.com>            $pattern = '/^[$_\p{L}][$_\p{L}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\x{200C}\x{200D}]*(?:\[(?:""(?:\\\.|[^""\\\])*""|\'(?:\\\.|[^\'\\\])*\'|\d+)\])*?$/u';            $reserved = [                'break', 'do', 'instanceof', 'typeof', 'case', 'else', 'new', 'var', 'catch', 'finally', 'return', 'void', 'continue', 'for', 'switch', 'while',                'debugger', 'function', 'this', 'with', 'default', 'if', 'throw', 'delete', 'in', 'try', 'class', 'enum', 'extends', 'super',  'const', 'export',                'import', 'implements', 'let', 'private', 'public', 'yield', 'interface', 'package', 'protected', 'static', 'null', 'true', 'false',            ];            $parts = explode('.', $callback);            foreach ($parts as $part) {                if (!preg_match($pattern, $part) || \in_array($part, $reserved, true)) {                    throw new \InvalidArgumentException('The callback name is not valid.');                }            }        }        $this->callback = $callback;        return $this->update();    }    /**     * Sets a raw string containing a JSON document to be sent.     *     * @return $this     */    public function setJson(string $json)    {        $this->data = $json;        return $this->update();    }    /**     * Sets the data to be sent as JSON.     *     * @param mixed $data     *     * @return $this     *     * @throws \InvalidArgumentException     */    public function setData($data = [])    {        try {            $data = json_encode($data, $this->encodingOptions);        } catch (\Exception $e) {            if ('Exception' === \get_class($e) && 0 === strpos($e->getMessage(), 'Failed calling ')) {                throw $e->getPrevious() ?: $e;            }            throw $e;        }        if (\PHP_VERSION_ID >= 70300 && (\JSON_THROW_ON_ERROR & $this->encodingOptions)) {            return $this->setJson($data);        }        if (\JSON_ERROR_NONE !== json_last_error()) {            throw new \InvalidArgumentException(json_last_error_msg());        }        return $this->setJson($data);    }    /**     * Returns options used while encoding data to JSON.     *     * @return int     */    public function getEncodingOptions()    {        return $this->encodingOptions;    }    /**     * Sets options used while encoding data to JSON.     *     * @return $this     */    public function setEncodingOptions(int $encodingOptions)    {        $this->encodingOptions = $encodingOptions;        return $this->setData(json_decode($this->data));    }    /**     * Updates the content and headers according to the JSON data and callback.     *     * @return $this     */    protected function update()    {        if (null !== $this->callback) {            // Not using application/javascript for compatibility reasons with older browsers.            $this->headers->set('Content-Type', 'text/javascript');            return $this->setContent(sprintf('/**/%s(%s);', $this->callback, $this->data));        }        // Only set the header when there is none or when it equals 'text/javascript' (from a previous update with callback)        // in order to not overwrite a custom definition.        if (!$this->headers->has('Content-Type') || 'text/javascript' === $this->headers->get('Content-Type')) {            $this->headers->set('Content-Type', 'application/json');        }        return $this->setContent($this->data);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_RequestMatcher_9850,Adds a check for the client IP.\n\n @param string $ip A specific IP address or a range specified using IP/netmask like 192.168.1.0/24\n,Dodaje proveru klijentskog IP-ja.,    public function matchIp(string $ip)    {        $this->matchIps($ip);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
symfony_http-foundation_Response_8917,"Prepares the Response before it is sent to the client.\n\n This method tweaks the Response to ensure that it is\n compliant with RFC 2616. Most of the changes are based on\n the Request that is ""associated"" with this Response.\n\n @return $this\n",Priprema odgovor pre nego što se pošalje klijentu. Ovaj metod menja odgovor kako bi osigurao da je u skladu sa RFC 2616. Većina izmena su zasnovane na zahtevu koji je povezan sa ovim zahtevom.,"public function prepare(Request $request)    {        $headers = $this->headers;        if ($this->isInformational() || $this->isEmpty()) {            $this->setContent(null);            $headers->remove('Content-Type');            $headers->remove('Content-Length');            // prevent PHP from sending the Content-Type header based on default_mimetype            ini_set('default_mimetype', '');        } else {            // Content-type based on the Request            if (!$headers->has('Content-Type')) {                $format = $request->getRequestFormat(null);                if (null !== $format && $mimeType = $request->getMimeType($format)) {                    $headers->set('Content-Type', $mimeType);                }            }            // Fix Content-Type            $charset = $this->charset ?: 'UTF-8';            if (!$headers->has('Content-Type')) {                $headers->set('Content-Type', 'text/html; charset='.$charset);            } elseif (0 === stripos($headers->get('Content-Type'), 'text/') && false === stripos($headers->get('Content-Type'), 'charset')) {                // add the charset                $headers->set('Content-Type', $headers->get('Content-Type').'; charset='.$charset);            }            // Fix Content-Length            if ($headers->has('Transfer-Encoding')) {                $headers->remove('Content-Length');            }            if ($request->isMethod('HEAD')) {                // cf. RFC2616 14.13                $length = $headers->get('Content-Length');                $this->setContent(null);                if ($length) {                    $headers->set('Content-Length', $length);                }            }        }        // Fix protocol        if ('HTTP/1.0' != $request->server->get('SERVER_PROTOCOL')) {            $this->setProtocolVersion('1.1');        }        // Check if we need to send extra expire info headers        if ('1.0' == $this->getProtocolVersion() && false !== strpos($headers->get('Cache-Control'), 'no-cache')) {            $headers->set('pragma', 'no-cache');            $headers->set('expires', -1);        }        $this->ensureIEOverSSLCompatibility($request);        if ($request->isSecure()) {            foreach ($headers->getCookies() as $cookie) {                $cookie->setSecureDefault(true);            }        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2076, Text content security check.\\n\\n @param string $text\\n\\n @return array|\\\\EasyWeChat\\\\Kernel\\\\Support\\\\Collection|object|\\\\Psr\\\\Http\\\\Message\\\\ResponseInterface|string\\n\\n @throws \\\\EasyWeChat\\\\Kernel\\\\Exceptions\\\\InvalidConfigException\\n @throws \\\\GuzzleHttp\\\\Exception\\\\GuzzleException\\n,Bezbednosna provera sadržaja teksta.,"    public function checkText(string $text)    {        $params = [            'content' => $text,        ];        return $this->httpPostJson('msg_sec_check', $params);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2077, Image security check.\n\n @param string $path\n\n @return array|\\EasyWeChat\\Kernel\\Support\\Collection|object|\\Psr\\Http\\Message\\ResponseInterface|string\n\n @throws \\EasyWeChat\\Kernel\\Exceptions\\InvalidConfigException\n @throws \\GuzzleHttp\\Exception\\GuzzleException\n,Bezbednosna provera slike.,"    public function checkImage(string $path)    {        return $this->httpUpload('img_sec_check', ['media' => $path]);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
w7corp_easywechat_Client_2093, Upload image.\n\n @param string $path\n\n @return \\Psr\\Http\\Message\\ResponseInterface|\\EasyWeChat\\Kernel\\Support\\Collection|array|object|string\n\n @throws \\EasyWeChat\\Kernel\\Exceptions\\InvalidArgumentException\n @throws \\EasyWeChat\\Kernel\\Exceptions\\InvalidConfigException\n @throws \\GuzzleHttp\\Exception\\GuzzleException\n,Uploaduj sliku.,"    public function uploadImage($path)    {        return $this->upload('image', $path);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
woocommerce_woocommerce_support_2031, Compare two strings containing YAML to ensure that @a $actualYaml contains at\n least what the YAML string @a $expectedYaml contains.\n\n @return whether or not @a $actualYaml contains @a $expectedJson\n     @retval true  @a $actualYaml contains @a $expectedJson\n     @retval false @a $actualYaml does not contain @a $expectedJson\n\n @param[in] $actualYaml   the YAML string to be tested\n @param[in] $expectedYaml the expected YAML string\n,Upoređivanje dva stringa koji sadrže YAML kako bi osigurali da @a $actualYaml sadrži bar ono što YAML string @a $expectedYaml sadrži.,"function checkThatYamlStringContainsYamlString( $actualYaml, $expectedYaml ) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_ActionFilter_1015, Returns a value indicating whether the filter is active for the given action.\\\\n @param Action $action the action being filtered\\\\n @return bool whether the filter is active for the given action.\\\\n,Vraća vrednost koja ukazuje da li je filter aktivan za datu akciju.,"    protected function isActive($action)    {        $id = $this->getActionId($action);        if (empty($this->only)) {            $onlyMatch = true;        } else {            $onlyMatch = false;            foreach ($this->only as $pattern) {                if (StringHelper::matchWildcard($pattern, $id)) {                    $onlyMatch = true;                    break;                }            }        }        $exceptMatch = false;        foreach ($this->except as $pattern) {            if (StringHelper::matchWildcard($pattern, $id)) {                $exceptMatch = true;                break;            }        }        return !$exceptMatch && $onlyMatch;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yiisoft_yii2_Application_1023,"Runs the application.\n This is the main entrance of an application.\n @return int the exit status (0 means normal, non-zero values mean abnormal)\n",Pokreće aplikaciju. Ovo je glavni ulaz u aplikaciju.,"    public function run()    {        try {            $this->state = self::STATE_BEFORE_REQUEST;            $this->trigger(self::EVENT_BEFORE_REQUEST);            $this->state = self::STATE_HANDLING_REQUEST;            $response = $this->handleRequest($this->getRequest());            $this->state = self::STATE_AFTER_REQUEST;            $this->trigger(self::EVENT_AFTER_REQUEST);            $this->state = self::STATE_SENDING_RESPONSE;            $response->send();            $this->state = self::STATE_END;            return $response->exitStatus;        } catch (ExitException $e) {            $this->end($e->statusCode, isset($response) ? $response : null);            return $e->statusCode;        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_KGB-Game-Panel-Restarter_restarter.class_1,," Metoda poziva parsiranje, i vraca listu servera u nizu",function getServers() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_KGB-Game-Panel-Restarter_restarter.class_2,," Metoda cita Gpanel feed, parsira i vraca niz servera sa informacijama","function parseServersFromFeed($feed,$tokenid) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_KGB-Game-Panel-Restarter_restarter.class_3,, Metoda vrati ceo sadrzaj datog linka,function procitaj($link) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_KGB-Game-Panel-Restarter_restarter.class_4,, Metoda restartuje server pozivom KGB API-ja,"function restartujServer($serverid,$token) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_KGB-Game-Panel-Restarter_restarter.class_5,, metoda skenira server na GT.rs i vraca informacije,function skenirajServer($ip) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_KGB-Game-Panel-Restarter_restarter.class_6,," Sigurnosna metoda, iz IP adrese izbaci sve sto nije broj, tacka ili dvotacka",function ocistiIP($ip) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_KGB-Game-Panel-Restarter_restarter.class_7,," Metoda ocisti output buffer, a zatim ispise gresku",function izbaciGresku($tekst) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_JavaScript-Multiplayer-Game_index_8,," Funkcija se poziva svakih X frejmova (frameRate), iz igraca izvadi samo Y koordinatu i brzinu po Y i posalje (da ne salje ceo niz)","            function sendPlayerCoords(playerName, player) {                var pp = {                    y: player.y,                    velY: player.velY                }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_JavaScript-Multiplayer-Game_index_9,," Funkcija koja pokrece loptu na osnovu brzine, i odbija od ivica mape","            function moveBall(canvas, ball, deltaTime) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_JavaScript-Multiplayer-Game_index_10,, Na osnovu korisnikovog inputa podesava brzinu igraca,"function getP1Input(canvas, player, deltaTime) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_JavaScript-Multiplayer-Game_index_11,," Funkcija pomera igrace na osnovu trenutne brzine. Ukoliko je trenutni igrac, onda ga pomeri na nove dimenzije, ali ukoliko je protivnicki igrac, onda pomera polako (smooth) zato sto koordinate protivnickog igraca dobija svakih X frejmova (frameRate), pa da ne bi seckao protivnicki igrac kad se krece","function movePlayers() {                for (i in players) {                    if (i == currentPlayer) {                        if (players[i].velY != 0) {                            players[i].y += players[i].velY;                        }                    } else {                        var curY = players[i].y,                            newY = players[i].newY;                                                players[i].y += (newY - curY) / lagSmoothLvl;                    }                }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_JavaScript-Multiplayer-Game_index_12,," Klasicno crtanje ""palice"" na osnovu podataka iz prosledjenog igraca","            function drawPaddle(context, player) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_JavaScript-Multiplayer-Game_index_13,, Crtanje lopte na osnovu podataka iz prosledjenog niza,"            function drawBall(context, ball) {",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_JavaScript-Multiplayer-Game_index_14,, Salje serveru start game i zapocinje animaciju,            function emitStart() {                if ( !started ) {                    socket.emit('startgame');                },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_controller_base.class_15,, Bazna apstraktna klasa za sve controllere,abstract class BaseController {// controller sve podatke koje odhvati iz modela i koje će proslijediti view-u čuva u registry-ju.protected $registry;function __construct( $registry ) {$this->registry = $registry;}// Svaki kontroller mora imati barem funkciju index.abstract function index();},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
turshija_KGB-Game-Panel-Restarter_restarter.class_19,, Metoda vrati ceo sadrzaj datog linka,function procitaj($link) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_controller_base.class_31,, Bazna apstraktna klasa za sve controllere,abstract class BaseController {// controller sve podatke koje odhvati iz modela i koje će proslijediti view-u čuva u registry-ju.protected $registry;function __construct( $registry ) {$this->registry = $registry;}// Svaki kontroller mora imati barem funkciju index.abstract function index();},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_controller_base.class_32,, Svaki kontroller mora imati barem funkciju index.,abstract function index();,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_init_33,, Automatsko učitavanja klasa iz modela kad se pozove new.,function __autoload( $class_name ){// Imena datoteke od klasa će biti napisana malim slovima.// Npr. za klasu User će biti spremljeno u user.class.php$filename = strtolower($class_name) . '.class.php';$file = __SITE_PATH .'/model/' . $filename;if( file_exists($file) === false ){    return false;}require_once ($file);},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_registry.class_34,, Jednostavni zajednički registry za deljenje podataka između controllera i viewa.,"class Registry {// Asocijativno polje (mapa) u koje ćemo moći dodati bilo što.private $vars = array();// Settter koji omogućava dodavanje novih podataka u registry (tj. u gornje privatno polje)public function __set( $index, $value ){$this->vars[$index] = $value;}// Getter iz privatnog polja.public function __get( $index ){return $this->vars[$index];}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_registry.class_35,, Settter koji omogućava dodavanje novih podataka u registry (tj. u gornje privatno polje),"public function __set( $index, $value ){$this->vars[$index] = $value;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_registry.class_36,, Getter iz privatnog polja.,public function __get( $index ){return $this->vars[$index];},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_router.class_37,, Funkcionalnost routera je izdvojena u zasebnu klasu.,"class Router {// Router također dijeli registry.private $registry;// Varijabla u koju ćemo spremiti putanju do controllera.private $path;private $args = array();public $file;// Objekt tipa controller.public $controller;// Ime akcije koja će se izvršiti u controlleru (index po defaultu).public $action; function __construct( $registry ){    $this->registry = $registry;}// Sprema putanju do kontrolera u $this->path.function setPath( $path ) {// Provjeri je li u $path zaista spremljena putanja (niz direktorija).if( is_dir( $path ) == false ){throw new Exception ( 'Invalid controller path: `' . $path . '`' );}$this->path = $path;}// Funkcija koja učitava (include-a) kod odgovarajućeg controllera.public function loader(){// Analiziraj rutu do kontrolera (razvoji $this->file, $this->path).$this->getController();// Ako traženi kontroler ne postoji, prikaži 404.if( is_readable( $this->file ) === false ){$this->file = $this->path . '/_404Controller.php';            $this->controller = '_404';}// Učitaj ispravni controller.require_once $this->file;// Stvori novi controller objekt. Proslijedi mu registry.$class = $this->controller . 'Controller';$controller = new $class( $this->registry );// Provjeri da li controller sadrži traženu akciju.if( method_exists( $controller, $this->action ) === false )$action = 'index';else$action = $this->action;// Pozovi odgovarajuću akciju.$controller->$action();}// Analiziraj $_GET['rt'], odredi ime controllera i akcije.private function getController() {// Dohvati $_GET['rt']$route = ( empty( $_GET['rt'] ) ) ? '' : $_GET['rt'];if( empty( $route ) )$route = 'index';else{// Ako $_GET['rt'] nije prazan, podijeli ga na controller i akciju.$parts = explode( '/', $route );$this->controller = $parts[0];if( isset( $parts[1] ) )$this->action = $parts[1];}if( empty( $this->controller ) )$this->controller = 'index';if( empty( $this->action ) )$this->action = 'index';// Sad imamo putanju do controllera.$this->file = $this->path .'/'. $this->controller . 'Controller.php';}}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_router.class_38,,Postavlja putanju do kontrolera u $this->path.,function setPath( $path ) {// Provjeri je li u $path zaista spremljena putanja (niz direktorija).if( is_dir( $path ) == false ){throw new Exception ( 'Invalid controller path: `' . $path . '`' );}$this->path = $path;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_router.class_39,, Funkcija koja učitava (include-a) kod odgovarajućeg controllera.,"public function loader(){// Analiziraj rutu do kontrolera (razvoji $this->file, $this->path).$this->getController();// Ako traženi kontroler ne postoji, prikaži 404.if( is_readable( $this->file ) === false ){$this->file = $this->path . '/_404Controller.php';            $this->controller = '_404';}// Učitaj ispravni controller.require_once $this->file;// Stvori novi controller objekt. Proslijedi mu registry.$class = $this->controller . 'Controller';$controller = new $class( $this->registry );// Provjeri da li controller sadrži traženu akciju.if( method_exists( $controller, $this->action ) === false )$action = 'index';else$action = $this->action;// Pozovi odgovarajuću akciju.$controller->$action();}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_router.class_40,," Analiziraj $_GET['rt'], odredi ime controllera i akcije.","private function getController() {// Dohvati $_GET['rt']$route = ( empty( $_GET['rt'] ) ) ? '' : $_GET['rt'];if( empty( $route ) )$route = 'index';else{// Ako $_GET['rt'] nije prazan, podijeli ga na controller i akciju.$parts = explode( '/', $route );$this->controller = $parts[0];if( isset( $parts[1] ) )$this->action = $parts[1];}if( empty( $this->controller ) )$this->controller = 'index';if( empty( $this->action ) )$this->action = 'index';// Sad imamo putanju do controllera.$this->file = $this->path .'/'. $this->controller . 'Controller.php';}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_template.class_41,, Klasa koja predstavlja šablon za view. Prikaz view-a će se napraviti tako da se objektu tipa Template pozove funkcija članica show. Njoj se kao parametar proslijedi ime view-a kojeg želimo prikazati.,"class Template {// Zajednički registry koji se dijeli sa routerom i controllerom.private $registry;// Asocijativno polje u koje spremamo varijable koje će biti direktno dostupne u view-u.private $vars = array();function __construct( $registry ) {$this->registry = $registry;}// Setter za varijable u asocijativnom polju.public function __set($index, $value){    $this->vars[$index] = $value;}// Funkcija koja efektivno prikazuje view imena $namefunction show( $name ) {$path = __SITE_PATH . '/view' . '/' . $name . '.php';if( file_exists($path) === false ){throw new Exception( 'Template not found in ' . $path );return false;}// Stvori par (varijabla, vrijednost) za svaki par (ključ, vrijednost) iz asoc. polja vars.// Npr. ako je vars['ime'] = 'Mirko', vars['ocjena'] = 5, ovo će napraviti varijable $ime='Mirko' i $ocjena=5.// Tako ćemo iz view-a moći direktno raditi echo $ime, a ne echo $vars['ime'].foreach( $this->vars as $key => $value ){$$key = $value;}// Ovdje ne koristimo require_once, zato da bi controller i više puta mogao prikazati jedan te isti view.// (Na primjer, za svakog usera pozove jedan (uvijek isti) view koji prikaže podatke o tom useru.)require ($path); }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_template.class_42,, Setter za varijable u asocijativnom polju.,"public function __set($index, $value){    $this->vars[$index] = $value;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_template.class_43,, Funkcija koja efektivno prikazuje view imena $name\,"function show( $name ) {$path = __SITE_PATH . '/view' . '/' . $name . '.php';if( file_exists($path) === false ){throw new Exception( 'Template not found in ' . $path );return false;}// Stvori par (varijabla, vrijednost) za svaki par (ključ, vrijednost) iz asoc. polja vars.// Npr. ako je vars['ime'] = 'Mirko', vars['ocjena'] = 5, ovo će napraviti varijable $ime='Mirko' i $ocjena=5.// Tako ćemo iz view-a moći direktno raditi echo $ime, a ne echo $vars['ime'].foreach( $this->vars as $key => $value ){$$key = $value;}// Ovdje ne koristimo require_once, zato da bi controller i više puta mogao prikazati jedan te isti view.// (Na primjer, za svakog usera pozove jedan (uvijek isti) view koji prikaže podatke o tom useru.)require ($path); }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_db.class_44,, klasa za povezivanje na bazu\\r\,"class DB { private static $db = null; private function __construct() { } private function __clone() { }  public static function getConnection() { if( DB::$db === null ) { try { / otvaramo bazu DB::$db = $myPDO = new PDO(“pgsql:host=localhost;port=5432;dbname=earchme;user=postgres;password=pass"");      DB::$db-> setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);     }     catch( PDOException $e ) { exit( 'PDO Error: ' . $e->getMessage() ); }     } return DB::$db; } }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_indexController_45,,samo preusmeri na dashboard,public function index() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_searchme_movie.class_47,,klasa koja predstavlja jedan film,class Movie{,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
besomuk_JMBG_JMBG_79,,JMBG.php Provera JMBG-a i i uzimanje podataka o rodjenju / prebivalistu,"class JMBG   {      private $num = 0;      public function __construct( $n = false )      {         if ( $n == false )         {            throw new \Exception(""<br><strong>Nije upisan broj za proveru!</strong><br>"", 1);         }         $this->num = $n;      }      /**       *       * Proverava JMBG i vraca true ako je sve u redu ili false ako nesto nije u redu       *       * @return      bool       *       */      public function isOK()      {         // odbaci brojeve neispravne duzine         if ( strlen($this->num) != 13 )            return false;         // odbaci nule         if ( $this->num == ""0000000000000"" )            return false;         $n = $this->num; // daj ga u varijablu, preglednije je za sabiranje         // napravi sumu         $s = 7*$n[0] + 6*$n[1] + 5*$n[2] + 4*$n[3] + 3*$n[4] + 2*$n[5] +              7*$n[6] + 6*$n[7] + 5*$n[8] + 4*$n[9] + 3*$n[10] + 2*$n[11];         // kontrolna cifra suma mod 11         $k = $s % 11;         // ako si veci od 1, oduzmi od 11         if ( $k > 1 )            $k = 11 - $k;         // da li je kontrolna cifra ista kao i ona na 13 mestu?         if ( $k == $n[12] )            return true;         else            return false;      }      /**       *       * Uzima podatke koji se mogu uzeti iz broja.       *       * @return      array       *              [""bday""]    -> datum rodjenja u ISO 8601 formatu ( YYYY-MM-DD )       *              [""gender""]  -> pol       *              [""region""]  -> glavni region rodjenja       *              [""region2""] -> pod region rodjenja       *       */      public function getPersonData ()      {         //proveri sam sebe         if ( !$this->isOK() )         {            echo ""Broj nije ispravan, nema podataka! Prvo uradi proveru broja, pa tek onda prikazi podatke."";         }         $data = array ();         // provera pola         $g = substr ( $this->num, 9,3 );         if ( $g >= 0 && $g <= 499)            $data[""gender""] = ""M"";         else            $data[""gender""] = ""Ž"";         // provera regiona rodjenja         $region = substr ( $this->num, 7, 2 );         if ( $region >= 0 && $region <= 9 )   // Stranci         {            $data[""region""] = ""Stranci koji su dobili SFRJ drzavljanstvo"";            switch ($region)            {               case 1: $data[""region2""] = ""Stranci u BiH""; break;               case 2: $data[""region2""] = ""Stranci u Crnoj Gori""; break;               case 3: $data[""region2""] = ""Stranci u Hrvatskoj""; break;               case 4: $data[""region2""] = ""Stranci u Makedoniji""; break;               case 5: $data[""region2""] = ""Stranci u sloveniji""; break;               case 7: $data[""region2""] = ""Stranci u Užoj Srbiji""; break;               case 8: $data[""region2""] = ""Stranci u Vojvodini""; break;               case 9: $data[""region2""] = ""Stranci na Kosovu i Metohiji""; break;            }         }         if ( $region >= 10 && $region <= 19 ) // BiH         {            $data[""region""] = ""Bosna i Hercegovina"";            switch ($region)            {               case 10: $data[""region2""] = ""Banja Luka""; break;               case 11: $data[""region2""] = ""Bihać""; break;               case 12: $data[""region2""] = ""Doboj""; break;               case 13: $data[""region2""] = ""Goražde""; break;               case 14: $data[""region2""] = ""Livno""; break;               case 15: $data[""region2""] = ""Mostar""; break;               case 16: $data[""region2""] = ""Prijedor""; break;               case 17: $data[""region2""] = ""Sarajevo""; break;               case 18: $data[""region2""] = ""Tuzla""; break;               case 19: $data[""region2""] = ""Zenica""; break;            }         }         if ( $region >= 20 && $region <= 29 ) // Crna Gora         {            $data[""region""] = ""Crna gora"";            switch ($region)            {               case 21: $data[""region2""] = ""Podgorica""; break;               case 22: $data[""region2""] = ""Bar, Ulcinj""; break;               case 23: $data[""region2""] = ""Budva, Kotor, Tivat""; break;               case 24: $data[""region2""] = ""Herceg Novi""; break;               case 25: $data[""region2""] = ""Cetinje""; break;               case 26: $data[""region2""] = ""Nikšić""; break;               case 27: $data[""region2""] = ""Berane, Rožaje, Plav, Andrijevica""; break;               case 28: $data[""region2""] = ""Bijelo Polje, Mojkovac""; break;               case 29: $data[""region2""] = ""Žabljak""; break;            }         }         if ( $region >= 30 && $region <= 39 ) // Hrvatska         {            $data[""region""] = ""Hrvatska"";            switch ($region)            {               case 30: $data[""region2""] = ""Osijek""; break;               case 31: $data[""region2""] = ""Bjelovar, Virovitica, Koprivnica, Pakrac""; break;               case 32: $data[""region2""] = ""Varaždin, Međumirje""; break;               case 33: $data[""region2""] = ""Zagreb""; break;               case 34: $data[""region2""] = ""Karlovac""; break;               case 35: $data[""region2""] = ""Lika""; break;               case 36: $data[""region2""] = ""Istra, Primorje""; break;               case 37: $data[""region2""] = ""Sisak, Banija""; break;               case 38: $data[""region2""] = ""Dalmacija""; break;               case 39: $data[""region2""] = ""Razno""; break;            }         }         if ( $region >= 40 && $region <= 49 ) // Makedonija         {            $data[""region""] = ""Makedonija"";            switch ($region)            {               case 41: $data[""region2""] = ""Bitolj""; break;               case 42: $data[""region2""] = ""Kumanovo""; break;               case 43: $data[""region2""] = ""Ohrid""; break;               case 44: $data[""region2""] = ""Prilep""; break;               case 45: $data[""region2""] = ""Skoplje""; break;               case 46: $data[""region2""] = ""Strumica""; break;               case 47: $data[""region2""] = ""Tetovo""; break;               case 48: $data[""region2""] = ""Veles""; break;               case 49: $data[""region2""] = ""Štip""; break;            }         }         if ( $region >= 50 && $region <= 59 ) // Slovenija         {            $data[""region""] = ""Slovenija"";            // nema pod regiona         }         if ( $region >= 60 && $region <= 69 ) // Privremeni boravak         {            $data[""region""] = ""Gradjani sa privremenim boravkom"";         }         if ( $region >= 70 && $region <= 79 ) // Srbija         {            $data[""region""] = ""Uža Srbija"";            switch ($region)            {               case 71: $data[""region2""] = ""Beograd""; break;               case 72: $data[""region2""] = ""Kragujevac, Jagodina""; break;               case 73: $data[""region2""] = ""Niš, Pirot, Toplica""; break;               case 74: $data[""region2""] = ""Leskovac, Vranje""; break;               case 75: $data[""region2""] = ""Zaječar, Bor""; break;               case 76: $data[""region2""] = ""Smederevo, Požarevac""; break;               case 77: $data[""region2""] = ""Mačva, Kolubara""; break;               case 78: $data[""region2""] = ""Čačak, Kraljevo, Kruševac""; break;               case 79: $data[""region2""] = ""Užice""; break;            }         }         if ( $region >= 80 && $region <= 89 ) // Vojvodina         {            $data[""region""] = ""AP Vojvodina"";            switch ($region)            {               case 80: $data[""region2""] = ""Novi Sad""; break;               case 81: $data[""region2""] = ""Sombor""; break;               case 82: $data[""region2""] = ""Subotica""; break;               case 83: $data[""region2""] = ""Vrbas""; break;               case 84: $data[""region2""] = ""Kikinda""; break;               case 85: $data[""region2""] = ""Zrenjanin""; break;               case 86: $data[""region2""] = ""Pančevo""; break;               case 87: $data[""region2""] = ""Vršac""; break;               case 88: $data[""region2""] = ""Ruma""; break;               case 89: $data[""region2""] = ""Sremska Mitrovica""; break;            }         }         if ( $region >= 90 && $region <= 99 ) // Kosovo         {            $data[""region""] = ""AP Kosovo"";            switch ($region)            {               case 91: $data[""region2""] = ""Priština""; break;               case 92: $data[""region2""] = ""Kosovska Mitrovica""; break;               case 93: $data[""region2""] = ""Peć""; break;               case 94: $data[""region2""] = ""Djakovica""; break;               case 95: $data[""region2""] = ""Prizren""; break;               case 96: $data[""region2""] = ""Gnjilane, Kosovska Kamenica, Vitina, Novo Brdo""; break;            }         }         if ( $this->num[5] == 0 )            $vek = 2;         else            $vek = 1;         $tempGod = $vek . substr($this->num, 4, 3);         $data[""bday""] = $tempGod . ""-"" . substr($this->num, 2, 2) . ""-"" . substr($this->num, 0, 2);         return $data;      }   }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
besomuk_JMBG_JMBG_80,,Proverava JMBG i vraca true ako je sve u redu ili false ako nesto nije u redu,"public function isOK()      {         // odbaci brojeve neispravne duzine         if ( strlen($this->num) != 13 )            return false;         // odbaci nule         if ( $this->num == ""0000000000000"" )            return false;         $n = $this->num; // daj ga u varijablu, preglednije je za sabiranje         // napravi sumu         $s = 7*$n[0] + 6*$n[1] + 5*$n[2] + 4*$n[3] + 3*$n[4] + 2*$n[5] +              7*$n[6] + 6*$n[7] + 5*$n[8] + 4*$n[9] + 3*$n[10] + 2*$n[11];         // kontrolna cifra suma mod 11         $k = $s % 11;         // ako si veci od 1, oduzmi od 11         if ( $k > 1 )            $k = 11 - $k;         // da li je kontrolna cifra ista kao i ona na 13 mestu?         if ( $k == $n[12] )            return true;         else            return false;      }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
besomuk_JMBG_JMBG_81,,Uzima podatke koji se mogu uzeti iz broja.,"public function getPersonData ()      {         //proveri sam sebe         if ( !$this->isOK() )         {            echo ""Broj nije ispravan, nema podataka! Prvo uradi proveru broja, pa tek onda prikazi podatke."";         }         $data = array ();         // provera pola         $g = substr ( $this->num, 9,3 );         if ( $g >= 0 && $g <= 499)            $data[""gender""] = ""M"";         else            $data[""gender""] = ""Ž"";         // provera regiona rodjenja         $region = substr ( $this->num, 7, 2 );         if ( $region >= 0 && $region <= 9 )   // Stranci         {            $data[""region""] = ""Stranci koji su dobili SFRJ drzavljanstvo"";            switch ($region)            {               case 1: $data[""region2""] = ""Stranci u BiH""; break;               case 2: $data[""region2""] = ""Stranci u Crnoj Gori""; break;               case 3: $data[""region2""] = ""Stranci u Hrvatskoj""; break;               case 4: $data[""region2""] = ""Stranci u Makedoniji""; break;               case 5: $data[""region2""] = ""Stranci u sloveniji""; break;               case 7: $data[""region2""] = ""Stranci u Užoj Srbiji""; break;               case 8: $data[""region2""] = ""Stranci u Vojvodini""; break;               case 9: $data[""region2""] = ""Stranci na Kosovu i Metohiji""; break;            }         }         if ( $region >= 10 && $region <= 19 ) // BiH         {            $data[""region""] = ""Bosna i Hercegovina"";            switch ($region)            {               case 10: $data[""region2""] = ""Banja Luka""; break;               case 11: $data[""region2""] = ""Bihać""; break;               case 12: $data[""region2""] = ""Doboj""; break;               case 13: $data[""region2""] = ""Goražde""; break;               case 14: $data[""region2""] = ""Livno""; break;               case 15: $data[""region2""] = ""Mostar""; break;               case 16: $data[""region2""] = ""Prijedor""; break;               case 17: $data[""region2""] = ""Sarajevo""; break;               case 18: $data[""region2""] = ""Tuzla""; break;               case 19: $data[""region2""] = ""Zenica""; break;            }         }         if ( $region >= 20 && $region <= 29 ) // Crna Gora         {            $data[""region""] = ""Crna gora"";            switch ($region)            {               case 21: $data[""region2""] = ""Podgorica""; break;               case 22: $data[""region2""] = ""Bar, Ulcinj""; break;               case 23: $data[""region2""] = ""Budva, Kotor, Tivat""; break;               case 24: $data[""region2""] = ""Herceg Novi""; break;               case 25: $data[""region2""] = ""Cetinje""; break;               case 26: $data[""region2""] = ""Nikšić""; break;               case 27: $data[""region2""] = ""Berane, Rožaje, Plav, Andrijevica""; break;               case 28: $data[""region2""] = ""Bijelo Polje, Mojkovac""; break;               case 29: $data[""region2""] = ""Žabljak""; break;            }         }         if ( $region >= 30 && $region <= 39 ) // Hrvatska         {            $data[""region""] = ""Hrvatska"";            switch ($region)            {               case 30: $data[""region2""] = ""Osijek""; break;               case 31: $data[""region2""] = ""Bjelovar, Virovitica, Koprivnica, Pakrac""; break;               case 32: $data[""region2""] = ""Varaždin, Međumirje""; break;               case 33: $data[""region2""] = ""Zagreb""; break;               case 34: $data[""region2""] = ""Karlovac""; break;               case 35: $data[""region2""] = ""Lika""; break;               case 36: $data[""region2""] = ""Istra, Primorje""; break;               case 37: $data[""region2""] = ""Sisak, Banija""; break;               case 38: $data[""region2""] = ""Dalmacija""; break;               case 39: $data[""region2""] = ""Razno""; break;            }         }         if ( $region >= 40 && $region <= 49 ) // Makedonija         {            $data[""region""] = ""Makedonija"";            switch ($region)            {               case 41: $data[""region2""] = ""Bitolj""; break;               case 42: $data[""region2""] = ""Kumanovo""; break;               case 43: $data[""region2""] = ""Ohrid""; break;               case 44: $data[""region2""] = ""Prilep""; break;               case 45: $data[""region2""] = ""Skoplje""; break;               case 46: $data[""region2""] = ""Strumica""; break;               case 47: $data[""region2""] = ""Tetovo""; break;               case 48: $data[""region2""] = ""Veles""; break;               case 49: $data[""region2""] = ""Štip""; break;            }         }         if ( $region >= 50 && $region <= 59 ) // Slovenija         {            $data[""region""] = ""Slovenija"";            // nema pod regiona         }         if ( $region >= 60 && $region <= 69 ) // Privremeni boravak         {            $data[""region""] = ""Gradjani sa privremenim boravkom"";         }         if ( $region >= 70 && $region <= 79 ) // Srbija         {            $data[""region""] = ""Uža Srbija"";            switch ($region)            {               case 71: $data[""region2""] = ""Beograd""; break;               case 72: $data[""region2""] = ""Kragujevac, Jagodina""; break;               case 73: $data[""region2""] = ""Niš, Pirot, Toplica""; break;               case 74: $data[""region2""] = ""Leskovac, Vranje""; break;               case 75: $data[""region2""] = ""Zaječar, Bor""; break;               case 76: $data[""region2""] = ""Smederevo, Požarevac""; break;               case 77: $data[""region2""] = ""Mačva, Kolubara""; break;               case 78: $data[""region2""] = ""Čačak, Kraljevo, Kruševac""; break;               case 79: $data[""region2""] = ""Užice""; break;            }         }         if ( $region >= 80 && $region <= 89 ) // Vojvodina         {            $data[""region""] = ""AP Vojvodina"";            switch ($region)            {               case 80: $data[""region2""] = ""Novi Sad""; break;               case 81: $data[""region2""] = ""Sombor""; break;               case 82: $data[""region2""] = ""Subotica""; break;               case 83: $data[""region2""] = ""Vrbas""; break;               case 84: $data[""region2""] = ""Kikinda""; break;               case 85: $data[""region2""] = ""Zrenjanin""; break;               case 86: $data[""region2""] = ""Pančevo""; break;               case 87: $data[""region2""] = ""Vršac""; break;               case 88: $data[""region2""] = ""Ruma""; break;               case 89: $data[""region2""] = ""Sremska Mitrovica""; break;            }         }         if ( $region >= 90 && $region <= 99 ) // Kosovo         {            $data[""region""] = ""AP Kosovo"";            switch ($region)            {               case 91: $data[""region2""] = ""Priština""; break;               case 92: $data[""region2""] = ""Kosovska Mitrovica""; break;               case 93: $data[""region2""] = ""Peć""; break;               case 94: $data[""region2""] = ""Djakovica""; break;               case 95: $data[""region2""] = ""Prizren""; break;               case 96: $data[""region2""] = ""Gnjilane, Kosovska Kamenica, Vitina, Novo Brdo""; break;            }         }         if ( $this->num[5] == 0 )            $vek = 2;         else            $vek = 1;         $tempGod = $vek . substr($this->num, 4, 3);         $data[""bday""] = $tempGod . ""-"" . substr($this->num, 2, 2) . ""-"" . substr($this->num, 0, 2);         return $data;      }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_visak_iz_modela_95,,vraća status trenutno prijavljenog studenta u ponudi s idom,function get_status(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_visak_iz_modela_97,,vraća username studenta,function get_username_by_id($id){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT username FROM studentplus_students WHERE id=:id' );$st->execute( array( 'id' => $id ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_companyController_98,,obradi logout,public function logout(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_companyController_99,,obradi login,public function check_login(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_companyController_100,,obradi register,public function check_register(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_companyController_101,,proverava na koje smo dugme stisnuli,public function check_button_choice(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_companyController_102,,dohvata sve ponude,public function all_offers(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_companyController_103,,ide kad stisnemo da želimo videti sve ponude koje je ta kompanija napravila,public function company_offers(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_companyController_104,,ide poslije ispunjavanja forme za pravljenje nove ponude,public function check_new_offer(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_companyController_105,,svi studenti koji su se prijavili na neku ponudu,public function show_students(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_indexController_106,,samo preusmjeri na dashboard,public function index() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_indexController_107,,dohvaća sve ponude,public function all_offers(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_indexController_108,,ako se stisnuo button login/register,public function check_button_choice(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_indexController_109,,procesuiraj login,public function check_login_type(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_indexController_110,,procesuiraj register,public function check_register_type(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentController_111,,obradi logout,public function logout(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentController_112,,obradi login,public function check_login(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentController_113,,obradi registraciju,public function check_register(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentController_114,,studentov glavni dashboard,public function all_offers(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentController_115,,koji button je stisnuo,public function check_button_choice(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentController_116,,vidi studentove prijave,public function my_applications(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_member.class_117,,mozda ne treba\r,class Member{,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0
mateastanisic_studentplus_studentplus_service.class_118,,vraća polje svih ponuda (od svih tvrtki),function get_all_offers(){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_offers ORDER BY id' );$st->execute();},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_119,,vraća ponudu s poslanim id-om,function get_offer_by_id($id){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_offers WHERE id=:id ORDER BY id' );$st->execute( array('id' => $id ));},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_120,,vraća sve ponude koje u imenu sadržavaju podstring $ime kod pretraživanja,function get_offers_by_podstring_name($ime){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_121,,vraća sve ponude čije ime je JEDNAKO varijabli $name kod pretraživanja,function get_offers_by_name($name){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_offers WHERE name=:name ORDER BY id' );$st->execute( array( 'name' => $name ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_123,,vraća polje svih ponuda kojima sam poslao zahtjev (bez obzira na status),function get_accepted_offers_by_id($id_student){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_members WHERE id_student=:id_student ORDER BY id_student' );$st->execute( array( 'id_student' => $id_student ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_124,,vraća polje svih ponuda kojima sam poslao zahtjev (bez obzira na status),function get_pending_offers_by_id($id_student){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_members WHERE id_student=:id_student ORDER BY id_student' );$st->execute( array( 'id_student' => $id_student ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_125,,vraća polje svih ponuda kojima sam poslao zahtjev (bez obzira na status,function get_rejected_offers_by_id($id_student){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_members WHERE id_student=:id_student ORDER BY id_student' );$st->execute( array( 'id_student' => $id_student ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_126,,vraća tvrtku (klasa) s određenim oib-om\n,function get_company_by_oib($oib){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_companies WHERE oib=:oib ORDER BY oib' );$st->execute( array( 'oib' => $oib ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_127,,vraća ime tvrtke s poslanim oib-om\n,function get_companyname_by_oib($oib){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_128,,vraća ime tvrtke koja je postavila određenu ponudu,function get_companyname_by_offerid($id){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT oib FROM studentplus_offers WHERE id=:id' );$st->execute( array( 'id' => $id ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_129,,vraća lozinku od neke tvrtke,function get_password_by_oib($oib){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT password FROM studentplus_companies WHERE oib=:oib' );$st->execute( array( 'oib' => $oib ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_130,,vraća studenta(klasa) s određenim id-om,function get_student_by_id($id){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_students WHERE id=:id ORDER BY id' );$st->execute( array('id' => $id ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_131,,vrati studentovo ime ako znamo username,function get_studentname_by_username($username){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_students WHERE username=:username ORDER BY username' );$st->execute( array('username' => $username ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_132,, vraća id studenta s određenim username-om,function get_id_by_username($username){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT id FROM studentplus_students WHERE username=:username' );$st->execute( array( 'username' => $username ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_133,,vraća lozinku nekog studenta,function get_password_by_username($username){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT password FROM studentplus_students WHERE username=:username' );$st->execute( array( 'username' => $username ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_134,,vraća polje svih članova (-1/0/1) neke ponude čiji id šaljemo,function get_students_in_offer_by_id($id_offer){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_members WHERE id_offer=:id_offer ORDER BY id_offer' );$st->execute( array( 'id_offer' => $id_offer ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_135,,vracamo je li student prijavljen za neku praksu,"function is_student_applied($id_student, $id_offer){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_members WHERE id_offer=:id_offer AND id_student=:id_student' );$st->execute( array( 'id_offer' => $id_offer, 'id_student' => $id_student ) );}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_136,,vraća polje svih  članova koji su podnijeli zahtjev (za koje još nismo odlučili što ćemo s njima),function get_pending_students_in_offer($id_offer){try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_members WHERE id_offer=:id_offer ORDER BY id_offer' );$st->execute( array( 'id_offer' => $id_offer ) );},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_137,,vraća polje svih  članova koji su podnijeli zahtjev (i koje je tvrtka prihvatila),function get_accepted_students_in_offer($id_offer){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_138,,vraća polje svih  članova koji su podnijeli zahtjev (i koje je tvrtka odbila),function get_rejected_students_in_offer($id_offer){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_139,,obradi prijavu studenta za neku ponudu,"function asign_student_to_offer($id_student, $id_offer){",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_140,,obradi prihvaćanje/odbijanje studenta,"function change_status( $status, $id_student, $id_offer ){",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_141,,dodaj novu ponudu u bazu,"function add_offer($company, $name, $description, $adress, $period){",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_142,,registracija tvrtke,"function add_company($oib, $password_hash, $name, $email, $adress, $phone, $description ){",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_143,,registracija studenta,"function add_student($username, $password_hash, $name, $surname, $email, $phone, $school, $grades, $free_time, $cv ){",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_144,,dodaj file u bazu,function upload_file(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_145,,dohvati file po njegovom id-u (id je spremljen u studenta),function get_file_by_id($id){    try{$db = DB::getConnection();$st = $db->prepare( 'SELECT * FROM studentplus_files WHERE id=:id' );$st->execute( array( 'id' => $id) );$row = $st->fetch();if( $row === false ) return null;else return $row;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
mateastanisic_studentplus_studentplus_service.class_146,, ---------------------  UPDATE PROFIL  -------------------------,"function update_student_password($id, $pass){",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_dbrw_147,, Upis u INI datoteku,function upis() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_relay-control_148,, Vraća stanje uređaja,function getRelayStatus($a) {switch ($a) {case 0:return PiroData::$data['rasveta']['led_centar'];case 1:return PiroData::$data['rasveta']['led_desno'];case 2:return PiroData::$data['rasveta']['led_levo'];},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_shell-commands_149,, Funkcija za vraćanje trenutne temperature procesora,function getShellTemp() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_shell-commands_150,, Vraća broj dana besprekidnog rada sistema,function getUptime() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_shell-commands_151,,Vraća prosečno opterećenje sistema u zadnjih 10 minuta,"function getLoadAvg() {exec(""uptime | sed 's/.*load average: //' | awk -F\, '{print $2}' 2>&1"", $tmp);        return intval(str_replace(""."", """", $tmp[0]));}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_thermal-control_152,,"Vraća stanje grejnog tela. Ukoliko peć nije povezana, rezultat je -1",function thermalStatus() {if (!TERM_DOSTUPNO && intval(PiroData::$data['grejanje']['status_peci']) != -1) {PiroData::$data['grejanje']['status_peci'] = -1;upis();},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_thermal-control_153,, Vraća trenutnu temperaturu,function getTemp() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_thermal-control_154,," Režim postavljen na ""A"" služi za pozive unutar Androida, nakon čega vraća trenutne parametre",function getMode() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_thermal-control_155,, Postavlja temperaturu na određenu vrednost,function setTemp($arg) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_thermal-control_156,, Funkcija za automatizaciju grejnog tela,function autoTemp() {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
laxsrbija_piro_weather_157,,"Argument koji funkcija uzima može biti ""force"". U tom slucaju se vreme ažurira čak i kada je prošlo manje od 5 minuta od poslednje provere",function azurirajVreme($a) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NevenaDarijevic_AplikacijaPHP_hr_158,,KLASA HR ZAPOSLENI ZA SVOJIM METODAMA,class HRZaposleni extends Baza{,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NevenaDarijevic_AplikacijaPHP_hr_159,,"metoda koja ubacuje novog hr zaposlenog, U INSERT FORMI ZA REGISTRACIJU","    public function insert_hr($vrednosti){        if($this->postoji_u_bazi($vrednosti[""korisnicko_ime""])==true){            return false;        }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NevenaDarijevic_AplikacijaPHP_hr_160,,metoda koja vraca sve hr zaposlene iz baze,    public function select_sve(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NevenaDarijevic_AplikacijaPHP_hr_161,,"da li taj zaposleni se nalazi u bazi i ima pristup,  ZA LOGIN FORMU",    public function ima_pristup($podaci){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NevenaDarijevic_AplikacijaPHP_hr_162,,"da li vec postoji u bazi, jer ako postoji, necemo ponovo izvrsiti insert",    public function postoji_u_bazi($username){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NevenaDarijevic_AplikacijaPHP_konekcija_163,,"KONEKCIJA SA BAZOM ""BAZAZAPOSLENIH""",class Baza{,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NevenaDarijevic_AplikacijaPHP_konekcija_164,,konstruktor,     function __construct(){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NevenaDarijevic_AplikacijaPHP_show_165,,KADA ZELIMO DA OBRISEMO RADNIKA POZIVA SE delete.php za brisanje radnika,        function obrisi(x){,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_166,, funkcija za kreiranje izbornika,"function izbornik(){        if(isset($_COOKIE['user_id']))        {            $pages = array            (                'index.php'           => 'Liste',                'log_out.php'         => 'Odjava'            );        }else        {            $pages = array            (                'index.php'     => 'Liste',                'register.php'  => 'Registracija',                'login.php'     => 'Prijava',            );        };        foreach ($pages as $address => $name)        {            echo '<li><a href=""' . $address . '"">' . $name . '</a></li>';        };};",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_167,, funkcija za potvrdu registracije,"function potvrda_registracije($email, $email_kod){    $test = $GLOBALS['con']->prepare(' select email from korisnici where email = :email and email_kod = :email_kod');    $test->execute([        ':email'     => $email,        ':email_kod' => $email_kod    ]);    $rezultat = $test->fetch(PDO::FETCH_OBJ);    if(isset($rezultat) && !empty($rezultat))    {        $potvrda = $GLOBALS['con']->prepare(' update korisnici set status = 1, email_kod = 0, datum_zadnjeg_log_in = current_date() where email = :email');        $potvrda->execute([            ':email' => $email        ]);        $dohvat = $GLOBALS['con']->prepare(' select korisnik_id from korisnici where email = :email ');        $dohvat->execute([            ':email' => $email        ]);        $korisnikov_id = $dohvat->fetch(PDO::FETCH_OBJ);        setcookie('user_id', $korisnikov_id->korisnik_id, time() + 86400);        header('location: index.php');    }else    {      echo '<h1>Neuspjela potvrda, <a href=""register.php"">probajte ponovno</a></h1>';    };};",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_168,, funkcija za prijavu,"function log_in($email, $lozinka){    $korisnik = $GLOBALS['con']->prepare(' select * from korisnici where email = :email and lozinka = md5(:lozinka) and status = 1 ');    $korisnik->execute([        ':email'     =>     $email,        ':lozinka'   =>     $lozinka    ]);    $korisnik_id = $korisnik->fetch(PDO::FETCH_OBJ);    // ako je prijava uspješna    if(isset($korisnik_id->korisnik_id))    {        // postavljamo zadnji datum prijave        $zadnji_log_in = $GLOBALS['con']->prepare(' update korisnici set datum_zadnjeg_log_in = current_date() where email = :email');        $zadnji_log_in->execute([            ':email' => $email                        ]);        // postavi korisnički ""Cookie"" za tjedan dana        setcookie('user_id', $korisnik_id->korisnik_id, time() + 86400);        header('location: index.php');    };};",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_169,, funkcija za prikaz grešaka pri prijavi,function login_try(){    if(!isset($_POST['email']) || !isset($_POST['lozinka']) || empty($_POST['email']) || empty($_POST['lozinka']))    {        echo 'Unesite e-mail i lozinku';    }else    {        if(!isset($_COOKIE['user_id']))        {            echo 'Pogrešan e-mail\lozinka';        };    };};,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_170,, funkcija za odjavu,"function log_off(){    // postavio sam varijablu ""$past"" na prošlo vrijeme    $past = time() - 3600;    // poništavamo sve ""Cookies""    foreach ( $_COOKIE as $key => $value )    {        setcookie( $key, $value, $past);    }    header('location: index.php');};",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_171,," funkcija za računjanje broja stranica listi -> kod ""paginacije""","function broj_stranica_lista($korisnik_id, $npp){    global $pages;    $total = $GLOBALS['con']->prepare(' select count(naziv) from to_do where korisnik_id = :korisnik_id ');    $total->execute([        ':korisnik_id' => $korisnik_id    ]);    $pages = ceil($total->fetchColumn() / $npp);        return $pages;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_172,," funkcija za dohvat podataka lista-> kod ""paginacije""","function dohvat_listi($korisnik_id, $page, $npp, $group, $value){    global $liste;        $liste = $GLOBALS['con']->prepare('         select to_do_id, korisnik_id, naziv as ""naziv_liste"", datum_unosa                                                 from to_do                                                where korisnik_id = :korisnik_id                                                order by ' . $group . ' ' . $value . '                                                limit '  . (($page * $npp / $npp)<=0 ? 0 : ($page * $npp - $npp)) . ', ' . $npp    );    $liste->execute([        ':korisnik_id' => $korisnik_id    ]);    $liste = $liste->fetchAll(PDO::FETCH_OBJ);        return $liste;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_173,, funkcija za određivanje zadataka u listi,function lista_zadaci($to_do_id){    global $zadaci;    $svi = $GLOBALS['con']->prepare(' select count(status) from zadaci where lista_id = :lista_id ');    $svi->execute([        ':lista_id' => $to_do_id    ]);    $zadaci = $svi->fetchColumn();    return $zadaci;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_174,, funkcija za određivanje nedovršenih zadataka,function nedovrseni_zadaci($to_do_id){    global $nedovrseni_zadaci;    $nedovrseno = $GLOBALS['con']->prepare(' select count(status) from zadaci where lista_id = :lista_id and status = 0 ');    $nedovrseno->execute([        ':lista_id' => $to_do_id    ]);    $nedovrseni_zadaci = $nedovrseno->fetchColumn();    return $nedovrseni_zadaci;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_175,, funkcija za brisanje liste,function brisanje_liste($to_do_id){    $brisanje = $GLOBALS['con']->prepare(' delete from to_do where to_do_id = :to_do_id ');    $brisanje->execute([        ':to_do_id' => $to_do_id    ]);    header('location: index.php');},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_176,, funkcija za pravljenje nove liste,"function napravi_to_do($naziv, $korisnik_id){    $napravi = $GLOBALS['con']->prepare(' insert into to_do (korisnik_id, naziv, datum_unosa) values                                         (:korisnik_id, :naziv, current_date())                                      ');     $napravi->execute([                    ':korisnik_id' => $korisnik_id,                    ':naziv'    => $naziv,                    ]);    $id_nove_liste = $GLOBALS['con']->lastInsertId();    return header('location: lista.php?to_do_id=' . $id_nove_liste);}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_177,, funkcija za dohvat podataka liste,function podaci_lista($to_do_id){    global $podaci_liste;    $lista_podaci = $GLOBALS['con']->prepare(' select * from to_do where to_do_id = :to_do_id ');    $lista_podaci->execute([        ':to_do_id' => $to_do_id                        ]);    $podaci_liste = $lista_podaci->fetch(PDO::FETCH_OBJ);    return $podaci_liste;},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_178,, funkcija za broj stranica zadataka,"function broj_stranica_zadataka($to_do_id, $npp){    global $pages;    $total = $GLOBALS['con']->prepare(' select count(naziv) from zadaci where lista_id = :to_do_id ');    $total->execute([        ':to_do_id' => $to_do_id    ]);    $pages = ceil($total->fetchColumn() / $npp);    return $pages;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_179,, funkcija za dohvat zadataka u listi,"function zadaci_liste($to_do_id, $page, $npp, $group, $value){    global $zadaci;        $lista_zadaci = $GLOBALS['con']->prepare('  select a.naziv, a.status, a.prioritet_id, a.rok , b.naziv as ""naziv_prioriteta"", a.zadatak_id                                                 from zadaci as a inner join prioriteti as b on a.prioritet_id = b.prioritet_id                                                 where lista_id = :to_do_id                                                order by ' . $group .  ' ' . $value .'                                                limit '  . (($page * $npp / $npp)<=0 ? 0 : ($page * $npp - $npp)) . ', ' . $npp                                                );    $lista_zadaci->execute([        ':to_do_id' => $to_do_id    ]);    $zadaci = $lista_zadaci->fetchAll(PDO::FETCH_OBJ);    return $zadaci;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_180,, funkcija za brisanje zadatka,function brisanje_zadatka($zadatak_id){    $brisanje = $GLOBALS['con']->prepare(' delete from zadaci where zadatak_id = :zadatak_id ');    $brisanje->execute([                        'zadatak_id' => $zadatak_id                        ]);},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_181,, funkcija za pravljenje zadatka,"function napravi_zadatak($to_do_id, $naziv, $prioritet_id, $rok){    $napravi = $GLOBALS['con']->prepare(' insert into zadaci (lista_id, naziv, prioritet_id, rok) values                                                            (:lista_id, :naziv, :prioritet_id, :rok)                                       ');    $napravi->execute([        ':lista_id'     => $to_do_id,        ':naziv'        => $naziv,        ':prioritet_id' => $prioritet_id,        ':rok'          => $rok    ]);}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_182,, funkcija za dohvat podataka o zadatku,"function podaci_zadatak($zadatak_id){    global $zadatak_podaci;    $zadatak = $GLOBALS['con']->prepare(' select a.*, b.naziv as \'naziv_prioriteta\'                                          from zadaci as a inner join prioriteti as b on a.prioritet_id = b.prioritet_id                                          where a.zadatak_id = :zadatak_id ');    $zadatak->execute([        ':zadatak_id' => $zadatak_id    ]);    $zadatak_podaci = $zadatak->fetch(PDO::FETCH_OBJ);        return $zadatak_podaci;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DamirLuketic_to_do_app_functions_183,, funkcija za prilagodbu zadatka,"function prilagodba_zadatka($zadatak_id, $naziv, $prioritet_id, $status, $datum_sat){    $prilagodba = $GLOBALS['con']->prepare(' update zadaci set naziv = :naziv, prioritet_id = :prioritet_id, status = :status, rok = :rok where zadatak_id = :zadatak_id');    $prilagodba->execute([        ':naziv'        => $naziv,        ':prioritet_id' => $prioritet_id,        ':status'       => $status,        ':rok'          => $datum_sat,        ':zadatak_id'   => $zadatak_id    ]);}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_AbstractCsv_184, An abstract class to enable CSV document loading.,Apstraktna klasa koja omogućava učitavanja CSV dokumenata.,"abstract class AbstractCsv implements ByteSequence{    protected const STREAM_FILTER_MODE = STREAM_FILTER_READ;    /**     * collection of stream filters.     *     * @var bool[]     */    protected $stream_filters = [];    /**     * The CSV document BOM sequence.     *     * @var string|null     */    protected $input_bom = null;    /**     * The Output file BOM character.     *     * @var string     */    protected $output_bom = '';    /**     * the field delimiter (one character only).     *     * @var string     */    protected $delimiter = ',';    /**     * the field enclosure character (one character only).     *     * @var string     */    protected $enclosure = '""';    /**     * the field escape character (one character only).     *     * @var string     */    protected $escape = '\\';    /**     * The CSV document.     *     * @var SplFileObject|Stream     */    protected $document;    /**     * Tells whether the Input BOM must be included or skipped.     *     * @var bool     */    protected $is_input_bom_included = false;    /**     * New instance.     *     * @param SplFileObject|Stream $document The CSV Object instance     */    protected function __construct($document)    {        $this->document = $document;        [$this->delimiter, $this->enclosure, $this->escape] = $this->document->getCsvControl();        $this->resetProperties();    }    /**     * Reset dynamic object properties to improve performance.     */    abstract protected function resetProperties(): void;    /**     * {@inheritdoc}     */    public function __destruct()    {        unset($this->document);    }    /**     * {@inheritdoc}     */    public function __clone()    {        throw UnavailableStream::dueToForbiddenCloning(static::class);    }    /**     * Return a new instance from a SplFileObject.     *     * @return static     */    public static function createFromFileObject(SplFileObject $file)    {        return new static($file);    }    /**     * Return a new instance from a PHP resource stream.     *     * @param resource $stream     *     * @return static     */    public static function createFromStream($stream)    {        return new static(new Stream($stream));    }    /**     * Return a new instance from a string.     *     * @return static     */    public static function createFromString(string $content = '')    {        return new static(Stream::createFromString($content));    }    /**     * Return a new instance from a file path.     *     * @param resource|null $context the resource context     *     * @return static     */    public static function createFromPath(string $path, string $open_mode = 'r+', $context = null)    {        return new static(Stream::createFromPath($path, $open_mode, $context));    }    /**     * Returns the current field delimiter.     */    public function getDelimiter(): string    {        return $this->delimiter;    }    /**     * Returns the current field enclosure.     */    public function getEnclosure(): string    {        return $this->enclosure;    }    /**     * Returns the pathname of the underlying document.     */    public function getPathname(): string    {        return $this->document->getPathname();    }    /**     * Returns the current field escape character.     */    public function getEscape(): string    {        return $this->escape;    }    /**     * Returns the BOM sequence in use on Output methods.     */    public function getOutputBOM(): string    {        return $this->output_bom;    }    /**     * Returns the BOM sequence of the given CSV.     */    public function getInputBOM(): string    {        if (null !== $this->input_bom) {            return $this->input_bom;        }        $this->document->setFlags(SplFileObject::READ_CSV);        $this->document->rewind();        $this->input_bom = Info::fetchBOMSequence((string) $this->document->fread(4)) ?? '';        return $this->input_bom;    }    /**     * DEPRECATION WARNING! This method will be removed in the next major point release.     *     * @deprecated since version 9.7.0     * @see AbstractCsv::supportsStreamFilterOnRead     * @see AbstractCsv::supportsStreamFilterOnWrite     *     * Returns the stream filter mode.     */    public function getStreamFilterMode(): int    {        return static::STREAM_FILTER_MODE;    }    /**     * DEPRECATION WARNING! This method will be removed in the next major point release.     *     * @deprecated since version 9.7.0     * @see AbstractCsv::supportsStreamFilterOnRead     * @see AbstractCsv::supportsStreamFilterOnWrite     *     * Tells whether the stream filter capabilities can be used.     */    public function supportsStreamFilter(): bool    {        return $this->document instanceof Stream;    }    /**     * Tells whether the stream filter read capabilities can be used.     */    public function supportsStreamFilterOnRead(): bool    {        return $this->document instanceof Stream            && ((static::STREAM_FILTER_MODE & STREAM_FILTER_READ) === STREAM_FILTER_READ);    }    /**     * Tells whether the stream filter write capabilities can be used.     */    public function supportsStreamFilterOnWrite(): bool    {        return $this->document instanceof Stream            && ((static::STREAM_FILTER_MODE & STREAM_FILTER_WRITE) === STREAM_FILTER_WRITE);    }    /**     * Tell whether the specify stream filter is attach to the current stream.     */    public function hasStreamFilter(string $filtername): bool    {        return $this->stream_filters[$filtername] ?? false;    }    /**     * Tells whether the BOM can be stripped if presents.     */    public function isInputBOMIncluded(): bool    {        return $this->is_input_bom_included;    }    /**     * Returns the CSV document as a Generator of string chunk.     *     * @param int $length number of bytes read     *     * @throws Exception if the number of bytes is lesser than 1     */    public function chunk(int $length): Generator    {        if ($length < 1) {            throw InvalidArgument::dueToInvalidChunkSize($length, __METHOD__);        }        $input_bom = $this->getInputBOM();        $this->document->rewind();        $this->document->setFlags(0);        $this->document->fseek(strlen($input_bom));        /** @var  array<int, string> $chunks */        $chunks = str_split($this->output_bom.$this->document->fread($length), $length);        foreach ($chunks as $chunk) {            yield $chunk;        }        while ($this->document->valid()) {            yield $this->document->fread($length);        }    }    /**     * DEPRECATION WARNING! This method will be removed in the next major point release.     *     * @deprecated since version 9.1.0     * @see AbstractCsv::toString     *     * Retrieves the CSV content     */    public function __toString(): string    {        return $this->toString();    }    /**     * Retrieves the CSV content.     *     * DEPRECATION WARNING! This method will be removed in the next major point release     *     * @deprecated since version 9.7.0     * @see AbstractCsv::toString     */    public function getContent(): string    {        return $this->toString();    }    /**     * Retrieves the CSV content.     *     * @throws Exception If the string representation can not be returned     */    public function toString(): string    {        $raw = '';        foreach ($this->chunk(8192) as $chunk) {            $raw .= $chunk;        }        return $raw;    }    /**     * Outputs all data on the CSV file.     *     * @return int Returns the number of characters read from the handle     *             and passed through to the output.     */    public function output(string $filename = null): int    {        if (null !== $filename) {            $this->sendHeaders($filename);        }        $this->document->rewind();        if (!$this->is_input_bom_included) {            $this->document->fseek(strlen($this->getInputBOM()));        }        echo $this->output_bom;        return strlen($this->output_bom) + (int) $this->document->fpassthru();    }    /**     * Send the CSV headers.     *     * Adapted from Symfony\Component\HttpFoundation\ResponseHeaderBag::makeDisposition     *     * @throws Exception if the submitted header is invalid according to RFC 6266     *     * @see https://tools.ietf.org/html/rfc6266#section-4.3     */    protected function sendHeaders(string $filename): void    {        if (strlen($filename) != strcspn($filename, '\\/')) {            throw InvalidArgument::dueToInvalidHeaderFilename($filename);        }        $flag = FILTER_FLAG_STRIP_LOW;        if (strlen($filename) !== mb_strlen($filename)) {            $flag |= FILTER_FLAG_STRIP_HIGH;        }        /** @var string $filtered_name */        $filtered_name = filter_var($filename, FILTER_SANITIZE_STRING, $flag);        $filename_fallback = str_replace('%', '', $filtered_name);        $disposition = sprintf('attachment; filename=""%s""', str_replace('""', '\\""', $filename_fallback));        if ($filename !== $filename_fallback) {            $disposition .= sprintf(""; filename*=utf-8''%s"", rawurlencode($filename));        }        header('Content-Type: text/csv');        header('Content-Transfer-Encoding: binary');        header('Content-Description: File Transfer');        header('Content-Disposition: '.$disposition);    }    /**     * Sets the field delimiter.     *     * @throws InvalidArgument If the Csv control character is not one character only.     *     * @return static     */    public function setDelimiter(string $delimiter): self    {        if ($delimiter === $this->delimiter) {            return $this;        }        if (1 !== strlen($delimiter)) {            throw InvalidArgument::dueToInvalidDelimiterCharacter($delimiter, __METHOD__);        }        $this->delimiter = $delimiter;        $this->resetProperties();        return $this;    }    /**     * Sets the field enclosure.     *     * @throws InvalidArgument If the Csv control character is not one character only.     *     * @return static     */    public function setEnclosure(string $enclosure): self    {        if ($enclosure === $this->enclosure) {            return $this;        }        if (1 !== strlen($enclosure)) {            throw InvalidArgument::dueToInvalidEnclosureCharacter($enclosure, __METHOD__);        }        $this->enclosure = $enclosure;        $this->resetProperties();        return $this;    }    /**     * Sets the field escape character.     *     * @throws InvalidArgument If the Csv control character is not one character only.     *     * @return static     */    public function setEscape(string $escape): self    {        if ($escape === $this->escape) {            return $this;        }        if ('' !== $escape && 1 !== strlen($escape)) {            throw InvalidArgument::dueToInvalidEscapeCharacter($escape, __METHOD__);        }        $this->escape = $escape;        $this->resetProperties();        return $this;    }    /**     * Enables BOM Stripping.     *     * @return static     */    public function skipInputBOM(): self    {        $this->is_input_bom_included = false;        return $this;    }    /**     * Disables skipping Input BOM.     *     * @return static     */    public function includeInputBOM(): self    {        $this->is_input_bom_included = true;        return $this;    }    /**     * Sets the BOM sequence to prepend the CSV on output.     *     * @return static     */    public function setOutputBOM(string $str): self    {        $this->output_bom = $str;        return $this;    }    /**     * append a stream filter.     *     * @param null|mixed $params     *     * @throws InvalidArgument    If the stream filter API can not be appended     * @throws UnavailableFeature If the stream filter API can not be used     *     * @return static     */    public function addStreamFilter(string $filtername, $params = null): self    {        if (!$this->document instanceof Stream) {            throw UnavailableFeature::dueToUnsupportedStreamFilterApi(get_class($this->document));        }        $this->document->appendFilter($filtername, static::STREAM_FILTER_MODE, $params);        $this->stream_filters[$filtername] = true;        $this->resetProperties();        $this->input_bom = null;        return $this;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
thephpleague_csv_AbstractCsv_191, Returns the current field delimiter.\n,Vrati trenutni razdvojni karakter.,    public function getDelimiter(): string    {        return $this->delimiter;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_AbstractCsv_193, Returns the pathname of the underlying document.,Vrati putanju do dokumenta,    public function getPathname(): string    {        return $this->document->getPathname();    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_AbstractCsv_203,Returns the CSV document as a Generator of string chunk.\n\n @param int $length number of bytes read\n\n @throws Exception if the number of bytes is lesser than 1\n,Vraća CSV dokument kao generator komada stringova.,"public function chunk(int $length): Generator    {        if ($length < 1) {            throw InvalidArgument::dueToInvalidChunkSize($length, __METHOD__);        }        $input_bom = $this->getInputBOM();        $this->document->rewind();        $this->document->setFlags(0);        $this->document->fseek(strlen($input_bom));        /** @var  array<int, string> $chunks */        $chunks = str_split($this->output_bom.$this->document->fread($length), $length);        foreach ($chunks as $chunk) {            yield $chunk;        }        while ($this->document->valid()) {            yield $this->document->fread($length);        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_AbstractCsv_206, Retrieves the CSV content.\n\n @throws Exception If the string representation can not be returned\n,Vraća sadržaj CSV fajla.,public function toString(): string    {        $raw = '';        foreach ($this->chunk(8192) as $chunk) {            $raw .= $chunk;        }        return $raw;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
thephpleague_csv_CannotInsertRecord_245, Thrown when a data is not added to the Csv Document.\n,Izuzetak koji se podiže kada podaci nisu dodati u CSV dokument.,"class CannotInsertRecord extends Exception{    /**     * The record submitted for insertion.     *     * @var array     */    protected $record;    /**     * Validator which did not validated the data.     *     * @var string     */    protected $name = '';    /**     * Create an Exception from a record insertion into a stream.     */    public static function triggerOnInsertion(array $record): self    {        $exception = new self('Unable to write record to the CSV document');        $exception->record = $record;        return $exception;    }    /**     * Create an Exception from a Record Validation.     */    public static function triggerOnValidation(string $name, array $record): self    {        $exception = new self('Record validation failed');        $exception->name = $name;        $exception->record = $record;        return $exception;    }    /**     * return the validator name.     *     */    public function getName(): string    {        return $this->name;    }    /**     * return the invalid data submitted.     *     */    public function getRecord(): array    {        return $this->record;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_CharsetConverter_260,Convert Csv records collection into UTF-8.\n,Pretvara csv strukturu kolekcija u utf-8,"    public function convert(iterable $records): iterable    {        if ($this->output_encoding === $this->input_encoding) {            return $records;        }        if (is_array($records)) {            return array_map($this, $records);        }        /* @var \Traversable $records */        return new MapIterator($records, $this);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_ColumnConsistency_276, Validates column consistency when inserting records into a CSV document.\n,Proverava konzistentnost kolona prilikom upisa zapisa u CSV dokument,"class ColumnConsistency{    /**     * The number of column per record.     *     * @var int     */    protected $columns_count;    /**     * New Instance.     *     * @throws InvalidArgument if the column count is lesser than -1     */    public function __construct(int $columns_count = -1)    {        if ($columns_count < -1) {            throw InvalidArgument::dueToInvalidColumnCount($columns_count, __METHOD__);        }        $this->columns_count = $columns_count;    }    /**     * Returns the column count.     */    public function getColumnCount(): int    {        return $this->columns_count;    }    /**     * Tell whether the submitted record is valid.     */    public function __invoke(array $record): bool    {        $count = count($record);        if (-1 === $this->columns_count) {            $this->columns_count = $count;            return true;        }        return $count === $this->columns_count;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_ColumnConsistency_277, Returns the column count.\n,Vraća broj kolona,    public function getColumnCount(): int    {        return $this->columns_count;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_ColumnConsistency_278, Tell whether the submitted record is valid.\n,Reci da li je poslat zapis validan.,public function __invoke(array $record): bool    {        $count = count($record);        if (-1 === $this->columns_count) {            $this->columns_count = $count;            return true;        }        return $count === $this->columns_count;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_HTMLConverter_310, Converts tabular data into an HTML Table string.\n,Pretvara tabelarne podatke u string koji je HTML tabela.,"class HTMLConverter{    /**     * table class attribute value.     *     * @var string     */    protected $class_name = 'table-csv-data';    /**     * table id attribute value.     *     * @var string     */    protected $id_value = '';    /**     * @var XMLConverter     */    protected $xml_converter;    public static function create(): self    {        return new self();    }    /**     * DEPRECATION WARNING! This method will be removed in the next major point release.     *     * @deprecated since version 9.7.0     * @see HTMLConverterTest::create()     */    public function __construct()    {        $this->xml_converter = XMLConverter::create()            ->rootElement('table')            ->recordElement('tr')            ->fieldElement('td')        ;    }    /**     * Converts a tabular data collection into a HTML table string.     *     * @param string[] $header_record An optional array of headers outputted using the`<thead>` section     * @param string[] $footer_record An optional array of footers to output to the table using `<tfoot>` and `<th>` elements     */    public function convert(iterable $records, array $header_record = [], array $footer_record = []): string    {        $doc = new DOMDocument('1.0');        if ([] === $header_record && [] === $footer_record) {            $table = $this->xml_converter->import($records, $doc);            $this->addHTMLAttributes($table);            $doc->appendChild($table);            /** @var string $content */            $content = $doc->saveHTML();            return $content;        }        $table = $doc->createElement('table');        $this->addHTMLAttributes($table);        $this->appendHeaderSection('thead', $header_record, $table);        $this->appendHeaderSection('tfoot', $footer_record, $table);        $table->appendChild($this->xml_converter->rootElement('tbody')->import($records, $doc));        $doc->appendChild($table);        /** @var string $content */        $content = $doc->saveHTML();        return $content;    }    /**     * Creates a DOMElement representing a HTML table heading section.     */    protected function appendHeaderSection(string $node_name, array $record, DOMElement $table): void    {        if ([] === $record) {            return;        }        /** @var DOMDocument $ownerDocument */        $ownerDocument = $table->ownerDocument;        $node = $this->xml_converter            ->rootElement($node_name)            ->recordElement('tr')            ->fieldElement('th')            ->import([$record], $ownerDocument)        ;        /** @var DOMElement $element */        foreach ($node->getElementsByTagName('th') as $element) {            $element->setAttribute('scope', 'col');        }        $table->appendChild($node);    }    /**     * Adds class and id attributes to an HTML tag.     */    protected function addHTMLAttributes(DOMElement $node): void    {        $node->setAttribute('class', $this->class_name);        $node->setAttribute('id', $this->id_value);    }    /**     * HTML table class name setter.     *     * @throws DOMException if the id_value contains any type of whitespace     */    public function table(string $class_name, string $id_value = ''): self    {        if (1 === preg_match("",\s,"", $id_value)) {            throw new DOMException(""the id attribute's value must not contain whitespace (spaces, tabs etc.)"");        }        $clone = clone $this;        $clone->class_name = $class_name;        $clone->id_value = $id_value;        return $clone;    }    /**     * HTML tr record offset attribute setter.     */    public function tr(string $record_offset_attribute_name): self    {        $clone = clone $this;        $clone->xml_converter = $this->xml_converter->recordElement('tr', $record_offset_attribute_name);        return $clone;    }    /**     * HTML td field name attribute setter.     */    public function td(string $fieldname_attribute_name): self    {        $clone = clone $this;        $clone->xml_converter = $this->xml_converter->fieldElement('td', $fieldname_attribute_name);        return $clone;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_HTMLConverter_313, Adds class and id attributes to an HTML tag.\n,Dodaje klasu i id atribute u html tag.,"    protected function addHTMLAttributes(DOMElement $node): void    {        $node->setAttribute('class', $this->class_name);        $node->setAttribute('id', $this->id_value);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_HTMLConverter_315, HTML td field name attribute setter.\n,Postavlja naziv HTML td polja. ,"    public function td(string $fieldname_attribute_name): self    {        $clone = clone $this;        $clone->xml_converter = $this->xml_converter->fieldElement('td', $fieldname_attribute_name);        return $clone;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Reader_346, A class to parse and read records from a CSV document.\n,Klasa koja parsira i čita zapise iz CSV dokumenta.,"class Reader extends AbstractCsv implements TabularDataReader, JsonSerializable{    protected const STREAM_FILTER_MODE = STREAM_FILTER_READ;    /**     * header offset.     *     * @var int|null     */    protected $header_offset;    /**     * header record.     *     * @var string[]     */    protected $header = [];    /**     * records count.     *     * @var int     */    protected $nb_records = -1;    /**     * @var bool     */    protected $is_empty_records_included = false;    /**     * {@inheritdoc}     */    public static function createFromPath(string $path, string $open_mode = 'r', $context = null)    {        return parent::createFromPath($path, $open_mode, $context);    }    /**     * {@inheritdoc}     */    protected function resetProperties(): void    {        $this->nb_records = -1;        $this->header = [];    }    /**     * Returns the header offset.     *     * If no CSV header offset is set this method MUST return null     *     */    public function getHeaderOffset(): ?int    {        return $this->header_offset;    }    /**     * {@inheritDoc}     */    public function getHeader(): array    {        if (null === $this->header_offset) {            return $this->header;        }        if ([] !== $this->header) {            return $this->header;        }        $this->header = $this->setHeader($this->header_offset);        return $this->header;    }    /**     * Determine the CSV record header.     *     * @throws Exception If the header offset is set and no record is found or is the empty array     *     * @return string[]     */    protected function setHeader(int $offset): array    {        $header = $this->seekRow($offset);        if (in_array($header, [[], [null]], true)) {            throw SyntaxError::dueToHeaderNotFound($offset);        }        if (0 !== $offset) {            return $header;        }        $header = $this->removeBOM($header, mb_strlen($this->getInputBOM()), $this->enclosure);        if ([''] === $header) {            throw SyntaxError::dueToHeaderNotFound($offset);        }        return $header;    }    /**     * Returns the row at a given offset.     */    protected function seekRow(int $offset): array    {        foreach ($this->getDocument() as $index => $record) {            if ($offset === $index) {                return $record;            }        }        return [];    }    /**     * Returns the document as an Iterator.     */    protected function getDocument(): Iterator    {        if (70400 > PHP_VERSION_ID && '' === $this->escape) {            $this->document->setCsvControl($this->delimiter, $this->enclosure);            return EmptyEscapeParser::parse($this->document);        }        $this->document->setFlags(SplFileObject::READ_CSV | SplFileObject::READ_AHEAD);        $this->document->setCsvControl($this->delimiter, $this->enclosure, $this->escape);        $this->document->rewind();        return $this->document;    }    /**     * Strip the BOM sequence from a record.     *     * @param string[] $record     *     * @return string[]     */    protected function removeBOM(array $record, int $bom_length, string $enclosure): array    {        if (0 === $bom_length) {            return $record;        }        $record[0] = mb_substr($record[0], $bom_length);        if ($enclosure.$enclosure != substr($record[0].$record[0], strlen($record[0]) - 1, 2)) {            return $record;        }        $record[0] = substr($record[0], 1, -1);        return $record;    }    /**     * {@inheritdoc}     */    public function fetchColumn($index = 0): Iterator    {        return ResultSet::createFromTabularDataReader($this)->fetchColumn($index);    }    /**     * {@inheritdoc}     */    public function fetchOne(int $nth_record = 0): array    {        return ResultSet::createFromTabularDataReader($this)->fetchOne($nth_record);    }    /**     * {@inheritdoc}     */    public function fetchPairs($offset_index = 0, $value_index = 1): Iterator    {        return ResultSet::createFromTabularDataReader($this)->fetchPairs($offset_index, $value_index);    }    /**     * {@inheritdoc}     */    public function count(): int    {        if (-1 === $this->nb_records) {            $this->nb_records = iterator_count($this->getRecords());        }        return $this->nb_records;    }    /**     * {@inheritdoc}     */    public function getIterator(): Iterator    {        return $this->getRecords();    }    /**     * {@inheritdoc}     */    public function jsonSerialize(): array    {        return iterator_to_array($this->getRecords(), false);    }    /**     * {@inheritDoc}     */    public function getRecords(array $header = []): Iterator    {        $header = $this->computeHeader($header);        $normalized = function ($record): bool {            return is_array($record) && ($this->is_empty_records_included || $record != [null]);        };        $bom = '';        if (!$this->is_input_bom_included) {            $bom = $this->getInputBOM();        }        $document = $this->getDocument();        $records = $this->stripBOM(new CallbackFilterIterator($document, $normalized), $bom);        if (null !== $this->header_offset) {            $records = new CallbackFilterIterator($records, function (array $record, int $offset): bool {                return $offset !== $this->header_offset;            });        }        if ($this->is_empty_records_included) {            $normalized_empty_records = static function (array $record): array {                if ([null] === $record) {                    return [];                }                return $record;            };            return $this->combineHeader(new MapIterator($records, $normalized_empty_records), $header);        }        return $this->combineHeader($records, $header);    }    /**     * Returns the header to be used for iteration.     *     * @param string[] $header     *     * @throws Exception If the header contains non unique column name     *     * @return string[]     */    protected function computeHeader(array $header)    {        if ([] === $header) {            $header = $this->getHeader();        }        if ($header !== ($filtered_header = array_filter($header, 'is_string'))) {            throw SyntaxError::dueToInvalidHeaderColumnNames();        }        if ($header !== array_unique($filtered_header)) {            throw SyntaxError::dueToDuplicateHeaderColumnNames($header);        }        return $header;    }    /**     * Combine the CSV header to each record if present.     *     * @param string[] $header     */    protected function combineHeader(Iterator $iterator, array $header): Iterator    {        if ([] === $header) {            return $iterator;        }        $field_count = count($header);        $mapper = static function (array $record) use ($header, $field_count): array {            if (count($record) != $field_count) {                $record = array_slice(array_pad($record, $field_count, null), 0, $field_count);            }            /** @var array<string|null> $assocRecord */            $assocRecord = array_combine($header, $record);            return $assocRecord;        };        return new MapIterator($iterator, $mapper);    }    /**     * Strip the BOM sequence from the returned records if necessary.     */    protected function stripBOM(Iterator $iterator, string $bom): Iterator    {        if ('' === $bom) {            return $iterator;        }        $bom_length = mb_strlen($bom);        $mapper = function (array $record, int $index) use ($bom_length): array {            if (0 !== $index) {                return $record;            }            $record = $this->removeBOM($record, $bom_length, $this->enclosure);            if ([''] === $record) {                return [null];            }            return $record;        };        $filter = function (array $record): bool {            return $this->is_empty_records_included || $record != [null];        };        return new CallbackFilterIterator(new MapIterator($iterator, $mapper), $filter);    }    /**     * Selects the record to be used as the CSV header.     *     * Because the header is represented as an array, to be valid     * a header MUST contain only unique string value.     *     * @param int|null $offset the header record offset     *     * @throws Exception if the offset is a negative integer     *     * @return static     */    public function setHeaderOffset(?int $offset): self    {        if ($offset === $this->header_offset) {            return $this;        }        if (null !== $offset && 0 > $offset) {            throw InvalidArgument::dueToInvalidHeaderOffset($offset, __METHOD__);        }        $this->header_offset = $offset;        $this->resetProperties();        return $this;    }    /**     * Enable skipping empty records.     */    public function skipEmptyRecords(): self    {        if ($this->is_empty_records_included) {            $this->is_empty_records_included = false;            $this->nb_records = -1;        }        return $this;    }    /**     * Disable skipping empty records.     */    public function includeEmptyRecords(): self    {        if (!$this->is_empty_records_included) {            $this->is_empty_records_included = true;            $this->nb_records = -1;        }        return $this;    }    /**     * Tells whether empty records are skipped by the instance.     */    public function isEmptyRecordsIncluded(): bool    {        return $this->is_empty_records_included;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
thephpleague_csv_Reader_352, Returns the document as an Iterator.\n,Vraća dokument kao iterator.,"protected function getDocument(): Iterator    {        if (70400 > PHP_VERSION_ID && '' === $this->escape) {            $this->document->setCsvControl($this->delimiter, $this->enclosure);            return EmptyEscapeParser::parse($this->document);        }        $this->document->setFlags(SplFileObject::READ_CSV | SplFileObject::READ_AHEAD);        $this->document->setCsvControl($this->delimiter, $this->enclosure, $this->escape);        $this->document->rewind();        return $this->document;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Reader_357, Returns the header to be used for iteration.\n\n @param string[] $header\n\n @throws Exception If the header contains non unique column name\n\n @return string[]\n,Vraća zaglavlje kako bi se koristilo za iteraciju.,"    protected function computeHeader(array $header)    {        if ([] === $header) {            $header = $this->getHeader();        }        if ($header !== ($filtered_header = array_filter($header, 'is_string'))) {            throw SyntaxError::dueToInvalidHeaderColumnNames();        }        if ($header !== array_unique($filtered_header)) {            throw SyntaxError::dueToDuplicateHeaderColumnNames($header);        }        return $header;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Reader_358, Combine the CSV header to each record if present.\n\n @param string[] $header\n,Kombinuje CSV zaglavlje sa svakim zapisom ako je prisutno.,"protected function combineHeader(Iterator $iterator, array $header): Iterator    {        if ([] === $header) {            return $iterator;        }        $field_count = count($header);        $mapper = static function (array $record) use ($header, $field_count): array {            if (count($record) != $field_count) {                $record = array_slice(array_pad($record, $field_count, null), 0, $field_count);            }            /** @var array<string|null> $assocRecord */            $assocRecord = array_combine($header, $record);            return $assocRecord;        };        return new MapIterator($iterator, $mapper);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Reader_361, Enable skipping empty records.\n,Omogućava preskakanje praznih zapisa.,public function skipEmptyRecords(): self    {        if ($this->is_empty_records_included) {            $this->is_empty_records_included = false;            $this->nb_records = -1;        }        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Statement_435, Sort the Iterator.\n,Sortiraj iteratore,"protected function buildOrderBy(Iterator $iterator): Iterator    {        if ([] === $this->order_by) {            return $iterator;        }        $compare = function (array $record_a, array $record_b): int {            foreach ($this->order_by as $callable) {                if (0 !== ($cmp = $callable($record_a, $record_b))) {                    return $cmp;                }            }            return $cmp ?? 0;        };        $it = new ArrayIterator();        foreach ($iterator as $offset => $value) {            $it[$offset] = $value;        }        $it->uasort($compare);        return $it;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Stream_450, Retrieves the current line as a CSV Record.\n\n @return array|false\n,Vraća trenutnu liniju kao CSV zapis.,"private function getCurrentRecord()    {        $flag = 0 !== ($this->flags & SplFileObject::SKIP_EMPTY);        do {            $ret = fgetcsv($this->stream, 0, $this->delimiter, $this->enclosure, $this->escape);        } while ($flag && is_array($ret) && null === $ret[0]);        return $ret;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Stream_453, Read from file.\n\n @see http://php.net/manual/en/SplFileObject.fread.php\n\n @param int $length The number of bytes to read\n\n @return string|false\n,Čitaj iz fajla.,"    public function fread(int $length)    {        return fread($this->stream, $length);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
thephpleague_csv_Stream_454, Gets a line from file.\n\n @see http://php.net/manual/en/SplFileObject.fgets.php\n\n @return string|false\n,Dohvati liniju iz fajla.,    public function fgets()    {        return fgets($this->stream);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Stream_455, Flushes the output to a file.\n\n @see http://php.net/manual/en/SplFileObject.fwrite.php\n,Isprazi izlaz u fajl.,    public function fflush(): bool    {        return fflush($this->stream);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_TabularDataReader_480, Returns the tabular data records as an iterator object.\n\n Each record is represented as a simple array containing strings or null values.\n\n If the CSV document has a header record then each record is combined\n to the header record and the header record is removed from the iterator.\n\n If the CSV document is inconsistent. Missing record fields are\n filled with null values while extra record fields are strip from\n the returned object.\n,"Vraća tabelarne zapise kao iterator. Svaki zapis je reprezentovan kao jednostavan niz koji sadrži stringove ili null vrednosti. Ako CSV dokument ima zapis zaglavlje, onda se svaki zapis kombinuje sa zapisom zaglavlja i zapis zaglavlja se izbacuje iz iteratora. Ako CSV dokument nije konzistentan, nedostajuća polja se dopunjuju pomoću null vrednosti, dok se polja koja su višak sklanjaju iz vraćenog objekta.",    public function getIterator(): Iterator;,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Writer_483, A class to insert records into a CSV Document.\n,Klasa koja upisuje zapise u CSV dokument.,"class Writer extends AbstractCsv{    protected const STREAM_FILTER_MODE = STREAM_FILTER_WRITE;    /**     * callable collection to format the record before insertion.     *     * @var callable[]     */    protected $formatters = [];    /**     * callable collection to validate the record before insertion.     *     * @var callable[]     */    protected $validators = [];    /**     * newline character.     *     * @var string     */    protected $newline = ""\n"";    /**     * Insert records count for flushing.     *     * @var int     */    protected $flush_counter = 0;    /**     * Buffer flush threshold.     *     * @var int|null     */    protected $flush_threshold;    /**     * Regular expression used to detect if RFC4180 formatting is necessary.     *     * @var string     */    protected $rfc4180_regexp;    /**     * double enclosure for RFC4180 compliance.     *     * @var string     */    protected $rfc4180_enclosure;    /**     * {@inheritdoc}     */    protected function resetProperties(): void    {        $characters = preg_quote($this->delimiter, '/').'|'.preg_quote($this->enclosure, '/');        $this->rfc4180_regexp = '/[\s|'.$characters.']/x';        $this->rfc4180_enclosure = $this->enclosure.$this->enclosure;    }    /**     * Returns the current newline sequence characters.     */    public function getNewline(): string    {        return $this->newline;    }    /**     * Get the flush threshold.     *     * @return int|null     */    public function getFlushThreshold()    {        return $this->flush_threshold;    }    /**     * Adds multiple records to the CSV document.     *     * @see Writer::insertOne     */    public function insertAll(iterable $records): int    {        $bytes = 0;        foreach ($records as $record) {            $bytes += $this->insertOne($record);        }        $this->flush_counter = 0;        $this->document->fflush();        return $bytes;    }    /**     * Adds a single record to a CSV document.     *     * A record is an array that can contains scalar types values, NULL values     * or objects implementing the __toString method.     *     * @throws CannotInsertRecord If the record can not be inserted     */    public function insertOne(array $record): int    {        $method = 'addRecord';        if (70400 > PHP_VERSION_ID && '' === $this->escape) {            $method = 'addRFC4180CompliantRecord';        }        $record = array_reduce($this->formatters, [$this, 'formatRecord'], $record);        $this->validateRecord($record);        $bytes = $this->$method($record);        if (false === $bytes || 0 >= $bytes) {            throw CannotInsertRecord::triggerOnInsertion($record);        }        return $bytes + $this->consolidate();    }    /**     * Adds a single record to a CSV Document using PHP algorithm.     *     * @see https://php.net/manual/en/function.fputcsv.php     *     * @return int|false     */    protected function addRecord(array $record)    {        return $this->document->fputcsv($record, $this->delimiter, $this->enclosure, $this->escape);    }    /**     * Adds a single record to a CSV Document using RFC4180 algorithm.     *     * @see https://php.net/manual/en/function.fputcsv.php     * @see https://php.net/manual/en/function.fwrite.php     * @see https://tools.ietf.org/html/rfc4180     * @see http://edoceo.com/utilitas/csv-file-format     *     * String conversion is done without any check like fputcsv.     *     *     - Emits E_NOTICE on Array conversion (returns the 'Array' string)     *     - Throws catchable fatal error on objects that can not be converted     *     - Returns resource id without notice or error (returns 'Resource id #2')     *     - Converts boolean true to '1', boolean false to the empty string     *     - Converts null value to the empty string     *     * Fields must be delimited with enclosures if they contains :     *     *     - Embedded whitespaces     *     - Embedded delimiters     *     - Embedded line-breaks     *     - Embedded enclosures.     *     * Embedded enclosures must be doubled.     *     * The LF character is added at the end of each record to mimic fputcsv behavior     *     * @return int|false     */    protected function addRFC4180CompliantRecord(array $record)    {        foreach ($record as &$field) {            $field = (string) $field;            if (1 === preg_match($this->rfc4180_regexp, $field)) {                $field = $this->enclosure.str_replace($this->enclosure, $this->rfc4180_enclosure, $field).$this->enclosure;            }        }        unset($field);        return $this->document->fwrite(implode($this->delimiter, $record).""\n"");    }    /**     * Format a record.     *     * The returned array must contain     *   - scalar types values,     *   - NULL values,     *   - or objects implementing the __toString() method.     */    protected function formatRecord(array $record, callable $formatter): array    {        return $formatter($record);    }    /**     * Validate a record.     *     * @throws CannotInsertRecord If the validation failed     */    protected function validateRecord(array $record): void    {        foreach ($this->validators as $name => $validator) {            if (true !== $validator($record)) {                throw CannotInsertRecord::triggerOnValidation($name, $record);            }        }    }    /**     * Apply post insertion actions.     */    protected function consolidate(): int    {        $bytes = 0;        if (""\n"" !== $this->newline) {            $this->document->fseek(-1, SEEK_CUR);            /** @var int $newlineBytes */            $newlineBytes = $this->document->fwrite($this->newline, strlen($this->newline));            $bytes =  $newlineBytes - 1;        }        if (null === $this->flush_threshold) {            return $bytes;        }        ++$this->flush_counter;        if (0 === $this->flush_counter % $this->flush_threshold) {            $this->flush_counter = 0;            $this->document->fflush();        }        return $bytes;    }    /**     * Adds a record formatter.     */    public function addFormatter(callable $formatter): self    {        $this->formatters[] = $formatter;        return $this;    }    /**     * Adds a record validator.     */    public function addValidator(callable $validator, string $validator_name): self    {        $this->validators[$validator_name] = $validator;        return $this;    }    /**     * Sets the newline sequence.     */    public function setNewline(string $newline): self    {        $this->newline = $newline;        return $this;    }    /**     * Set the flush threshold.     *     * @param ?int $threshold     *     * @throws InvalidArgument if the threshold is a integer lesser than 1     */    public function setFlushThreshold(?int $threshold): self    {        if ($threshold === $this->flush_threshold) {            return $this;        }        if (null !== $threshold && 1 > $threshold) {            throw InvalidArgument::dueToInvalidThreshold($threshold, __METHOD__);        }        $this->flush_threshold = $threshold;        $this->flush_counter = 0;        $this->document->fflush();        return $this;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Writer_487, Adds multiple records to the CSV document.\n\n @see Writer::insertOne\n,Dodaje više zapisa u CSV dokument.,public function insertAll(iterable $records): int    {        $bytes = 0;        foreach ($records as $record) {            $bytes += $this->insertOne($record);        }        $this->flush_counter = 0;        $this->document->fflush();        return $bytes;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Writer_488," Adds a single record to a CSV document.\n\n A record is an array that can contains scalar types values, NULL values\n or objects implementing the __toString method.\n\n @throws CannotInsertRecord If the record can not be inserted\n","Dodaje jedan zapis u CSV dokument. Zapis je niz koji može da sadrži skalarne vrednosti, null vrednosti ili objekte koji imaju implementiran __toString metod.","public function insertOne(array $record): int    {        $method = 'addRecord';        if (70400 > PHP_VERSION_ID && '' === $this->escape) {            $method = 'addRFC4180CompliantRecord';        }        $record = array_reduce($this->formatters, [$this, 'formatRecord'], $record);        $this->validateRecord($record);        $bytes = $this->$method($record);        if (false === $bytes || 0 >= $bytes) {            throw CannotInsertRecord::triggerOnInsertion($record);        }        return $bytes + $this->consolidate();    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_Writer_489, Adds a single record to a CSV Document using PHP algorithm.\n\n @see https://php.net/manual/en/function.fputcsv.php\n\n @return int|false\n,Dodaje jedan zapis u CSV dokument koristeći PHP algoritam.,"    protected function addRecord(array $record)    {        return $this->document->fputcsv($record, $this->delimiter, $this->enclosure, $this->escape);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_XMLConverter_515, Filter XML element name.\n\n @throws DOMException If the Element name is invalid\n,Filtrira XML element po nazivu.,    protected function filterElementName(string $value): string    {        return (new DOMElement($value))->tagName;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_XMLConverter_516, Filter XML attribute name.\n\n @param string $value Element name\n\n @throws DOMException If the Element attribute name is invalid\n,Filtrira XML atribut po nazivu.,    protected function filterAttributeName(string $value): string    {        if ('' === $value) {            return $value;        }        return (new DOMAttr($value))->name;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_EmptyEscapeParser_525, Filters the submitted document.\n\n @return SplFileObject|Stream\n,Filtrira dostavljeni dokument.,"private static function filterDocument(object $document)    {        if ($document instanceof Stream || $document instanceof SplFileObject) {            return $document;        }        throw new TypeError(__METHOD__.' expects parameter 1 to be a '.Stream::class.' or a SplFileObject object, '.get_class($document).' given.');    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
thephpleague_csv_EmptyEscapeParser_526, Extracts a record form the CSV document.\n,Izvlači zapis iz CSV dokumenta.,"private static function extractRecord(): array    {        $record = [];        self::$line = self::$document->fgets();        do {            $is_field_enclosed = false;            $buffer = '';            if (false !== self::$line) {                $buffer = ltrim(self::$line, self::$trim_mask);            }            if (($buffer[0] ?? '') === self::$enclosure) {                $is_field_enclosed = true;                self::$line = $buffer;            }            $record[] = $is_field_enclosed ? self::extractEnclosedFieldContent() : self::extractFieldContent();        } while (false !== self::$line);        return $record;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_540, Set the connection name to use in the next query\n\n @param string $name\n\n @return $this\n @throws Exception\n,Postavlja ime konekcije koja će se koristiti u sledećem upitu.,    public function connection($name)    {        if (!isset($this->connectionsSettings[$name]))            throw new Exception('Connection ' . $name . ' was not added.');        $this->defConnectionName = $name;        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_542, A method to get mysqli object or create it in case needed\n\n @return mysqli\n @throws Exception\n,Metod koji dogvara mysqli objekat ili ga pravi u slučaju da je potrebno.,    public function mysqli()    {        if (!isset($this->_mysqli[$this->defConnectionName])) {            $this->connect($this->defConnectionName);        }        return $this->_mysqli[$this->defConnectionName];    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_545, Helper function to create dbObject with JSON return type\n\n @return MysqliDb\n,Pomoćna funkcija koja pravi dbObject koji vraća JSON.,    public function jsonBuilder()    {        $this->returnType = 'json';        return $this;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_550, This method allows you to specify multiple (method chaining optional) options for SQL queries.\n\n @uses $MySqliDb->setQueryOption('name');\n\n @param string|array $options The options name of the query.\n\n @throws Exception\n @return MysqliDb\n,Ovaj metod omogućava specifikaciju višestrukih opcija za SQL upit.,"    public function setQueryOption($options)    {        $allowedOptions = Array('ALL', 'DISTINCT', 'DISTINCTROW', 'HIGH_PRIORITY', 'STRAIGHT_JOIN', 'SQL_SMALL_RESULT',            'SQL_BIG_RESULT', 'SQL_BUFFER_RESULT', 'SQL_CACHE', 'SQL_NO_CACHE', 'SQL_CALC_FOUND_ROWS',            'LOW_PRIORITY', 'IGNORE', 'QUICK', 'MYSQLI_NESTJOIN', 'FOR UPDATE', 'LOCK IN SHARE MODE');        if (!is_array($options)) {            $options = Array($options);        }        foreach ($options as $option) {            $option = strtoupper($option);            if (!in_array($option, $allowedOptions)) {                throw new Exception('Wrong query option: ' . $option);            }            if ($option == 'MYSQLI_NESTJOIN') {                $this->_nestJoin = true;            } elseif ($option == 'FOR UPDATE') {                $this->_forUpdate = true;            } elseif ($option == 'LOCK IN SHARE MODE') {                $this->_lockInShareMode = true;            } else {                $this->_queryOptions[] = $option;            }        }        return $this;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_554," A convenient function that returns TRUE if exists at least an element that\n satisfy the where condition specified calling the ""where"" method before this one.\n\n @param string $tableName The name of the database table to work with.\n\n @return bool\n @throws Exception\n",Zgodna funkcija koja vraća tačno ukoliko postoji bar jedan element koji ispinjava “gde” upit koji je definisan “gde” metodom.,"public function has($tableName)    {        $this->getOne($tableName, '1');        return $this->count >= 1;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_557, Locks a table for R/W action.\n\n @author Jonas Barascu\n\n @param string|array $table The table to be locked. Can be a table or a view.\n\n @return bool if succeeded;\n @throws Exception\n,Zaključava tabelu za upis i ispis.,"public function lock($table){// Main Query$this->_query = ""LOCK TABLES"";// Is the table an array?if(gettype($table) == ""array"") {// Loop trough it and attach it to the queryforeach($table as $key => $value) {if(gettype($value) == ""string"") {if($key > 0) {$this->_query .= "","";}$this->_query .= "" "".self::$prefix.$value."" "".$this->_tableLockMethod;}}}else{// Build the table prefix$table = self::$prefix . $table;// Build the query$this->_query = ""LOCK TABLES "".$table."" "".$this->_tableLockMethod;}// Execute the query unprepared because LOCK only works with unprepared statements.$result = $this->queryUnprepared($this->_query);        $errno  = $this->mysqli()->errno;// Reset the query$this->reset();// Are there rows modified?if($result) {// Return true// We can't return ourself because if one table gets locked, all other ones get unlocked!return true;}// Something went wrongelse {throw new Exception(""Locking of table "".$table."" failed"", $errno);}// Return the success valuereturn false;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_558, Unlocks all tables in a database.\n Also commits transactions.\n\n @author Jonas Barascu\n @return MysqliDb\n @throws Exception\n,Otključava sve tabele u bazi.,"public function unlock(){// Build the query$this->_query = ""UNLOCK TABLES"";// Execute the query unprepared because UNLOCK and LOCK only works with unprepared statements.$result = $this->queryUnprepared($this->_query);        $errno  = $this->mysqli()->errno;// Reset the query$this->reset();// Are there rows modified?if($result) {// return selfreturn $this;}// Something went wrongelse {throw new Exception(""Unlocking of tables failed"", $errno);}// Return selfreturn $this;}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_559, This methods returns the ID of the last inserted item\n\n @return int The last inserted item ID.\n @throws Exception\n,Ovaj metod vraća ID poslednje dodate stavke.,    public function getInsertId()    {        return $this->mysqli()->insert_id;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_560, Escape harmful characters which might affect a query.\n\n @param string $str The string to escape.\n\n @return string The escaped string.\n @throws Exception\n,Izbegava opasne karaktere koji bi mogli da utiču na upit.,    public function escape($str)    {        return $this->mysqli()->real_escape_string($str);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_573, Abstraction method that will build the GROUP BY part of the WHERE statement\n\n @return void\n,Apstraktni metod koji pravi deo “gde” izjave za grupisanje.,"    protected function _buildGroupBy()    {        if (empty($this->_groupBy)) {            return;        }        $this->_query .= "" GROUP BY "";        foreach ($this->_groupBy as $key => $value) {            $this->_query .= $value . "", "";        }        $this->_query = rtrim($this->_query, ', ') . "" "";    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_576, Method attempts to prepare the SQL query\n and throws an error if there was a problem.\n\n @return mysqli_stmt\n @throws Exception\n,Metod pokušava da pripremi SQL upit i izbacuje grešku ako ima problema.,"protected function _prepareQuery()    {        $stmt = $this->mysqli()->prepare($this->_query);        if ($stmt !== false) {            if ($this->traceEnabled)                $this->traceStartQ = microtime(true);            return $stmt;        }        if ($this->mysqli()->errno === 2006 && $this->autoReconnect === true && $this->autoReconnectCount === 0) {            $this->connect($this->defConnectionName);            $this->autoReconnectCount++;            return $this->_prepareQuery();        }        $error = $this->mysqli()->error;        $query = $this->_query;        $errno = $this->mysqli()->errno;        $this->reset();        throw new Exception(sprintf('%s query: %s', $error, $query), $errno);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_579, Method returns last executed query\n\n @return string\n,Metod vraća poslednji izvršeni upit.,    public function getLastQuery()    {        return $this->_lastQuery;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_581, Method returns mysql error code\n\n @return int\n,Metod vraća kod mysql greške.,    public function getLastErrno () {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_MysqliDb_589, Method to check if needed table is created\n\n @param array $tables Table name or an Array of table names to check\n\n @return bool True if table exists\n @throws Exception\n,Metod koji proverava da li je potrebna tabela napravljena.,"public function tableExists($tables)    {        $tables = !is_array($tables) ? Array($tables) : $tables;        $count = count($tables);        if ($count == 0) {            return false;        }        foreach ($tables as $i => $value)            $tables[$i] = self::$prefix . $value;        $db = isset($this->connectionsSettings[$this->defConnectionName]) ? $this->connectionsSettings[$this->defConnectionName]['db'] : null;        $this->where('table_schema', $db);        $this->where('table_name', $tables, 'in');        $this->get('information_schema.tables', $count);        return $this->count == $count;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_dbObject_605, Function to get a total records count\n\n @return int\n,Funkcija koja vraća ukupan broj zapisa.,    protected function count () {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ThingEngineer_PHP-MySQLi-Database-Class_dbObject_609, Converts object data to a JSON string.\n\n @return string Converted data\n,Pretvara podatke objekta u JSON string.,    public function toJson () {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_AbstractMcryptMixer_624, Encrypts a block using the suppied key\n\n @param string $input Plaintext to encrypt\n @param string $key   Encryption key\n\n @return string Resulting ciphertext\n,Enkriiptuje blok koristeći dostavljen ključ,"    private function encryptBlock($input, $key)    {        if (!$input && !$key) {            return '';        }        $this->prepareCipher($key);        $result = mcrypt_generic($this->mcrypt, $input);        mcrypt_generic_deinit($this->mcrypt);        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_AbstractMcryptMixer_625, Derypts a block using the suppied key\n\n @param string $input Ciphertext to decrypt\n @param string $key   Encryption key\n\n @return string Resulting plaintext\n,Dekriptuje blok koristeći dostavljeni ključ.,"    private function decryptBlock($input, $key)    {        if (!$input && !$key) {            return '';        }        $this->prepareCipher($key);        $result = mdecrypt_generic($this->mcrypt, $input);        mcrypt_generic_deinit($this->mcrypt);        return $result;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_AbstractMixer_631, Mix the provided array of strings into a single output of the same size\n\n All elements of the array should be the same size.\n\n @param array $parts The parts to be mixed\n\n @return string The mixed result\n,Meša dati niz stringova u jedan izlaz iste veličine. Svi elementi niza bi trebalo da su iste veličine.,"public function mix(array $parts)    {        if (empty($parts)) {            return '';        }        $len        = Util::safeStrlen($parts[0]);        $parts      = $this->normalizeParts($parts);        $stringSize = count($parts[0]);        $partsSize  = count($parts);        $result     = '';        $offset     = 0;        for ($i = 0; $i < $stringSize; $i++) {            $stub = $parts[$offset][$i];            for ($j = 1; $j < $partsSize; $j++) {                $newKey = $parts[($j + $offset) % $partsSize][$i];                //Alternately mix the output for each source                if ($j % 2 == 1) {                    $stub ^= $this->mixParts1($stub, $newKey);                } else {                    $stub ^= $this->mixParts2($stub, $newKey);                }            }            $result .= $stub;            $offset  = ($offset + 1) % $partsSize;        }        return Util::safeSubstr($result, 0, $len);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_AbstractSource_634, Return an instance of Strength indicating the strength of the source\n\n @return \\SecurityLib\\Strength An instance of one of the strength classes\n,Vraća instancu objekta Strength koji ukazuje na jačinu izvora.,    public static function getStrength()    {        return new Strength(Strength::VERYLOW);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_AbstractSource_636," Returns a string of zeroes, useful when no entropy is available.\n\n @param int $size The size of the requested random string\n\n @return string A string of the requested size\n",Vraća string nula. Koristno kada nema entropije.,"protected static function emptyValue($size)    {        return str_repeat(chr(0), $size);    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_Factory_637," The Random Factory\n\n Use this factory to instantiate random number generators, sources and mixers.\n\n @category   PHPPasswordLib\n @package    Random\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n","Nasumična fabrika. Koristiti je da se instanciraju generatori nsumičnih brojeva, izvori i mešalice.","class Factory extends \SecurityLib\AbstractFactory{    /**     * @var array A list of available random number mixing strategies     */    protected $mixers = array();    /**     * @var array A list of available random number sources     */    protected $sources = array();    /**     * Build a new instance of the factory, loading core mixers and sources     *     * @return void     */    public function __construct()    {        $this->loadMixers();        $this->loadSources();    }    /**     * Get a generator for the requested strength     *     * @param Strength $strength The requested strength of the random number     *     * @throws RuntimeException If an appropriate mixing strategy isn't found     *     * @return Generator The instantiated generator     */    public function getGenerator(\SecurityLib\Strength $strength)    {        $sources = $this->findSources($strength);        $mixer   = $this->findMixer($strength);        return new Generator($sources, $mixer);    }    /**     * Get a high strength random number generator     *     * High Strength keys should ONLY be used for generating extremely strong     * cryptographic keys.  Generating them is very resource intensive and may     * take several minutes or more depending on the requested size.     *     * @return Generator The instantiated generator     */    public function getHighStrengthGenerator()    {        return $this->getGenerator(new Strength(Strength::HIGH));    }    /**     * Get a low strength random number generator     *     * Low Strength should be used anywhere that random strings are needed in a     * non-cryptographical setting.  They are not strong enough to be used as     * keys or salts.  They are however useful for one-time use tokens.     *     * @return Generator The instantiated generator     */    public function getLowStrengthGenerator()    {        return $this->getGenerator(new Strength(Strength::LOW));    }    /**     * Get a medium strength random number generator     *     * Medium Strength should be used for most needs of a cryptographic nature.     * They are strong enough to be used as keys and salts.  However, they do     * take some time and resources to generate, so they should not be over-used     *     * @return Generator The instantiated generator     */    public function getMediumStrengthGenerator()    {        return $this->getGenerator(new Strength(Strength::MEDIUM));    }    /**     * Get all loaded mixing strategies     *     * @return array An array of mixers     */    public function getMixers()    {        return $this->mixers;    }    /**     * Get all loaded random number sources     *     * @return array An array of sources     */    public function getSources()    {        return $this->sources;    }    /**     * Register a mixing strategy for this factory instance     *     * @param string $name  The name of the stategy     * @param string $class The class name of the implementation     *     * @return Factory $this The current factory instance     */    public function registerMixer($name, $class)    {        $this->registerType(            'mixers',            __NAMESPACE__ . '\\Mixer',            $name,            $class        );        return $this;    }    /**     * Register a random number source for this factory instance     *     * Note that this class must implement the Source interface     *     * @param string $name  The name of the stategy     * @param string $class The class name of the implementation     *     * @return Factory $this The current factory instance     */    public function registerSource($name, $class)    {        $this->registerType(            'sources',            __NAMESPACE__ . '\\Source',            $name,            $class        );        return $this;    }    /**     * Find a sources based upon the requested strength     *     * @param Strength $strength The strength mixer to find     *     * @throws RuntimeException if a valid source cannot be found     *     * @return Source The found source     */    protected function findSources(\SecurityLib\Strength $strength)    {        $sources = array();        foreach ($this->getSources() as $source) {            if ($strength->compare($source::getStrength()) <= 0 && $source::isSupported()) {                $sources[] = new $source();            }        }        if (0 === count($sources)) {            throw new \RuntimeException('Could not find sources');        }        return $sources;    }    /**     * Find a mixer based upon the requested strength     *     * @param Strength $strength The strength mixer to find     *     * @throws RuntimeException if a valid mixer cannot be found     *     * @return Mixer The found mixer     */    protected function findMixer(\SecurityLib\Strength $strength)    {        $newMixer = null;        $fallback = null;        foreach ($this->getMixers() as $mixer) {            if (!$mixer::test()) {                continue;            }            if ($strength->compare($mixer::getStrength()) == 0) {                $newMixer = new $mixer();            } elseif ($strength->compare($mixer::getStrength()) == 1) {                $fallback = new $mixer();            }        }        if (is_null($newMixer)) {            if (is_null($fallback)) {                throw new \RuntimeException('Could not find mixer');            }            return $fallback;        }        return $newMixer;    }    /**     * Load all core mixing strategies     *     * @return void     */    protected function loadMixers()    {        $this->loadFiles(            __DIR__ . '/Mixer',            __NAMESPACE__ . '\\Mixer\\',            array($this, 'registerMixer')        );    }    /**     * Load all core random number sources     *     * @return void     */    protected function loadSources()    {        $this->loadFiles(            __DIR__ . '/Source',            __NAMESPACE__ . '\\Source\\',            array($this, 'registerSource')        );    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_Generator_651, The Random Number Generator Class\n\n Use this factory to generate cryptographic quality random numbers (strings)\n\n @category   PHPPasswordLib\n @package    Random\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @author     Timo Hamina\n,Klasa generatora nsaumičnih brojeva. Koristiti ovu fabriku za generisanje nasumičnih brojeva kriptografskog kvaliteta.,"class Generator{    /**     * @const Flag for uppercase letters     */    const CHAR_UPPER = 1;    /**     * @const Flag for lowercase letters     */    const CHAR_LOWER = 2;    /**     * @const Flag for alpha characters (combines UPPER + LOWER)     */    const CHAR_ALPHA = 3; // CHAR_UPPER | CHAR_LOWER    /**     * @const Flag for digits     */    const CHAR_DIGITS = 4;    /**     * @const Flag for alpha numeric characters     */    const CHAR_ALNUM = 7; // CHAR_ALPHA | CHAR_DIGITS    /**     * @const Flag for uppercase hexadecimal symbols     */    const CHAR_UPPER_HEX = 12; // 8 | CHAR_DIGITS    /**     * @const Flag for lowercase hexidecimal symbols     */    const CHAR_LOWER_HEX = 20; // 16 | CHAR_DIGITS    /**     * @const Flag for base64 symbols     */    const CHAR_BASE64 = 39; // 32 | CHAR_ALNUM    /**     * @const Flag for additional symbols accessible via the keyboard     */    const CHAR_SYMBOLS = 64;    /**     * @const Flag for brackets     */    const CHAR_BRACKETS = 128;    /**     * @const Flag for punctuation marks     */    const CHAR_PUNCT = 256;    /**     * @const Flag for upper/lower-case and digits but without ""B8G6I1l|0OQDS5Z2""     */    const EASY_TO_READ = 512;    /**     * @var Mixer The mixing strategy to use for this generator instance     */    protected $mixer = null;    /**     * @var array An array of random number sources to use for this generator     */    protected $sources = array();    /**     * @var array The different characters, by Flag     */    protected $charArrays = array(        self::CHAR_UPPER     => 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',        self::CHAR_LOWER     => 'abcdefghijklmnopqrstuvwxyz',        self::CHAR_DIGITS    => '0123456789',        self::CHAR_UPPER_HEX => 'ABCDEF',        self::CHAR_LOWER_HEX => 'abcdef',        self::CHAR_BASE64    => '+/',        self::CHAR_SYMBOLS   => '!""#$%&\'()* +,-./:;<=>?@[\]^_`{|}~',        self::CHAR_BRACKETS  => '()[]{}<>',        self::CHAR_PUNCT     => ',.;:',    );    /**     * @internal     * @private     * @const string Ambiguous characters for ""Easy To Read"" sets     */    const AMBIGUOUS_CHARS = 'B8G6I1l|0OQDS5Z2()[]{}:;,.';    /**     * Build a new instance of the generator     *     * @param array $sources An array of random data sources to use     * @param Mixer $mixer   The mixing strategy to use for this generator     */    public function __construct(array $sources, Mixer $mixer)    {        foreach ($sources as $source) {            $this->addSource($source);        }        $this->mixer = $mixer;    }    /**     * Add a random number source to the generator     *     * @param Source $source The random number source to add     *     * @return Generator $this The current generator instance     */    public function addSource(Source $source)    {        $this->sources[] = $source;        return $this;    }    /**     * Generate a random number (string) of the requested size     *     * @param int $size The size of the requested random number     *     * @return string The generated random number (string)     */    public function generate($size)    {        $seeds = array();        foreach ($this->sources as $source) {            $seeds[] = $source->generate($size);        }        return $this->mixer->mix($seeds);    }    /**     * Generate a random integer with the given range     *     * @param int $min The lower bound of the range to generate     * @param int $max The upper bound of the range to generate     *     * @return int The generated random number within the range     */    public function generateInt($min = 0, $max = PHP_INT_MAX)    {        $tmp   = (int) max($max, $min);        $min   = (int) min($max, $min);        $max   = $tmp;        $range = $max - $min;        if ($range == 0) {            return $max;        } elseif ($range > PHP_INT_MAX || is_float($range) || $range < 0) {            /**             * This works, because PHP will auto-convert it to a float at this point,             * But on 64 bit systems, the float won't have enough precision to             * actually store the difference, so we need to check if it's a float             * and hence auto-converted...             */            throw new \RangeException(                'The supplied range is too great to generate'            );        }        $bits  = $this->countBits($range) + 1;        $bytes = (int) max(ceil($bits / 8), 1);        if ($bits == 63) {            /**             * Fixes issue #22             *             * @see https://github.com/ircmaxell/RandomLib/issues/22             */            $mask = 0x7fffffffffffffff;        } else {            $mask = (int) (pow(2, $bits) - 1);        }        /**         * The mask is a better way of dropping unused bits.  Basically what it does         * is to set all the bits in the mask to 1 that we may need.  Since the max         * range is PHP_INT_MAX, we will never need negative numbers (which would         * have the MSB set on the max int possible to generate).  Therefore we         * can just mask that away.  Since pow returns a float, we need to cast         * it back to an int so the mask will work.         *         * On a 64 bit platform, that means that PHP_INT_MAX is 2^63 - 1.  Which         * is also the mask if 63 bits are needed (by the log(range, 2) call).         * So if the computed result is negative (meaning the 64th bit is set), the         * mask will correct that.         *         * This turns out to be slightly better than the shift as we don't need to         * worry about ""fixing"" negative values.         */        do {            $test   = $this->generate($bytes);            $result = hexdec(bin2hex($test)) & $mask;        } while ($result > $range);        return $result + $min;    }    /**     * Generate a random string of specified length.     *     * This uses the supplied character list for generating the new result     * string.     *     * @param int   $length     The length of the generated string     * @param mixed $characters String: An optional list of characters to use     *                          Integer: Character flags     *     * @return string The generated random string     */    public function generateString($length, $characters = '')    {        if (is_int($characters)) {            // Combine character sets            $characters = $this->expandCharacterSets($characters);        }        if ($length == 0 || strlen($characters) == 1) {            return '';        } elseif (empty($characters)) {            // Default to base 64            $characters = $this->expandCharacterSets(self::CHAR_BASE64);        }        // determine how many bytes to generate        // This is basically doing floor(log(strlen($characters)))        // But it's fixed to work properly for all numbers        $len   = strlen($characters);        // The max call here fixes an issue where we under-generate in cases        // where less than 8 bits are needed to represent $len        $bytes = $length * ceil(($this->countBits($len)) / 8);        // determine mask for valid characters        $mask   = 256 - (256 % $len);        $result = '';        do {            $rand = $this->generate($bytes);            for ($i = 0; $i < $bytes; $i++) {                if (ord($rand[$i]) >= $mask) {                    continue;                }                $result .= $characters[ord($rand[$i]) % $len];            }        } while (strlen($result) < $length);        // We may over-generate, since we always use the entire buffer        return substr($result, 0, $length);    }    /**     * Get the Mixer used for this instance     *     * @return Mixer the current mixer     */    public function getMixer()    {        return $this->mixer;    }    /**     * Get the Sources used for this instance     *     * @return Source[] the current mixer     */    public function getSources()    {        return $this->sources;    }    /**     * Count the minimum number of bits to represent the provided number     *     * This is basically floor(log($number, 2))     * But avoids float precision issues     *     * @param int $number The number to count     *     * @return int The number of bits     */    protected function countBits($number)    {        $log2 = 0;        while ($number >>= 1) {            $log2++;        }        return $log2;    }    /**     * Expand a character set bitwise spec into a string character set     *     * This will also replace EASY_TO_READ characters if the flag is set     *     * @param int $spec The spec to expand (bitwise combination of flags)     *     * @return string The expanded string     */    protected function expandCharacterSets($spec)    {        $combined = '';        if ($spec == self::EASY_TO_READ) {            $spec |= self::CHAR_ALNUM;        }        foreach ($this->charArrays as $flag => $chars) {            if ($flag == self::EASY_TO_READ) {                // handle this later                continue;            }            if (($spec & $flag) === $flag) {                $combined .= $chars;            }        }        if ($spec & self::EASY_TO_READ) {            // remove ambiguous characters            $combined = str_replace(str_split(self::AMBIGUOUS_CHARS), '', $combined);        }        return count_chars($combined, 3);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_Generator_654, Generate a random number (string) of the requested size\n\n @param int $size The size of the requested random number\n\n @return string The generated random number (string)\n,Generiši string nasumičnog broja tražene veličine.,    public function generate($size)    {        $seeds = array();        foreach ($this->sources as $source) {            $seeds[] = $source->generate($size);        }        return $this->mixer->mix($seeds);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_Source_664," Generate a random string of the specified size\n\n Note: If the source fails to generate enough data, the result must be\n padded to the requested length.\n\n @param int $size The size of the requested random string\n\n @return string A string of the requested size\n","Generiši nasumičan string tražene veličine. Napomena: Ako izvor ne uspe da generiše dovoljno podataka, rezultat će biti dopunjen do tražene dužine.",    public function generate($size);,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_CAPICOM_680, The Capicom Random Number Source\n\n This uses the Windows CapiCom Com object to generate random numbers\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,Capicom generator nasumičnih brojeva. Koristi Windows CapiCom Com objekat da generiše nasumične brojeve.,"class CAPICOM extends \RandomLib\AbstractSource{    /**     * Return an instance of Strength indicating the strength of the source     *     * @return \SecurityLib\Strength An instance of one of the strength classes     */    public static function getStrength()    {        return new Strength(Strength::MEDIUM);    }    /**     * If the source is currently available.     * Reasons might be because the library is not installed     *     * @return bool     */    public static function isSupported()    {        return class_exists('\\COM', false);    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        try {            $util = new \COM('CAPICOM.Utilities.1');            $data = base64_decode($util->GetRandom($size, 0));            return str_pad($data, $size, chr(0));        } catch (\Exception $e) {            unset($e);            return static::emptyValue($size);        }    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_MicroTime_687, The Microtime Random Number Source\n\n This uses the current micro-second (looped several times) for a  random number source.  This is only useful when combined with several other\n stronger sources\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,Microtime generator nasumičnih brojeva. Koristi trenutno vreme u mikrosekundama kao izvor nasumičnih brojeva. Ovo je jedino korisno kada se kombinuje sa više drugih jačih izvora.,"final class MicroTime extends \RandomLib\AbstractSource{    /**     * A static counter to ensure unique hashes and prevent state collisions     *     * @var int A counter     */    private static $counter = null;    /**     * The current state of the random number generator.     *     * @var string The state of the PRNG     */    private static $state = '';    public function __construct()    {        $state = self::$state;        if (function_exists('posix_times')) {            $state .= serialize(posix_times());        }        if (!defined('HHVM_VERSION') && function_exists('zend_thread_id')) {            $state .= zend_thread_id();        }        if (function_exists('hphp_get_thread_id')) {            $state .= hphp_get_thread_id();        }        $state      .= getmypid() . memory_get_usage();        $state      .= serialize($_ENV);        $state      .= serialize($_SERVER);        $state      .= count(debug_backtrace(false));        self::$state = hash('sha512', $state, true);        if (is_null(self::$counter)) {            list(, self::$counter) = unpack(""i"", Util::safeSubstr(self::$state, 0, 4));            $seed = $this->generate(Util::safeStrlen(dechex(PHP_INT_MAX)));            list(, self::$counter) = unpack(""i"", $seed);        }    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        $result      = '';        $seed        = microtime() . memory_get_usage();        self::$state = hash('sha512', self::$state . $seed, true);        /**         * Make the generated randomness a bit better by forcing a GC run which         * should complete in a indeterminate amount of time, hence improving         * the strength of the randomness a bit. It's still not crypto-safe,         * but at least it's more difficult to predict.         */        gc_collect_cycles();        for ($i = 0; $i < $size; $i += 8) {            $seed = self::$state .                    microtime() .                    pack('Ni', $i, self::counter());            self::$state = hash('sha512', $seed, true);            /**             * We only use the first 8 bytes here to prevent exposing the state             * in its entirety, which could potentially expose other random             * generations in the future (in the same process)...             */            $result .= Util::safeSubstr(self::$state, 0, 8);        }        return Util::safeSubstr($result, 0, $size);    }    private static function counter()    {        if (self::$counter >= PHP_INT_MAX) {            self::$counter = -1 * PHP_INT_MAX - 1;        } else {            self::$counter++;        }        return self::$counter;    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_OpenSSL_689, The OpenSSL Random Number Source\n\n This uses the OS's secure generator to generate high strength numbers\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,OpenSSL generator nasumičnih brojeva. Koristi bezbedan generator operativnog sistema da generiše jake brojeve.,"class OpenSSL extends \RandomLib\AbstractSource{    /**     * Return an instance of Strength indicating the strength of the source     *     * @return \SecurityLib\Strength An instance of one of the strength classes     */    public static function getStrength()    {        /**         * Prior to PHP 5.6.12 (see https://bugs.php.net/bug.php?id=70014) the ""openssl_random_pseudo_bytes""         * was using ""RAND_pseudo_bytes"" (predictable) instead of ""RAND_bytes"" (unpredictable).         * Release notes: http://php.net/ChangeLog-5.php#5.6.12         */        if (PHP_VERSION_ID >= 50612) {            return new Strength(Strength::HIGH);        }                /**         * Prior to PHP 5.5.28 (see https://bugs.php.net/bug.php?id=70014) the ""openssl_random_pseudo_bytes""         * was using ""RAND_pseudo_bytes"" (predictable) instead of ""RAND_bytes"" (unpredictable).         * Release notes: http://php.net/ChangeLog-5.php#5.5.28         */        if (PHP_VERSION_ID >= 50528 && PHP_VERSION_ID < 50600) {            return new Strength(Strength::HIGH);        }                /**         * Prior to PHP 5.4.44 (see https://bugs.php.net/bug.php?id=70014) the ""openssl_random_pseudo_bytes""         * was using ""RAND_pseudo_bytes"" (predictable) instead of ""RAND_bytes"" (unpredictable).         * Release notes: http://php.net/ChangeLog-5.php#5.4.44         */        if (PHP_VERSION_ID >= 50444 && PHP_VERSION_ID < 50500) {            return new Strength(Strength::HIGH);        }                return new Strength(Strength::MEDIUM);    }    /**     * If the source is currently available.     * Reasons might be because the library is not installed     *     * @return bool     */    public static function isSupported()    {        return function_exists('openssl_random_pseudo_bytes');    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        if ($size < 1) {            return str_repeat(chr(0), $size);        }        /**         * Note, normally we would check the return of of $crypto_strong to         * ensure that we generated a good random string.  However, since we're         * using this as one part of many sources a low strength random number         * shouldn't be much of an issue.         */        return openssl_random_pseudo_bytes($size);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_Rand_693, The Rand Random Number Source\n\n This source generates low strength random numbers by using the internal\n rand() function.  By itself it is quite weak.  However when combined with\n other sources it does provide significant benefit.\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,"Rand izvor nasumičnih brojeva. Ovaj izvor generiše nasumične brojeve slabe snage koristeći unutrašnju rand funkciju. Sam po sebi je dosta slab, ali kada se kombinuje sa drugim izvorima donosi dosta prednosti.",class Rand extends \RandomLib\AbstractSource{    /**     * Return an instance of Strength indicating the strength of the source     *     * @return \SecurityLib\Strength An instance of one of the strength classes     */    public static function getStrength()    {        // Detect if Suhosin Hardened PHP patch is applied        if (defined('S_ALL')) {            return new Strength(Strength::LOW);        } else {            return new Strength(Strength::VERYLOW);        }    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        $result = '';        for ($i = 0; $i < $size; $i++) {            $result .= chr((rand() ^ rand()) % 256);        }        return $result;    }},0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_RandomBytes_699, If the source is currently available.\n Reasons might be because the library is not installed\n\n @return bool\n,Proverava da li je izvor dostupan. Razlozi mogu biti da neka biblioteka nije instalirana.,    public static function isSupported()    {        return function_exists('random_bytes');    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ircmaxell_RandomLib_UniqID_710, The UniqID Random Number Source\n\n This uses the internal `uniqid()` function to generate low strength random\n numbers.\n\n @category   PHPCryptLib\n @package    Random\n @subpackage Source\n\n @author     Anthony Ferrara <ircmaxell@ircmaxell.com>\n @codeCoverageIgnore\n,UniqID izvor nasumičnih brojeva. Koristi unutrašnju uniqid() funkciju da generiše slabe nasumične brojeve.,"class UniqID extends \RandomLib\AbstractSource{    /**     * Return an instance of Strength indicating the strength of the source     *     * @return \SecurityLib\Strength An instance of one of the strength classes     */    public static function getStrength()    {        return new Strength(Strength::LOW);    }    /**     * Generate a random string of the specified size     *     * @param int $size The size of the requested random string     *     * @return string A string of the requested size     */    public function generate($size)    {        $result = '';        while (Util::safeStrlen($result) < $size) {            $result = uniqid($result, true);        }        return Util::safeSubstr($result, 0, $size);    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
denissimon_prediction-builder_PredictionBuilder_739, Reads the data from a given array\n \n @param array $data\n\n @throws \\InvalidArgumentException\n,Čita podatke iz datog niza.,    public function readFromArray(array $data) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
denissimon_prediction-builder_PredictionBuilder_743, Sum of the vector values\n \n @param array $vector\n\n @return number\n,Suma vrednosti vektora.,    private function sum(array $vector) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
denissimon_prediction-builder_PredictionBuilder_744, Sum of the vector squared values\n\n @param array $vector\n\n @return number\n,Suma kvadrata vrednosti vektora.,    private function sumSquared(array $vector) {,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
denissimon_prediction-builder_PredictionBuilder_750, Creats a linear model that fits the data.\n The resulting equation has the form: h(x) = a + bx\n\n @param float $a\n @param float $b\n\n @return \\Closure\n,Pravi linearni model koji odgovara podacima. Rezultujuća jednačina ima formu h(x)=a+bx.,"    private function createModel($a, $b) {        return function($x) use ($a, $b) {             return $a + $b*$x;        };",0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
denissimon_prediction-builder_PredictionBuilder_752," Builds a prediction of the expected value of y for a given x, based on a linear regression model.\n\n @return \\stdClass\n\n @throws \\InvalidArgumentException\n",Pravi predviđanje očekivane vrednosti y za dato x zasnovano na modelu linearne regresije.,    public function build() {,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_DBSCAN_760, Return the string representation of the object.\n\n @return string\n,Vraća tekstualnu reprezentaciju objekta u vidu stringa.,    public function __toString() : string    {        return 'DBSCAN (' . Params::stringify($this->params()) . ')';    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_FuzzyCMeans_766, Has the learner been trained?\n\n @return bool\n,Da li je učenik obučen?,    public function trained() : bool    {        return !empty($this->centroids);    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_FuzzyCMeans_767, Return the computed cluster centroids of the training data.\n\n @return array[]\n,Vraća izračunate centroide klastera podataka za obučavanje.,    public function centroids() : array    {        return $this->centroids;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_FuzzyCMeans_769, Return the loss for each epoch from the last training session.\n\n @return float[]|null\n,Vraća gubitak svake epohe iz prethodne obučavajuće sesije.,    public function losses() : ?array    {        return $this->losses;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_FuzzyCMeans_770, Train the learner with a dataset.\n\n @param \\Rubix\\ML\\Datasets\\Dataset $dataset\n,Obuči učenika pomoću skupa podataka.,"public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),        ])->check();        if ($this->logger) {            $this->logger->info(""$this initialized"");        }        $this->centroids = $this->seeder->seed($dataset, $this->c);        $this->losses = [];        $features = $dataset->features();        $prevLoss = INF;        for ($epoch = 1; $epoch <= $this->epochs; ++$epoch) {            $memberships = array_map([$this, 'probaSample'], $dataset->samples());            $loss = $this->inertia($dataset->samples(), $memberships);            if (is_nan($loss)) {                if ($this->logger) {                    $this->logger->info('Numerical instability detected');                }                break;            }            $loss /= $dataset->numSamples();            $this->losses[$epoch] = $loss;            if ($this->logger) {                $this->logger->info(""Epoch $epoch - Inertia: $loss"");            }            foreach ($this->centroids as $cluster => &$centroid) {                $means = [];                foreach ($features as $column => $values) {                    $sigma = $total = 0.0;                    foreach ($memberships as $i => $probabilities) {                        $weight = $probabilities[$cluster] ** $this->fuzz;                        $sigma += $weight * $values[$i];                        $total += $weight;                    }                    $means[] = $sigma / $total;                }                $centroid = $means;            }            if ($loss <= 0.0) {                break;            }            if (abs($prevLoss - $loss) < $this->minChange) {                break;            }            $prevLoss = $loss;        }        if ($this->logger) {            $this->logger->info('Training complete');        }    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_FuzzyCMeans_772, Predict a single sample and return the result.\n\n @internal\n\n @param (int|float)[] $sample\n @return int\n,Predvidi jedan uzorak i vrati rezultat.,    public function predictSample(array $sample) : int    {        return argmax($this->probaSample($sample));    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_FuzzyCMeans_773, Estimate the joint probabilities for each possible outcome.\n\n @param \\Rubix\\ML\\Datasets\\Dataset $dataset\n @throws \\Rubix\\ML\\Exceptions\\RuntimeException\n @return list<float[]>\n,Proceni združene verovatnoće za svaki mogući rezultat.,"    public function proba(Dataset $dataset) : array    {        if (empty($this->centroids)) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'probaSample'], $dataset->samples());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_KMeans_798,K Means\n\n A fast online centroid-based hard clustering algorithm capable of grouping linearly\n separable data points given some prior knowledge of the target number of clusters\n (defined by  minimizes the inertia cost function. Inertia is defined as the average sum of distances\n between each sample and its nearest cluster centroid.\n\n References:\n [1] D. Sculley. (2010). Web-Scale K-Means Clustering.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n,K means. Brzi online algoritam za klastering zasnovan na centroidima sposoban da grupiše linearno separabilne uzorke za dato prethodno znanje o ciljanom broju klastera. Definisan je funkcijom inercije. Inercija se definiše kao prosečna suma udaljenost između svakog uzorka i njegovog najbližeg centroida grupe.,"class KMeans implements Estimator, Learner, Online, Probabilistic, Verbose, Persistable{    use AutotrackRevisions, LoggerAware;    /**     * The target number of clusters.     *     * @var int     */    protected int $k;    /**     * The size of each mini batch in samples.     *     * @var int     */    protected int $batchSize;    /**     * The maximum number of iterations to run until the algorithm terminates.     *     * @var int     */    protected int $epochs;    /**     * The minimum change in the inertia for training to continue.     *     * @var float     */    protected float $minChange;    /**     * The number of epochs without improvement in the training loss to wait before considering an early stop.     *     * @var int     */    protected int $window;    /**     * The distance function to use when computing the distances.     *     * @var \Rubix\ML\Kernels\Distance\Distance     */    protected \Rubix\ML\Kernels\Distance\Distance $kernel;    /**     * The cluster centroid seeder.     *     * @var \Rubix\ML\Clusterers\Seeders\Seeder     */    protected \Rubix\ML\Clusterers\Seeders\Seeder $seeder;    /**     * The computed centroid vectors of the training data.     *     * @var array[]     */    protected array $centroids = [        //    ];    /**     * The number of training samples contained within each cluster centroid.     *     * @var int[]     */    protected array $sizes = [        //    ];    /**     * The loss at each epoch from the last training session.     *     * @var float[]|null     */    protected ?array $losses = null;    /**     * @param int $k     * @param int $batchSize     * @param int $epochs     * @param float $minChange     * @param int $window     * @param \Rubix\ML\Kernels\Distance\Distance|null $kernel     * @param \Rubix\ML\Clusterers\Seeders\Seeder|null $seeder     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(        int $k,        int $batchSize = 128,        int $epochs = 1000,        float $minChange = 1e-4,        int $window = 5,        ?Distance $kernel = null,        ?Seeder $seeder = null    ) {        if ($k < 1) {            throw new InvalidArgumentException('K must be greater'                . "" than 0, $k given."");        }        if ($batchSize < 1) {            throw new InvalidArgumentException('Batch size must be'                . "" greater than 0, $batchSize given."");        }        if ($epochs < 1) {            throw new InvalidArgumentException('Number of epochs'                . "" must be greater than 0, $epochs given."");        }        if ($minChange < 0.0) {            throw new InvalidArgumentException('Minimum change must be'                . "" greater than 0, $minChange given."");        }        if ($window < 1) {            throw new InvalidArgumentException('Window must be'                . "" greater than 0, $window given."");        }        $this->k = $k;        $this->batchSize = $batchSize;        $this->epochs = $epochs;        $this->minChange = $minChange;        $this->window = $window;        $this->kernel = $kernel ?? new Euclidean();        $this->seeder = $seeder ?? new PlusPlus($kernel);    }    /**     * Return the estimator type.     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::clusterer();    }    /**     * Return the data types that the estimator is compatible with.     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @return mixed[]     */    public function params() : array    {        return [            'k' => $this->k,            'batch size' => $this->batchSize,            'epochs' => $this->epochs,            'min change' => $this->minChange,            'window' => $this->window,            'kernel' => $this->kernel,            'seeder' => $this->seeder,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return !empty($this->centroids);    }    /**     * Return the computed cluster centroids of the training data.     *     * @return array[]     */    public function centroids() : array    {        return $this->centroids;    }    /**     * Return the number of training samples each centroid is responsible for.     *     * @return int[]     */    public function sizes() : array    {        return $this->sizes;    }    /**     * Return an iterable progress table with the steps from the last training session.     *     * @return \Generator<mixed[]>     */    public function steps() : Generator    {        if (!$this->losses) {            return;        }        foreach ($this->losses as $epoch => $loss) {            yield [                'epoch' => $epoch,                'loss' => $loss,            ];        }    }    /**     * Return the loss for each epoch from the last training session.     *     * @return float[]|null     */    public function losses() : ?array    {        return $this->losses;    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     */    public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),        ])->check();        $this->centroids = $this->seeder->seed($dataset, $this->k);        $sizes = array_fill(0, $this->k, 0);        $sizes[0] = $dataset->numSamples();        $this->sizes = $sizes;        $this->partial($dataset);    }    /**     * Perform a partial train on the learner.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     */    public function partial(Dataset $dataset) : void    {        if (empty($this->centroids) or empty($this->sizes)) {            $this->train($dataset);            return;        }        SpecificationChain::with([            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new DatasetHasDimensionality($dataset, count(current($this->centroids))),        ])->check();        if ($this->logger) {            $this->logger->info(""$this initialized"");        }        $labels = array_fill(0, $dataset->numSamples(), 0);        $dataset = Labeled::quick($dataset->samples(), $labels);        $prevLoss = $bestLoss = INF;        $delta = 0;        $this->losses = [];        for ($epoch = 1; $epoch <= $this->epochs; ++$epoch) {            $batches = $dataset->randomize()->batch($this->batchSize);            $loss = 0.0;            foreach ($batches as $i => &$batch) {                $assignments = array_map([$this, 'predictSample'], $batch->samples());                $labels = $batch->labels();                foreach ($assignments as $j => $cluster) {                    $expected = $labels[$j];                    if ($cluster !== $expected) {                        $labels[$j] = $cluster;                        --$this->sizes[$expected];                        ++$this->sizes[$cluster];                    }                }                $batch = Labeled::quick($batch->samples(), $labels);                $loss += $this->inertia($batch->samples(), $labels);                if (is_nan($loss)) {                    if ($this->logger) {                        $this->logger->info('Numerical instability detected');                    }                    break;                }                foreach ($batch->stratify() as $cluster => $stratum) {                    $centroid = &$this->centroids[$cluster];                    $means = array_map([Stats::class, 'mean'], $stratum->features());                    $weight = 1.0 / (1 + $this->sizes[$cluster]);                    foreach ($centroid as $i => &$mean) {                        $mean = (1.0 - $weight) * $mean + $weight * $means[$i];                    }                }            }            $loss /= $dataset->numSamples();            $this->losses[$epoch] = $loss;            if ($this->logger) {                $this->logger->info(""Epoch $epoch - Inertia: $loss"");            }            if ($loss <= 0.0) {                break;            }            if (abs($prevLoss - $loss) < $this->minChange) {                break;            }            if ($loss < $bestLoss) {                $bestLoss = $loss;                $delta = 0;            } else {                ++$delta;            }            if ($delta >= $this->window) {                break;            }            $dataset = Labeled::stack($batches);            $prevLoss = $loss;        }        if ($this->logger) {            $this->logger->info('Training complete');        }    }    /**     * Cluster the dataset by assigning a label to each sample.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int>     */    public function predict(Dataset $dataset) : array    {        if (!$this->centroids) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }    /**     * Label a given sample based on its distance from a particular centroid.     *     * @internal     *     * @param list<int|float> $sample     * @return int     */    public function predictSample(array $sample) : int    {        $bestDistance = INF;        $bestCluster = -1;        foreach ($this->centroids as $cluster => $centroid) {            $distance = $this->kernel->compute($sample, $centroid);            if ($distance < $bestDistance) {                $bestDistance = $distance;                $bestCluster = $cluster;            }        }        return (int) $bestCluster;    }    /**     * Estimate the joint probabilities for each possible outcome.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<float[]>     */    public function proba(Dataset $dataset) : array    {        if (!$this->centroids) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'probaSample'], $dataset->samples());    }    /**     * Return the membership of a sample to each of the k centroids.     *     * @internal     *     * @param list<int|float> $sample     * @return float[]     */    public function probaSample(array $sample) : array    {        $distances = $dist = [];        foreach ($this->centroids as $centroid) {            $distances[] = $this->kernel->compute($sample, $centroid) ?: EPSILON;        }        foreach ($distances as $distanceA) {            $sigma = 0.0;            foreach ($distances as $distanceB) {                $sigma += $distanceA / $distanceB;            }            $dist[] = 1.0 / $sigma;        }        return $dist;    }    /**     * Calculate the average sum of distances between all samples and their closest     * centroid.     *     * @param list<list<int|float>> $samples     * @param list<int> $labels     * @return float     */    protected function inertia(array $samples, array $labels) : float    {        $inertia = 0.0;        foreach ($samples as $i => $sample) {            $centroid = $this->centroids[$labels[$i]];            $inertia += $this->kernel->compute($sample, $centroid);        }        return $inertia;    }    /**     * Return an associative array containing the data used to serialize the object.     *     * @return mixed[]     */    public function __serialize() : array    {        $properties = get_object_vars($this);        unset($properties['losses']);        return $properties;    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'K Means (' . Params::stringify($this->params()) . ')';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_KMeans_805, Return the number of training samples each centroid is responsible for.\n\n @return int[]\n,Vraća broj obučavajućih uzoraka za koje je svaki centroid zadužen.,    public function sizes() : array    {        return $this->sizes;    },0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_KMeans_810, Cluster the dataset by assigning a label to each sample.\n\n @param \\Rubix\\ML\\Datasets\\Dataset $dataset\n @throws \\Rubix\\ML\\Exceptions\\RuntimeException\n @return list<int>\n,Grupiši skup podataka dodeljivanjem labele svakom uzorku.,"    public function predict(Dataset $dataset) : array    {        if (!$this->centroids) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_KMeans_811, Label a given sample based on its distance from a particular centroid.\n\n @internal\n\n @param list<int|float> $sample\n @return int\n,Označi zadati uzorak u zavisnosti od udaljenosti od određenog centroida.,"public function predictSample(array $sample) : int    {        $bestDistance = INF;        $bestCluster = -1;        foreach ($this->centroids as $cluster => $centroid) {            $distance = $this->kernel->compute($sample, $centroid);            if ($distance < $bestDistance) {                $bestDistance = $distance;                $bestCluster = $cluster;            }        }        return (int) $bestCluster;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_KMeans_813, Return the membership of a sample to each of the k centroids.\n\n @internal\n\n @param list<int|float> $sample\n @return float[]\n,Vrati pripadnost uzorka svakog od k centroida.,"public function probaSample(array $sample) : array    {        $distances = $dist = [];        foreach ($this->centroids as $centroid) {            $distances[] = $this->kernel->compute($sample, $centroid) ?: EPSILON;        }        foreach ($distances as $distanceA) {            $sigma = 0.0;            foreach ($distances as $distanceB) {                $sigma += $distanceA / $distanceB;            }            $dist[] = 1.0 / $sigma;        }        return $dist;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_MeanShift_817,Mean Shift\n\n A hierarchical clustering algorithm that uses peak finding to locate the candidate centroids of a\n training set given a radius constraint. Near-duplicate candidates are merged together in a final\n post-processing step.\n\n References:\n [1] M. A. Carreira-Perpinan et al. (2015). A Review of Mean-shift Algorithms for Clustering.\n [2] D. Comaniciu et al. (2012). Mean Shift: A Robust Approach Toward Feature Space Analysis.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n,Mean Shift. Hijerarhijski algoritam za klasterizaciju koji koristi pronalazak vrhova da locira kandidate centroida obučavajućeg skopa za zadato ograničenje prečnika. Bliski centroidi su združeni u finalnom koraku.,"class MeanShift implements Estimator, Learner, Probabilistic, Verbose, Persistable{    use AutotrackRevisions, LoggerAware;    /**     * The minimum number of initial centroids.     *     * @var int     */    protected const MIN_SEEDS = 20;    /**     * The maximum distance between two points to be considered neighbors.     *     * @var float     */    protected float $radius;    /**     * The precomputed denominator of the weight calculation.     *     * @var float     */    protected float $delta;    /**     * The ratio of samples from the training set to use as initial centroids.     *     * @var float     */    protected float $ratio;    /**     * The maximum number of iterations to run until the algorithm terminates.     *     * @var int     */    protected int $epochs;    /**     * The minimum shift in the position of the centroids necessary to continue training.     *     * @var float     */    protected float $minShift;    /**     * The spatial tree used to run range searches.     *     * @var \Rubix\ML\Graph\Trees\Spatial     */    protected \Rubix\ML\Graph\Trees\Spatial $tree;    /**     * The cluster centroid seeder.     *     * @var \Rubix\ML\Clusterers\Seeders\Seeder     */    protected \Rubix\ML\Clusterers\Seeders\Seeder $seeder;    /**     * The computed centroid vectors of the training data.     *     * @var array[]     */    protected array $centroids = [        //    ];    /**     * The loss at each epoch from the last training session.     *     * @var float[]|null     */    protected ?array $losses = null;    /**     * Estimate the radius of a cluster that encompasses a certain percentage of     * the training samples.     *     * > **Note**: Since radius estimation scales quadratically in the number of     * samples, for large datasets you can speed up the process by running it on     * a smaller subset of the training data.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @param float $percentile     * @param \Rubix\ML\Kernels\Distance\Distance|null $kernel     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     * @return float     */    public static function estimateRadius(        Dataset $dataset,        float $percentile = 30.0,        ?Distance $kernel = null    ) : float {        if ($percentile < 0.0 or $percentile > 100.0) {            throw new InvalidArgumentException('Percentile must be'                . "" between 0 and 100, $percentile given."");        }        $kernel = $kernel ?? new Euclidean();        $samples = $dataset->samples();        $distances = [];        foreach ($samples as $i => $sampleA) {            foreach ($samples as $j => $sampleB) {                if ($i !== $j) {                    $distances[] = $kernel->compute($sampleA, $sampleB);                }            }        }        return Stats::quantile($distances, $percentile / 100.0);    }    /**     * @param float $radius     * @param float $ratio     * @param int $epochs     * @param float $minShift     * @param \Rubix\ML\Graph\Trees\Spatial|null $tree     * @param \Rubix\ML\Clusterers\Seeders\Seeder|null $seeder     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(        float $radius,        float $ratio = 0.1,        int $epochs = 100,        float $minShift = 1e-4,        ?Spatial $tree = null,        ?Seeder $seeder = null    ) {        if ($radius <= 0.0) {            throw new InvalidArgumentException('Radius must be'                . "" greater than 0, $radius given."");        }        if ($ratio <= 0.0 or $ratio > 1.0) {            throw new InvalidArgumentException('Ratio must be'                . "" between 0 and 1, $ratio given."");        }        if ($epochs < 1) {            throw new InvalidArgumentException('Number of epochs'                . "" must be greater than 0, $epochs given."");        }        if ($minShift < 0.0) {            throw new InvalidArgumentException('Minimum shift must be'                . "" greater than 0, $minShift given."");        }        $this->radius = $radius;        $this->delta = 2.0 * $radius ** 2;        $this->ratio = $ratio;        $this->epochs = $epochs;        $this->minShift = $minShift;        $this->tree = $tree ?? new BallTree();        $this->seeder = $seeder ?? new Random();    }    /**     * Return the estimator type.     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::clusterer();    }    /**     * Return the data types that the estimator is compatible with.     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @return mixed[]     */    public function params() : array    {        return [            'radius' => $this->radius,            'ratio' => $this->ratio,            'epochs' => $this->epochs,            'min shift' => $this->minShift,            'tree' => $this->tree,            'seeder' => $this->seeder,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return !empty($this->centroids);    }    /**     * Return the computed cluster centroids of the training data.     *     * @return array[]     */    public function centroids() : array    {        return $this->centroids;    }    /**     * Return an iterable progress table with the steps from the last training session.     *     * @return \Generator<mixed[]>     */    public function steps() : Generator    {        if (!$this->losses) {            return;        }        foreach ($this->losses as $epoch => $loss) {            yield [                'epoch' => $epoch,                'loss' => $loss,            ];        }    }    /**     * Return the amount of centroid shift at each epoch of training.     *     * @return float[]|null     */    public function losses() : ?array    {        return $this->losses;    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     */    public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),        ])->check();        if ($this->logger) {            $this->logger->info(""$this initialized"");        }        $n = $dataset->numSamples();        $labels = range(0, $n - 1);        $dataset = Labeled::quick($dataset->samples(), $labels);        $k = max(self::MIN_SEEDS, (int) round($this->ratio * $n));        $centroids = $this->seeder->seed($dataset, $k);        $this->tree->grow($dataset);        $this->losses = [];        $previous = $centroids;        for ($epoch = 1; $epoch <= $this->epochs; ++$epoch) {            foreach ($centroids as $i => &$centroidA) {                [$samples, $indices, $distances] = $this->tree->range($centroidA, $this->radius);                $means = array_map([Stats::class, 'mean'], array_transpose($samples));                $mu2 = Stats::mean($distances) ** 2;                $weight = exp(-$mu2 / $this->delta);                foreach ($centroidA as $column => &$mean) {                    $mean = ($weight * $means[$column]) / $weight;                }                foreach ($centroids as $j => $centroidB) {                    if ($i !== $j) {                        $distance = $this->tree->kernel()->compute($centroidA, $centroidB);                        if ($distance < $this->radius) {                            unset($centroids[$j]);                        }                    }                }            }            $loss = $this->shift($centroids, $previous);            if (is_nan($loss)) {                if ($this->logger) {                    $this->logger->info('Numerical instability detected');                }                break;            }            $loss /= $n;            $this->losses[$epoch] = $loss;            if ($this->logger) {                $this->logger->info(""Epoch $epoch - loss: $loss"");            }            if ($loss < $this->minShift) {                break;            }            $previous = $centroids;        }        $this->centroids = array_values($centroids);        $this->tree->destroy();        if ($this->logger) {            $this->logger->info('Training complete');        }    }    /**     * Cluster the dataset by assigning a label to each sample.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int>     */    public function predict(Dataset $dataset) : array    {        if (empty($this->centroids)) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }    /**     * Label a given sample based on its distance from a particular centroid.     *     * @internal     *     * @param list<int|float> $sample     * @return int     */    public function predictSample(array $sample) : int    {        $bestDistance = INF;        $bestCluster = -1;        foreach ($this->centroids as $cluster => $centroid) {            $distance = $this->tree->kernel()->compute($sample, $centroid);            if ($distance < $bestDistance) {                $bestDistance = $distance;                $bestCluster = $cluster;            }        }        return (int) $bestCluster;    }    /**     * Estimate the joint probabilities for each possible outcome.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<float[]>     */    public function proba(Dataset $dataset) : array    {        if (empty($this->centroids)) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->centroids)))->check();        return array_map([$this, 'probaSample'], $dataset->samples());    }    /**     * Return the membership of a sample to each of the centroids.     *     * @param list<int|float> $sample     * @return float[]     */    public function probaSample(array $sample) : array    {        $distances = $dist = [];        foreach ($this->centroids as $centroid) {            $distances[] = $this->tree->kernel()->compute($sample, $centroid) ?: EPSILON;        }        foreach ($distances as $distanceA) {            $sigma = 0.0;            foreach ($distances as $distanceB) {                $sigma += $distanceA / $distanceB;            }            $dist[] = 1.0 / $sigma;        }        return $dist;    }    /**     * Calculate the amount of centroid shift from the previous epoch.     *     * @param array[] $current     * @param array[] $previous     * @return float     */    protected function shift(array $current, array $previous) : float    {        $shift = 0.0;        foreach ($current as $cluster => $centroid) {            $prevCentroid = $previous[$cluster];            foreach ($centroid as $column => $mean) {                $shift += abs($prevCentroid[$column] - $mean);            }        }        return $shift;    }    /**     * Return an associative array containing the data used to serialize the object.     *     * @return mixed[]     */    public function __serialize() : array    {        $properties = get_object_vars($this);        unset($properties['losses']);        return $properties;    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'Mean Shift (' . Params::stringify($this->params()) . ')';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_MeanShift_832, Calculate the amount of centroid shift from the previous epoch.\n\n @param array[] $current\n @param array[] $previous\n @return float\n,Izračunaj količinu pomeraja centroida od prethodne epohe.,"protected function shift(array $current, array $previous) : float    {        $shift = 0.0;        foreach ($current as $cluster => $centroid) {            $prevCentroid = $previous[$cluster];            foreach ($centroid as $column => $mean) {                $shift += abs($prevCentroid[$column] - $mean);            }        }        return $shift;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_KMC2_835,K-MC2\n\n A fast Plus Plus approximator that replaces the brute force method with a substantially\n faster Markov Chain Monte Carlo (MCMC) sampling procedure with comparable results.\n\n References:\n [1] O. Bachem et al. (2016). Approximate K-Means++ in Sublinear Time.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n,K-MC2 Brzi plus plus aproksimator koji menja brute force metod značajno bržio MCMC procedurom odabiranja sa uporedivim rezultatima. Aproksimativni K Means algoritam.,"class KMC2 implements Seeder{    /**     * The number of candidate nodes in the Markov Chain.     *     * @var int     */    protected int $m;    /**     * The distance kernel used to compute the distance between samples.     *     * @var \Rubix\ML\Kernels\Distance\Distance     */    protected \Rubix\ML\Kernels\Distance\Distance $kernel;    /**     * @param int $m     * @param \Rubix\ML\Kernels\Distance\Distance|null $kernel     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(int $m = 50, ?Distance $kernel = null)    {        if ($m < 1) {            throw new InvalidArgumentException('M must be greater'                . "" than 0, $m given."");        }        $this->m = $m;        $this->kernel = $kernel ?? new Euclidean();    }    /**     * Seed k cluster centroids from a dataset.     *     * @internal     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @param int $k     * @return list<list<string|int|float>>     */    public function seed(Dataset $dataset, int $k) : array    {        DatasetIsNotEmpty::with($dataset)->check();        $centroids = $dataset->randomSubset(1)->samples();        $max = getrandmax();        while (count($centroids) < $k) {            $candidates = $dataset->randomSubsetWithReplacement($this->m)->samples();            $x = array_pop($candidates) ?? [];            $target = end($centroids) ?: [];            $xDistance = $this->kernel->compute($x, $target) ?: EPSILON;            foreach ($candidates as $candidate) {                $yDistance = $this->kernel->compute($candidate, $target);                $density = min(1.0, $yDistance / $xDistance);                $threshold = rand() / $max;                if ($density > $threshold) {                    $xDistance = $yDistance;                    $x = $candidate;                }            }            $centroids[] = $x;        }        return $centroids;    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return ""KMC2 (m: {$this->m}, kernel: {$this->kernel})"";    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Clusterers_KMC2_836, Seed k cluster centroids from a dataset.\n\n @internal\n\n @param \\Rubix\\ML\\Datasets\\Dataset $dataset\n @param int $k\n @return list<list<string|int|float>>\n,Posej centroide k klastera iz skupa podataka.,"public function seed(Dataset $dataset, int $k) : array    {        DatasetIsNotEmpty::with($dataset)->check();        $centroids = $dataset->randomSubset(1)->samples();        $max = getrandmax();        while (count($centroids) < $k) {            $candidates = $dataset->randomSubsetWithReplacement($this->m)->samples();            $x = array_pop($candidates) ?? [];            $target = end($centroids) ?: [];            $xDistance = $this->kernel->compute($x, $target) ?: EPSILON;            foreach ($candidates as $candidate) {                $yDistance = $this->kernel->compute($candidate, $target);                $density = min(1.0, $yDistance / $xDistance);                $threshold = rand() / $max;                if ($density > $threshold) {                    $xDistance = $yDistance;                    $x = $candidate;                }            }            $centroids[] = $x;        }        return $centroids;    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
V1beta1_ClassificationEvaluationMetrics_ConfusionMatrix_874,Confusion matrix of the model running the classification.\n\n Generated from protobuf message <code>google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix</code>\n,Konfuziona matrica modela koji vrši klasifikaciju. Generiše se od protobuf poruke.,"class ConfusionMatrix extends \Google\Protobuf\Internal\Message{    /**     * Output only. IDs of the annotation specs used in the confusion matrix.     * For Tables CLASSIFICATION     * [prediction_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type]     * only list of [annotation_spec_display_name-s][] is populated.     *     * Generated from protobuf field <code>repeated string annotation_spec_id = 1;</code>     */    private $annotation_spec_id;    /**     * Output only. Display name of the annotation specs used in the confusion     * matrix, as they were at the moment of the evaluation. For Tables     * CLASSIFICATION     * [prediction_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type],     * distinct values of the target column at the moment of the model     * evaluation are populated here.     *     * Generated from protobuf field <code>repeated string display_name = 3;</code>     */    private $display_name;    /**     * Output only. Rows in the confusion matrix. The number of rows is equal to     * the size of `annotation_spec_id`.     * `row[i].example_count[j]` is the number of examples that have ground     * truth of the `annotation_spec_id[i]` and are predicted as     * `annotation_spec_id[j]` by the model being evaluated.     *     * Generated from protobuf field <code>repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row row = 2;</code>     */    private $row;    /**     * Constructor.     *     * @param array $data {     *     Optional. Data for populating the Message object.     *     *     @type string[]|\Google\Protobuf\Internal\RepeatedField $annotation_spec_id     *           Output only. IDs of the annotation specs used in the confusion matrix.     *           For Tables CLASSIFICATION     *           [prediction_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type]     *           only list of [annotation_spec_display_name-s][] is populated.     *     @type string[]|\Google\Protobuf\Internal\RepeatedField $display_name     *           Output only. Display name of the annotation specs used in the confusion     *           matrix, as they were at the moment of the evaluation. For Tables     *           CLASSIFICATION     *           [prediction_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type],     *           distinct values of the target column at the moment of the model     *           evaluation are populated here.     *     @type \Google\Cloud\AutoMl\V1beta1\ClassificationEvaluationMetrics\ConfusionMatrix\Row[]|\Google\Protobuf\Internal\RepeatedField $row     *           Output only. Rows in the confusion matrix. The number of rows is equal to     *           the size of `annotation_spec_id`.     *           `row[i].example_count[j]` is the number of examples that have ground     *           truth of the `annotation_spec_id[i]` and are predicted as     *           `annotation_spec_id[j]` by the model being evaluated.     * }     */    public function __construct($data = NULL) {        \GPBMetadata\Google\Cloud\Automl\V1Beta1\Classification::initOnce();        parent::__construct($data);    }    /**     * Output only. IDs of the annotation specs used in the confusion matrix.     * For Tables CLASSIFICATION     * [prediction_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type]     * only list of [annotation_spec_display_name-s][] is populated.     *     * Generated from protobuf field <code>repeated string annotation_spec_id = 1;</code>     * @return \Google\Protobuf\Internal\RepeatedField     */    public function getAnnotationSpecId()    {        return $this->annotation_spec_id;    }    /**     * Output only. IDs of the annotation specs used in the confusion matrix.     * For Tables CLASSIFICATION     * [prediction_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type]     * only list of [annotation_spec_display_name-s][] is populated.     *     * Generated from protobuf field <code>repeated string annotation_spec_id = 1;</code>     * @param string[]|\Google\Protobuf\Internal\RepeatedField $var     * @return $this     */    public function setAnnotationSpecId($var)    {        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);        $this->annotation_spec_id = $arr;        return $this;    }    /**     * Output only. Display name of the annotation specs used in the confusion     * matrix, as they were at the moment of the evaluation. For Tables     * CLASSIFICATION     * [prediction_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type],     * distinct values of the target column at the moment of the model     * evaluation are populated here.     *     * Generated from protobuf field <code>repeated string display_name = 3;</code>     * @return \Google\Protobuf\Internal\RepeatedField     */    public function getDisplayName()    {        return $this->display_name;    }    /**     * Output only. Display name of the annotation specs used in the confusion     * matrix, as they were at the moment of the evaluation. For Tables     * CLASSIFICATION     * [prediction_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction_type],     * distinct values of the target column at the moment of the model     * evaluation are populated here.     *     * Generated from protobuf field <code>repeated string display_name = 3;</code>     * @param string[]|\Google\Protobuf\Internal\RepeatedField $var     * @return $this     */    public function setDisplayName($var)    {        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);        $this->display_name = $arr;        return $this;    }    /**     * Output only. Rows in the confusion matrix. The number of rows is equal to     * the size of `annotation_spec_id`.     * `row[i].example_count[j]` is the number of examples that have ground     * truth of the `annotation_spec_id[i]` and are predicted as     * `annotation_spec_id[j]` by the model being evaluated.     *     * Generated from protobuf field <code>repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row row = 2;</code>     * @return \Google\Protobuf\Internal\RepeatedField     */    public function getRow()    {        return $this->row;    }    /**     * Output only. Rows in the confusion matrix. The number of rows is equal to     * the size of `annotation_spec_id`.     * `row[i].example_count[j]` is the number of examples that have ground     * truth of the `annotation_spec_id[i]` and are predicted as     * `annotation_spec_id[j]` by the model being evaluated.     *     * Generated from protobuf field <code>repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row row = 2;</code>     * @param \Google\Cloud\AutoMl\V1beta1\ClassificationEvaluationMetrics\ConfusionMatrix\Row[]|\Google\Protobuf\Internal\RepeatedField $var     * @return $this     */    public function setRow($var)    {        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Google\Cloud\AutoMl\V1beta1\ClassificationEvaluationMetrics\ConfusionMatrix\Row::class);        $this->row = $arr;        return $this;    }}",0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Regressors_KNNRegressor_944," KNN Regressor\n\n A version of the K Nearest Neighbors algorithm that uses the average (mean) outcome of\n the  predictions suitable for regression problems.\n\n >  of its computation during inference. For a fast spatial tree-accelerated version, see\n KD Neighbors Regressor.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n",KNN regresor. Verzija algoritma K najbližih suseda koja koristi prosek (srednju vrednost) ishoda predviđanja pogodnih za regresione probleme.,"class KNNRegressor implements Estimator, Learner, Online, Persistable{    use AutotrackRevisions;    /**     * The number of neighbors to consider when making a prediction.     *     * @var int     */    protected int $k;    /**     * Should we consider the distances of our nearest neighbors when making predictions?     *     * @var bool     */    protected bool $weighted;    /**     * The distance kernel to use when computing the distances.     *     * @var \Rubix\ML\Kernels\Distance\Distance     */    protected \Rubix\ML\Kernels\Distance\Distance $kernel;    /**     * The training samples.     *     * @var list<array>     */    protected array $samples = [        //    ];    /**     * The training labels.     *     * @var list<int|float>     */    protected array $labels = [        //    ];    /**     * @param int $k     * @param bool $weighted     * @param \Rubix\ML\Kernels\Distance\Distance|null $kernel     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(int $k = 5, bool $weighted = false, ?Distance $kernel = null)    {        if ($k < 1) {            throw new InvalidArgumentException('At least 1 neighbor is required'                . "" to make a prediction, $k given."");        }        $this->k = $k;        $this->weighted = $weighted;        $this->kernel = $kernel ?? new Euclidean();    }    /**     * Return the estimator type.     *     * @internal     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::regressor();    }    /**     * Return the data types that the estimator is compatible with.     *     * @internal     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return $this->kernel->compatibility();    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @internal     *     * @return mixed[]     */    public function params() : array    {        return [            'k' => $this->k,            'weighted' => $this->weighted,            'kernel' => $this->kernel,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return $this->samples and $this->labels;    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function train(Dataset $dataset) : void    {        $this->samples = $this->labels = [];        $this->partial($dataset);    }    /**     * Perform a partial train on the learner.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function partial(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsLabeled($dataset),            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new LabelsAreCompatibleWithLearner($dataset, $this),        ])->check();        $this->samples = array_merge($this->samples, $dataset->samples());        $this->labels = array_merge($this->labels, $dataset->labels());    }    /**     * Make a prediction based on the nearest neighbors.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int|float>     */    public function predict(Dataset $dataset) : array    {        if (!$this->samples or !$this->labels) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count(current($this->samples)))->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }    /**     * Predict a single sample and return the result.     *     * @internal     *     * @param list<string|int|float> $sample     * @return int|float     */    public function predictSample(array $sample)    {        [$labels, $distances] = $this->nearest($sample);        if ($this->weighted) {            $weights = [];            foreach ($distances as $distance) {                $weights[] = 1.0 / (1.0 + $distance);            }            return Stats::weightedMean(array_values($labels), $weights);        }        return Stats::mean($labels);    }    /**     * Find the K nearest neighbors to the given sample vector using     * the brute force method.     *     * @param (string|int|float)[] $sample     * @return array[]     */    protected function nearest(array $sample) : array    {        $distances = [];        foreach ($this->samples as $neighbor) {            $distances[] = $this->kernel->compute($sample, $neighbor);        }        asort($distances);        $distances = array_slice($distances, 0, $this->k, true);        $labels = array_intersect_key($this->labels, $distances);        return [$labels, $distances];    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'KNN Regressor (' . Params::stringify($this->params()) . ')';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Regressors_KNNRegressor_953, Find the K nearest neighbors to the given sample vector using\n the brute force method.\n\n @param (string|int|float)[] $sample\n @return array[]\n,Naži K najbližih suseda za vektor uzorka koristeći brute force metod.,"protected function nearest(array $sample) : array    {        $distances = [];        foreach ($this->samples as $neighbor) {            $distances[] = $this->kernel->compute($sample, $neighbor);        }        asort($distances);        $distances = array_slice($distances, 0, $this->k, true);        $labels = array_intersect_key($this->labels, $distances);        return [$labels, $distances];    }",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Regressors_MLPRegressor_955,"MLP Regressor\n\n A multilayer feed forward neural network with a continuous output layer suitable for\n regression problems. Like the Multilayer Perceptron classifier, the MLP Regressor is\n able to handle complex non-linear regression problems by forming higher-order\n representations of the input features using intermediate hidden layers.\n\n References:\n [1] G. E. Hinton. (1989). Connectionist learning procedures.\n [2] L. Prechelt. (1997). Early Stopping - but when?\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n","MLP regresor. Višeslojna neuralna mreža sa kontinualnim izlaznim slojem pogodna za regresione probleme. Kao višeslojni perceptronski klasifikator, MLP regresor je sposovan da rešava nelinearne regresione probleme tako što pravi reprezentacije ulaznih obeležja višeg reda pomoću skrivenih slojeva.","class MLPRegressor implements Estimator, Learner, Online, Verbose, Persistable{    use AutotrackRevisions, LoggerAware;    /**     * An array composing the user-specified hidden layers of the network in order.     *     * @var \Rubix\ML\NeuralNet\Layers\Hidden[]     */    protected array $hiddenLayers = [        //    ];    /**     * The number of training samples to process at a time.     *     * @var int     */    protected int $batchSize;    /**     * The gradient descent optimizer used to update the network parameters.     *     * @var \Rubix\ML\NeuralNet\Optimizers\Optimizer     */    protected \Rubix\ML\NeuralNet\Optimizers\Optimizer $optimizer;    /**     * The amount of L2 regularization applied to the weights of the output layer.     *     * @var float     */    protected float $alpha;    /**     * The maximum number of training epochs. i.e. the number of times to iterate     * over the entire training set before terminating.     *     * @var int     */    protected int $epochs;    /**     * The minimum change in the training loss necessary to continue training.     *     * @var float     */    protected float $minChange;    /**     * The number of epochs without improvement in the validation score to wait before considering an early stop.     *     * @var int     */    protected int $window;    /**     * The proportion of training samples to use for validation and progress monitoring.     *     * @var float     */    protected float $holdOut;    /**     * The function that computes the loss associated with an erroneous activation during training.     *     * @var \Rubix\ML\NeuralNet\CostFunctions\RegressionLoss     */    protected \Rubix\ML\NeuralNet\CostFunctions\RegressionLoss $costFn;    /**     * The metric used to score the generalization performance of the model during training.     *     * @var \Rubix\ML\CrossValidation\Metrics\Metric     */    protected \Rubix\ML\CrossValidation\Metrics\Metric $metric;    /**     * The underlying neural network instance.     *     * @var \Rubix\ML\NeuralNet\FeedForward|null     */    protected ?\Rubix\ML\NeuralNet\FeedForward $network = null;    /**     * The validation scores at each epoch from the last training session.     *     * @var float[]|null     */    protected ?array $scores = null;    /**     * The loss at each epoch from the last training session.     *     * @var float[]|null     */    protected ?array $losses = null;    /**     * @param \Rubix\ML\NeuralNet\Layers\Hidden[] $hiddenLayers     * @param int $batchSize     * @param \Rubix\ML\NeuralNet\Optimizers\Optimizer|null $optimizer     * @param float $alpha     * @param int $epochs     * @param float $minChange     * @param int $window     * @param float $holdOut     * @param \Rubix\ML\NeuralNet\CostFunctions\RegressionLoss|null $costFn     * @param \Rubix\ML\CrossValidation\Metrics\Metric|null $metric     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(        array $hiddenLayers = [],        int $batchSize = 128,        ?Optimizer $optimizer = null,        float $alpha = 1e-4,        int $epochs = 1000,        float $minChange = 1e-4,        int $window = 3,        float $holdOut = 0.1,        ?RegressionLoss $costFn = null,        ?Metric $metric = null    ) {        foreach ($hiddenLayers as $layer) {            if (!$layer instanceof Hidden) {                throw new InvalidArgumentException('Hidden layer'                    . ' must implement the Hidden interface.');            }        }        if ($batchSize < 1) {            throw new InvalidArgumentException('Batch size must be'                . "" greater than 0, $batchSize given."");        }        if ($alpha < 0.0) {            throw new InvalidArgumentException('Alpha must be'                . "" greater than 0, $alpha given."");        }        if ($epochs < 1) {            throw new InvalidArgumentException('Number of epochs'                . "" must be greater than 0, $epochs given."");        }        if ($minChange < 0.0) {            throw new InvalidArgumentException('Minimum change must be'                . "" greater than 0, $minChange given."");        }        if ($window < 1) {            throw new InvalidArgumentException('Window must be'                . "" greater than 0, $window given."");        }        if ($holdOut < 0.0 or $holdOut > 0.5) {            throw new InvalidArgumentException('Hold out ratio must be'                . "" between 0 and 0.5, $holdOut given."");        }        if ($metric) {            EstimatorIsCompatibleWithMetric::with($this, $metric)->check();        }        $this->hiddenLayers = $hiddenLayers;        $this->batchSize = $batchSize;        $this->optimizer = $optimizer ?? new Adam();        $this->alpha = $alpha;        $this->epochs = $epochs;        $this->minChange = $minChange;        $this->window = $window;        $this->holdOut = $holdOut;        $this->costFn = $costFn ?? new LeastSquares();        $this->metric = $metric ?? new RMSE();    }    /**     * Return the estimator type.     *     * @internal     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::regressor();    }    /**     * Return the data types that the estimator is compatible with.     *     * @internal     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @internal     *     * @return mixed[]     */    public function params() : array    {        return [            'hidden layers' => $this->hiddenLayers,            'batch size' => $this->batchSize,            'optimizer' => $this->optimizer,            'alpha' => $this->alpha,            'epochs' => $this->epochs,            'min change' => $this->minChange,            'window' => $this->window,            'hold out' => $this->holdOut,            'cost fn' => $this->costFn,            'metric' => $this->metric,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return isset($this->network);    }    /**     * Return an iterable progress table with the steps from the last training session.     *     * @return \Generator<mixed[]>     */    public function steps() : Generator    {        if (!$this->losses) {            return;        }        foreach ($this->losses as $epoch => $loss) {            yield [                'epoch' => $epoch,                'score' => $this->scores[$epoch] ?? null,                'loss' => $loss,            ];        }    }    /**     * Return the validation score at each epoch.     *     * @return float[]|null     */    public function scores() : ?array    {        return $this->scores;    }    /**     * Return the training loss at each epoch.     *     * @return float[]|null     */    public function losses() : ?array    {        return $this->losses;    }    /**     * Return the underlying neural network instance or null if not trained.     *     * @return \Rubix\ML\NeuralNet\FeedForward|null     */    public function network() : ?FeedForward    {        return $this->network;    }    /**     * Train the estimator with a dataset.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function train(Dataset $dataset) : void    {        DatasetIsNotEmpty::with($dataset)->check();        $hiddenLayers = $this->hiddenLayers;        $hiddenLayers[] = new Dense(1, $this->alpha, true, new Xavier2());        $this->network = new FeedForward(            new Placeholder1D($dataset->numFeatures()),            $hiddenLayers,            new Continuous($this->costFn),            $this->optimizer        );        $this->network->initialize();        $this->partial($dataset);    }    /**     * Train the network using mini-batch gradient descent with backpropagation.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     */    public function partial(Dataset $dataset) : void    {        if (!$this->network) {            $this->train($dataset);            return;        }        SpecificationChain::with([            new DatasetIsLabeled($dataset),            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new LabelsAreCompatibleWithLearner($dataset, $this),            new DatasetHasDimensionality($dataset, $this->network->input()->width()),        ])->check();        if ($this->logger) {            $this->logger->info(""$this initialized"");        }        [$testing, $training] = $dataset->randomize()->split($this->holdOut);        [$min, $max] = $this->metric->range()->list();        $bestScore = $min;        $bestEpoch = $delta = 0;        $snapshot = null;        $prevLoss = INF;        $this->scores = $this->losses = [];        for ($epoch = 1; $epoch <= $this->epochs; ++$epoch) {            $batches = $training->randomize()->batch($this->batchSize);            $loss = 0.0;            $score = null;            foreach ($batches as $batch) {                $loss += $this->network->roundtrip($batch);            }            if (is_nan($loss)) {                if ($this->logger) {                    $this->logger->info('Numerical instability detected');                }                break;            }            $loss /= count($batches);            $this->losses[$epoch] = $loss;            if (!$testing->empty()) {                $predictions = $this->predict($testing);                $score = $this->metric->score($predictions, $testing->labels());                $this->scores[$epoch] = $score;            }            if ($this->logger) {                $this->logger->info(""Epoch $epoch - {$this->metric}: ""                    . ($score ?? 'n/a') . "", {$this->costFn}: $loss"");            }            if (isset($score)) {                if ($score >= $max) {                    break;                }                if ($score > $bestScore) {                    $bestScore = $score;                    $bestEpoch = $epoch;                    $snapshot = Snapshot::take($this->network);                    $delta = 0;                } else {                    ++$delta;                }                if ($delta >= $this->window) {                    break;                }            }            if ($loss <= 0.0) {                break;            }            if (abs($prevLoss - $loss) < $this->minChange) {                break;            }            $prevLoss = $loss;        }        if ($snapshot and end($this->scores) < $bestScore) {            $snapshot->restore();            if ($this->logger) {                $this->logger->info(""Network restored from snapshot at epoch $bestEpoch"");            }        }        if ($this->logger) {            $this->logger->info('Training complete');        }    }    /**     * Feed a sample through the network and make a prediction based on the     * activation of the output neuron.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int|float>     */    public function predict(Dataset $dataset) : array    {        if (!$this->network) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, $this->network->input()->width())->check();        $activations = $this->network->infer($dataset);        $activations = array_column($activations->asArray(), 0);        return $activations;    }    /**     * Return an associative array containing the data used to serialize the object.     *     * @return mixed[]     */    public function __serialize() : array    {        $properties = get_object_vars($this);        unset($properties['losses'], $properties['scores']);        return $properties;    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'MLP Regressor (' . Params::stringify($this->params()) . ')';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Regressors_RegressionTree_980,Regression Tree\n\n A decision tree based on the CART ( algorithm that performs greedy splitting by minimizing the variance of the labels\n at each node split.\n\n References:\n [1] W. Y. Loh. (2011). Classification and Regression Trees.\n [2] K. Alsabti. et al. (1998). CLOUDS: A Decision Tree Classifier for Large Datasets.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n,Regresiono stablo. Stablo odlučivanja zasnovano na CART algoritmu koji izvodi pohlepno deljenje minimizacijom varijanse labela na svakom čvoru.,"class RegressionTree extends CART implements Estimator, Learner, RanksFeatures, Persistable{    use AutotrackRevisions;    /**     * @param int $maxHeight     * @param int $maxLeafSize     * @param float $minPurityIncrease     * @param int|null $maxFeatures     */    public function __construct(        int $maxHeight = PHP_INT_MAX,        int $maxLeafSize = 3,        float $minPurityIncrease = 1e-7,        ?int $maxFeatures = null    ) {        parent::__construct($maxHeight, $maxLeafSize, $minPurityIncrease, $maxFeatures);    }    /**     * Return the estimator type.     *     * @internal     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::regressor();    }    /**     * Return the data types that the estimator is compatible with.     *     * @internal     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::categorical(),            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @internal     *     * @return mixed[]     */    public function params() : array    {        return [            'max height' => $this->maxHeight,            'max leaf size' => $this->maxLeafSize,            'max features' => $this->maxFeatures,            'min purity increase' => $this->minPurityIncrease,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return !$this->bare();    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsLabeled($dataset),            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new LabelsAreCompatibleWithLearner($dataset, $this),        ])->check();        $this->grow($dataset);    }    /**     * Make a prediction based on the value of a terminal node in the tree.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int|float>     */    public function predict(Dataset $dataset) : array    {        if ($this->bare() or !$this->featureCount) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, $this->featureCount)->check();        return array_map([$this, 'predictSample'], $dataset->samples());    }    /**     * Predict a single sample and return the result.     *     * @internal     *     * @param list<string|int|float> $sample     * @return int|float     */    public function predictSample(array $sample)    {        /** @var \Rubix\ML\Graph\Nodes\Average $node */        $node = $this->search($sample);        return $node->outcome();    }    /**     * Terminate the branch with the most likely Average.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     * @return \Rubix\ML\Graph\Nodes\Average     */    protected function terminate(Labeled $dataset) : Average    {        [$mean, $variance] = Stats::meanVar($dataset->labels());        return new Average($mean, $variance, $dataset->numSamples());    }    /**     * Calculate the impurity of a set of labels.     *     * @param list<int|float> $labels     * @return float     */    protected function impurity(array $labels) : float    {        return Stats::variance($labels);    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'Regression Tree (' . Params::stringify($this->params()) . ')';    }}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
src_Regressors_Ridge_992,"Ridge\n\n L2 regularized least squares linear model solved using a closed-form solution. The addition\n of regularization, controlled by the  than ordinary linear regression.\n\n @category    Machine Learning\n @package     Rubix/ML\n @author      Andrew DalPino\n",Grebeno regularizovani linearni model zasnovan na metodi najmanjih kvadrata. Osim regularizacije isti kao običan linearni model.,"class Ridge implements Estimator, Learner, RanksFeatures, Persistable{    use AutotrackRevisions;    /**     * The strength of the L2 regularization penalty.     *     * @var float     */    protected float $alpha;    /**     * The y intercept i.e. the bias added to the decision function.     *     * @var float|null     */    protected ?float $bias = null;    /**     * The computed coefficients of the regression line.     *     * @var \Tensor\Vector|null     */    protected ?\Tensor\Vector $coefficients = null;    /**     * @param float $alpha     * @throws \Rubix\ML\Exceptions\InvalidArgumentException     */    public function __construct(float $alpha = 1.0)    {        if ($alpha < 0.0) {            throw new InvalidArgumentException('Alpha must be'                . "" greater than 0, $alpha given."");        }        $this->alpha = $alpha;    }    /**     * Return the estimator type.     *     * @internal     *     * @return \Rubix\ML\EstimatorType     */    public function type() : EstimatorType    {        return EstimatorType::regressor();    }    /**     * Return the data types that the estimator is compatible with.     *     * @internal     *     * @return list<\Rubix\ML\DataType>     */    public function compatibility() : array    {        return [            DataType::continuous(),        ];    }    /**     * Return the settings of the hyper-parameters in an associative array.     *     * @internal     *     * @return mixed[]     */    public function params() : array    {        return [            'alpha' => $this->alpha,        ];    }    /**     * Has the learner been trained?     *     * @return bool     */    public function trained() : bool    {        return $this->coefficients and isset($this->bias);    }    /**     * Return the weights of features in the decision function.     *     * @return (int|float)[]|null     */    public function coefficients() : ?array    {        return $this->coefficients ? $this->coefficients->asArray() : null;    }    /**     * Return the bias added to the decision function.     *     * @return float|null     */    public function bias() : ?float    {        return $this->bias;    }    /**     * Train the learner with a dataset.     *     * @param \Rubix\ML\Datasets\Labeled $dataset     */    public function train(Dataset $dataset) : void    {        SpecificationChain::with([            new DatasetIsLabeled($dataset),            new DatasetIsNotEmpty($dataset),            new SamplesAreCompatibleWithEstimator($dataset, $this),            new LabelsAreCompatibleWithLearner($dataset, $this),        ])->check();        $biases = Matrix::ones($dataset->numSamples(), 1);        $x = Matrix::build($dataset->samples())->augmentLeft($biases);        $y = Vector::build($dataset->labels());        $alphas = array_fill(0, $x->n() - 1, $this->alpha);        array_unshift($alphas, 0.0);        $penalties = Matrix::diagonal($alphas);        $xT = $x->transpose();        $coefficients = $xT->matmul($x)            ->add($penalties)            ->inverse()            ->dot($xT->dot($y))            ->asArray();        $this->bias = (float) array_shift($coefficients);        $this->coefficients = Vector::quick($coefficients);    }    /**     * Make a prediction based on the line calculated from the training data.     *     * @param \Rubix\ML\Datasets\Dataset $dataset     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return list<int|float>     */    public function predict(Dataset $dataset) : array    {        if (!$this->coefficients or is_null($this->bias)) {            throw new RuntimeException('Estimator has not been trained.');        }        DatasetHasDimensionality::with($dataset, count($this->coefficients))->check();        return Matrix::build($dataset->samples())            ->dot($this->coefficients)            ->add($this->bias)            ->asArray();    }    /**     * Return the importance scores of each feature column of the training set.     *     * @throws \Rubix\ML\Exceptions\RuntimeException     * @return float[]     */    public function featureImportances() : array    {        if (is_null($this->coefficients)) {            throw new RuntimeException('Learner has not been trained.');        }        return $this->coefficients->abs()->asArray();    }    /**     * Return the string representation of the object.     *     * @return string     */    public function __toString() : string    {        return 'Ridge (' . Params::stringify($this->params()) . ')';    }}",0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0